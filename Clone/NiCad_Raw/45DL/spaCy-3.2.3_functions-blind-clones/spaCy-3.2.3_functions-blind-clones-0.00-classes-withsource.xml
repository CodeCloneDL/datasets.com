<clones>
<systeminfo processor="nicad6" system="spaCy-3.2.3" granularity="functions-blind" threshold="0%" minlines="10" maxlines="2500"/>
<cloneinfo npcs="1944" npairs="319"/>
<runinfo ncompares="17241" cputime="48901"/>
<classinfo nclasses="25"/>

<class classid="1" nclones="2" nlines="11" similarity="100">
<source file="systems/spaCy-3.2.3/spacy/tests/training/test_new_example.py" startline="258" endline="270" pcid="187">
def test_Example_from_dict_with_spans(annots):
    vocab = Vocab()
    predicted = Doc(vocab, words=annots["words"])
    example = Example.from_dict(predicted, annots)
    assert len(list(example.reference.ents)) == 0
    assert len(list(example.reference.spans["cities"])) == 2
    assert len(list(example.reference.spans["people"])) == 1
    for span in example.reference.spans["cities"]:
        assert span.label_ == "LOC"
    for span in example.reference.spans["people"]:
        assert span.label_ == "PERSON"


</source>
<source file="systems/spaCy-3.2.3/spacy/tests/training/test_new_example.py" startline="283" endline="295" pcid="188">
def test_Example_from_dict_with_spans_overlapping(annots):
    vocab = Vocab()
    predicted = Doc(vocab, words=annots["words"])
    example = Example.from_dict(predicted, annots)
    assert len(list(example.reference.ents)) == 0
    assert len(list(example.reference.spans["cities"])) == 3
    assert len(list(example.reference.spans["people"])) == 1
    for span in example.reference.spans["cities"]:
        assert span.label_ == "LOC"
    for span in example.reference.spans["people"]:
        assert span.label_ == "PERSON"


</source>
</class>

<class classid="2" nclones="2" nlines="10" similarity="100">
<source file="systems/spaCy-3.2.3/spacy/tests/matcher/test_matcher_api.py" startline="418" endline="429" pcid="295">
def test_matcher_regex(en_vocab):
    matcher = Matcher(en_vocab)
    pattern = [{"ORTH": {"REGEX": r"(?:a|an)"}}]
    matcher.add("A_OR_AN", [pattern])
    doc = Doc(en_vocab, words=["an", "a", "hi"])
    matches = matcher(doc)
    assert len(matches) == 2
    doc = Doc(en_vocab, words=["bye"])
    matches = matcher(doc)
    assert len(matches) == 0


</source>
<source file="systems/spaCy-3.2.3/spacy/tests/matcher/test_matcher_api.py" startline="430" endline="441" pcid="296">
def test_matcher_regex_shape(en_vocab):
    matcher = Matcher(en_vocab)
    pattern = [{"SHAPE": {"REGEX": r"^[^x]+$"}}]
    matcher.add("NON_ALPHA", [pattern])
    doc = Doc(en_vocab, words=["99", "problems", "!"])
    matches = matcher(doc)
    assert len(matches) == 2
    doc = Doc(en_vocab, words=["bye"])
    matches = matcher(doc)
    assert len(matches) == 0


</source>
</class>

<class classid="3" nclones="2" nlines="17" similarity="100">
<source file="systems/spaCy-3.2.3/spacy/tests/parser/test_preset_sbd.py" startline="24" endline="45" pcid="395">
def parser(vocab):
    vocab.strings.add("ROOT")
    cfg = {"model": DEFAULT_PARSER_MODEL}
    model = registry.resolve(cfg, validate=True)["model"]
    parser = DependencyParser(vocab, model)
    parser.cfg["token_vector_width"] = 4
    parser.cfg["hidden_width"] = 32
    # parser.add_label('right')
    parser.add_label("left")
    parser.initialize(lambda: [_parser_example(parser)])
    sgd = Adam(0.001)

    for i in range(10):
        losses = {}
        doc = Doc(vocab, words=["a", "b", "c", "d"])
        example = Example.from_dict(
            doc, {"heads": [1, 1, 3, 3], "deps": ["left", "ROOT", "left", "ROOT"]}
        )
        parser.update([example], sgd=sgd, losses=losses)
    return parser


</source>
<source file="systems/spaCy-3.2.3/spacy/tests/parser/test_parse.py" startline="70" endline="91" pcid="492">
def parser(vocab):
    vocab.strings.add("ROOT")
    cfg = {"model": DEFAULT_PARSER_MODEL}
    model = registry.resolve(cfg, validate=True)["model"]
    parser = DependencyParser(vocab, model)
    parser.cfg["token_vector_width"] = 4
    parser.cfg["hidden_width"] = 32
    # parser.add_label('right')
    parser.add_label("left")
    parser.initialize(lambda: [_parser_example(parser)])
    sgd = Adam(0.001)

    for i in range(10):
        losses = {}
        doc = Doc(vocab, words=["a", "b", "c", "d"])
        example = Example.from_dict(
            doc, {"heads": [1, 1, 3, 3], "deps": ["left", "ROOT", "left", "ROOT"]}
        )
        parser.update([example], sgd=sgd, losses=losses)
    return parser


</source>
</class>

<class classid="4" nclones="2" nlines="13" similarity="100">
<source file="systems/spaCy-3.2.3/spacy/tests/pipeline/test_attributeruler.py" startline="18" endline="34" pcid="622">
def pattern_dicts():
    return [
        {
            "patterns": [[{"ORTH": "a"}], [{"ORTH": "irrelevant"}]],
            "attrs": {"LEMMA": "the", "MORPH": "Case=Nom|Number=Plur"},
        },
        # one pattern sets the lemma
        {"patterns": [[{"ORTH": "test"}]], "attrs": {"LEMMA": "cat"}},
        # another pattern sets the morphology
        {
            "patterns": [[{"ORTH": "test"}]],
            "attrs": {"MORPH": "Case=Nom|Number=Sing"},
            "index": 0,
        },
    ]


</source>
<source file="systems/spaCy-3.2.3/spacy/tests/pipeline/test_attributeruler.py" startline="109" endline="124" pcid="629">
    def attribute_ruler_patterns():
        return [
            {
                "patterns": [[{"ORTH": "a"}], [{"ORTH": "irrelevant"}]],
                "attrs": {"LEMMA": "the", "MORPH": "Case=Nom|Number=Plur"},
            },
            # one pattern sets the lemma
            {"patterns": [[{"ORTH": "test"}]], "attrs": {"LEMMA": "cat"}},
            # another pattern sets the morphology
            {
                "patterns": [[{"ORTH": "test"}]],
                "attrs": {"MORPH": "Case=Nom|Number=Sing"},
                "index": 0,
            },
        ]

</source>
</class>

<class classid="5" nclones="5" nlines="10" similarity="100">
<source file="systems/spaCy-3.2.3/spacy/tests/lang/sr/test_tokenizer.py" startline="103" endline="114" pcid="1007">
def test_sr_tokenizer_two_diff_punct(
    sr_tokenizer, punct_open, punct_close, punct_open2, punct_close2, text
):
    tokens = sr_tokenizer(punct_open2 + punct_open + text + punct_close + punct_close2)
    assert len(tokens) == 5
    assert tokens[0].text == punct_open2
    assert tokens[1].text == punct_open
    assert tokens[2].text == text
    assert tokens[3].text == punct_close
    assert tokens[4].text == punct_close2


</source>
<source file="systems/spaCy-3.2.3/spacy/tests/lang/ru/test_tokenizer.py" startline="103" endline="114" pcid="1236">
def test_ru_tokenizer_two_diff_punct(
    ru_tokenizer, punct_open, punct_close, punct_open2, punct_close2, text
):
    tokens = ru_tokenizer(punct_open2 + punct_open + text + punct_close + punct_close2)
    assert len(tokens) == 5
    assert tokens[0].text == punct_open2
    assert tokens[1].text == punct_open
    assert tokens[2].text == text
    assert tokens[3].text == punct_close
    assert tokens[4].text == punct_close2


</source>
<source file="systems/spaCy-3.2.3/spacy/tests/lang/uk/test_tokenizer.py" startline="119" endline="130" pcid="1139">
def test_uk_tokenizer_two_diff_punct(
    uk_tokenizer, punct_open, punct_close, punct_open2, punct_close2, text
):
    tokens = uk_tokenizer(punct_open2 + punct_open + text + punct_close + punct_close2)
    assert len(tokens) == 5
    assert tokens[0].text == punct_open2
    assert tokens[1].text == punct_open
    assert tokens[2].text == text
    assert tokens[3].text == punct_close
    assert tokens[4].text == punct_close2


</source>
<source file="systems/spaCy-3.2.3/spacy/tests/lang/tl/test_punct.py" startline="105" endline="116" pcid="1352">
def test_tl_tokenizer_two_diff_punct(
    tl_tokenizer, punct_open, punct_close, punct_open2, punct_close2, text
):
    tokens = tl_tokenizer(punct_open2 + punct_open + text + punct_close + punct_close2)
    assert len(tokens) == 5
    assert tokens[0].text == punct_open2
    assert tokens[1].text == punct_open
    assert tokens[2].text == text
    assert tokens[3].text == punct_close
    assert tokens[4].text == punct_close2


</source>
<source file="systems/spaCy-3.2.3/spacy/tests/lang/en/test_punct.py" startline="105" endline="116" pcid="1394">
def test_en_tokenizer_two_diff_punct(
    en_tokenizer, punct_open, punct_close, punct_open2, punct_close2, text
):
    tokens = en_tokenizer(punct_open2 + punct_open + text + punct_close + punct_close2)
    assert len(tokens) == 5
    assert tokens[0].text == punct_open2
    assert tokens[1].text == punct_open
    assert tokens[2].text == text
    assert tokens[3].text == punct_close
    assert tokens[4].text == punct_close2


</source>
</class>

<class classid="6" nclones="3" nlines="11" similarity="100">
<source file="systems/spaCy-3.2.3/spacy/tests/lang/ko/test_serialize.py" startline="7" endline="20" pcid="1056">
def test_ko_tokenizer_serialize(ko_tokenizer):
    tokenizer_bytes = ko_tokenizer.to_bytes()
    nlp = Korean()
    nlp.tokenizer.from_bytes(tokenizer_bytes)
    assert tokenizer_bytes == nlp.tokenizer.to_bytes()

    with make_tempdir() as d:
        file_path = d / "tokenizer"
        ko_tokenizer.to_disk(file_path)
        nlp = Korean()
        nlp.tokenizer.from_disk(file_path)
        assert tokenizer_bytes == nlp.tokenizer.to_bytes()


</source>
<source file="systems/spaCy-3.2.3/spacy/tests/lang/th/test_serialize.py" startline="7" endline="20" pcid="1447">
def test_th_tokenizer_serialize(th_tokenizer):
    tokenizer_bytes = th_tokenizer.to_bytes()
    nlp = Thai()
    nlp.tokenizer.from_bytes(tokenizer_bytes)
    assert tokenizer_bytes == nlp.tokenizer.to_bytes()

    with make_tempdir() as d:
        file_path = d / "tokenizer"
        th_tokenizer.to_disk(file_path)
        nlp = Thai()
        nlp.tokenizer.from_disk(file_path)
        assert tokenizer_bytes == nlp.tokenizer.to_bytes()


</source>
<source file="systems/spaCy-3.2.3/spacy/tests/lang/zh/test_serialize.py" startline="6" endline="19" pcid="1187">
def zh_tokenizer_serialize(zh_tokenizer):
    tokenizer_bytes = zh_tokenizer.to_bytes()
    nlp = Chinese()
    nlp.tokenizer.from_bytes(tokenizer_bytes)
    assert tokenizer_bytes == nlp.tokenizer.to_bytes()

    with make_tempdir() as d:
        file_path = d / "tokenizer"
        zh_tokenizer.to_disk(file_path)
        nlp = Chinese()
        nlp.tokenizer.from_disk(file_path)
        assert tokenizer_bytes == nlp.tokenizer.to_bytes()


</source>
</class>

<class classid="7" nclones="2" nlines="10" similarity="100">
<source file="systems/spaCy-3.2.3/spacy/tests/lang/de/test_parser.py" startline="4" endline="15" pcid="1097">
def test_de_parser_noun_chunks_standard_de(de_vocab):
    words = ["Eine", "Tasse", "steht", "auf", "dem", "Tisch", "."]
    heads = [1, 2, 2, 2, 5, 3, 2]
    pos = ["DET", "NOUN", "VERB", "ADP", "DET", "NOUN", "PUNCT"]
    deps = ["nk", "sb", "ROOT", "mo", "nk", "nk", "punct"]
    doc = Doc(de_vocab, words=words, pos=pos, deps=deps, heads=heads)
    chunks = list(doc.noun_chunks)
    assert len(chunks) == 2
    assert chunks[0].text_with_ws == "Eine Tasse "
    assert chunks[1].text_with_ws == "dem Tisch "


</source>
<source file="systems/spaCy-3.2.3/spacy/tests/lang/en/test_parser.py" startline="29" endline="40" pcid="1404">
def test_en_parser_noun_chunks_pp_chunks(en_vocab):
    words = ["A", "phrase", "with", "another", "phrase", "occurs", "."]
    heads = [1, 5, 1, 4, 2, 5, 5]
    pos = ["DET", "NOUN", "ADP", "DET", "NOUN", "VERB", "PUNCT"]
    deps = ["det", "nsubj", "prep", "det", "pobj", "ROOT", "punct"]
    doc = Doc(en_vocab, words=words, pos=pos, deps=deps, heads=heads)
    chunks = list(doc.noun_chunks)
    assert len(chunks) == 2
    assert chunks[0].text_with_ws == "A phrase "
    assert chunks[1].text_with_ws == "another phrase "


</source>
</class>

<class classid="8" nclones="5" nlines="11" similarity="100">
<source file="systems/spaCy-3.2.3/spacy/tests/lang/tr/test_parser.py" startline="4" endline="17" pcid="1292">
def test_tr_noun_chunks_amod_simple(tr_tokenizer):
    text = "sarı kedi"
    heads = [1, 1]
    deps = ["amod", "ROOT"]
    pos = ["ADJ", "NOUN"]
    tokens = tr_tokenizer(text)
    doc = Doc(
        tokens.vocab, words=[t.text for t in tokens], pos=pos, heads=heads, deps=deps
    )
    chunks = list(doc.noun_chunks)
    assert len(chunks) == 1
    assert chunks[0].text_with_ws == "sarı kedi "


</source>
<source file="systems/spaCy-3.2.3/spacy/tests/lang/tr/test_parser.py" startline="200" endline="213" pcid="1306">
def test_tr_noun_chunks_acl_verb(tr_tokenizer):
    text = "sevdiğim sanatçılar"
    heads = [1, 1]
    deps = ["acl", "ROOT"]
    pos = ["VERB", "NOUN"]
    tokens = tr_tokenizer(text)
    doc = Doc(
        tokens.vocab, words=[t.text for t in tokens], pos=pos, heads=heads, deps=deps
    )
    chunks = list(doc.noun_chunks)
    assert len(chunks) == 1
    assert chunks[0].text_with_ws == "sevdiğim sanatçılar "


</source>
<source file="systems/spaCy-3.2.3/spacy/tests/lang/tr/test_parser.py" startline="18" endline="31" pcid="1293">
def test_tr_noun_chunks_nmod_simple(tr_tokenizer):
    text = "arkadaşımın kedisi"  # my friend's cat
    heads = [1, 1]
    deps = ["nmod", "ROOT"]
    pos = ["NOUN", "NOUN"]
    tokens = tr_tokenizer(text)
    doc = Doc(
        tokens.vocab, words=[t.text for t in tokens], pos=pos, heads=heads, deps=deps
    )
    chunks = list(doc.noun_chunks)
    assert len(chunks) == 1
    assert chunks[0].text_with_ws == "arkadaşımın kedisi "


</source>
<source file="systems/spaCy-3.2.3/spacy/tests/lang/tr/test_parser.py" startline="479" endline="492" pcid="1325">
def test_tr_noun_chunks_flat_simple(tr_tokenizer):
    text = "New York"
    heads = [0, 0]
    deps = ["ROOT", "flat"]
    pos = ["PROPN", "PROPN"]
    tokens = tr_tokenizer(text)
    doc = Doc(
        tokens.vocab, words=[t.text for t in tokens], pos=pos, heads=heads, deps=deps
    )
    chunks = list(doc.noun_chunks)
    assert len(chunks) == 1
    assert chunks[0].text_with_ws == "New York "


</source>
<source file="systems/spaCy-3.2.3/spacy/tests/lang/tr/test_parser.py" startline="32" endline="45" pcid="1294">
def test_tr_noun_chunks_determiner_simple(tr_tokenizer):
    text = "O kedi"  # that cat
    heads = [1, 1]
    deps = ["det", "ROOT"]
    pos = ["DET", "NOUN"]
    tokens = tr_tokenizer(text)
    doc = Doc(
        tokens.vocab, words=[t.text for t in tokens], pos=pos, heads=heads, deps=deps
    )
    chunks = list(doc.noun_chunks)
    assert len(chunks) == 1
    assert chunks[0].text_with_ws == "O kedi "


</source>
</class>

<class classid="9" nclones="9" nlines="11" similarity="100">
<source file="systems/spaCy-3.2.3/spacy/tests/lang/tr/test_parser.py" startline="46" endline="59" pcid="1295">
def test_tr_noun_chunks_nmod_amod(tr_tokenizer):
    text = "okulun eski müdürü"
    heads = [2, 2, 2]
    deps = ["nmod", "amod", "ROOT"]
    pos = ["NOUN", "ADJ", "NOUN"]
    tokens = tr_tokenizer(text)
    doc = Doc(
        tokens.vocab, words=[t.text for t in tokens], pos=pos, heads=heads, deps=deps
    )
    chunks = list(doc.noun_chunks)
    assert len(chunks) == 1
    assert chunks[0].text_with_ws == "okulun eski müdürü "


</source>
<source file="systems/spaCy-3.2.3/spacy/tests/lang/tr/test_parser.py" startline="242" endline="255" pcid="1309">
def test_tr_noun_chunks_np_recursive_nsubj_to_root(tr_tokenizer):
    text = "Simge'nin okuduğu kitap"
    heads = [1, 2, 2]
    deps = ["nsubj", "acl", "ROOT"]
    pos = ["PROPN", "VERB", "NOUN"]
    tokens = tr_tokenizer(text)
    doc = Doc(
        tokens.vocab, words=[t.text for t in tokens], pos=pos, heads=heads, deps=deps
    )
    chunks = list(doc.noun_chunks)
    assert len(chunks) == 1
    assert chunks[0].text_with_ws == "Simge'nin okuduğu kitap "


</source>
<source file="systems/spaCy-3.2.3/spacy/tests/lang/tr/test_parser.py" startline="102" endline="115" pcid="1299">
def test_tr_noun_chunks_nmod_two(tr_tokenizer):
    text = "kızın saçının rengi"
    heads = [1, 2, 2]
    deps = ["nmod", "nmod", "ROOT"]
    pos = ["NOUN", "NOUN", "NOUN"]
    tokens = tr_tokenizer(text)
    doc = Doc(
        tokens.vocab, words=[t.text for t in tokens], pos=pos, heads=heads, deps=deps
    )
    chunks = list(doc.noun_chunks)
    assert len(chunks) == 1
    assert chunks[0].text_with_ws == "kızın saçının rengi "


</source>
<source file="systems/spaCy-3.2.3/spacy/tests/lang/tr/test_parser.py" startline="507" endline="520" pcid="1327">
def test_tr_noun_chunks_flat_names_and_title2(tr_tokenizer):
    text = "Ahmet Vefik Paşa"
    heads = [2, 0, 2]
    deps = ["nmod", "flat", "ROOT"]
    pos = ["PROPN", "PROPN", "PROPN"]
    tokens = tr_tokenizer(text)
    doc = Doc(
        tokens.vocab, words=[t.text for t in tokens], pos=pos, heads=heads, deps=deps
    )
    chunks = list(doc.noun_chunks)
    assert len(chunks) == 1
    assert chunks[0].text_with_ws == "Ahmet Vefik Paşa "


</source>
<source file="systems/spaCy-3.2.3/spacy/tests/lang/tr/test_parser.py" startline="256" endline="269" pcid="1310">
def test_tr_noun_chunks_np_recursive_nsubj_attached_to_pron_root(tr_tokenizer):
    text = "Simge'nin konuşabileceği birisi"
    heads = [1, 2, 2]
    deps = ["nsubj", "acl", "ROOT"]
    pos = ["PROPN", "VERB", "PRON"]
    tokens = tr_tokenizer(text)
    doc = Doc(
        tokens.vocab, words=[t.text for t in tokens], pos=pos, heads=heads, deps=deps
    )
    chunks = list(doc.noun_chunks)
    assert len(chunks) == 1
    assert chunks[0].text_with_ws == "Simge'nin konuşabileceği birisi "


</source>
<source file="systems/spaCy-3.2.3/spacy/tests/lang/tr/test_parser.py" startline="186" endline="199" pcid="1305">
def test_tr_noun_chunks_acl_simple(tr_tokenizer):
    text = "bahçesi olan okul"
    heads = [2, 0, 2]
    deps = ["acl", "cop", "ROOT"]
    pos = ["NOUN", "AUX", "NOUN"]
    tokens = tr_tokenizer(text)
    doc = Doc(
        tokens.vocab, words=[t.text for t in tokens], pos=pos, heads=heads, deps=deps
    )
    chunks = list(doc.noun_chunks)
    assert len(chunks) == 1
    assert chunks[0].text_with_ws == "bahçesi olan okul "


</source>
<source file="systems/spaCy-3.2.3/spacy/tests/lang/tr/test_parser.py" startline="493" endline="506" pcid="1326">
def test_tr_noun_chunks_flat_names_and_title(tr_tokenizer):
    text = "Gazi Mustafa Kemal"
    heads = [1, 1, 1]
    deps = ["nmod", "ROOT", "flat"]
    pos = ["PROPN", "PROPN", "PROPN"]
    tokens = tr_tokenizer(text)
    doc = Doc(
        tokens.vocab, words=[t.text for t in tokens], pos=pos, heads=heads, deps=deps
    )
    chunks = list(doc.noun_chunks)
    assert len(chunks) == 1
    assert chunks[0].text_with_ws == "Gazi Mustafa Kemal "


</source>
<source file="systems/spaCy-3.2.3/spacy/tests/lang/tr/test_parser.py" startline="74" endline="87" pcid="1297">
def test_tr_noun_chunks_two_adjs_simple(tr_tokenizer):
    text = "beyaz tombik kedi"
    heads = [2, 2, 2]
    deps = ["amod", "amod", "ROOT"]
    pos = ["ADJ", "ADJ", "NOUN"]
    tokens = tr_tokenizer(text)
    doc = Doc(
        tokens.vocab, words=[t.text for t in tokens], pos=pos, heads=heads, deps=deps
    )
    chunks = list(doc.noun_chunks)
    assert len(chunks) == 1
    assert chunks[0].text_with_ws == "beyaz tombik kedi "


</source>
<source file="systems/spaCy-3.2.3/spacy/tests/lang/tr/test_parser.py" startline="60" endline="73" pcid="1296">
def test_tr_noun_chunks_one_det_one_adj_simple(tr_tokenizer):
    text = "O sarı kedi"
    heads = [2, 2, 2]
    deps = ["det", "amod", "ROOT"]
    pos = ["DET", "ADJ", "NOUN"]
    tokens = tr_tokenizer(text)
    doc = Doc(
        tokens.vocab, words=[t.text for t in tokens], pos=pos, heads=heads, deps=deps
    )
    chunks = list(doc.noun_chunks)
    assert len(chunks) == 1
    assert chunks[0].text_with_ws == "O sarı kedi "


</source>
</class>

<class classid="10" nclones="12" nlines="11" similarity="100">
<source file="systems/spaCy-3.2.3/spacy/tests/lang/tr/test_parser.py" startline="88" endline="101" pcid="1298">
def test_tr_noun_chunks_one_det_two_adjs_simple(tr_tokenizer):
    text = "o beyaz tombik kedi"
    heads = [3, 3, 3, 3]
    deps = ["det", "amod", "amod", "ROOT"]
    pos = ["DET", "ADJ", "ADJ", "NOUN"]
    tokens = tr_tokenizer(text)
    doc = Doc(
        tokens.vocab, words=[t.text for t in tokens], pos=pos, heads=heads, deps=deps
    )
    chunks = list(doc.noun_chunks)
    assert len(chunks) == 1
    assert chunks[0].text_with_ws == "o beyaz tombik kedi "


</source>
<source file="systems/spaCy-3.2.3/spacy/tests/lang/tr/test_parser.py" startline="214" endline="227" pcid="1307">
def test_tr_noun_chunks_acl_nmod(tr_tokenizer):
    text = "en sevdiğim ses sanatçısı"
    heads = [1, 3, 3, 3]
    deps = ["advmod", "acl", "nmod", "ROOT"]
    pos = ["ADV", "VERB", "NOUN", "NOUN"]
    tokens = tr_tokenizer(text)
    doc = Doc(
        tokens.vocab, words=[t.text for t in tokens], pos=pos, heads=heads, deps=deps
    )
    chunks = list(doc.noun_chunks)
    assert len(chunks) == 1
    assert chunks[0].text_with_ws == "en sevdiğim ses sanatçısı "


</source>
<source file="systems/spaCy-3.2.3/spacy/tests/lang/tr/test_parser.py" startline="172" endline="185" pcid="1304">
def test_tr_noun_chunks_det_amod_nmod(tr_tokenizer):
    text = "bazı eski oyun kuralları"
    heads = [3, 3, 3, 3]
    deps = ["det", "nmod", "nmod", "ROOT"]
    pos = ["DET", "ADJ", "NOUN", "NOUN"]
    tokens = tr_tokenizer(text)
    doc = Doc(
        tokens.vocab, words=[t.text for t in tokens], pos=pos, heads=heads, deps=deps
    )
    chunks = list(doc.noun_chunks)
    assert len(chunks) == 1
    assert chunks[0].text_with_ws == "bazı eski oyun kuralları "


</source>
<source file="systems/spaCy-3.2.3/spacy/tests/lang/tr/test_parser.py" startline="158" endline="171" pcid="1303">
def test_tr_noun_chunks_nmod_three(tr_tokenizer):
    text = "güney Afrika ülkelerinden Mozambik"
    heads = [1, 2, 3, 3]
    deps = ["nmod", "nmod", "nmod", "ROOT"]
    pos = ["NOUN", "PROPN", "NOUN", "PROPN"]
    tokens = tr_tokenizer(text)
    doc = Doc(
        tokens.vocab, words=[t.text for t in tokens], pos=pos, heads=heads, deps=deps
    )
    chunks = list(doc.noun_chunks)
    assert len(chunks) == 1
    assert chunks[0].text_with_ws == "güney Afrika ülkelerinden Mozambik "


</source>
<source file="systems/spaCy-3.2.3/spacy/tests/lang/tr/test_parser.py" startline="116" endline="129" pcid="1300">
def test_tr_noun_chunks_chain_nmod_with_adj(tr_tokenizer):
    text = "ev sahibinin tatlı köpeği"
    heads = [1, 3, 3, 3]
    deps = ["nmod", "nmod", "amod", "ROOT"]
    pos = ["NOUN", "NOUN", "ADJ", "NOUN"]
    tokens = tr_tokenizer(text)
    doc = Doc(
        tokens.vocab, words=[t.text for t in tokens], pos=pos, heads=heads, deps=deps
    )
    chunks = list(doc.noun_chunks)
    assert len(chunks) == 1
    assert chunks[0].text_with_ws == "ev sahibinin tatlı köpeği "


</source>
<source file="systems/spaCy-3.2.3/spacy/tests/lang/tr/test_parser.py" startline="228" endline="241" pcid="1308">
def test_tr_noun_chunks_acl_nmod2(tr_tokenizer):
    text = "bildiğim bir turizm şirketi"
    heads = [3, 3, 3, 3]
    deps = ["acl", "det", "nmod", "ROOT"]
    pos = ["VERB", "DET", "NOUN", "NOUN"]
    tokens = tr_tokenizer(text)
    doc = Doc(
        tokens.vocab, words=[t.text for t in tokens], pos=pos, heads=heads, deps=deps
    )
    chunks = list(doc.noun_chunks)
    assert len(chunks) == 1
    assert chunks[0].text_with_ws == "bildiğim bir turizm şirketi "


</source>
<source file="systems/spaCy-3.2.3/spacy/tests/lang/tr/test_parser.py" startline="130" endline="143" pcid="1301">
def test_tr_noun_chunks_chain_nmod_with_acl(tr_tokenizer):
    text = "ev sahibinin gelen köpeği"
    heads = [1, 3, 3, 3]
    deps = ["nmod", "nmod", "acl", "ROOT"]
    pos = ["NOUN", "NOUN", "VERB", "NOUN"]
    tokens = tr_tokenizer(text)
    doc = Doc(
        tokens.vocab, words=[t.text for t in tokens], pos=pos, heads=heads, deps=deps
    )
    chunks = list(doc.noun_chunks)
    assert len(chunks) == 1
    assert chunks[0].text_with_ws == "ev sahibinin gelen köpeği "


</source>
<source file="systems/spaCy-3.2.3/spacy/tests/lang/tr/test_parser.py" startline="144" endline="157" pcid="1302">
def test_tr_noun_chunks_chain_nmod_head_with_amod_acl(tr_tokenizer):
    text = "arabanın kırdığım sol aynası"
    heads = [3, 3, 3, 3]
    deps = ["nmod", "acl", "amod", "ROOT"]
    pos = ["NOUN", "VERB", "ADJ", "NOUN"]
    tokens = tr_tokenizer(text)
    doc = Doc(
        tokens.vocab, words=[t.text for t in tokens], pos=pos, heads=heads, deps=deps
    )
    chunks = list(doc.noun_chunks)
    assert len(chunks) == 1
    assert chunks[0].text_with_ws == "arabanın kırdığım sol aynası "


</source>
<source file="systems/spaCy-3.2.3/spacy/tests/lang/tr/test_parser.py" startline="521" endline="534" pcid="1328">
def test_tr_noun_chunks_flat_name_lastname_and_title(tr_tokenizer):
    text = "Cumhurbaşkanı Ahmet Necdet Sezer"
    heads = [1, 1, 1, 1]
    deps = ["nmod", "ROOT", "flat", "flat"]
    pos = ["NOUN", "PROPN", "PROPN", "PROPN"]
    tokens = tr_tokenizer(text)
    doc = Doc(
        tokens.vocab, words=[t.text for t in tokens], pos=pos, heads=heads, deps=deps
    )
    chunks = list(doc.noun_chunks)
    assert len(chunks) == 1
    assert chunks[0].text_with_ws == "Cumhurbaşkanı Ahmet Necdet Sezer "


</source>
<source file="systems/spaCy-3.2.3/spacy/tests/lang/tr/test_parser.py" startline="357" endline="370" pcid="1317">
def test_tr_noun_chunks_two_nouns_in_nmod2(tr_tokenizer):
    text = "tatlı ve gürbüz çocuklar"
    heads = [3, 2, 0, 3]
    deps = ["amod", "cc", "conj", "ROOT"]
    pos = ["ADJ", "CCONJ", "NOUN", "NOUN"]
    tokens = tr_tokenizer(text)
    doc = Doc(
        tokens.vocab, words=[t.text for t in tokens], pos=pos, heads=heads, deps=deps
    )
    chunks = list(doc.noun_chunks)
    assert len(chunks) == 1
    assert chunks[0].text_with_ws == "tatlı ve gürbüz çocuklar "


</source>
<source file="systems/spaCy-3.2.3/spacy/tests/lang/tr/test_parser.py" startline="270" endline="283" pcid="1311">
def test_tr_noun_chunks_np_recursive_nsubj_in_subnp(tr_tokenizer):
    text = "Simge'nin yarın gideceği yer"
    heads = [2, 2, 3, 3]
    deps = ["nsubj", "obl", "acl", "ROOT"]
    pos = ["PROPN", "NOUN", "VERB", "NOUN"]
    tokens = tr_tokenizer(text)
    doc = Doc(
        tokens.vocab, words=[t.text for t in tokens], pos=pos, heads=heads, deps=deps
    )
    chunks = list(doc.noun_chunks)
    assert len(chunks) == 1
    assert chunks[0].text_with_ws == "Simge'nin yarın gideceği yer "


</source>
<source file="systems/spaCy-3.2.3/spacy/tests/lang/tr/test_parser.py" startline="343" endline="356" pcid="1316">
def test_tr_noun_chunks_two_nouns_in_nmod(tr_tokenizer):
    text = "kız ve erkek çocuklar"
    heads = [3, 2, 0, 3]
    deps = ["nmod", "cc", "conj", "ROOT"]
    pos = ["NOUN", "CCONJ", "NOUN", "NOUN"]
    tokens = tr_tokenizer(text)
    doc = Doc(
        tokens.vocab, words=[t.text for t in tokens], pos=pos, heads=heads, deps=deps
    )
    chunks = list(doc.noun_chunks)
    assert len(chunks) == 1
    assert chunks[0].text_with_ws == "kız ve erkek çocuklar "


</source>
</class>

<class classid="11" nclones="4" nlines="11" similarity="100">
<source file="systems/spaCy-3.2.3/spacy/tests/lang/tr/test_parser.py" startline="284" endline="297" pcid="1312">
def test_tr_noun_chunks_np_recursive_two_nmods(tr_tokenizer):
    text = "ustanın kapısını degiştireceği çamasır makinası"
    heads = [2, 2, 4, 4, 4]
    deps = ["nsubj", "obj", "acl", "nmod", "ROOT"]
    pos = ["NOUN", "NOUN", "VERB", "NOUN", "NOUN"]
    tokens = tr_tokenizer(text)
    doc = Doc(
        tokens.vocab, words=[t.text for t in tokens], pos=pos, heads=heads, deps=deps
    )
    chunks = list(doc.noun_chunks)
    assert len(chunks) == 1
    assert chunks[0].text_with_ws == "ustanın kapısını degiştireceği çamasır makinası "


</source>
<source file="systems/spaCy-3.2.3/spacy/tests/lang/tr/test_parser.py" startline="535" endline="548" pcid="1329">
def test_tr_noun_chunks_flat_in_nmod(tr_tokenizer):
    text = "Ahmet Sezer adında bir ögrenci"
    heads = [2, 0, 4, 4, 4]
    deps = ["nmod", "flat", "nmod", "det", "ROOT"]
    pos = ["PROPN", "PROPN", "NOUN", "DET", "NOUN"]
    tokens = tr_tokenizer(text)
    doc = Doc(
        tokens.vocab, words=[t.text for t in tokens], pos=pos, heads=heads, deps=deps
    )
    chunks = list(doc.noun_chunks)
    assert len(chunks) == 1
    assert chunks[0].text_with_ws == "Ahmet Sezer adında bir ögrenci "


</source>
<source file="systems/spaCy-3.2.3/spacy/tests/lang/tr/test_parser.py" startline="298" endline="311" pcid="1313">
def test_tr_noun_chunks_np_recursive_four_nouns(tr_tokenizer):
    text = "kızına piyano dersi verdiğim hanım"
    heads = [3, 2, 3, 4, 4]
    deps = ["obl", "nmod", "obj", "acl", "ROOT"]
    pos = ["NOUN", "NOUN", "NOUN", "VERB", "NOUN"]
    tokens = tr_tokenizer(text)
    doc = Doc(
        tokens.vocab, words=[t.text for t in tokens], pos=pos, heads=heads, deps=deps
    )
    chunks = list(doc.noun_chunks)
    assert len(chunks) == 1
    assert chunks[0].text_with_ws == "kızına piyano dersi verdiğim hanım "


</source>
<source file="systems/spaCy-3.2.3/spacy/tests/lang/tr/test_parser.py" startline="549" endline="562" pcid="1330">
def test_tr_noun_chunks_flat_and_chain_nmod(tr_tokenizer):
    text = "Batı Afrika ülkelerinden Sierra Leone"
    heads = [1, 2, 3, 3, 3]
    deps = ["nmod", "nmod", "nmod", "ROOT", "flat"]
    pos = ["NOUN", "PROPN", "NOUN", "PROPN", "PROPN"]
    tokens = tr_tokenizer(text)
    doc = Doc(
        tokens.vocab, words=[t.text for t in tokens], pos=pos, heads=heads, deps=deps
    )
    chunks = list(doc.noun_chunks)
    assert len(chunks) == 1
    assert chunks[0].text_with_ws == "Batı Afrika ülkelerinden Sierra Leone "


</source>
</class>

<class classid="12" nclones="2" nlines="12" similarity="100">
<source file="systems/spaCy-3.2.3/spacy/tests/lang/tr/test_parser.py" startline="371" endline="385" pcid="1318">
def test_tr_noun_chunks_conj_simple(tr_tokenizer):
    text = "Sen ya da ben"
    heads = [0, 3, 1, 0]
    deps = ["ROOT", "cc", "fixed", "conj"]
    pos = ["PRON", "CCONJ", "CCONJ", "PRON"]
    tokens = tr_tokenizer(text)
    doc = Doc(
        tokens.vocab, words=[t.text for t in tokens], pos=pos, heads=heads, deps=deps
    )
    chunks = list(doc.noun_chunks)
    assert len(chunks) == 2
    assert chunks[0].text_with_ws == "ben "
    assert chunks[1].text_with_ws == "Sen "


</source>
<source file="systems/spaCy-3.2.3/spacy/tests/lang/tr/test_parser.py" startline="418" endline="432" pcid="1321">
def test_tr_noun_chunks_conj_and_adj_phrase(tr_tokenizer):
    text = "ben ve akıllı çocuk"
    heads = [0, 3, 3, 0]
    deps = ["ROOT", "cc", "amod", "conj"]
    pos = ["PRON", "CCONJ", "ADJ", "NOUN"]
    tokens = tr_tokenizer(text)
    doc = Doc(
        tokens.vocab, words=[t.text for t in tokens], pos=pos, heads=heads, deps=deps
    )
    chunks = list(doc.noun_chunks)
    assert len(chunks) == 2
    assert chunks[0].text_with_ws == "akıllı çocuk "
    assert chunks[1].text_with_ws == "ben "


</source>
</class>

<class classid="13" nclones="3" nlines="12" similarity="100">
<source file="systems/spaCy-3.2.3/spacy/tests/lang/tr/test_parser.py" startline="433" endline="447" pcid="1322">
def test_tr_noun_chunks_conj_fixed_adj_phrase(tr_tokenizer):
    text = "ben ya da akıllı çocuk"
    heads = [0, 4, 1, 4, 0]
    deps = ["ROOT", "cc", "fixed", "amod", "conj"]
    pos = ["PRON", "CCONJ", "CCONJ", "ADJ", "NOUN"]
    tokens = tr_tokenizer(text)
    doc = Doc(
        tokens.vocab, words=[t.text for t in tokens], pos=pos, heads=heads, deps=deps
    )
    chunks = list(doc.noun_chunks)
    assert len(chunks) == 2
    assert chunks[0].text_with_ws == "akıllı çocuk "
    assert chunks[1].text_with_ws == "ben "


</source>
<source file="systems/spaCy-3.2.3/spacy/tests/lang/tr/test_parser.py" startline="563" endline="575" pcid="1331">
def test_tr_noun_chunks_two_flats_conjed(tr_tokenizer):
    text = "New York ve Sierra Leone"
    heads = [0, 0, 3, 0, 3]
    deps = ["ROOT", "flat", "cc", "conj", "flat"]
    pos = ["PROPN", "PROPN", "CCONJ", "PROPN", "PROPN"]
    tokens = tr_tokenizer(text)
    doc = Doc(
        tokens.vocab, words=[t.text for t in tokens], pos=pos, heads=heads, deps=deps
    )
    chunks = list(doc.noun_chunks)
    assert len(chunks) == 2
    assert chunks[0].text_with_ws == "Sierra Leone "
    assert chunks[1].text_with_ws == "New York "
</source>
<source file="systems/spaCy-3.2.3/spacy/tests/lang/tr/test_parser.py" startline="448" endline="462" pcid="1323">
def test_tr_noun_chunks_conj_subject(tr_tokenizer):
    text = "Sen ve ben iyi anlaşıyoruz"
    heads = [4, 2, 0, 2, 4]
    deps = ["nsubj", "cc", "conj", "adv", "ROOT"]
    pos = ["PRON", "CCONJ", "PRON", "ADV", "VERB"]
    tokens = tr_tokenizer(text)
    doc = Doc(
        tokens.vocab, words=[t.text for t in tokens], pos=pos, heads=heads, deps=deps
    )
    chunks = list(doc.noun_chunks)
    assert len(chunks) == 2
    assert chunks[0].text_with_ws == "ben "
    assert chunks[1].text_with_ws == "Sen "


</source>
</class>

<class classid="14" nclones="10" nlines="13" similarity="100">
<source file="systems/spaCy-3.2.3/spacy/lang/sv/lex_attrs.py" startline="44" endline="58" pcid="1798">
def like_num(text):
    if text.startswith(("+", "-", "±", "~")):
        text = text[1:]
    text = text.replace(",", "").replace(".", "")
    if text.isdigit():
        return True
    if text.count("/") == 1:
        num, denom = text.split("/")
        if num.isdigit() and denom.isdigit():
            return True
    if text.lower() in _num_words:
        return True
    return False


</source>
<source file="systems/spaCy-3.2.3/spacy/lang/sr/lex_attrs.py" startline="51" endline="65" pcid="1801">
def like_num(text):
    if text.startswith(("+", "-", "±", "~")):
        text = text[1:]
    text = text.replace(",", "").replace(".", "")
    if text.isdigit():
        return True
    if text.count("/") == 1:
        num, denom = text.split("/")
        if num.isdigit() and denom.isdigit():
            return True
    if text.lower() in _num_words:
        return True
    return False


</source>
<source file="systems/spaCy-3.2.3/spacy/lang/es/lex_attrs.py" startline="50" endline="64" pcid="1894">
def like_num(text):
    if text.startswith(("+", "-", "±", "~")):
        text = text[1:]
    text = text.replace(",", "").replace(".", "")
    if text.isdigit():
        return True
    if text.count("/") == 1:
        num, denom = text.split("/")
        if num.isdigit() and denom.isdigit():
            return True
    if text.lower() in _num_words:
        return True
    return False


</source>
<source file="systems/spaCy-3.2.3/spacy/lang/ru/lex_attrs.py" startline="51" endline="65" pcid="1885">
def like_num(text):
    if text.startswith(("+", "-", "±", "~")):
        text = text[1:]
    text = text.replace(",", "").replace(".", "")
    if text.isdigit():
        return True
    if text.count("/") == 1:
        num, denom = text.split("/")
        if num.isdigit() and denom.isdigit():
            return True
    if text.lower() in _num_words:
        return True
    return False


</source>
<source file="systems/spaCy-3.2.3/spacy/lang/hy/lex_attrs.py" startline="42" endline="56" pcid="1830">
def like_num(text):
    if text.startswith(("+", "-", "±", "~")):
        text = text[1:]
    text = text.replace(",", "").replace(".", "")
    if text.isdigit():
        return True
    if text.count("/") == 1:
        num, denom = text.split("/")
        if num.isdigit() and denom.isdigit():
            return True
    if text.lower() in _num_words:
        return True
    return False


</source>
<source file="systems/spaCy-3.2.3/spacy/lang/cs/lex_attrs.py" startline="46" endline="60" pcid="1871">
def like_num(text):
    if text.startswith(("+", "-", "±", "~")):
        text = text[1:]
    text = text.replace(",", "").replace(".", "")
    if text.isdigit():
        return True
    if text.count("/") == 1:
        num, denom = text.split("/")
        if num.isdigit() and denom.isdigit():
            return True
    if text.lower() in _num_words:
        return True
    return False


</source>
<source file="systems/spaCy-3.2.3/spacy/lang/bg/lex_attrs.py" startline="73" endline="87" pcid="1803">
def like_num(text):
    if text.startswith(("+", "-", "±", "~")):
        text = text[1:]
    text = text.replace(",", "").replace(".", "")
    if text.isdigit():
        return True
    if text.count("/") == 1:
        num, denom = text.split("/")
        if num.isdigit() and denom.isdigit():
            return True
    if text.lower() in _num_words:
        return True
    return False


</source>
<source file="systems/spaCy-3.2.3/spacy/lang/ne/lex_attrs.py" startline="80" endline="94" pcid="1907">
def like_num(text):
    if text.startswith(("+", "-", "±", "~")):
        text = text[1:]
    text = text.replace(", ", "").replace(".", "")
    if text.isdigit():
        return True
    if text.count("/") == 1:
        num, denom = text.split("/")
        if num.isdigit() and denom.isdigit():
            return True
    if text.lower() in _num_words:
        return True
    return False


</source>
<source file="systems/spaCy-3.2.3/spacy/lang/sk/lex_attrs.py" startline="44" endline="58" pcid="1802">
def like_num(text):
    if text.startswith(("+", "-", "±", "~")):
        text = text[1:]
    text = text.replace(",", "").replace(".", "")
    if text.isdigit():
        return True
    if text.count("/") == 1:
        num, denom = text.split("/")
        if num.isdigit() and denom.isdigit():
            return True
    if text.lower() in _num_words:
        return True
    return False


</source>
<source file="systems/spaCy-3.2.3/spacy/lang/vi/lex_attrs.py" startline="24" endline="38" pcid="1873">
def like_num(text):
    if text.startswith(("+", "-", "±", "~")):
        text = text[1:]
    text = text.replace(",", "").replace(".", "")
    if text.isdigit():
        return True
    if text.count("/") == 1:
        num, denom = text.split("/")
        if num.isdigit() and denom.isdigit():
            return True
    if text.lower() in _num_words:
        return True
    return False


</source>
</class>

<class classid="15" nclones="14" nlines="10" similarity="100">
<source file="systems/spaCy-3.2.3/spacy/lang/sv/__init__.py" startline="40" endline="52" pcid="1800">
def make_lemmatizer(
    nlp: Language,
    model: Optional[Model],
    name: str,
    mode: str,
    overwrite: bool,
    scorer: Optional[Callable],
):
    return Lemmatizer(
        nlp.vocab, model, name, mode=mode, overwrite=overwrite, scorer=scorer
    )


</source>
<source file="systems/spaCy-3.2.3/spacy/lang/es/__init__.py" startline="37" endline="49" pcid="1895">
def make_lemmatizer(
    nlp: Language,
    model: Optional[Model],
    name: str,
    mode: str,
    overwrite: bool,
    scorer: Optional[Callable],
):
    return SpanishLemmatizer(
        nlp.vocab, model, name, mode=mode, overwrite=overwrite, scorer=scorer
    )


</source>
<source file="systems/spaCy-3.2.3/spacy/lang/mk/__init__.py" startline="49" endline="61" pcid="1828">
def make_lemmatizer(
    nlp: Language,
    model: Optional[Model],
    name: str,
    mode: str,
    overwrite: bool,
    scorer: Optional[Callable],
):
    return MacedonianLemmatizer(
        nlp.vocab, model, name, mode=mode, overwrite=overwrite, scorer=scorer
    )


</source>
<source file="systems/spaCy-3.2.3/spacy/lang/uk/__init__.py" startline="34" endline="46" pcid="1833">
def make_lemmatizer(
    nlp: Language,
    model: Optional[Model],
    name: str,
    mode: str,
    overwrite: bool,
    scorer: Optional[Callable],
):
    return UkrainianLemmatizer(
        nlp.vocab, model, name, mode=mode, overwrite=overwrite, scorer=scorer
    )


</source>
<source file="systems/spaCy-3.2.3/spacy/lang/ca/__init__.py" startline="40" endline="52" pcid="1864">
def make_lemmatizer(
    nlp: Language,
    model: Optional[Model],
    name: str,
    mode: str,
    overwrite: bool,
    scorer: Optional[Callable],
):
    return CatalanLemmatizer(
        nlp.vocab, model, name, mode=mode, overwrite=overwrite, scorer=scorer
    )


</source>
<source file="systems/spaCy-3.2.3/spacy/lang/fr/__init__.py" startline="42" endline="54" pcid="1891">
def make_lemmatizer(
    nlp: Language,
    model: Optional[Model],
    name: str,
    mode: str,
    overwrite: bool,
    scorer: Optional[Callable],
):
    return FrenchLemmatizer(
        nlp.vocab, model, name, mode=mode, overwrite=overwrite, scorer=scorer
    )


</source>
<source file="systems/spaCy-3.2.3/spacy/lang/it/__init__.py" startline="34" endline="46" pcid="1905">
def make_lemmatizer(
    nlp: Language,
    model: Optional[Model],
    name: str,
    mode: str,
    overwrite: bool,
    scorer: Optional[Callable],
):
    return ItalianLemmatizer(
        nlp.vocab, model, name, mode=mode, overwrite=overwrite, scorer=scorer
    )


</source>
<source file="systems/spaCy-3.2.3/spacy/lang/nb/__init__.py" startline="37" endline="49" pcid="1816">
def make_lemmatizer(
    nlp: Language,
    model: Optional[Model],
    name: str,
    mode: str,
    overwrite: bool,
    scorer: Optional[Callable],
):
    return Lemmatizer(
        nlp.vocab, model, name, mode=mode, overwrite=overwrite, scorer=scorer
    )


</source>
<source file="systems/spaCy-3.2.3/spacy/lang/el/__init__.py" startline="39" endline="51" pcid="1918">
def make_lemmatizer(
    nlp: Language,
    model: Optional[Model],
    name: str,
    mode: str,
    overwrite: bool,
    scorer: Optional[Callable],
):
    return GreekLemmatizer(
        nlp.vocab, model, name, mode=mode, overwrite=overwrite, scorer=scorer
    )


</source>
<source file="systems/spaCy-3.2.3/spacy/lang/nl/__init__.py" startline="41" endline="53" pcid="1822">
def make_lemmatizer(
    nlp: Language,
    model: Optional[Model],
    name: str,
    mode: str,
    overwrite: bool,
    scorer: Optional[Callable],
):
    return DutchLemmatizer(
        nlp.vocab, model, name, mode=mode, overwrite=overwrite, scorer=scorer
    )


</source>
<source file="systems/spaCy-3.2.3/spacy/lang/bn/__init__.py" startline="34" endline="46" pcid="1875">
def make_lemmatizer(
    nlp: Language,
    model: Optional[Model],
    name: str,
    mode: str,
    overwrite: bool,
    scorer: Optional[Callable],
):
    return Lemmatizer(
        nlp.vocab, model, name, mode=mode, overwrite=overwrite, scorer=scorer
    )


</source>
<source file="systems/spaCy-3.2.3/spacy/lang/ru/__init__.py" startline="33" endline="45" pcid="1886">
def make_lemmatizer(
    nlp: Language,
    model: Optional[Model],
    name: str,
    mode: str,
    overwrite: bool,
    scorer: Optional[Callable],
):
    return RussianLemmatizer(
        nlp.vocab, model, name, mode=mode, overwrite=overwrite, scorer=scorer
    )


</source>
<source file="systems/spaCy-3.2.3/spacy/lang/en/__init__.py" startline="37" endline="49" pcid="1924">
def make_lemmatizer(
    nlp: Language,
    model: Optional[Model],
    name: str,
    mode: str,
    overwrite: bool,
    scorer: Optional[Callable],
):
    return EnglishLemmatizer(
        nlp.vocab, model, name, mode=mode, overwrite=overwrite, scorer=scorer
    )


</source>
<source file="systems/spaCy-3.2.3/spacy/lang/fa/__init__.py" startline="37" endline="49" pcid="1877">
def make_lemmatizer(
    nlp: Language,
    model: Optional[Model],
    name: str,
    mode: str,
    overwrite: bool,
    scorer: Optional[Callable],
):
    return Lemmatizer(
        nlp.vocab, model, name, mode=mode, overwrite=overwrite, scorer=scorer
    )


</source>
</class>

<class classid="16" nclones="7" nlines="13" similarity="100">
<source file="systems/spaCy-3.2.3/spacy/lang/ky/lex_attrs.py" startline="33" endline="47" pcid="1804">
def like_num(text):
    if text.startswith(("+", "-", "±", "~")):
        text = text[1:]
    text = text.replace(",", "").replace(".", "")
    if text.isdigit():
        return True
    if text.count("/") == 1:
        num, denom = text.split("/")
        if num.isdigit() and denom.isdigit():
            return True
    if text in _num_words:
        return True
    return False


</source>
<source file="systems/spaCy-3.2.3/spacy/lang/tt/lex_attrs.py" startline="43" endline="57" pcid="1835">
def like_num(text):
    if text.startswith(("+", "-", "±", "~")):
        text = text[1:]
    text = text.replace(",", "").replace(".", "")
    if text.isdigit():
        return True
    if text.count("/") == 1:
        num, denom = text.split("/")
        if num.isdigit() and denom.isdigit():
            return True
    if text in _num_words:
        return True
    return False


</source>
<source file="systems/spaCy-3.2.3/spacy/lang/sa/lex_attrs.py" startline="109" endline="126" pcid="1872">
def like_num(text):
    """
    Check if text resembles a number
    """
    if text.startswith(("+", "-", "±", "~")):
        text = text[1:]
    text = text.replace(",", "").replace(".", "")
    if text.isdigit():
        return True
    if text.count("/") == 1:
        num, denom = text.split("/")
        if num.isdigit() and denom.isdigit():
            return True
    if text in _num_words:
        return True
    return False


</source>
<source file="systems/spaCy-3.2.3/spacy/lang/fi/lex_attrs.py" startline="41" endline="55" pcid="1934">
def like_num(text):
    if text.startswith(("+", "-", "±", "~")):
        text = text[1:]
    text = text.replace(".", "").replace(",", "")
    if text.isdigit():
        return True
    if text.count("/") == 1:
        num, denom = text.split("/")
        if num.isdigit() and denom.isdigit():
            return True
    if text in _num_words:
        return True
    return False


</source>
<source file="systems/spaCy-3.2.3/spacy/lang/th/lex_attrs.py" startline="44" endline="58" pcid="1926">
def like_num(text):
    if text.startswith(("+", "-", "±", "~")):
        text = text[1:]
    text = text.replace(",", "").replace(".", "")
    if text.isdigit():
        return True
    if text.count("/") == 1:
        num, denom = text.split("/")
        if num.isdigit() and denom.isdigit():
            return True
    if text in _num_words:
        return True
    return False


</source>
<source file="systems/spaCy-3.2.3/spacy/lang/ml/lex_attrs.py" startline="59" endline="76" pcid="1806">
def like_num(text):
    """
    Check if text resembles a number
    """
    if text.startswith(("+", "-", "±", "~")):
        text = text[1:]
    text = text.replace(",", "").replace(".", "")
    if text.isdigit():
        return True
    if text.count("/") == 1:
        num, denom = text.split("/")
        if num.isdigit() and denom.isdigit():
            return True
    if text in _num_words:
        return True
    return False


</source>
<source file="systems/spaCy-3.2.3/spacy/lang/ca/lex_attrs.py" startline="44" endline="58" pcid="1862">
def like_num(text):
    if text.startswith(("+", "-", "±", "~")):
        text = text[1:]
    text = text.replace(",", "").replace(".", "")
    if text.isdigit():
        return True
    if text.count("/") == 1:
        num, denom = text.split("/")
        if num.isdigit() and denom.isdigit():
            return True
    if text in _num_words:
        return True
    return False


</source>
</class>

<class classid="17" nclones="4" nlines="15" similarity="100">
<source file="systems/spaCy-3.2.3/spacy/lang/ar/lex_attrs.py" startline="77" endline="96" pcid="1805">
def like_num(text):
    """
    Check if text resembles a number
    """
    if text.startswith(("+", "-", "±", "~")):
        text = text[1:]
    text = text.replace(",", "").replace(".", "")
    if text.isdigit():
        return True
    if text.count("/") == 1:
        num, denom = text.split("/")
        if num.isdigit() and denom.isdigit():
            return True
    if text in _num_words:
        return True
    if text in _ordinal_words:
        return True
    return False


</source>
<source file="systems/spaCy-3.2.3/spacy/lang/ur/lex_attrs.py" startline="28" endline="44" pcid="1897">
def like_num(text):
    if text.startswith(("+", "-", "±", "~")):
        text = text[1:]
    text = text.replace(",", "").replace(".", "")
    if text.isdigit():
        return True
    if text.count("/") == 1:
        num, denom = text.split("/")
        if num.isdigit() and denom.isdigit():
            return True
    if text in _num_words:
        return True
    if text in _ordinal_words:
        return True
    return False


</source>
<source file="systems/spaCy-3.2.3/spacy/lang/eu/lex_attrs.py" startline="59" endline="75" pcid="1834">
def like_num(text):
    if text.startswith(("+", "-", "±", "~")):
        text = text[1:]
    text = text.replace(",", "").replace(".", "")
    if text.isdigit():
        return True
    if text.count("/") == 1:
        num, denom = text.split("/")
        if num.isdigit() and denom.isdigit():
            return True
    if text in _num_words:
        return True
    if text in _ordinal_words:
        return True
    return False


</source>
<source file="systems/spaCy-3.2.3/spacy/lang/he/lex_attrs.py" startline="74" endline="94" pcid="1933">
def like_num(text):
    if text.startswith(("+", "-", "±", "~")):
        text = text[1:]
    text = text.replace(",", "").replace(".", "")
    if text.isdigit():
        return True

    if text.count("/") == 1:
        num, denom = text.split("/")
        if num.isdigit() and denom.isdigit():
            return True

    if text in _num_words:
        return True

    # Check ordinal number
    if text in _ordinal_words:
        return True
    return False


</source>
</class>

<class classid="18" nclones="3" nlines="24" similarity="100">
<source file="systems/spaCy-3.2.3/spacy/lang/id/syntax_iterators.py" startline="8" endline="40" pcid="1809">
def noun_chunks(doclike: Union[Doc, Span]) -> Iterator[Tuple[int, int, int]]:
    """
    Detect base noun phrases from a dependency parse. Works on both Doc and Span.
    """
    # fmt: off
    labels = ["nsubj", "nsubj:pass", "obj", "iobj", "ROOT", "appos", "nmod", "nmod:poss"]
    # fmt: on
    doc = doclike.doc  # Ensure works on both Doc and Span.
    if not doc.has_annotation("DEP"):
        raise ValueError(Errors.E029)
    np_deps = [doc.vocab.strings[label] for label in labels]
    conj = doc.vocab.strings.add("conj")
    np_label = doc.vocab.strings.add("NP")
    prev_end = -1
    for i, word in enumerate(doclike):
        if word.pos not in (NOUN, PROPN, PRON):
            continue
        # Prevent nested chunks from being produced
        if word.left_edge.i <= prev_end:
            continue
        if word.dep in np_deps:
            prev_end = word.right_edge.i
            yield word.left_edge.i, word.right_edge.i + 1, np_label
        elif word.dep == conj:
            head = word.head
            while head.dep == conj and head.head.i < head.i:
                head = head.head
            # If the head is an NP, and we're coordinated to it, we're an NP
            if head.dep in np_deps:
                prev_end = word.right_edge.i
                yield word.left_edge.i, word.right_edge.i + 1, np_label


</source>
<source file="systems/spaCy-3.2.3/spacy/lang/nb/syntax_iterators.py" startline="8" endline="38" pcid="1815">
def noun_chunks(doclike: Union[Doc, Span]) -> Iterator[Tuple[int, int, int]]:
    """Detect base noun phrases from a dependency parse. Works on Doc and Span."""
    # fmt: off
    labels = ["nsubj", "nsubj:pass", "obj", "iobj", "ROOT", "appos", "nmod", "nmod:poss"]
    # fmt: on
    doc = doclike.doc  # Ensure works on both Doc and Span.
    if not doc.has_annotation("DEP"):
        raise ValueError(Errors.E029)
    np_deps = [doc.vocab.strings[label] for label in labels]
    conj = doc.vocab.strings.add("conj")
    np_label = doc.vocab.strings.add("NP")
    prev_end = -1
    for i, word in enumerate(doclike):
        if word.pos not in (NOUN, PROPN, PRON):
            continue
        # Prevent nested chunks from being produced
        if word.left_edge.i <= prev_end:
            continue
        if word.dep in np_deps:
            prev_end = word.right_edge.i
            yield word.left_edge.i, word.right_edge.i + 1, np_label
        elif word.dep == conj:
            head = word.head
            while head.dep == conj and head.head.i < head.i:
                head = head.head
            # If the head is an NP, and we're coordinated to it, we're an NP
            if head.dep in np_deps:
                prev_end = word.right_edge.i
                yield word.left_edge.i, word.right_edge.i + 1, np_label


</source>
<source file="systems/spaCy-3.2.3/spacy/lang/fr/syntax_iterators.py" startline="8" endline="38" pcid="1890">
def noun_chunks(doclike: Union[Doc, Span]) -> Iterator[Tuple[int, int, int]]:
    """Detect base noun phrases from a dependency parse. Works on Doc and Span."""
    # fmt: off
    labels = ["nsubj", "nsubj:pass", "obj", "iobj", "ROOT", "appos", "nmod", "nmod:poss"]
    # fmt: on
    doc = doclike.doc  # Ensure works on both Doc and Span.
    if not doc.has_annotation("DEP"):
        raise ValueError(Errors.E029)
    np_deps = [doc.vocab.strings[label] for label in labels]
    conj = doc.vocab.strings.add("conj")
    np_label = doc.vocab.strings.add("NP")
    prev_end = -1
    for i, word in enumerate(doclike):
        if word.pos not in (NOUN, PROPN, PRON):
            continue
        # Prevent nested chunks from being produced
        if word.left_edge.i <= prev_end:
            continue
        if word.dep in np_deps:
            prev_end = word.right_edge.i
            yield word.left_edge.i, word.right_edge.i + 1, np_label
        elif word.dep == conj:
            head = word.head
            while head.dep == conj and head.head.i < head.i:
                head = head.head
            # If the head is an NP, and we're coordinated to it, we're an NP
            if head.dep in np_deps:
                prev_end = word.right_edge.i
                yield word.left_edge.i, word.right_edge.i + 1, np_label


</source>
</class>

<class classid="19" nclones="3" nlines="11" similarity="100">
<source file="systems/spaCy-3.2.3/spacy/lang/si/lex_attrs.py" startline="48" endline="60" pcid="1811">
def like_num(text):
    text = text.replace(",", "").replace(".", "")
    if text.isdigit():
        return True
    if text.count("/") == 1:
        num, denom = text.split("/")
        if num.isdigit() and denom.isdigit():
            return True
    if text.lower() in _num_words:
        return True
    return False


</source>
<source file="systems/spaCy-3.2.3/spacy/lang/pl/lex_attrs.py" startline="53" endline="65" pcid="1870">
def like_num(text):
    text = text.replace(",", "").replace(".", "")
    if text.isdigit():
        return True
    if text.count("/") == 1:
        num, denom = text.split("/")
        if num.isdigit() and denom.isdigit():
            return True
    if text.lower() in _num_words:
        return True
    return False


</source>
<source file="systems/spaCy-3.2.3/spacy/lang/te/lex_attrs.py" startline="41" endline="53" pcid="1925">
def like_num(text):
    text = text.replace(",", "").replace(".", "")
    if text.isdigit():
        return True
    if text.count("/") == 1:
        num, denom = text.split("/")
        if num.isdigit() and denom.isdigit():
            return True
    if text.lower() in _num_words:
        return True
    return False


</source>
</class>

<class classid="20" nclones="3" nlines="19" similarity="100">
<source file="systems/spaCy-3.2.3/spacy/lang/tn/lex_attrs.py" startline="82" endline="106" pcid="1814">
def like_num(text):
    if text.startswith(("+", "-", "±", "~")):
        text = text[1:]
    text = text.replace(",", "").replace(".", "")
    if text.isdigit():
        return True
    if text.count("/") == 1:
        num, denom = text.split("/")
        if num.isdigit() and denom.isdigit():
            return True

    text_lower = text.lower()
    if text_lower in _num_words:
        return True

    # CHeck ordinal number
    if text_lower in _ordinal_words:
        return True
    if text_lower.endswith("th"):
        if text_lower[:-2].isdigit():
            return True

    return False


</source>
<source file="systems/spaCy-3.2.3/spacy/lang/ti/lex_attrs.py" startline="48" endline="72" pcid="1892">
def like_num(text):
    if text.startswith(("+", "-", "±", "~")):
        text = text[1:]
    text = text.replace(",", "").replace(".", "")
    if text.isdigit():
        return True
    if text.count("/") == 1:
        num, denom = text.split("/")
        if num.isdigit() and denom.isdigit():
            return True

    text_lower = text.lower()
    if text_lower in _num_words:
        return True

    # Check ordinal number
    if text_lower in _ordinal_words:
        return True
    if text_lower.endswith("ይ"):
        if text_lower[:-2].isdigit():
            return True

    return False


</source>
<source file="systems/spaCy-3.2.3/spacy/lang/am/lex_attrs.py" startline="77" endline="101" pcid="1893">
def like_num(text):
    if text.startswith(("+", "-", "±", "~")):
        text = text[1:]
    text = text.replace(",", "").replace(".", "")
    if text.isdigit():
        return True
    if text.count("/") == 1:
        num, denom = text.split("/")
        if num.isdigit() and denom.isdigit():
            return True

    text_lower = text.lower()
    if text_lower in _num_words:
        return True

    # Check ordinal number
    if text_lower in _ordinal_words:
        return True
    if text_lower.endswith("ኛ"):
        if text_lower[:-2].isdigit():
            return True

    return False


</source>
</class>

<class classid="21" nclones="2" nlines="11" similarity="100">
<source file="systems/spaCy-3.2.3/spacy/lang/uk/lex_attrs.py" startline="57" endline="69" pcid="1832">
def like_num(text):
    text = text.replace(",", "").replace(".", "")
    if text.isdigit():
        return True
    if text.count("/") == 1:
        num, denom = text.split("/")
        if num.isdigit() and denom.isdigit():
            return True
    if text in _num_words:
        return True
    return False


</source>
<source file="systems/spaCy-3.2.3/spacy/lang/tl/lex_attrs.py" startline="44" endline="56" pcid="1919">
def like_num(text):
    text = text.replace(",", "").replace(".", "")
    if text.isdigit():
        return True
    if text.count("/") == 1:
        num, denom = text.split("/")
        if num.isdigit() and denom.isdigit():
            return True
    if text in _num_words:
        return True
    return False


</source>
</class>

<class classid="22" nclones="3" nlines="15" similarity="100">
<source file="systems/spaCy-3.2.3/spacy/lang/ro/lex_attrs.py" startline="26" endline="42" pcid="1858">
def like_num(text):
    if text.startswith(("+", "-", "±", "~")):
        text = text[1:]
    text = text.replace(",", "").replace(".", "")
    if text.isdigit():
        return True
    if text.count("/") == 1:
        num, denom = text.split("/")
        if num.isdigit() and denom.isdigit():
            return True
    if text.lower() in _num_words:
        return True
    if text.lower() in _ordinal_words:
        return True
    return False


</source>
<source file="systems/spaCy-3.2.3/spacy/lang/fr/lex_attrs.py" startline="25" endline="43" pcid="1889">
def like_num(text):
    # Might require more work?
    # See this discussion: https://github.com/explosion/spaCy/pull/1161
    if text.startswith(("+", "-", "±", "~")):
        text = text[1:]
    text = text.replace(",", "").replace(".", "")
    if text.isdigit():
        return True
    if text.count("/") == 1:
        num, denom = text.split("/")
        if num.isdigit() and denom.isdigit():
            return True
    if text.lower() in _num_words:
        return True
    if text.lower() in _ordinal_words:
        return True
    return False


</source>
<source file="systems/spaCy-3.2.3/spacy/lang/da/lex_attrs.py" startline="34" endline="50" pcid="1879">
def like_num(text):
    if text.startswith(("+", "-", "±", "~")):
        text = text[1:]
    text = text.replace(",", "").replace(".", "")
    if text.isdigit():
        return True
    if text.count("/") == 1:
        num, denom = text.split("/")
        if num.isdigit() and denom.isdigit():
            return True
    if text.lower() in _num_words:
        return True
    if text.lower() in _ordinal_words:
        return True
    return False


</source>
</class>

<class classid="23" nclones="2" nlines="56" similarity="100">
<source file="systems/spaCy-3.2.3/spacy/lang/ca/lemmatizer.py" startline="26" endline="81" pcid="1861">
    def rule_lemmatize(self, token: Token) -> List[str]:
        cache_key = (token.orth, token.pos)
        if cache_key in self.cache:
            return self.cache[cache_key]
        string = token.text
        univ_pos = token.pos_.lower()
        if univ_pos in ("", "eol", "space"):
            return [string.lower()]
        elif "lemma_rules" not in self.lookups or univ_pos not in (
            "noun",
            "verb",
            "adj",
            "adp",
            "adv",
            "aux",
            "cconj",
            "det",
            "pron",
            "punct",
            "sconj",
        ):
            return self.lookup_lemmatize(token)
        index_table = self.lookups.get_table("lemma_index", {})
        exc_table = self.lookups.get_table("lemma_exc", {})
        rules_table = self.lookups.get_table("lemma_rules", {})
        lookup_table = self.lookups.get_table("lemma_lookup", {})
        index = index_table.get(univ_pos, {})
        exceptions = exc_table.get(univ_pos, {})
        rules = rules_table.get(univ_pos, [])
        string = string.lower()
        forms = []
        if string in index:
            forms.append(string)
            self.cache[cache_key] = forms
            return forms
        forms.extend(exceptions.get(string, []))
        oov_forms = []
        if not forms:
            for old, new in rules:
                if string.endswith(old):
                    form = string[: len(string) - len(old)] + new
                    if not form:
                        pass
                    elif form in index or not form.isalpha():
                        forms.append(form)
                    else:
                        oov_forms.append(form)
        if not forms:
            forms.extend(oov_forms)
        if not forms and string in lookup_table.keys():
            forms.append(self.lookup_lemmatize(token)[0])
        if not forms:
            forms.append(string)
        forms = list(dict.fromkeys(forms))
        self.cache[cache_key] = forms
        return forms
</source>
<source file="systems/spaCy-3.2.3/spacy/lang/fr/lemmatizer.py" startline="25" endline="80" pcid="1888">
    def rule_lemmatize(self, token: Token) -> List[str]:
        cache_key = (token.orth, token.pos)
        if cache_key in self.cache:
            return self.cache[cache_key]
        string = token.text
        univ_pos = token.pos_.lower()
        if univ_pos in ("", "eol", "space"):
            return [string.lower()]
        elif "lemma_rules" not in self.lookups or univ_pos not in (
            "noun",
            "verb",
            "adj",
            "adp",
            "adv",
            "aux",
            "cconj",
            "det",
            "pron",
            "punct",
            "sconj",
        ):
            return self.lookup_lemmatize(token)
        index_table = self.lookups.get_table("lemma_index", {})
        exc_table = self.lookups.get_table("lemma_exc", {})
        rules_table = self.lookups.get_table("lemma_rules", {})
        lookup_table = self.lookups.get_table("lemma_lookup", {})
        index = index_table.get(univ_pos, {})
        exceptions = exc_table.get(univ_pos, {})
        rules = rules_table.get(univ_pos, [])
        string = string.lower()
        forms = []
        if string in index:
            forms.append(string)
            self.cache[cache_key] = forms
            return forms
        forms.extend(exceptions.get(string, []))
        oov_forms = []
        if not forms:
            for old, new in rules:
                if string.endswith(old):
                    form = string[: len(string) - len(old)] + new
                    if not form:
                        pass
                    elif form in index or not form.isalpha():
                        forms.append(form)
                    else:
                        oov_forms.append(form)
        if not forms:
            forms.extend(oov_forms)
        if not forms and string in lookup_table.keys():
            forms.append(self.lookup_lemmatize(token)[0])
        if not forms:
            forms.append(string)
        forms = list(dict.fromkeys(forms))
        self.cache[cache_key] = forms
        return forms
</source>
</class>

<class classid="24" nclones="2" nlines="10" similarity="100">
<source file="systems/spaCy-3.2.3/spacy/lang/pl/lemmatizer.py" startline="75" endline="86" pcid="1869">
    def lemmatize_noun(
        self, string: str, morphology: dict, lookup_table: Dict[str, str]
    ) -> List[str]:
        # this method is case-sensitive, in order to work
        # for incorrectly tagged proper names
        if string != string.lower():
            if string.lower() in lookup_table:
                return [lookup_table[string.lower()]]
            elif string in lookup_table:
                return [lookup_table[string]]
            return [string.lower()]
        return [lookup_table.get(string, string)]
</source>
<source file="systems/spaCy-3.2.3/spacy/lang/it/lemmatizer.py" startline="121" endline="132" pcid="1904">
    def lemmatize_noun(
        self, string: str, morphology: dict, lookup_table: Dict[str, str]
    ) -> List[str]:
        # this method is case-sensitive, in order to work
        # for incorrectly tagged proper names
        if string != string.lower():
            if string.lower() in lookup_table:
                return [lookup_table[string.lower()]]
            elif string in lookup_table:
                return [lookup_table[string]]
            return [string.lower()]
        return [lookup_table.get(string, string)]
</source>
</class>

<class classid="25" nclones="2" nlines="19" similarity="100">
<source file="systems/spaCy-3.2.3/spacy/lang/az/lex_attrs.py" startline="66" endline="88" pcid="1896">
def like_num(text):
    if text.startswith(("+", "-", "±", "~")):
        text = text[1:]
    text = text.replace(",", "").replace(".", "")
    if text.isdigit():
        return True
    if text.count("/") == 1:
        num, denom = text.split("/")
        if num.isdigit() and denom.isdigit():
            return True
    text_lower = text.lower()
    # Check cardinal number
    if text_lower in _num_words:
        return True
    # Check ordinal number
    if text_lower in _ordinal_words:
        return True
    if text_lower.endswith(_ordinal_endings):
        if text_lower[:-3].isdigit() or text_lower[:-4].isdigit():
            return True
    return False


</source>
<source file="systems/spaCy-3.2.3/spacy/lang/tr/lex_attrs.py" startline="66" endline="88" pcid="1910">
def like_num(text):
    if text.startswith(("+", "-", "±", "~")):
        text = text[1:]
    text = text.replace(",", "").replace(".", "")
    if text.isdigit():
        return True
    if text.count("/") == 1:
        num, denom = text.split("/")
        if num.isdigit() and denom.isdigit():
            return True
    text_lower = text.lower()
    # Check cardinal number
    if text_lower in _num_words:
        return True
    # Check ordinal number
    if text_lower in _ordinal_words:
        return True
    if text_lower.endswith(_ordinal_endings):
        if text_lower[:-3].isdigit() or text_lower[:-4].isdigit():
            return True
    return False


</source>
</class>

</clones>
