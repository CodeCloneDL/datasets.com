<clones>
<systeminfo processor="nicad6" system="ipython-8.1.1" granularity="functions-blind" threshold="30%" minlines="10" maxlines="2500"/>
<cloneinfo npcs="1420" npairs="16"/>
<runinfo ncompares="26485" cputime="50121"/>
<classinfo nclasses="14"/>

<class classid="1" nclones="2" nlines="15" similarity="70">
<source file="systems/ipython-8.1.1/IPython/utils/tests/test_tokenutil.py" startline="45" endline="58" pcid="261">
def test_multiline():
    cell = '\n'.join([
        'a = 5',
        'b = hello("string", there)'
    ])
    expected = 'hello'
    start = cell.index(expected) + 1
    for i in range(start, start + len(expected)):
        expect_token(expected, cell, i)
    expected = 'hello'
    start = cell.index(expected) + 1
    for i in range(start, start + len(expected)):
        expect_token(expected, cell, i)

</source>
<source file="systems/ipython-8.1.1/IPython/utils/tests/test_tokenutil.py" startline="59" endline="77" pcid="262">
def test_multiline_token():
    cell = '\n'.join([
        '"""\n\nxxxxxxxxxx\n\n"""',
        '5, """',
        'docstring',
        'multiline token',
        '""", [',
        '2, 3, "complicated"]',
        'b = hello("string", there)'
    ])
    expected = 'hello'
    start = cell.index(expected) + 1
    for i in range(start, start + len(expected)):
        expect_token(expected, cell, i)
    expected = 'hello'
    start = cell.index(expected) + 1
    for i in range(start, start + len(expected)):
        expect_token(expected, cell, i)

</source>
</class>

<class classid="2" nclones="2" nlines="14" similarity="78">
<source file="systems/ipython-8.1.1/IPython/utils/tests/test_tokenutil.py" startline="78" endline="92" pcid="263">
def test_nested_call():
    cell = "foo(bar(a=5), b=10)"
    expected = 'foo'
    start = cell.index('bar') + 1
    for i in range(start, start + 3):
        expect_token(expected, cell, i)
    expected = 'bar'
    start = cell.index('a=')
    for i in range(start, start + 3):
        expect_token(expected, cell, i)
    expected = 'foo'
    start = cell.index(')') + 1
    for i in range(start, len(cell)-1):
        expect_token(expected, cell, i)

</source>
<source file="systems/ipython-8.1.1/IPython/utils/tests/test_tokenutil.py" startline="93" endline="107" pcid="264">
def test_attrs():
    cell = "a = obj.attr.subattr"
    expected = 'obj'
    idx = cell.find('obj') + 1
    for i in range(idx, idx + 3):
        expect_token(expected, cell, i)
    idx = cell.find('.attr') + 2
    expected = 'obj.attr'
    for i in range(idx, idx + 4):
        expect_token(expected, cell, i)
    idx = cell.find('.subattr') + 2
    expected = 'obj.attr.subattr'
    for i in range(idx, len(cell)):
        expect_token(expected, cell, i)

</source>
</class>

<class classid="3" nclones="2" nlines="14" similarity="85">
<source file="systems/ipython-8.1.1/IPython/utils/tests/test_wildcard.py" startline="51" endline="65" pcid="270">
    def test_case(self):
        ns=root.__dict__
        tests=[
         ("a*",     ["abbot","abel","active","arna",]),
         ("?b*.?o*",["abbot.koppel","abbot.loop","abel.koppel","abel.loop",]),
         ("_a*",    []),
         ("_*anka", ["__anka",]),
         ("_*a*",   ["__anka",]),
        ]
        for pat,res in tests:
            res.sort()
            a=sorted(wildcard.list_namespace(ns,"all",pat,ignore_case=False,
                                             show_all=False).keys())
            self.assertEqual(a,res)

</source>
<source file="systems/ipython-8.1.1/IPython/utils/tests/test_wildcard.py" startline="66" endline="81" pcid="271">
    def test_case_showall(self):
        ns=root.__dict__
        tests=[
         ("a*",     ["abbot","abel","active","arna",]),
         ("?b*.?o*",["abbot.koppel","abbot.loop","abel.koppel","abel.loop",]),
         ("_a*",    ["_apan"]),
         ("_*anka", ["__anka",]),
         ("_*a*",   ["__anka","_apan",]),
        ]
        for pat,res in tests:
            res.sort()
            a=sorted(wildcard.list_namespace(ns,"all",pat,ignore_case=False,
                                             show_all=True).keys())
            self.assertEqual(a,res)


</source>
</class>

<class classid="4" nclones="2" nlines="16" similarity="81">
<source file="systems/ipython-8.1.1/IPython/utils/tests/test_wildcard.py" startline="82" endline="97" pcid="272">
    def test_nocase(self):
        ns=root.__dict__
        tests=[
         ("a*",     ["abbot","abel","ABEL","active","arna",]),
         ("?b*.?o*",["abbot.koppel","abbot.loop","abel.koppel","abel.loop",
                     "ABEL.koppel","ABEL.loop",]),
         ("_a*",    []),
         ("_*anka", ["__anka","__ANKA",]),
         ("_*a*",   ["__anka","__ANKA",]),
        ]
        for pat,res in tests:
            res.sort()
            a=sorted(wildcard.list_namespace(ns,"all",pat,ignore_case=True,
                                             show_all=False).keys())
            self.assertEqual(a,res)

</source>
<source file="systems/ipython-8.1.1/IPython/utils/tests/test_wildcard.py" startline="98" endline="114" pcid="273">
    def test_nocase_showall(self):
        ns=root.__dict__
        tests=[
         ("a*",     ["abbot","abel","ABEL","active","arna",]),
         ("?b*.?o*",["abbot.koppel","abbot.loop","abel.koppel","abel.loop",
                     "ABEL.koppel","ABEL.loop",]),
         ("_a*",    ["_apan","_APAN"]),
         ("_*anka", ["__anka","__ANKA",]),
         ("_*a*",   ["__anka","__ANKA","_apan","_APAN"]),
        ]
        for pat,res in tests:
            res.sort()
            a=sorted(wildcard.list_namespace(ns,"all",pat,ignore_case=True,
                                             show_all=True).keys())
            a.sort()
            self.assertEqual(a,res)
            
</source>
</class>

<class classid="5" nclones="2" nlines="13" similarity="92">
<source file="systems/ipython-8.1.1/IPython/lib/tests/test_display.py" startline="117" endline="134" pcid="549">


def test_existing_path_FileLinks_alt_formatter():
    """FileLinks: Calling _repr_html_ functions as expected w/ an alt formatter
    """
    td = mkdtemp()
    tf1 = NamedTemporaryFile(dir=td)
    tf2 = NamedTemporaryFile(dir=td)
    def fake_formatter(dirname,fnames,included_suffixes):
        return ["hello","world"]
    fl = display.FileLinks(td,notebook_display_formatter=fake_formatter)
    actual = fl._repr_html_()
    actual = actual.split('\n')
    actual.sort()
    expected = ["hello","world"]
    expected.sort()
    # We compare the sorted list of links here as that's more reliable
    assert actual == expected
</source>
<source file="systems/ipython-8.1.1/IPython/lib/tests/test_display.py" startline="150" endline="167" pcid="552">


def test_existing_path_FileLinks_repr_alt_formatter():
    """FileLinks: Calling repr() functions as expected w/ alt formatter
    """
    td = mkdtemp()
    tf1 = NamedTemporaryFile(dir=td)
    tf2 = NamedTemporaryFile(dir=td)
    def fake_formatter(dirname,fnames,included_suffixes):
        return ["hello","world"]
    fl = display.FileLinks(td,terminal_display_formatter=fake_formatter)
    actual = repr(fl)
    actual = actual.split('\n')
    actual.sort()
    expected = ["hello","world"]
    expected.sort()
    # We compare the sorted list of links here as that's more reliable
    assert actual == expected
</source>
</class>

<class classid="6" nclones="2" nlines="16" similarity="81">
<source file="systems/ipython-8.1.1/IPython/lib/pretty.py" startline="625" endline="646" pcid="618">

def _seq_pprinter_factory(start, end):
    """
    Factory that returns a pprint function useful for sequences.  Used by
    the default pprint for tuples and lists.
    """
    def inner(obj, p, cycle):
        if cycle:
            return p.text(start + '...' + end)
        step = len(start)
        p.begin_group(step, start)
        for idx, x in p._enumerate(obj):
            if idx:
                p.text(',')
                p.breakable()
            p.pretty(x)
        if len(obj) == 1 and isinstance(obj, tuple):
            # Special case for 1-item tuples.
            p.text(',')
        p.end_group(step, end)
    return inner

</source>
<source file="systems/ipython-8.1.1/IPython/lib/pretty.py" startline="674" endline="695" pcid="622">

def _dict_pprinter_factory(start, end):
    """
    Factory that returns a pprint function used by the default pprint of
    dicts and dict proxies.
    """
    def inner(obj, p, cycle):
        if cycle:
            return p.text('{...}')
        step = len(start)
        p.begin_group(step, start)
        keys = obj.keys()
        for idx, key in p._enumerate(keys):
            if idx:
                p.text(',')
                p.breakable()
            p.pretty(key)
            p.text(': ')
            p.pretty(obj[key])
        p.end_group(step, end)
    return inner

</source>
</class>

<class classid="7" nclones="2" nlines="11" similarity="72">
<source file="systems/ipython-8.1.1/IPython/core/tests/test_run.py" startline="394" endline="410" pcid="940">
    def test_run_nb(self):
        """Test %run notebook.ipynb"""
        pytest.importorskip("nbformat")
        from nbformat import v4, writes
        nb = v4.new_notebook(
           cells=[
                v4.new_markdown_cell("The Ultimate Question of Everything"),
                v4.new_code_cell("answer=42")
            ]
        )
        src = writes(nb, version=4)
        self.mktmp(src, ext='.ipynb')

        _ip.magic("run %s" % self.fname)

        assert _ip.user_ns["answer"] == 42

</source>
<source file="systems/ipython-8.1.1/IPython/core/tests/test_run.py" startline="411" endline="431" pcid="941">
    def test_run_nb_error(self):
        """Test %run notebook.ipynb error"""
        pytest.importorskip("nbformat")
        from nbformat import v4, writes

        # %run when a file name isn't provided
        pytest.raises(Exception, _ip.magic, "run")

        # %run when a file doesn't exist
        pytest.raises(Exception, _ip.magic, "run foobar.ipynb")

        # %run on a notebook with an error
        nb = v4.new_notebook(
           cells=[
                v4.new_code_cell("0/0")
            ]
        )
        src = writes(nb, version=4)
        self.mktmp(src, ext='.ipynb')
        pytest.raises(Exception, _ip.magic, "run %s" % self.fname)

</source>
</class>

<class classid="8" nclones="2" nlines="19" similarity="76">
<source file="systems/ipython-8.1.1/IPython/core/tests/test_run.py" startline="549" endline="574" pcid="958">
def test_run_tb():
    """Test traceback offset in %run"""
    with TemporaryDirectory() as td:
        path = pjoin(td, "foo.py")
        with open(path, "w", encoding="utf-8") as f:
            f.write(
                "\n".join(
                    [
                        "def foo():",
                        "    return bar()",
                        "def bar():",
                        "    raise RuntimeError('hello!')",
                        "foo()",
                    ]
                )
            )
        with capture_output() as io:
            _ip.magic('run {}'.format(path))
        out = io.stdout
        assert "execfile" not in out
        assert "RuntimeError" in out
        assert out.count("---->") == 3
        del ip.user_ns['bar']
        del ip.user_ns['foo']


</source>
<source file="systems/ipython-8.1.1/IPython/core/tests/test_run.py" startline="603" endline="622" pcid="960">
def test_script_tb():
    """Test traceback offset in `ipython script.py`"""
    with TemporaryDirectory() as td:
        path = pjoin(td, "foo.py")
        with open(path, "w", encoding="utf-8") as f:
            f.write(
                "\n".join(
                    [
                        "def foo():",
                        "    return bar()",
                        "def bar():",
                        "    raise RuntimeError('hello!')",
                        "foo()",
                    ]
                )
            )
        out, err = tt.ipexec(path)
        assert "execfile" not in out
        assert "RuntimeError" in out
        assert out.count("---->") == 3
</source>
</class>

<class classid="9" nclones="2" nlines="15" similarity="70">
<source file="systems/ipython-8.1.1/IPython/core/tests/test_displayhook.py" startline="58" endline="84" pcid="976">
def test_interactivehooks_ast_modes():
    """
    Test that ast nodes can be triggered with different modes
    """
    saved_mode = ip.ast_node_interactivity
    ip.ast_node_interactivity = 'last_expr_or_assign'

    try:
        with AssertPrints('2'):
            ip.run_cell('a = 1+1', store_history=True)

        with AssertPrints('9'):
            ip.run_cell('b = 1+8 # comment with a semicolon;', store_history=False)

        with AssertPrints('7'):
            ip.run_cell('c = 1+6\n#commented_out_function();', store_history=True)

        ip.run_cell('d = 11', store_history=True)
        with AssertPrints('12'):
            ip.run_cell('d += 1', store_history=True)

        with AssertNotPrints('42'):
            ip.run_cell('(u,v) = (41+1, 43-1)')

    finally:
        ip.ast_node_interactivity = saved_mode

</source>
<source file="systems/ipython-8.1.1/IPython/core/tests/test_displayhook.py" startline="85" endline="105" pcid="977">
def test_interactivehooks_ast_modes_semi_suppress():
    """
    Test that ast nodes can be triggered with different modes and suppressed
    by semicolon
    """
    saved_mode = ip.ast_node_interactivity
    ip.ast_node_interactivity = 'last_expr_or_assign'

    try:
        with AssertNotPrints('2'):
            ip.run_cell('x = 1+1;', store_history=True)

        with AssertNotPrints('7'):
            ip.run_cell('y = 1+6; # comment with a semicolon', store_history=True)

        with AssertNotPrints('9'):
            ip.run_cell('z = 1+8;\n#commented_out_function()', store_history=True)

    finally:
        ip.ast_node_interactivity = saved_mode

</source>
</class>

<class classid="10" nclones="2" nlines="32" similarity="75">
<source file="systems/ipython-8.1.1/IPython/core/tests/test_debugger.py" startline="246" endline="311" pcid="1015">
def test_xmode_skip():
    """that xmode skip frames

    Not as a doctest as pytest does not run doctests.
    """
    import pexpect
    env = os.environ.copy()
    env["IPY_TEST_SIMPLE_PROMPT"] = "1"

    child = pexpect.spawn(
        sys.executable, ["-m", "IPython", "--colors=nocolor"], env=env
    )
    child.timeout = 15 * IPYTHON_TESTING_TIMEOUT_SCALE

    child.expect("IPython")
    child.expect("\n")
    child.expect_exact("In [1]")

    block = dedent(
        """
    def f():
        __tracebackhide__ = True
        g()

    def g():
        raise ValueError

    f()
    """
    )

    for line in block.splitlines():
        child.sendline(line)
        child.expect_exact(line)
    child.expect_exact("skipping")

    block = dedent(
        """
    def f():
        __tracebackhide__ = True
        g()

    def g():
        from IPython.core.debugger import set_trace
        set_trace()

    f()
    """
    )

    for line in block.splitlines():
        child.sendline(line)
        child.expect_exact(line)

    child.expect("ipdb>")
    child.sendline("w")
    child.expect("hidden")
    child.expect("ipdb>")
    child.sendline("skip_hidden false")
    child.sendline("w")
    child.expect("__traceba")
    child.expect("ipdb>")

    child.close()


</source>
<source file="systems/ipython-8.1.1/IPython/core/tests/test_debugger.py" startline="504" endline="567" pcid="1020">
def test_where_erase_value():
    """Test that `where` does not access f_locals and erase values."""
    import pexpect

    env = os.environ.copy()
    env["IPY_TEST_SIMPLE_PROMPT"] = "1"

    child = pexpect.spawn(
        sys.executable, ["-m", "IPython", "--colors=nocolor"], env=env
    )
    child.timeout = 15 * IPYTHON_TESTING_TIMEOUT_SCALE

    child.expect("IPython")
    child.expect("\n")
    child.expect_exact("In [1]")

    block = dedent(
        """
    def simple_f():
         myvar = 1
         print(myvar)
         1/0
         print(myvar)
    simple_f()    """
    )

    for line in block.splitlines():
        child.sendline(line)
        child.expect_exact(line)
    child.expect_exact("ZeroDivisionError")
    child.expect_exact("In [2]:")

    child.sendline("%debug")

    ##
    child.expect("ipdb>")

    child.sendline("myvar")
    child.expect("1")

    ##
    child.expect("ipdb>")

    child.sendline("myvar = 2")

    ##
    child.expect_exact("ipdb>")

    child.sendline("myvar")

    child.expect_exact("2")

    ##
    child.expect("ipdb>")
    child.sendline("where")

    ##
    child.expect("ipdb>")
    child.sendline("myvar")

    child.expect_exact("2")
    child.expect("ipdb>")

    child.close()
</source>
</class>

<class classid="11" nclones="2" nlines="11" similarity="100">
<source file="systems/ipython-8.1.1/IPython/core/tests/test_inputtransformer2.py" startline="376" endline="390" pcid="1097">
def test_side_effects_I():
    count = 0
    def counter(lines):
        nonlocal count
        count += 1
        return lines

    counter.has_side_effects = True

    manager = ipt2.TransformerManager()
    manager.cleanup_transforms.insert(0, counter)
    assert manager.check_complete("a=1\n") == ('complete', None)
    assert count == 0


</source>
<source file="systems/ipython-8.1.1/IPython/core/tests/test_inputtransformer2.py" startline="393" endline="405" pcid="1099">
def test_side_effects_II():
    count = 0
    def counter(lines):
        nonlocal count
        count += 1
        return lines

    counter.has_side_effects = True

    manager = ipt2.TransformerManager()
    manager.line_transforms.insert(0, counter)
    assert manager.check_complete("b=1\n") == ('complete', None)
    assert count == 0
</source>
</class>

<class classid="12" nclones="3" nlines="10" similarity="83">
<source file="systems/ipython-8.1.1/IPython/core/tests/test_inputsplitter.py" startline="170" endline="181" pcid="1132">
    def test_indent4(self):
        isp = self.isp
        # whitespace after ':' should not screw up indent level
        isp.push('if 1: \n    x=1')
        self.assertEqual(isp.get_indent_spaces(), 4)
        isp.push('y=2\n')
        self.assertEqual(isp.get_indent_spaces(), 0)
        isp.push('if 1:\t\n    x=1')
        self.assertEqual(isp.get_indent_spaces(), 4)
        isp.push('y=2\n')
        self.assertEqual(isp.get_indent_spaces(), 0)

</source>
<source file="systems/ipython-8.1.1/IPython/core/tests/test_inputsplitter.py" startline="224" endline="237" pcid="1137">
    def test_dedent_return(self):
        isp = self.isp # shorthand
        # should NOT cause dedent
        isp.push('if 1:\n    returning = 4')
        self.assertEqual(isp.get_indent_spaces(), 4)
        isp.push('if 1:\n     return 5 + 493')
        self.assertEqual(isp.get_indent_spaces(), 0)
        isp.push('if 1:\n     return')
        self.assertEqual(isp.get_indent_spaces(), 0)
        isp.push('if 1:\n     return      ')
        self.assertEqual(isp.get_indent_spaces(), 0)
        isp.push('if 1:\n     return(0)')
        self.assertEqual(isp.get_indent_spaces(), 0)

</source>
<source file="systems/ipython-8.1.1/IPython/core/tests/test_inputsplitter.py" startline="212" endline="223" pcid="1136">
    def test_dedent_raise(self):
        isp = self.isp # shorthand
        # should NOT cause dedent
        isp.push('if 1:\n    raised = 4')
        self.assertEqual(isp.get_indent_spaces(), 4)
        isp.push('if 1:\n     raise TypeError()')
        self.assertEqual(isp.get_indent_spaces(), 0)
        isp.push('if 1:\n     raise')
        self.assertEqual(isp.get_indent_spaces(), 0)
        isp.push('if 1:\n     raise      ')
        self.assertEqual(isp.get_indent_spaces(), 0)

</source>
</class>

<class classid="13" nclones="2" nlines="15" similarity="70">
<source file="systems/ipython-8.1.1/IPython/core/tests/test_inputsplitter.py" startline="531" endline="545" pcid="1166">
def test_last_blank():
    assert isp.last_blank("") is False
    assert isp.last_blank("abc") is False
    assert isp.last_blank("abc\n") is False
    assert isp.last_blank("abc\na") is False

    assert isp.last_blank("\n") is True
    assert isp.last_blank("\n ") is True
    assert isp.last_blank("abc\n ") is True
    assert isp.last_blank("abc\n\n") is True
    assert isp.last_blank("abc\nd\n\n") is True
    assert isp.last_blank("abc\nd\ne\n\n") is True
    assert isp.last_blank("abc \n \n \n\n") is True


</source>
<source file="systems/ipython-8.1.1/IPython/core/tests/test_inputsplitter.py" startline="546" endline="565" pcid="1167">
def test_last_two_blanks():
    assert isp.last_two_blanks("") is False
    assert isp.last_two_blanks("abc") is False
    assert isp.last_two_blanks("abc\n") is False
    assert isp.last_two_blanks("abc\n\na") is False
    assert isp.last_two_blanks("abc\n \n") is False
    assert isp.last_two_blanks("abc\n\n") is False

    assert isp.last_two_blanks("\n\n") is True
    assert isp.last_two_blanks("\n\n ") is True
    assert isp.last_two_blanks("\n \n") is True
    assert isp.last_two_blanks("abc\n\n ") is True
    assert isp.last_two_blanks("abc\n\n\n") is True
    assert isp.last_two_blanks("abc\n\n \n") is True
    assert isp.last_two_blanks("abc\n\n \n ") is True
    assert isp.last_two_blanks("abc\n\n \n \n") is True
    assert isp.last_two_blanks("abc\nd\n\n\n") is True
    assert isp.last_two_blanks("abc\nd\ne\nf\n\n\n") is True


</source>
</class>

<class classid="14" nclones="2" nlines="12" similarity="100">
<source file="systems/ipython-8.1.1/IPython/terminal/shortcuts.py" startline="96" endline="110" pcid="1319">
    def preceding_text(pattern):
        try:
            return _preceding_text_cache[pattern]
        except KeyError:
            pass
        m = re.compile(pattern)

        def _preceding_text():
            app = get_app()
            return bool(m.match(app.current_buffer.document.current_line_before_cursor))

        condition = Condition(_preceding_text)
        _preceding_text_cache[pattern] = condition
        return condition

</source>
<source file="systems/ipython-8.1.1/IPython/terminal/shortcuts.py" startline="111" endline="126" pcid="1321">
    def following_text(pattern):
        try:
            return _following_text_cache[pattern]
        except KeyError:
            pass
        m = re.compile(pattern)

        def _following_text():
            app = get_app()
            return bool(m.match(app.current_buffer.document.current_line_after_cursor))

        condition = Condition(_following_text)
        _following_text_cache[pattern] = condition
        return condition

    # auto match
</source>
</class>

</clones>
