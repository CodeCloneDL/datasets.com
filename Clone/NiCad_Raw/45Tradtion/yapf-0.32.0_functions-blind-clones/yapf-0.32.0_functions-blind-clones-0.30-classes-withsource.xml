<clones>
<systeminfo processor="nicad6" system="yapf-0.32.0" granularity="functions-blind" threshold="30%" minlines="10" maxlines="2500"/>
<cloneinfo npcs="754" npairs="197"/>
<runinfo ncompares="4231" cputime="62329"/>
<classinfo nclasses="13"/>

<class classid="1" nclones="23" nlines="11" similarity="71">
<source file="systems/yapf-0.32.0/yapftests/reformatter_pep8_test.py" startline="240" endline="272" pcid="13">
  def testSplittingBeforeLogicalOperator(self):
    try:
      style.SetGlobalStyle(
          style.CreateStyleFromConfig(
              '{based_on_style: pep8, split_before_logical_operator: True}'))
      unformatted_code = textwrap.dedent("""\
          def foo():
              return bool(update.message.new_chat_member or update.message.left_chat_member or
                          update.message.new_chat_title or update.message.new_chat_photo or
                          update.message.delete_chat_photo or update.message.group_chat_created or
                          update.message.supergroup_chat_created or update.message.channel_chat_created
                          or update.message.migrate_to_chat_id or update.message.migrate_from_chat_id or
                          update.message.pinned_message)
          """)  # noqa
      expected_formatted_code = textwrap.dedent("""\
          def foo():
              return bool(
                  update.message.new_chat_member or update.message.left_chat_member
                  or update.message.new_chat_title or update.message.new_chat_photo
                  or update.message.delete_chat_photo
                  or update.message.group_chat_created
                  or update.message.supergroup_chat_created
                  or update.message.channel_chat_created
                  or update.message.migrate_to_chat_id
                  or update.message.migrate_from_chat_id
                  or update.message.pinned_message)
          """)  # noqa
      llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
      self.assertCodeEqual(expected_formatted_code,
                           reformatter.Reformat(llines))
    finally:
      style.SetGlobalStyle(style.CreatePEP8Style())

</source>
<source file="systems/yapf-0.32.0/yapftests/reformatter_python3_test.py" startline="284" endline="353" pcid="182">
  def testSplittingArguments(self):
    if sys.version_info[1] < 5:
      return

    unformatted_code = """\
async def open_file(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None):
    pass

async def run_sync_in_worker_thread(sync_fn, *args, cancellable=False, limiter=None):
    pass

def open_file(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None):
    pass

def run_sync_in_worker_thread(sync_fn, *args, cancellable=False, limiter=None):
    pass
"""  # noqa
    expected_formatted_code = """\
async def open_file(
    file,
    mode='r',
    buffering=-1,
    encoding=None,
    errors=None,
    newline=None,
    closefd=True,
    opener=None
):
    pass


async def run_sync_in_worker_thread(
    sync_fn, *args, cancellable=False, limiter=None
):
    pass


def open_file(
    file,
    mode='r',
    buffering=-1,
    encoding=None,
    errors=None,
    newline=None,
    closefd=True,
    opener=None
):
    pass


def run_sync_in_worker_thread(sync_fn, *args, cancellable=False, limiter=None):
    pass
"""

    try:
      style.SetGlobalStyle(
          style.CreateStyleFromConfig(
              '{based_on_style: pep8, '
              'dedent_closing_brackets: true, '
              'coalesce_brackets: false, '
              'space_between_ending_comma_and_closing_bracket: false, '
              'split_arguments_when_comma_terminated: true, '
              'split_before_first_argument: true}'))

      llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
      self.assertCodeEqual(expected_formatted_code,
                           reformatter.Reformat(llines))
    finally:
      style.SetGlobalStyle(style.CreatePEP8Style())

</source>
<source file="systems/yapf-0.32.0/yapftests/reformatter_basic_test.py" startline="3111" endline="3124" pcid="328">
  def testForceMultilineDict_False(self):
    try:
      style.SetGlobalStyle(
          style.CreateStyleFromConfig('{force_multiline_dict: false}'))
      unformatted_code = textwrap.dedent("""\
        responseDict = {'childDict': {'spam': 'eggs'}}
      """)
      expected_formatted_code = unformatted_code
      llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
      self.assertCodeEqual(expected_formatted_code,
                           reformatter.Reformat(llines))
    finally:
      style.SetGlobalStyle(style.CreateYapfStyle())

</source>
<source file="systems/yapf-0.32.0/yapftests/reformatter_basic_test.py" startline="2735" endline="2770" pcid="316">
  def testCoalesceBracketsOnDict(self):
    """Tests coalesce_brackets on a dictionary."""
    unformatted_code = textwrap.dedent("""\
        date_time_values = (
            {
                u'year': year,
                u'month': month,
                u'day_of_month': day_of_month,
                u'hours': hours,
                u'minutes': minutes,
                u'seconds': seconds
            }
        )
        """)
    expected_formatted_code = textwrap.dedent("""\
        date_time_values = ({
            u'year': year,
            u'month': month,
            u'day_of_month': day_of_month,
            u'hours': hours,
            u'minutes': minutes,
            u'seconds': seconds
        })
        """)

    try:
      style.SetGlobalStyle(
          style.CreateStyleFromConfig(
              '{based_on_style: yapf, coalesce_brackets: True}'))

      llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
      self.assertCodeEqual(expected_formatted_code,
                           reformatter.Reformat(llines))
    finally:
      style.SetGlobalStyle(style.CreateYapfStyle())

</source>
<source file="systems/yapf-0.32.0/yapftests/reformatter_basic_test.py" startline="2709" endline="2734" pcid="315">
  def testSplittingBeforeFirstArgumentOnCompoundStatement(self):
    """Tests split_before_first_argument on a compound statement."""
    unformatted_code = textwrap.dedent("""\
        if (long_argument_name_1 == 1 or
            long_argument_name_2 == 2 or
            long_argument_name_3 == 3 or
            long_argument_name_4 == 4):
          pass
        """)
    expected_formatted_code = textwrap.dedent("""\
        if (long_argument_name_1 == 1 or long_argument_name_2 == 2 or
            long_argument_name_3 == 3 or long_argument_name_4 == 4):
          pass
        """)

    try:
      style.SetGlobalStyle(
          style.CreateStyleFromConfig(
              '{based_on_style: yapf, split_before_first_argument: True}'))

      llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
      self.assertCodeEqual(expected_formatted_code,
                           reformatter.Reformat(llines))
    finally:
      style.SetGlobalStyle(style.CreateYapfStyle())

</source>
<source file="systems/yapf-0.32.0/yapftests/reformatter_basic_test.py" startline="2685" endline="2708" pcid="314">
  def testSplittingBeforeFirstArgumentOnFunctionDefinition(self):
    """Tests split_before_first_argument on a function definition."""
    unformatted_code = textwrap.dedent("""\
        def _GetNumberOfSecondsFromElements(year, month, day, hours,
                                            minutes, seconds, microseconds):
          return
        """)
    expected_formatted_code = textwrap.dedent("""\
        def _GetNumberOfSecondsFromElements(
            year, month, day, hours, minutes, seconds, microseconds):
          return
        """)

    try:
      style.SetGlobalStyle(
          style.CreateStyleFromConfig(
              '{based_on_style: yapf, split_before_first_argument: True}'))

      llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
      self.assertCodeEqual(expected_formatted_code,
                           reformatter.Reformat(llines))
    finally:
      style.SetGlobalStyle(style.CreateYapfStyle())

</source>
<source file="systems/yapf-0.32.0/yapftests/reformatter_basic_test.py" startline="2663" endline="2684" pcid="313">
  def testSplittingBeforeFirstArgumentOnFunctionCall(self):
    """Tests split_before_first_argument on a function call."""
    unformatted_code = textwrap.dedent("""\
        a_very_long_function_name("long string with formatting {0:s}".format(
            "mystring"))
        """)
    expected_formatted_code = textwrap.dedent("""\
        a_very_long_function_name(
            "long string with formatting {0:s}".format("mystring"))
        """)

    try:
      style.SetGlobalStyle(
          style.CreateStyleFromConfig(
              '{based_on_style: yapf, split_before_first_argument: True}'))

      llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
      self.assertCodeEqual(expected_formatted_code,
                           reformatter.Reformat(llines))
    finally:
      style.SetGlobalStyle(style.CreateYapfStyle())

</source>
<source file="systems/yapf-0.32.0/yapftests/reformatter_pep8_test.py" startline="557" endline="597" pcid="25">
  def testNoBlankLineBeforeNestedFuncOrClass(self):
    try:
      style.SetGlobalStyle(
          style.CreateStyleFromConfig(
              '{based_on_style: pep8, '
              'blank_line_before_nested_class_or_def: false}'))

      unformatted_code = '''\
def normal_function():
    """Return the nested function."""

    def nested_function():
        """Do nothing just nest within."""

        @nested(klass)
        class nested_class():
            pass

        pass

    return nested_function
'''
      expected_formatted_code = '''\
def normal_function():
    """Return the nested function."""
    def nested_function():
        """Do nothing just nest within."""
        @nested(klass)
        class nested_class():
            pass

        pass

    return nested_function
'''
      llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
      self.assertCodeEqual(expected_formatted_code,
                           reformatter.Reformat(llines))
    finally:
      style.SetGlobalStyle(style.CreatePEP8Style())

</source>
<source file="systems/yapf-0.32.0/yapftests/reformatter_python3_test.py" startline="151" endline="170" pcid="174">
  def testSpacesAroundDefaultOrNamedAssign(self):
    unformatted_code = textwrap.dedent("""\
        f(a=5)
        """)
    expected_formatted_code = textwrap.dedent("""\
        f(a = 5)
        """)

    try:
      style.SetGlobalStyle(
          style.CreateStyleFromConfig(
              '{based_on_style: pep8, '
              'SPACES_AROUND_DEFAULT_OR_NAMED_ASSIGN: True}'))

      llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
      self.assertCodeEqual(expected_formatted_code,
                           reformatter.Reformat(llines))
    finally:
      style.SetGlobalStyle(style.CreatePEP8Style())

</source>
<source file="systems/yapf-0.32.0/yapftests/reformatter_python3_test.py" startline="132" endline="150" pcid="173">
  def testNoSpacesAroundPowerOperator(self):
    unformatted_code = textwrap.dedent("""\
        a**b
        """)
    expected_formatted_code = textwrap.dedent("""\
        a ** b
        """)

    try:
      style.SetGlobalStyle(
          style.CreateStyleFromConfig(
              '{based_on_style: pep8, SPACES_AROUND_POWER_OPERATOR: True}'))

      llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
      self.assertCodeEqual(expected_formatted_code,
                           reformatter.Reformat(llines))
    finally:
      style.SetGlobalStyle(style.CreatePEP8Style())

</source>
<source file="systems/yapf-0.32.0/yapftests/reformatter_basic_test.py" startline="1912" endline="1946" pcid="286">
  def testMultilineLambdas(self):
    unformatted_code = textwrap.dedent("""\
        class SomeClass(object):
          do_something = True

          def succeeded(self, dddddddddddddd):
            d = defer.succeed(None)

            if self.do_something:
              d.addCallback(lambda _: self.aaaaaa.bbbbbbbbbbbbbbbb.cccccccccccccccccccccccccccccccc(dddddddddddddd))
            return d
        """)  # noqa
    expected_formatted_code = textwrap.dedent("""\
        class SomeClass(object):
          do_something = True

          def succeeded(self, dddddddddddddd):
            d = defer.succeed(None)

            if self.do_something:
              d.addCallback(lambda _: self.aaaaaa.bbbbbbbbbbbbbbbb.
                            cccccccccccccccccccccccccccccccc(dddddddddddddd))
            return d
        """)

    try:
      style.SetGlobalStyle(
          style.CreateStyleFromConfig(
              '{based_on_style: yapf, allow_multiline_lambdas: true}'))
      llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
      self.assertCodeEqual(expected_formatted_code,
                           reformatter.Reformat(llines))
    finally:
      style.SetGlobalStyle(style.CreateYapfStyle())

</source>
<source file="systems/yapf-0.32.0/yapftests/reformatter_pep8_test.py" startline="522" endline="542" pcid="23">
  def testSplitBeforeArithmeticOperators(self):
    try:
      style.SetGlobalStyle(
          style.CreateStyleFromConfig(
              '{based_on_style: pep8, split_before_arithmetic_operator: true}'))

      unformatted_code = """\
def _():
    raise ValueError('This is a long message that ends with an argument: ' + str(42))
"""  # noqa
      expected_formatted_code = """\
def _():
    raise ValueError('This is a long message that ends with an argument: '
                     + str(42))
"""
      llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
      self.assertCodeEqual(expected_formatted_code,
                           reformatter.Reformat(llines))
    finally:
      style.SetGlobalStyle(style.CreatePEP8Style())

</source>
<source file="systems/yapf-0.32.0/yapftests/reformatter_pep8_test.py" startline="288" endline="309" pcid="15">
  def testSplittingBeforeFirstArgument(self):
    try:
      style.SetGlobalStyle(
          style.CreateStyleFromConfig(
              '{based_on_style: pep8, split_before_first_argument: True}'))
      unformatted_code = textwrap.dedent("""\
          a_very_long_function_name(long_argument_name_1=1, long_argument_name_2=2,
                                    long_argument_name_3=3, long_argument_name_4=4)
          """)  # noqa
      expected_formatted_code = textwrap.dedent("""\
          a_very_long_function_name(
              long_argument_name_1=1,
              long_argument_name_2=2,
              long_argument_name_3=3,
              long_argument_name_4=4)
          """)
      llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
      self.assertCodeEqual(expected_formatted_code,
                           reformatter.Reformat(llines))
    finally:
      style.SetGlobalStyle(style.CreatePEP8Style())

</source>
<source file="systems/yapf-0.32.0/yapftests/reformatter_basic_test.py" startline="2963" endline="2997" pcid="324">
  def testIndentClosingBracketsInList(self):
    unformatted_code = textwrap.dedent("""\
        def function():
          some_var = ['a long element', 'another long element', 'short element', 'really really long element']
          return True

        def function():
          some_var = ['a couple', 'small', 'elemens']
          return False
        """)  # noqa
    expected_formatted_code = textwrap.dedent("""\
        def function():
          some_var = [
              'a long element', 'another long element', 'short element',
              'really really long element'
              ]
          return True


        def function():
          some_var = ['a couple', 'small', 'elemens']
          return False
        """)

    try:
      style.SetGlobalStyle(
          style.CreateStyleFromConfig('{based_on_style: yapf,'
                                      ' indent_closing_brackets: True}'))

      llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
      self.assertCodeEqual(expected_formatted_code,
                           reformatter.Reformat(llines))
    finally:
      style.SetGlobalStyle(style.CreateYapfStyle())

</source>
<source file="systems/yapf-0.32.0/yapftests/reformatter_basic_test.py" startline="2860" endline="2892" pcid="321">
  def testIndentClosingBracketsWithTypeAnnotationExceedingLineLength(self):
    unformatted_code = textwrap.dedent("""\
        def function(first_argument_xxxxxxxxxxxxxxxx=(0,), second_argument=None) -> None:
          pass


        def function(first_argument_xxxxxxxxxxxxxxxxxxxxxxx=(0,), second_argument=None) -> None:
          pass
        """)  # noqa
    expected_formatted_code = textwrap.dedent("""\
        def function(
            first_argument_xxxxxxxxxxxxxxxx=(0,), second_argument=None
            ) -> None:
          pass


        def function(
            first_argument_xxxxxxxxxxxxxxxxxxxxxxx=(0,), second_argument=None
            ) -> None:
          pass
        """)  # noqa

    try:
      style.SetGlobalStyle(
          style.CreateStyleFromConfig('{based_on_style: yapf,'
                                      ' indent_closing_brackets: True}'))

      llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
      self.assertCodeEqual(expected_formatted_code,
                           reformatter.Reformat(llines))
    finally:
      style.SetGlobalStyle(style.CreateYapfStyle())

</source>
<source file="systems/yapf-0.32.0/yapftests/reformatter_basic_test.py" startline="2893" endline="2927" pcid="322">
  def testIndentClosingBracketsInFunctionCall(self):
    unformatted_code = textwrap.dedent("""\
        def function(first_argument_xxxxxxxxxxxxxxxx=(0,), second_argument=None, third_and_final_argument=True):
          pass


        def function(first_argument_xxxxxxxxxxxxxxxxxxxxxxx=(0,), second_and_last_argument=None):
          pass
        """)  # noqa
    expected_formatted_code = textwrap.dedent("""\
        def function(
            first_argument_xxxxxxxxxxxxxxxx=(0,),
            second_argument=None,
            third_and_final_argument=True
            ):
          pass


        def function(
            first_argument_xxxxxxxxxxxxxxxxxxxxxxx=(0,), second_and_last_argument=None
            ):
          pass
        """)  # noqa

    try:
      style.SetGlobalStyle(
          style.CreateStyleFromConfig('{based_on_style: yapf,'
                                      ' indent_closing_brackets: True}'))

      llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
      self.assertCodeEqual(expected_formatted_code,
                           reformatter.Reformat(llines))
    finally:
      style.SetGlobalStyle(style.CreateYapfStyle())

</source>
<source file="systems/yapf-0.32.0/yapftests/reformatter_basic_test.py" startline="2827" endline="2859" pcid="320">
  def testDedentClosingBracketsWithTypeAnnotationExceedingLineLength(self):
    unformatted_code = textwrap.dedent("""\
        def function(first_argument_xxxxxxxxxxxxxxxx=(0,), second_argument=None) -> None:
          pass


        def function(first_argument_xxxxxxxxxxxxxxxxxxxxxxx=(0,), second_argument=None) -> None:
          pass
        """)  # noqa
    expected_formatted_code = textwrap.dedent("""\
        def function(
            first_argument_xxxxxxxxxxxxxxxx=(0,), second_argument=None
        ) -> None:
          pass


        def function(
            first_argument_xxxxxxxxxxxxxxxxxxxxxxx=(0,), second_argument=None
        ) -> None:
          pass
        """)  # noqa

    try:
      style.SetGlobalStyle(
          style.CreateStyleFromConfig('{based_on_style: yapf,'
                                      ' dedent_closing_brackets: True}'))

      llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
      self.assertCodeEqual(expected_formatted_code,
                           reformatter.Reformat(llines))
    finally:
      style.SetGlobalStyle(style.CreateYapfStyle())

</source>
<source file="systems/yapf-0.32.0/yapftests/reformatter_basic_test.py" startline="1947" endline="1979" pcid="287">
  def testMultilineDictionaryKeys(self):
    unformatted_code = textwrap.dedent("""\
        MAP_WITH_LONG_KEYS = {
            ('lorem ipsum', 'dolor sit amet'):
                1,
            ('consectetur adipiscing elit.', 'Vestibulum mauris justo, ornare eget dolor eget'):
                2,
            ('vehicula convallis nulla. Vestibulum dictum nisl in malesuada finibus.',):
                3
        }
        """)  # noqa
    expected_formatted_code = textwrap.dedent("""\
        MAP_WITH_LONG_KEYS = {
            ('lorem ipsum', 'dolor sit amet'):
                1,
            ('consectetur adipiscing elit.',
             'Vestibulum mauris justo, ornare eget dolor eget'):
                2,
            ('vehicula convallis nulla. Vestibulum dictum nisl in malesuada finibus.',):
                3
        }
        """)  # noqa

    try:
      style.SetGlobalStyle(
          style.CreateStyleFromConfig('{based_on_style: yapf, '
                                      'allow_multiline_dictionary_keys: true}'))
      llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
      self.assertCodeEqual(expected_formatted_code,
                           reformatter.Reformat(llines))
    finally:
      style.SetGlobalStyle(style.CreateYapfStyle())

</source>
<source file="systems/yapf-0.32.0/yapftests/reformatter_basic_test.py" startline="2998" endline="3038" pcid="325">
  def testIndentClosingBracketsInDict(self):
    unformatted_code = textwrap.dedent("""\
        def function():
          some_var = {1: ('a long element', 'and another really really long element that is really really amazingly long'), 2: 'another long element', 3: 'short element', 4: 'really really long element'}
          return True

        def function():
          some_var = {1: 'a couple', 2: 'small', 3: 'elemens'}
          return False
        """)  # noqa
    expected_formatted_code = textwrap.dedent("""\
        def function():
          some_var = {
              1:
                  (
                      'a long element',
                      'and another really really long element that is really really amazingly long'
                      ),
              2: 'another long element',
              3: 'short element',
              4: 'really really long element'
              }
          return True


        def function():
          some_var = {1: 'a couple', 2: 'small', 3: 'elemens'}
          return False
        """)  # noqa

    try:
      style.SetGlobalStyle(
          style.CreateStyleFromConfig('{based_on_style: yapf,'
                                      ' indent_closing_brackets: True}'))

      llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
      self.assertCodeEqual(expected_formatted_code,
                           reformatter.Reformat(llines))
    finally:
      style.SetGlobalStyle(style.CreateYapfStyle())

</source>
<source file="systems/yapf-0.32.0/yapftests/reformatter_basic_test.py" startline="2928" endline="2962" pcid="323">
  def testIndentClosingBracketsInTuple(self):
    unformatted_code = textwrap.dedent("""\
        def function():
          some_var = ('a long element', 'another long element', 'short element', 'really really long element')
          return True

        def function():
          some_var = ('a couple', 'small', 'elemens')
          return False
        """)  # noqa
    expected_formatted_code = textwrap.dedent("""\
        def function():
          some_var = (
              'a long element', 'another long element', 'short element',
              'really really long element'
              )
          return True


        def function():
          some_var = ('a couple', 'small', 'elemens')
          return False
        """)  # noqa

    try:
      style.SetGlobalStyle(
          style.CreateStyleFromConfig('{based_on_style: yapf,'
                                      ' indent_closing_brackets: True}'))

      llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
      self.assertCodeEqual(expected_formatted_code,
                           reformatter.Reformat(llines))
    finally:
      style.SetGlobalStyle(style.CreateYapfStyle())

</source>
<source file="systems/yapf-0.32.0/yapftests/reformatter_basic_test.py" startline="2771" endline="2790" pcid="317">
  def testSplitAfterComment(self):
    code = textwrap.dedent("""\
        if __name__ == "__main__":
          with another_resource:
            account = {
                "validUntil":
                    int(time() + (6 * 7 * 24 * 60 * 60))  # in 6 weeks time
            }
        """)

    try:
      style.SetGlobalStyle(
          style.CreateStyleFromConfig(
              '{based_on_style: yapf, coalesce_brackets: True, '
              'dedent_closing_brackets: true}'))
      llines = yapf_test_helper.ParseAndUnwrap(code)
      self.assertCodeEqual(code, reformatter.Reformat(llines))
    finally:
      style.SetGlobalStyle(style.CreateYapfStyle())

</source>
<source file="systems/yapf-0.32.0/yapftests/reformatter_basic_test.py" startline="2469" endline="2528" pcid="306">
  def testBlankLineBeforeClassDocstring(self):
    unformatted_code = textwrap.dedent('''\
        class A:

          """Does something.

          Also, here are some details.
          """

          def __init__(self):
            pass
        ''')
    expected_code = textwrap.dedent('''\
        class A:
          """Does something.

          Also, here are some details.
          """

          def __init__(self):
            pass
        ''')
    llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
    self.assertCodeEqual(expected_code, reformatter.Reformat(llines))

    unformatted_code = textwrap.dedent('''\
        class A:

          """Does something.

          Also, here are some details.
          """

          def __init__(self):
            pass
        ''')
    expected_formatted_code = textwrap.dedent('''\
        class A:

          """Does something.

          Also, here are some details.
          """

          def __init__(self):
            pass
        ''')

    try:
      style.SetGlobalStyle(
          style.CreateStyleFromConfig(
              '{based_on_style: yapf, '
              'blank_line_before_class_docstring: True}'))

      llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
      self.assertCodeEqual(expected_formatted_code,
                           reformatter.Reformat(llines))
    finally:
      style.SetGlobalStyle(style.CreateYapfStyle())

</source>
<source file="systems/yapf-0.32.0/yapftests/reformatter_basic_test.py" startline="2529" endline="2583" pcid="307">
  def testBlankLineBeforeModuleDocstring(self):
    unformatted_code = textwrap.dedent('''\
        #!/usr/bin/env python
        # -*- coding: utf-8 name> -*-

        """Some module docstring."""


        def foobar():
          pass
        ''')
    expected_code = textwrap.dedent('''\
        #!/usr/bin/env python
        # -*- coding: utf-8 name> -*-
        """Some module docstring."""


        def foobar():
          pass
        ''')
    llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
    self.assertCodeEqual(expected_code, reformatter.Reformat(llines))

    unformatted_code = textwrap.dedent('''\
        #!/usr/bin/env python
        # -*- coding: utf-8 name> -*-
        """Some module docstring."""


        def foobar():
            pass
        ''')
    expected_formatted_code = textwrap.dedent('''\
        #!/usr/bin/env python
        # -*- coding: utf-8 name> -*-

        """Some module docstring."""


        def foobar():
            pass
        ''')

    try:
      style.SetGlobalStyle(
          style.CreateStyleFromConfig(
              '{based_on_style: pep8, '
              'blank_line_before_module_docstring: True}'))

      llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
      self.assertCodeEqual(expected_formatted_code,
                           reformatter.Reformat(llines))
    finally:
      style.SetGlobalStyle(style.CreateYapfStyle())

</source>
</class>

<class classid="2" nclones="3" nlines="10" similarity="70">
<source file="systems/yapf-0.32.0/yapftests/yapf_test.py" startline="445" endline="461" pcid="76">
  def testInPlaceReformatting(self):
    unformatted_code = textwrap.dedent(u"""\
        def foo():
          x = 37
        """)
    expected_formatted_code = textwrap.dedent("""\
        def foo():
            x = 37
        """)
    with utils.TempFileContents(
        self.test_tmpdir, unformatted_code, suffix='.py') as filepath:
      p = subprocess.Popen(YAPF_BINARY + ['--in-place', filepath])
      p.wait()
      with io.open(filepath, mode='r', newline='') as fd:
        reformatted_code = fd.read()
    self.assertEqual(reformatted_code, expected_formatted_code)

</source>
<source file="systems/yapf-0.32.0/yapftests/yapf_test.py" startline="462" endline="472" pcid="77">
  def testInPlaceReformattingBlank(self):
    unformatted_code = u'\n\n'
    expected_formatted_code = u'\n'
    with utils.TempFileContents(
        self.test_tmpdir, unformatted_code, suffix='.py') as filepath:
      p = subprocess.Popen(YAPF_BINARY + ['--in-place', filepath])
      p.wait()
      with io.open(filepath, mode='r', encoding='utf-8', newline='') as fd:
        reformatted_code = fd.read()
    self.assertEqual(reformatted_code, expected_formatted_code)

</source>
<source file="systems/yapf-0.32.0/yapftests/yapf_test.py" startline="473" endline="483" pcid="78">
  def testInPlaceReformattingEmpty(self):
    unformatted_code = u''
    expected_formatted_code = u''
    with utils.TempFileContents(
        self.test_tmpdir, unformatted_code, suffix='.py') as filepath:
      p = subprocess.Popen(YAPF_BINARY + ['--in-place', filepath])
      p.wait()
      with io.open(filepath, mode='r', encoding='utf-8', newline='') as fd:
        reformatted_code = fd.read()
    self.assertEqual(reformatted_code, expected_formatted_code)

</source>
</class>

<class classid="3" nclones="4" nlines="28" similarity="73">
<source file="systems/yapf-0.32.0/yapftests/reformatter_basic_test.py" startline="32" endline="108" pcid="192">
  def testSplittingAllArgs(self):
    style.SetGlobalStyle(
        style.CreateStyleFromConfig(
            '{split_all_comma_separated_values: true, column_limit: 40}'))
    unformatted_code = textwrap.dedent("""\
          responseDict = {"timestamp": timestamp, "someValue":   value, "whatever": 120}
          """)  # noqa
    expected_formatted_code = textwrap.dedent("""\
          responseDict = {
              "timestamp": timestamp,
              "someValue": value,
              "whatever": 120
          }
          """)
    llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
    self.assertCodeEqual(expected_formatted_code, reformatter.Reformat(llines))

    unformatted_code = textwrap.dedent("""\
          yes = { 'yes': 'no', 'no': 'yes', }
          """)
    expected_formatted_code = textwrap.dedent("""\
          yes = {
              'yes': 'no',
              'no': 'yes',
          }
          """)
    llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
    self.assertCodeEqual(expected_formatted_code, reformatter.Reformat(llines))
    unformatted_code = textwrap.dedent("""\
          def foo(long_arg, really_long_arg, really_really_long_arg, cant_keep_all_these_args):
                pass
          """)  # noqa
    expected_formatted_code = textwrap.dedent("""\
          def foo(long_arg,
                  really_long_arg,
                  really_really_long_arg,
                  cant_keep_all_these_args):
            pass
          """)
    llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
    self.assertCodeEqual(expected_formatted_code, reformatter.Reformat(llines))
    unformatted_code = textwrap.dedent("""\
          foo_tuple = [long_arg, really_long_arg, really_really_long_arg, cant_keep_all_these_args]
          """)  # noqa
    expected_formatted_code = textwrap.dedent("""\
          foo_tuple = [
              long_arg,
              really_long_arg,
              really_really_long_arg,
              cant_keep_all_these_args
          ]
          """)
    llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
    self.assertCodeEqual(expected_formatted_code, reformatter.Reformat(llines))
    unformatted_code = textwrap.dedent("""\
          foo_tuple = [short, arg]
          """)
    expected_formatted_code = textwrap.dedent("""\
          foo_tuple = [short, arg]
          """)
    llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
    self.assertCodeEqual(expected_formatted_code, reformatter.Reformat(llines))
    # There is a test for split_all_top_level_comma_separated_values, with
    # different expected value
    unformatted_code = textwrap.dedent("""\
          someLongFunction(this_is_a_very_long_parameter,
              abc=(a, this_will_just_fit_xxxxxxx))
          """)
    expected_formatted_code = textwrap.dedent("""\
          someLongFunction(
              this_is_a_very_long_parameter,
              abc=(a,
                   this_will_just_fit_xxxxxxx))
          """)
    llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
    self.assertCodeEqual(expected_formatted_code, reformatter.Reformat(llines))

</source>
<source file="systems/yapf-0.32.0/yapftests/reformatter_buganizer_test.py" startline="2263" endline="2325" pcid="523">
  def testB13900309(self):
    unformatted_code = textwrap.dedent("""\
        self.aaaaaaaaaaa(  # A comment in the middle of it all.
               948.0/3600, self.bbb.ccccccccccccccccccccc(dddddddddddddddd.eeee, True))
        """)  # noqa
    expected_formatted_code = textwrap.dedent("""\
        self.aaaaaaaaaaa(  # A comment in the middle of it all.
            948.0 / 3600, self.bbb.ccccccccccccccccccccc(dddddddddddddddd.eeee, True))
        """)  # noqa
    llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
    self.assertCodeEqual(expected_formatted_code, reformatter.Reformat(llines))

    code = textwrap.dedent("""\
        aaaaaaaaaa.bbbbbbbbbbbbbbbbbbbbbbbb.cccccccccccccccccccccccccccccc(
            DC_1, (CL - 50, CL), AAAAAAAA, BBBBBBBBBBBBBBBB, 98.0,
            CCCCCCC).ddddddddd(  # Look! A comment is here.
                AAAAAAAA - (20 * 60 - 5))
        """)
    llines = yapf_test_helper.ParseAndUnwrap(code)
    self.assertCodeEqual(code, reformatter.Reformat(llines))

    unformatted_code = textwrap.dedent("""\
        aaaaaaaaaaaaaaaaaaaaaaaa.bbbbbbbbbbbbb.ccccccccccccccccccccccccc().dddddddddddddddddddddddddd(1, 2, 3, 4)
        """)  # noqa
    expected_formatted_code = textwrap.dedent("""\
        aaaaaaaaaaaaaaaaaaaaaaaa.bbbbbbbbbbbbb.ccccccccccccccccccccccccc(
        ).dddddddddddddddddddddddddd(1, 2, 3, 4)
        """)
    llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
    self.assertCodeEqual(expected_formatted_code, reformatter.Reformat(llines))

    unformatted_code = textwrap.dedent("""\
        aaaaaaaaaaaaaaaaaaaaaaaa.bbbbbbbbbbbbb.ccccccccccccccccccccccccc(x).dddddddddddddddddddddddddd(1, 2, 3, 4)
        """)  # noqa
    expected_formatted_code = textwrap.dedent("""\
        aaaaaaaaaaaaaaaaaaaaaaaa.bbbbbbbbbbbbb.ccccccccccccccccccccccccc(
            x).dddddddddddddddddddddddddd(1, 2, 3, 4)
        """)
    llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
    self.assertCodeEqual(expected_formatted_code, reformatter.Reformat(llines))

    unformatted_code = textwrap.dedent("""\
        aaaaaaaaaaaaaaaaaaaaaaaa(xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx).dddddddddddddddddddddddddd(1, 2, 3, 4)
        """)  # noqa
    expected_formatted_code = textwrap.dedent("""\
        aaaaaaaaaaaaaaaaaaaaaaaa(
            xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx).dddddddddddddddddddddddddd(1, 2, 3, 4)
        """)  # noqa
    llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
    self.assertCodeEqual(expected_formatted_code, reformatter.Reformat(llines))

    unformatted_code = textwrap.dedent("""\
        aaaaaaaaaaaaaaaaaaaaaaaa().bbbbbbbbbbbbbbbbbbbbbbbb().ccccccccccccccccccc().\
dddddddddddddddddd().eeeeeeeeeeeeeeeeeeeee().fffffffffffffffff().gggggggggggggggggg()
        """)
    expected_formatted_code = textwrap.dedent("""\
        aaaaaaaaaaaaaaaaaaaaaaaa().bbbbbbbbbbbbbbbbbbbbbbbb().ccccccccccccccccccc(
        ).dddddddddddddddddd().eeeeeeeeeeeeeeeeeeeee().fffffffffffffffff(
        ).gggggggggggggggggg()
        """)
    llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
    self.assertCodeEqual(expected_formatted_code, reformatter.Reformat(llines))

</source>
<source file="systems/yapf-0.32.0/yapftests/reformatter_basic_test.py" startline="256" endline="344" pcid="195">
  def testBlankLinesBetweenTopLevelImportsAndVariables(self):
    unformatted_code = textwrap.dedent("""\
        import foo as bar
        VAR = 'baz'
        """)
    expected_formatted_code = textwrap.dedent("""\
        import foo as bar

        VAR = 'baz'
        """)
    llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
    self.assertCodeEqual(expected_formatted_code, reformatter.Reformat(llines))

    unformatted_code = textwrap.dedent("""\
        import foo as bar

        VAR = 'baz'
        """)
    expected_formatted_code = textwrap.dedent("""\
        import foo as bar


        VAR = 'baz'
        """)
    try:
      style.SetGlobalStyle(
          style.CreateStyleFromConfig(
              '{based_on_style: yapf, '
              'blank_lines_between_top_level_imports_and_variables: 2}'))
      llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
      self.assertCodeEqual(expected_formatted_code,
                           reformatter.Reformat(llines))
    finally:
      style.SetGlobalStyle(style.CreateYapfStyle())

    unformatted_code = textwrap.dedent("""\
        import foo as bar
        # Some comment
        """)
    expected_formatted_code = textwrap.dedent("""\
        import foo as bar
        # Some comment
        """)
    llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
    self.assertCodeEqual(expected_formatted_code, reformatter.Reformat(llines))

    unformatted_code = textwrap.dedent("""\
        import foo as bar
        class Baz():
          pass
        """)
    expected_formatted_code = textwrap.dedent("""\
        import foo as bar


        class Baz():
          pass
        """)
    llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
    self.assertCodeEqual(expected_formatted_code, reformatter.Reformat(llines))

    unformatted_code = textwrap.dedent("""\
        import foo as bar
        def foobar():
          pass
        """)
    expected_formatted_code = textwrap.dedent("""\
        import foo as bar


        def foobar():
          pass
        """)
    llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
    self.assertCodeEqual(expected_formatted_code, reformatter.Reformat(llines))

    unformatted_code = textwrap.dedent("""\
        def foobar():
          from foo import Bar
          Bar.baz()
        """)
    expected_formatted_code = textwrap.dedent("""\
        def foobar():
          from foo import Bar
          Bar.baz()
        """)
    llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
    self.assertCodeEqual(expected_formatted_code, reformatter.Reformat(llines))

</source>
<source file="systems/yapf-0.32.0/yapftests/reformatter_basic_test.py" startline="109" endline="226" pcid="193">
  def testSplittingTopLevelAllArgs(self):
    style.SetGlobalStyle(
        style.CreateStyleFromConfig(
            '{split_all_top_level_comma_separated_values: true, '
            'column_limit: 40}'))
    # Works the same way as split_all_comma_separated_values
    unformatted_code = textwrap.dedent("""\
          responseDict = {"timestamp": timestamp, "someValue":   value, "whatever": 120}
          """)  # noqa
    expected_formatted_code = textwrap.dedent("""\
          responseDict = {
              "timestamp": timestamp,
              "someValue": value,
              "whatever": 120
          }
          """)
    llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
    self.assertCodeEqual(expected_formatted_code, reformatter.Reformat(llines))
    # Works the same way as split_all_comma_separated_values
    unformatted_code = textwrap.dedent("""\
          def foo(long_arg, really_long_arg, really_really_long_arg, cant_keep_all_these_args):
                pass
          """)  # noqa
    expected_formatted_code = textwrap.dedent("""\
          def foo(long_arg,
                  really_long_arg,
                  really_really_long_arg,
                  cant_keep_all_these_args):
            pass
          """)
    llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
    self.assertCodeEqual(expected_formatted_code, reformatter.Reformat(llines))
    # Works the same way as split_all_comma_separated_values
    unformatted_code = textwrap.dedent("""\
          foo_tuple = [long_arg, really_long_arg, really_really_long_arg, cant_keep_all_these_args]
          """)  # noqa
    expected_formatted_code = textwrap.dedent("""\
          foo_tuple = [
              long_arg,
              really_long_arg,
              really_really_long_arg,
              cant_keep_all_these_args
          ]
          """)
    llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
    self.assertCodeEqual(expected_formatted_code, reformatter.Reformat(llines))
    # Works the same way as split_all_comma_separated_values
    unformatted_code = textwrap.dedent("""\
          foo_tuple = [short, arg]
          """)
    expected_formatted_code = textwrap.dedent("""\
          foo_tuple = [short, arg]
          """)
    llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
    self.assertCodeEqual(expected_formatted_code, reformatter.Reformat(llines))
    # There is a test for split_all_comma_separated_values, with different
    # expected value
    unformatted_code = textwrap.dedent("""\
          someLongFunction(this_is_a_very_long_parameter,
              abc=(a, this_will_just_fit_xxxxxxx))
          """)
    expected_formatted_code = textwrap.dedent("""\
          someLongFunction(
              this_is_a_very_long_parameter,
              abc=(a, this_will_just_fit_xxxxxxx))
          """)
    llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
    actual_formatted_code = reformatter.Reformat(llines)
    self.assertEqual(40, len(actual_formatted_code.splitlines()[-1]))
    self.assertCodeEqual(expected_formatted_code, actual_formatted_code)

    unformatted_code = textwrap.dedent("""\
          someLongFunction(this_is_a_very_long_parameter,
              abc=(a, this_will_not_fit_xxxxxxxxx))
          """)
    expected_formatted_code = textwrap.dedent("""\
          someLongFunction(
              this_is_a_very_long_parameter,
              abc=(a,
                   this_will_not_fit_xxxxxxxxx))
          """)
    llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
    self.assertCodeEqual(expected_formatted_code, reformatter.Reformat(llines))

    # Exercise the case where there's no opening bracket (for a, b)
    unformatted_code = textwrap.dedent("""\
          a, b = f(
              a_very_long_parameter, yet_another_one, and_another)
          """)
    expected_formatted_code = textwrap.dedent("""\
          a, b = f(
              a_very_long_parameter, yet_another_one, and_another)
          """)
    llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
    self.assertCodeEqual(expected_formatted_code, reformatter.Reformat(llines))

    # Don't require splitting before comments.
    unformatted_code = textwrap.dedent("""\
          KO = {
              'ABC': Abc, # abc
              'DEF': Def, # def
              'LOL': Lol, # wtf
              'GHI': Ghi,
              'JKL': Jkl,
          }
          """)
    expected_formatted_code = textwrap.dedent("""\
          KO = {
              'ABC': Abc,  # abc
              'DEF': Def,  # def
              'LOL': Lol,  # wtf
              'GHI': Ghi,
              'JKL': Jkl,
          }
          """)
    llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
    self.assertCodeEqual(expected_formatted_code, reformatter.Reformat(llines))

</source>
</class>

<class classid="4" nclones="4" nlines="13" similarity="76">
<source file="systems/yapf-0.32.0/yapftests/reformatter_basic_test.py" startline="1980" endline="2011" pcid="288">
  def testStableDictionaryFormatting(self):
    code = textwrap.dedent("""\
        class A(object):

          def method(self):
            filters = {
                'expressions': [{
                    'field': {
                        'search_field': {
                            'user_field': 'latest_party__number_of_guests'
                        },
                    }
                }]
            }
        """)  # noqa

    try:
      style.SetGlobalStyle(
          style.CreateStyleFromConfig('{based_on_style: pep8, indent_width: 2, '
                                      'continuation_indent_width: 4, '
                                      'indent_dictionary_value: True}'))

      llines = yapf_test_helper.ParseAndUnwrap(code)
      reformatted_code = reformatter.Reformat(llines)
      self.assertCodeEqual(code, reformatted_code)

      llines = yapf_test_helper.ParseAndUnwrap(reformatted_code)
      reformatted_code = reformatter.Reformat(llines)
      self.assertCodeEqual(code, reformatted_code)
    finally:
      style.SetGlobalStyle(style.CreateYapfStyle())

</source>
<source file="systems/yapf-0.32.0/yapftests/reformatter_basic_test.py" startline="2077" endline="2109" pcid="293">
  def testNoSplittingWhenBinPacking(self):
    code = textwrap.dedent("""\
        a_very_long_function_name(
            long_argument_name_1=1,
            long_argument_name_2=2,
            long_argument_name_3=3,
            long_argument_name_4=4,
        )

        a_very_long_function_name(
            long_argument_name_1=1, long_argument_name_2=2, long_argument_name_3=3,
            long_argument_name_4=4
        )
        """)  # noqa

    try:
      style.SetGlobalStyle(
          style.CreateStyleFromConfig(
              '{based_on_style: pep8, indent_width: 2, '
              'continuation_indent_width: 4, indent_dictionary_value: True, '
              'dedent_closing_brackets: True, '
              'split_before_named_assigns: False}'))

      llines = yapf_test_helper.ParseAndUnwrap(code)
      reformatted_code = reformatter.Reformat(llines)
      self.assertCodeEqual(code, reformatted_code)

      llines = yapf_test_helper.ParseAndUnwrap(reformatted_code)
      reformatted_code = reformatter.Reformat(llines)
      self.assertCodeEqual(code, reformatted_code)
    finally:
      style.SetGlobalStyle(style.CreateYapfStyle())

</source>
<source file="systems/yapf-0.32.0/yapftests/reformatter_basic_test.py" startline="2012" endline="2038" pcid="289">
  def testStableInlinedDictionaryFormatting(self):
    try:
      style.SetGlobalStyle(style.CreatePEP8Style())
      unformatted_code = textwrap.dedent("""\
          def _():
              url = "http://{0}/axis-cgi/admin/param.cgi?{1}".format(
                  value, urllib.urlencode({'action': 'update', 'parameter': value}))
          """)  # noqa
      expected_formatted_code = textwrap.dedent("""\
          def _():
              url = "http://{0}/axis-cgi/admin/param.cgi?{1}".format(
                  value, urllib.urlencode({
                      'action': 'update',
                      'parameter': value
                  }))
          """)

      llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
      reformatted_code = reformatter.Reformat(llines)
      self.assertCodeEqual(expected_formatted_code, reformatted_code)

      llines = yapf_test_helper.ParseAndUnwrap(reformatted_code)
      reformatted_code = reformatter.Reformat(llines)
      self.assertCodeEqual(expected_formatted_code, reformatted_code)
    finally:
      style.SetGlobalStyle(style.CreateYapfStyle())

</source>
<source file="systems/yapf-0.32.0/yapftests/reformatter_basic_test.py" startline="2176" endline="2232" pcid="297">
  def testSplittingArgumentsTerminatedByComma(self):
    unformatted_code = textwrap.dedent("""\
        function_name(argument_name_1=1, argument_name_2=2, argument_name_3=3)

        function_name(argument_name_1=1, argument_name_2=2, argument_name_3=3,)

        a_very_long_function_name(long_argument_name_1=1, long_argument_name_2=2, long_argument_name_3=3, long_argument_name_4=4)

        a_very_long_function_name(long_argument_name_1, long_argument_name_2, long_argument_name_3, long_argument_name_4,)

        r =f0 (1,  2,3,)
        """)  # noqa
    expected_formatted_code = textwrap.dedent("""\
        function_name(argument_name_1=1, argument_name_2=2, argument_name_3=3)

        function_name(
            argument_name_1=1,
            argument_name_2=2,
            argument_name_3=3,
        )

        a_very_long_function_name(
            long_argument_name_1=1,
            long_argument_name_2=2,
            long_argument_name_3=3,
            long_argument_name_4=4)

        a_very_long_function_name(
            long_argument_name_1,
            long_argument_name_2,
            long_argument_name_3,
            long_argument_name_4,
        )

        r = f0(
            1,
            2,
            3,
        )
        """)

    try:
      style.SetGlobalStyle(
          style.CreateStyleFromConfig(
              '{based_on_style: yapf, '
              'split_arguments_when_comma_terminated: True}'))

      llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
      reformatted_code = reformatter.Reformat(llines)
      self.assertCodeEqual(expected_formatted_code, reformatted_code)

      llines = yapf_test_helper.ParseAndUnwrap(reformatted_code)
      reformatted_code = reformatter.Reformat(llines)
      self.assertCodeEqual(expected_formatted_code, reformatted_code)
    finally:
      style.SetGlobalStyle(style.CreateYapfStyle())

</source>
</class>

<class classid="5" nclones="2" nlines="10" similarity="70">
<source file="systems/yapf-0.32.0/yapftests/comment_splicer_test.py" startline="236" endline="257" pcid="352">
  def testCommentsInClass(self):
    code = textwrap.dedent(r'''
      class Foo:
        """docstring abc..."""
        # top-level comment
        def foo(): pass
        # another comment
      ''')

    tree = pytree_utils.ParseCodeToTree(code)
    comment_splicer.SpliceComments(tree)

    class_suite = tree.children[0].children[3]
    another_comment = class_suite.children[-2]
    self._AssertNodeIsComment(another_comment, '# another')

    # It's OK for the comment to be a child of funcdef, as long as it's
    # the first child and thus comes before the 'def'.
    funcdef = class_suite.children[3]
    toplevel_comment = funcdef.children[0]
    self._AssertNodeIsComment(toplevel_comment, '# top-level')

</source>
<source file="systems/yapf-0.32.0/yapftests/comment_splicer_test.py" startline="277" endline="300" pcid="354">
  def testCommentsOnDedents(self):
    code = textwrap.dedent(r'''
        class Foo(object):
          # A comment for qux.
          def qux(self):
            pass

          # Interim comment.

          def mux(self):
            pass
        ''')

    tree = pytree_utils.ParseCodeToTree(code)
    comment_splicer.SpliceComments(tree)

    classdef = tree.children[0]
    class_suite = classdef.children[6]
    qux_comment = class_suite.children[1]
    self._AssertNodeIsComment(qux_comment, '# A comment for qux.')

    interim_comment = class_suite.children[4]
    self._AssertNodeIsComment(interim_comment, '# Interim comment.')

</source>
</class>

<class classid="6" nclones="2" nlines="32" similarity="82">
<source file="systems/yapf-0.32.0/yapftests/format_decision_state_test.py" startline="33" endline="86" pcid="526">
  def testSimpleFunctionDefWithNoSplitting(self):
    code = textwrap.dedent(r"""
      def f(a, b):
        pass
      """)
    llines = yapf_test_helper.ParseAndUnwrap(code)
    lline = logical_line.LogicalLine(0, _FilterLine(llines[0]))
    lline.CalculateFormattingInformation()

    # Add: 'f'
    state = format_decision_state.FormatDecisionState(lline, 0)
    state.MoveStateToNextToken()
    self.assertEqual('f', state.next_token.value)
    self.assertFalse(state.CanSplit(False))

    # Add: '('
    state.AddTokenToState(False, True)
    self.assertEqual('(', state.next_token.value)
    self.assertFalse(state.CanSplit(False))
    self.assertFalse(state.MustSplit())

    # Add: 'a'
    state.AddTokenToState(False, True)
    self.assertEqual('a', state.next_token.value)
    self.assertTrue(state.CanSplit(False))
    self.assertFalse(state.MustSplit())

    # Add: ','
    state.AddTokenToState(False, True)
    self.assertEqual(',', state.next_token.value)
    self.assertFalse(state.CanSplit(False))
    self.assertFalse(state.MustSplit())

    # Add: 'b'
    state.AddTokenToState(False, True)
    self.assertEqual('b', state.next_token.value)
    self.assertTrue(state.CanSplit(False))
    self.assertFalse(state.MustSplit())

    # Add: ')'
    state.AddTokenToState(False, True)
    self.assertEqual(')', state.next_token.value)
    self.assertTrue(state.CanSplit(False))
    self.assertFalse(state.MustSplit())

    # Add: ':'
    state.AddTokenToState(False, True)
    self.assertEqual(':', state.next_token.value)
    self.assertFalse(state.CanSplit(False))
    self.assertFalse(state.MustSplit())

    clone = state.Clone()
    self.assertEqual(repr(state), repr(clone))

</source>
<source file="systems/yapf-0.32.0/yapftests/format_decision_state_test.py" startline="87" endline="135" pcid="527">
  def testSimpleFunctionDefWithSplitting(self):
    code = textwrap.dedent(r"""
      def f(a, b):
        pass
      """)
    llines = yapf_test_helper.ParseAndUnwrap(code)
    lline = logical_line.LogicalLine(0, _FilterLine(llines[0]))
    lline.CalculateFormattingInformation()

    # Add: 'f'
    state = format_decision_state.FormatDecisionState(lline, 0)
    state.MoveStateToNextToken()
    self.assertEqual('f', state.next_token.value)
    self.assertFalse(state.CanSplit(False))

    # Add: '('
    state.AddTokenToState(True, True)
    self.assertEqual('(', state.next_token.value)
    self.assertFalse(state.CanSplit(False))

    # Add: 'a'
    state.AddTokenToState(True, True)
    self.assertEqual('a', state.next_token.value)
    self.assertTrue(state.CanSplit(False))

    # Add: ','
    state.AddTokenToState(True, True)
    self.assertEqual(',', state.next_token.value)
    self.assertFalse(state.CanSplit(False))

    # Add: 'b'
    state.AddTokenToState(True, True)
    self.assertEqual('b', state.next_token.value)
    self.assertTrue(state.CanSplit(False))

    # Add: ')'
    state.AddTokenToState(True, True)
    self.assertEqual(')', state.next_token.value)
    self.assertTrue(state.CanSplit(False))

    # Add: ':'
    state.AddTokenToState(True, True)
    self.assertEqual(':', state.next_token.value)
    self.assertFalse(state.CanSplit(False))

    clone = state.Clone()
    self.assertEqual(repr(state), repr(clone))


</source>
</class>

<class classid="7" nclones="4" nlines="13" similarity="73">
<source file="systems/yapf-0.32.0/yapftests/file_resources_test.py" startline="76" endline="92" pcid="535">
  def test_get_exclude_file_patterns_from_pyproject(self):
    try:
      import toml
    except ImportError:
      return
    local_ignore_file = os.path.join(self.test_tmpdir, 'pyproject.toml')
    ignore_patterns = ['temp/**/*.py', 'temp2/*.py']
    with open(local_ignore_file, 'w') as f:
      f.write('[tool.yapfignore]\n')
      f.write('ignore_patterns=[')
      f.writelines('\n,'.join(['"{}"'.format(p) for p in ignore_patterns]))
      f.write(']')

    self.assertEqual(
        sorted(file_resources.GetExcludePatternsForDir(self.test_tmpdir)),
        sorted(ignore_patterns))

</source>
<source file="systems/yapf-0.32.0/yapftests/file_resources_test.py" startline="123" endline="136" pcid="538">
  def test_get_exclude_file_patterns_from_pyproject_ignore_section_empty(self):
    try:
      import toml
    except ImportError:
      return
    local_ignore_file = os.path.join(self.test_tmpdir, 'pyproject.toml')
    ignore_patterns = []
    with open(local_ignore_file, 'w') as f:
      f.write('[tool.yapfignore]\n')

    self.assertEqual(
        sorted(file_resources.GetExcludePatternsForDir(self.test_tmpdir)),
        sorted(ignore_patterns))

</source>
<source file="systems/yapf-0.32.0/yapftests/file_resources_test.py" startline="94" endline="109" pcid="536">
  def test_get_exclude_file_patterns_from_pyproject_with_wrong_syntax(self):
    try:
      import toml
    except ImportError:
      return
    local_ignore_file = os.path.join(self.test_tmpdir, 'pyproject.toml')
    ignore_patterns = ['temp/**/*.py', './wrong/syntax/*.py']
    with open(local_ignore_file, 'w') as f:
      f.write('[tool.yapfignore]\n')
      f.write('ignore_patterns=[')
      f.writelines('\n,'.join(['"{}"'.format(p) for p in ignore_patterns]))
      f.write(']')

    with self.assertRaises(errors.YapfError):
      file_resources.GetExcludePatternsForDir(self.test_tmpdir)

</source>
<source file="systems/yapf-0.32.0/yapftests/file_resources_test.py" startline="110" endline="122" pcid="537">
  def test_get_exclude_file_patterns_from_pyproject_no_ignore_section(self):
    try:
      import toml
    except ImportError:
      return
    local_ignore_file = os.path.join(self.test_tmpdir, 'pyproject.toml')
    ignore_patterns = []
    open(local_ignore_file, 'w').close()

    self.assertEqual(
        sorted(file_resources.GetExcludePatternsForDir(self.test_tmpdir)),
        sorted(ignore_patterns))

</source>
</class>

<class classid="8" nclones="2" nlines="12" similarity="71">
<source file="systems/yapf-0.32.0/yapftests/file_resources_test.py" startline="177" endline="191" pcid="545">
  def test_setup_config(self):
    # An empty setup.cfg file should not be used
    setup_config = os.path.join(self.test_tmpdir, 'setup.cfg')
    open(setup_config, 'w').close()

    test_dir = os.path.join(self.test_tmpdir, 'dir1')
    style_name = file_resources.GetDefaultStyleForDir(test_dir)
    self.assertEqual(style_name, 'pep8')

    # One with a '[yapf]' section should be used
    with open(setup_config, 'w') as f:
      f.write('[yapf]\n')
    self.assertEqual(setup_config,
                     file_resources.GetDefaultStyleForDir(test_dir))

</source>
<source file="systems/yapf-0.32.0/yapftests/file_resources_test.py" startline="192" endline="211" pcid="546">
  def test_pyproject_toml(self):
    # An empty pyproject.toml file should not be used
    try:
      import toml
    except ImportError:
      return

    pyproject_toml = os.path.join(self.test_tmpdir, 'pyproject.toml')
    open(pyproject_toml, 'w').close()

    test_dir = os.path.join(self.test_tmpdir, 'dir1')
    style_name = file_resources.GetDefaultStyleForDir(test_dir)
    self.assertEqual(style_name, 'pep8')

    # One with a '[tool.yapf]' section should be used
    with open(pyproject_toml, 'w') as f:
      f.write('[tool.yapf]\n')
    self.assertEqual(pyproject_toml,
                     file_resources.GetDefaultStyleForDir(test_dir))

</source>
</class>

<class classid="9" nclones="3" nlines="17" similarity="73">
<source file="systems/yapf-0.32.0/yapftests/file_resources_test.py" startline="285" endline="301" pcid="555">
  def test_recursive_find_in_dir(self):
    tdir1 = self._make_test_dir('test1')
    tdir2 = self._make_test_dir('test2/testinner/')
    tdir3 = self._make_test_dir('test3/foo/bar/bas/xxx')
    files = [
        os.path.join(tdir1, 'testfile1.py'),
        os.path.join(tdir2, 'testfile2.py'),
        os.path.join(tdir3, 'testfile3.py'),
    ]
    _touch_files(files)

    self.assertEqual(
        sorted(
            file_resources.GetCommandLineFiles([self.test_tmpdir],
                                               recursive=True,
                                               exclude=None)), sorted(files))

</source>
<source file="systems/yapf-0.32.0/yapftests/file_resources_test.py" startline="302" endline="322" pcid="556">
  def test_recursive_find_in_dir_with_exclude(self):
    tdir1 = self._make_test_dir('test1')
    tdir2 = self._make_test_dir('test2/testinner/')
    tdir3 = self._make_test_dir('test3/foo/bar/bas/xxx')
    files = [
        os.path.join(tdir1, 'testfile1.py'),
        os.path.join(tdir2, 'testfile2.py'),
        os.path.join(tdir3, 'testfile3.py'),
    ]
    _touch_files(files)

    self.assertEqual(
        sorted(
            file_resources.GetCommandLineFiles([self.test_tmpdir],
                                               recursive=True,
                                               exclude=['*test*3.py'])),
        sorted([
            os.path.join(tdir1, 'testfile1.py'),
            os.path.join(tdir2, 'testfile2.py'),
        ]))

</source>
<source file="systems/yapf-0.32.0/yapftests/file_resources_test.py" startline="323" endline="344" pcid="557">
  def test_find_with_excluded_hidden_dirs(self):
    tdir1 = self._make_test_dir('.test1')
    tdir2 = self._make_test_dir('test_2')
    tdir3 = self._make_test_dir('test.3')
    files = [
        os.path.join(tdir1, 'testfile1.py'),
        os.path.join(tdir2, 'testfile2.py'),
        os.path.join(tdir3, 'testfile3.py'),
    ]
    _touch_files(files)

    actual = file_resources.GetCommandLineFiles([self.test_tmpdir],
                                                recursive=True,
                                                exclude=['*.test1*'])

    self.assertEqual(
        sorted(actual),
        sorted([
            os.path.join(tdir2, 'testfile2.py'),
            os.path.join(tdir3, 'testfile3.py'),
        ]))

</source>
</class>

<class classid="10" nclones="2" nlines="42" similarity="79">
<source file="systems/yapf-0.32.0/yapftests/split_penalty_test.py" startline="164" endline="214" pcid="588">
  def testStronglyConnected(self):
    # Test dictionary keys.
    code = textwrap.dedent(r"""
      a = {
          'x': 42,
          y(lambda a: 23): 37,
      }
      """)
    tree = self._ParseAndComputePenalties(code)
    self._CheckPenalties(tree, [
        ('a', None),
        ('=', None),
        ('{', None),
        ("'x'", None),
        (':', STRONGLY_CONNECTED),
        ('42', None),
        (',', None),
        ('y', None),
        ('(', UNBREAKABLE),
        ('lambda', STRONGLY_CONNECTED),
        ('a', VERY_STRONGLY_CONNECTED),
        (':', VERY_STRONGLY_CONNECTED),
        ('23', VERY_STRONGLY_CONNECTED),
        (')', VERY_STRONGLY_CONNECTED),
        (':', STRONGLY_CONNECTED),
        ('37', None),
        (',', None),
        ('}', None),
    ])

    # Test list comprehension.
    code = textwrap.dedent(r"""
      [a for a in foo if a.x == 37]
      """)
    tree = self._ParseAndComputePenalties(code)
    self._CheckPenalties(tree, [
        ('[', None),
        ('a', None),
        ('for', 0),
        ('a', STRONGLY_CONNECTED),
        ('in', STRONGLY_CONNECTED),
        ('foo', STRONGLY_CONNECTED),
        ('if', 0),
        ('a', STRONGLY_CONNECTED),
        ('.', VERY_STRONGLY_CONNECTED),
        ('x', DOTTED_NAME),
        ('==', STRONGLY_CONNECTED),
        ('37', STRONGLY_CONNECTED),
        (']', None),
    ])

</source>
<source file="systems/yapf-0.32.0/yapftests/split_penalty_test.py" startline="215" endline="264" pcid="589">
  def testFuncCalls(self):
    code = 'foo(1, 2, 3)\n'
    tree = self._ParseAndComputePenalties(code)
    self._CheckPenalties(tree, [
        ('foo', None),
        ('(', UNBREAKABLE),
        ('1', None),
        (',', UNBREAKABLE),
        ('2', None),
        (',', UNBREAKABLE),
        ('3', None),
        (')', VERY_STRONGLY_CONNECTED),
    ])

    # Now a method call, which has more than one trailer
    code = 'foo.bar.baz(1, 2, 3)\n'
    tree = self._ParseAndComputePenalties(code)
    self._CheckPenalties(tree, [
        ('foo', None),
        ('.', VERY_STRONGLY_CONNECTED),
        ('bar', DOTTED_NAME),
        ('.', VERY_STRONGLY_CONNECTED),
        ('baz', DOTTED_NAME),
        ('(', STRONGLY_CONNECTED),
        ('1', None),
        (',', UNBREAKABLE),
        ('2', None),
        (',', UNBREAKABLE),
        ('3', None),
        (')', VERY_STRONGLY_CONNECTED),
    ])

    # Test single generator argument.
    code = 'max(i for i in xrange(10))\n'
    tree = self._ParseAndComputePenalties(code)
    self._CheckPenalties(tree, [
        ('max', None),
        ('(', UNBREAKABLE),
        ('i', 0),
        ('for', 0),
        ('i', STRONGLY_CONNECTED),
        ('in', STRONGLY_CONNECTED),
        ('xrange', STRONGLY_CONNECTED),
        ('(', UNBREAKABLE),
        ('10', STRONGLY_CONNECTED),
        (')', VERY_STRONGLY_CONNECTED),
        (')', VERY_STRONGLY_CONNECTED),
    ])


</source>
</class>

<class classid="11" nclones="3" nlines="11" similarity="75">
<source file="systems/yapf-0.32.0/yapftests/pytree_unwrapper_test.py" startline="107" endline="123" pcid="596">
  def testIfWithCommentsInside(self):
    code = textwrap.dedent(r"""
      if foo:
          # c1
          x = 1 # c2
          # c3
          y = 2
      """)
    llines = yapf_test_helper.ParseAndUnwrap(code)
    self._CheckLogicalLines(llines, [
        (0, ['if', 'foo', ':']),
        (1, ['# c1']),
        (1, ['x', '=', '1', '# c2']),
        (1, ['# c3']),
        (1, ['y', '=', '2']),
    ])

</source>
<source file="systems/yapf-0.32.0/yapftests/pytree_unwrapper_test.py" startline="124" endline="144" pcid="597">
  def testIfElifElse(self):
    code = textwrap.dedent(r"""
       if x:
         x = 1 # c1
       elif y: # c2
         y = 1
       else:
         # c3
         z = 1
      """)
    llines = yapf_test_helper.ParseAndUnwrap(code)
    self._CheckLogicalLines(llines, [
        (0, ['if', 'x', ':']),
        (1, ['x', '=', '1', '# c1']),
        (0, ['elif', 'y', ':', '# c2']),
        (1, ['y', '=', '1']),
        (0, ['else', ':']),
        (1, ['# c3']),
        (1, ['z', '=', '1']),
    ])

</source>
<source file="systems/yapf-0.32.0/yapftests/pytree_unwrapper_test.py" startline="145" endline="163" pcid="598">
  def testNestedCompoundTwoLevel(self):
    code = textwrap.dedent(r"""
       if x:
         x = 1 # c1
         while t:
           # c2
           j = 1
         k = 1
      """)
    llines = yapf_test_helper.ParseAndUnwrap(code)
    self._CheckLogicalLines(llines, [
        (0, ['if', 'x', ':']),
        (1, ['x', '=', '1', '# c1']),
        (1, ['while', 't', ':']),
        (2, ['# c2']),
        (2, ['j', '=', '1']),
        (1, ['k', '=', '1']),
    ])

</source>
</class>

<class classid="12" nclones="4" nlines="13" similarity="76">
<source file="systems/yapf-0.32.0/yapftests/reformatter_style_config_test.py" startline="59" endline="79" pcid="654">
  def testOperatorNoSpaceStyle(self):
    try:
      sympy_style = style.CreatePEP8Style()
      sympy_style['NO_SPACES_AROUND_SELECTED_BINARY_OPERATORS'] = \
        style._StringSetConverter('*,/')
      style.SetGlobalStyle(sympy_style)
      unformatted_code = textwrap.dedent("""\
          a = 1+2 * 3 - 4 / 5
          b = '0' * 1
          """)
      expected_formatted_code = textwrap.dedent("""\
          a = 1 + 2*3 - 4/5
          b = '0'*1
          """)

      llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
      self.assertCodeEqual(expected_formatted_code,
                           reformatter.Reformat(llines))
    finally:
      style.SetGlobalStyle(style.CreatePEP8Style())
      style.DEFAULT_STYLE = self.current_style
</source>
<source file="systems/yapf-0.32.0/yapftests/reformatter_style_config_test.py" startline="80" endline="122" pcid="655">

  def testOperatorPrecedenceStyle(self):
    try:
      pep8_with_precedence = style.CreatePEP8Style()
      pep8_with_precedence['ARITHMETIC_PRECEDENCE_INDICATION'] = True
      style.SetGlobalStyle(pep8_with_precedence)
      unformatted_code = textwrap.dedent("""\
          1+2
          (1 + 2) * (3 - (4 / 5))
          a = 1 * 2 + 3 / 4
          b = 1 / 2 - 3 * 4
          c = (1 + 2) * (3 - 4)
          d = (1 - 2) / (3 + 4)
          e = 1 * 2 - 3
          f = 1 + 2 + 3 + 4
          g = 1 * 2 * 3 * 4
          h = 1 + 2 - 3 + 4
          i = 1 * 2 / 3 * 4
          j = (1 * 2 - 3) + 4
          k = (1 * 2 * 3) + (4 * 5 * 6 * 7 * 8)
          """)
      expected_formatted_code = textwrap.dedent("""\
          1 + 2
          (1+2) * (3 - (4/5))
          a = 1*2 + 3/4
          b = 1/2 - 3*4
          c = (1+2) * (3-4)
          d = (1-2) / (3+4)
          e = 1*2 - 3
          f = 1 + 2 + 3 + 4
          g = 1 * 2 * 3 * 4
          h = 1 + 2 - 3 + 4
          i = 1 * 2 / 3 * 4
          j = (1*2 - 3) + 4
          k = (1*2*3) + (4*5*6*7*8)
          """)

      llines = yapf_test_helper.ParseAndUnwrap(unformatted_code)
      self.assertCodeEqual(expected_formatted_code,
                           reformatter.Reformat(llines))
    finally:
      style.SetGlobalStyle(style.CreatePEP8Style())
      style.DEFAULT_STYLE = self.current_style
</source>
<source file="systems/yapf-0.32.0/yapftests/reformatter_style_config_test.py" startline="164" endline="195" pcid="657">

  def testNoSplitBeforeFirstArgumentStyle2(self):
    try:
      pep8_no_split_before_first = style.CreatePEP8Style()
      pep8_no_split_before_first['SPLIT_BEFORE_FIRST_ARGUMENT'] = False
      pep8_no_split_before_first['SPLIT_BEFORE_NAMED_ASSIGNS'] = True
      style.SetGlobalStyle(pep8_no_split_before_first)
      formatted_code = textwrap.dedent("""\
          # Examples Issue#556
          i_take_a_lot_of_params(arg1,
                                 param1=very_long_expression1(),
                                 param2=very_long_expression2(),
                                 param3=very_long_expression3(),
                                 param4=very_long_expression4())

          # Examples Issue#590
          plt.plot(numpy.linspace(0, 1, 10),
                   numpy.linspace(0, 1, 10),
                   marker="x",
                   color="r")

          plt.plot(veryverylongvariablename,
                   veryverylongvariablename,
                   marker="x",
                   color="r")
          """)
      llines = yapf_test_helper.ParseAndUnwrap(formatted_code)
      self.assertCodeEqual(formatted_code, reformatter.Reformat(llines))
    finally:
      style.SetGlobalStyle(style.CreatePEP8Style())
      style.DEFAULT_STYLE = self.current_style

</source>
<source file="systems/yapf-0.32.0/yapftests/reformatter_style_config_test.py" startline="123" endline="163" pcid="656">

  def testNoSplitBeforeFirstArgumentStyle1(self):
    try:
      pep8_no_split_before_first = style.CreatePEP8Style()
      pep8_no_split_before_first['SPLIT_BEFORE_FIRST_ARGUMENT'] = False
      pep8_no_split_before_first['SPLIT_BEFORE_NAMED_ASSIGNS'] = False
      style.SetGlobalStyle(pep8_no_split_before_first)
      formatted_code = textwrap.dedent("""\
          # Example from in-code MustSplit comments
          foo = outer_function_call(fitting_inner_function_call(inner_arg1, inner_arg2),
                                    outer_arg1, outer_arg2)

          foo = outer_function_call(
              not_fitting_inner_function_call(inner_arg1, inner_arg2), outer_arg1,
              outer_arg2)

          # Examples Issue#424
          a_super_long_version_of_print(argument1, argument2, argument3, argument4,
                                        argument5, argument6, argument7)

          CREDS_FILE = os.path.join(os.path.expanduser('~'),
                                    'apis/super-secret-admin-creds.json')

          # Examples Issue#556
          i_take_a_lot_of_params(arg1, param1=very_long_expression1(),
                                 param2=very_long_expression2(),
                                 param3=very_long_expression3(),
                                 param4=very_long_expression4())

          # Examples Issue#590
          plt.plot(numpy.linspace(0, 1, 10), numpy.linspace(0, 1, 10), marker="x",
                   color="r")

          plt.plot(veryverylongvariablename, veryverylongvariablename, marker="x",
                   color="r")
          """)  # noqa
      llines = yapf_test_helper.ParseAndUnwrap(formatted_code)
      self.assertCodeEqual(formatted_code, reformatter.Reformat(llines))
    finally:
      style.SetGlobalStyle(style.CreatePEP8Style())
      style.DEFAULT_STYLE = self.current_style
</source>
</class>

<class classid="13" nclones="2" nlines="12" similarity="71">
<source file="systems/yapf-0.32.0/yapf/yapflib/identify_container.py" startline="41" endline="57" pcid="703">
  def Visit_trailer(self, node):  # pylint: disable=invalid-name
    for child in node.children:
      self.Visit(child)

    if len(node.children) != 3:
      return
    if node.children[0].type != grammar_token.LPAR:
      return

    if pytree_utils.NodeName(node.children[1]) == 'arglist':
      for child in node.children[1].children:
        pytree_utils.SetOpeningBracket(
            pytree_utils.FirstLeafNode(child), node.children[0])
    else:
      pytree_utils.SetOpeningBracket(
          pytree_utils.FirstLeafNode(node.children[1]), node.children[0])

</source>
<source file="systems/yapf-0.32.0/yapf/yapflib/identify_container.py" startline="58" endline="69" pcid="704">
  def Visit_atom(self, node):  # pylint: disable=invalid-name
    for child in node.children:
      self.Visit(child)

    if len(node.children) != 3:
      return
    if node.children[0].type != grammar_token.LPAR:
      return

    for child in node.children[1].children:
      pytree_utils.SetOpeningBracket(
          pytree_utils.FirstLeafNode(child), node.children[0])
</source>
</class>

</clones>
