<clones>
<systeminfo processor="nicad6" system="matplotlib-3.5.1" granularity="functions" threshold="0%" minlines="10" maxlines="2500"/>
<cloneinfo npcs="2089" npairs="2"/>
<runinfo ncompares="16411" cputime="51139"/>
<classinfo nclasses="2"/>

<class classid="1" nclones="2" nlines="14" similarity="100">
<source file="systems/matplotlib-3.5.1/lib/matplotlib/backends/backend_gtk3cairo.py" startline="19" endline="36" pcid="426">
    def on_draw_event(self, widget, ctx):
        with (self.toolbar._wait_cursor_for_draw_cm() if self.toolbar
              else nullcontext()):
            self._renderer.set_context(ctx)
            scale = self.device_pixel_ratio
            # Scale physical drawing to logical size.
            ctx.scale(1 / scale, 1 / scale)
            allocation = self.get_allocation()
            Gtk.render_background(
                self.get_style_context(), ctx,
                allocation.x, allocation.y,
                allocation.width, allocation.height)
            self._renderer.set_width_height(
                allocation.width * scale, allocation.height * scale)
            self._renderer.dpi = self.figure.dpi
            self.figure.draw(self._renderer)


</source>
<source file="systems/matplotlib-3.5.1/lib/matplotlib/backends/backend_gtk4cairo.py" startline="20" endline="37" pcid="429">
    def on_draw_event(self, widget, ctx):
        with (self.toolbar._wait_cursor_for_draw_cm() if self.toolbar
              else nullcontext()):
            self._renderer.set_context(ctx)
            scale = self.device_pixel_ratio
            # Scale physical drawing to logical size.
            ctx.scale(1 / scale, 1 / scale)
            allocation = self.get_allocation()
            Gtk.render_background(
                self.get_style_context(), ctx,
                allocation.x, allocation.y,
                allocation.width, allocation.height)
            self._renderer.set_width_height(
                allocation.width * scale, allocation.height * scale)
            self._renderer.dpi = self.figure.dpi
            self.figure.draw(self._renderer)


</source>
</class>

<class classid="2" nclones="2" nlines="18" similarity="100">
<source file="systems/matplotlib-3.5.1/lib/matplotlib/tests/test_skew.py" startline="22" endline="40" pcid="1370">
    def draw(self, renderer):
        with ExitStack() as stack:
            for artist in [self.gridline, self.tick1line, self.tick2line,
                           self.label1, self.label2]:
                stack.callback(artist.set_visible, artist.get_visible())
            needs_lower = transforms.interval_contains(
                self.axes.lower_xlim, self.get_loc())
            needs_upper = transforms.interval_contains(
                self.axes.upper_xlim, self.get_loc())
            self.tick1line.set_visible(
                self.tick1line.get_visible() and needs_lower)
            self.label1.set_visible(
                self.label1.get_visible() and needs_lower)
            self.tick2line.set_visible(
                self.tick2line.get_visible() and needs_upper)
            self.label2.set_visible(
                self.label2.get_visible() and needs_upper)
            super().draw(renderer)

</source>
<source file="systems/matplotlib-3.5.1/examples/specialty_plots/skewt.py" startline="28" endline="50" pcid="2056">
    def draw(self, renderer):
        # When adding the callbacks with `stack.callback`, we fetch the current
        # visibility state of the artist with `get_visible`; the ExitStack will
        # restore these states (`set_visible`) at the end of the block (after
        # the draw).
        with ExitStack() as stack:
            for artist in [self.gridline, self.tick1line, self.tick2line,
                           self.label1, self.label2]:
                stack.callback(artist.set_visible, artist.get_visible())
            needs_lower = transforms.interval_contains(
                self.axes.lower_xlim, self.get_loc())
            needs_upper = transforms.interval_contains(
                self.axes.upper_xlim, self.get_loc())
            self.tick1line.set_visible(
                self.tick1line.get_visible() and needs_lower)
            self.label1.set_visible(
                self.label1.get_visible() and needs_lower)
            self.tick2line.set_visible(
                self.tick2line.get_visible() and needs_upper)
            self.label2.set_visible(
                self.label2.get_visible() and needs_upper)
            super().draw(renderer)

</source>
</class>

</clones>
