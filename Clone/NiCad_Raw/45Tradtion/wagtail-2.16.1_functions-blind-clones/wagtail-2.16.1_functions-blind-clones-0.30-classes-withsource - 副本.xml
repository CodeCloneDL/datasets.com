<clones>
<systeminfo processor="nicad6" system="wagtail-2.16.1" granularity="functions-blind" threshold="30%" minlines="10" maxlines="2500"/>
<cloneinfo npcs="5932" npairs="1230"/>
<runinfo ncompares="666756" cputime="272992"/>
<classinfo nclasses="252"/>

<class classid="1" nclones="2" nlines="11" similarity="90">
<source file="systems/wagtail-2.16.1/wagtail/users/views/groups.py" startline="80" endline="99" pcid="17">
    def post(self, request, *args, **kwargs):
        """
        Handle POST requests: instantiate a form instance with the passed
        POST variables and then check if it's valid.
        """
        # Create an object now so that the permission panel forms have something to link them against
        self.object = Group()

        form = self.get_form()
        permission_panels = self.get_permission_panel_forms()
        if form.is_valid() and all(panel.is_valid() for panel in permission_panels):
            response = self.form_valid(form)

            for panel in permission_panels:
                panel.save()

            return response
        else:
            return self.form_invalid(form)

</source>
<source file="systems/wagtail-2.16.1/wagtail/users/views/groups.py" startline="119" endline="137" pcid="19">
    def post(self, request, *args, **kwargs):
        """
        Handle POST requests: instantiate a form instance with the passed
        POST variables and then check if it's valid.
        """
        self.object = self.get_object()

        form = self.get_form()
        permission_panels = self.get_permission_panel_forms()
        if form.is_valid() and all(panel.is_valid() for panel in permission_panels):
            response = self.form_valid(form)

            for panel in permission_panels:
                panel.save()

            return response
        else:
            return self.form_invalid(form)

</source>
</class>

<class classid="2" nclones="2" nlines="10" similarity="70">
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_admin_views.py" startline="87" endline="99" pcid="41">
    def setUp(self):
        # create a user that should be visible in the listing
        self.test_user = self.create_user(
            username='testuser',
            email='testuser@email.com',
            password='password',
            first_name='First Name',
            last_name='Last Name'
        )
        self.test_group = Group.objects.create(name='Test Group')
        self.test_user.groups.add(self.test_group)
        self.login()

</source>
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_admin_views.py" startline="483" endline="497" pcid="78">
    def setUp(self):
        # create a user that should be visible in the listing
        self.test_user = self.create_user(
            username='testuser',
            email='testuser@email.com',
            password='password'
        )
        # also create a superuser to delete
        self.superuser = self.create_superuser(
            username='testsuperuser',
            email='testsuperuser@email.com',
            password='password'
        )
        self.current_user = self.login()

</source>
</class>

<class classid="3" nclones="28" nlines="13" similarity="70">
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_admin_views.py" startline="208" endline="224" pcid="61">
    def test_create(self):
        response = self.post({
            'username': "testuser",
            'email': "test@user.com",
            'first_name': "Test",
            'last_name': "User",
            'password1': "password",
            'password2': "password",
        })

        # Should redirect back to index
        self.assertRedirects(response, reverse('wagtailusers_users:index'))

        # Check that the user was created
        users = get_user_model().objects.filter(email='test@user.com')
        self.assertEqual(users.count(), 1)

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/redirects/tests/test_redirects.py" startline="582" endline="598" pcid="430">
    def test_edit(self):
        response = self.post({
            'old_path': '/test',
            'is_permanent': 'on',
            'site': '',
            'redirect_link': 'http://www.test.com/ive-been-edited',
        })

        # Should redirect back to index
        self.assertRedirects(response, reverse('wagtailredirects:index'))

        # Check that the redirect was edited
        redirects = models.Redirect.objects.filter(old_path='/test')
        self.assertEqual(redirects.count(), 1)
        self.assertEqual(redirects.first().redirect_link, 'http://www.test.com/ive-been-edited')
        self.assertEqual(redirects.first().site, None)

</source>
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_admin_views.py" startline="356" endline="376" pcid="68">
    def test_optional_password_is_still_validated(self):
        """When WAGTAILUSERS_PASSWORD_REQUIRED is False, password validation should still apply if a password _is_ supplied"""
        response = self.post({
            'username': "testuser",
            'email': "test@user.com",
            'first_name': "Test",
            'last_name': "User",
            'password1': "banana",
            'password2': "kumquat",
        })

        # Should remain on page
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'wagtailusers/users/create.html')

        self.assertTrue(response.context['form'].errors['password2'])

        # Check that the user was not created
        users = get_user_model().objects.filter(email='test@user.com')
        self.assertEqual(users.count(), 0)

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/redirects/tests/test_redirects.py" startline="537" endline="554" pcid="424">
    def test_add_long_redirect(self):
        response = self.post({
            'old_path': '/test',
            'site': '',
            'is_permanent': 'on',
            'redirect_link': 'https://www.google.com/search?q=this+is+a+very+long+url+because+it+has+a+huge+search+term+appended+to+the+end+of+it+even+though+someone+should+really+not+be+doing+something+so+crazy+without+first+seeing+a+psychiatrist',
        })

        # Should redirect back to index
        self.assertRedirects(response, reverse('wagtailredirects:index'))

        # Check that the redirect was created
        redirects = models.Redirect.objects.filter(old_path='/test')
        self.assertEqual(redirects.count(), 1)
        self.assertEqual(redirects.first().redirect_link, 'https://www.google.com/search?q=this+is+a+very+long+url+because+it+has+a+huge+search+term+appended+to+the+end+of+it+even+though+someone+should+really+not+be+doing+something+so+crazy+without+first+seeing+a+psychiatrist')
        self.assertEqual(redirects.first().site, None)


</source>
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_admin_views.py" startline="336" endline="354" pcid="67">
    def test_create_with_password_not_required(self):
        """Password should not be required if WAGTAILUSERS_PASSWORD_REQUIRED is False"""
        response = self.post({
            'username': "testuser",
            'email': "test@user.com",
            'first_name': "Test",
            'last_name': "User",
            'password1': "",
            'password2': "",
        })

        # Should redirect back to index
        self.assertRedirects(response, reverse('wagtailusers_users:index'))

        # Check that the user was created
        users = get_user_model().objects.filter(email='test@user.com')
        self.assertEqual(users.count(), 1)
        self.assertEqual(users.first().password, '')

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/redirects/tests/test_redirects.py" startline="446" endline="462" pcid="418">
    def test_add(self):
        response = self.post({
            'old_path': '/test',
            'site': '',
            'is_permanent': 'on',
            'redirect_link': 'http://www.test.com/',
        })

        # Should redirect back to index
        self.assertRedirects(response, reverse('wagtailredirects:index'))

        # Check that the redirect was created
        redirects = models.Redirect.objects.filter(old_path='/test')
        self.assertEqual(redirects.count(), 1)
        self.assertEqual(redirects.first().redirect_link, 'http://www.test.com/')
        self.assertEqual(redirects.first().site, None)

</source>
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_admin_views.py" startline="915" endline="928" pcid="111">
    def test_edit_validation_error(self):
        # Leave "username" field blank. This should give a validation error
        response = self.post({
            'username': "",
            'email': "test@user.com",
            'first_name': "Teset",
            'last_name': "User",
            'password1': "password",
            'password2': "password",
        })

        # Should not redirect to index
        self.assertEqual(response.status_code, 200)

</source>
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_admin_views.py" startline="378" endline="396" pcid="69">
    def test_password_still_accepted_when_optional(self):
        """When WAGTAILUSERS_PASSWORD_REQUIRED is False, we should still allow a password to be set"""
        response = self.post({
            'username': "testuser",
            'email': "test@user.com",
            'first_name': "Test",
            'last_name': "User",
            'password1': "banana",
            'password2': "banana",
        })

        # Should redirect back to index
        self.assertRedirects(response, reverse('wagtailusers_users:index'))

        # Check that the user was created
        users = get_user_model().objects.filter(email='test@user.com')
        self.assertEqual(users.count(), 1)
        self.assertTrue(users.first().check_password('banana'))

</source>
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_admin_views.py" startline="305" endline="325" pcid="65">
    def test_create_with_missing_password(self):
        """Password should be required by default"""
        response = self.post({
            'username': "testuser",
            'email': "test@user.com",
            'first_name': "Test",
            'last_name': "User",
            'password1': "",
            'password2': "",
        })

        # Should remain on page
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'wagtailusers/users/create.html')

        self.assertTrue(response.context['form'].errors['password1'])

        # Check that the user was not created
        users = get_user_model().objects.filter(email='test@user.com')
        self.assertEqual(users.count(), 0)

</source>
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_admin_views.py" startline="230" endline="250" pcid="62">
    def test_create_with_custom_form(self):
        response = self.post({
            'username': "testuser",
            'email': "test@user.com",
            'first_name': "Test",
            'last_name': "User",
            'password1': "password",
            'password2': "password",
            'country': "testcountry",
            'attachment': SimpleUploadedFile('test.txt', b"Uploaded file"),
        })

        # Should redirect back to index
        self.assertRedirects(response, reverse('wagtailusers_users:index'))

        # Check that the user was created
        users = get_user_model().objects.filter(email='test@user.com')
        self.assertEqual(users.count(), 1)
        self.assertEqual(users.first().country, 'testcountry')
        self.assertEqual(users.first().attachment.read(), b"Uploaded file")

</source>
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_admin_views.py" startline="407" endline="425" pcid="71">
    def test_password_fields_ignored_when_disabled(self):
        """When WAGTAILUSERS_PASSWORD_ENABLED is False, users should always be created without a usable password"""
        response = self.post({
            'username': "testuser",
            'email': "test@user.com",
            'first_name': "Test",
            'last_name': "User",
            'password1': "banana",  # not part of the form - should be ignored
            'password2': "kumquat",  # not part of the form - should be ignored
        })

        # Should redirect back to index
        self.assertRedirects(response, reverse('wagtailusers_users:index'))

        # Check that the user was created
        users = get_user_model().objects.filter(email='test@user.com')
        self.assertEqual(users.count(), 1)
        self.assertEqual(users.first().password, '')

</source>
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_admin_views.py" startline="765" endline="788" pcid="105">
    def test_edit_and_deactivate(self):
        response = self.post({
            'username': "testuser",
            'email': "test@user.com",
            'first_name': "Edited",
            'last_name': "User",
            'password1': "password",
            'password2': "password",
            # Leaving out these fields, thus setting them to False:
            # 'is_active': 'on'
            # 'is_superuser': 'on',
        })

        # Should redirect back to index
        self.assertRedirects(response, reverse('wagtailusers_users:index'))

        # Check that the user was edited
        user = get_user_model().objects.get(pk=self.test_user.pk)
        self.assertEqual(user.first_name, 'Edited')
        # Check that the user is no longer superuser
        self.assertEqual(user.is_superuser, False)
        # Check that the user is no longer active
        self.assertEqual(user.is_active, False)

</source>
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_admin_views.py" startline="251" endline="270" pcid="63">
    def test_create_with_password_mismatch(self):
        response = self.post({
            'username': "testuser",
            'email': "test@user.com",
            'first_name': "Test",
            'last_name': "User",
            'password1': "password1",
            'password2': "password2",
        })

        # Should remain on page
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'wagtailusers/users/create.html')

        self.assertTrue(response.context['form'].errors['password2'])

        # Check that the user was not created
        users = get_user_model().objects.filter(email='test@user.com')
        self.assertEqual(users.count(), 0)

</source>
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_admin_views.py" startline="939" endline="958" pcid="113">
    def test_password_fields_ignored_when_disabled(self):
        """When WAGTAILUSERS_PASSWORD_REQUIRED is False, existing password should be left unchanged"""
        response = self.post({
            'username': "testuser",
            'email': "test@user.com",
            'first_name': "Edited",
            'last_name': "User",
            'is_active': 'on',
            'password1': "banana",  # not part of the form - should be ignored
            'password2': "kumquat",  # not part of the form - should be ignored
        })

        # Should redirect back to index
        self.assertRedirects(response, reverse('wagtailusers_users:index'))

        # Check that the user was edited but password is unchanged
        user = get_user_model().objects.get(pk=self.test_user.pk)
        self.assertEqual(user.first_name, 'Edited')
        self.assertTrue(user.check_password('password'))

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/redirects/tests/test_redirects.py" startline="599" endline="617" pcid="431">
    def test_edit_with_site(self):
        localhost = Site.objects.get(hostname='localhost')

        response = self.post({
            'old_path': '/test',
            'is_permanent': 'on',
            'site': localhost.id,
            'redirect_link': 'http://www.test.com/ive-been-edited',
        })

        # Should redirect back to index
        self.assertRedirects(response, reverse('wagtailredirects:index'))

        # Check that the redirect was edited
        redirects = models.Redirect.objects.filter(old_path='/test')
        self.assertEqual(redirects.count(), 1)
        self.assertEqual(redirects.first().redirect_link, 'http://www.test.com/ive-been-edited')
        self.assertEqual(redirects.first().site, localhost)

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/redirects/tests/test_redirects.py" startline="463" endline="480" pcid="419">
    def test_add_with_site(self):
        localhost = Site.objects.get(hostname='localhost')
        response = self.post({
            'old_path': '/test',
            'site': localhost.id,
            'is_permanent': 'on',
            'redirect_link': 'http://www.test.com/',
        })

        # Should redirect back to index
        self.assertRedirects(response, reverse('wagtailredirects:index'))

        # Check that the redirect was created
        redirects = models.Redirect.objects.filter(old_path='/test')
        self.assertEqual(redirects.count(), 1)
        self.assertEqual(redirects.first().redirect_link, 'http://www.test.com/')
        self.assertEqual(redirects.first().site, localhost)

</source>
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_admin_views.py" startline="708" endline="729" pcid="103">
    def test_passwords_match(self):
        """Password fields should be validated if supplied"""
        response = self.post({
            'username': "testuser",
            'email': "test@user.com",
            'first_name': "Edited",
            'last_name': "User",
            'password1': "banana",
            'password2': "kumquat",
            'is_active': 'on'
        })
        # Should remain on page
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'wagtailusers/users/edit.html')

        self.assertTrue(response.context['form'].errors['password2'])

        # Check that the user was not edited
        user = get_user_model().objects.get(pk=self.test_user.pk)
        self.assertEqual(user.first_name, 'Original')
        self.assertTrue(user.check_password('password'))

</source>
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_admin_views.py" startline="276" endline="304" pcid="64">
    def test_create_with_password_validation(self):
        """
        Test that the Django password validators are run when creating a user.
        Specifically test that the UserAttributeSimilarityValidator works,
        which requires a full-populated user model before the validation works.
        """
        # Create a user with a password the same as their name
        response = self.post({
            'username': "testuser",
            'email': "test@user.com",
            'first_name': "Example",
            'last_name': "Name",
            'password1': "example name",
            'password2': "example name",
        })

        # Should remain on page
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'wagtailusers/users/create.html')

        # Password field should have an error
        errors = response.context['form'].errors.as_data()
        self.assertIn('password2', errors)
        self.assertEqual(errors['password2'][0].code, 'password_too_similar')

        # Check that the user was not created
        users = get_user_model().objects.filter(email='test@user.com')
        self.assertEqual(users.count(), 0)

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/redirects/tests/test_redirects.py" startline="504" endline="516" pcid="422">
    def test_cannot_add_duplicate_on_same_site(self):
        localhost = Site.objects.get(hostname='localhost')
        models.Redirect.objects.create(old_path='/test', site=localhost, redirect_link='http://elsewhere.com/')
        response = self.post({
            'old_path': '/test',
            'site': localhost.pk,
            'is_permanent': 'on',
            'redirect_link': 'http://www.test.com/',
        })

        # Should not redirect to index
        self.assertEqual(response.status_code, 200)

</source>
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_admin_views.py" startline="893" endline="913" pcid="110">
    def test_edit_with_custom_form(self):
        response = self.post({
            'username': "testuser",
            'email': "test@user.com",
            'first_name': "Edited",
            'last_name': "User",
            'password1': "password",
            'password2': "password",
            'country': "testcountry",
            'attachment': SimpleUploadedFile('test.txt', b"Uploaded file"),
        })

        # Should redirect back to index
        self.assertRedirects(response, reverse('wagtailusers_users:index'))

        # Check that the user was edited
        user = get_user_model().objects.get(pk=self.test_user.pk)
        self.assertEqual(user.first_name, 'Edited')
        self.assertEqual(user.country, 'testcountry')
        self.assertEqual(user.attachment.read(), b"Uploaded file")

</source>
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_admin_views.py" startline="689" endline="707" pcid="102">
    def test_password_optional(self):
        """Leaving password fields blank should leave it unchanged"""
        response = self.post({
            'username': "testuser",
            'email': "test@user.com",
            'first_name': "Edited",
            'last_name': "User",
            'password1': "",
            'password2': "",
            'is_active': 'on'
        })
        # Should redirect back to index
        self.assertRedirects(response, reverse('wagtailusers_users:index'))

        # Check that the user was edited but password is unchanged
        user = get_user_model().objects.get(pk=self.test_user.pk)
        self.assertEqual(user.first_name, 'Edited')
        self.assertTrue(user.check_password('password'))

</source>
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_admin_views.py" startline="789" endline="811" pcid="106">
    def test_edit_and_make_superuser(self):
        response = self.post({
            'username': "testuser",
            'email': "test@user.com",
            'first_name': "Edited",
            'last_name': "User",
            'password1': "password",
            'password2': "password",
            'is_active': 'on',
            'is_superuser': 'on',
        })

        # Should redirect back to index
        self.assertRedirects(response, reverse('wagtailusers_users:index'))

        # Check that the user was edited
        user = get_user_model().objects.get(pk=self.test_user.pk)

        # Check that the user is now superuser
        self.assertEqual(user.is_superuser, True)
        # Check that the user is now active
        self.assertEqual(user.is_active, True)

</source>
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_admin_views.py" startline="812" endline="835" pcid="107">
    def test_edit_self(self):
        response = self.post({
            'username': 'test@email.com',
            'email': 'test@email.com',
            'first_name': "Edited Myself",
            'last_name': "User",
            # 'password1': "password",
            # 'password2': "password",
            'is_active': 'on',
            'is_superuser': 'on',
        }, self.current_user.pk)

        # Should redirect back to index
        self.assertRedirects(response, reverse('wagtailusers_users:index'))

        # Check that the user was edited
        user = get_user_model().objects.get(pk=self.current_user.pk)
        self.assertEqual(user.first_name, 'Edited Myself')

        # Check that the user is still superuser
        self.assertEqual(user.is_superuser, True)
        # Check that the user is still active
        self.assertEqual(user.is_active, True)

</source>
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_admin_views.py" startline="671" endline="688" pcid="101">
    def test_simple_post(self):
        response = self.post({
            'username': "testuser",
            'email': "test@user.com",
            'first_name': "Edited",
            'last_name': "User",
            'password1': "newpassword",
            'password2': "newpassword",
            'is_active': 'on'
        })
        # Should redirect back to index
        self.assertRedirects(response, reverse('wagtailusers_users:index'))

        # Check that the user was edited
        user = get_user_model().objects.get(pk=self.test_user.pk)
        self.assertEqual(user.first_name, 'Edited')
        self.assertTrue(user.check_password('newpassword'))

</source>
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_admin_views.py" startline="859" endline="888" pcid="109">
    def test_cannot_demote_self(self):
        """
        check that unsetting a user's own is_active or is_superuser flag has no effect
        """
        response = self.post({
            'username': 'test@email.com',
            'email': 'test@email.com',
            'first_name': "Edited Myself",
            'last_name': "User",
            # 'password1': "password",
            # 'password2': "password",

            # failing to submit is_active or is_superuser would unset those flags,
            # if we didn't explicitly prevent that when editing self
            # 'is_active': 'on',
            # 'is_superuser': 'on',
        }, self.current_user.pk)

        # Should redirect back to index
        self.assertRedirects(response, reverse('wagtailusers_users:index'))

        # Check that the user was edited
        user = get_user_model().objects.get(pk=self.current_user.pk)
        self.assertEqual(user.first_name, 'Edited Myself')

        # Check that the user is still superuser
        self.assertEqual(user.is_superuser, True)
        # Check that the user is still active
        self.assertEqual(user.is_active, True)

</source>
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_admin_views.py" startline="735" endline="764" pcid="104">
    def test_edit_with_password_validation(self):
        """
        Test that the Django password validators are run when editing a user.
        Specifically test that the UserAttributeSimilarityValidator works,
        which requires a full-populated user model before the validation works.
        """
        # Create a user with a password the same as their name
        response = self.post({
            'username': "testuser",
            'email': "test@user.com",
            'first_name': "Edited",
            'last_name': "Name",
            'password1': "edited name",
            'password2': "edited name",
        })

        # Should remain on page
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'wagtailusers/users/edit.html')

        # Password field should have an error
        errors = response.context['form'].errors.as_data()
        self.assertIn('password2', errors)
        self.assertEqual(errors['password2'][0].code, 'password_too_similar')

        # Check that the user was not edited
        user = get_user_model().objects.get(pk=self.test_user.pk)
        self.assertEqual(user.first_name, 'Original')
        self.assertTrue(user.check_password('password'))

</source>
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_admin_views.py" startline="836" endline="858" pcid="108">
    def test_editing_own_password_does_not_log_out(self):
        response = self.post({
            'username': 'test@email.com',
            'email': 'test@email.com',
            'first_name': "Edited Myself",
            'last_name': "User",
            'password1': "c0rrecth0rse",
            'password2': "c0rrecth0rse",
            'is_active': 'on',
            'is_superuser': 'on',
        }, self.current_user.pk)

        # Should redirect back to index
        self.assertRedirects(response, reverse('wagtailusers_users:index'))

        # Check that the user was edited
        user = get_user_model().objects.get(pk=self.current_user.pk)
        self.assertEqual(user.first_name, 'Edited Myself')

        # Check user is not logged out
        response = self.client.get(reverse('wagtailusers_users:index'))
        self.assertEqual(response.status_code, 200)

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/redirects/tests/test_redirects.py" startline="517" endline="536" pcid="423">
    def test_can_reuse_path_on_other_site(self):
        localhost = Site.objects.get(hostname='localhost')
        contact_page = Page.objects.get(url_path='/home/contact-us/')
        other_site = Site.objects.create(hostname='other.example.com', port=80, root_page=contact_page)

        models.Redirect.objects.create(old_path='/test', site=localhost, redirect_link='http://elsewhere.com/')
        response = self.post({
            'old_path': '/test',
            'site': other_site.pk,
            'is_permanent': 'on',
            'redirect_link': 'http://www.test.com/',
        })

        # Should redirect back to index
        self.assertRedirects(response, reverse('wagtailredirects:index'))

        # Check that the redirect was created
        redirects = models.Redirect.objects.filter(redirect_link='http://www.test.com/')
        self.assertEqual(redirects.count(), 1)

</source>
</class>

<class classid="4" nclones="15" nlines="18" similarity="70">
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_admin_views.py" startline="438" endline="458" pcid="74">
    def test_before_create_user_hook_post(self):
        def hook_func(request):
            self.assertIsInstance(request, HttpRequest)
            return HttpResponse("Overridden!")

        with self.register_hook('before_create_user', hook_func):
            post_data = {
                'username': "testuser",
                'email': "testuser@test.com",
                'password1': 'password12',
                'password2': 'password12',
                'first_name': 'test',
                'last_name': 'user',
            }
            response = self.client.post(
                reverse('wagtailusers_users:add'),
                post_data
            )
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="943" endline="965" pcid="1706">
        self.assertEqual(response.content, b"Overridden!")
        self.child_page.refresh_from_db()
        self.assertEqual(self.child_page.status_string, _("live"))

    def test_before_publish_page(self):
        def hook_func(request, page):
            self.assertIsInstance(request, HttpRequest)
            self.assertEqual(page.id, self.child_page.id)

            return HttpResponse("Overridden!")

        with self.register_hook("before_publish_page", hook_func):
            post_data = {
                'title': "I've been edited!",
                'content': "Some content",
                'slug': 'hello-world-new',
                'action-publish': "Publish",
            }
            response = self.client.post(
                reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data
            )

        self.assertEqual(response.status_code, 200)
</source>
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_admin_views.py" startline="459" endline="481" pcid="76">
    def test_after_create_user_hook(self):
        def hook_func(request, user):
            self.assertIsInstance(request, HttpRequest)
            self.assertIsInstance(user, get_user_model())
            return HttpResponse("Overridden!")

        with self.register_hook('after_create_user', hook_func):
            post_data = {
                'username': "testuser",
                'email': "testuser@test.com",
                'password1': 'password12',
                'password2': 'password12',
                'first_name': 'test',
                'last_name': 'user',
            }
            response = self.client.post(
                reverse('wagtailusers_users:add'),
                post_data
            )
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")


</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="896" endline="919" pcid="1702">

        # page should not be edited
        self.assertEqual(Page.objects.get(id=self.child_page.id).title, "Hello world!")

    def test_after_edit_page_hook(self):
        def hook_func(request, page):
            self.assertIsInstance(request, HttpRequest)
            self.assertEqual(page.id, self.child_page.id)

            return HttpResponse("Overridden!")

        with self.register_hook('after_edit_page', hook_func):
            post_data = {
                'title': "I've been edited!",
                'content': "Some content",
                'slug': 'hello-world-new',
                'action-publish': "Publish",
            }
            response = self.client.post(
                reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data
            )

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")
</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="872" endline="895" pcid="1700">

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")

    def test_before_edit_page_hook_post(self):
        def hook_func(request, page):
            self.assertIsInstance(request, HttpRequest)
            self.assertEqual(page.id, self.child_page.id)

            return HttpResponse("Overridden!")

        with self.register_hook('before_edit_page', hook_func):
            post_data = {
                'title': "I've been edited!",
                'content': "Some content",
                'slug': 'hello-world-new',
                'action-publish': "Publish",
            }
            response = self.client.post(
                reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data
            )

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")
</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_create_page.py" startline="629" endline="653" pcid="1818">
    def test_before_create_page_hook_post(self):
        def hook_func(request, parent_page, page_class):
            self.assertIsInstance(request, HttpRequest)
            self.assertEqual(parent_page.id, self.root_page.id)
            self.assertEqual(page_class, SimplePage)

            return HttpResponse("Overridden!")

        with self.register_hook('before_create_page', hook_func):
            post_data = {
                'title': "New page!",
                'content': "Some content",
                'slug': 'hello-world',
            }
            response = self.client.post(
                reverse('wagtailadmin_pages:add', args=('tests', 'simplepage', self.root_page.id)),
                post_data
            )

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")

        # page should not be created
        self.assertFalse(Page.objects.filter(title="New page!").exists())

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="920" endline="942" pcid="1704">

        # page should be edited
        self.assertEqual(Page.objects.get(id=self.child_page.id).title, "I've been edited!")

    def test_after_publish_page(self):
        def hook_func(request, page):
            self.assertIsInstance(request, HttpRequest)
            self.assertEqual(page.id, self.child_page.id)

            return HttpResponse("Overridden!")

        with self.register_hook("after_publish_page", hook_func):
            post_data = {
                'title': "I've been edited!",
                'content': "Some content",
                'slug': 'hello-world-new',
                'action-publish': "Publish",
            }
            response = self.client.post(
                reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data
            )

        self.assertEqual(response.status_code, 200)
</source>
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_admin_views.py" startline="995" endline="1018" pcid="118">
    def test_after_edit_user_hook_post(self):
        def hook_func(request, user):
            self.assertIsInstance(request, HttpRequest)
            self.assertEqual(user.pk, self.test_user.pk)

            return HttpResponse("Overridden!")

        with self.register_hook('after_edit_user', hook_func):
            post_data = {
                'username': "testuser",
                'email': "test@user.com",
                'first_name': "Edited",
                'last_name': "User",
                'password1': "password",
                'password2': "password",
            }
            response = self.client.post(
                reverse('wagtailusers_users:edit', args=(self.test_user.pk, )), post_data
            )

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")


</source>
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_admin_views.py" startline="972" endline="994" pcid="116">
    def test_before_edit_user_hook_post(self):
        def hook_func(request, user):
            self.assertIsInstance(request, HttpRequest)
            self.assertEqual(user.pk, self.test_user.pk)

            return HttpResponse("Overridden!")

        with self.register_hook('before_edit_user', hook_func):
            post_data = {
                'username': "testuser",
                'email': "test@user.com",
                'first_name': "Edited",
                'last_name': "User",
                'password1': "password",
                'password2': "password",
            }
            response = self.client.post(
                reverse('wagtailusers_users:edit', args=(self.test_user.pk, )), post_data
            )

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_unpublish_page.py" startline="92" endline="110" pcid="2042">
    def test_after_unpublish_page(self):
        def hook_func(request, page):
            self.assertIsInstance(request, HttpRequest)
            self.assertEqual(page.id, self.page.id)

            return HttpResponse("Overridden!")

        with self.register_hook('after_unpublish_page', hook_func):
            post_data = {}
            response = self.client.post(
                reverse('wagtailadmin_pages:unpublish', args=(self.page.id, )), post_data
            )

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")

        self.page.refresh_from_db()
        self.assertEqual(self.page.status_string, _("draft"))

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_unpublish_page.py" startline="111" endline="130" pcid="2044">
    def test_before_unpublish_page(self):
        def hook_func(request, page):
            self.assertIsInstance(request, HttpRequest)
            self.assertEqual(page.id, self.page.id)

            return HttpResponse("Overridden!")

        with self.register_hook('before_unpublish_page', hook_func):
            post_data = {}
            response = self.client.post(
                reverse('wagtailadmin_pages:unpublish', args=(self.page.id, )), post_data
            )

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")

        # The hook response is served before unpublish is called.
        self.page.refresh_from_db()
        self.assertEqual(self.page.status_string, _("live"))

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_create_page.py" startline="710" endline="736" pcid="1824">
    def test_after_publish_page(self):
        def hook_func(request, page):
            self.assertIsInstance(request, HttpRequest)
            self.assertEqual(page.title, "New page!")

            self.assertIsNotNone(page.first_published_at)
            self.assertIsNotNone(page.last_published_at)

            return HttpResponse("Overridden!")

        with self.register_hook("after_publish_page", hook_func):
            post_data = {
                "title": "New page!",
                "content": "Some content",
                "slug": "hello-world",
                "action-publish": "Publish",
            }
            response = self.client.post(
                reverse("wagtailadmin_pages:add", args=("tests", "simplepage", self.root_page.id)),
                post_data
            )

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")
        self.root_page.refresh_from_db()
        self.assertEqual(self.root_page.get_children()[0].status_string, _("live"))

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_create_page.py" startline="737" endline="763" pcid="1826">
    def test_before_publish_page(self):
        def hook_func(request, page):
            self.assertIsInstance(request, HttpRequest)
            self.assertEqual(page.title, "New page!")

            self.assertIsNone(page.first_published_at)
            self.assertIsNone(page.last_published_at)

            return HttpResponse("Overridden!")

        with self.register_hook("before_publish_page", hook_func):
            post_data = {
                "title": "New page!",
                "content": "Some content",
                "slug": "hello-world",
                "action-publish": "Publish",
            }
            response = self.client.post(
                reverse("wagtailadmin_pages:add", args=("tests", "simplepage", self.root_page.id)),
                post_data
            )

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")
        self.root_page.refresh_from_db()
        self.assertEqual(self.root_page.get_children()[0].status_string, _("live + draft"))

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_create_page.py" startline="654" endline="681" pcid="1820">
    def test_after_create_page_hook(self):
        def hook_func(request, page):
            self.assertIsInstance(request, HttpRequest)
            self.assertIsInstance(page, SimplePage)

            # Both are None as this is only a draft
            self.assertIsNone(page.first_published_at)
            self.assertIsNone(page.last_published_at)

            return HttpResponse("Overridden!")

        with self.register_hook('after_create_page', hook_func):
            post_data = {
                'title': "New page!",
                'content': "Some content",
                'slug': 'hello-world',
            }
            response = self.client.post(
                reverse('wagtailadmin_pages:add', args=('tests', 'simplepage', self.root_page.id)),
                post_data
            )

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")

        # page should be created
        self.assertTrue(Page.objects.filter(title="New page!").exists())

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_create_page.py" startline="682" endline="709" pcid="1822">
    def test_after_create_page_hook_with_page_publish(self):
        def hook_func(request, page):
            self.assertIsInstance(request, HttpRequest)
            self.assertIsInstance(page, SimplePage)

            self.assertIsNotNone(page.first_published_at)
            self.assertIsNotNone(page.last_published_at)

            return HttpResponse("Overridden!")

        with self.register_hook('after_create_page', hook_func):
            post_data = {
                'title': "New page!",
                'content': "Some content",
                'slug': 'hello-world',
                'action-publish': "Publish",
            }
            response = self.client.post(
                reverse('wagtailadmin_pages:add', args=('tests', 'simplepage', self.root_page.id)),
                post_data
            )

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")

        # page should be created
        self.assertTrue(Page.objects.filter(title="New page!").exists())

</source>
</class>

<class classid="5" nclones="2" nlines="15" similarity="81">
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_admin_views.py" startline="1160" endline="1180" pcid="135">
    def test_group_create_adding_permissions(self):
        response = self.post({
            'name': "test group",
            'page_permissions-0-page': ['1'],
            'page_permissions-0-permission_types': ['edit', 'publish'],
            'page_permissions-TOTAL_FORMS': ['1'],
            'document_permissions-0-collection': [Collection.get_first_root_node().pk],
            'document_permissions-0-permissions': [self.add_doc_permission.pk],
            'document_permissions-TOTAL_FORMS': ['1'],
        })

        self.assertRedirects(response, reverse('wagtailusers_groups:index'))
        # The test group now exists, with two page permissions
        # and one 'add document' collection permission
        new_group = Group.objects.get(name='test group')
        self.assertEqual(new_group.page_permissions.all().count(), 2)
        self.assertEqual(
            new_group.collection_permissions.filter(permission=self.add_doc_permission).count(),
            1
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_admin_views.py" startline="1219" endline="1238" pcid="138">
    def test_can_submit_blank_permission_form(self):
        # the formsets for page / collection permissions should gracefully
        # handle (and ignore) forms that have been left entirely blank
        response = self.post({
            'name': "test group",
            'page_permissions-0-page': [''],
            'page_permissions-TOTAL_FORMS': ['1'],
            'document_permissions-0-collection': [''],
            'document_permissions-TOTAL_FORMS': ['1'],
        })

        self.assertRedirects(response, reverse('wagtailusers_groups:index'))
        # The test group now exists, with no page / document permissions
        new_group = Group.objects.get(name='test group')
        self.assertEqual(new_group.page_permissions.all().count(), 0)
        self.assertEqual(
            new_group.collection_permissions.filter(permission=self.add_doc_permission).count(),
            0
        )

</source>
</class>

<class classid="6" nclones="2" nlines="13" similarity="73">
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_admin_views.py" startline="1196" endline="1218" pcid="137">
    def test_duplicate_document_permissions_error(self):
        # Try to submit multiple document permission entries for the same collection
        root_collection = Collection.get_first_root_node()
        response = self.post({
            'name': "test group",
            'document_permissions-0-collection': [root_collection.pk],
            'document_permissions-0-permissions': [self.add_doc_permission.pk],
            'document_permissions-1-collection': [root_collection.pk],
            'document_permissions-1-permissions': [self.change_doc_permission.pk],
            'document_permissions-TOTAL_FORMS': ['2'],
        })

        self.assertEqual(response.status_code, 200)
        # formset should have a non-form error about the duplication
        # (we don't know what index in permission_panels the formset will be,
        # so just assert that it happens on at least one permission_panel)
        self.assertTrue(
            any(
                hasattr(panel, 'non_form_errors') and panel.non_form_errors
                for panel in response.context['permission_panels']
            )
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_admin_views.py" startline="1563" endline="1579" pcid="158">
    def test_duplicate_document_permissions_error(self):
        # Try to submit multiple document permission entries for the same collection
        response = self.post({
            'document_permissions-1-page': [self.evil_plans_collection.pk],
            'document_permissions-1-permissions': [self.change_doc_permission],
            'document_permissions-TOTAL_FORMS': ['2'],
        })

        self.assertEqual(response.status_code, 200)
        # the formset should have a non-form error
        self.assertTrue(
            any(
                hasattr(panel, 'non_form_errors') and panel.non_form_errors
                for panel in response.context['permission_panels']
            )
        )

</source>
</class>

<class classid="7" nclones="3" nlines="14" similarity="85">
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_admin_views.py" startline="1374" endline="1398" pcid="150">
    def test_group_edit_adding_document_permissions_same_collection(self):
        # The test group has one document permission to begin with -
        # 'add' permission on evil_plans.
        # Add 'change' permission on evil_plans
        self.assertEqual(
            self.test_group.collection_permissions.filter(
                permission__content_type__app_label='wagtaildocs'
            ).count(),
            1
        )
        response = self.post({
            'document_permissions-0-permissions': [
                self.add_doc_permission.pk, self.change_doc_permission.pk
            ],
        })

        self.assertRedirects(response, reverse('wagtailusers_groups:index'))
        # The test group now has two document permissions
        self.assertEqual(
            self.test_group.collection_permissions.filter(
                permission__content_type__app_label='wagtaildocs'
            ).count(),
            2
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_admin_views.py" startline="1438" endline="1459" pcid="153">
    def test_group_edit_deleting_document_permissions(self):
        # The test group has one document permission to begin with
        self.assertEqual(
            self.test_group.collection_permissions.filter(
                permission__content_type__app_label='wagtaildocs'
            ).count(),
            1
        )

        response = self.post({
            'document_permissions-0-DELETE': ['1'],
        })

        self.assertRedirects(response, reverse('wagtailusers_groups:index'))
        # The test group now has zero document permissions
        self.assertEqual(
            self.test_group.collection_permissions.filter(
                permission__content_type__app_label='wagtaildocs'
            ).count(),
            0
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_admin_views.py" startline="1399" endline="1425" pcid="151">
    def test_group_edit_adding_document_permissions_different_collection(self):
        # The test group has one document permission to begin with -
        # 'add' permission on evil_plans.
        # Add 'add' and 'change' permission on the root collection
        self.assertEqual(
            self.test_group.collection_permissions.filter(
                permission__content_type__app_label='wagtaildocs'
            ).count(),
            1
        )
        response = self.post({
            'document_permissions-TOTAL_FORMS': ['2'],
            'document_permissions-1-collection': [self.root_collection.pk],
            'document_permissions-1-permissions': [
                self.add_doc_permission.pk, self.change_doc_permission.pk
            ],
        })

        self.assertRedirects(response, reverse('wagtailusers_groups:index'))
        # The test group now has three document permissions
        self.assertEqual(
            self.test_group.collection_permissions.filter(
                permission__content_type__app_label='wagtaildocs'
            ).count(),
            3
        )

</source>
</class>

<class classid="8" nclones="12" nlines="13" similarity="71">
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_bulk_actions/test_bulk_assign_role.py" startline="47" endline="64" pcid="172">
    def test_before_toggle_user_hook_post(self):
        def hook_func(request, action_type, users, action_class_instance):
            self.assertEqual(action_type, 'assign_role')
            self.assertIsInstance(request, HttpRequest)
            self.assertIsInstance(action_class_instance, UserBulkAction)
            self.assertCountEqual([user.pk for user in self.test_users], [user.pk for user in users])

            return HttpResponse("Overridden!")

        with self.register_hook('before_bulk_action', hook_func):
            response = self.client.post(self.url, self.post_data)

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")

        for user in self.test_users:
            self.assertFalse(User.objects.get(email=user.email).groups.filter(name=self.new_group).exists())

</source>
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_bulk_actions/test_bulk_delete.py" startline="82" endline="99" pcid="189">
    def test_before_delete_user_hook_post(self):
        def hook_func(request, action_type, users, action_class_instance):
            self.assertEqual(action_type, 'delete')
            self.assertIsInstance(request, HttpRequest)
            self.assertIsInstance(action_class_instance, UserBulkAction)
            self.assertCountEqual([user.pk for user in self.test_users], [user.pk for user in users])

            return HttpResponse("Overridden!")

        with self.register_hook('before_bulk_action', hook_func):
            response = self.client.post(self.url)

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")

        for user in self.test_users:
            self.assertTrue(User.objects.filter(email=user.email).exists())

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_bulk_actions/test_bulk_delete.py" startline="255" endline="274" pcid="1983">
    def test_before_delete_page_hook(self):

        def hook_func(request, action_type, pages, action_class_instance):
            self.assertEqual(action_type, 'delete')
            self.assertIsInstance(request, HttpRequest)
            self.assertIsInstance(action_class_instance, PageBulkAction)
            for i, page in enumerate(pages):
                self.assertEqual(page.id, self.pages_to_be_deleted[i].id)
            return HttpResponse("Overridden!")

        with self.register_hook('before_bulk_action', hook_func):
            response = self.client.post(self.url)

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")

        # Check that the child pages are not deleted
        for child_page in self.child_pages:
            self.assertTrue(SimplePage.objects.filter(id=child_page.id).exists())

</source>
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_bulk_actions/test_bulk_set_active_state.py" startline="82" endline="98" pcid="182">
    def test_after_toggle_user_hook(self):
        def hook_func(request, action_type, users, action_class_instance):
            self.assertEqual(action_type, 'set_active_state')
            self.assertIsInstance(request, HttpRequest)
            self.assertIsInstance(action_class_instance, UserBulkAction)
            self.assertCountEqual([user.pk for user in self.test_users], [user.pk for user in users])

            return HttpResponse("Overridden!")

        with self.register_hook('after_bulk_action', hook_func):
            response = self.client.post(self.url, self.make_active_data)

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")

        for user in self.test_users:
            self.assertTrue(User.objects.get(email=user.email).is_active)
</source>
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_bulk_actions/test_bulk_delete.py" startline="100" endline="115" pcid="191">
    def test_after_delete_user_hook(self):
        def hook_func(request, action_type, users, action_class_instance):
            self.assertEqual(action_type, 'delete')
            self.assertIsInstance(request, HttpRequest)
            self.assertIsInstance(action_class_instance, UserBulkAction)

            return HttpResponse("Overridden!")

        with self.register_hook('after_bulk_action', hook_func):
            response = self.client.post(self.url)

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")

        for user in self.test_users:
            self.assertFalse(User.objects.filter(email=user.email).exists())
</source>
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_bulk_actions/test_bulk_assign_role.py" startline="65" endline="81" pcid="174">
    def test_after_toggle_user_hook(self):
        def hook_func(request, action_type, users, action_class_instance):
            self.assertEqual(action_type, 'assign_role')
            self.assertIsInstance(request, HttpRequest)
            self.assertIsInstance(action_class_instance, UserBulkAction)
            self.assertCountEqual([user.pk for user in self.test_users], [user.pk for user in users])

            return HttpResponse("Overridden!")

        with self.register_hook('after_bulk_action', hook_func):
            response = self.client.post(self.url, self.post_data)

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")

        for user in self.test_users:
            self.assertTrue(User.objects.get(email=user.email).groups.filter(name=self.new_group).exists())
</source>
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_bulk_actions/test_bulk_set_active_state.py" startline="67" endline="81" pcid="180">
    def test_before_toggle_user_hook_post(self):
        def hook_func(request, action_type, users, action_class_instance):
            self.assertEqual(action_type, 'set_active_state')
            self.assertIsInstance(request, HttpRequest)
            self.assertIsInstance(action_class_instance, UserBulkAction)
            self.assertCountEqual([user.pk for user in self.test_users], [user.pk for user in users])

            return HttpResponse("Overridden!")

        with self.register_hook('before_bulk_action', hook_func):
            response = self.client.post(self.url, self.make_active_data)

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_bulk_actions/test_bulk_unpublish.py" startline="135" endline="151" pcid="1941">
    def test_before_unpublish_page(self):

        def hook_func(request, action_type, pages, action_class_instance):
            self.assertEqual(action_type, 'unpublish')
            self.assertIsInstance(request, HttpRequest)
            self.assertIsInstance(action_class_instance, PageBulkAction)
            for i, page in enumerate(pages):
                self.assertEqual(page.id, self.pages_to_be_unpublished[i].id)

            return HttpResponse("Overridden!")

        with self.register_hook('before_bulk_action', hook_func):
            response = self.client.post(self.url)

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_bulk_actions/test_bulk_unpublish.py" startline="114" endline="134" pcid="1939">
    def test_after_unpublish_page(self):

        def hook_func(request, action_type, pages, action_class_instance):
            self.assertEqual(action_type, 'unpublish')
            self.assertIsInstance(request, HttpRequest)
            self.assertIsInstance(action_class_instance, PageBulkAction)
            for i, page in enumerate(pages):
                self.assertEqual(page.id, self.pages_to_be_unpublished[i].id)

            return HttpResponse("Overridden!")

        with self.register_hook('after_bulk_action', hook_func):
            response = self.client.post(self.url)

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")

        for child_page in self.pages_to_be_unpublished:
            child_page.refresh_from_db()
            self.assertEqual(child_page.status_string, _("draft"))

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_bulk_actions/test_bulk_publish.py" startline="144" endline="160" pcid="1966">
    def test_before_publish_page(self):

        def hook_func(request, action_type, pages, action_class_instance):
            self.assertEqual(action_type, 'publish')
            self.assertIsInstance(request, HttpRequest)
            self.assertIsInstance(action_class_instance, PageBulkAction)
            for i, page in enumerate(pages):
                self.assertEqual(page.id, self.pages_to_be_published[i].id)

            return HttpResponse("Overridden!")

        with self.register_hook('before_bulk_action', hook_func):
            response = self.client.post(self.url)

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_bulk_actions/test_bulk_delete.py" startline="275" endline="298" pcid="1985">
    def test_after_delete_page_hook(self):

        def hook_func(request, action_type, pages, action_class_instance):
            self.assertEqual(action_type, 'delete')
            self.assertIsInstance(request, HttpRequest)
            self.assertIsInstance(action_class_instance, PageBulkAction)
            for i, page in enumerate(pages):
                self.assertEqual(page.id, self.pages_to_be_deleted[i].id)

            return HttpResponse("Overridden!")

        with self.register_hook('after_bulk_action', hook_func):
            response = self.client.post(self.url)

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")

        # Check that the child pages to be deleted are gone
        for child_page in self.pages_to_be_deleted:
            self.assertFalse(SimplePage.objects.filter(id=child_page.id).exists())

        # Check that the child pages not to be deleted remain
        for child_page in self.pages_not_to_be_deleted:
            self.assertTrue(SimplePage.objects.filter(id=child_page.id).exists())
</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_bulk_actions/test_bulk_publish.py" startline="123" endline="143" pcid="1964">
    def test_after_publish_page(self):

        def hook_func(request, action_type, pages, action_class_instance):
            self.assertEqual(action_type, 'publish')
            self.assertIsInstance(request, HttpRequest)
            self.assertIsInstance(action_class_instance, PageBulkAction)
            for i, page in enumerate(pages):
                self.assertEqual(page.id, self.pages_to_be_published[i].id)

            return HttpResponse("Overridden!")

        with self.register_hook('after_bulk_action', hook_func):
            response = self.client.post(self.url)

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")

        for child_page in self.pages_to_be_published:
            child_page.refresh_from_db()
            self.assertEqual(child_page.status_string, _("live"))

</source>
</class>

<class classid="9" nclones="2" nlines="11" similarity="81">
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_bulk_actions/test_bulk_set_active_state.py" startline="52" endline="66" pcid="179">
    def test_user_cannot_mark_self_as_inactive(self):
        response = self.client.get(self.self_toggle_url)

        self.assertEqual(response.status_code, 200)
        html = response.content.decode()
        self.assertInHTML("<p>You cannot change your own active status</p>", html)

        needle = '<ul>'
        needle += '<li>{user_email}</li>'.format(user_email=self.current_user.email)
        needle += '</ul>'
        self.assertInHTML(needle, html)

        # Check user was not marked as inactive
        self.assertTrue(User.objects.get(pk=self.current_user.pk).is_active)

</source>
<source file="systems/wagtail-2.16.1/wagtail/users/tests/test_bulk_actions/test_bulk_delete.py" startline="52" endline="68" pcid="187">
    def test_user_cannot_delete_self(self):
        response = self.client.get(self.self_delete_url)

        self.assertEqual(response.status_code, 200)
        html = response.content.decode()
        self.assertInHTML("<p>You don't have permission to delete this user</p>", html)

        needle = '<ul>'
        needle += '<li>{user_email}</li>'.format(user_email=self.current_user.email)
        needle += '</ul>'
        self.assertInHTML(needle, html)

        response = self.client.post(self.self_delete_url)

        # Check user was not deleted
        self.assertTrue(User.objects.filter(pk=self.current_user.pk).exists())

</source>
</class>

<class classid="10" nclones="2" nlines="10" similarity="90">
<source file="systems/wagtail-2.16.1/wagtail/contrib/typed_table_block/tests.py" startline="61" endline="76" pcid="221">
    def test_value_from_datadict(self):
        """
        Test that we can turn posted form data into a TypedTable instance,
        accounting for row reordering and deleted rows.
        """
        table = self.block.value_from_datadict(self.form_data, {}, 'table')

        self.assertIsInstance(table, TypedTable)
        self.assertEqual(len(table.columns), 2)
        self.assertEqual(table.columns[0]['heading'], 'Country')
        self.assertEqual(table.columns[1]['heading'], 'Description')
        rows = list(table.rows)
        self.assertEqual(len(rows), 2)
        self.assertEqual([block.value for block in rows[0]], ['nl', 'A small country with stroopwafels'])
        self.assertEqual([block.value for block in rows[1]], ['fr', 'A large country with baguettes'])

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/typed_table_block/tests.py" startline="123" endline="136" pcid="223">
    def test_to_python(self):
        """
        Test that we can turn JSONish data from the database into a TypedTable instance
        """
        table = self.block.to_python(self.db_data)
        self.assertIsInstance(table, TypedTable)
        self.assertEqual(len(table.columns), 2)
        self.assertEqual(table.columns[0]['heading'], 'Country')
        self.assertEqual(table.columns[1]['heading'], 'Description')
        rows = list(table.rows)
        self.assertEqual(len(rows), 2)
        self.assertEqual([block.value for block in rows[0]], ['nl', 'A small country with stroopwafels'])
        self.assertEqual([block.value for block in rows[1]], ['fr', 'A large country with baguettes'])

</source>
</class>

<class classid="11" nclones="2" nlines="15" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/contrib/postgres_search/tests/test_stemming.py" startline="22" endline="43" pcid="231">
    def test_ru_stemming(self):
        with connection.cursor() as cursor:
            cursor.execute(
                "SET default_text_search_config TO 'pg_catalog.russian'"
            )

        ru_book = models.Book.objects.create(
            title=" ", publication_date="1999-05-01",
            number_of_pages=352
        )
        self.backend.add(ru_book)

        results = self.backend.search("", models.Book)
        self.assertEqual(list(results), [ru_book])

        results = self.backend.search("", models.Book)
        self.assertEqual(list(results), [ru_book])

        results = self.backend.search("", models.Book)
        self.assertEqual(list(results), [ru_book])

        ru_book.delete()
</source>
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_postgres_stemming.py" startline="22" endline="43" pcid="5664">
    def test_ru_stemming(self):
        with connection.cursor() as cursor:
            cursor.execute(
                "SET default_text_search_config TO 'pg_catalog.russian'"
            )

        ru_book = models.Book.objects.create(
            title=" ", publication_date="1999-05-01",
            number_of_pages=352
        )
        self.backend.add(ru_book)

        results = self.backend.search("", models.Book)
        self.assertEqual(list(results), [ru_book])

        results = self.backend.search("", models.Book)
        self.assertEqual(list(results), [ru_book])

        results = self.backend.search("", models.Book)
        self.assertEqual(list(results), [ru_book])

        ru_book.delete()
</source>
</class>

<class classid="12" nclones="2" nlines="26" similarity="92">
<source file="systems/wagtail-2.16.1/wagtail/contrib/postgres_search/tests/test_backend.py" startline="12" endline="39" pcid="232">
    def test_weights(self):
        self.assertListEqual(BOOSTS_WEIGHTS,
                             [(10, 'A'), (2, 'B'), (0.5, 'C'), (0.25, 'D')])
        self.assertListEqual(WEIGHTS_VALUES, [0.025, 0.05, 0.2, 1.0])

        self.assertEqual(get_weight(15), 'A')
        self.assertEqual(get_weight(10), 'A')
        self.assertEqual(get_weight(9.9), 'B')
        self.assertEqual(get_weight(2), 'B')
        self.assertEqual(get_weight(1.9), 'C')
        self.assertEqual(get_weight(0), 'D')
        self.assertEqual(get_weight(-1), 'D')

        self.assertListEqual(determine_boosts_weights([1]),
                             [(1, 'A'), (0, 'B'), (0, 'C'), (0, 'D')])
        self.assertListEqual(determine_boosts_weights([-1]),
                             [(-1, 'A'), (-1, 'B'), (-1, 'C'), (-1, 'D')])
        self.assertListEqual(determine_boosts_weights([-1, 1, 2]),
                             [(2, 'A'), (1, 'B'), (-1, 'C'), (-1, 'D')])
        self.assertListEqual(determine_boosts_weights([0, 1, 2, 3]),
                             [(3, 'A'), (2, 'B'), (1, 'C'), (0, 'D')])
        self.assertListEqual(determine_boosts_weights([0, 0.25, 0.75, 1, 1.5]),
                             [(1.5, 'A'), (1, 'B'), (0.5, 'C'), (0, 'D')])
        self.assertListEqual(determine_boosts_weights([0, 1, 2, 3, 4, 5, 6]),
                             [(6, 'A'), (4, 'B'), (2, 'C'), (0, 'D')])
        self.assertListEqual(determine_boosts_weights([-2, -1, 0, 1, 2, 3, 4]),
                             [(4, 'A'), (2, 'B'), (0, 'C'), (-2, 'D')])

</source>
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_postgres_backend.py" startline="20" endline="49" pcid="5679">
    def test_weights(self):
        from ..backends.database.postgres.weights import (
            BOOSTS_WEIGHTS, WEIGHTS_VALUES, determine_boosts_weights, get_weight)
        self.assertListEqual(BOOSTS_WEIGHTS,
                             [(10, 'A'), (2, 'B'), (0.5, 'C'), (0.25, 'D')])
        self.assertListEqual(WEIGHTS_VALUES, [0.025, 0.05, 0.2, 1.0])

        self.assertEqual(get_weight(15), 'A')
        self.assertEqual(get_weight(10), 'A')
        self.assertEqual(get_weight(9.9), 'B')
        self.assertEqual(get_weight(2), 'B')
        self.assertEqual(get_weight(1.9), 'C')
        self.assertEqual(get_weight(0), 'D')
        self.assertEqual(get_weight(-1), 'D')

        self.assertListEqual(determine_boosts_weights([1]),
                             [(1, 'A'), (0, 'B'), (0, 'C'), (0, 'D')])
        self.assertListEqual(determine_boosts_weights([-1]),
                             [(-1, 'A'), (-1, 'B'), (-1, 'C'), (-1, 'D')])
        self.assertListEqual(determine_boosts_weights([-1, 1, 2]),
                             [(2, 'A'), (1, 'B'), (-1, 'C'), (-1, 'D')])
        self.assertListEqual(determine_boosts_weights([0, 1, 2, 3]),
                             [(3, 'A'), (2, 'B'), (1, 'C'), (0, 'D')])
        self.assertListEqual(determine_boosts_weights([0, 0.25, 0.75, 1, 1.5]),
                             [(1.5, 'A'), (1, 'B'), (0.5, 'C'), (0, 'D')])
        self.assertListEqual(determine_boosts_weights([0, 1, 2, 3, 4, 5, 6]),
                             [(6, 'A'), (4, 'B'), (2, 'C'), (0, 'D')])
        self.assertListEqual(determine_boosts_weights([-2, -1, 0, 1, 2, 3, 4]),
                             [(4, 'A'), (2, 'B'), (0, 'C'), (-2, 'D')])

</source>
</class>

<class classid="13" nclones="4" nlines="31" similarity="90">
<source file="systems/wagtail-2.16.1/wagtail/contrib/postgres_search/tests/test_backend.py" startline="40" endline="86" pcid="233">
    def test_search_tsquery_chars(self):
        """
        Checks that tsquery characters are correctly escaped
        and do not generate a PostgreSQL syntax error.
        """

        # Simple quote should be escaped inside each tsquery term.
        results = self.backend.search("L'amour piqu par une abeille",
                                      models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])
        results = self.backend.search("'starting quote",
                                      models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])
        results = self.backend.search("ending quote'",
                                      models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])
        results = self.backend.search("double quo''te",
                                      models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])
        results = self.backend.search("triple quo'''te",
                                      models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])

        # Now suffixes.
        results = self.backend.search("Something:B", models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])
        results = self.backend.search("Something:*", models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])
        results = self.backend.search("Something:A*BCD", models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])

        # Now the AND operator.
        results = self.backend.search("first & second", models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])

        # Now the OR operator.
        results = self.backend.search("first | second", models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])

        # Now the NOT operator.
        results = self.backend.search("first & !second", models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])

        # Now the phrase operator.
        results = self.backend.search("first <-> second", models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])

</source>
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_postgres_backend.py" startline="50" endline="96" pcid="5680">
    def test_search_tsquery_chars(self):
        """
        Checks that tsquery characters are correctly escaped
        and do not generate a PostgreSQL syntax error.
        """

        # Simple quote should be escaped inside each tsquery term.
        results = self.backend.search("L'amour piqu par une abeille",
                                      models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])
        results = self.backend.search("'starting quote",
                                      models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])
        results = self.backend.search("ending quote'",
                                      models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])
        results = self.backend.search("double quo''te",
                                      models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])
        results = self.backend.search("triple quo'''te",
                                      models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])

        # Now suffixes.
        results = self.backend.search("Something:B", models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])
        results = self.backend.search("Something:*", models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])
        results = self.backend.search("Something:A*BCD", models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])

        # Now the AND operator.
        results = self.backend.search("first & second", models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])

        # Now the OR operator.
        results = self.backend.search("first | second", models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])

        # Now the NOT operator.
        results = self.backend.search("first & !second", models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])

        # Now the phrase operator.
        results = self.backend.search("first <-> second", models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/postgres_search/tests/test_backend.py" startline="87" endline="138" pcid="234">
    def test_autocomplete_tsquery_chars(self):
        """
        Checks that tsquery characters are correctly escaped
        and do not generate a PostgreSQL syntax error.
        """

        # Simple quote should be escaped inside each tsquery term.
        results = self.backend.autocomplete("L'amour piqu par une abeille",
                                            models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])
        results = self.backend.autocomplete("'starting quote",
                                            models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])
        results = self.backend.autocomplete("ending quote'",
                                            models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])
        results = self.backend.autocomplete("double quo''te",
                                            models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])
        results = self.backend.autocomplete("triple quo'''te",
                                            models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])

        # Backslashes should be escaped inside each tsquery term.
        results = self.backend.autocomplete("backslash\\",
                                            models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])

        # Now suffixes.
        results = self.backend.autocomplete("Something:B", models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])
        results = self.backend.autocomplete("Something:*", models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])
        results = self.backend.autocomplete("Something:A*BCD", models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])

        # Now the AND operator.
        results = self.backend.autocomplete("first & second", models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])

        # Now the OR operator.
        results = self.backend.autocomplete("first | second", models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])

        # Now the NOT operator.
        results = self.backend.autocomplete("first & !second", models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])

        # Now the phrase operator.
        results = self.backend.autocomplete("first <-> second", models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])

</source>
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_postgres_backend.py" startline="97" endline="148" pcid="5681">
    def test_autocomplete_tsquery_chars(self):
        """
        Checks that tsquery characters are correctly escaped
        and do not generate a PostgreSQL syntax error.
        """

        # Simple quote should be escaped inside each tsquery term.
        results = self.backend.autocomplete("L'amour piqu par une abeille",
                                            models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])
        results = self.backend.autocomplete("'starting quote",
                                            models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])
        results = self.backend.autocomplete("ending quote'",
                                            models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])
        results = self.backend.autocomplete("double quo''te",
                                            models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])
        results = self.backend.autocomplete("triple quo'''te",
                                            models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])

        # Backslashes should be escaped inside each tsquery term.
        results = self.backend.autocomplete("backslash\\",
                                            models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])

        # Now suffixes.
        results = self.backend.autocomplete("Something:B", models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])
        results = self.backend.autocomplete("Something:*", models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])
        results = self.backend.autocomplete("Something:A*BCD", models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])

        # Now the AND operator.
        results = self.backend.autocomplete("first & second", models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])

        # Now the OR operator.
        results = self.backend.autocomplete("first | second", models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])

        # Now the NOT operator.
        results = self.backend.autocomplete("first & !second", models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])

        # Now the phrase operator.
        results = self.backend.autocomplete("first <-> second", models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [])

</source>
</class>

<class classid="14" nclones="2" nlines="17" similarity="76">
<source file="systems/wagtail-2.16.1/wagtail/contrib/routable_page/tests.py" startline="225" endline="244" pcid="277">
    def setUp(self):
        default_site = Site.objects.get(is_default_site=True)
        second_site = Site.objects.create(  # add another site with the same root page
            hostname='development.local',
            port=default_site.port,
            root_page_id=default_site.root_page_id,
        )

        self.home_page = Page.objects.get(id=2)
        self.routable_page = self.home_page.add_child(instance=RoutablePageTest(
            title="Routable Page",
            live=True,
        ))

        self.rf = RequestFactory()
        self.request = self.rf.get(self.routable_page.url)
        self.context = {'request': self.request}
        self.request.META['HTTP_HOST'] = second_site.hostname
        self.request.META['SERVER_PORT'] = second_site.port

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/routable_page/tests.py" startline="282" endline="304" pcid="283">
    def setUp(self):
        self.home_page = Page.objects.get(id=2)

        events_page = self.home_page.add_child(instance=Page(title='Events', live=True))

        second_site = Site.objects.create(
            hostname='events.local',
            port=80,
            root_page=events_page,
        )

        self.routable_page = self.home_page.add_child(instance=RoutablePageTest(
            title="Routable Page",
            live=True,
        ))

        self.rf = RequestFactory()
        self.request = self.rf.get(self.routable_page.url)
        self.context = {'request': self.request}

        self.request.META['HTTP_HOST'] = second_site.hostname
        self.request.META['SERVER_PORT'] = second_site.port

</source>
</class>

<class classid="15" nclones="2" nlines="11" similarity="72">
<source file="systems/wagtail-2.16.1/wagtail/contrib/table_block/tests.py" startline="56" endline="81" pcid="292">
    def test_table_block_alignment_render(self):
        """
        Test a generic render with some cells aligned.
        """
        value = {'first_row_is_table_header': True, 'first_col_is_header': False,
                 'cell': [{'row': 0, 'col': 1, 'className': 'htLeft'},
                          {'row': 1, 'col': 1, 'className': 'htRight'}],
                 'data': [['Test 1', 'Test 2', 'Test 3'], [None, None, None],
                          [None, None, None]]}
        block = TableBlock()
        result = block.render(value)
        expected = """
            <table>
                <thead>
                    <tr><th scope="col">Test 1</th><th scope="col" class="htLeft">Test 2</th><th scope="col">Test 3</th></tr>
                </thead>
                <tbody>
                    <tr><td></td><td class="htRight"></td><td></td></tr>
                    <tr><td></td><td></td><td></td></tr>
                </tbody>
            </table>
        """

        self.assertHTMLEqual(result, expected)
        self.assertIn('Test 2', result)

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/table_block/tests.py" startline="253" endline="275" pcid="303">
    def test_table_block_caption_render(self):
        """
        Test a generic render with caption.
        """
        value = {'table_caption': 'caption', 'first_row_is_table_header': False,
                 'first_col_is_header': False,
                 'data': [['Test 1', 'Test 2', 'Test 3'], [None, None, None],
                          [None, None, None]]}
        block = TableBlock()
        result = block.render(value)
        expected = """
            <table>
                <caption>caption</caption>
                <tbody>
                    <tr><td>Test 1</td><td>Test 2</td><td>Test 3</td></tr>
                    <tr><td></td><td></td><td></td></tr>
                    <tr><td></td><td></td><td></td></tr>
                </tbody>
            </table>
        """
        self.assertHTMLEqual(result, expected)
        self.assertIn('Test 2', result)

</source>
</class>

<class classid="16" nclones="2" nlines="16" similarity="70">
<source file="systems/wagtail-2.16.1/wagtail/contrib/table_block/tests.py" startline="291" endline="309" pcid="305">
    def setUp(self):
        # test value for table data
        self.value = {
            'first_row_is_table_header': True,
            'first_col_is_header': True,
            'data': [
                ['Ship', 'Type', 'Status'],
                ['Galactica', 'Battlestar', 'Active'],
                ['Valkyrie', 'Battlestar', 'Destroyed'],
                ['Cylon Basestar', 'Basestar', 'Active'],
                ['Brenik', 'Small Military Vessel', 'Destroyed'],
            ]
        }
        # set language from testing environment
        language = translation.get_language()

        self.default_table_options = DEFAULT_TABLE_OPTIONS.copy()
        self.default_table_options['language'] = language

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/table_block/tests.py" startline="412" endline="431" pcid="312">
    def setUp(self):
        self.value = {
            'first_row_is_table_header': True,
            'first_col_is_header': True,
            'data': [
                ['Ship', 'Type', 'Status'],
                ['Galactica', 'Battlestar', 'Active'],
                ['Valkyrie', 'Battlestar', 'Destroyed'],
                ['Cylon Basestar', 'Basestar', 'Active'],
                ['Brenik', 'Small Military Vessel', 'Destroyed'],
            ]
        }
        self.root_page = Page.objects.get(id=2)
        table_block_page_instance = TableBlockStreamPage(
            title='Ships',
            table=json.dumps([{'type': 'table', 'value': self.value}])
        )
        self.table_block_page = self.root_page.add_child(instance=table_block_page_instance)
        self.user = self.login()

</source>
</class>

<class classid="17" nclones="3" nlines="14" similarity="80">
<source file="systems/wagtail-2.16.1/wagtail/contrib/table_block/tests.py" startline="383" endline="399" pcid="310">
    def test_adapt(self):
        block = TableBlock()

        block.set_name('test_tableblock')
        js_args = FieldBlockAdapter().js_args(block)

        self.assertEqual(js_args[0], 'test_tableblock')
        self.assertIsInstance(js_args[1], TableInput)
        self.assertEqual(js_args[2], {
            'label': 'Test tableblock',
            'required': True,
            'icon': 'table',
            'classname': 'field char_field widget-table_input fieldname-test_tableblock',
            'showAddCommentButton': True,
            'strings': {'ADD_COMMENT': 'Add Comment'}
        })

</source>
<source file="systems/wagtail-2.16.1/wagtail/snippets/tests.py" startline="1616" endline="1634" pcid="3064">
    def test_adapt(self):
        block = SnippetChooserBlock(AdvertWithCustomPrimaryKey, help_text="pick an advert, any advert")

        block.set_name('test_snippetchooserblock')
        js_args = FieldBlockAdapter().js_args(block)

        self.assertEqual(js_args[0], 'test_snippetchooserblock')
        self.assertIsInstance(js_args[1], AdminSnippetChooser)
        self.assertEqual(js_args[1].target_model, AdvertWithCustomPrimaryKey)
        self.assertEqual(js_args[2], {
            'label': 'Test snippetchooserblock',
            'required': True,
            'icon': 'snippet',
            'helpText': 'pick an advert, any advert',
            'classname': 'field model_choice_field widget-admin_snippet_chooser fieldname-test_snippetchooserblock',
            'showAddCommentButton': True,
            'strings': {'ADD_COMMENT': 'Add Comment'}
        })

</source>
<source file="systems/wagtail-2.16.1/wagtail/snippets/tests.py" startline="1438" endline="1456" pcid="3042">
    def test_adapt(self):
        block = SnippetChooserBlock(Advert, help_text="pick an advert, any advert")

        block.set_name('test_snippetchooserblock')
        js_args = FieldBlockAdapter().js_args(block)

        self.assertEqual(js_args[0], 'test_snippetchooserblock')
        self.assertIsInstance(js_args[1], AdminSnippetChooser)
        self.assertEqual(js_args[1].target_model, Advert)
        self.assertEqual(js_args[2], {
            'label': 'Test snippetchooserblock',
            'required': True,
            'icon': 'snippet',
            'helpText': 'pick an advert, any advert',
            'classname': 'field model_choice_field widget-admin_snippet_chooser fieldname-test_snippetchooserblock',
            'showAddCommentButton': True,
            'strings': {'ADD_COMMENT': 'Add Comment'}
        })

</source>
</class>

<class classid="18" nclones="2" nlines="11" similarity="81">
<source file="systems/wagtail-2.16.1/wagtail/contrib/redirects/tests/test_redirects.py" startline="247" endline="267" pcid="398">
    def test_duplicate_redirects_with_query_string_when_match_is_for_generic(self):
        contact_page = Page.objects.get(url_path='/home/contact-us/')
        site = Site.objects.create(hostname='other.example.com', port=80, root_page=contact_page)

        # two redirects, one for any site, one for specific, both with query string
        models.Redirect.objects.create(old_path='/xmas?foo=Bar', redirect_link='/generic-with-query-string')
        models.Redirect.objects.create(site=site, old_path='/xmas?foo=Bar', redirect_link='/site-specific-with-query-string')

        # and two redirects, one for any site, one for specific, without query strings
        models.Redirect.objects.create(old_path='/xmas', redirect_link='/generic')
        models.Redirect.objects.create(site=site, old_path='/xmas', redirect_link='/site-specific')

        response = self.client.get('/xmas/?foo=Bar')
        # the redirect which matched was /generic-with-query-string
        self.assertRedirects(response, '/generic-with-query-string', status_code=301, fetch_redirect_response=False)

        # now use a non-matching query string
        response = self.client.get('/xmas/?foo=Baz')
        # the redirect which matched was /generic
        self.assertRedirects(response, '/generic', status_code=301, fetch_redirect_response=False)

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/redirects/tests/test_redirects.py" startline="280" endline="300" pcid="400">
    def test_duplicate_redirects_with_query_string_when_match_is_for_specific_with_qs(self):
        contact_page = Page.objects.get(url_path='/home/contact-us/')
        site = Site.objects.create(hostname='other.example.com', port=80, root_page=contact_page)

        # two redirects, one for any site, one for specific, both with query string
        models.Redirect.objects.create(old_path='/xmas?foo=Bar', redirect_link='/generic-with-query-string')
        models.Redirect.objects.create(site=site, old_path='/xmas?foo=Bar', redirect_link='/site-specific-with-query-string')

        # and two redirects, one for any site, one for specific, without query strings
        models.Redirect.objects.create(old_path='/xmas', redirect_link='/generic')
        models.Redirect.objects.create(site=site, old_path='/xmas', redirect_link='/site-specific')

        response = self.client.get('/xmas/?foo=Bar', HTTP_HOST='other.example.com')
        # the redirect which matched was /site-specific-with-query-string
        self.assertRedirects(response, '/site-specific-with-query-string', status_code=301, fetch_redirect_response=False)

        # now use a non-matching query string
        response = self.client.get('/xmas/?foo=Baz', HTTP_HOST='other.example.com')
        # the redirect which matched was /site-specific
        self.assertRedirects(response, '/site-specific', status_code=301, fetch_redirect_response=False)

</source>
</class>

<class classid="19" nclones="2" nlines="11" similarity="72">
<source file="systems/wagtail-2.16.1/wagtail/contrib/redirects/tests/test_redirects.py" startline="345" endline="366" pcid="405">
    def test_add_redirect_with_url(self):
        add_redirect = models.Redirect.add_redirect

        old_path = '/old-path'
        redirect_to = '/new-path'

        # Create a redirect
        redirect = add_redirect(
            old_path=old_path,
            redirect_to=redirect_to,
            is_permanent=False
        )

        # Old path should match in redirect
        self.assertEqual(redirect.old_path, old_path)

        # Redirect page should match in redirect
        self.assertEqual(redirect.link, redirect_to)

        # should use is_permanent kwarg
        self.assertEqual(redirect.is_permanent, False)

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/redirects/tests/test_redirects.py" startline="367" endline="388" pcid="406">
    def test_add_redirect_with_page(self):
        add_redirect = models.Redirect.add_redirect

        old_path = '/old-path'
        redirect_to = Page.objects.get(url_path='/home/events/christmas/')

        # Create a redirect
        redirect = add_redirect(
            old_path=old_path,
            redirect_to=redirect_to
        )

        # Old path should match in redirect
        self.assertEqual(redirect.old_path, old_path)

        # Redirect page should match in redirect
        self.assertEqual(redirect.link, redirect_to.url)

        # should default is_permanent to True
        self.assertEqual(redirect.is_permanent, True)


</source>
</class>

<class classid="20" nclones="3" nlines="12" similarity="84">
<source file="systems/wagtail-2.16.1/wagtail/contrib/redirects/tests/test_import_command.py" startline="71" endline="87" pcid="447">
    def test_redirect_gets_imported(self):
        invalid_file = tempfile.NamedTemporaryFile(mode="w+", encoding="utf-8")
        invalid_file.write("from,to\n")
        invalid_file.write("/alpha,http://omega.test/")
        invalid_file.seek(0)

        out = StringIO()
        call_command(
            "import_redirects", src=invalid_file.name, stdout=out, format="csv"
        )

        self.assertEqual(Redirect.objects.count(), 1)
        redirect = Redirect.objects.first()
        self.assertEqual(redirect.old_path, "/alpha")
        self.assertEqual(redirect.redirect_link, "http://omega.test/")
        self.assertEqual(redirect.is_permanent, True)

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/redirects/tests/test_import_command.py" startline="88" endline="102" pcid="448">
    def test_trailing_slash_gets_stripped(self):
        invalid_file = tempfile.NamedTemporaryFile(mode="w+", encoding="utf-8")
        invalid_file.write("from,to\n")
        invalid_file.write("/alpha/,http://omega.test/")
        invalid_file.seek(0)

        out = StringIO()
        call_command(
            "import_redirects", src=invalid_file.name, stdout=out, format="csv"
        )

        redirect = Redirect.objects.first()
        self.assertEqual(redirect.old_path, "/alpha")
        self.assertEqual(redirect.redirect_link, "http://omega.test/")

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/redirects/tests/test_import_command.py" startline="189" endline="204" pcid="454">
    def test_from_links_are_converted_to_relative(self):
        invalid_file = tempfile.NamedTemporaryFile(mode="w+", encoding="utf-8")
        invalid_file.write("from,to\n")
        invalid_file.write("http://alpha.test/alpha/,http://omega.test/\n")
        invalid_file.seek(0)

        out = StringIO()
        call_command(
            "import_redirects", src=invalid_file.name, format="csv", stdout=out
        )

        self.assertEqual(Redirect.objects.count(), 1)
        redirect = Redirect.objects.first()
        self.assertEqual(redirect.old_path, "/alpha")
        self.assertEqual(redirect.redirect_link, "http://omega.test/")

</source>
</class>

<class classid="21" nclones="8" nlines="17" similarity="70">
<source file="systems/wagtail-2.16.1/wagtail/contrib/redirects/tests/test_import_command.py" startline="108" endline="132" pcid="450">
    def test_redirect_gets_added_to_site(self):
        invalid_file = tempfile.NamedTemporaryFile(mode="w+", encoding="utf-8")
        invalid_file.write("from,to\n")
        invalid_file.write("/alpha/,http://omega.test/")
        invalid_file.seek(0)

        current_site = Site.objects.first()
        site = Site.objects.create(
            hostname="random.test", root_page=current_site.root_page
        )

        out = StringIO()
        call_command(
            "import_redirects",
            src=invalid_file.name,
            site=site.pk,
            stdout=out,
            format="csv",
        )

        redirect = Redirect.objects.first()
        self.assertEqual(redirect.old_path, "/alpha")
        self.assertEqual(redirect.redirect_link, "http://omega.test/")
        self.assertEqual(redirect.site, site)

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/redirects/tests/test_import_command.py" startline="205" endline="226" pcid="455">
    def test_column_index_are_used(self):
        invalid_file = tempfile.NamedTemporaryFile(mode="w+", encoding="utf-8")
        invalid_file.write("priority,from,year,to\n")
        invalid_file.write("5,/alpha,2020,http://omega.test/")
        invalid_file.seek(0)

        out = StringIO()
        call_command(
            "import_redirects",
            "--src={}".format(invalid_file.name),
            "--from=1",
            "--to=3",
            "--format=csv",
            stdout=out,
        )

        self.assertEqual(Redirect.objects.count(), 1)
        redirect = Redirect.objects.first()
        self.assertEqual(redirect.old_path, "/alpha")
        self.assertEqual(redirect.redirect_link, "http://omega.test/")
        self.assertEqual(redirect.is_permanent, True)

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/redirects/tests/test_import_command.py" startline="133" endline="152" pcid="451">
    def test_temporary_redirect(self):
        invalid_file = tempfile.NamedTemporaryFile(mode="w+", encoding="utf-8")
        invalid_file.write("from,to\n")
        invalid_file.write("/alpha/,http://omega.test/")
        invalid_file.seek(0)

        out = StringIO()
        call_command(
            "import_redirects",
            src=invalid_file.name,
            permanent=False,
            stdout=out,
            format="csv",
        )

        redirect = Redirect.objects.first()
        self.assertEqual(redirect.old_path, "/alpha")
        self.assertEqual(redirect.redirect_link, "http://omega.test/")
        self.assertEqual(redirect.is_permanent, False)

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/redirects/tests/test_import_command.py" startline="171" endline="188" pcid="453">
    def test_non_absolute_to_links_get_skipped(self):
        invalid_file = tempfile.NamedTemporaryFile(mode="w+", encoding="utf-8")
        invalid_file.write("from,to\n")
        invalid_file.write("/alpha/,/omega.test/\n")
        invalid_file.seek(0)

        out = StringIO()
        call_command(
            "import_redirects",
            src=invalid_file.name,
            permanent=False,
            stdout=out,
            format="csv",
        )

        self.assertEqual(Redirect.objects.count(), 0)
        self.assertIn("Errors: 1", out.getvalue())

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/redirects/tests/test_import_command.py" startline="153" endline="170" pcid="452">
    def test_duplicate_from_links_get_skipped(self):
        invalid_file = tempfile.NamedTemporaryFile(mode="w+", encoding="utf-8")
        invalid_file.write("from,to\n")
        invalid_file.write("/alpha/,http://omega.test/\n")
        invalid_file.write("/alpha/,http://omega2.test/\n")
        invalid_file.seek(0)

        out = StringIO()
        call_command(
            "import_redirects",
            src=invalid_file.name,
            permanent=False,
            format="csv",
            stdout=out,
        )

        self.assertEqual(Redirect.objects.count(), 1)

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/redirects/tests/test_import_command.py" startline="227" endline="243" pcid="456">
    def test_nothing_gets_saved_on_dry_run(self):
        invalid_file = tempfile.NamedTemporaryFile(mode="w+", encoding="utf-8")
        invalid_file.write("from,to\n")
        invalid_file.write("/alpha,http://omega.test/")
        invalid_file.seek(0)

        out = StringIO()
        call_command(
            "import_redirects",
            src=invalid_file.name,
            format="csv",
            dry_run=True,
            stdout=out,
        )

        self.assertEqual(Redirect.objects.count(), 0)

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/redirects/tests/test_import_command.py" startline="248" endline="264" pcid="457">
    def test_successfull_ask_imports_redirect(self, get_input):
        invalid_file = tempfile.NamedTemporaryFile(mode="w+", encoding="utf-8")
        invalid_file.write("from,to\n")
        invalid_file.write("/alpha,http://omega.test/")
        invalid_file.seek(0)

        out = StringIO()
        call_command(
            "import_redirects",
            src=invalid_file.name,
            format="csv",
            ask=True,
            stdout=out,
        )

        self.assertEqual(Redirect.objects.count(), 1)

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/redirects/tests/test_import_command.py" startline="269" endline="285" pcid="458">
    def test_native_ask_imports_redirect(self, get_input):
        invalid_file = tempfile.NamedTemporaryFile(mode="w+", encoding="utf-8")
        invalid_file.write("from,to\n")
        invalid_file.write("/alpha,http://omega.test/")
        invalid_file.seek(0)

        out = StringIO()
        call_command(
            "import_redirects",
            src=invalid_file.name,
            format="csv",
            ask=True,
            stdout=out,
        )

        self.assertEqual(Redirect.objects.count(), 0)

</source>
</class>

<class classid="22" nclones="2" nlines="22" similarity="91">
<source file="systems/wagtail-2.16.1/wagtail/contrib/redirects/tests/test_import_command.py" startline="286" endline="312" pcid="459">
    def test_offset_parameter(self):
        invalid_file = tempfile.NamedTemporaryFile(mode="w+", encoding="utf-8")
        invalid_file.write("from,to\n")
        invalid_file.write("/one,http://one.test/\n")
        invalid_file.write("/two,http://two.test/\n")
        invalid_file.write("/three,http://three.test/\n")
        invalid_file.write("/four,http://four.test/")
        invalid_file.seek(0)

        out = StringIO()
        call_command(
            "import_redirects",
            src=invalid_file.name,
            format="csv",
            offset=2,
            stdout=out,
        )

        redirects = Redirect.objects.all()

        self.assertEqual(len(redirects), 2)
        self.assertEqual(redirects[0].old_path, "/three")
        self.assertEqual(redirects[0].redirect_link, "http://three.test/")
        self.assertEqual(redirects[0].is_permanent, True)
        self.assertEqual(redirects[1].old_path, "/four")
        self.assertEqual(redirects[1].redirect_link, "http://four.test/")

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/redirects/tests/test_import_command.py" startline="313" endline="336" pcid="460">
    def test_limit_parameter(self):
        invalid_file = tempfile.NamedTemporaryFile(mode="w+", encoding="utf-8")
        invalid_file.write("from,to\n")
        invalid_file.write("/one,http://one.test/\n")
        invalid_file.write("/two,http://two.test/\n")
        invalid_file.write("/three,http://three.test/\n")
        invalid_file.write("/four,http://four.test/")
        invalid_file.seek(0)

        out = StringIO()
        call_command(
            "import_redirects",
            src=invalid_file.name,
            format="csv",
            limit=1,
            stdout=out,
        )

        redirects = Redirect.objects.all()

        self.assertEqual(len(redirects), 1)
        self.assertEqual(redirects[0].old_path, "/one")
        self.assertEqual(redirects[0].redirect_link, "http://one.test/")
        self.assertEqual(redirects[0].is_permanent, True)
</source>
</class>

<class classid="23" nclones="2" nlines="13" similarity="78">
<source file="systems/wagtail-2.16.1/wagtail/contrib/settings/tests/test_templates.py" startline="179" endline="196" pcid="576">
    def render(self, string, context=None, request_context=True):
        if context is None:
            context = {}

        # Add a request to the template, to simulate a RequestContext
        if request_context:
            if 'site' in context:
                site = context['site']
            else:
                site = Site.objects.get(is_default_site=True)
            request = HttpRequest()
            request.META['HTTP_HOST'] = site.hostname
            request.META['SERVER_PORT'] = site.port
            context['request'] = request

        template = self.engine.from_string(string)
        return template.render(context)

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_jinja2.py" startline="18" endline="32" pcid="3795">
    def render(self, string, context=None, request_context=True):
        if context is None:
            context = {}

        # Add a request to the template, to simulate a RequestContext
        if request_context:
            site = Site.objects.get(is_default_site=True)
            request = HttpRequest()
            request.META['HTTP_HOST'] = site.hostname
            request.META['SERVER_PORT'] = site.port
            context['request'] = request

        template = self.engine.from_string(string)
        return template.render(context)

</source>
</class>

<class classid="24" nclones="2" nlines="21" similarity="85">
<source file="systems/wagtail-2.16.1/wagtail/contrib/settings/tests/test_model.py" startline="87" endline="126" pcid="590">
    def test_get_page_url_when_settings_fetched_via_for_request(self):
        """ Using ImportantPages.for_request() makes the setting
        object request-aware, improving efficiency and allowing
        site-relative URLs to be returned """

        self._create_importantpages_object()

        request = self.get_request()
        settings = ImportantPages.for_request(request)

        # Force site root paths query beforehand
        self.default_site.root_page._get_site_root_paths(request)

        for page_fk_field, expected_result in (
            ('sign_up_page', '/'),
            ('general_terms_page', '/'),
            ('privacy_policy_page', 'http://other/'),
        ):
            with self.subTest(page_fk_field=page_fk_field):

                with self.assertNumQueries(1):
                    # because results are cached, only the first
                    # request for a URL will trigger a query to
                    # fetch the page
                    self.assertEqual(
                        settings.get_page_url(page_fk_field),
                        expected_result)

                    # when called directly
                    self.assertEqual(
                        settings.get_page_url(page_fk_field),
                        expected_result
                    )

                    # when called indirectly via shortcut
                    self.assertEqual(
                        getattr(settings.page_url, page_fk_field),
                        expected_result
                    )

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/settings/tests/test_model.py" startline="127" endline="169" pcid="591">
    def test_get_page_url_when_for_settings_fetched_via_for_site(self):
        """ ImportantPages.for_site() cannot make the settings object
        request-aware, so things are a little less efficient, and the
        URLs returned will not be site-relative """
        self._create_importantpages_object()

        settings = ImportantPages.for_site(self.default_site)

        # Force site root paths query beforehand
        self.default_site.root_page._get_site_root_paths()

        for page_fk_field, expected_result in (
            ('sign_up_page', 'http://localhost/'),
            ('general_terms_page', 'http://localhost/'),
            ('privacy_policy_page', 'http://other/'),
        ):
            with self.subTest(page_fk_field=page_fk_field):

                # only the first request for each URL will trigger queries.
                # 2 are triggered instead of 1 here, because tests use the
                # database cache backed, and the cache is queried each time
                # to fetch site root paths (because there's no 'request' to
                # store them on)

                with self.assertNumQueries(2):

                    self.assertEqual(
                        settings.get_page_url(page_fk_field),
                        expected_result
                    )

                    # when called directly
                    self.assertEqual(
                        settings.get_page_url(page_fk_field),
                        expected_result
                    )

                    # when called indirectly via shortcut
                    self.assertEqual(
                        getattr(settings.page_url, page_fk_field),
                        expected_result
                    )

</source>
</class>

<class classid="25" nclones="3" nlines="11" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/contrib/simple_translation/tests/test_views.py" startline="112" endline="126" pcid="631">
    def setUp(self):
        self.en_locale = Locale.objects.first()
        self.fr_locale = Locale.objects.create(language_code="fr")
        self.de_locale = Locale.objects.create(language_code="de")

        self.en_homepage = Page.objects.get(depth=2)
        self.fr_homepage = self.en_homepage.copy_for_translation(self.fr_locale)
        self.de_homepage = self.en_homepage.copy_for_translation(self.de_locale)

        self.en_blog_index = TestPage(title="Blog", slug="blog")
        self.en_homepage.add_child(instance=self.en_blog_index)

        self.en_blog_post = TestPage(title="Blog post", slug="blog-post")
        self.en_blog_index.add_child(instance=self.en_blog_post)

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/simple_translation/tests/test_forms.py" startline="23" endline="37" pcid="649">
    def setUp(self):
        self.en_locale = Locale.objects.first()
        self.fr_locale = Locale.objects.create(language_code="fr")
        self.de_locale = Locale.objects.create(language_code="de")

        self.en_homepage = Page.objects.get(depth=2)
        self.fr_homepage = self.en_homepage.copy_for_translation(self.fr_locale)
        self.de_homepage = self.en_homepage.copy_for_translation(self.de_locale)

        self.en_blog_index = TestPage(title="Blog", slug="blog")
        self.en_homepage.add_child(instance=self.en_blog_index)

        self.en_blog_post = TestPage(title="Blog post", slug="blog-post")
        self.en_blog_index.add_child(instance=self.en_blog_post)

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/simple_translation/tests/test_wagtail_hooks.py" startline="15" endline="30" pcid="656">
    def setUp(self):
        self.en_locale = Locale.objects.first()
        self.fr_locale = Locale.objects.create(language_code="fr")
        self.de_locale = Locale.objects.create(language_code="de")

        self.en_homepage = Page.objects.get(depth=2)
        self.fr_homepage = self.en_homepage.copy_for_translation(self.fr_locale)
        self.de_homepage = self.en_homepage.copy_for_translation(self.de_locale)

        self.en_blog_index = TestPage(title="Blog", slug="blog")
        self.en_homepage.add_child(instance=self.en_blog_index)

        self.en_blog_post = TestPage(title="Blog post", slug="blog-post")
        self.en_blog_index.add_child(instance=self.en_blog_post)


</source>
</class>

<class classid="26" nclones="5" nlines="12" similarity="71">
<source file="systems/wagtail-2.16.1/wagtail/contrib/frontend_cache/tests.py" startline="30" endline="43" pcid="684">
    def test_varnish(self):
        backends = get_backends(backend_settings={
            'varnish': {
                'BACKEND': 'wagtail.contrib.frontend_cache.backends.HTTPBackend',
                'LOCATION': 'http://localhost:8000',
            },
        })

        self.assertEqual(set(backends.keys()), set(['varnish']))
        self.assertIsInstance(backends['varnish'], HTTPBackend)

        self.assertEqual(backends['varnish'].cache_scheme, 'http')
        self.assertEqual(backends['varnish'].cache_netloc, 'localhost:8000')

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/frontend_cache/tests.py" startline="62" endline="74" pcid="686">
    def test_cloudfront(self):
        backends = get_backends(backend_settings={
            'cloudfront': {
                'BACKEND': 'wagtail.contrib.frontend_cache.backends.CloudfrontBackend',
                'DISTRIBUTION_ID': 'frontend',
            },
        })

        self.assertEqual(set(backends.keys()), set(['cloudfront']))
        self.assertIsInstance(backends['cloudfront'], CloudfrontBackend)

        self.assertEqual(backends['cloudfront'].cloudfront_distribution_id, 'frontend')

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/frontend_cache/tests.py" startline="44" endline="61" pcid="685">
    def test_cloudflare(self):
        backends = get_backends(backend_settings={
            'cloudflare': {
                'BACKEND': 'wagtail.contrib.frontend_cache.backends.CloudflareBackend',
                'EMAIL': 'test@test.com',
                'API_KEY': 'this is the api key',
                'ZONEID': 'this is a zone id',
                'BEARER_TOKEN': 'this is a bearer token'
            },
        })

        self.assertEqual(set(backends.keys()), set(['cloudflare']))
        self.assertIsInstance(backends['cloudflare'], CloudflareBackend)

        self.assertEqual(backends['cloudflare'].cloudflare_email, 'test@test.com')
        self.assertEqual(backends['cloudflare'].cloudflare_api_key, 'this is the api key')
        self.assertEqual(backends['cloudflare'].cloudflare_token, 'this is a bearer token')

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/frontend_cache/tests.py" startline="91" endline="104" pcid="688">
    def test_azure_front_door(self):
        backends = get_backends(backend_settings={
            'azure_front_door': {
                'BACKEND': 'wagtail.contrib.frontend_cache.backends.AzureFrontDoorBackend',
                'RESOURCE_GROUP_NAME': 'test-resource-group',
                'FRONT_DOOR_NAME': 'wagtail-io-front-door',
            },
        })

        self.assertEqual(set(backends.keys()), set(['azure_front_door']))
        self.assertIsInstance(backends['azure_front_door'], AzureFrontDoorBackend)
        self.assertEqual(backends['azure_front_door']._resource_group_name, 'test-resource-group')
        self.assertEqual(backends['azure_front_door']._front_door_name, 'wagtail-io-front-door')

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/frontend_cache/tests.py" startline="75" endline="90" pcid="687">
    def test_azure_cdn(self):
        backends = get_backends(backend_settings={
            'azure_cdn': {
                'BACKEND': 'wagtail.contrib.frontend_cache.backends.AzureCdnBackend',
                'RESOURCE_GROUP_NAME': 'test-resource-group',
                'CDN_PROFILE_NAME': 'wagtail-io-profile',
                'CDN_ENDPOINT_NAME': 'wagtail-io-endpoint',
            },
        })

        self.assertEqual(set(backends.keys()), set(['azure_cdn']))
        self.assertIsInstance(backends['azure_cdn'], AzureCdnBackend)
        self.assertEqual(backends['azure_cdn']._resource_group_name, 'test-resource-group')
        self.assertEqual(backends['azure_cdn']._cdn_profile_name, 'wagtail-io-profile')
        self.assertEqual(backends['azure_cdn']._cdn_endpoint_name, 'wagtail-io-endpoint')

</source>
</class>

<class classid="27" nclones="2" nlines="17" similarity="88">
<source file="systems/wagtail-2.16.1/wagtail/contrib/frontend_cache/tests.py" startline="105" endline="122" pcid="689">
    def test_azure_cdn_get_client(self):
        mock_credentials = mock.MagicMock()
        backends = get_backends(backend_settings={
            'azure_cdn': {
                'BACKEND': 'wagtail.contrib.frontend_cache.backends.AzureCdnBackend',
                'RESOURCE_GROUP_NAME': 'test-resource-group',
                'CDN_PROFILE_NAME': 'wagtail-io-profile',
                'CDN_ENDPOINT_NAME': 'wagtail-io-endpoint',
                'SUBSCRIPTION_ID': 'fake-subscription-id',
                'CREDENTIALS': mock_credentials,
            },
        })
        self.assertEqual(set(backends.keys()), set(['azure_cdn']))
        client = backends['azure_cdn']._get_client()
        self.assertIsInstance(client, CdnManagementClient)
        self.assertEqual(client.config.subscription_id, 'fake-subscription-id')
        self.assertIs(client.config.credentials, mock_credentials)

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/frontend_cache/tests.py" startline="123" endline="139" pcid="690">
    def test_azure_front_door_get_client(self):
        mock_credentials = mock.MagicMock()
        backends = get_backends(backend_settings={
            'azure_front_door': {
                'BACKEND': 'wagtail.contrib.frontend_cache.backends.AzureFrontDoorBackend',
                'RESOURCE_GROUP_NAME': 'test-resource-group',
                'FRONT_DOOR_NAME': 'wagtail-io-fake-front-door-name',
                'SUBSCRIPTION_ID': 'fake-subscription-id',
                'CREDENTIALS': mock_credentials,
            },
        })
        client = backends['azure_front_door']._get_client()
        self.assertEqual(set(backends.keys()), set(['azure_front_door']))
        self.assertIsInstance(client, FrontDoorManagementClient)
        self.assertEqual(client.config.subscription_id, 'fake-subscription-id')
        self.assertIs(client.config.credentials, mock_credentials)

</source>
</class>

<class classid="28" nclones="2" nlines="24" similarity="92">
<source file="systems/wagtail-2.16.1/wagtail/contrib/frontend_cache/tests.py" startline="141" endline="172" pcid="691">
    def test_azure_cdn_purge(self, make_purge_call_mock):
        backends = get_backends(backend_settings={
            'azure_cdn': {
                'BACKEND': 'wagtail.contrib.frontend_cache.backends.AzureCdnBackend',
                'RESOURCE_GROUP_NAME': 'test-resource-group',
                'CDN_PROFILE_NAME': 'wagtail-io-profile',
                'CDN_ENDPOINT_NAME': 'wagtail-io-endpoint',
                'CREDENTIALS': 'Fake credentials',
            },
        })

        self.assertEqual(set(backends.keys()), set(['azure_cdn']))
        self.assertIsInstance(backends['azure_cdn'], AzureCdnBackend)

        # purge()
        backends['azure_cdn'].purge('http://www.wagtail.io/home/events/christmas/?test=1')
        make_purge_call_mock.assert_called_once()
        call_args = tuple(make_purge_call_mock.call_args)[0]
        self.assertEqual(len(call_args), 2)
        self.assertIsInstance(call_args[0], CdnManagementClient)
        self.assertEqual(call_args[1], ["/home/events/christmas/?test=1"])
        make_purge_call_mock.reset_mock()

        # purge_batch()
        backends['azure_cdn'].purge_batch([
            'http://www.wagtail.io/home/events/christmas/?test=1', 'http://torchbox.com/blog/'
        ])
        make_purge_call_mock.assert_called_once()
        call_args = tuple(make_purge_call_mock.call_args)[0]
        self.assertIsInstance(call_args[0], CdnManagementClient)
        self.assertEqual(call_args[1], ["/home/events/christmas/?test=1", "/blog/"])

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/frontend_cache/tests.py" startline="174" endline="204" pcid="692">
    def test_azure_front_door_purge(self, make_purge_call_mock):
        backends = get_backends(backend_settings={
            'azure_front_door': {
                'BACKEND': 'wagtail.contrib.frontend_cache.backends.AzureFrontDoorBackend',
                'RESOURCE_GROUP_NAME': 'test-resource-group',
                'FRONT_DOOR_NAME': 'wagtail-io-front-door',
                'CREDENTIALS': 'Fake credentials',
            },
        })

        self.assertEqual(set(backends.keys()), set(['azure_front_door']))
        self.assertIsInstance(backends['azure_front_door'], AzureFrontDoorBackend)

        # purge()
        backends['azure_front_door'].purge('http://www.wagtail.io/home/events/christmas/?test=1')
        make_purge_call_mock.assert_called_once()
        call_args = tuple(make_purge_call_mock.call_args)[0]
        self.assertIsInstance(call_args[0], FrontDoorManagementClient)
        self.assertEqual(call_args[1], ["/home/events/christmas/?test=1"])

        make_purge_call_mock.reset_mock()

        # purge_batch()
        backends['azure_front_door'].purge_batch([
            'http://www.wagtail.io/home/events/christmas/?test=1', 'http://torchbox.com/blog/'
        ])
        make_purge_call_mock.assert_called_once()
        call_args = tuple(make_purge_call_mock.call_args)[0]
        self.assertIsInstance(call_args[0], FrontDoorManagementClient)
        self.assertEqual(call_args[1], ["/home/events/christmas/?test=1", "/blog/"])

</source>
</class>

<class classid="29" nclones="2" nlines="13" similarity="84">
<source file="systems/wagtail-2.16.1/wagtail/contrib/frontend_cache/tests.py" startline="282" endline="297" pcid="699">
    def test_multiple(self):
        backends = get_backends(backend_settings={
            'varnish': {
                'BACKEND': 'wagtail.contrib.frontend_cache.backends.HTTPBackend',
                'LOCATION': 'http://localhost:8000/',
            },
            'cloudflare': {
                'BACKEND': 'wagtail.contrib.frontend_cache.backends.CloudflareBackend',
                'EMAIL': 'test@test.com',
                'API_KEY': 'this is the api key',
                'ZONEID': 'this is a zone id',
            }
        })

        self.assertEqual(set(backends.keys()), set(['varnish', 'cloudflare']))

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/frontend_cache/tests.py" startline="298" endline="313" pcid="700">
    def test_filter(self):
        backends = get_backends(backend_settings={
            'varnish': {
                'BACKEND': 'wagtail.contrib.frontend_cache.backends.HTTPBackend',
                'LOCATION': 'http://localhost:8000/',
            },
            'cloudflare': {
                'BACKEND': 'wagtail.contrib.frontend_cache.backends.CloudflareBackend',
                'EMAIL': 'test@test.com',
                'API_KEY': 'this is the api key',
                'ZONEID': 'this is a zone id',
            }
        }, backends=['cloudflare'])

        self.assertEqual(set(backends.keys()), set(['cloudflare']))

</source>
</class>

<class classid="30" nclones="2" nlines="11" similarity="83">
<source file="systems/wagtail-2.16.1/wagtail/contrib/frontend_cache/tests.py" startline="438" endline="451" pcid="718">
    def test_purge_on_publish_in_multilang_env(self):
        PURGED_URLS[:] = []  # reset PURGED_URLS to the empty list
        page = EventIndex.objects.get(url_path='/home/events/')
        page.save_revision().publish()

        self.assertEqual(PURGED_URLS, [
            'http://localhost/en/events/',
            'http://localhost/en/events/past/',
            'http://localhost/fr/events/',
            'http://localhost/fr/events/past/',
            'http://localhost/pt-br/events/',
            'http://localhost/pt-br/events/past/',
        ])

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/frontend_cache/tests.py" startline="456" endline="467" pcid="719">
    def test_purge_on_publish_with_i18n_enabled(self):
        PURGED_URLS[:] = []  # reset PURGED_URLS to the empty list
        page = EventIndex.objects.get(url_path='/home/events/')
        page.save_revision().publish()

        self.assertEqual(PURGED_URLS, [
            'http://localhost/en/events/',
            'http://localhost/en/events/past/',
            'http://localhost/fr/events/',
            'http://localhost/fr/events/past/',
        ])

</source>
</class>

<class classid="31" nclones="4" nlines="21" similarity="71">
<source file="systems/wagtail-2.16.1/wagtail/contrib/search_promotions/tests.py" startline="288" endline="313" pcid="798">
    def test_post(self):
        # Submit
        post_data = {
            'query_string': "Hello",
            'editors_picks-TOTAL_FORMS': 2,
            'editors_picks-INITIAL_FORMS': 2,
            'editors_picks-MAX_NUM_FORMS': 1000,
            'editors_picks-0-id': self.search_pick.id,
            'editors_picks-0-DELETE': '',
            'editors_picks-0-ORDER': 0,
            'editors_picks-0-page': 1,
            'editors_picks-0-description': "Description has changed",  # Change
            'editors_picks-1-id': self.search_pick_2.id,
            'editors_picks-1-DELETE': '',
            'editors_picks-1-ORDER': 1,
            'editors_picks-1-page': 2,
            'editors_picks-1-description': "Homepage",
        }
        response = self.client.post(reverse('wagtailsearchpromotions:edit', args=(self.query.id, )), post_data)

        # User should be redirected back to the index
        self.assertRedirects(response, reverse('wagtailsearchpromotions:index'))

        # Check that the search pick description was edited
        self.assertEqual(SearchPromotion.objects.get(id=self.search_pick.id).description, "Description has changed")

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/search_promotions/tests.py" startline="349" endline="377" pcid="800">
    def test_post_delete_recommendation(self):
        # Submit
        post_data = {
            'query_string': "Hello",
            'editors_picks-TOTAL_FORMS': 2,
            'editors_picks-INITIAL_FORMS': 2,
            'editors_picks-MAX_NUM_FORMS': 1000,
            'editors_picks-0-id': self.search_pick.id,
            'editors_picks-0-DELETE': '',
            'editors_picks-0-ORDER': 0,
            'editors_picks-0-page': 1,
            'editors_picks-0-description': "Root page",
            'editors_picks-1-id': self.search_pick_2.id,
            'editors_picks-1-DELETE': 1,
            'editors_picks-1-ORDER': 1,
            'editors_picks-1-page': 2,
            'editors_picks-1-description': "Homepage",
        }
        response = self.client.post(reverse('wagtailsearchpromotions:edit', args=(self.query.id, )), post_data)

        # User should be redirected back to the index
        self.assertRedirects(response, reverse('wagtailsearchpromotions:index'))

        # Check that the recommendation was deleted
        self.assertFalse(SearchPromotion.objects.filter(id=self.search_pick_2.id).exists())

        # The other recommendation should still exist
        self.assertTrue(SearchPromotion.objects.filter(id=self.search_pick.id).exists())

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/search_promotions/tests.py" startline="378" endline="405" pcid="801">
    def test_post_without_recommendations(self):
        # Submit
        post_data = {
            'query_string': "Hello",
            'editors_picks-TOTAL_FORMS': 2,
            'editors_picks-INITIAL_FORMS': 2,
            'editors_picks-MAX_NUM_FORMS': 1000,
            'editors_picks-0-id': self.search_pick.id,
            'editors_picks-0-DELETE': 1,
            'editors_picks-0-ORDER': 0,
            'editors_picks-0-page': 1,
            'editors_picks-0-description': "Description has changed",  # Change
            'editors_picks-1-id': self.search_pick_2.id,
            'editors_picks-1-DELETE': 1,
            'editors_picks-1-ORDER': 1,
            'editors_picks-1-page': 2,
            'editors_picks-1-description': "Homepage",
        }
        response = self.client.post(reverse('wagtailsearchpromotions:edit', args=(self.query.id, )), post_data)

        # User should be given an error
        self.assertEqual(response.status_code, 200)
        self.assertFormsetError(
            response, 'searchpicks_formset', None, None,
            "Please specify at least one recommendation for this search term."
        )


</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/search_promotions/tests.py" startline="314" endline="348" pcid="799">
    def test_post_reorder(self):
        # Check order before reordering
        self.assertEqual(Query.get("Hello").editors_picks.all()[0], self.search_pick)
        self.assertEqual(Query.get("Hello").editors_picks.all()[1], self.search_pick_2)

        # Submit
        post_data = {
            'query_string': "Hello",
            'editors_picks-TOTAL_FORMS': 2,
            'editors_picks-INITIAL_FORMS': 2,
            'editors_picks-MAX_NUM_FORMS': 1000,
            'editors_picks-0-id': self.search_pick.id,
            'editors_picks-0-DELETE': '',
            'editors_picks-0-ORDER': 1,  # Change
            'editors_picks-0-page': 1,
            'editors_picks-0-description': "Root page",
            'editors_picks-1-id': self.search_pick_2.id,
            'editors_picks-1-DELETE': '',
            'editors_picks-1-ORDER': 0,  # Change
            'editors_picks-1-page': 2,
            'editors_picks-1-description': "Homepage",
        }
        response = self.client.post(reverse('wagtailsearchpromotions:edit', args=(self.query.id, )), post_data)

        # User should be redirected back to the index
        self.assertRedirects(response, reverse('wagtailsearchpromotions:index'))

        # Check that the ordering has been saved correctly
        self.assertEqual(SearchPromotion.objects.get(id=self.search_pick.id).sort_order, 1)
        self.assertEqual(SearchPromotion.objects.get(id=self.search_pick_2.id).sort_order, 0)

        # Check that the recommendations were reordered
        self.assertEqual(Query.get("Hello").editors_picks.all()[0], self.search_pick_2)
        self.assertEqual(Query.get("Hello").editors_picks.all()[1], self.search_pick)

</source>
</class>

<class classid="32" nclones="2" nlines="26" similarity="70">
<source file="systems/wagtail-2.16.1/wagtail/contrib/search_promotions/views.py" startline="114" endline="149" pcid="808">
def add(request):
    if request.method == 'POST':
        # Get query
        query_form = search_forms.QueryForm(request.POST)
        if query_form.is_valid():
            query = Query.get(query_form['query_string'].value())

            # Save search picks
            searchpicks_formset = forms.SearchPromotionsFormSet(request.POST, instance=query)
            if save_searchpicks(query, query, searchpicks_formset):
                for search_pick in searchpicks_formset.new_objects:
                    log(search_pick, 'wagtail.create')
                messages.success(request, _("Editor's picks for '{0}' created.").format(query), buttons=[
                    messages.button(reverse('wagtailsearchpromotions:edit', args=(query.id,)), _('Edit'))
                ])
                return redirect('wagtailsearchpromotions:index')
            else:
                if len(searchpicks_formset.non_form_errors()):
                    # formset level error (e.g. no forms submitted)
                    messages.error(request, " ".join(error for error in searchpicks_formset.non_form_errors()))
                else:
                    # specific errors will be displayed within form fields
                    messages.error(request, _("Recommendations have not been created due to errors"))
        else:
            searchpicks_formset = forms.SearchPromotionsFormSet()
    else:
        query_form = search_forms.QueryForm()
        searchpicks_formset = forms.SearchPromotionsFormSet()

    return TemplateResponse(request, 'wagtailsearchpromotions/add.html', {
        'query_form': query_form,
        'searchpicks_formset': searchpicks_formset,
        'form_media': query_form.media + searchpicks_formset.media,
    })


</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/search_promotions/views.py" startline="151" endline="188" pcid="809">
def edit(request, query_id):
    query = get_object_or_404(Query, id=query_id)

    if request.method == 'POST':
        # Get query
        query_form = search_forms.QueryForm(request.POST)
        # and the recommendations
        searchpicks_formset = forms.SearchPromotionsFormSet(request.POST, instance=query)

        if query_form.is_valid():
            new_query = Query.get(query_form['query_string'].value())

            # Save search picks
            if save_searchpicks(query, new_query, searchpicks_formset):
                messages.success(request, _("Editor's picks for '{0}' updated.").format(new_query), buttons=[
                    messages.button(reverse('wagtailsearchpromotions:edit', args=(query.id,)), _('Edit'))
                ])
                return redirect('wagtailsearchpromotions:index')
            else:
                if len(searchpicks_formset.non_form_errors()):
                    messages.error(request, " ".join(error for error in searchpicks_formset.non_form_errors()))
                    # formset level error (e.g. no forms submitted)
                else:
                    messages.error(request, _("Recommendations have not been saved due to errors"))
                    # specific errors will be displayed within form fields

    else:
        query_form = search_forms.QueryForm(initial=dict(query_string=query.query_string))
        searchpicks_formset = forms.SearchPromotionsFormSet(instance=query)

    return TemplateResponse(request, 'wagtailsearchpromotions/edit.html', {
        'query_form': query_form,
        'searchpicks_formset': searchpicks_formset,
        'query': query,
        'form_media': query_form.media + searchpicks_formset.media,
    })


</source>
</class>

<class classid="33" nclones="3" nlines="10" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/contrib/modeladmin/tests/test_page_modeladmin.py" startline="339" endline="367" pcid="936">
    def test_choose_parent_page(self):
        response = self.client.get('/admin/tests/eventpage/choose_parent/')

        # check correct templates were used
        self.assertTemplateUsed(response, 'modeladmin/includes/breadcrumb.html')
        self.assertTemplateUsed(response, 'wagtailadmin/shared/header.html')

        # check that home breadcrumb link exists
        expected = """
            <li class="breadcrumb-item home">
                <a href="/admin/" class="breadcrumb-link">
                    <svg class="icon icon-home home_icon" aria-hidden="true" focusable="false">
                        <use href="#icon-home"></use>
                    </svg>
                    <span class="visuallyhidden">Home</span>
                    <svg class="icon icon-arrow-right arrow_right_icon" aria-hidden="true" focusable="false">
                        <use href="#icon-arrow-right"></use>
                    </svg>
                </a>
            </li>
        """
        self.assertContains(response, expected, html=True)

        # check that the breadcrumbs are after the header opening tag
        content_str = str(response.content)
        position_of_header = content_str.index('<header')  # intentionally not closing tag
        position_of_breadcrumbs = content_str.index('<ul class="breadcrumb">')
        self.assertLess(position_of_header, position_of_breadcrumbs)

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/modeladmin/tests/test_simple_modeladmin.py" startline="696" endline="725" pcid="1040">
    def test_choose_inspect_model(self):
        response = self.client.get('/admin/modeladmintest/author/inspect/1/')

        # check correct templates were used
        self.assertTemplateUsed(response, 'modeladmin/includes/breadcrumb.html')
        self.assertTemplateUsed(response, 'wagtailadmin/shared/header.html')

        # check that home breadcrumb link exists
        expected = """
            <li class="breadcrumb-item home">
                <a href="/admin/" class="breadcrumb-link">
                    <svg class="icon icon-home home_icon" aria-hidden="true" focusable="false">
                        <use href="#icon-home"></use>
                    </svg>
                    <span class="visuallyhidden">Home</span>
                    <svg class="icon icon-arrow-right arrow_right_icon" aria-hidden="true" focusable="false">
                        <use href="#icon-arrow-right"></use>
                    </svg>
                </a>
            </li>
        """
        self.assertContains(response, expected, html=True)

        # check that the breadcrumbs are before the first header closing tag
        content_str = str(response.content)
        position_of_header_close = content_str.index('</header>')
        position_of_breadcrumbs = content_str.index('<ul class="breadcrumb">')
        self.assertGreater(position_of_header_close, position_of_breadcrumbs)


</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/modeladmin/tests/test_page_modeladmin.py" startline="368" endline="397" pcid="937">
    def test_choose_inspect_page(self):
        response = self.client.get('/admin/tests/eventpage/inspect/4/')

        # check correct templates were used
        self.assertTemplateUsed(response, 'modeladmin/includes/breadcrumb.html')
        self.assertTemplateUsed(response, 'wagtailadmin/shared/header.html')

        # check that home breadcrumb link exists
        expected = """
            <li class="breadcrumb-item home">
                <a href="/admin/" class="breadcrumb-link">
                    <svg class="icon icon-home home_icon" aria-hidden="true" focusable="false">
                        <use href="#icon-home"></use>
                    </svg>
                    <span class="visuallyhidden">Home</span>
                    <svg class="icon icon-arrow-right arrow_right_icon" aria-hidden="true" focusable="false">
                        <use href="#icon-arrow-right"></use>
                    </svg>
                </a>
            </li>
        """
        self.assertContains(response, expected, html=True)

        # check that the breadcrumbs are after the header opening tag
        content_str = str(response.content)
        position_of_header = content_str.index('<header')  # intentionally not closing tag
        position_of_breadcrumbs = content_str.index('<ul class="breadcrumb">')
        self.assertLess(position_of_header, position_of_breadcrumbs)


</source>
</class>

<class classid="34" nclones="3" nlines="13" similarity="84">
<source file="systems/wagtail-2.16.1/wagtail/contrib/modeladmin/tests/test_search_handlers.py" startline="84" endline="99" pcid="958">
    def test_search_queryset_no_search_fields(self, mocked_method):
        # When no search fields are specified, WagtailBackendSearchHandler
        # searches on all indexed fields
        search_handler = self.get_search_handler()
        queryset = self.get_queryset()
        search_kwargs = search_handler.search_queryset(queryset, 'test')
        self.assertTrue(mocked_method.called)
        self.assertEqual(search_kwargs, dict(
            query='test',
            model_or_queryset=queryset,
            fields=None,
            operator=None,
            order_by_relevance=True,
            partial_match=True,
        ))

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/modeladmin/tests/test_search_handlers.py" startline="101" endline="117" pcid="959">
    def test_search_queryset_with_search_fields(self, mocked_method):
        # When no search fields are specified, WagtailBackendSearchHandler
        # searches on all indexed fields
        search_fields = ('field1', 'field2')
        search_handler = self.get_search_handler(search_fields)
        queryset = self.get_queryset()
        search_kwargs = search_handler.search_queryset(queryset, 'test')
        self.assertTrue(mocked_method.called)
        self.assertEqual(search_kwargs, dict(
            query='test',
            model_or_queryset=queryset,
            fields=search_fields,
            operator=None,
            order_by_relevance=True,
            partial_match=True,
        ))

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/modeladmin/tests/test_search_handlers.py" startline="119" endline="132" pcid="960">
    def test_search_queryset_preserve_order(self, get_search_backend):
        search_handler = self.get_search_handler()
        queryset = self.get_queryset()

        search_kwargs = search_handler.search_queryset(queryset, 'Lord', preserve_order=True)
        self.assertEqual(search_kwargs, dict(
            query='Lord',
            model_or_queryset=queryset,
            fields=None,
            operator=None,
            order_by_relevance=False,
            partial_match=True,
        ))

</source>
</class>

<class classid="35" nclones="2" nlines="10" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/contrib/modeladmin/tests/test_simple_modeladmin.py" startline="548" endline="563" pcid="1023">
    def test_post_with_dependent_object(self):
        response = self.post(1)

        self.assertEqual(response.status_code, 200)
        self.assertContains(
            response,
            "'J. R. R. Tolkien' is currently referenced by other objects"
        )
        self.assertContains(
            response,
            "<li><b>Book:</b> The Lord of the Rings</li>"
        )

        # Author not deleted
        self.assertTrue(Author.objects.filter(id=1).exists())

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/modeladmin/tests/test_simple_modeladmin.py" startline="573" endline="589" pcid="1025">
    def test_post_with_1to1_dependent_object(self):
        response = self.post(5)

        self.assertEqual(response.status_code, 200)
        self.assertContains(
            response,
            "'Harper Lee' is currently referenced by other objects"
        )
        self.assertContains(
            response,
            "<li><b>Solo Book:</b> To Kill a Mockingbird</li>"
        )

        # Author not deleted
        self.assertTrue(Author.objects.filter(id=5).exists())


</source>
</class>

<class classid="36" nclones="3" nlines="11" similarity="81">
<source file="systems/wagtail-2.16.1/wagtail/contrib/modeladmin/tests/test_simple_modeladmin.py" startline="740" endline="759" pcid="1043">
    def test_model_with_single_tabbed_panel_only(self):
        Publisher.content_panels = [FieldPanel('name'), FieldPanel('headquartered_in')]

        warning = checks.Warning(
            "Publisher.content_panels will have no effect on modeladmin editing",
            hint="""Ensure that Publisher uses `panels` instead of `content_panels`\
or set up an `edit_handler` if you want a tabbed editing interface.
There are no default tabs on non-Page models so there will be no\
 Content tab for the content_panels to render in.""",
            obj=Publisher,
            id='wagtailadmin.W002',
        )

        checks_results = self.get_checks_result()

        self.assertIn(warning, checks_results)

        # clean up for future checks
        delattr(Publisher, 'content_panels')

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_edit_handlers.py" startline="1009" endline="1027" pcid="2556">
    def test_page_with_inline_model_with_tabbed_panel_only(self):
        """Test that checks will warn against setting single tabbed panel on InlinePanel model"""

        EventPageSpeaker.settings_panels = [FieldPanel('first_name'), FieldPanel('last_name')]

        warning = checks.Warning(
            "EventPageSpeaker.settings_panels will have no effect on InlinePanel model editing",
            hint="""Ensure that EventPageSpeaker uses `panels` instead of `settings_panels`.
There are no tabs on non-Page model editing within InlinePanels.""",
            obj=EventPageSpeaker,
            id=self.warning_id,
        )

        checks_results = self.get_checks_result()

        self.assertIn(warning, checks_results)

        delattr(EventPageSpeaker, 'settings_panels')

</source>
<source file="systems/wagtail-2.16.1/wagtail/snippets/tests.py" startline="1795" endline="1814" pcid="3085">
    def test_model_with_single_tabbed_panel_only(self):

        StandardSnippet.content_panels = [FieldPanel('text')]

        warning = checks.Warning(
            "StandardSnippet.content_panels will have no effect on snippets editing",
            hint="""Ensure that StandardSnippet uses `panels` instead of `content_panels`\
or set up an `edit_handler` if you want a tabbed editing interface.
There are no default tabs on non-Page models so there will be no\
 Content tab for the content_panels to render in.""",
            obj=StandardSnippet,
            id='wagtailadmin.W002',
        )

        checks_results = self.get_checks_result()

        self.assertEqual([warning], checks_results)

        # clean up for future checks
        delattr(StandardSnippet, 'content_panels')
</source>
</class>

<class classid="37" nclones="2" nlines="20" similarity="90">
<source file="systems/wagtail-2.16.1/wagtail/contrib/modeladmin/tests/test_simple_modeladmin.py" startline="760" endline="792" pcid="1044">
    def test_model_with_two_tabbed_panels_only(self):
        Publisher.settings_panels = [FieldPanel('name')]
        Publisher.promote_panels = [FieldPanel('headquartered_in')]

        warning_1 = checks.Warning(
            "Publisher.promote_panels will have no effect on modeladmin editing",
            hint="""Ensure that Publisher uses `panels` instead of `promote_panels`\
or set up an `edit_handler` if you want a tabbed editing interface.
There are no default tabs on non-Page models so there will be no\
 Promote tab for the promote_panels to render in.""",
            obj=Publisher,
            id='wagtailadmin.W002',
        )

        warning_2 = checks.Warning(
            "Publisher.settings_panels will have no effect on modeladmin editing",
            hint="""Ensure that Publisher uses `panels` instead of `settings_panels`\
or set up an `edit_handler` if you want a tabbed editing interface.
There are no default tabs on non-Page models so there will be no\
 Settings tab for the settings_panels to render in.""",
            obj=Publisher,
            id='wagtailadmin.W002',
        )

        checks_results = self.get_checks_result()

        self.assertIn(warning_1, checks_results)
        self.assertIn(warning_2, checks_results)

        # clean up for future checks
        delattr(Publisher, 'settings_panels')
        delattr(Publisher, 'promote_panels')

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_edit_handlers.py" startline="1028" endline="1056" pcid="2557">
    def test_page_with_inline_model_with_two_tabbed_panels(self):
        """Test that checks will warn against multiple tabbed panels on InlinePanel models"""

        EventPageSpeaker.content_panels = [FieldPanel('first_name')]
        EventPageSpeaker.promote_panels = [FieldPanel('last_name')]

        warning_1 = checks.Warning(
            "EventPageSpeaker.content_panels will have no effect on InlinePanel model editing",
            hint="""Ensure that EventPageSpeaker uses `panels` instead of `content_panels`.
There are no tabs on non-Page model editing within InlinePanels.""",
            obj=EventPageSpeaker,
            id=self.warning_id,
        )
        warning_2 = checks.Warning(
            "EventPageSpeaker.promote_panels will have no effect on InlinePanel model editing",
            hint="""Ensure that EventPageSpeaker uses `panels` instead of `promote_panels`.
There are no tabs on non-Page model editing within InlinePanels.""",
            obj=EventPageSpeaker,
            id=self.warning_id,
        )

        checks_results = self.get_checks_result()

        self.assertIn(warning_1, checks_results)
        self.assertIn(warning_2, checks_results)

        delattr(EventPageSpeaker, 'content_panels')
        delattr(EventPageSpeaker, 'promote_panels')

</source>
</class>

<class classid="38" nclones="6" nlines="13" similarity="75">
<source file="systems/wagtail-2.16.1/wagtail/contrib/modeladmin/helpers/button.py" startline="33" endline="46" pcid="1084">
    def add_button(self, classnames_add=None, classnames_exclude=None):
        if classnames_add is None:
            classnames_add = []
        if classnames_exclude is None:
            classnames_exclude = []
        classnames = self.add_button_classnames + classnames_add
        cn = self.finalise_classname(classnames, classnames_exclude)
        return {
            'url': self.url_helper.create_url,
            'label': _('Add %s') % self.verbose_name,
            'classname': cn,
            'title': _('Add a new %s') % self.verbose_name,
        }

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/modeladmin/helpers/button.py" startline="61" endline="74" pcid="1086">
    def edit_button(self, pk, classnames_add=None, classnames_exclude=None):
        if classnames_add is None:
            classnames_add = []
        if classnames_exclude is None:
            classnames_exclude = []
        classnames = self.edit_button_classnames + classnames_add
        cn = self.finalise_classname(classnames, classnames_exclude)
        return {
            'url': self.url_helper.get_action_url('edit', quote(pk)),
            'label': _('Edit'),
            'classname': cn,
            'title': _('Edit this %s') % self.verbose_name,
        }

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/modeladmin/helpers/button.py" startline="75" endline="88" pcid="1087">
    def delete_button(self, pk, classnames_add=None, classnames_exclude=None):
        if classnames_add is None:
            classnames_add = []
        if classnames_exclude is None:
            classnames_exclude = []
        classnames = self.delete_button_classnames + classnames_add
        cn = self.finalise_classname(classnames, classnames_exclude)
        return {
            'url': self.url_helper.get_action_url('delete', quote(pk)),
            'label': _('Delete'),
            'classname': cn,
            'title': _('Delete this %s') % self.verbose_name,
        }

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/modeladmin/helpers/button.py" startline="47" endline="60" pcid="1085">
    def inspect_button(self, pk, classnames_add=None, classnames_exclude=None):
        if classnames_add is None:
            classnames_add = []
        if classnames_exclude is None:
            classnames_exclude = []
        classnames = self.inspect_button_classnames + classnames_add
        cn = self.finalise_classname(classnames, classnames_exclude)
        return {
            'url': self.url_helper.get_action_url('inspect', quote(pk)),
            'label': _('Inspect'),
            'classname': cn,
            'title': _('Inspect this %s') % self.verbose_name,
        }

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/modeladmin/helpers/button.py" startline="121" endline="134" pcid="1089">
    def unpublish_button(self, pk, classnames_add=None, classnames_exclude=None):
        if classnames_add is None:
            classnames_add = []
        if classnames_exclude is None:
            classnames_exclude = []
        classnames = self.unpublish_button_classnames + classnames_add
        cn = self.finalise_classname(classnames, classnames_exclude)
        return {
            'url': self.url_helper.get_action_url('unpublish', quote(pk)),
            'label': _('Unpublish'),
            'classname': cn,
            'title': _('Unpublish this %s') % self.verbose_name,
        }

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/modeladmin/helpers/button.py" startline="135" endline="148" pcid="1090">
    def copy_button(self, pk, classnames_add=None, classnames_exclude=None):
        if classnames_add is None:
            classnames_add = []
        if classnames_exclude is None:
            classnames_exclude = []
        classnames = self.copy_button_classnames + classnames_add
        cn = self.finalise_classname(classnames, classnames_exclude)
        return {
            'url': self.url_helper.get_action_url('copy', quote(pk)),
            'label': _('Copy'),
            'classname': cn,
            'title': _('Copy this %s') % self.verbose_name,
        }

</source>
</class>

<class classid="39" nclones="2" nlines="25" similarity="78">
<source file="systems/wagtail-2.16.1/wagtail/contrib/modeladmin/helpers/button.py" startline="89" endline="115" pcid="1088">
    def get_buttons_for_obj(self, obj, exclude=None, classnames_add=None,
                            classnames_exclude=None):
        if exclude is None:
            exclude = []
        if classnames_add is None:
            classnames_add = []
        if classnames_exclude is None:
            classnames_exclude = []
        ph = self.permission_helper
        usr = self.request.user
        pk = getattr(obj, self.opts.pk.attname)
        btns = []
        if('inspect' not in exclude and ph.user_can_inspect_obj(usr, obj)):
            btns.append(
                self.inspect_button(pk, classnames_add, classnames_exclude)
            )
        if('edit' not in exclude and ph.user_can_edit_obj(usr, obj)):
            btns.append(
                self.edit_button(pk, classnames_add, classnames_exclude)
            )
        if('delete' not in exclude and ph.user_can_delete_obj(usr, obj)):
            btns.append(
                self.delete_button(pk, classnames_add, classnames_exclude)
            )
        return btns


</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/modeladmin/helpers/button.py" startline="149" endline="181" pcid="1091">
    def get_buttons_for_obj(self, obj, exclude=None, classnames_add=None,
                            classnames_exclude=None):
        if exclude is None:
            exclude = []
        if classnames_add is None:
            classnames_add = []
        if classnames_exclude is None:
            classnames_exclude = []
        ph = self.permission_helper
        usr = self.request.user
        pk = getattr(obj, self.opts.pk.attname)
        btns = []
        if('inspect' not in exclude and ph.user_can_inspect_obj(usr, obj)):
            btns.append(
                self.inspect_button(pk, classnames_add, classnames_exclude)
            )
        if('edit' not in exclude and ph.user_can_edit_obj(usr, obj)):
            btns.append(
                self.edit_button(pk, classnames_add, classnames_exclude)
            )
        if('copy' not in exclude and ph.user_can_copy_obj(usr, obj)):
            btns.append(
                self.copy_button(pk, classnames_add, classnames_exclude)
            )
        if('unpublish' not in exclude and ph.user_can_unpublish_obj(usr, obj)):
            btns.append(
                self.unpublish_button(pk, classnames_add, classnames_exclude)
            )
        if('delete' not in exclude and ph.user_can_delete_obj(usr, obj)):
            btns.append(
                self.delete_button(pk, classnames_add, classnames_exclude)
            )
        return btns
</source>
</class>

<class classid="40" nclones="2" nlines="11" similarity="81">
<source file="systems/wagtail-2.16.1/wagtail/contrib/modeladmin/templatetags/modeladmin_tags.py" startline="111" endline="124" pcid="1095">
def pagination_link_previous(current_page, view):
    if current_page.has_previous():
        previous_page_number0 = current_page.previous_page_number() - 1
        tpl = get_template('wagtailadmin/shared/icon.html')
        icon_svg = tpl.render({'name': 'arrow-left', 'class_name': 'default'})
        return format_html(
            '<li class="prev"><a href="{}">{} {}</a></li>',
            view.get_query_string({view.PAGE_VAR: previous_page_number0}),
            icon_svg,
            _('Previous')
        )
    return ''


</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/modeladmin/templatetags/modeladmin_tags.py" startline="126" endline="139" pcid="1096">
def pagination_link_next(current_page, view):
    if current_page.has_next():
        next_page_number0 = current_page.next_page_number() - 1
        tpl = get_template('wagtailadmin/shared/icon.html')
        icon_svg = tpl.render({'name': 'arrow-right', 'class_name': 'default'})
        return format_html(
            '<li class="next"><a href="{}">{} {}</a></li>',
            view.get_query_string({view.PAGE_VAR: next_page_number0}),
            _('Next'),
            icon_svg
        )
    return ''


</source>
</class>

<class classid="41" nclones="4" nlines="25" similarity="72">
<source file="systems/wagtail-2.16.1/wagtail/contrib/forms/tests/test_views.py" startline="297" endline="329" pcid="1138">
    def setUp(self):
        # Create a form page
        self.form_page = make_form_page()

        # Add a couple of form submissions
        # (save new_form_submission first, so that we're more likely to reveal bugs where
        # we're relying on the database's internal ordering instead of explicitly ordering
        # by submit_time)

        new_form_submission = FormSubmission.objects.create(
            page=self.form_page,
            form_data=json.dumps({
                'your_email': "new@example.com",
                'your_message': "this is a fairly new message",
                'your_choices': ['foo', 'baz'],
            }),
        )
        new_form_submission.submit_time = '2014-01-01T12:00:00.000Z'
        new_form_submission.save()

        old_form_submission = FormSubmission.objects.create(
            page=self.form_page,
            form_data=json.dumps({
                'your_email': "old@example.com",
                'your_message': "this is a really old message",
            }),
        )
        old_form_submission.submit_time = '2013-01-01T12:00:00.000Z'
        old_form_submission.save()

        # Login
        self.login()

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/forms/tests/test_views.py" startline="736" endline="771" pcid="1166">
    def setUp(self):
        # Create a form page
        self.form_page = make_form_page_with_custom_submission()

        # Add a couple of form submissions
        old_form_submission = CustomFormPageSubmission.objects.create(
            user=self.create_test_user_without_admin('user-john'),
            page=self.form_page,
            form_data=json.dumps({
                'your_email': "old@example.com",
                'your_message': "this is a really old message",
            }),
        )
        if settings.USE_TZ:
            old_form_submission.submit_time = '2013-01-01T12:00:00.000Z'
        else:
            old_form_submission.submit_time = '2013-01-01T12:00:00'
        old_form_submission.save()

        new_form_submission = CustomFormPageSubmission.objects.create(
            user=self.create_test_user_without_admin('user-m1kola'),
            page=self.form_page,
            form_data=json.dumps({
                'your_email': "new@example.com",
                'your_message': "this is a fairly new message",
            }),
        )
        if settings.USE_TZ:
            new_form_submission.submit_time = '2014-01-01T12:00:00.000Z'
        else:
            new_form_submission.submit_time = '2014-01-01T12:00:00'
        new_form_submission.save()

        # Login
        self.login()

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/forms/tests/test_views.py" startline="505" endline="539" pcid="1154">
    def setUp(self):
        # Create a form page
        self.form_page = make_form_page()

        # Add a couple of form submissions
        old_form_submission = FormSubmission.objects.create(
            page=self.form_page,
            form_data=json.dumps({
                'your_email': "old@example.com",
                'your_message': "this is a really old message",
                'your_choices': ['foo', 'baz'],
            }),
        )
        if settings.USE_TZ:
            old_form_submission.submit_time = '2013-01-01T12:00:00.000Z'
        else:
            old_form_submission.submit_time = '2013-01-01T12:00:00'
        old_form_submission.save()

        new_form_submission = FormSubmission.objects.create(
            page=self.form_page,
            form_data=json.dumps({
                'your_email': "new@example.com",
                'your_message': "this is a fairly new message",
            }),
        )
        if settings.USE_TZ:
            new_form_submission.submit_time = '2014-01-01T12:00:00.000Z'
        else:
            new_form_submission.submit_time = '2014-01-01T12:00:00'
        new_form_submission.save()

        # Login
        self.login()

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/forms/tests/test_views.py" startline="929" endline="958" pcid="1174">
    def setUp(self):
        # Create a form page
        self.form_page = make_form_page_with_custom_submission()

        # Add a couple of form submissions
        old_form_submission = CustomFormPageSubmission.objects.create(
            user=self.create_test_user_without_admin('user-john'),
            page=self.form_page,
            form_data=json.dumps({
                'your_email': "old@example.com",
                'your_message': "this is a really old message",
            }),
        )
        old_form_submission.submit_time = '2013-01-01T12:00:00.000Z'
        old_form_submission.save()

        new_form_submission = CustomFormPageSubmission.objects.create(
            user=self.create_test_user_without_admin('user-m1kola'),
            page=self.form_page,
            form_data=json.dumps({
                'your_email': "new@example.com",
                'your_message': "this is a fairly new message",
            }),
        )
        new_form_submission.submit_time = '2014-01-01T12:00:00.000Z'
        new_form_submission.save()

        # Login
        self.login()

</source>
</class>

<class classid="42" nclones="5" nlines="12" similarity="76">
<source file="systems/wagtail-2.16.1/wagtail/contrib/forms/tests/test_views.py" startline="540" endline="557" pcid="1155">
    def test_list_submissions_csv_export(self):
        response = self.client.get(
            reverse('wagtailforms:list_submissions', args=(self.form_page.id,)),
            {'export': 'csv'}
        )

        # Check response
        self.assertEqual(response.status_code, 200)
        data_lines = response.getvalue().decode().split("\n")

        self.assertEqual(data_lines[0], 'Submission date,Your email,Your message,Your choices\r')
        if settings.USE_TZ:
            self.assertEqual(data_lines[1], '2013-01-01 12:00:00+00:00,old@example.com,this is a really old message,"foo, baz"\r')
            self.assertEqual(data_lines[2], '2014-01-01 12:00:00+00:00,new@example.com,this is a fairly new message,None\r')
        else:
            self.assertEqual(data_lines[1], '2013-01-01 12:00:00,old@example.com,this is a really old message,"foo, baz"\r')
            self.assertEqual(data_lines[2], '2014-01-01 12:00:00,new@example.com,this is a fairly new message,None\r')

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/forms/tests/test_views.py" startline="645" endline="660" pcid="1161">
    def test_list_submissions_csv_export_with_date_to_filtering(self):
        response = self.client.get(
            reverse('wagtailforms:list_submissions', args=(self.form_page.id,)),
            {'export': 'csv', 'date_to': '12/31/2013'}
        )

        # Check response
        self.assertEqual(response.status_code, 200)
        data_lines = response.getvalue().decode().split("\n")

        self.assertEqual(data_lines[0], 'Submission date,Your email,Your message,Your choices\r')
        if settings.USE_TZ:
            self.assertEqual(data_lines[1], '2013-01-01 12:00:00+00:00,old@example.com,this is a really old message,"foo, baz"\r')
        else:
            self.assertEqual(data_lines[1], '2013-01-01 12:00:00,old@example.com,this is a really old message,"foo, baz"\r')

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/forms/tests/test_views.py" startline="629" endline="644" pcid="1160">
    def test_list_submissions_csv_export_with_date_from_filtering(self):
        response = self.client.get(
            reverse('wagtailforms:list_submissions', args=(self.form_page.id,)),
            {'export': 'csv', 'date_from': '01/01/2014'}
        )

        # Check response
        self.assertEqual(response.status_code, 200)
        data_lines = response.getvalue().decode().split("\n")

        self.assertEqual(data_lines[0], 'Submission date,Your email,Your message,Your choices\r')
        if settings.USE_TZ:
            self.assertEqual(data_lines[1], '2014-01-01 12:00:00+00:00,new@example.com,this is a fairly new message,None\r')
        else:
            self.assertEqual(data_lines[1], '2014-01-01 12:00:00,new@example.com,this is a fairly new message,None\r')

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/forms/tests/test_views.py" startline="1319" endline="1337" pcid="1200">
    def test_list_submissions_csv_export(self):
        response = self.client.get(
            reverse('wagtailforms:list_submissions', args=(self.form_page.id,)),
            {'export': 'csv'}
        )

        # Check response
        self.assertEqual(response.status_code, 200)
        data_lines = response.getvalue().decode().split("\n")
        self.assertIn('filename="%s-export' % self.form_page.slug, response.get('Content-Disposition'))
        self.assertEqual(data_lines[0], 'User email,Submission date,Your email,Chocolate,Ingredients,Your Excitement\r')
        # first result should be the most recent as order_csv has been reversed
        if settings.USE_TZ:
            self.assertEqual(data_lines[1], 'user-chocolate-maniac@example.com,2017-10-01 12:00:00+00:00,new@example.com,White Chocolate,White colouring,Much excitement\r')
            self.assertEqual(data_lines[2], 'user-chocolate-guy@example.com,2017-01-01 12:00:00+00:00,old@example.com,Dark Chocolate,Charcoal,What is chocolate?\r')
        else:
            self.assertEqual(data_lines[1], 'user-chocolate-maniac@example.com,2017-10-01 12:00:00,new@example.com,White Chocolate,White colouring,Much excitement\r')
            self.assertEqual(data_lines[2], 'user-chocolate-guy@example.com,2017-01-01 12:00:00,old@example.com,Dark Chocolate,Charcoal,What is chocolate?\r')

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/forms/tests/test_views.py" startline="661" endline="676" pcid="1162">
    def test_list_submissions_csv_export_with_range_filtering(self):
        response = self.client.get(
            reverse('wagtailforms:list_submissions', args=(self.form_page.id,)),
            {'export': 'csv', 'date_from': '12/31/2013', 'date_to': '01/02/2014'}
        )

        # Check response
        self.assertEqual(response.status_code, 200)
        data_lines = response.getvalue().decode().split("\n")

        self.assertEqual(data_lines[0], 'Submission date,Your email,Your message,Your choices\r')
        if settings.USE_TZ:
            self.assertEqual(data_lines[1], '2014-01-01 12:00:00+00:00,new@example.com,this is a fairly new message,None\r')
        else:
            self.assertEqual(data_lines[1], '2014-01-01 12:00:00,new@example.com,this is a fairly new message,None\r')

</source>
</class>

<class classid="43" nclones="2" nlines="17" similarity="94">
<source file="systems/wagtail-2.16.1/wagtail/contrib/forms/tests/test_views.py" startline="677" endline="697" pcid="1163">
    def test_list_submissions_csv_export_with_unicode_in_submission(self):
        unicode_form_submission = FormSubmission.objects.create(
            page=self.form_page,
            form_data=json.dumps({
                'your_email': "unicode@example.com",
                'your_message': '',
            }),
        )
        unicode_form_submission.submit_time = '2014-01-02T12:00:00.000Z'
        unicode_form_submission.save()

        response = self.client.get(
            reverse('wagtailforms:list_submissions', args=(self.form_page.id,)),
            {'date_from': '01/02/2014', 'export': 'csv'}
        )

        # Check response
        self.assertEqual(response.status_code, 200)
        data_line = response.getvalue().decode('utf-8').split("\n")[1]
        self.assertIn('', data_line)

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/forms/tests/test_views.py" startline="868" endline="889" pcid="1171">
    def test_list_submissions_csv_export_with_unicode_in_submission(self):
        unicode_form_submission = CustomFormPageSubmission.objects.create(
            user=self.create_test_user_without_admin('user-bob'),
            page=self.form_page,
            form_data=json.dumps({
                'your_email': "unicode@example.com",
                'your_message': '',
            }),
        )
        unicode_form_submission.submit_time = '2014-01-02T12:00:00.000Z'
        unicode_form_submission.save()

        response = self.client.get(
            reverse('wagtailforms:list_submissions', args=(self.form_page.id,)),
            {'date_from': '01/02/2014', 'export': 'csv'}
        )

        # Check response
        self.assertEqual(response.status_code, 200)
        data_line = response.getvalue().decode('utf-8').split("\n")[1]
        self.assertIn('', data_line)

</source>
</class>

<class classid="44" nclones="2" nlines="28" similarity="96">
<source file="systems/wagtail-2.16.1/wagtail/contrib/forms/tests/test_views.py" startline="698" endline="731" pcid="1164">
    def test_list_submissions_csv_export_with_unicode_in_field(self):
        FormField.objects.create(
            page=self.form_page,
            sort_order=2,
            label="   IDE    Python",
            help_text="     ",
            field_type='radio',
            required=True,
            choices='PyCharm,vim,nano',
        )
        unicode_form_submission = FormSubmission.objects.create(
            page=self.form_page,
            form_data=json.dumps({
                'your_email': "unicode@example.com",
                'your_message': "We don\'t need unicode here",
                'u0412u044bu0431u0435u0440u0438u0442u0435_u0441u0430u043cu0443u044e_u043bu044eu0431u0438u043cu0443u044e_ide_u0434u043bu044f_u0440u0430u0437u0440u0430u0431u043eu0442u043au0435_u043du0430_python': "vim",
            }),
        )
        unicode_form_submission.submit_time = '2014-01-02T12:00:00.000Z'
        unicode_form_submission.save()

        response = self.client.get(
            reverse('wagtailforms:list_submissions', args=(self.form_page.id, )),
            {'date_from': '01/02/2014', 'export': 'csv'}
        )

        # Check response
        self.assertEqual(response.status_code, 200)

        data_lines = response.getvalue().decode('utf-8').split("\n")
        self.assertIn('   IDE    Python', data_lines[0])
        self.assertIn('vim', data_lines[1])


</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/forms/tests/test_views.py" startline="890" endline="924" pcid="1172">
    def test_list_submissions_csv_export_with_unicode_in_field(self):
        FormFieldWithCustomSubmission.objects.create(
            page=self.form_page,
            sort_order=2,
            label="   IDE    Python",
            help_text="     ",
            field_type='radio',
            required=True,
            choices='PyCharm,vim,nano',
        )
        unicode_form_submission = CustomFormPageSubmission.objects.create(
            user=self.create_test_user_without_admin('user-bob'),
            page=self.form_page,
            form_data=json.dumps({
                'your-email': "unicode@example.com",
                'your-message': "We don\'t need unicode here",
                'u0412u044bu0431u0435u0440u0438u0442u0435_u0441u0430u043cu0443u044e_u043bu044eu0431u0438u043cu0443u044e_ide_u0434u043bu044f_u0440u0430u0437u0440u0430u0431u043eu0442u043au0435_u043du0430_python': "vim",
            }),
        )
        unicode_form_submission.submit_time = '2014-01-02T12:00:00.000Z'
        unicode_form_submission.save()

        response = self.client.get(
            reverse('wagtailforms:list_submissions', args=(self.form_page.id,)),
            {'date_from': '01/02/2014', 'export': 'csv'}
        )

        # Check response
        self.assertEqual(response.status_code, 200)

        data_lines = response.getvalue().decode('utf-8').split("\n")
        self.assertIn('   IDE    Python', data_lines[0])
        self.assertIn('vim', data_lines[1])


</source>
</class>

<class classid="45" nclones="3" nlines="15" similarity="93">
<source file="systems/wagtail-2.16.1/wagtail/contrib/forms/tests/test_views.py" startline="802" endline="823" pcid="1168">
    def test_list_submissions_csv_export_with_date_from_filtering(self):
        response = self.client.get(
            reverse('wagtailforms:list_submissions', args=(self.form_page.id,)),
            {'export': 'csv', 'date_from': '01/01/2014'}
        )

        # Check response
        self.assertEqual(response.status_code, 200)
        data_lines = response.getvalue().decode().split("\n")

        self.assertEqual(data_lines[0], 'User email,Submission date,Your email,Your message,Your choices\r')
        if settings.USE_TZ:
            self.assertEqual(
                data_lines[1],
                'user-m1kola@example.com,2014-01-01 12:00:00+00:00,new@example.com,this is a fairly new message,None\r'
            )
        else:
            self.assertEqual(
                data_lines[1],
                'user-m1kola@example.com,2014-01-01 12:00:00,new@example.com,this is a fairly new message,None\r'
            )

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/forms/tests/test_views.py" startline="824" endline="845" pcid="1169">
    def test_list_submissions_csv_export_with_date_to_filtering(self):
        response = self.client.get(
            reverse('wagtailforms:list_submissions', args=(self.form_page.id,)),
            {'export': 'csv', 'date_to': '12/31/2013'}
        )

        # Check response
        self.assertEqual(response.status_code, 200)
        data_lines = response.getvalue().decode().split("\n")

        self.assertEqual(data_lines[0], 'User email,Submission date,Your email,Your message,Your choices\r')
        if settings.USE_TZ:
            self.assertEqual(
                data_lines[1],
                'user-john@example.com,2013-01-01 12:00:00+00:00,old@example.com,this is a really old message,None\r'
            )
        else:
            self.assertEqual(
                data_lines[1],
                'user-john@example.com,2013-01-01 12:00:00,old@example.com,this is a really old message,None\r'
            )

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/forms/tests/test_views.py" startline="846" endline="867" pcid="1170">
    def test_list_submissions_csv_export_with_range_filtering(self):
        response = self.client.get(
            reverse('wagtailforms:list_submissions', args=(self.form_page.id,)),
            {'export': 'csv', 'date_from': '12/31/2013', 'date_to': '01/02/2014'}
        )

        # Check response
        self.assertEqual(response.status_code, 200)
        data_lines = response.getvalue().decode().split("\n")

        self.assertEqual(data_lines[0], 'User email,Submission date,Your email,Your message,Your choices\r')
        if settings.USE_TZ:
            self.assertEqual(
                data_lines[1],
                'user-m1kola@example.com,2014-01-01 12:00:00+00:00,new@example.com,this is a fairly new message,None\r'
            )
        else:
            self.assertEqual(
                data_lines[1],
                'user-m1kola@example.com,2014-01-01 12:00:00,new@example.com,this is a fairly new message,None\r'
            )

</source>
</class>

<class classid="46" nclones="2" nlines="26" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/contrib/forms/tests/test_views.py" startline="1427" endline="1456" pcid="1205">
    def test_adding_duplicate_form_labels(self):
        post_data = {
            'title': "Form page!",
            'content': "Some content",
            'slug': 'contact-us',
            'form_fields-TOTAL_FORMS': '3',
            'form_fields-INITIAL_FORMS': '3',
            'form_fields-MIN_NUM_FORMS': '0',
            'form_fields-MAX_NUM_FORMS': '1000',
            'form_fields-0-id': '',
            'form_fields-0-label': 'foo',
            'form_fields-0-field_type': 'singleline',
            'form_fields-1-id': '',
            'form_fields-1-label': 'foo',
            'form_fields-1-field_type': 'singleline',
            'form_fields-2-id': '',
            'form_fields-2-label': 'bar',
            'form_fields-2-field_type': 'singleline',
        }
        response = self.client.post(
            reverse('wagtailadmin_pages:add', args=('tests', 'formpage', self.root_page.id)), post_data
        )

        self.assertEqual(response.status_code, 200)

        self.assertContains(
            response,
            text="There is another field with the label foo, please change one of them.",
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/forms/tests/test_views.py" startline="1457" endline="1490" pcid="1206">
    def test_adding_duplicate_form_labels_as_cleaned_name(self):
        """
        Ensure form submission fails when attempting to create labels that will resolve
        to the same internal clean_name on the form field.
        """

        post_data = {
            'title': "Form page!",
            'content': "Some content",
            'slug': 'contact-us',
            'form_fields-TOTAL_FORMS': '3',
            'form_fields-INITIAL_FORMS': '3',
            'form_fields-MIN_NUM_FORMS': '0',
            'form_fields-MAX_NUM_FORMS': '1000',
            'form_fields-0-id': '',
            'form_fields-0-label': 'LOW EARTH ORBIT',
            'form_fields-0-field_type': 'singleline',
            'form_fields-1-id': '',
            'form_fields-1-label': 'low earth orbit',
            'form_fields-1-field_type': 'singleline',
            'form_fields-2-id': '',
            'form_fields-2-label': 'bar',
            'form_fields-2-field_type': 'singleline',
        }
        response = self.client.post(
            reverse('wagtailadmin_pages:add', args=('tests', 'formpage', self.root_page.id)), post_data
        )

        self.assertEqual(response.status_code, 200)

        self.assertContains(
            response,
            text="There is another field with the label LOW EARTH ORBIT, please change one of them.",
        )
</source>
</class>

<class classid="47" nclones="3" nlines="32" similarity="90">
<source file="systems/wagtail-2.16.1/wagtail/contrib/forms/tests/utils.py" startline="8" endline="44" pcid="1207">
def make_form_page(**kwargs):
    kwargs.setdefault('title', "Contact us")
    kwargs.setdefault('slug', "contact-us")
    kwargs.setdefault('to_address', "to@email.com")
    kwargs.setdefault('from_address', "from@email.com")
    kwargs.setdefault('subject', "The subject")

    home_page = Page.objects.get(url_path='/home/')
    form_page = home_page.add_child(instance=FormPage(**kwargs))

    FormField.objects.create(
        page=form_page,
        sort_order=1,
        label="Your email",
        field_type='email',
        required=True,
    )
    FormField.objects.create(
        page=form_page,
        sort_order=2,
        label="Your message",
        field_type='multiline',
        required=True,
        help_text="<em>please</em> be polite"
    )
    FormField.objects.create(
        page=form_page,
        sort_order=3,
        label="Your choices",
        field_type='checkboxes',
        required=False,
        choices='foo,bar,baz',
    )

    return form_page


</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/forms/tests/utils.py" startline="83" endline="120" pcid="1209">
def make_form_page_with_redirect(**kwargs):
    kwargs.setdefault('title', "Contact us")
    kwargs.setdefault('slug', "contact-us")
    kwargs.setdefault('to_address', "to@email.com")
    kwargs.setdefault('from_address', "from@email.com")
    kwargs.setdefault('subject', "The subject")

    home_page = Page.objects.get(url_path='/home/')
    kwargs.setdefault('thank_you_redirect_page', home_page)
    form_page = home_page.add_child(instance=FormPageWithRedirect(**kwargs))
    # form_page.thank_you_redirect_page = home_page

    RedirectFormField.objects.create(
        page=form_page,
        sort_order=1,
        label="Your email",
        field_type='email',
        required=True,
    )
    RedirectFormField.objects.create(
        page=form_page,
        sort_order=2,
        label="Your message",
        field_type='multiline',
        required=True,
    )
    RedirectFormField.objects.create(
        page=form_page,
        sort_order=3,
        label="Your choices",
        field_type='checkboxes',
        required=False,
        choices='foo,bar,baz',
    )

    return form_page


</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/forms/tests/utils.py" startline="45" endline="82" pcid="1208">
def make_form_page_with_custom_submission(**kwargs):
    kwargs.setdefault('title', "Contact us")
    kwargs.setdefault('intro', "<p>Boring intro text</p>")
    kwargs.setdefault('thank_you_text', "<p>Thank you for your patience!</p>")
    kwargs.setdefault('slug', "contact-us")
    kwargs.setdefault('to_address', "to@email.com")
    kwargs.setdefault('from_address', "from@email.com")
    kwargs.setdefault('subject', "The subject")

    home_page = Page.objects.get(url_path='/home/')
    form_page = home_page.add_child(instance=FormPageWithCustomSubmission(**kwargs))

    FormFieldWithCustomSubmission.objects.create(
        page=form_page,
        sort_order=1,
        label="Your email",
        field_type='email',
        required=True,
    )
    FormFieldWithCustomSubmission.objects.create(
        page=form_page,
        sort_order=2,
        label="Your message",
        field_type='multiline',
        required=True,
    )
    FormFieldWithCustomSubmission.objects.create(
        page=form_page,
        sort_order=3,
        label="Your choices",
        field_type='checkboxes',
        required=False,
        choices='foo,bar,baz',
    )

    return form_page


</source>
</class>

<class classid="48" nclones="2" nlines="102" similarity="73">
<source file="systems/wagtail-2.16.1/wagtail/contrib/forms/tests/utils.py" startline="121" endline="220" pcid="1210">
def make_types_test_form_page(**kwargs):
    kwargs.setdefault('title', "Contact us")
    kwargs.setdefault('slug', "contact-us")
    kwargs.setdefault('to_address', "to@email.com")
    kwargs.setdefault('from_address', "from@email.com")
    kwargs.setdefault('subject', "The subject")

    home_page = Page.objects.get(url_path='/home/')
    form_page = home_page.add_child(instance=FormPage(**kwargs))

    FormField.objects.create(
        page=form_page,
        sort_order=1,
        label="Single line text",
        field_type='singleline',
        required=False,
    )
    FormField.objects.create(
        page=form_page,
        sort_order=2,
        label="Multiline",
        field_type='multiline',
        required=False,
    )
    FormField.objects.create(
        page=form_page,
        sort_order=3,
        label="Email",
        field_type='email',
        required=False,
    )
    FormField.objects.create(
        page=form_page,
        sort_order=4,
        label="Number",
        field_type='number',
        required=False,
    )
    FormField.objects.create(
        page=form_page,
        sort_order=5,
        label="URL",
        field_type='url',
        required=False,
    )
    FormField.objects.create(
        page=form_page,
        sort_order=6,
        label="Checkbox",
        field_type='checkbox',
        required=False,
    )
    FormField.objects.create(
        page=form_page,
        sort_order=7,
        label="Checkboxes",
        field_type='checkboxes',
        required=False,
        choices='foo,bar,baz',
    )
    FormField.objects.create(
        page=form_page,
        sort_order=8,
        label="Drop down",
        field_type='dropdown',
        required=False,
        choices='spam,ham,eggs',
    )
    FormField.objects.create(
        page=form_page,
        sort_order=9,
        label="Multiple select",
        field_type='multiselect',
        required=False,
        choices='qux,quux,quuz,corge',
    )
    FormField.objects.create(
        page=form_page,
        sort_order=10,
        label="Radio buttons",
        field_type='radio',
        required=False,
        choices='wibble,wobble,wubble',
    )
    FormField.objects.create(
        page=form_page,
        sort_order=11,
        label="Date",
        field_type='date',
        required=False,
    )
    FormField.objects.create(
        page=form_page,
        sort_order=12,
        label="Datetime",
        field_type='datetime',
        required=False,
    )

    return form_page
</source>
<source file="systems/wagtail-2.16.1/wagtail/contrib/forms/tests/test_forms.py" startline="12" endline="123" pcid="1211">
    def setUp(self):
        # Create a form page
        home_page = Page.objects.get(url_path='/home/')

        self.form_page = home_page.add_child(instance=FormPage(
            title="Contact us",
            slug="contact-us",
            to_address="to@email.com",
            from_address="from@email.com",
            subject="The subject",
        ))

        FormField.objects.create(
            page=self.form_page,
            sort_order=1,
            label="Your name",
            field_type='singleline',
            required=True,
        )
        FormField.objects.create(
            page=self.form_page,
            sort_order=2,
            label="Your message",
            field_type='multiline',
            required=True,
        )
        FormField.objects.create(
            page=self.form_page,
            sort_order=2,
            label="Your birthday",
            field_type='date',
            required=True,
        )
        FormField.objects.create(
            page=self.form_page,
            sort_order=2,
            label="Your birthtime :)",
            field_type='datetime',
            required=True,
        )
        FormField.objects.create(
            page=self.form_page,
            sort_order=1,
            label="Your email",
            field_type='email',
            required=True,
        )
        FormField.objects.create(
            page=self.form_page,
            sort_order=2,
            label="Your homepage",
            field_type='url',
            required=True,
        )
        FormField.objects.create(
            page=self.form_page,
            sort_order=2,
            label="Your favourite number",
            field_type='number',
            required=True,
        )
        FormField.objects.create(
            page=self.form_page,
            sort_order=2,
            label="Your favourite text editors",
            field_type='multiselect',
            required=True,
            choices='vim,nano,emacs',
        )
        FormField.objects.create(
            page=self.form_page,
            sort_order=2,
            label="Your favourite Python IDEs",
            field_type='dropdown',
            required=True,
            choices='PyCharm,vim,nano',
        )
        FormField.objects.create(
            page=self.form_page,
            sort_order=2,
            label="our favourite ython ",  # unicode example
            help_text="Choose one",
            field_type='radio',
            required=True,
            choices='PyCharm,vim,nano',
        )
        FormField.objects.create(
            page=self.form_page,
            sort_order=3,
            label="Your choices",
            field_type='checkboxes',
            required=False,
            choices='foo,bar,baz',
        )
        FormField.objects.create(
            page=self.form_page,
            sort_order=3,
            label="I agree to the Terms of Use",
            field_type='checkbox',
            required=True,
        )
        FormField.objects.create(
            page=self.form_page,
            sort_order=1,
            label="A Hidden Field",
            field_type='hidden',
            required=False,
        )

        # Create a form builder
        self.fb = FormBuilder(self.form_page.get_form_fields())

</source>
</class>

<class classid="49" nclones="2" nlines="11" similarity="72">
<source file="systems/wagtail-2.16.1/wagtail/sites/tests.py" startline="75" endline="90" pcid="1272">
    def test_duplicate_defaults_not_allowed(self):
        response = self.post({
            'hostname': "also_default",
            'port': "80",
            'is_default_site': "on",
            'root_page': str(self.home_page.id),
        })

        # Should return the form with errors
        self.assertEqual(response.status_code, 200)
        self.assertEqual(bool(response.context['form'].errors), True)

        # Check that the site was not created
        sites = Site.objects.filter(hostname='also_default')
        self.assertEqual(sites.count(), 0)

</source>
<source file="systems/wagtail-2.16.1/wagtail/sites/tests.py" startline="104" endline="121" pcid="1274">
    def test_duplicate_hostnames_on_same_port_not_allowed(self):
        # Confirm there's one localhost already
        self.assertEqual(Site.objects.filter(hostname='localhost').count(), 1)

        response = self.post({
            'hostname': "localhost",
            'port': "80",
            'root_page': str(self.home_page.id),
        })

        # Should return the form with errors
        self.assertEqual(response.status_code, 200)
        self.assertEqual(bool(response.context['form'].errors), True)

        # Check that the site was not created, still only one localhost entry
        self.assertEqual(Site.objects.filter(hostname='localhost').count(), 1)


</source>
</class>

<class classid="50" nclones="2" nlines="18" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/admin/action_menu.py" startline="93" endline="116" pcid="1338">
    def get_context_data(self, parent_context):
        """Defines context for the template, overridable to use more data"""
        context = parent_context.copy()

        if requires_request_arg(self.get_url):
            warn(
                "%s.get_url should no longer take a 'request' argument. "
                "See https://docs.wagtail.org/en/stable/releases/2.15.html#template-components-2-15" % type(self).__name__,
                category=RemovedInWagtail217Warning
            )
            url = self.get_url(parent_context['request'], parent_context)
        else:
            url = self.get_url(parent_context)

        context.update({
            'label': self.label,
            'url': url,
            'name': self.name,
            'classname': self.classname,
            'icon_name': self.icon_name,
            'request': parent_context['request'],
        })
        return context

</source>
<source file="systems/wagtail-2.16.1/wagtail/snippets/action_menu.py" startline="79" endline="102" pcid="2869">
    def get_context_data(self, parent_context):
        """Defines context for the template, overridable to use more data"""
        context = parent_context.copy()

        if requires_request_arg(self.get_url):
            warn(
                "%s.get_url should no longer take a 'request' argument. "
                "See https://docs.wagtail.org/en/stable/releases/2.15.html#template-components-2-15" % type(self).__name__,
                category=RemovedInWagtail217Warning
            )
            url = self.get_url(parent_context['request'], parent_context)
        else:
            url = self.get_url(parent_context)

        context.update({
            'label': self.label,
            'url': url,
            'name': self.name,
            'classname': self.classname,
            'icon_name': self.icon_name,
            'request': parent_context['request'],
        })
        return context

</source>
</class>

<class classid="51" nclones="2" nlines="24" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/admin/action_menu.py" startline="124" endline="164" pcid="1340">
    def render_html(self, *args):
        # accepts both render_html(request, parent_context) (pre-2.15 signature)
        # and render_html(parent_context) (signature as of 2.15)
        # to allow for pre-2.15 ActionMenuItem subclasses calling super().
        # RemovedInWagtail217Warning: signature should become render_html(self, parent_context)

        if len(args) == 2:
            warn(
                "ActionMenuItem.render_html no longer takes a 'request' argument. "
                "See https://docs.wagtail.org/en/stable/releases/2.15.html#template-components-2-15",
                category=RemovedInWagtail217Warning, stacklevel=2
            )
            request, parent_context = args
        else:
            parent_context, = args

        if not getattr(self.get_context, 'is_base_method', False):
            # get_context has been overridden, so call it instead of get_context_data
            warn(
                "%s should define get_context_data(self, parent_context) instead of get_context(self, request, get_context_data). "
                "See https://docs.wagtail.org/en/stable/releases/2.15.html#template-components-2-15" % type(self).__name__,
                category=RemovedInWagtail217Warning
            )
            context_data = self.get_context(parent_context['request'], parent_context)
        else:
            context_data = self.get_context_data(parent_context)

        if self.template:
            warn(
                "%s should define template_name instead of template. "
                "See https://docs.wagtail.org/en/stable/releases/2.15.html#template-components-2-15" % type(self).__name__,
                category=RemovedInWagtail217Warning
            )
            template_name = self.template
        else:
            template_name = self.template_name

        template = get_template(template_name)
        return template.render(context_data)


</source>
<source file="systems/wagtail-2.16.1/wagtail/snippets/action_menu.py" startline="110" endline="150" pcid="2871">
    def render_html(self, *args):
        # accepts both render_html(request, parent_context) (pre-2.15 signature)
        # and render_html(parent_context) (signature as of 2.15)
        # to allow for pre-2.15 ActionMenuItem subclasses calling super().
        # RemovedInWagtail217Warning: signature should become render_html(self, parent_context)

        if len(args) == 2:
            warn(
                "ActionMenuItem.render_html no longer takes a 'request' argument. "
                "See https://docs.wagtail.org/en/stable/releases/2.15.html#template-components-2-15",
                category=RemovedInWagtail217Warning, stacklevel=2
            )
            request, parent_context = args
        else:
            parent_context, = args

        if not getattr(self.get_context, 'is_base_method', False):
            # get_context has been overridden, so call it instead of get_context_data
            warn(
                "%s should define get_context_data(self, parent_context) instead of get_context(self, request, get_context_data). "
                "See https://docs.wagtail.org/en/stable/releases/2.15.html#template-components-2-15" % type(self).__name__,
                category=RemovedInWagtail217Warning
            )
            context_data = self.get_context(parent_context['request'], parent_context)
        else:
            context_data = self.get_context_data(parent_context)

        if self.template:
            warn(
                "%s should define template_name instead of template."
                "See https://docs.wagtail.org/en/stable/releases/2.15.html#template-components-2-15" % type(self).__name__,
                category=RemovedInWagtail217Warning
            )
            template_name = self.template
        else:
            template_name = self.template_name

        template = get_template(template_name)
        return template.render(context_data)


</source>
</class>

<class classid="52" nclones="2" nlines="22" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/admin/action_menu.py" startline="482" endline="510" pcid="1364">
    def render_html(self):
        rendered_menu_items = []
        for menu_item in self.menu_items:
            if requires_request_arg(menu_item.render_html):
                warn(
                    "%s.render_html should no longer take a 'request' argument. "
                    "See https://docs.wagtail.org/en/stable/releases/2.15.html#template-components-2-15" % type(menu_item).__name__,
                    category=RemovedInWagtail217Warning
                )
                rendered_menu_items.append(menu_item.render_html(self.request, self.context))
            else:
                rendered_menu_items.append(menu_item.render_html(self.context))

        if requires_request_arg(self.default_item.render_html):
            warn(
                "%s.render_html should no longer take a 'request' argument. "
                "See https://docs.wagtail.org/en/stable/releases/2.15.html#template-components-2-15" % type(self.default_item).__name__,
                category=RemovedInWagtail217Warning
            )
            rendered_default_item = self.default_item.render_html(self.request, self.context)
        else:
            rendered_default_item = self.default_item.render_html(self.context)

        return render_to_string(self.template, {
            'default_menu_item': rendered_default_item,
            'show_menu': bool(self.menu_items),
            'rendered_menu_items': rendered_menu_items,
        }, request=self.request)

</source>
<source file="systems/wagtail-2.16.1/wagtail/snippets/action_menu.py" startline="234" endline="262" pcid="2876">
    def render_html(self):
        rendered_menu_items = []
        for menu_item in self.menu_items:
            if requires_request_arg(menu_item.render_html):
                warn(
                    "%s.render_html should no longer take a 'request' argument. "
                    "See https://docs.wagtail.org/en/stable/releases/2.15.html#template-components-2-15" % type(menu_item).__name__,
                    category=RemovedInWagtail217Warning
                )
                rendered_menu_items.append(menu_item.render_html(self.request, self.context))
            else:
                rendered_menu_items.append(menu_item.render_html(self.context))

        if requires_request_arg(self.default_item.render_html):
            warn(
                "%s.render_html should no longer take a 'request' argument. "
                "See https://docs.wagtail.org/en/stable/releases/2.15.html#template-components-2-15" % type(self.default_item).__name__,
                category=RemovedInWagtail217Warning
            )
            rendered_default_item = self.default_item.render_html(self.request, self.context)
        else:
            rendered_default_item = self.default_item.render_html(self.context)

        return render_to_string(self.template, {
            'default_menu_item': rendered_default_item,
            'show_menu': bool(self.menu_items),
            'rendered_menu_items': rendered_menu_items,
        }, request=self.request)

</source>
</class>

<class classid="53" nclones="3" nlines="13" similarity="84">
<source file="systems/wagtail-2.16.1/wagtail/admin/migrations/0001_create_admin_access_permissions.py" startline="5" endline="27" pcid="1366">
def create_admin_access_permissions(apps, schema_editor):
    ContentType = apps.get_model('contenttypes.ContentType')
    Permission = apps.get_model('auth.Permission')
    Group = apps.get_model('auth.Group')

    # Add a content type to hang the 'can access Wagtail admin' permission off
    wagtailadmin_content_type, created = ContentType.objects.get_or_create(
        app_label='wagtailadmin',
        model='admin'
    )

    # Create admin permission
    admin_permission, created = Permission.objects.get_or_create(
        content_type=wagtailadmin_content_type,
        codename='access_admin',
        name='Can access Wagtail admin'
    )

    # Assign it to Editors and Moderators groups
    for group in Group.objects.filter(name__in=['Editors', 'Moderators']):
        group.permissions.add(admin_permission)


</source>
<source file="systems/wagtail-2.16.1/wagtail/images/migrations/0023_add_choose_permissions.py" startline="6" endline="30" pcid="4916">
def add_choose_permission_to_admin_groups(apps, _schema_editor):
    ContentType = apps.get_model('contenttypes.ContentType')
    Permission = apps.get_model('auth.Permission')
    Group = apps.get_model('auth.Group')

    # Get image content type
    image_content_type, _created = ContentType.objects.get_or_create(
        model='image',
        app_label='wagtailimages'
    )

    # Create the Choose permission (if it doesn't already exist)
    choose_image_permission, _created = Permission.objects.get_or_create(
        content_type=image_content_type,
        codename='choose_image',
        defaults={'name': 'Can choose image'}
    )

    # Assign it to all groups which have "Access the Wagtail admin" permission.
    # This emulates the previous behavior, where everyone could choose any image in any Collection
    # because choosing wasn't permissioned.
    for group in Group.objects.filter(permissions__codename='access_admin'):
        group.permissions.add(choose_image_permission)


</source>
<source file="systems/wagtail-2.16.1/wagtail/documents/migrations/0011_add_choose_permissions.py" startline="6" endline="30" pcid="4670">
def add_choose_permission_to_admin_groups(apps, _schema_editor):
    ContentType = apps.get_model('contenttypes.ContentType')
    Permission = apps.get_model('auth.Permission')
    Group = apps.get_model('auth.Group')

    # Get document content type
    document_content_type, _created = ContentType.objects.get_or_create(
        model='document',
        app_label='wagtaildocs'
    )

    # Create the Choose permission (if it doesn't already exist)
    choose_document_permission, _created = Permission.objects.get_or_create(
        content_type=document_content_type,
        codename='choose_document',
        defaults={'name': 'Can choose document'}
    )

    # Assign it to all groups which have "Access the Wagtail admin" permission.
    # This emulates the previous behavior, where everyone who would access the admin
    # could choose any document in any Collection, because choosing wasn't permissioned.
    for group in Group.objects.filter(permissions__codename='access_admin'):
        group.permissions.add(choose_document_permission)


</source>
</class>

<class classid="54" nclones="5" nlines="11" similarity="81">
<source file="systems/wagtail-2.16.1/wagtail/admin/migrations/0001_create_admin_access_permissions.py" startline="28" endline="42" pcid="1367">
def remove_admin_access_permissions(apps, schema_editor):
    """Reverse the above additions of permissions."""
    ContentType = apps.get_model('contenttypes.ContentType')
    Permission = apps.get_model('auth.Permission')
    wagtailadmin_content_type = ContentType.objects.get(
        app_label='wagtailadmin',
        model='admin',
    )
    # This cascades to Group
    Permission.objects.filter(
        content_type=wagtailadmin_content_type,
        codename='access_admin',
    ).delete()


</source>
<source file="systems/wagtail-2.16.1/wagtail/documents/migrations/0002_initial_data.py" startline="37" endline="51" pcid="4666">
def remove_document_permissions(apps, schema_editor):
    """Reverse the above additions of permissions."""
    ContentType = apps.get_model('contenttypes.ContentType')
    Permission = apps.get_model('auth.Permission')
    document_content_type = ContentType.objects.get(
        model='document',
        app_label='wagtaildocs',
    )
    # This cascades to Group
    Permission.objects.filter(
        content_type=document_content_type,
        codename__in=('add_document', 'change_document', 'delete_document'),
    ).delete()


</source>
<source file="systems/wagtail-2.16.1/wagtail/images/migrations/0023_add_choose_permissions.py" startline="31" endline="45" pcid="4917">
def remove_choose_permission(apps, _schema_editor):
    """Reverse the above additions of permissions."""
    ContentType = apps.get_model('contenttypes.ContentType')
    Permission = apps.get_model('auth.Permission')
    image_content_type = ContentType.objects.get(
        model='image',
        app_label='wagtailimages',
    )
    # This cascades to Group
    Permission.objects.filter(
        content_type=image_content_type,
        codename='choose_image'
    ).delete()


</source>
<source file="systems/wagtail-2.16.1/wagtail/documents/migrations/0011_add_choose_permissions.py" startline="31" endline="45" pcid="4671">
def remove_choose_permission(apps, _schema_editor):
    """Reverse the above additions of permissions."""
    ContentType = apps.get_model('contenttypes.ContentType')
    Permission = apps.get_model('auth.Permission')
    document_content_type = ContentType.objects.get(
        model='document',
        app_label='wagtaildocs',
    )
    # This cascades to Group
    Permission.objects.filter(
        content_type=document_content_type,
        codename='choose_document'
    ).delete()


</source>
<source file="systems/wagtail-2.16.1/wagtail/images/migrations/0002_initial_data.py" startline="37" endline="51" pcid="4912">
def remove_image_permissions(apps, schema_editor):
    """Reverse the above additions of permissions."""
    ContentType = apps.get_model('contenttypes.ContentType')
    Permission = apps.get_model('auth.Permission')
    image_content_type = ContentType.objects.get(
        model='image',
        app_label='wagtailimages',
    )
    # This cascades to Group
    Permission.objects.filter(
        content_type=image_content_type,
        codename__in=('add_image', 'change_image', 'delete_image')
    ).delete()


</source>
</class>

<class classid="55" nclones="2" nlines="15" similarity="73">
<source file="systems/wagtail-2.16.1/wagtail/admin/checks.py" startline="35" endline="54" pcid="1369">
def base_form_class_check(app_configs, **kwargs):
    from wagtail.admin.forms import WagtailAdminPageForm
    from wagtail.core.models import get_page_models

    errors = []

    for cls in get_page_models():
        if not issubclass(cls.base_form_class, WagtailAdminPageForm):
            errors.append(Error(
                "{}.base_form_class does not extend WagtailAdminPageForm".format(
                    cls.__name__),
                hint="Ensure that {}.{} extends WagtailAdminPageForm".format(
                    cls.base_form_class.__module__,
                    cls.base_form_class.__name__),
                obj=cls,
                id='wagtailadmin.E001'))

    return errors


</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/checks.py" startline="56" endline="75" pcid="1370">
def get_form_class_check(app_configs, **kwargs):
    from wagtail.admin.forms import WagtailAdminPageForm
    from wagtail.core.models import get_page_models

    errors = []

    for cls in get_page_models():
        edit_handler = cls.get_edit_handler()
        if not issubclass(edit_handler.get_form_class(), WagtailAdminPageForm):
            errors.append(Error(
                "{cls}.get_edit_handler().get_form_class() does not extend WagtailAdminPageForm".format(
                    cls=cls.__name__),
                hint="Ensure that the EditHandler for {cls} creates a subclass of WagtailAdminPageForm".format(
                    cls=cls.__name__),
                obj=cls,
                id='wagtailadmin.E002'))

    return errors


</source>
</class>

<class classid="56" nclones="2" nlines="26" similarity="85">
<source file="systems/wagtail-2.16.1/wagtail/admin/views/pages/delete.py" startline="14" endline="48" pcid="1392">
def delete(request, page_id):
    page = get_object_or_404(Page, id=page_id).specific
    if not page.permissions_for_user(request.user).can_delete():
        raise PermissionDenied

    with transaction.atomic():
        for fn in hooks.get_hooks('before_delete_page'):
            result = fn(request, page)
            if hasattr(result, 'status_code'):
                return result

        next_url = get_valid_next_url_from_request(request)

        if request.method == 'POST':
            parent_id = page.get_parent().id
            action = DeletePageAction(page, user=request.user)
            # Permission checks are done above, so skip them in execute.
            action.execute(skip_permission_checks=True)

            messages.success(request, _("Page '{0}' deleted.").format(page.get_admin_display_title()))

            for fn in hooks.get_hooks('after_delete_page'):
                result = fn(request, page)
                if hasattr(result, 'status_code'):
                    return result

            if next_url:
                return redirect(next_url)
            return redirect('wagtailadmin_explore', parent_id)

    return TemplateResponse(request, 'wagtailadmin/pages/confirm_delete.html', {
        'page': page,
        'descendant_count': page.get_descendant_count(),
        'next': next_url,
    })
</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/views/pages/convert_alias.py" startline="14" endline="45" pcid="1422">
def convert_alias(request, page_id):
    page = get_object_or_404(Page, id=page_id, alias_of_id__isnull=False).specific
    if not page.permissions_for_user(request.user).can_edit():
        raise PermissionDenied

    with transaction.atomic():
        for fn in hooks.get_hooks('before_convert_alias_page'):
            result = fn(request, page)
            if hasattr(result, 'status_code'):
                return result

        next_url = get_valid_next_url_from_request(request)

        if request.method == 'POST':
            action = ConvertAliasPageAction(page, user=request.user)
            action.execute(skip_permission_checks=True)

            messages.success(request, _("Page '{0}' has been converted into an ordinary page.").format(page.get_admin_display_title()))

            for fn in hooks.get_hooks('after_convert_alias_page'):
                result = fn(request, page)
                if hasattr(result, 'status_code'):
                    return result

            if next_url:
                return redirect(next_url)
            return redirect('wagtailadmin_pages:edit', page.id)

    return TemplateResponse(request, 'wagtailadmin/pages/confirm_convert_alias.html', {
        'page': page,
        'next': next_url,
    })
</source>
</class>

<class classid="57" nclones="3" nlines="17" similarity="70">
<source file="systems/wagtail-2.16.1/wagtail/admin/views/pages/edit.py" startline="449" endline="473" pcid="1412">
    def save_action(self):
        self.page = self.form.save(commit=False)
        self.subscription.save()

        # Save revision
        revision = self.page.save_revision(
            user=self.request.user,
            log_action=True,  # Always log the new revision on edit
            previous_revision=(self.previous_revision if self.is_reverting else None)
        )

        self.add_save_confirmation_message()

        if self.has_content_changes and 'comments' in self.form.formsets:
            changes = self.get_commenting_changes()
            self.log_commenting_changes(changes, revision)
            self.send_commenting_notifications(changes)

        response = self.run_hook('after_edit_page', self.request, self.page)
        if response:
            return response

        # Just saving - remain on edit page for further edits
        return self.redirect_and_remain()

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/views/pages/edit.py" startline="683" endline="709" pcid="1417">
    def cancel_workflow_action(self):
        self.workflow_state.cancel(user=self.request.user)
        self.page = self.form.save(commit=False)
        self.subscription.save()

        # Save revision
        revision = self.page.save_revision(
            user=self.request.user,
            log_action=True,  # Always log the new revision on edit
            previous_revision=(self.previous_revision if self.is_reverting else None)
        )

        if self.has_content_changes and 'comments' in self.form.formsets:
            changes = self.get_commenting_changes()
            self.log_commenting_changes(changes, revision)
            self.send_commenting_notifications(changes)

        # Notifications
        self.add_cancel_workflow_confirmation_message()

        response = self.run_hook('after_edit_page', self.request, self.page)
        if response:
            return response

        # Just saving - remain on edit page for further edits
        return self.redirect_and_remain()

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/views/pages/edit.py" startline="653" endline="682" pcid="1416">
    def perform_workflow_action(self):
        self.page = self.form.save(commit=False)
        self.subscription.save()

        if self.has_content_changes:
            # Save revision
            revision = self.page.save_revision(
                user=self.request.user,
                log_action=True,  # Always log the new revision on edit
                previous_revision=(self.previous_revision if self.is_reverting else None)
            )

            if 'comments' in self.form.formsets:
                changes = self.get_commenting_changes()
                self.log_commenting_changes(changes, revision)
                self.send_commenting_notifications(changes)

        extra_workflow_data_json = self.request.POST.get('workflow-action-extra-data', '{}')
        extra_workflow_data = json.loads(extra_workflow_data_json)
        self.page.current_workflow_task.on_action(self.page.current_workflow_task_state, self.request.user, self.workflow_action, **extra_workflow_data)

        self.add_save_confirmation_message()

        response = self.run_hook('after_edit_page', self.request, self.page)
        if response:
            return response

        # we're done here - redirect back to the explorer
        return self.redirect_away()

</source>
</class>

<class classid="58" nclones="2" nlines="26" similarity="88">
<source file="systems/wagtail-2.16.1/wagtail/admin/views/pages/edit.py" startline="571" endline="612" pcid="1414">
    def submit_action(self):
        self.page = self.form.save(commit=False)
        self.subscription.save()

        # Save revision
        revision = self.page.save_revision(
            user=self.request.user,
            log_action=True,  # Always log the new revision on edit
            previous_revision=(self.previous_revision if self.is_reverting else None)
        )

        if self.has_content_changes and 'comments' in self.form.formsets:
            changes = self.get_commenting_changes()
            self.log_commenting_changes(changes, revision)
            self.send_commenting_notifications(changes)

        if self.workflow_state and self.workflow_state.status == WorkflowState.STATUS_NEEDS_CHANGES:
            # If the workflow was in the needs changes state, resume the existing workflow on submission
            self.workflow_state.resume(self.request.user)
        else:
            # Otherwise start a new workflow
            workflow = self.page.get_workflow()
            workflow.start(self.page, self.request.user)

        message = _(
            "Page '{0}' has been submitted for moderation."
        ).format(
            self.page.get_admin_display_title()
        )

        messages.success(self.request, message, buttons=[
            self.get_view_draft_message_button(),
            self.get_edit_message_button(),
        ])

        response = self.run_hook('after_edit_page', self.request, self.page)
        if response:
            return response

        # we're done here - redirect back to the explorer
        return self.redirect_away()

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/views/pages/edit.py" startline="613" endline="652" pcid="1415">
    def restart_workflow_action(self):
        self.page = self.form.save(commit=False)
        self.subscription.save()

        # save revision
        revision = self.page.save_revision(
            user=self.request.user,
            log_action=True,  # Always log the new revision on edit
            previous_revision=(self.previous_revision if self.is_reverting else None)
        )

        if self.has_content_changes and 'comments' in self.form.formsets:
            changes = self.get_commenting_changes()
            self.log_commenting_changes(changes, revision)
            self.send_commenting_notifications(changes)

        # cancel workflow
        self.workflow_state.cancel(user=self.request.user)
        # start new workflow
        workflow = self.page.get_workflow()
        workflow.start(self.page, self.request.user)

        message = _(
            "Workflow on page '{0}' has been restarted."
        ).format(
            self.page.get_admin_display_title()
        )

        messages.success(self.request, message, buttons=[
            self.get_view_draft_message_button(),
            self.get_edit_message_button(),
        ])

        response = self.run_hook('after_edit_page', self.request, self.page)
        if response:
            return response

        # we're done here - redirect back to the explorer
        return self.redirect_away()

</source>
</class>

<class classid="59" nclones="2" nlines="46" similarity="91">
<source file="systems/wagtail-2.16.1/wagtail/admin/views/page_privacy.py" startline="9" endline="72" pcid="1464">
def set_privacy(request, page_id):
    page = get_object_or_404(Page, id=page_id)
    page_perms = page.permissions_for_user(request.user)
    if not page_perms.can_set_view_restrictions():
        raise PermissionDenied

    # fetch restriction records in depth order so that ancestors appear first
    restrictions = page.get_view_restrictions().order_by('page__depth')
    if restrictions:
        restriction = restrictions[0]
        restriction_exists_on_ancestor = (restriction.page != page)
    else:
        restriction = None
        restriction_exists_on_ancestor = False

    if request.method == 'POST':
        form = PageViewRestrictionForm(request.POST, instance=restriction)
        if form.is_valid() and not restriction_exists_on_ancestor:
            if form.cleaned_data['restriction_type'] == PageViewRestriction.NONE:
                # remove any existing restriction
                if restriction:
                    restriction.delete(user=request.user)
            else:
                restriction = form.save(commit=False)
                restriction.page = page
                restriction.save(user=request.user)
                # Save the groups many-to-many field
                form.save_m2m()

            return render_modal_workflow(
                request, None, None,
                None, json_data={
                    'step': 'set_privacy_done',
                    'is_public': (form.cleaned_data['restriction_type'] == 'none')
                }
            )

    else:  # request is a GET
        if not restriction_exists_on_ancestor:
            if restriction:
                form = PageViewRestrictionForm(instance=restriction)
            else:
                # no current view restrictions on this page
                form = PageViewRestrictionForm(initial={
                    'restriction_type': 'none'
                })

    if restriction_exists_on_ancestor:
        # display a message indicating that there is a restriction at ancestor level -
        # do not provide the form for setting up new restrictions
        return render_modal_workflow(
            request, 'wagtailadmin/page_privacy/ancestor_privacy.html', None,
            {
                'page_with_restriction': restriction.page,
            }
        )
    else:
        # no restriction set at ancestor level - can set restrictions here
        return render_modal_workflow(
            request, 'wagtailadmin/page_privacy/set_privacy.html', None, {
                'page': page,
                'form': form,
            }, json_data={'step': 'set_privacy'}
        )
</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/views/collection_privacy.py" startline="10" endline="70" pcid="1532">
def set_privacy(request, collection_id):
    collection = get_object_or_404(Collection, id=collection_id)
    if not collection_permission_policy.user_has_permission(request.user, 'change'):
        raise PermissionDenied

    # fetch restriction records in depth order so that ancestors appear first
    restrictions = collection.get_view_restrictions().order_by('collection__depth')
    if restrictions:
        restriction = restrictions[0]
        restriction_exists_on_ancestor = (restriction.collection != collection)
    else:
        restriction = None
        restriction_exists_on_ancestor = False

    if request.method == 'POST':
        form = CollectionViewRestrictionForm(request.POST, instance=restriction)
        if form.is_valid() and not restriction_exists_on_ancestor:
            if form.cleaned_data['restriction_type'] == CollectionViewRestriction.NONE:
                # remove any existing restriction
                if restriction:
                    restriction.delete()
            else:
                restriction = form.save(commit=False)
                restriction.collection = collection
                form.save()

            return render_modal_workflow(
                request, None, None,
                None, json_data={
                    'step': 'set_privacy_done',
                    'is_public': (form.cleaned_data['restriction_type'] == 'none')
                }
            )

    else:  # request is a GET
        if not restriction_exists_on_ancestor:
            if restriction:
                form = CollectionViewRestrictionForm(instance=restriction)
            else:
                # no current view restrictions on this collection
                form = CollectionViewRestrictionForm(initial={
                    'restriction_type': 'none'
                })

    if restriction_exists_on_ancestor:
        # display a message indicating that there is a restriction at ancestor level -
        # do not provide the form for setting up new restrictions
        return render_modal_workflow(
            request, 'wagtailadmin/collection_privacy/ancestor_privacy.html', None,
            {
                'collection_with_restriction': restriction.collection,
            }
        )
    else:
        # no restriction set at ancestor level - can set restrictions here
        return render_modal_workflow(
            request, 'wagtailadmin/collection_privacy/set_privacy.html', None, {
                'collection': collection,
                'form': form,
            }, json_data={'step': 'set_privacy'}
        )
</source>
</class>

<class classid="60" nclones="2" nlines="13" similarity="85">
<source file="systems/wagtail-2.16.1/wagtail/admin/views/userbar.py" startline="11" endline="31" pcid="1484">
def for_frontend(request, page_id):
    items = [
        EditPageItem(Page.objects.get(id=page_id)),
        AddPageItem(Page.objects.get(id=page_id)),
    ]

    for fn in hooks.get_hooks('construct_wagtail_userbar'):
        fn(request, items)

    # Render the items
    rendered_items = [item.render(request) for item in items]

    # Remove any unrendered items
    rendered_items = [item for item in rendered_items if item]

    # Render the edit bird
    return TemplateResponse(request, 'wagtailadmin/userbar/base.html', {
        'items': rendered_items,
    })


</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/views/userbar.py" startline="33" endline="53" pcid="1485">
def for_moderation(request, revision_id):
    items = [
        EditPageItem(PageRevision.objects.get(id=revision_id).page),
        AddPageItem(PageRevision.objects.get(id=revision_id).page),
        ApproveModerationEditPageItem(PageRevision.objects.get(id=revision_id)),
        RejectModerationEditPageItem(PageRevision.objects.get(id=revision_id)),
    ]

    for fn in hooks.get_hooks('construct_wagtail_userbar'):
        fn(request, items)

    # Render the items
    rendered_items = [item.render(request) for item in items]

    # Remove any unrendered items
    rendered_items = [item for item in rendered_items if item]

    # Render the edit bird
    return TemplateResponse(request, 'wagtailadmin/userbar/base.html', {
        'items': rendered_items,
    })
</source>
</class>

<class classid="61" nclones="2" nlines="11" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/admin/views/generic/multiple_upload.py" startline="49" endline="65" pcid="1540">
    def get_edit_object_form_context_data(self):
        """
        Return the context data necessary for rendering the HTML form for editing
        an object that has been successfully uploaded
        """
        edit_form_class = self.get_edit_form_class()
        return {
            self.context_object_name: self.object,
            'edit_action': reverse(self.edit_object_url_name, args=(self.object.id,)),
            'delete_action': reverse(self.delete_object_url_name, args=(self.object.id,)),
            'form': edit_form_class(
                instance=self.object,
                prefix='%s-%d' % (self.edit_object_form_prefix, self.object.id),
                user=self.request.user
            ),
        }

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/views/generic/multiple_upload.py" startline="80" endline="96" pcid="1542">
    def get_edit_upload_form_context_data(self):
        """
        Return the context data necessary for rendering the HTML form for supplying the
        metadata to turn an upload object into a final object
        """
        edit_form_class = self.get_edit_form_class()
        return {
            self.context_upload_name: self.upload_object,
            'edit_action': reverse(self.edit_upload_url_name, args=(self.upload_object.id,)),
            'delete_action': reverse(self.delete_upload_url_name, args=(self.upload_object.id,)),
            'form': edit_form_class(
                instance=self.object,
                prefix='%s-%d' % (self.edit_upload_form_prefix, self.upload_object.id),
                user=self.request.user
            ),
        }

</source>
</class>

<class classid="62" nclones="2" nlines="30" similarity="77">
<source file="systems/wagtail-2.16.1/wagtail/admin/views/generic/multiple_upload.py" startline="197" endline="233" pcid="1548">
    def post(self, request, *args, **kwargs):
        object_id = kwargs[self.pk_url_kwarg]
        self.model = self.get_model()
        self.form_class = self.get_edit_form_class()

        self.object = get_object_or_404(self.model, id=object_id)

        if not self.permission_policy.user_has_permission_for_instance(request.user, 'change', self.object):
            raise PermissionDenied

        form = self.form_class(
            request.POST, request.FILES,
            instance=self.object,
            prefix='%s-%d' % (self.edit_object_form_prefix, object_id),
            user=request.user
        )

        if form.is_valid():
            self.save_object(form)

            return JsonResponse({
                'success': True,
                self.context_object_id_name: int(object_id),
            })
        else:
            return JsonResponse({
                'success': False,
                self.context_object_id_name: int(object_id),
                'form': render_to_string(self.edit_form_template_name, {
                    self.context_object_name: self.object,  # only used for tests
                    'edit_action': reverse(self.edit_object_url_name, args=(object_id,)),
                    'delete_action': reverse(self.delete_object_url_name, args=(object_id,)),
                    'form': form,
                }, request=request),
            })


</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/views/generic/multiple_upload.py" startline="278" endline="316" pcid="1551">
    def post(self, request, *args, **kwargs):
        upload_id = kwargs[self.upload_pk_url_kwarg]
        self.model = self.get_model()
        self.form_class = self.get_edit_form_class()

        self.upload = get_object_or_404(self.upload_model, id=upload_id)

        if self.upload.uploaded_by_user != request.user:
            raise PermissionDenied

        self.object = self.model()
        form = self.form_class(
            request.POST, request.FILES,
            instance=self.object,
            prefix='%s-%d' % (self.edit_upload_form_prefix, upload_id),
            user=request.user
        )

        if form.is_valid():
            self.save_object(form)
            self.upload.file.delete()
            self.upload.delete()

            return JsonResponse({
                'success': True,
                self.context_object_id_name: self.object.id,
            })
        else:
            return JsonResponse({
                'success': False,
                'form': render_to_string(self.edit_form_template_name, {
                    self.context_upload_name: self.upload,
                    'edit_action': reverse(self.edit_upload_url_name, args=(self.upload.id,)),
                    'delete_action': reverse(self.delete_upload_url_name, args=(self.upload.id,)),
                    'form': form,
                }, request=request),
            })


</source>
</class>

<class classid="63" nclones="2" nlines="10" similarity="90">
<source file="systems/wagtail-2.16.1/wagtail/admin/views/generic/models.py" startline="164" endline="175" pcid="1569">
    def form_valid(self, form):
        self.form = form
        with transaction.atomic():
            self.object = self.save_instance()
            log(instance=self.object, action='wagtail.create')
        success_message = self.get_success_message(self.object)
        if success_message is not None:
            messages.success(self.request, success_message, buttons=[
                messages.button(reverse(self.edit_url_name, args=(self.object.id,)), _('Edit'))
            ])
        return redirect(self.get_success_url())

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/views/generic/models.py" startline="233" endline="244" pcid="1579">
    def form_valid(self, form):
        self.form = form
        with transaction.atomic():
            self.object = self.save_instance()
            log(instance=self.object, action='wagtail.edit')
        success_message = self.get_success_message()
        if success_message is not None:
            messages.success(self.request, success_message, buttons=[
                messages.button(reverse(self.edit_url_name, args=(self.object.id,)), _('Edit'))
            ])
        return redirect(self.get_success_url())

</source>
</class>

<class classid="64" nclones="5" nlines="10" similarity="70">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_page_locking.py" startline="12" endline="27" pcid="1607">
    def setUp(self):
        # Find root page
        self.root_page = Page.objects.get(id=2)

        # Login
        self.user = self.login()

        # Create a page and submit it for moderation
        self.child_page = SimplePage(
            title="Hello world!",
            slug='hello-world',
            content="hello",
            live=False,
        )
        self.root_page.add_child(instance=self.child_page)

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_management_commands.py" startline="358" endline="369" pcid="4323">
    def setUp(self):
        # Find root page
        self.root_page = Page.objects.get(id=2)
        self.page = SimplePage(
            title="Hello world!",
            slug="hello-world",
            content="hello",
            live=False,
        )
        self.root_page.add_child(instance=self.page)
        self.page.refresh_from_db()

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_unpublish_page.py" startline="16" endline="28" pcid="2037">
    def setUp(self):
        self.user = self.login()

        # Create a page to unpublish
        self.root_page = Page.objects.get(id=2)
        self.page = SimplePage(
            title="Hello world!",
            slug='hello-world',
            content="hello",
            live=True,
        )
        self.root_page.add_child(instance=self.page)

</source>
<source file="systems/wagtail-2.16.1/wagtail/snippets/tests.py" startline="1080" endline="1090" pcid="2999">
    def setUp(self):
        self.user = self.login()
        self.test_snippet = Advert.objects.get(pk=1)
        ModelLogEntry.objects.create(
            content_type=ContentType.objects.get_for_model(Advert),
            label="Test Advert",
            action='wagtail.create',
            timestamp=make_aware(datetime.datetime(2021, 9, 30, 10, 1, 0)),
            object_id='1',
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/snippets/tests.py" startline="531" endline="541" pcid="2939">
    def setUp(self):
        super().setUp()
        self.test_snippet = Advert.objects.get(pk=1)
        ModelLogEntry.objects.create(
            content_type=ContentType.objects.get_for_model(Advert),
            label="Test Advert",
            action='wagtail.create',
            timestamp=make_aware(datetime.datetime(2021, 9, 30, 10, 1, 0)),
            object_id='1',
        )

</source>
</class>

<class classid="65" nclones="9" nlines="11" similarity="72">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_page_locking.py" startline="52" endline="69" pcid="1610">
    def test_lock_post_already_locked(self):
        # Lock the page
        self.child_page.locked = True
        self.child_page.locked_by = self.user
        self.child_page.locked_at = timezone.now()
        self.child_page.save()

        response = self.client.post(reverse('wagtailadmin_pages:lock', args=(self.child_page.id, )))

        # Check response
        self.assertRedirects(response, reverse('wagtailadmin_explore', args=(self.root_page.id, )))

        # Check that the page is still locked
        page = Page.objects.get(id=self.child_page.id)
        self.assertTrue(page.locked)
        self.assertEqual(page.locked_by, self.user)
        self.assertIsNotNone(page.locked_at)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_page_locking.py" startline="227" endline="244" pcid="1621">
    def test_unlock_post_bad_page(self):
        # Lock the page
        self.child_page.locked = True
        self.child_page.locked_by = self.user
        self.child_page.locked_at = timezone.now()
        self.child_page.save()

        response = self.client.post(reverse('wagtailadmin_pages:unlock', args=(9999, )))

        # Check response
        self.assertEqual(response.status_code, 404)

        # Check that the page is still locked
        page = Page.objects.get(id=self.child_page.id)
        self.assertTrue(page.locked)
        self.assertEqual(page.locked_by, self.user)
        self.assertIsNotNone(page.locked_at)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_page_locking.py" startline="157" endline="174" pcid="1617">
    def test_unlock_get(self):
        # Lock the page
        self.child_page.locked = True
        self.child_page.locked_by = self.user
        self.child_page.locked_at = timezone.now()
        self.child_page.save()

        response = self.client.get(reverse('wagtailadmin_pages:unlock', args=(self.child_page.id, )))

        # Check response
        self.assertEqual(response.status_code, 405)

        # Check that the page is still locked
        page = Page.objects.get(id=self.child_page.id)
        self.assertTrue(page.locked)
        self.assertEqual(page.locked_by, self.user)
        self.assertIsNotNone(page.locked_at)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_page_locking.py" startline="139" endline="156" pcid="1616">
    def test_unlock_post(self):
        # Lock the page
        self.child_page.locked = True
        self.child_page.locked_by = self.user
        self.child_page.locked_at = timezone.now()
        self.child_page.save()

        response = self.client.post(reverse('wagtailadmin_pages:unlock', args=(self.child_page.id, )))

        # Check response
        self.assertRedirects(response, reverse('wagtailadmin_explore', args=(self.root_page.id, )))

        # Check that the page is unlocked
        page = Page.objects.get(id=self.child_page.id)
        self.assertFalse(page.locked)
        self.assertIsNone(page.locked_by)
        self.assertIsNone(page.locked_at)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_page_locking.py" startline="207" endline="226" pcid="1620">
    def test_unlock_post_with_bad_redirect(self):
        # Lock the page
        self.child_page.locked = True
        self.child_page.locked_by = self.user
        self.child_page.locked_at = timezone.now()
        self.child_page.save()

        response = self.client.post(reverse('wagtailadmin_pages:unlock', args=(self.child_page.id, )), {
            'next': 'http://www.google.co.uk'
        })

        # Check response
        self.assertRedirects(response, reverse('wagtailadmin_explore', args=(self.root_page.id, )))

        # Check that the page is unlocked
        page = Page.objects.get(id=self.child_page.id)
        self.assertFalse(page.locked)
        self.assertIsNone(page.locked_by)
        self.assertIsNone(page.locked_at)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_page_locking.py" startline="187" endline="206" pcid="1619">
    def test_unlock_post_with_good_redirect(self):
        # Lock the page
        self.child_page.locked = True
        self.child_page.locked_by = self.user
        self.child_page.locked_at = timezone.now()
        self.child_page.save()

        response = self.client.post(reverse('wagtailadmin_pages:unlock', args=(self.child_page.id, )), {
            'next': reverse('wagtailadmin_pages:edit', args=(self.child_page.id, ))
        })

        # Check response
        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )))

        # Check that the page is unlocked
        page = Page.objects.get(id=self.child_page.id)
        self.assertFalse(page.locked)
        self.assertIsNone(page.locked_by)
        self.assertIsNone(page.locked_at)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_page_locking.py" startline="110" endline="128" pcid="1614">
    def test_lock_post_bad_permissions(self):
        # Remove privileges from user
        self.user.is_superuser = False
        self.user.user_permissions.add(
            Permission.objects.get(content_type__app_label='wagtailadmin', codename='access_admin')
        )
        self.user.save()

        response = self.client.post(reverse('wagtailadmin_pages:lock', args=(self.child_page.id, )))

        # Check response
        self.assertEqual(response.status_code, 302)

        # Check that the page is still unlocked
        page = Page.objects.get(id=self.child_page.id)
        self.assertFalse(page.locked)
        self.assertIsNone(page.locked_by)
        self.assertIsNone(page.locked_at)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_page_locking.py" startline="245" endline="265" pcid="1622">
    def test_unlock_post_bad_permissions(self):
        # Remove privileges from user
        self.user.is_superuser = False
        self.user.groups.add(Group.objects.get(name="Editors"))
        self.user.save()

        # Lock the page
        self.child_page.locked = True
        self.child_page.locked_at = timezone.now()
        self.child_page.save()

        response = self.client.post(reverse('wagtailadmin_pages:unlock', args=(self.child_page.id, )))

        # Check response
        self.assertEqual(response.status_code, 302)

        # Check that the page is still locked
        page = Page.objects.get(id=self.child_page.id)
        self.assertTrue(page.locked)
        self.assertIsNotNone(page.locked_at)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_page_locking.py" startline="266" endline="291" pcid="1623">
    def test_unlock_post_own_page_with_bad_permissions(self):
        # Unlike the previous test, the user can unlock pages that they have locked

        # Remove privileges from user
        self.user.is_superuser = False
        self.user.groups.add(Group.objects.get(name="Editors"))
        self.user.save()

        # Lock the page
        self.child_page.locked = True
        self.child_page.locked_by = self.user
        self.child_page.locked_at = timezone.now()
        self.child_page.save()

        response = self.client.post(reverse('wagtailadmin_pages:unlock', args=(self.child_page.id, )), {
            'next': reverse('wagtailadmin_pages:edit', args=(self.child_page.id, ))
        })

        # Check response
        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )))

        # Check that the page is still locked
        page = Page.objects.get(id=self.child_page.id)
        self.assertFalse(page.locked)
        self.assertIsNone(page.locked_by)
        self.assertIsNone(page.locked_at)
</source>
</class>

<class classid="66" nclones="2" nlines="11" similarity="72">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_explorer_view.py" startline="398" endline="415" pcid="1653">
    def test_nonadmin_at_root(self):
        # Assign siteeditor permission over no_site_page, so that the deepest-common-ancestor
        # logic allows them to explore root
        GroupPagePermission.objects.create(
            group=Group.objects.get(name="Site-wide editors"),
            page=self.no_site_page, permission_type='add'
        )
        self.login(username='siteeditor', password='password')
        response = self.client.get(reverse('wagtailadmin_explore_root'))

        self.assertEqual(response.status_code, 200)
        # Non-admin should get a simple "create pages as children of the homepage" prompt
        self.assertContains(
            response,
            "Pages created here will not be accessible at any URL. "
            "To add pages to an existing site, create them as children of the homepage."
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_explorer_view.py" startline="416" endline="434" pcid="1654">
    def test_nonadmin_at_non_site_page(self):
        # Assign siteeditor permission over no_site_page
        GroupPagePermission.objects.create(
            group=Group.objects.get(name="Site-wide editors"),
            page=self.no_site_page, permission_type='add'
        )
        self.login(username='siteeditor', password='password')
        response = self.client.get(reverse('wagtailadmin_explore', args=(self.no_site_page.id, )))

        self.assertEqual(response.status_code, 200)
        # Non-admin should get a warning about unroutable pages
        self.assertContains(
            response,
            (
                "There is no site record for this location. "
                "Pages created here will not be accessible at any URL."
            )
        )

</source>
</class>

<class classid="67" nclones="2" nlines="16" similarity="70">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="151" endline="173" pcid="1674">
    def test_upload_file_publish(self):
        """
        Check that file uploads work when directly publishing
        """
        file_upload = ContentFile(b"A new file", name='published-file.txt')
        post_data = {
            'title': 'New file',
            'slug': 'new-file',
            'file_field': file_upload,
            'action-publish': "Publish",
        }
        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.file_page.id]), post_data)

        # Should be redirected to explorer
        self.assertRedirects(response, reverse('wagtailadmin_explore', args=[self.root_page.id]))

        # Check the new file exists
        file_page = FilePage.objects.get()

        self.assertEqual(file_page.file_field.name, file_upload.name)
        self.assertTrue(os.path.exists(file_page.file_field.path))
        self.assertEqual(file_page.file_field.read(), b"A new file")

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="174" endline="203" pcid="1675">
    def test_upload_file_draft(self):
        """
        Check that file uploads work when saving a draft
        """
        file_upload = ContentFile(b"A new file", name='draft-file.txt')
        post_data = {
            'title': 'New file',
            'slug': 'new-file',
            'file_field': file_upload,
        }
        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.file_page.id]), post_data)

        # Should be redirected to edit page
        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=[self.file_page.id]))

        # Check the file was uploaded
        file_path = os.path.join(settings.MEDIA_ROOT, file_upload.name)
        self.assertTrue(os.path.exists(file_path))
        with open(file_path, 'rb') as saved_file:
            self.assertEqual(saved_file.read(), b"A new file")

        # Publish the draft just created
        FilePage.objects.get().get_latest_revision().publish()

        # Get the file page, check the file is set
        file_page = FilePage.objects.get()
        self.assertEqual(file_page.file_field.name, file_upload.name)
        self.assertTrue(os.path.exists(file_page.file_field.path))
        self.assertEqual(file_page.file_field.read(), b"A new file")

</source>
</class>

<class classid="68" nclones="10" nlines="12" similarity="70">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="302" endline="320" pcid="1680">
    def test_edit_scheduled_go_live_before_expiry(self):
        post_data = {
            'title': "I've been edited!",
            'content': "Some content",
            'slug': 'hello-world',
            'go_live_at': submittable_timestamp(timezone.now() + datetime.timedelta(days=2)),
            'expire_at': submittable_timestamp(timezone.now() + datetime.timedelta(days=1)),
        }
        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)

        self.assertEqual(response.status_code, 200)

        # Check that a form error was raised
        self.assertFormError(response, 'form', 'go_live_at', "Go live date/time must be before expiry date/time")
        self.assertFormError(response, 'form', 'expire_at', "Go live date/time must be before expiry date/time")

        # form should be marked as having unsaved changes for the purposes of the dirty-forms warning
        self.assertContains(response, "alwaysDirty: true")

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_create_page.py" startline="330" endline="350" pcid="1802">
    def test_create_simplepage_scheduled_go_live_before_expiry(self):
        post_data = {
            'title': "New page!",
            'content': "Some content",
            'slug': 'hello-world',
            'go_live_at': submittable_timestamp(timezone.now() + datetime.timedelta(days=2)),
            'expire_at': submittable_timestamp(timezone.now() + datetime.timedelta(days=1)),
        }
        response = self.client.post(
            reverse('wagtailadmin_pages:add', args=('tests', 'simplepage', self.root_page.id)), post_data
        )

        self.assertEqual(response.status_code, 200)

        # Check that a form error was raised
        self.assertFormError(response, 'form', 'go_live_at', "Go live date/time must be before expiry date/time")
        self.assertFormError(response, 'form', 'expire_at', "Go live date/time must be before expiry date/time")

        # form should be marked as having unsaved changes for the purposes of the dirty-forms warning
        self.assertContains(response, "alwaysDirty: true")

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="321" endline="337" pcid="1681">
    def test_edit_scheduled_expire_in_the_past(self):
        post_data = {
            'title': "I've been edited!",
            'content': "Some content",
            'slug': 'hello-world',
            'expire_at': submittable_timestamp(timezone.now() + datetime.timedelta(days=-1)),
        }
        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)

        self.assertEqual(response.status_code, 200)

        # Check that a form error was raised
        self.assertFormError(response, 'form', 'expire_at', "Expiry date/time must be in the future")

        # form should be marked as having unsaved changes for the purposes of the dirty-forms warning
        self.assertContains(response, "alwaysDirty: true")

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_create_page.py" startline="469" endline="495" pcid="1807">
    def test_create_simplepage_post_existing_slug(self):
        # This tests the existing slug checking on page save

        # Create a page
        self.child_page = SimplePage(title="Hello world!", slug="hello-world", content="hello")
        self.root_page.add_child(instance=self.child_page)

        # Attempt to create a new one with the same slug
        post_data = {
            'title': "New page!",
            'content': "Some content",
            'slug': 'hello-world',
            'action-publish': "Publish",
        }
        response = self.client.post(
            reverse('wagtailadmin_pages:add', args=('tests', 'simplepage', self.root_page.id)), post_data
        )

        # Should not be redirected (as the save should fail)
        self.assertEqual(response.status_code, 200)

        # Check that a form error was raised
        self.assertFormError(response, 'form', 'slug', "This slug is already in use")

        # form should be marked as having unsaved changes for the purposes of the dirty-forms warning
        self.assertContains(response, "alwaysDirty: true")

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_create_page.py" startline="351" endline="369" pcid="1803">
    def test_create_simplepage_scheduled_expire_in_the_past(self):
        post_data = {
            'title': "New page!",
            'content': "Some content",
            'slug': 'hello-world',
            'expire_at': submittable_timestamp(timezone.now() + datetime.timedelta(days=-1)),
        }
        response = self.client.post(
            reverse('wagtailadmin_pages:add', args=('tests', 'simplepage', self.root_page.id)), post_data
        )

        self.assertEqual(response.status_code, 200)

        # Check that a form error was raised
        self.assertFormError(response, 'form', 'expire_at', "Expiry date/time must be in the future")

        # form should be marked as having unsaved changes for the purposes of the dirty-forms warning
        self.assertContains(response, "alwaysDirty: true")

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_privacy.py" startline="227" endline="245" pcid="2581">
    def test_unset_group_restriction(self):
        """
        This tests that removing a groups restriction using the set_privacy view works
        """
        post_data = {
            'restriction_type': 'none',
            'password': '',
            'groups': [],
        }
        response = self.client.post(reverse('wagtailadmin_pages:set_privacy', args=(self.private_page.id, )), post_data)

        # Check response
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, '"is_public": true')

        # Check that the page restriction has been deleted
        self.assertFalse(PageViewRestriction.objects.filter(page=self.private_page).exists())


</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="666" endline="686" pcid="1689">
    def test_page_edit_post_existing_slug(self):
        # This tests the existing slug checking on page edit

        # Create a page
        self.child_page = SimplePage(title="Hello world 2", slug="hello-world2", content="hello")
        self.root_page.add_child(instance=self.child_page)

        # Attempt to change the slug to one that's already in use
        post_data = {
            'title': "Hello world 2",
            'slug': 'hello-world',
            'action-submit': "Submit",
        }
        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)

        # Should not be redirected (as the save should fail)
        self.assertEqual(response.status_code, 200)

        # Check that a form error was raised
        self.assertFormError(response, 'form', 'slug', "This slug is already in use")

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_create_page.py" startline="595" endline="612" pcid="1815">
    def test_long_slug(self):
        post_data = {
            'title': "Hello world",
            'content': "Some content",
            'slug': 'hello-world-hello-world-hello-world-hello-world-hello-world-hello-world-'
                    'hello-world-hello-world-hello-world-hello-world-hello-world-hello-world-'
                    'hello-world-hello-world-hello-world-hello-world-hello-world-hello-world-'
                    'hello-world-hello-world-hello-world-hello-world-hello-world-hello-world',
            'action-submit': "Submit",
        }
        response = self.client.post(
            reverse('wagtailadmin_pages:add', args=('tests', 'simplepage', self.root_page.id)), post_data
        )

        # Check that a form error was raised
        self.assertEqual(response.status_code, 200)
        self.assertFormError(response, 'form', 'slug', "Ensure this value has at most 255 characters (it has 287).")

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_create_page.py" startline="533" endline="546" pcid="1811">
    def test_whitespace_titles(self):
        post_data = {
            'title': " ",  # Single space on purpose
            'content': "Some content",
            'slug': 'hello-world',
            'action-submit': "Submit",
        }
        response = self.client.post(
            reverse('wagtailadmin_pages:add', args=('tests', 'simplepage', self.root_page.id)), post_data
        )

        # Check that a form error was raised
        self.assertFormError(response, 'form', 'title', "This field is required.")

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_privacy.py" startline="143" endline="161" pcid="2577">
    def test_unset_password_restriction(self):
        """
        This tests that removing a password restriction using the set_privacy view works
        """
        post_data = {
            'restriction_type': 'none',
            'password': '',
            'groups': [],
        }
        response = self.client.post(
            reverse('wagtailadmin_pages:set_privacy', args=(self.private_page.id, )), post_data)

        # Check response
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, '"is_public": true')

        # Check that the page restriction has been deleted
        self.assertFalse(PageViewRestriction.objects.filter(page=self.private_page).exists())

</source>
</class>

<class classid="69" nclones="2" nlines="27" similarity="70">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="429" endline="467" pcid="1684">
    def test_edit_post_publish_scheduled_unpublished_page(self):
        # Unpublish the page
        self.child_page.live = False
        self.child_page.save()

        go_live_at = timezone.now() + datetime.timedelta(days=1)
        expire_at = timezone.now() + datetime.timedelta(days=2)
        post_data = {
            'title': "I've been edited!",
            'content': "Some content",
            'slug': 'hello-world',
            'action-publish': "Publish",
            'go_live_at': submittable_timestamp(go_live_at),
            'expire_at': submittable_timestamp(expire_at),
        }
        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)

        # Should be redirected to explorer page
        self.assertEqual(response.status_code, 302)

        child_page_new = SimplePage.objects.get(id=self.child_page.id)

        # The page should not be live anymore
        self.assertFalse(child_page_new.live)

        # Instead a revision with approved_go_live_at should now exist
        self.assertTrue(
            PageRevision.objects.filter(page=child_page_new).exclude(approved_go_live_at__isnull=True).exists()
        )

        # The page SHOULD have the "has_unpublished_changes" flag set,
        # because the changes are not visible as a live page yet
        self.assertTrue(
            child_page_new.has_unpublished_changes,
            "A page scheduled for future publishing should have has_unpublished_changes=True"
        )

        self.assertEqual(child_page_new.status_string, "scheduled")

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="525" endline="576" pcid="1686">
    def test_edit_post_publish_scheduled_published_page(self):
        # Page is live
        self.child_page.live = True
        self.child_page.save()

        live_revision = self.child_page.live_revision
        original_title = self.child_page.title

        go_live_at = timezone.now() + datetime.timedelta(days=1)
        expire_at = timezone.now() + datetime.timedelta(days=2)
        post_data = {
            'title': "I've been edited!",
            'content': "Some content",
            'slug': 'hello-world',
            'action-publish': "Publish",
            'go_live_at': submittable_timestamp(go_live_at),
            'expire_at': submittable_timestamp(expire_at),
        }
        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)

        # Should be redirected to explorer page
        self.assertEqual(response.status_code, 302)

        child_page_new = SimplePage.objects.get(id=self.child_page.id)

        # The page should still be live
        self.assertTrue(child_page_new.live)

        self.assertEqual(child_page_new.status_string, "live + scheduled")

        # Instead a revision with approved_go_live_at should now exist
        self.assertTrue(
            PageRevision.objects.filter(page=child_page_new).exclude(approved_go_live_at__isnull=True).exists()
        )

        # The page SHOULD have the "has_unpublished_changes" flag set,
        # because the changes are not visible as a live page yet
        self.assertTrue(
            child_page_new.has_unpublished_changes,
            "A page scheduled for future publishing should have has_unpublished_changes=True"
        )

        self.assertNotEqual(
            child_page_new.get_latest_revision(), live_revision,
            "A page scheduled for future publishing should have a new revision, that is not the live revision"
        )

        self.assertEqual(
            child_page_new.title, original_title,
            "A live page with scheduled revisions should still have original content"
        )

</source>
</class>

<class classid="70" nclones="2" nlines="37" similarity="81">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="468" endline="524" pcid="1685">
    def test_edit_post_publish_now_an_already_scheduled_unpublished_page(self):
        # Unpublish the page
        self.child_page.live = False
        self.child_page.save()

        # First let's publish a page with a go_live_at in the future
        go_live_at = timezone.now() + datetime.timedelta(days=1)
        expire_at = timezone.now() + datetime.timedelta(days=2)
        post_data = {
            'title': "I've been edited!",
            'content': "Some content",
            'slug': 'hello-world',
            'action-publish': "Publish",
            'go_live_at': submittable_timestamp(go_live_at),
            'expire_at': submittable_timestamp(expire_at),
        }
        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)

        # Should be redirected to edit page
        self.assertEqual(response.status_code, 302)

        child_page_new = SimplePage.objects.get(id=self.child_page.id)

        # The page should not be live
        self.assertFalse(child_page_new.live)

        self.assertEqual(child_page_new.status_string, "scheduled")

        # Instead a revision with approved_go_live_at should now exist
        self.assertTrue(
            PageRevision.objects.filter(page=child_page_new).exclude(approved_go_live_at__isnull=True).exists()
        )

        # Now, let's edit it and publish it right now
        go_live_at = timezone.now()
        post_data = {
            'title': "I've been edited!",
            'content': "Some content",
            'slug': 'hello-world',
            'action-publish': "Publish",
            'go_live_at': "",
        }
        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)

        # Should be redirected to edit page
        self.assertEqual(response.status_code, 302)

        child_page_new = SimplePage.objects.get(id=self.child_page.id)

        # The page should be live now
        self.assertTrue(child_page_new.live)

        # And a revision with approved_go_live_at should not exist
        self.assertFalse(
            PageRevision.objects.filter(page=child_page_new).exclude(approved_go_live_at__isnull=True).exists()
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="577" endline="642" pcid="1687">
    def test_edit_post_publish_now_an_already_scheduled_published_page(self):
        # Unpublish the page
        self.child_page.live = True
        self.child_page.save()

        original_title = self.child_page.title
        # First let's publish a page with a go_live_at in the future
        go_live_at = timezone.now() + datetime.timedelta(days=1)
        expire_at = timezone.now() + datetime.timedelta(days=2)
        post_data = {
            'title': "I've been edited!",
            'content': "Some content",
            'slug': 'hello-world',
            'action-publish': "Publish",
            'go_live_at': submittable_timestamp(go_live_at),
            'expire_at': submittable_timestamp(expire_at),
        }
        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)

        # Should be redirected to edit page
        self.assertEqual(response.status_code, 302)

        child_page_new = SimplePage.objects.get(id=self.child_page.id)

        # The page should still be live
        self.assertTrue(child_page_new.live)

        # Instead a revision with approved_go_live_at should now exist
        self.assertTrue(
            PageRevision.objects.filter(page=child_page_new).exclude(approved_go_live_at__isnull=True).exists()
        )

        self.assertEqual(
            child_page_new.title, original_title,
            "A live page with scheduled revisions should still have original content"
        )

        # Now, let's edit it and publish it right now
        go_live_at = timezone.now()
        post_data = {
            'title': "I've been edited!",
            'content': "Some content",
            'slug': 'hello-world',
            'action-publish': "Publish",
            'go_live_at': "",
        }
        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)

        # Should be redirected to edit page
        self.assertEqual(response.status_code, 302)

        child_page_new = SimplePage.objects.get(id=self.child_page.id)

        # The page should be live now
        self.assertTrue(child_page_new.live)

        # And a revision with approved_go_live_at should not exist
        self.assertFalse(
            PageRevision.objects.filter(page=child_page_new).exclude(approved_go_live_at__isnull=True).exists()
        )

        self.assertEqual(
            child_page_new.title, post_data['title'],
            "A published page should have the new title"
        )

</source>
</class>

<class classid="71" nclones="3" nlines="17" similarity="72">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="687" endline="708" pcid="1690">
    def test_preview_on_edit(self):
        post_data = {
            'title': "I've been edited!",
            'content': "Some content",
            'slug': 'hello-world',
            'action-submit': "Submit",
        }
        preview_url = reverse('wagtailadmin_pages:preview_on_edit',
                              args=(self.child_page.id,))
        response = self.client.post(preview_url, post_data)

        # Check the JSON response
        self.assertEqual(response.status_code, 200)
        self.assertJSONEqual(response.content.decode(), {'is_valid': True})

        response = self.client.get(preview_url)

        # Check the HTML response
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'tests/simple_page.html')
        self.assertContains(response, "I&#39;ve been edited!", html=True)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_create_page.py" startline="506" endline="532" pcid="1810">
    def test_preview_on_create(self):
        post_data = {
            'title': "New page!",
            'content': "Some content",
            'slug': 'hello-world',
            'action-submit': "Submit",
        }
        preview_url = reverse('wagtailadmin_pages:preview_on_add',
                              args=('tests', 'simplepage', self.root_page.id))
        response = self.client.post(preview_url, post_data)

        # Check the JSON response
        self.assertEqual(response.status_code, 200)
        self.assertJSONEqual(response.content.decode(), {'is_valid': True})

        response = self.client.get(preview_url)

        # Check the HTML response
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'tests/simple_page.html')
        self.assertContains(response, "New page!")

        # Check that the treebeard attributes were set correctly on the page object
        self.assertEqual(response.context['self'].depth, self.root_page.depth + 1)
        self.assertTrue(response.context['self'].path.startswith(self.root_page.path))
        self.assertEqual(response.context['self'].get_parent(), self.root_page)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="762" endline="786" pcid="1693">
    def test_preview_uses_correct_site(self):
        # create a Site record for the child page
        Site.objects.create(hostname='childpage.example.com', root_page=self.child_page)

        post_data = {
            'title': "I've been edited!",
            'content': "Some content",
            'slug': 'hello-world',
            'action-submit': "Submit",
        }
        preview_url = reverse('wagtailadmin_pages:preview_on_edit',
                              args=(self.child_page.id,))
        response = self.client.post(preview_url, post_data)

        # Check the JSON response
        self.assertEqual(response.status_code, 200)
        self.assertJSONEqual(response.content.decode(), {'is_valid': True})

        response = self.client.get(preview_url)

        # Check that the correct site object has been selected by the site middleware
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'tests/simple_page.html')
        self.assertEqual(Site.find_for_request(response.context['request']).hostname, 'childpage.example.com')

</source>
</class>

<class classid="72" nclones="3" nlines="13" similarity="71">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="709" endline="731" pcid="1691">
    def test_preview_on_edit_no_session_key(self):
        preview_url = reverse('wagtailadmin_pages:preview_on_edit',
                              args=(self.child_page.id,))

        # get() without corresponding post(), key not set.
        response = self.client.get(preview_url)

        # Check the HTML response
        self.assertEqual(response.status_code, 200)

        # We should have an error page because we are unable to
        # preview; the page key was not in the session.
        self.assertContains(
            response,
            "<title>Wagtail - Preview error</title>",
            html=True
        )
        self.assertContains(
            response,
            "<h1>Preview error</h1>",
            html=True
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_revisions.py" startline="254" endline="269" pcid="1874">
    def test_comparison_as_superuser(self):
        self.login()
        response = self.client.get(self.compare_url)
        self.assertEqual(response.status_code, 200)

        self.assertContains(
            response,
            'InnocentCorp is the leading supplier of <span class="deletion">door hinges</span><span class="addition">rubber sprockets</span>',
            html=True
        )
        self.assertContains(
            response,
            'for <span class="deletion">flying saucers</span><span class="addition">fake moon landings</span>',
            html=True
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_revisions.py" startline="270" endline="288" pcid="1875">
    def test_comparison_as_ordinary_user(self):
        user = self.create_user(username='editor', password='password')
        user.groups.add(Group.objects.get(name='Site-wide editors'))
        self.login(username='editor', password='password')

        response = self.client.get(self.compare_url)
        self.assertEqual(response.status_code, 200)

        self.assertContains(
            response,
            'InnocentCorp is the leading supplier of <span class="deletion">door hinges</span><span class="addition">rubber sprockets</span>',
            html=True
        )
        self.assertNotContains(
            response,
            'moon landings',
        )


</source>
</class>

<class classid="73" nclones="2" nlines="12" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="814" endline="836" pcid="1696">
    def test_editor_page_shows_live_url_in_status_when_draft_edits_exist(self):
        # If a page has draft edits (ie. page has unpublished changes)
        # that affect the URL (eg. slug) we  should still ensure the
        # status button at the top of the page links to the live URL

        self.child_page.content = "Some content with a draft edit"
        self.child_page.slug = "revised-slug-in-draft-only"  # live version contains 'hello-world'
        self.child_page.save_revision()

        response = self.client.get(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )))

        link_to_live = '<a href="/hello-world/" target="_blank" rel="noopener noreferrer" class="button button-nostroke button--live" title="Visit the live page">\n' \
                       '<svg class="icon icon-link-external initial" aria-hidden="true" focusable="false"><use href="#icon-link-external"></use></svg>\n\n        ' \
                       'Live\n        <span class="privacy-indicator-tag u-hidden" aria-hidden="true" title="This page is live but only available to certain users">(restricted)</span>'
        input_field_for_draft_slug = '<input type="text" name="slug" value="revised-slug-in-draft-only" id="id_slug" maxlength="255" required />'
        input_field_for_live_slug = '<input type="text" name="slug" value="hello-world" id="id_slug" maxlength="255" required />'

        # Status Link should be the live page (not revision)
        self.assertContains(response, link_to_live, html=True)
        self.assertNotContains(response, 'href="/revised-slug-in-draft-only/"', html=True)

        # Editing input for slug should be the draft revision
        self.assertContains(response, input_field_for_draft_slug, html=True)
</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="837" endline="858" pcid="1697">
        self.assertNotContains(response, input_field_for_live_slug, html=True)

    def test_editor_page_shows_custom_live_url_in_status_when_draft_edits_exist(self):
        # When showing a live URL in the status button that differs from the draft one,
        # ensure that we pick up any custom URL logic defined on the specific page model

        self.single_event_page.location = "The other side of Mars"
        self.single_event_page.slug = "revised-slug-in-draft-only"  # live version contains 'hello-world'
        self.single_event_page.save_revision()

        response = self.client.get(reverse('wagtailadmin_pages:edit', args=(self.single_event_page.id, )))

        link_to_live = '<a href="/mars-landing/pointless-suffix/" target="_blank" rel="noopener noreferrer" class="button button-nostroke button--live" title="Visit the live page">\n' \
                       '<svg class="icon icon-link-external initial" aria-hidden="true" focusable="false"><use href="#icon-link-external"></use></svg>\n\n        ' \
                       'Live\n        <span class="privacy-indicator-tag u-hidden" aria-hidden="true" title="This page is live but only available to certain users">(restricted)</span>'
        input_field_for_draft_slug = '<input type="text" name="slug" value="revised-slug-in-draft-only" id="id_slug" maxlength="255" required />'
        input_field_for_live_slug = '<input type="text" name="slug" value="mars-landing" id="id_slug" maxlength="255" required />'

        # Status Link should be the live page (not revision)
        self.assertContains(response, link_to_live, html=True)
        self.assertNotContains(response, 'href="/revised-slug-in-draft-only/pointless-suffix/"', html=True)

</source>
</class>

<class classid="74" nclones="2" nlines="13" similarity="83">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="1029" endline="1055" pcid="1712">
        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[alias_page.id]), post_data)

        self.assertEqual(response.status_code, 405)

    def test_edit_after_change_language_code(self):
        """
        Verify that changing LANGUAGE_CODE with no corresponding database change does not break editing
        """
        # Add a draft revision
        self.child_page.title = "Hello world updated"
        self.child_page.save_revision()

        # Hack the Locale model to simulate a page tree that was created with LANGUAGE_CODE = 'de'
        # (which is not a valid content language under the current configuration)
        Locale.objects.update(language_code='de')

        # Tests that the edit page loads
        response = self.client.get(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )))
        self.assertEqual(response.status_code, 200)

        # Tests simple editing
        post_data = {
            'title': "I've been edited!",
            'content': "Some content",
            'slug': 'hello-world',
        }
        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)
</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="1056" endline="1081" pcid="1713">

        # Should be redirected to edit page
        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )))

    def test_edit_after_change_language_code_without_revisions(self):
        """
        Verify that changing LANGUAGE_CODE with no corresponding database change does not break editing
        """
        # Hack the Locale model to simulate a page tree that was created with LANGUAGE_CODE = 'de'
        # (which is not a valid content language under the current configuration)
        Locale.objects.update(language_code='de')

        PageRevision.objects.filter(page_id=self.child_page.id).delete()

        # Tests that the edit page loads
        response = self.client.get(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )))
        self.assertEqual(response.status_code, 200)

        # Tests simple editing
        post_data = {
            'title': "I've been edited!",
            'content': "Some content",
            'slug': 'hello-world',
        }
        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)

</source>
</class>

<class classid="75" nclones="9" nlines="34" similarity="70">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="1114" endline="1159" pcid="1717">

        self.assertEqual(response.status_code, 200)
        self.check_order(response, ['1234567', '7654321', 'abcdefg'])

    def test_reorder(self):
        post_data = {
            'title': "Event page",
            'slug': 'event-page',

            'date_from': '01/01/2014',
            'cost': '$10',
            'audience': 'public',
            'location': 'somewhere',

            'related_links-INITIAL_FORMS': 0,
            'related_links-MAX_NUM_FORMS': 1000,
            'related_links-TOTAL_FORMS': 0,

            'speakers-INITIAL_FORMS': 0,
            'speakers-MAX_NUM_FORMS': 1000,
            'speakers-TOTAL_FORMS': 0,

            'head_counts-INITIAL_FORMS': 0,
            'head_counts-MAX_NUM_FORMS': 1000,
            'head_counts-TOTAL_FORMS': 0,

            'carousel_items-INITIAL_FORMS': 3,
            'carousel_items-MAX_NUM_FORMS': 1000,
            'carousel_items-TOTAL_FORMS': 3,
            'carousel_items-0-id': self.event_page.carousel_items.all()[0].id,
            'carousel_items-0-caption': self.event_page.carousel_items.all()[0].caption,
            'carousel_items-0-ORDER': 2,
            'carousel_items-1-id': self.event_page.carousel_items.all()[1].id,
            'carousel_items-1-caption': self.event_page.carousel_items.all()[1].caption,
            'carousel_items-1-ORDER': 3,
            'carousel_items-2-id': self.event_page.carousel_items.all()[2].id,
            'carousel_items-2-caption': self.event_page.carousel_items.all()[2].caption,
            'carousel_items-2-ORDER': 1,
        }
        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.event_page.id, )), post_data)

        # Should be redirected back to same page
        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=(self.event_page.id, )))

        # Check order
        response = self.client.get(reverse('wagtailadmin_pages:edit', args=(self.event_page.id, )))
</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="1590" endline="1626" pcid="1741">

        self.assertIn(self.holiday_category, created_revision.categories.all())
        self.assertIn(self.men_with_beards_category, created_revision.categories.all())

    def test_create_and_publish(self):
        post_data = {
            'action-publish': "Publish",
            'title': "Presidents' Day",
            'date_from': "2017-02-20",
            'slug': "presidents-day",
            'audience': "public",
            'location': "America",
            'cost': "$1",
            'carousel_items-TOTAL_FORMS': 0,
            'carousel_items-INITIAL_FORMS': 0,
            'carousel_items-MIN_NUM_FORMS': 0,
            'carousel_items-MAX_NUM_FORMS': 0,
            'speakers-TOTAL_FORMS': 0,
            'speakers-INITIAL_FORMS': 0,
            'speakers-MIN_NUM_FORMS': 0,
            'speakers-MAX_NUM_FORMS': 0,
            'related_links-TOTAL_FORMS': 0,
            'related_links-INITIAL_FORMS': 0,
            'related_links-MIN_NUM_FORMS': 0,
            'related_links-MAX_NUM_FORMS': 0,
            'head_counts-TOTAL_FORMS': 0,
            'head_counts-INITIAL_FORMS': 0,
            'head_counts-MIN_NUM_FORMS': 0,
            'head_counts-MAX_NUM_FORMS': 0,
            'categories': [self.holiday_category.id, self.men_with_beards_category.id]
        }
        response = self.client.post(
            reverse('wagtailadmin_pages:add', args=('tests', 'eventpage', self.events_index.id)),
            post_data
        )
        self.assertRedirects(response, reverse('wagtailadmin_explore', args=(self.events_index.id, )))

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="1627" endline="1666" pcid="1742">
        created_page = EventPage.objects.get(url_path='/home/events/presidents-day/')
        self.assertIn(self.holiday_category, created_page.categories.all())
        self.assertIn(self.men_with_beards_category, created_page.categories.all())

    def test_edit_and_save(self):
        post_data = {
            'title': "Christmas",
            'date_from': "2017-12-25",
            'slug': "christmas",
            'audience': "public",
            'location': "The North Pole",
            'cost': "Free",
            'carousel_items-TOTAL_FORMS': 0,
            'carousel_items-INITIAL_FORMS': 0,
            'carousel_items-MIN_NUM_FORMS': 0,
            'carousel_items-MAX_NUM_FORMS': 0,
            'speakers-TOTAL_FORMS': 0,
            'speakers-INITIAL_FORMS': 0,
            'speakers-MIN_NUM_FORMS': 0,
            'speakers-MAX_NUM_FORMS': 0,
            'related_links-TOTAL_FORMS': 0,
            'related_links-INITIAL_FORMS': 0,
            'related_links-MIN_NUM_FORMS': 0,
            'related_links-MAX_NUM_FORMS': 0,
            'head_counts-TOTAL_FORMS': 0,
            'head_counts-INITIAL_FORMS': 0,
            'head_counts-MIN_NUM_FORMS': 0,
            'head_counts-MAX_NUM_FORMS': 0,
            'categories': [self.holiday_category.id, self.men_with_beards_category.id]
        }
        response = self.client.post(
            reverse('wagtailadmin_pages:edit', args=(self.christmas_page.id, )),
            post_data
        )
        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=(self.christmas_page.id, )))
        updated_page = EventPage.objects.get(id=self.christmas_page.id)
        created_revision = updated_page.get_latest_revision_as_page()

        self.assertIn(self.holiday_category, created_revision.categories.all())
        self.assertIn(self.men_with_beards_category, created_revision.categories.all())
</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="1786" endline="1831" pcid="1747">

        self.assertContains(response, "The page could not be saved due to validation errors")
        self.assertContains(response, "<li>The end date must be after the start date</li>", count=1)

    def test_field_and_non_field_error(self):
        """
        If both field and non-field errors exist, all errors should be shown in the header message
        with appropriate context to identify the field; and field errors should also be shown
        against the relevant fields.
        """
        post_data = {
            'title': "",
            'date_from': "2017-12-25",
            'date_to': "2017-12-24",
            'slug': "christmas",
            'audience': "public",
            'location': "The North Pole",
            'cost': "Free",
            'carousel_items-TOTAL_FORMS': 0,
            'carousel_items-INITIAL_FORMS': 0,
            'carousel_items-MIN_NUM_FORMS': 0,
            'carousel_items-MAX_NUM_FORMS': 0,
            'speakers-TOTAL_FORMS': 0,
            'speakers-INITIAL_FORMS': 0,
            'speakers-MIN_NUM_FORMS': 0,
            'speakers-MAX_NUM_FORMS': 0,
            'related_links-TOTAL_FORMS': 0,
            'related_links-INITIAL_FORMS': 0,
            'related_links-MIN_NUM_FORMS': 0,
            'related_links-MAX_NUM_FORMS': 0,
            'head_counts-TOTAL_FORMS': 0,
            'head_counts-INITIAL_FORMS': 0,
            'head_counts-MIN_NUM_FORMS': 0,
            'head_counts-MAX_NUM_FORMS': 0,
        }
        response = self.client.post(
            reverse('wagtailadmin_pages:edit', args=(self.christmas_page.id, )),
            post_data
        )
        self.assertEqual(response.status_code, 200)

        self.assertContains(response, "The page could not be saved due to validation errors")
        self.assertContains(response, "<li>The end date must be after the start date</li>", count=1)

        # Error on title shown against the title field
        self.assertContains(response, """<p class="error-message"><span>This field is required.</span></p>""", count=1, html=True)
</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="1667" endline="1704" pcid="1743">

        # no change to live page record yet
        self.assertEqual(0, updated_page.categories.count())

    def test_edit_and_publish(self):
        post_data = {
            'action-publish': "Publish",
            'title': "Christmas",
            'date_from': "2017-12-25",
            'slug': "christmas",
            'audience': "public",
            'location': "The North Pole",
            'cost': "Free",
            'carousel_items-TOTAL_FORMS': 0,
            'carousel_items-INITIAL_FORMS': 0,
            'carousel_items-MIN_NUM_FORMS': 0,
            'carousel_items-MAX_NUM_FORMS': 0,
            'speakers-TOTAL_FORMS': 0,
            'speakers-INITIAL_FORMS': 0,
            'speakers-MIN_NUM_FORMS': 0,
            'speakers-MAX_NUM_FORMS': 0,
            'related_links-TOTAL_FORMS': 0,
            'related_links-INITIAL_FORMS': 0,
            'related_links-MIN_NUM_FORMS': 0,
            'related_links-MAX_NUM_FORMS': 0,
            'head_counts-TOTAL_FORMS': 0,
            'head_counts-INITIAL_FORMS': 0,
            'head_counts-MIN_NUM_FORMS': 0,
            'head_counts-MAX_NUM_FORMS': 0,
            'categories': [self.holiday_category.id, self.men_with_beards_category.id]
        }
        response = self.client.post(
            reverse('wagtailadmin_pages:edit', args=(self.christmas_page.id, )),
            post_data
        )
        self.assertRedirects(response, reverse('wagtailadmin_explore', args=(self.events_index.id, )))
        updated_page = EventPage.objects.get(id=self.christmas_page.id)
        self.assertEqual(2, updated_page.categories.count())
</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="1160" endline="1200" pcid="1718">

        self.assertEqual(response.status_code, 200)
        self.check_order(response, ['abcdefg', '1234567', '7654321'])

    def test_reorder_with_validation_error(self):
        post_data = {
            'title': "",  # Validation error
            'slug': 'event-page',

            'date_from': '01/01/2014',
            'cost': '$10',
            'audience': 'public',
            'location': 'somewhere',

            'related_links-INITIAL_FORMS': 0,
            'related_links-MAX_NUM_FORMS': 1000,
            'related_links-TOTAL_FORMS': 0,

            'speakers-INITIAL_FORMS': 0,
            'speakers-MAX_NUM_FORMS': 1000,
            'speakers-TOTAL_FORMS': 0,

            'head_counts-INITIAL_FORMS': 0,
            'head_counts-MAX_NUM_FORMS': 1000,
            'head_counts-TOTAL_FORMS': 0,

            'carousel_items-INITIAL_FORMS': 3,
            'carousel_items-MAX_NUM_FORMS': 1000,
            'carousel_items-TOTAL_FORMS': 3,
            'carousel_items-0-id': self.event_page.carousel_items.all()[0].id,
            'carousel_items-0-caption': self.event_page.carousel_items.all()[0].caption,
            'carousel_items-0-ORDER': 2,
            'carousel_items-1-id': self.event_page.carousel_items.all()[1].id,
            'carousel_items-1-caption': self.event_page.carousel_items.all()[1].caption,
            'carousel_items-1-ORDER': 3,
            'carousel_items-2-id': self.event_page.carousel_items.all()[2].id,
            'carousel_items-2-caption': self.event_page.carousel_items.all()[2].caption,
            'carousel_items-2-ORDER': 1,
        }
        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.event_page.id, )), post_data)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="1750" endline="1785" pcid="1746">
        # the error should only appear once: against the field, not in the header message
        self.assertContains(response, """<p class="error-message"><span>This field is required.</span></p>""", count=1, html=True)
        self.assertContains(response, "This field is required", count=1)

    def test_non_field_error(self):
        """Non-field errors should be shown in the header message"""
        post_data = {
            'title': "Christmas",
            'date_from': "2017-12-25",
            'date_to': "2017-12-24",
            'slug': "christmas",
            'audience': "public",
            'location': "The North Pole",
            'cost': "Free",
            'carousel_items-TOTAL_FORMS': 0,
            'carousel_items-INITIAL_FORMS': 0,
            'carousel_items-MIN_NUM_FORMS': 0,
            'carousel_items-MAX_NUM_FORMS': 0,
            'speakers-TOTAL_FORMS': 0,
            'speakers-INITIAL_FORMS': 0,
            'speakers-MIN_NUM_FORMS': 0,
            'speakers-MAX_NUM_FORMS': 0,
            'related_links-TOTAL_FORMS': 0,
            'related_links-INITIAL_FORMS': 0,
            'related_links-MIN_NUM_FORMS': 0,
            'related_links-MAX_NUM_FORMS': 0,
            'head_counts-TOTAL_FORMS': 0,
            'head_counts-INITIAL_FORMS': 0,
            'head_counts-MIN_NUM_FORMS': 0,
            'head_counts-MAX_NUM_FORMS': 0,
        }
        response = self.client.post(
            reverse('wagtailadmin_pages:edit', args=(self.christmas_page.id, )),
            post_data
        )
        self.assertEqual(response.status_code, 200)
</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="1713" endline="1749" pcid="1745">
        self.events_index = Page.objects.get(url_path='/home/events/')
        self.christmas_page = Page.objects.get(url_path='/home/events/christmas/')
        self.user = self.login()

    def test_field_error(self):
        """Field errors should be shown against the relevant fields, not in the header message"""
        post_data = {
            'title': "",
            'date_from': "2017-12-25",
            'slug': "christmas",
            'audience': "public",
            'location': "The North Pole",
            'cost': "Free",
            'carousel_items-TOTAL_FORMS': 0,
            'carousel_items-INITIAL_FORMS': 0,
            'carousel_items-MIN_NUM_FORMS': 0,
            'carousel_items-MAX_NUM_FORMS': 0,
            'speakers-TOTAL_FORMS': 0,
            'speakers-INITIAL_FORMS': 0,
            'speakers-MIN_NUM_FORMS': 0,
            'speakers-MAX_NUM_FORMS': 0,
            'related_links-TOTAL_FORMS': 0,
            'related_links-INITIAL_FORMS': 0,
            'related_links-MIN_NUM_FORMS': 0,
            'related_links-MAX_NUM_FORMS': 0,
            'head_counts-TOTAL_FORMS': 0,
            'head_counts-INITIAL_FORMS': 0,
            'head_counts-MIN_NUM_FORMS': 0,
            'head_counts-MAX_NUM_FORMS': 0,
        }
        response = self.client.post(
            reverse('wagtailadmin_pages:edit', args=(self.christmas_page.id, )),
            post_data
        )
        self.assertEqual(response.status_code, 200)

        self.assertContains(response, "The page could not be saved due to validation errors")
</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="1553" endline="1589" pcid="1740">
        self.user = self.login()
        self.holiday_category = EventCategory.objects.create(name='Holiday')
        self.men_with_beards_category = EventCategory.objects.create(name='Men with beards')

    def test_create_and_save(self):
        post_data = {
            'title': "Presidents' Day",
            'date_from': "2017-02-20",
            'slug': "presidents-day",
            'audience': "public",
            'location': "America",
            'cost': "$1",
            'carousel_items-TOTAL_FORMS': 0,
            'carousel_items-INITIAL_FORMS': 0,
            'carousel_items-MIN_NUM_FORMS': 0,
            'carousel_items-MAX_NUM_FORMS': 0,
            'speakers-TOTAL_FORMS': 0,
            'speakers-INITIAL_FORMS': 0,
            'speakers-MIN_NUM_FORMS': 0,
            'speakers-MAX_NUM_FORMS': 0,
            'related_links-TOTAL_FORMS': 0,
            'related_links-INITIAL_FORMS': 0,
            'related_links-MIN_NUM_FORMS': 0,
            'related_links-MAX_NUM_FORMS': 0,
            'head_counts-TOTAL_FORMS': 0,
            'head_counts-INITIAL_FORMS': 0,
            'head_counts-MIN_NUM_FORMS': 0,
            'head_counts-MAX_NUM_FORMS': 0,
            'categories': [self.holiday_category.id, self.men_with_beards_category.id]
        }
        response = self.client.post(
            reverse('wagtailadmin_pages:add', args=('tests', 'eventpage', self.events_index.id)),
            post_data
        )
        created_page = EventPage.objects.get(url_path='/home/events/presidents-day/')
        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=(created_page.id, )))
        created_revision = created_page.get_latest_revision_as_page()
</source>
</class>

<class classid="76" nclones="4" nlines="16" similarity="73">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="1265" endline="1288" pcid="1722">
        # Response should include an advert_placements formset labelled Adverts
        self.assertContains(response, "Adverts")
        self.assertContains(response, "id_advert_placements-TOTAL_FORMS")

    def test_post_create_form(self):
        post_data = {
            'title': "New index!",
            'slug': 'new-index',
            'advert_placements-TOTAL_FORMS': '1',
            'advert_placements-INITIAL_FORMS': '0',
            'advert_placements-MAX_NUM_FORMS': '1000',
            'advert_placements-0-advert': '1',
            'advert_placements-0-colour': 'yellow',
            'advert_placements-0-id': '',
        }
        response = self.client.post(
            reverse('wagtailadmin_pages:add', args=('tests', 'standardindex', self.root_page.id)), post_data
        )

        # Find the page and check it
        page = Page.objects.get(path__startswith=self.root_page.path, slug='new-index').specific

        # Should be redirected to edit page
        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=(page.id, )))
</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="1289" endline="1309" pcid="1723">

        self.assertEqual(page.advert_placements.count(), 1)
        self.assertEqual(page.advert_placements.first().advert.text, 'test_advert')

    def test_post_create_form_with_validation_error_in_formset(self):
        post_data = {
            'title': "New index!",
            'slug': 'new-index',
            'advert_placements-TOTAL_FORMS': '1',
            'advert_placements-INITIAL_FORMS': '0',
            'advert_placements-MAX_NUM_FORMS': '1000',
            'advert_placements-0-advert': '1',
            'advert_placements-0-colour': '',  # should fail as colour is a required field
            'advert_placements-0-id': '',
        }
        response = self.client.post(
            reverse('wagtailadmin_pages:add', args=('tests', 'standardindex', self.root_page.id)), post_data
        )

        # Should remain on the edit page with a validation error
        self.assertEqual(response.status_code, 200)
</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_create_page.py" startline="991" endline="1010" pcid="1842">
    def test_page_edit_post_publish_url(self):
        # Post
        post_data = {
            'title': "Issue 2994 test",
            'slug': 'issue-2994-test',
            'body-count': '1',
            'body-0-deleted': '',
            'body-0-order': '0',
            'body-0-type': 'text',
            'body-0-value': 'hello world',
            'action-publish': "Publish",
        }
        self.client.post(
            reverse('wagtailadmin_pages:add', args=('tests', 'defaultstreampage', self.root_page.id)), post_data
        )
        new_page = DefaultStreamPage.objects.get(slug='issue-2994-test')
        self.assertEqual(1, len(new_page.body))
        self.assertEqual('hello world', new_page.body[0].value)


</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="1349" endline="1369" pcid="1726">
        self.assertEqual(page.advert_placements.count(), 2)
        self.assertEqual(page.advert_placements.all()[0].advert.text, 'test_advert')
        self.assertEqual(page.advert_placements.all()[1].advert.text, 'test_advert')

    def test_post_edit_form_with_validation_error_in_formset(self):
        post_data = {
            'title': "My lovely index",
            'slug': 'my-lovely-index',
            'advert_placements-TOTAL_FORMS': '1',
            'advert_placements-INITIAL_FORMS': '1',
            'advert_placements-MAX_NUM_FORMS': '1000',
            'advert_placements-0-advert': '1',
            'advert_placements-0-colour': '',
            'advert_placements-0-id': self.index_page.advert_placements.first().id,
            'action-publish': "Publish",
        }
        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.index_page.id, )), post_data)

        # Should remain on the edit page with a validation error
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, "This field is required.")
</source>
</class>

<class classid="77" nclones="2" nlines="18" similarity="77">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="1952" endline="1978" pcid="1754">

        edit_translation_url = reverse('wagtailadmin_pages:edit', args=[self.translated_christmas_page.id])
        self.assertNotContains(response, f'<a href="{edit_translation_url}" aria-label="French" class="u-link is-live">')

    def test_locale_dropdown_not_present_without_permission_to_edit(self):
        # Remove user's permissions to edit French tree
        en_events_index = Page.objects.get(url_path='/home/events/')
        group = Group.objects.get(name='Moderators')
        GroupPagePermission.objects.create(
            group=group,
            page=en_events_index,
            permission_type='edit',
        )
        self.user.is_superuser = False
        self.user.user_permissions.add(
            Permission.objects.get(content_type__app_label='wagtailadmin', codename='access_admin')
        )
        self.user.groups.add(group)
        self.user.save()

        # Locale indicator should exist, but the "French" option should be hidden
        response = self.client.get(
            reverse('wagtailadmin_pages:edit', args=[self.christmas_page.id])
        )

        self.assertContains(response, '<li class="header-meta--locale">')

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_create_page.py" startline="1118" endline="1143" pcid="1850">
    def test_locale_dropdown_not_present_without_permission_to_add(self):
        # Remove user's permissions to add in the French tree
        group = Group.objects.get(name='Moderators')
        GroupPagePermission.objects.create(
            group=group,
            page=self.events_page,
            permission_type='add',
        )
        self.user.is_superuser = False
        self.user.user_permissions.add(
            Permission.objects.get(content_type__app_label='wagtailadmin', codename='access_admin')
        )
        self.user.groups.add(group)
        self.user.save()

        # Locale indicator should exist, but the "French" option should be hidden
        response = self.client.get(
            reverse('wagtailadmin_pages:add', args=['tests', 'eventpage', self.events_page.id])
        )

        self.assertContains(response, '<li class="header-meta--locale">')

        add_translation_url = reverse('wagtailadmin_pages:add', args=['tests', 'eventpage', self.translated_events_page.id])
        self.assertNotContains(response, f'<a href="{add_translation_url}" aria-label="French" class="u-link is-live">')


</source>
</class>

<class classid="78" nclones="2" nlines="12" similarity="83">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="1980" endline="1996" pcid="1755">
        self.assertNotContains(response, f'<a href="{edit_translation_url}" aria-label="French" class="u-link is-live">')


class TestPageSubscriptionSettings(TestCase, WagtailTestUtils):
    def setUp(self):
        # Find root page
        self.root_page = Page.objects.get(id=2)

        # Add child page
        child_page = SimplePage(
            title="Hello world!",
            slug="hello-world",
            content="hello",
        )
        self.root_page.add_child(instance=child_page)
        child_page.save_revision().publish()
        self.child_page = SimplePage.objects.get(id=child_page.id)
</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_dashboard.py" startline="12" endline="28" pcid="2030">
    def setUp(self):
        # Find root page
        self.root_page = Page.objects.get(id=2)

        # Add child page
        child_page = SimplePage(
            title="Hello world!",
            slug="hello-world",
            content="Some content here",
        )
        self.root_page.add_child(instance=child_page)
        child_page.save_revision().publish()
        self.child_page = SimplePage.objects.get(id=child_page.id)

        self.create_superuser(username='alice', password='password')
        self.create_superuser(username='bob', password='password')

</source>
</class>

<class classid="79" nclones="3" nlines="12" similarity="75">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="2015" endline="2031" pcid="1758">

        self.assertEqual(response.status_code, 200)
        self.assertContains(response, '<input type="checkbox" name="comment_notifications" id="id_comment_notifications" checked>')

    def test_post_with_comment_notifications_switched_on(self):
        post_data = {
            'title': "I've been edited!",
            'content': "Some content",
            'slug': 'hello-world',
            'comment_notifications': 'on'
        }
        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]), post_data)
        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=[self.child_page.id]))

        # Check the subscription
        page = Page.objects.get(path__startswith=self.root_page.path, slug='hello-world').specific
        subscription = page.subscribers.get()
</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_create_page.py" startline="1208" endline="1224" pcid="1857">
    def test_post_with_comment_notifications_switched_off(self):
        post_data = {
            'title': "New page!",
            'content': "Some content",
            'slug': 'hello-world',
        }
        response = self.client.post(reverse('wagtailadmin_pages:add', args=['tests', 'simplepage', self.root_page.id]), post_data)

        page = Page.objects.get(path__startswith=self.root_page.path, slug='hello-world').specific

        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=[page.id]))

        # Check the subscription
        subscription = page.subscribers.get()

        self.assertEqual(subscription.user, self.user)
        self.assertFalse(subscription.comment_notifications)
</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_create_page.py" startline="1189" endline="1207" pcid="1856">
    def test_post_with_comment_notifications_switched_on(self):
        post_data = {
            'title': "New page!",
            'content': "Some content",
            'slug': 'hello-world',
            'comment_notifications': 'on'
        }
        response = self.client.post(reverse('wagtailadmin_pages:add', args=['tests', 'simplepage', self.root_page.id]), post_data)

        page = Page.objects.get(path__startswith=self.root_page.path, slug='hello-world').specific

        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=[page.id]))

        # Check the subscription
        subscription = page.subscribers.get()

        self.assertEqual(subscription.user, self.user)
        self.assertTrue(subscription.comment_notifications)

</source>
</class>

<class classid="80" nclones="8" nlines="39" similarity="70">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="2130" endline="2174" pcid="1764">

    def assertNeverEmailedWrongUser(self):
        self.assertNotIn(self.never_emailed_user.email, [to for email in mail.outbox for to in email.to])

    def test_new_comment(self):
        post_data = {
            'title': "I've been edited!",
            'content': "Some content",
            'slug': 'hello-world',
            'comments-TOTAL_FORMS': '1',
            'comments-INITIAL_FORMS': '0',
            'comments-MIN_NUM_FORMS': '0',
            'comments-MAX_NUM_FORMS': '',
            'comments-0-DELETE': '',
            'comments-0-resolved': '',
            'comments-0-id': '',
            'comments-0-contentpath': 'title',
            'comments-0-text': 'A test comment',
            'comments-0-position': '',
            'comments-0-replies-TOTAL_FORMS': '0',
            'comments-0-replies-INITIAL_FORMS': '0',
            'comments-0-replies-MIN_NUM_FORMS': '0',
            'comments-0-replies-MAX_NUM_FORMS': '0'
        }

        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]), post_data)

        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=[self.child_page.id]))

        # Check the comment was added
        comment = self.child_page.wagtail_admin_comments.get()
        self.assertEqual(comment.text, 'A test comment')

        # Check notification email
        self.assertEqual(len(mail.outbox), 1)
        self.assertNeverEmailedWrongUser()
        self.assertEqual(mail.outbox[0].to, [self.subscriber.email])
        self.assertEqual(mail.outbox[0].subject, 'test@email.com has updated comments on "I\'ve been edited! (simple page)"')
        self.assertIn('New comments:\n - "A test comment"\n\n', mail.outbox[0].body)

        # Check audit log
        log_entry = PageLogEntry.objects.get(action='wagtail.comments.create')
        self.assertEqual(log_entry.page, self.child_page.page_ptr)
        self.assertEqual(log_entry.user, self.user)
        self.assertEqual(log_entry.revision, self.child_page.get_latest_revision())
</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="2175" endline="2222" pcid="1765">
        self.assertEqual(log_entry.data['comment']['id'], comment.id)
        self.assertEqual(log_entry.data['comment']['contentpath'], comment.contentpath)
        self.assertEqual(log_entry.data['comment']['text'], comment.text)

    def test_edit_comment(self):
        comment = Comment.objects.create(
            page=self.child_page,
            user=self.user,
            text="A test comment",
            contentpath="title",
        )

        post_data = {
            'title': "I've been edited!",
            'content': "Some content",
            'slug': 'hello-world',
            'comments-TOTAL_FORMS': '1',
            'comments-INITIAL_FORMS': '1',
            'comments-MIN_NUM_FORMS': '0',
            'comments-MAX_NUM_FORMS': '',
            'comments-0-DELETE': '',
            'comments-0-resolved': '',
            'comments-0-id': str(comment.id),
            'comments-0-contentpath': 'title',
            'comments-0-text': 'Edited',
            'comments-0-position': '',
            'comments-0-replies-TOTAL_FORMS': '0',
            'comments-0-replies-INITIAL_FORMS': '0',
            'comments-0-replies-MIN_NUM_FORMS': '0',
            'comments-0-replies-MAX_NUM_FORMS': '0'
        }

        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]), post_data)

        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=[self.child_page.id]))

        # Check the comment was edited
        comment.refresh_from_db()
        self.assertEqual(comment.text, 'Edited')

        # No emails should be sent for edited comments
        self.assertEqual(len(mail.outbox), 0)

        # Check audit log
        log_entry = PageLogEntry.objects.get(action='wagtail.comments.edit')
        self.assertEqual(log_entry.page, self.child_page.page_ptr)
        self.assertEqual(log_entry.user, self.user)
        self.assertEqual(log_entry.revision, self.child_page.get_latest_revision())
</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="2319" endline="2369" pcid="1768">
        self.assertEqual(log_entry.data['comment']['id'], comment.id)
        self.assertEqual(log_entry.data['comment']['contentpath'], comment.contentpath)
        self.assertEqual(log_entry.data['comment']['text'], comment.text)

    def test_delete_comment(self):
        comment = Comment.objects.create(
            page=self.child_page,
            user=self.user,
            text="A test comment",
            contentpath="title",
        )

        post_data = {
            'title': "I've been edited!",
            'content': "Some content",
            'slug': 'hello-world',
            'comments-TOTAL_FORMS': '1',
            'comments-INITIAL_FORMS': '1',
            'comments-MIN_NUM_FORMS': '0',
            'comments-MAX_NUM_FORMS': '',
            'comments-0-DELETE': 'on',
            'comments-0-resolved': '',
            'comments-0-id': str(comment.id),
            'comments-0-contentpath': 'title',
            'comments-0-text': 'A test comment',
            'comments-0-position': '',
            'comments-0-replies-TOTAL_FORMS': '0',
            'comments-0-replies-INITIAL_FORMS': '0',
            'comments-0-replies-MIN_NUM_FORMS': '0',
            'comments-0-replies-MAX_NUM_FORMS': '0'
        }

        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]), post_data)

        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=[self.child_page.id]))

        # Check the comment was deleted
        self.assertFalse(self.child_page.wagtail_admin_comments.exists())

        # Check notification email
        self.assertEqual(len(mail.outbox), 1)
        self.assertNeverEmailedWrongUser()
        self.assertEqual(mail.outbox[0].to, [self.subscriber.email])
        self.assertEqual(mail.outbox[0].subject, 'test@email.com has updated comments on "I\'ve been edited! (simple page)"')
        self.assertIn('Deleted comments:\n - "A test comment"\n\n', mail.outbox[0].body)

        # Check audit log
        log_entry = PageLogEntry.objects.get(action='wagtail.comments.delete')
        self.assertEqual(log_entry.page, self.child_page.page_ptr)
        self.assertEqual(log_entry.user, self.user)
        self.assertEqual(log_entry.revision, self.child_page.get_latest_revision())
</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="2262" endline="2318" pcid="1767">

        # Check no log entry was created
        self.assertFalse(PageLogEntry.objects.filter(action='wagtail.comments.edit').exists())

    def test_resolve_comment(self):
        comment = Comment.objects.create(
            page=self.child_page,
            user=self.non_subscriber,
            text="A test comment",
            contentpath="title",
        )

        post_data = {
            'title': "I've been edited!",
            'content': "Some content",
            'slug': 'hello-world',
            'comments-TOTAL_FORMS': '1',
            'comments-INITIAL_FORMS': '1',
            'comments-MIN_NUM_FORMS': '0',
            'comments-MAX_NUM_FORMS': '',
            'comments-0-DELETE': '',
            'comments-0-resolved': 'on',
            'comments-0-id': str(comment.id),
            'comments-0-contentpath': 'title',
            'comments-0-text': 'A test comment',
            'comments-0-position': '',
            'comments-0-replies-TOTAL_FORMS': '0',
            'comments-0-replies-INITIAL_FORMS': '0',
            'comments-0-replies-MIN_NUM_FORMS': '0',
            'comments-0-replies-MAX_NUM_FORMS': '0'
        }

        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]), post_data)

        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=[self.child_page.id]))

        # Check the comment was resolved
        comment.refresh_from_db()
        self.assertTrue(comment.resolved_at)
        self.assertEqual(comment.resolved_by, self.user)

        # Check notification email
        self.assertEqual(len(mail.outbox), 2)
        self.assertNeverEmailedWrongUser()
        # The non subscriber created the comment, so should also get an email
        self.assertEqual(mail.outbox[0].to, [self.non_subscriber.email])
        self.assertEqual(mail.outbox[0].subject, 'test@email.com has updated comments on "I\'ve been edited! (simple page)"')
        self.assertIn('Resolved comments:\n - "A test comment"\n\n', mail.outbox[0].body)
        self.assertEqual(mail.outbox[1].to, [self.subscriber.email])
        self.assertEqual(mail.outbox[1].subject, 'test@email.com has updated comments on "I\'ve been edited! (simple page)"')
        self.assertIn('Resolved comments:\n - "A test comment"\n\n', mail.outbox[1].body)

        # Check audit log
        log_entry = PageLogEntry.objects.get(action='wagtail.comments.resolve')
        self.assertEqual(log_entry.page, self.child_page.page_ptr)
        self.assertEqual(log_entry.user, self.user)
        self.assertEqual(log_entry.revision, self.child_page.get_latest_revision())
</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="2500" endline="2557" pcid="1771">
        self.assertEqual(log_entry.data['comment']['text'], comment.text)
        self.assertEqual(log_entry.data['reply']['id'], reply.id)
        self.assertEqual(log_entry.data['reply']['text'], 'an edited reply')

    def test_delete_reply(self):
        comment = Comment.objects.create(
            page=self.child_page,
            user=self.non_subscriber,
            text="A test comment",
            contentpath="title",
        )

        reply = CommentReply.objects.create(
            comment=comment,
            user=self.user,
            text='an old reply'
        )

        post_data = {
            'title': "I've been edited!",
            'content': "Some content",
            'slug': 'hello-world',
            'comments-TOTAL_FORMS': '1',
            'comments-INITIAL_FORMS': '1',
            'comments-MIN_NUM_FORMS': '0',
            'comments-MAX_NUM_FORMS': '',
            'comments-0-DELETE': '',
            'comments-0-resolved': '',
            'comments-0-id': str(comment.id),
            'comments-0-contentpath': 'title',
            'comments-0-text': 'A test comment',
            'comments-0-position': '',
            'comments-0-replies-TOTAL_FORMS': '1',
            'comments-0-replies-INITIAL_FORMS': '1',
            'comments-0-replies-MIN_NUM_FORMS': '0',
            'comments-0-replies-MAX_NUM_FORMS': '',
            'comments-0-replies-0-id': str(reply.id),
            'comments-0-replies-0-text': 'an old reply',
            'comments-0-replies-0-DELETE': 'on',
        }

        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]), post_data)

        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=[self.child_page.id]))

        # Check the comment reply was deleted
        self.assertFalse(comment.replies.exists())

        # Check no notification was sent
        self.assertEqual(len(mail.outbox), 0)

        # Check audit log
        log_entry = PageLogEntry.objects.get(action='wagtail.comments.delete_reply')
        self.assertEqual(log_entry.page, self.child_page.page_ptr)
        self.assertEqual(log_entry.user, self.user)
        self.assertEqual(log_entry.revision, self.child_page.get_latest_revision())
        self.assertEqual(log_entry.data['comment']['id'], comment.id)
        self.assertEqual(log_entry.data['comment']['contentpath'], comment.contentpath)
</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="2442" endline="2499" pcid="1770">
        self.assertEqual(log_entry.data['comment']['text'], comment.text)
        self.assertNotEqual(log_entry.data['reply']['id'], reply.id)
        self.assertEqual(log_entry.data['reply']['text'], 'a new reply')

    def test_edit_reply(self):
        comment = Comment.objects.create(
            page=self.child_page,
            user=self.non_subscriber,
            text="A test comment",
            contentpath="title",
        )

        reply = CommentReply.objects.create(
            comment=comment,
            user=self.user,
            text='an old reply'
        )

        post_data = {
            'title': "I've been edited!",
            'content': "Some content",
            'slug': 'hello-world',
            'comments-TOTAL_FORMS': '1',
            'comments-INITIAL_FORMS': '1',
            'comments-MIN_NUM_FORMS': '0',
            'comments-MAX_NUM_FORMS': '',
            'comments-0-DELETE': '',
            'comments-0-resolved': '',
            'comments-0-id': str(comment.id),
            'comments-0-contentpath': 'title',
            'comments-0-text': 'A test comment',
            'comments-0-position': '',
            'comments-0-replies-TOTAL_FORMS': '1',
            'comments-0-replies-INITIAL_FORMS': '1',
            'comments-0-replies-MIN_NUM_FORMS': '0',
            'comments-0-replies-MAX_NUM_FORMS': '',
            'comments-0-replies-0-id': str(reply.id),
            'comments-0-replies-0-text': 'an edited reply',
        }

        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]), post_data)

        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=[self.child_page.id]))

        # Check the comment reply was edited
        reply.refresh_from_db()
        self.assertEqual(reply.text, 'an edited reply')

        # Check no notification was sent
        self.assertEqual(len(mail.outbox), 0)

        # Check audit log
        log_entry = PageLogEntry.objects.get(action='wagtail.comments.edit_reply')
        self.assertEqual(log_entry.page, self.child_page.page_ptr)
        self.assertEqual(log_entry.user, self.user)
        self.assertEqual(log_entry.revision, self.child_page.get_latest_revision())
        self.assertEqual(log_entry.data['comment']['id'], comment.id)
        self.assertEqual(log_entry.data['comment']['contentpath'], comment.contentpath)
</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="2223" endline="2261" pcid="1766">
        self.assertEqual(log_entry.data['comment']['id'], comment.id)
        self.assertEqual(log_entry.data['comment']['contentpath'], comment.contentpath)
        self.assertEqual(log_entry.data['comment']['text'], comment.text)

    def test_edit_another_users_comment(self):
        comment = Comment.objects.create(
            page=self.child_page,
            user=self.subscriber,
            text="A test comment",
            contentpath="title",
        )

        post_data = {
            'title': "I've been edited!",
            'content': "Some content",
            'slug': 'hello-world',
            'comments-TOTAL_FORMS': '1',
            'comments-INITIAL_FORMS': '1',
            'comments-MIN_NUM_FORMS': '0',
            'comments-MAX_NUM_FORMS': '',
            'comments-0-DELETE': '',
            'comments-0-resolved': '',
            'comments-0-id': str(comment.id),
            'comments-0-contentpath': 'title',
            'comments-0-text': 'Edited',
            'comments-0-position': '',
            'comments-0-replies-TOTAL_FORMS': '0',
            'comments-0-replies-INITIAL_FORMS': '0',
            'comments-0-replies-MIN_NUM_FORMS': '0',
            'comments-0-replies-MAX_NUM_FORMS': '0'
        }

        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]), post_data)

        self.assertEqual(response.context['form'].formsets['comments'].errors, [{'__all__': ["You cannot edit another user's comment."]}])

        # Check the comment was not edited
        comment.refresh_from_db()
        self.assertNotEqual(comment.text, 'Edited')
</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="2370" endline="2441" pcid="1769">
        self.assertEqual(log_entry.data['comment']['id'], comment.id)
        self.assertEqual(log_entry.data['comment']['contentpath'], comment.contentpath)
        self.assertEqual(log_entry.data['comment']['text'], comment.text)

    def test_new_reply(self):
        comment = Comment.objects.create(
            page=self.child_page,
            user=self.non_subscriber,
            text="A test comment",
            contentpath="title",
        )

        reply = CommentReply.objects.create(
            comment=comment,
            user=self.non_subscriber_2,
            text='an old reply'
        )

        post_data = {
            'title': "I've been edited!",
            'content': "Some content",
            'slug': 'hello-world',
            'comments-TOTAL_FORMS': '1',
            'comments-INITIAL_FORMS': '1',
            'comments-MIN_NUM_FORMS': '0',
            'comments-MAX_NUM_FORMS': '',
            'comments-0-DELETE': '',
            'comments-0-resolved': '',
            'comments-0-id': str(comment.id),
            'comments-0-contentpath': 'title',
            'comments-0-text': 'A test comment',
            'comments-0-position': '',
            'comments-0-replies-TOTAL_FORMS': '2',
            'comments-0-replies-INITIAL_FORMS': '1',
            'comments-0-replies-MIN_NUM_FORMS': '0',
            'comments-0-replies-MAX_NUM_FORMS': '',
            'comments-0-replies-0-id': str(reply.id),
            'comments-0-replies-0-text': 'an old reply',
            'comments-0-replies-1-id': '',
            'comments-0-replies-1-text': 'a new reply'
        }

        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]), post_data)

        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=[self.child_page.id]))

        # Check the comment reply was added
        comment.refresh_from_db()
        self.assertEqual(comment.replies.last().text, 'a new reply')

        # Check notification email
        self.assertEqual(len(mail.outbox), 3)
        self.assertNeverEmailedWrongUser()

        recipients = [mail.to for mail in mail.outbox]
        # The other non subscriber replied in the thread, so should get an email
        self.assertIn([self.non_subscriber_2.email], recipients)

        # The non subscriber created the comment, so should get an email
        self.assertIn([self.non_subscriber.email], recipients)

        self.assertIn([self.subscriber.email], recipients)
        self.assertEqual(mail.outbox[2].subject, 'test@email.com has updated comments on "I\'ve been edited! (simple page)"')
        self.assertIn('  New replies to: "A test comment"\n   - "a new reply"', mail.outbox[2].body)

        # Check audit log
        log_entry = PageLogEntry.objects.get(action='wagtail.comments.create_reply')
        self.assertEqual(log_entry.page, self.child_page.page_ptr)
        self.assertEqual(log_entry.user, self.user)
        self.assertEqual(log_entry.revision, self.child_page.get_latest_revision())
        self.assertEqual(log_entry.data['comment']['id'], comment.id)
        self.assertEqual(log_entry.data['comment']['contentpath'], comment.contentpath)
</source>
</class>

<class classid="81" nclones="2" nlines="27" similarity="88">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="2558" endline="2594" pcid="1772">
        self.assertEqual(log_entry.data['comment']['text'], comment.text)
        self.assertEqual(log_entry.data['reply']['id'], reply.id)
        self.assertEqual(log_entry.data['reply']['text'], reply.text)

    def test_updated_comments_notifications_profile_setting(self):
        # Users can disable commenting notifications globally from account settings
        profile = UserProfile.get_for_user(self.subscriber)
        profile.updated_comments_notifications = False
        profile.save()

        post_data = {
            'title': "I've been edited!",
            'content': "Some content",
            'slug': 'hello-world',
            'comments-TOTAL_FORMS': '1',
            'comments-INITIAL_FORMS': '0',
            'comments-MIN_NUM_FORMS': '0',
            'comments-MAX_NUM_FORMS': '',
            'comments-0-DELETE': '',
            'comments-0-resolved': '',
            'comments-0-id': '',
            'comments-0-contentpath': 'title',
            'comments-0-text': 'A test comment',
            'comments-0-position': '',
            'comments-0-replies-TOTAL_FORMS': '0',
            'comments-0-replies-INITIAL_FORMS': '0',
            'comments-0-replies-MIN_NUM_FORMS': '0',
            'comments-0-replies-MAX_NUM_FORMS': '0'
        }

        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]), post_data)

        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=[self.child_page.id]))

        # Check the comment was added
        comment = self.child_page.wagtail_admin_comments.get()
        self.assertEqual(comment.text, 'A test comment')
</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_edit_page.py" startline="2595" endline="2629" pcid="1773">

        # This time, no emails should be submitted because the only subscriber has disabled these emails globally
        self.assertEqual(len(mail.outbox), 0)

    def test_updated_comments_notifications_active_users_only(self):
        # subscriber is inactive
        self.subscriber.is_active = False
        self.subscriber.save()

        post_data = {
            'title': "I've been edited!",
            'content': "Some content",
            'slug': 'hello-world',
            'comments-TOTAL_FORMS': '1',
            'comments-INITIAL_FORMS': '0',
            'comments-MIN_NUM_FORMS': '0',
            'comments-MAX_NUM_FORMS': '',
            'comments-0-DELETE': '',
            'comments-0-resolved': '',
            'comments-0-id': '',
            'comments-0-contentpath': 'title',
            'comments-0-text': 'A test comment',
            'comments-0-position': '',
            'comments-0-replies-TOTAL_FORMS': '0',
            'comments-0-replies-INITIAL_FORMS': '0',
            'comments-0-replies-MIN_NUM_FORMS': '0',
            'comments-0-replies-MAX_NUM_FORMS': '0'
        }

        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]), post_data)

        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=[self.child_page.id]))

        # Check the comment was added
        comment = self.child_page.wagtail_admin_comments.get()
</source>
</class>

<class classid="82" nclones="2" nlines="11" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_create_page.py" startline="201" endline="229" pcid="1796">
    def test_cannot_create_page_when_can_create_at_returns_false(self):
        # issue #2892

        # Check that creating a second SingletonPage results in a permission
        # denied error.

        # SingletonPage overrides the can_create_at method to make it return
        # False if another SingletonPage already exists.

        # The Page model now has a max_count attribute (issue 4841),
        # but we are leaving this test in place to cover existing behaviour and
        # ensure it does not break any code doing this in the wild.
        add_url = reverse('wagtailadmin_pages:add', args=[
            SingletonPage._meta.app_label, SingletonPage._meta.model_name, self.root_page.pk])

        # A single singleton page should be creatable
        self.assertTrue(SingletonPage.can_create_at(self.root_page))
        response = self.client.get(add_url)
        self.assertEqual(response.status_code, 200)

        # Create a singleton page
        self.root_page.add_child(instance=SingletonPage(
            title='singleton', slug='singleton'))

        # A second singleton page should not be creatable
        self.assertFalse(SingletonPage.can_create_at(self.root_page))
        response = self.client.get(add_url)
        self.assertRedirects(response, '/admin/')

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_create_page.py" startline="230" endline="253" pcid="1797">
    def test_cannot_create_singleton_page_with_max_count(self):
        # Check that creating a second SingletonPageViaMaxCount results in a permission
        # denied error.

        # SingletonPageViaMaxCount uses the max_count attribute to limit the number of
        # instance it can have.

        add_url = reverse('wagtailadmin_pages:add', args=[
            SingletonPageViaMaxCount._meta.app_label, SingletonPageViaMaxCount._meta.model_name, self.root_page.pk])

        # A single singleton page should be creatable
        self.assertTrue(SingletonPageViaMaxCount.can_create_at(self.root_page))
        response = self.client.get(add_url)
        self.assertEqual(response.status_code, 200)

        # Create a singleton page
        self.root_page.add_child(instance=SingletonPageViaMaxCount(
            title='singleton', slug='singleton'))

        # A second singleton page should not be creatable
        self.assertFalse(SingletonPageViaMaxCount.can_create_at(self.root_page))
        response = self.client.get(add_url)
        self.assertRedirects(response, '/admin/')

</source>
</class>

<class classid="83" nclones="2" nlines="21" similarity="80">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_create_page.py" startline="303" endline="329" pcid="1801">
    def test_create_simplepage_scheduled(self):
        go_live_at = timezone.now() + datetime.timedelta(days=1)
        expire_at = timezone.now() + datetime.timedelta(days=2)
        post_data = {
            'title': "New page!",
            'content': "Some content",
            'slug': 'hello-world',
            'go_live_at': submittable_timestamp(go_live_at),
            'expire_at': submittable_timestamp(expire_at),
        }
        response = self.client.post(
            reverse('wagtailadmin_pages:add', args=('tests', 'simplepage', self.root_page.id)), post_data
        )

        # Should be redirected to explorer page
        self.assertEqual(response.status_code, 302)

        # Find the page and check the scheduled times
        page = Page.objects.get(path__startswith=self.root_page.path, slug='hello-world').specific
        self.assertEqual(page.go_live_at.date(), go_live_at.date())
        self.assertEqual(page.expire_at.date(), expire_at.date())
        self.assertEqual(page.expired, False)
        self.assertTrue(page.status_string, "draft")

        # No revisions with approved_go_live_at
        self.assertFalse(PageRevision.objects.filter(page=page).exclude(approved_go_live_at__isnull=True).exists())

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_create_page.py" startline="409" endline="439" pcid="1805">
    def test_create_simplepage_post_publish_scheduled(self):
        go_live_at = timezone.now() + datetime.timedelta(days=1)
        expire_at = timezone.now() + datetime.timedelta(days=2)
        post_data = {
            'title': "New page!",
            'content': "Some content",
            'slug': 'hello-world',
            'action-publish': "Publish",
            'go_live_at': submittable_timestamp(go_live_at),
            'expire_at': submittable_timestamp(expire_at),
        }
        response = self.client.post(
            reverse('wagtailadmin_pages:add', args=('tests', 'simplepage', self.root_page.id)), post_data
        )

        # Should be redirected to explorer page
        self.assertEqual(response.status_code, 302)

        # Find the page and check it
        page = Page.objects.get(path__startswith=self.root_page.path, slug='hello-world').specific
        self.assertEqual(page.go_live_at.date(), go_live_at.date())
        self.assertEqual(page.expire_at.date(), expire_at.date())
        self.assertEqual(page.expired, False)

        # A revision with approved_go_live_at should exist now
        self.assertTrue(PageRevision.objects.filter(page=page).exclude(approved_go_live_at__isnull=True).exists())
        # But Page won't be live
        self.assertFalse(page.live)
        self.assertFalse(page.first_published_at)
        self.assertTrue(page.status_string, "scheduled")

</source>
</class>

<class classid="84" nclones="2" nlines="12" similarity="84">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_create_page.py" startline="559" endline="575" pcid="1813">
    def test_whitespace_titles_with_tab_in_seo_title(self):
        post_data = {
            'title': "Hello",
            'content': "Some content",
            'slug': 'hello-world',
            'action-submit': "Submit",
            'seo_title': '\t'
        }
        response = self.client.post(reverse('wagtailadmin_pages:add', args=('tests', 'simplepage', self.root_page.id)), post_data)

        # Should be successful, as seo_title is not required
        self.assertEqual(response.status_code, 302)

        # The tab should be automatically stripped from the seo_title
        page = Page.objects.order_by('-id').first()
        self.assertEqual(page.seo_title, '')

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_create_page.py" startline="576" endline="594" pcid="1814">
    def test_whitespace_is_stripped_from_titles(self):
        post_data = {
            'title': "   Hello   ",
            'content': "Some content",
            'slug': 'hello-world',
            'action-submit': "Submit",
            'seo_title': '   hello SEO   '
        }
        response = self.client.post(reverse('wagtailadmin_pages:add', args=('tests', 'simplepage', self.root_page.id)), post_data)

        # Should be successful, as both title and seo_title are non-empty after stripping
        self.assertEqual(response.status_code, 302)

        # Whitespace should be automatically stripped from title and seo_title
        page = Page.objects.order_by('-id').first()
        self.assertEqual(page.title, 'Hello')
        self.assertEqual(page.draft_title, 'Hello')
        self.assertEqual(page.seo_title, 'hello SEO')

</source>
</class>

<class classid="85" nclones="2" nlines="11" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_create_page.py" startline="865" endline="881" pcid="1834">
    def test_standard_subpage(self):
        add_subpage_url = reverse('wagtailadmin_pages:add_subpage', args=(self.standard_index.id, ))

        # explorer should contain a link to 'add child page'
        response = self.client.get(reverse('wagtailadmin_explore', args=(self.standard_index.id, )))
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, add_subpage_url)

        # add_subpage should give us choices of StandardChild, and BusinessIndex.
        # BusinessSubIndex and BusinessChild are not allowed
        response = self.client.get(add_subpage_url)
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, StandardChild.get_verbose_name())
        self.assertContains(response, BusinessIndex.get_verbose_name())
        self.assertNotContains(response, BusinessSubIndex.get_verbose_name())
        self.assertNotContains(response, BusinessChild.get_verbose_name())

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_create_page.py" startline="882" endline="897" pcid="1835">
    def test_business_subpage(self):
        add_subpage_url = reverse('wagtailadmin_pages:add_subpage', args=(self.business_index.id, ))

        # explorer should contain a link to 'add child page'
        response = self.client.get(reverse('wagtailadmin_explore', args=(self.business_index.id, )))
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, add_subpage_url)

        # add_subpage should give us a cut-down set of page types to choose
        response = self.client.get(add_subpage_url)
        self.assertEqual(response.status_code, 200)
        self.assertNotContains(response, StandardIndex.get_verbose_name())
        self.assertNotContains(response, StandardChild.get_verbose_name())
        self.assertContains(response, BusinessSubIndex.get_verbose_name())
        self.assertContains(response, BusinessChild.get_verbose_name())

</source>
</class>

<class classid="86" nclones="3" nlines="17" similarity="80">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_revisions.py" startline="17" endline="40" pcid="1860">
    def setUp(self):
        self.christmas_event = EventPage.objects.get(url_path='/home/events/christmas/')
        self.christmas_event.title = "Last Christmas"
        self.christmas_event.date_from = '2013-12-25'
        self.christmas_event.body = (
            "<p>Last Christmas I gave you my heart, "
            "but the very next day you gave it away</p>"
        )
        self.last_christmas_revision = self.christmas_event.save_revision()
        self.last_christmas_revision.created_at = local_datetime(2013, 12, 25)
        self.last_christmas_revision.save()

        self.christmas_event.title = "This Christmas"
        self.christmas_event.date_from = '2014-12-25'
        self.christmas_event.body = (
            "<p>This year, to save me from tears, "
            "I'll give it to someone special</p>"
        )
        self.this_christmas_revision = self.christmas_event.save_revision()
        self.this_christmas_revision.created_at = local_datetime(2014, 12, 25)
        self.this_christmas_revision.save()

        self.login()

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_revisions.py" startline="146" endline="169" pcid="1868">
    def setUp(self):
        self.christmas_event = EventPage.objects.get(url_path='/home/events/christmas/')
        self.christmas_event.title = "Last Christmas"
        self.christmas_event.date_from = '2013-12-25'
        self.christmas_event.body = (
            "<p>Last Christmas I gave you my heart, "
            "but the very next day you gave it away</p>"
        )
        self.last_christmas_revision = self.christmas_event.save_revision()
        self.last_christmas_revision.created_at = local_datetime(2013, 12, 25)
        self.last_christmas_revision.save()

        self.christmas_event.title = "This Christmas"
        self.christmas_event.date_from = '2014-12-25'
        self.christmas_event.body = (
            "<p>This year, to save me from tears, "
            "I'll give it to someone special</p>"
        )
        self.this_christmas_revision = self.christmas_event.save_revision()
        self.this_christmas_revision.created_at = local_datetime(2014, 12, 25)
        self.this_christmas_revision.save()

        self.login()

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_revisions.py" startline="357" endline="384" pcid="1879">
    def setUp(self):
        self.christmas_event = EventPage.objects.get(url_path='/home/events/christmas/')
        self.christmas_event.title = "Last Christmas"
        self.christmas_event.date_from = '2013-12-25'
        self.christmas_event.body = (
            "<p>Last Christmas I gave you my heart, "
            "but the very next day you gave it away</p>"
        )
        self.last_christmas_revision = self.christmas_event.save_revision()
        self.last_christmas_revision.created_at = local_datetime(2013, 12, 25)
        self.last_christmas_revision.save()
        self.last_christmas_revision.publish()

        self.christmas_event.title = "This Christmas"
        self.christmas_event.date_from = '2014-12-25'
        self.christmas_event.body = (
            "<p>This year, to save me from tears, "
            "I'll give it to someone special</p>"
        )
        self.this_christmas_revision = self.christmas_event.save_revision()
        self.this_christmas_revision.created_at = local_datetime(2014, 12, 24)
        self.this_christmas_revision.save()

        self.this_christmas_revision.approved_go_live_at = local_datetime(2014, 12, 25)
        self.this_christmas_revision.save()

        self.user = self.login()

</source>
</class>

<class classid="87" nclones="4" nlines="10" similarity="76">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_revisions.py" startline="170" endline="183" pcid="1869">
    def test_compare_revisions(self):
        compare_url = reverse(
            'wagtailadmin_pages:revisions_compare',
            args=(self.christmas_event.id, self.last_christmas_revision.id, self.this_christmas_revision.id)
        )
        response = self.client.get(compare_url)
        self.assertEqual(response.status_code, 200)

        self.assertContains(
            response,
            '<span class="deletion">Last Christmas I gave you my heart, but the very next day you gave it away</span><span class="addition">This year, to save me from tears, I&#39;ll give it to someone special</span>',
            html=True
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_revisions.py" startline="184" endline="197" pcid="1870">
    def test_compare_revisions_earliest(self):
        compare_url = reverse(
            'wagtailadmin_pages:revisions_compare',
            args=(self.christmas_event.id, 'earliest', self.this_christmas_revision.id)
        )
        response = self.client.get(compare_url)
        self.assertEqual(response.status_code, 200)

        self.assertContains(
            response,
            '<span class="deletion">Last Christmas I gave you my heart, but the very next day you gave it away</span><span class="addition">This year, to save me from tears, I&#39;ll give it to someone special</span>',
            html=True
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_revisions.py" startline="198" endline="211" pcid="1871">
    def test_compare_revisions_latest(self):
        compare_url = reverse(
            'wagtailadmin_pages:revisions_compare',
            args=(self.christmas_event.id, self.last_christmas_revision.id, 'latest')
        )
        response = self.client.get(compare_url)
        self.assertEqual(response.status_code, 200)

        self.assertContains(
            response,
            '<span class="deletion">Last Christmas I gave you my heart, but the very next day you gave it away</span><span class="addition">This year, to save me from tears, I&#39;ll give it to someone special</span>',
            html=True
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_revisions.py" startline="212" endline="233" pcid="1872">
    def test_compare_revisions_live(self):
        # Mess with the live version, bypassing revisions
        self.christmas_event.body = (
            "<p>This year, to save me from tears, "
            "I'll just feed it to the dog</p>"
        )
        self.christmas_event.save(update_fields=['body'])

        compare_url = reverse(
            'wagtailadmin_pages:revisions_compare',
            args=(self.christmas_event.id, self.last_christmas_revision.id, 'live')
        )
        response = self.client.get(compare_url)
        self.assertEqual(response.status_code, 200)

        self.assertContains(
            response,
            '<span class="deletion">Last Christmas I gave you my heart, but the very next day you gave it away</span><span class="addition">This year, to save me from tears, I&#39;ll just feed it to the dog</span>',
            html=True
        )


</source>
</class>

<class classid="88" nclones="2" nlines="12" similarity="83">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_delete_page.py" startline="63" endline="87" pcid="1892">
    def test_page_delete_post(self):
        # Connect a mock signal handler to page_unpublished signal
        mock_handler = mock.MagicMock()
        page_unpublished.connect(mock_handler)

        # Post
        response = self.client.post(reverse('wagtailadmin_pages:delete', args=(self.child_page.id, )))

        # Should be redirected to explorer page
        self.assertRedirects(response, reverse('wagtailadmin_explore', args=(self.root_page.id, )))

        # treebeard should report no consistency problems with the tree
        self.assertFalse(any(Page.find_problems()), 'treebeard found consistency problems')

        # Check that the page is gone
        self.assertEqual(Page.objects.filter(path__startswith=self.root_page.path, slug='hello-world').count(), 0)

        # Check that the page_unpublished signal was fired
        self.assertEqual(mock_handler.call_count, 1)
        mock_call = mock_handler.mock_calls[0][2]

        self.assertEqual(mock_call['sender'], self.child_page.specific_class)
        self.assertEqual(mock_call['instance'], self.child_page)
        self.assertIsInstance(mock_call['instance'], self.child_page.specific_class)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_unpublish_page.py" startline="67" endline="91" pcid="2041">
    def test_unpublish_view_post(self):
        """
        This posts to the unpublish view and checks that the page was unpublished
        """
        # Connect a mock signal handler to page_unpublished signal
        mock_handler = mock.MagicMock()
        page_unpublished.connect(mock_handler)

        # Post to the unpublish page
        response = self.client.post(reverse('wagtailadmin_pages:unpublish', args=(self.page.id, )))

        # Should be redirected to explorer page
        self.assertRedirects(response, reverse('wagtailadmin_explore', args=(self.root_page.id, )))

        # Check that the page was unpublished
        self.assertFalse(SimplePage.objects.get(id=self.page.id).live)

        # Check that the page_unpublished signal was fired
        self.assertEqual(mock_handler.call_count, 1)
        mock_call = mock_handler.mock_calls[0][2]

        self.assertEqual(mock_call['sender'], self.page.specific_class)
        self.assertEqual(mock_call['instance'], self.page)
        self.assertIsInstance(mock_call['instance'], self.page.specific_class)

</source>
</class>

<class classid="89" nclones="5" nlines="10" similarity="70">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_delete_page.py" startline="174" endline="189" pcid="1900">
    def test_before_delete_page_hook_post(self):
        def hook_func(request, page):
            self.assertIsInstance(request, HttpRequest)
            self.assertEqual(page.id, self.child_page.id)

            return HttpResponse("Overridden!")

        with self.register_hook('before_delete_page', hook_func):
            response = self.client.post(reverse('wagtailadmin_pages:delete', args=(self.child_page.id, )))

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")

        # page should not be deleted
        self.assertTrue(Page.objects.filter(id=self.child_page.id).exists())

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_delete_page.py" startline="190" endline="204" pcid="1902">
    def test_after_delete_page_hook(self):
        def hook_func(request, page):
            self.assertIsInstance(request, HttpRequest)
            self.assertEqual(page.id, self.child_page.id)

            return HttpResponse("Overridden!")

        with self.register_hook('after_delete_page', hook_func):
            response = self.client.post(reverse('wagtailadmin_pages:delete', args=(self.child_page.id, )))

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")

        # page should be deleted
        self.assertFalse(Page.objects.filter(id=self.child_page.id).exists())
</source>
<source file="systems/wagtail-2.16.1/wagtail/snippets/tests.py" startline="624" endline="637" pcid="2948">
    def test_before_edit_snippet_hook_get(self):

        def hook_func(request, instance):
            self.assertIsInstance(request, HttpRequest)
            self.assertEqual(instance.text, 'test_advert')
            self.assertEqual(instance.url, 'http://www.example.com')
            return HttpResponse("Overridden!")

        with self.register_hook('before_edit_snippet', hook_func):
            response = self.get()

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")

</source>
<source file="systems/wagtail-2.16.1/wagtail/snippets/tests.py" startline="638" endline="655" pcid="2950">
    def test_before_edit_snippet_hook_post(self):

        def hook_func(request, instance):
            self.assertIsInstance(request, HttpRequest)
            self.assertEqual(instance.text, 'test_advert')
            self.assertEqual(instance.url, 'http://www.example.com')
            return HttpResponse("Overridden!")

        with self.register_hook('before_edit_snippet', hook_func):
            response = self.post(post_data={'text': 'Edited and runs hook',
                                            'url': 'http://www.example.com/hook-enabled-edited'})

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")

        # Request intercepted before advert was updated
        self.assertEqual(Advert.objects.get().text, "test_advert")

</source>
<source file="systems/wagtail-2.16.1/wagtail/snippets/tests.py" startline="656" endline="673" pcid="2952">
    def test_after_edit_snippet_hook(self):

        def hook_func(request, instance):
            self.assertIsInstance(request, HttpRequest)
            self.assertEqual(instance.text, 'Edited and runs hook')
            self.assertEqual(instance.url, 'http://www.example.com/hook-enabled-edited')
            return HttpResponse("Overridden!")

        with self.register_hook('after_edit_snippet', hook_func):
            response = self.post(post_data={'text': 'Edited and runs hook',
                                            'url': 'http://www.example.com/hook-enabled-edited'})

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")

        # Request intercepted after advert was updated
        self.assertEqual(Advert.objects.get().text, "Edited and runs hook")

</source>
</class>

<class classid="90" nclones="3" nlines="23" similarity="70">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_copy_page.py" startline="13" endline="45" pcid="1909">
    def setUp(self):
        # Find root page
        self.root_page = Page.objects.get(id=2)

        # Create a page
        self.test_page = self.root_page.add_child(instance=SimplePage(
            title="Hello world!",
            slug='hello-world',
            content="hello",
            live=True,
            has_unpublished_changes=False,
        ))

        # Create a couple of child pages
        self.test_child_page = self.test_page.add_child(instance=SimplePage(
            title="Child page",
            slug='child-page',
            content="hello",
            live=True,
            has_unpublished_changes=True,
        ))

        self.test_unpublished_child_page = self.test_page.add_child(instance=SimplePage(
            title="Unpublished Child page",
            slug='unpublished-child-page',
            content="hello",
            live=False,
            has_unpublished_changes=True,
        ))

        # Login
        self.user = self.login()

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_unpublish_page.py" startline="146" endline="176" pcid="2047">
    def setUp(self):
        self.user = self.login()
        # Find root page
        self.root_page = Page.objects.get(id=2)

        # Create a page to unpublish
        self.test_page = self.root_page.add_child(instance=SimplePage(
            title="Hello world!",
            slug='hello-world',
            content="hello",
            live=True,
            has_unpublished_changes=False,
        ))

        # Create a couple of child pages
        self.test_child_page = self.test_page.add_child(instance=SimplePage(
            title="Child page",
            slug='child-page',
            content="hello",
            live=True,
            has_unpublished_changes=True,
        ))

        self.test_another_child_page = self.test_page.add_child(instance=SimplePage(
            title="Another Child page",
            slug='another-child-page',
            content="hello",
            live=True,
            has_unpublished_changes=True,
        ))

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_privacy.py" startline="247" endline="273" pcid="2582">
    def setUp(self):
        self.login()

        # Create some pages
        self.homepage = Page.objects.get(id=2)

        self.public_page = self.homepage.add_child(instance=SimplePage(
            title="Public page",
            content="hello",
            live=True,
        ))

        self.private_page = self.homepage.add_child(instance=SimplePage(
            title="Private page",
            content="hello",
            live=True,
        ))
        PageViewRestriction.objects.create(
            page=self.private_page, restriction_type='password', password='password123'
        )

        self.private_child_page = self.private_page.add_child(instance=SimplePage(
            title="Private child page",
            content="hello",
            live=True,
        ))

</source>
</class>

<class classid="91" nclones="6" nlines="11" similarity="72">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_copy_page.py" startline="46" endline="60" pcid="1910">
    def test_page_copy(self):
        response = self.client.get(reverse('wagtailadmin_pages:copy', args=(self.test_page.id, )))

        # Check response
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'wagtailadmin/pages/copy.html')

        # Make sure all fields are in the form
        self.assertContains(response, "New title")
        self.assertContains(response, "New slug")
        self.assertContains(response, "New parent page")
        self.assertContains(response, "Copy subpages")
        self.assertContains(response, "Publish copies")
        self.assertContains(response, "Alias")

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_rich_text.py" startline="494" endline="511" pcid="2101">
    def test_additional_features_should_not_be_included_by_default(self):
        response = self.client.get(reverse(
            'wagtailadmin_pages:add', args=('tests', 'defaultrichtextfieldpage', self.root_page.id)
        ))

        self.assertEqual(response.status_code, 200)
        # default ones are there
        self.assertContains(response, '"type": "header-two"')
        self.assertContains(response, '"type": "LINK"')
        self.assertContains(response, '"type": "ITALIC"')

        # not the additional ones.
        self.assertNotContains(response, '"type": "CODE"')
        self.assertNotContains(response, '"type": "blockquote"')
        self.assertNotContains(response, '"type": "SUPERSCRIPT"')
        self.assertNotContains(response, '"type": "SUBSCRIPT"')
        self.assertNotContains(response, '"type": "STRIKETHROUGH"')

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_rich_text.py" startline="523" endline="541" pcid="2102">
    def test_additional_features_included(self):
        response = self.client.get(reverse(
            'wagtailadmin_pages:add', args=('tests', 'defaultrichtextfieldpage', self.root_page.id)
        ))

        self.assertEqual(response.status_code, 200)
        # Added features are there
        self.assertContains(response, '"type": "header-two"')
        self.assertContains(response, '"type": "CODE"')
        self.assertContains(response, '"type": "blockquote"')
        self.assertContains(response, '"type": "SUPERSCRIPT"')
        self.assertContains(response, '"type": "SUBSCRIPT"')
        self.assertContains(response, '"type": "STRIKETHROUGH"')

        # But not the unprovided default ones.
        self.assertNotContains(response, '"type": "LINK"')
        self.assertNotContains(response, '"type": "ITALIC"')


</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_rich_text.py" startline="396" endline="416" pcid="2095">
    def test_features_list_on_rich_text_field(self):
        response = self.client.get(reverse(
            'wagtailadmin_pages:add', args=('tests', 'richtextfieldwithfeaturespage', self.root_page.id)
        ))

        # Check status code
        self.assertEqual(response.status_code, 200)

        # Check that the custom plugin options are being passed in the hallo initialiser
        self.assertContains(response, '"halloquotation":')
        self.assertContains(response, '"hallowagtailembeds":')
        self.assertNotContains(response, '"hallolists":')
        self.assertNotContains(response, '"hallowagtailimage":')

        # check that media (js/css) from the features is being imported
        self.assertContains(response, 'testapp/js/hallo-quotation.js')
        self.assertContains(response, 'testapp/css/hallo-quotation.css')

        # check that we're NOT importing media for the default features we're not using
        self.assertNotContains(response, 'wagtaildocs/js/hallo-plugins/hallo-wagtaildoclink.js')

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_rich_text.py" startline="99" endline="120" pcid="2075">
    def test_default_editor_in_rich_text_field(self):
        # Simulate the absence of a setting
        if hasattr(settings, 'WAGTAILADMIN_RICH_TEXT_EDITORS'):
            del settings.WAGTAILADMIN_RICH_TEXT_EDITORS

        response = self.client.get(reverse(
            'wagtailadmin_pages:add', args=('tests', 'defaultrichtextfieldpage', self.root_page.id)
        ))

        # Check status code
        self.assertEqual(response.status_code, 200)

        # Check that draftail (default editor) initialisation is applied
        self.assertContains(response, "window.draftail.initEditor('#id_body',")

        # check that media for draftail is being imported
        self.assertContains(response, 'wagtailadmin/js/draftail.js')

        # check that media for non-active features is not being imported
        self.assertNotContains(response, 'testapp/js/draftail-blockquote.js')
        self.assertNotContains(response, 'testapp/css/draftail-blockquote.css')

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_rich_text.py" startline="123" endline="145" pcid="2076">
    def test_default_editor_in_rich_text_block(self):
        # Simulate the absence of a setting
        if hasattr(settings, 'WAGTAILADMIN_RICH_TEXT_EDITORS'):
            del settings.WAGTAILADMIN_RICH_TEXT_EDITORS

        response = self.client.get(reverse(
            'wagtailadmin_pages:add', args=('tests', 'defaultrichblockfieldpage', self.root_page.id)
        ))

        # Check status code
        self.assertEqual(response.status_code, 200)

        # Check that draftail (default editor) initialisation is applied
        self.assertContains(response, "window.draftail.initEditor('#__PREFIX__\\u002Dvalue',")

        # check that media for draftail is being imported
        self.assertContains(response, 'wagtailadmin/js/draftail.js')

        # check that media for non-active features is not being imported
        self.assertNotContains(response, 'testapp/js/draftail-blockquote.js')
        self.assertNotContains(response, 'testapp/css/draftail-blockquote.css')


</source>
</class>

<class classid="92" nclones="2" nlines="18" similarity="88">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_copy_page.py" startline="104" endline="136" pcid="1912">
    def test_page_copy_post(self):
        post_data = {
            'new_title': "Hello world 2",
            'new_slug': 'hello-world-2',
            'new_parent_page': str(self.root_page.id),
            'copy_subpages': False,
            'publish_copies': False,
            'alias': False,
        }
        response = self.client.post(reverse('wagtailadmin_pages:copy', args=(self.test_page.id, )), post_data)

        # Check that the user was redirected to the parents explore page
        self.assertRedirects(response, reverse('wagtailadmin_explore', args=(self.root_page.id, )))

        # Get copy
        page_copy = self.root_page.get_children().filter(slug='hello-world-2').first()

        # Check that the copy exists
        self.assertNotEqual(page_copy, None)

        # Check that the copy is not live
        self.assertFalse(page_copy.live)
        self.assertTrue(page_copy.has_unpublished_changes)

        # Check that the owner of the page is set correctly
        self.assertEqual(page_copy.owner, self.user)

        # Check that the children were not copied
        self.assertEqual(page_copy.get_children().count(), 0)

        # treebeard should report no consistency problems with the tree
        self.assertFalse(any(Page.find_problems()), 'treebeard found consistency problems')

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_copy_page.py" startline="477" endline="510" pcid="1929">
    def test_page_copy_alias_post(self):
        post_data = {
            'new_title': "Hello world 2",
            'new_slug': 'hello-world-2',
            'new_parent_page': str(self.root_page.id),
            'copy_subpages': False,
            'publish_copies': False,
            'alias': True,
        }
        response = self.client.post(reverse('wagtailadmin_pages:copy', args=(self.test_page.id, )), post_data)

        # Check that the user was redirected to the parents explore page
        self.assertRedirects(response, reverse('wagtailadmin_explore', args=(self.root_page.id, )))

        # Get copy
        page_copy = self.root_page.get_children().get(slug='hello-world-2')

        # Check the copy is an alias of the original
        self.assertEqual(page_copy.alias_of, self.test_page.page_ptr)

        # Check that the copy is live
        # Note: publish_copies is ignored. Alias pages always keep the same state as their original
        self.assertTrue(page_copy.live)
        self.assertFalse(page_copy.has_unpublished_changes)

        # Check that the owner of the page is set correctly
        self.assertEqual(page_copy.owner, self.user)

        # Check that the children were not copied
        self.assertEqual(page_copy.get_children().count(), 0)

        # treebeard should report no consistency problems with the tree
        self.assertFalse(any(Page.find_problems()), 'treebeard found consistency problems')

</source>
</class>

<class classid="93" nclones="4" nlines="26" similarity="81">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_copy_page.py" startline="137" endline="181" pcid="1913">
    def test_page_copy_post_copy_subpages(self):
        post_data = {
            'new_title': "Hello world 2",
            'new_slug': 'hello-world-2',
            'new_parent_page': str(self.root_page.id),
            'copy_subpages': True,
            'publish_copies': False,
            'alias': False,
        }
        response = self.client.post(reverse('wagtailadmin_pages:copy', args=(self.test_page.id, )), post_data)

        # Check that the user was redirected to the parents explore page
        self.assertRedirects(response, reverse('wagtailadmin_explore', args=(self.root_page.id, )))

        # Get copy
        page_copy = self.root_page.get_children().filter(slug='hello-world-2').first()

        # Check that the copy exists
        self.assertNotEqual(page_copy, None)

        # Check that the copy is not live
        self.assertFalse(page_copy.live)
        self.assertTrue(page_copy.has_unpublished_changes)

        # Check that the owner of the page is set correctly
        self.assertEqual(page_copy.owner, self.user)

        # Check that the children were copied
        self.assertEqual(page_copy.get_children().count(), 2)

        # Check the the child pages
        # Neither of them should be live
        child_copy = page_copy.get_children().filter(slug='child-page').first()
        self.assertNotEqual(child_copy, None)
        self.assertFalse(child_copy.live)
        self.assertTrue(child_copy.has_unpublished_changes)

        unpublished_child_copy = page_copy.get_children().filter(slug='unpublished-child-page').first()
        self.assertNotEqual(unpublished_child_copy, None)
        self.assertFalse(unpublished_child_copy.live)
        self.assertTrue(unpublished_child_copy.has_unpublished_changes)

        # treebeard should report no consistency problems with the tree
        self.assertFalse(any(Page.find_problems()), 'treebeard found consistency problems')

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_copy_page.py" startline="182" endline="226" pcid="1914">
    def test_page_copy_post_copy_subpages_publish_copies(self):
        post_data = {
            'new_title': "Hello world 2",
            'new_slug': 'hello-world-2',
            'new_parent_page': str(self.root_page.id),
            'copy_subpages': True,
            'publish_copies': True,
            'alias': False,
        }
        response = self.client.post(reverse('wagtailadmin_pages:copy', args=(self.test_page.id, )), post_data)

        # Check that the user was redirected to the parents explore page
        self.assertRedirects(response, reverse('wagtailadmin_explore', args=(self.root_page.id, )))

        # Get copy
        page_copy = self.root_page.get_children().filter(slug='hello-world-2').first()

        # Check that the copy exists
        self.assertNotEqual(page_copy, None)

        # Check that the copy is live
        self.assertTrue(page_copy.live)
        self.assertFalse(page_copy.has_unpublished_changes)

        # Check that the owner of the page is set correctly
        self.assertEqual(page_copy.owner, self.user)

        # Check that the children were copied
        self.assertEqual(page_copy.get_children().count(), 2)

        # Check the the child pages
        # The child_copy should be live but the unpublished_child_copy shouldn't
        child_copy = page_copy.get_children().filter(slug='child-page').first()
        self.assertNotEqual(child_copy, None)
        self.assertTrue(child_copy.live)
        self.assertTrue(child_copy.has_unpublished_changes)

        unpublished_child_copy = page_copy.get_children().filter(slug='unpublished-child-page').first()
        self.assertNotEqual(unpublished_child_copy, None)
        self.assertFalse(unpublished_child_copy.live)
        self.assertTrue(unpublished_child_copy.has_unpublished_changes)

        # treebeard should report no consistency problems with the tree
        self.assertFalse(any(Page.find_problems()), 'treebeard found consistency problems')

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_copy_page.py" startline="363" endline="414" pcid="1922">
    def test_page_copy_no_publish_permission_post_copy_subpages_publish_copies(self):
        # This tests that unprivileged users cannot publish copied pages even if they hack their browser

        # Turn user into an editor who can add pages but not publish them
        self.user.is_superuser = False
        self.user.groups.add(
            Group.objects.get(name="Editors"),
        )
        self.user.save()

        # Post
        post_data = {
            'new_title': "Hello world 2",
            'new_slug': 'hello-world-2',
            'new_parent_page': str(self.root_page.id),
            'copy_subpages': True,
            'publish_copies': True,
            'alias': False,
        }
        response = self.client.post(reverse('wagtailadmin_pages:copy', args=(self.test_page.id, )), post_data)

        # Check that the user was redirected to the parents explore page
        self.assertRedirects(response, reverse('wagtailadmin_explore', args=(self.root_page.id, )))

        # Get copy
        page_copy = self.root_page.get_children().filter(slug='hello-world-2').first()

        # Check that the copy exists
        self.assertNotEqual(page_copy, None)

        # Check that the copy is not live
        self.assertFalse(page_copy.live)

        # Check that the owner of the page is set correctly
        self.assertEqual(page_copy.owner, self.user)

        # Check that the children were copied
        self.assertEqual(page_copy.get_children().count(), 2)

        # Check the the child pages
        # Neither of them should be live
        child_copy = page_copy.get_children().filter(slug='child-page').first()
        self.assertNotEqual(child_copy, None)
        self.assertFalse(child_copy.live)

        unpublished_child_copy = page_copy.get_children().filter(slug='unpublished-child-page').first()
        self.assertNotEqual(unpublished_child_copy, None)
        self.assertFalse(unpublished_child_copy.live)

        # treebeard should report no consistency problems with the tree
        self.assertFalse(any(Page.find_problems()), 'treebeard found consistency problems')

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_copy_page.py" startline="511" endline="558" pcid="1930">
    def test_page_copy_alias_post_copy_subpages(self):
        post_data = {
            'new_title': "Hello world 2",
            'new_slug': 'hello-world-2',
            'new_parent_page': str(self.root_page.id),
            'copy_subpages': True,
            'publish_copies': False,
            'alias': True,
        }
        response = self.client.post(reverse('wagtailadmin_pages:copy', args=(self.test_page.id, )), post_data)

        # Check that the user was redirected to the parents explore page
        self.assertRedirects(response, reverse('wagtailadmin_explore', args=(self.root_page.id, )))

        # Get copy
        page_copy = self.root_page.get_children().get(slug='hello-world-2')

        # Check the copy is an alias of the original
        self.assertEqual(page_copy.alias_of, self.test_page.page_ptr)

        # Check that the copy is live
        # Note: publish_copies is ignored. Alias pages always keep the same state as their original
        self.assertTrue(page_copy.live)
        self.assertFalse(page_copy.has_unpublished_changes)

        # Check that the owner of the page is set correctly
        self.assertEqual(page_copy.owner, self.user)

        # Check that the children were copied
        self.assertEqual(page_copy.get_children().count(), 2)

        # Check the the child pages
        # Neither of them should be live
        child_copy = page_copy.get_children().filter(slug='child-page').first()
        self.assertNotEqual(child_copy, None)
        self.assertEqual(child_copy.alias_of, self.test_child_page.page_ptr)
        self.assertTrue(child_copy.live)
        self.assertFalse(child_copy.has_unpublished_changes)

        unpublished_child_copy = page_copy.get_children().filter(slug='unpublished-child-page').first()
        self.assertNotEqual(unpublished_child_copy, None)
        self.assertEqual(unpublished_child_copy.alias_of, self.test_unpublished_child_page.page_ptr)
        self.assertFalse(unpublished_child_copy.live)
        self.assertTrue(unpublished_child_copy.has_unpublished_changes)

        # treebeard should report no consistency problems with the tree
        self.assertFalse(any(Page.find_problems()), 'treebeard found consistency problems')

</source>
</class>

<class classid="94" nclones="6" nlines="12" similarity="71">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_copy_page.py" startline="227" endline="246" pcid="1915">
    def test_page_copy_post_new_parent(self):
        post_data = {
            'new_title': "Hello world 2",
            'new_slug': 'hello-world-2',
            'new_parent_page': str(self.test_child_page.id),
            'copy_subpages': False,
            'publish_copies': False,
            'alias': False,
        }
        response = self.client.post(reverse('wagtailadmin_pages:copy', args=(self.test_page.id, )), post_data)

        # Check that the user was redirected to the new parents explore page
        self.assertRedirects(response, reverse('wagtailadmin_explore', args=(self.test_child_page.id, )))

        # Check that the page was copied to the correct place
        self.assertTrue(Page.objects.filter(slug='hello-world-2').first().get_parent(), self.test_child_page)

        # treebeard should report no consistency problems with the tree
        self.assertFalse(any(Page.find_problems()), 'treebeard found consistency problems')

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_copy_page.py" startline="290" endline="305" pcid="1918">
    def test_page_copy_post_existing_slug_to_another_parent_page(self):
        # This tests the existing slug checking on page copy when changing the parent page

        # Attempt to copy the page and changed the parent page
        post_data = {
            'new_title': "Hello world 2",
            'new_slug': 'hello-world',
            'new_parent_page': str(self.test_child_page.id),
            'copy_subpages': False,
            'alias': False,
        }
        response = self.client.post(reverse('wagtailadmin_pages:copy', args=(self.test_page.id, )), post_data)

        # Check that the user was redirected to the parents explore page
        self.assertRedirects(response, reverse('wagtailadmin_explore', args=(self.test_child_page.id, )))

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_copy_page.py" startline="325" endline="344" pcid="1920">
    def test_page_copy_post_valid_unicode_slug(self):
        post_data = {
            'new_title': "Hello wld",
            'new_slug': 'hello-wld',
            'new_parent_page': str(self.test_page.id),
            'copy_subpages': False,
            'alias': False,
        }
        response = self.client.post(reverse('wagtailadmin_pages:copy', args=(self.test_page.id, )), post_data)

        # Check response
        self.assertRedirects(response, reverse('wagtailadmin_explore', args=(self.test_page.id, )))

        # Get copy
        page_copy = self.test_page.get_children().filter(slug=post_data['new_slug']).first()

        # Check that the copy exists with the good slug
        self.assertNotEqual(page_copy, None)
        self.assertEqual(page_copy.slug, post_data['new_slug'])

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_copy_page.py" startline="306" endline="324" pcid="1919">
    def test_page_copy_post_invalid_slug(self):
        # Attempt to copy the page but set an invalid slug string
        post_data = {
            'new_title': "Hello world 2",
            'new_slug': 'hello world!',
            'new_parent_page': str(self.root_page.id),
            'copy_subpages': False,
            'alias': False,
        }
        response = self.client.post(reverse('wagtailadmin_pages:copy', args=(self.test_page.id, )), post_data)

        # Should not be redirected (as the save should fail)
        self.assertEqual(response.status_code, 200)

        # Check that a form error was raised
        self.assertFormError(
            response, 'form', 'new_slug', "Enter a valid slug consisting of Unicode letters, numbers, underscores, or hyphens."
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_copy_page.py" startline="271" endline="289" pcid="1917">
    def test_page_copy_post_and_subpages_to_same_tree_branch(self):
        # This tests that a page cannot be copied into itself when copying subpages
        post_data = {
            'new_title': "Hello world 2",
            'new_slug': 'hello-world',
            'new_parent_page': str(self.test_child_page.id),
            'copy_subpages': True,
            'alias': False,
        }
        response = self.client.post(reverse('wagtailadmin_pages:copy', args=(self.test_page.id,)), post_data)

        # Should not be redirected (as the save should fail)
        self.assertEqual(response.status_code, 200)

        # Check that a form error was raised
        self.assertFormError(
            response, 'form', 'new_parent_page', "You cannot copy a page into itself when copying subpages"
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_copy_page.py" startline="247" endline="270" pcid="1916">
    def test_page_copy_post_existing_slug_within_same_parent_page(self):
        # This tests the existing slug checking on page copy when not changing the parent page

        # Attempt to copy the page but forget to change the slug
        post_data = {
            'new_title': "Hello world 2",
            'new_slug': 'hello-world',
            'new_parent_page': str(self.root_page.id),
            'copy_subpages': False,
            'alias': False,
        }
        response = self.client.post(reverse('wagtailadmin_pages:copy', args=(self.test_page.id, )), post_data)

        # Should not be redirected (as the save should fail)
        self.assertEqual(response.status_code, 200)

        # Check that a form error was raised
        self.assertFormError(
            response,
            'form',
            'new_slug',
            "This slug is already in use within the context of its parent page \"Welcome to your new Wagtail site!\""
        )

</source>
</class>

<class classid="95" nclones="2" nlines="19" similarity="88">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_copy_page.py" startline="428" endline="451" pcid="1925">
    def test_before_copy_page_hook_post(self):
        def hook_func(request, page):
            self.assertIsInstance(request, HttpRequest)
            self.assertIsInstance(page.specific, SimplePage)

            return HttpResponse("Overridden!")

        with self.register_hook('before_copy_page', hook_func):
            post_data = {
                'new_title': "Hello world 2",
                'new_slug': 'hello-world-2',
                'new_parent_page': str(self.root_page.id),
                'copy_subpages': False,
                'publish_copies': False,
                'alias': False,
            }
            response = self.client.post(reverse('wagtailadmin_pages:copy', args=(self.test_page.id,)), post_data)

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")

        # page should not be copied
        self.assertFalse(Page.objects.filter(title="Hello world 2").exists())

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_copy_page.py" startline="452" endline="476" pcid="1927">
    def test_after_copy_page_hook(self):
        def hook_func(request, page, new_page):
            self.assertIsInstance(request, HttpRequest)
            self.assertIsInstance(page.specific, SimplePage)
            self.assertIsInstance(new_page.specific, SimplePage)

            return HttpResponse("Overridden!")

        with self.register_hook('after_copy_page', hook_func):
            post_data = {
                'new_title': "Hello world 2",
                'new_slug': 'hello-world-2',
                'new_parent_page': str(self.root_page.id),
                'copy_subpages': False,
                'publish_copies': False,
                'alias': False,
            }
            response = self.client.post(reverse('wagtailadmin_pages:copy', args=(self.test_page.id,)), post_data)

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")

        # page should be copied
        self.assertTrue(Page.objects.filter(title="Hello world 2").exists())

</source>
</class>

<class classid="96" nclones="2" nlines="16" similarity="76">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_bulk_actions/test_bulk_unpublish.py" startline="17" endline="37" pcid="1934">
    def setUp(self):
        # Create pages to unpublish
        self.root_page = Page.objects.get(id=2)
        self.child_pages = [
            SimplePage(title=f"Hello world!-{i}", slug=f"hello-world-{i}", content=f"hello-{i}")
            for i in range(1, 5)
        ]
        # first three child pages will be unpublished
        self.pages_to_be_unpublished = self.child_pages[:3]
        self.pages_not_to_be_unpublished = self.child_pages[3:]
        for child_page in self.child_pages:
            self.root_page.add_child(instance=child_page)

        self.url = reverse('wagtail_bulk_action', args=('wagtailcore', 'page', 'unpublish', )) + '?'
        for child_page in self.pages_to_be_unpublished:
            self.url += f'&id={child_page.id}'
        self.redirect_url = reverse('wagtailadmin_explore', args=(self.root_page.id, ))

        # Login
        self.user = self.login()

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_bulk_actions/test_bulk_publish.py" startline="17" endline="41" pcid="1959">
    def setUp(self):
        self.root_page = Page.objects.get(id=2)

        # Add child pages
        self.child_pages = [
            SimplePage(title=f"Hello world!-{i}", slug=f"hello-world-{i}", content=f"Hello world {i}!", live=False)
            for i in range(1, 5)
        ]
        self.pages_to_be_published = self.child_pages[:3]
        self.pages_not_to_be_published = self.child_pages[3:]

        for child_page in self.child_pages:
            self.root_page.add_child(instance=child_page)

        for i, child_page in enumerate(self.child_pages):
            child_page.content = f"Hello updated world {i}!"
            child_page.save_revision()

        self.url = reverse('wagtail_bulk_action', args=('wagtailcore', 'page', 'publish', )) + '?'
        for child_page in self.pages_to_be_published:
            self.url += f'id={child_page.id}&'
        self.redirect_url = reverse('wagtailadmin_explore', args=(self.root_page.id, ))

        self.user = self.login()

</source>
</class>

<class classid="97" nclones="10" nlines="12" similarity="73">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_bulk_actions/test_bulk_unpublish.py" startline="59" endline="82" pcid="1937">
    def test_unpublish_view_bad_permissions(self):
        """
        This tests that the unpublish view doesn't allow users without unpublish permissions
        """
        # Remove privileges from user
        self.user.is_superuser = False
        self.user.user_permissions.add(
            Permission.objects.get(content_type__app_label='wagtailadmin', codename='access_admin')
        )
        self.user.save()

        # Request confirm unpublish page
        response = self.client.get(self.url)

        # Check that the user received a 200 redirected response
        self.assertEqual(response.status_code, 200)

        html = response.content.decode()

        self.assertInHTML("<p>You don't have permission to unpublish these pages</p>", html)

        for child_page in self.pages_to_be_unpublished:
            self.assertInHTML('<li>{page_title}</li>'.format(page_title=child_page.title), html)

</source>
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_bulk_actions/test_bulk_add_to_collection.py" startline="28" endline="49" pcid="5275">
    def test_add_to_collection_with_limited_permissions(self):
        self.user.is_superuser = False
        self.user.user_permissions.add(
            Permission.objects.get(content_type__app_label='wagtailadmin', codename='access_admin')
        )
        self.user.save()

        response = self.client.get(self.url)
        self.assertEqual(response.status_code, 200)

        html = response.content.decode()
        self.assertInHTML("<p>You don't have permission to add these images to a collection</p>", html)

        for image in self.images:
            self.assertInHTML('<li>{image_title}</li>'.format(image_title=image.title), html)

        response = self.client.post(self.url, self.post_data)

        # Images should not be moved to new collection
        for image in self.images:
            self.assertEqual(Image.objects.get(id=image.id).collection_id, self.root_collection.id)

</source>
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_bulk_actions/test_bulk_add_tags.py" startline="30" endline="51" pcid="5280">
    def test_add_tags_with_limited_permissions(self):
        self.user.is_superuser = False
        self.user.user_permissions.add(
            Permission.objects.get(content_type__app_label='wagtailadmin', codename='access_admin')
        )
        self.user.save()

        response = self.client.get(self.url)
        self.assertEqual(response.status_code, 200)

        html = response.content.decode()
        self.assertInHTML("<p>You don't have permission to add tags to these images</p>", html)

        for image in self.images:
            self.assertInHTML('<li>{image_title}</li>'.format(image_title=image.title), html)

        response = self.client.post(self.url, self.post_data)

        # New tags should not be added to the images
        for image in self.images:
            self.assertCountEqual(get_tag_list(Image.objects.get(id=image.id)), [])

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_bulk_actions/test_bulk_publish.py" startline="66" endline="89" pcid="1962">
    def test_publish_view_bad_permissions(self):
        """
        This tests that the publish view doesn't allow users without publish permissions
        """
        # Remove privileges from user
        self.user.is_superuser = False
        self.user.user_permissions.add(
            Permission.objects.get(content_type__app_label='wagtailadmin', codename='access_admin')
        )
        self.user.save()

        # Request confirm publish page
        response = self.client.get(self.url)

        # Check that the user received a 200 redirected response
        self.assertEqual(response.status_code, 200)

        html = response.content.decode()

        self.assertInHTML("<p>You don't have permission to publish these pages</p>", html)

        for child_page in self.pages_to_be_published:
            self.assertInHTML('<li>{page_title}</li>'.format(page_title=child_page.title), html)

</source>
<source file="systems/wagtail-2.16.1/wagtail/documents/tests/test_bulk_actions/test_bulk_delete.py" startline="25" endline="48" pcid="4839">
    def test_delete_with_limited_permissions(self):
        self.user.is_superuser = False
        self.user.user_permissions.add(
            Permission.objects.get(content_type__app_label='wagtailadmin', codename='access_admin')
        )
        self.user.save()

        response = self.client.get(self.url)
        self.assertEqual(response.status_code, 200)

        html = response.content.decode()
        self.assertInHTML("<p>You don't have permission to delete these documents</p>", html)

        for document in self.documents:
            self.assertInHTML('<li>{document_title}</li>'.format(document_title=document.title), html)

        response = self.client.post(self.url)
        # User should be redirected back to the index
        self.assertEqual(response.status_code, 302)

        # Documents should not be deleted
        for document in self.documents:
            self.assertTrue(Document.objects.filter(id=document.id).exists())

</source>
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_bulk_actions/test_bulk_delete.py" startline="27" endline="50" pcid="5284">
    def test_delete_with_limited_permissions(self):
        self.user.is_superuser = False
        self.user.user_permissions.add(
            Permission.objects.get(content_type__app_label='wagtailadmin', codename='access_admin')
        )
        self.user.save()

        response = self.client.get(self.url)
        self.assertEqual(response.status_code, 200)

        html = response.content.decode()
        self.assertInHTML("<p>You don't have permission to delete these images</p>", html)

        for image in self.images:
            self.assertInHTML('<li>{image_title}</li>'.format(image_title=image.title), html)

        response = self.client.post(self.url)
        # User should be redirected back to the index
        self.assertEqual(response.status_code, 302)

        # Images should not be deleted
        for image in self.images:
            self.assertTrue(Image.objects.filter(id=image.id).exists())

</source>
<source file="systems/wagtail-2.16.1/wagtail/documents/tests/test_bulk_actions/test_bulk_add_to_collection.py" startline="26" endline="47" pcid="4830">
    def test_add_to_collection_with_limited_permissions(self):
        self.user.is_superuser = False
        self.user.user_permissions.add(
            Permission.objects.get(content_type__app_label='wagtailadmin', codename='access_admin')
        )
        self.user.save()

        response = self.client.get(self.url)
        self.assertEqual(response.status_code, 200)

        html = response.content.decode()
        self.assertInHTML("<p>You don't have permission to add these documents to a collection</p>", html)

        for document in self.documents:
            self.assertInHTML('<li>{document_title}</li>'.format(document_title=document.title), html)

        response = self.client.post(self.url, self.post_data)

        # Documents should not be moved to new collection
        for document in self.documents:
            self.assertEqual(Document.objects.get(id=document.id).collection_id, self.root_collection.id)

</source>
<source file="systems/wagtail-2.16.1/wagtail/documents/tests/test_bulk_actions/test_bulk_add_tags.py" startline="28" endline="49" pcid="4835">
    def test_add_tags_with_limited_permissions(self):
        self.user.is_superuser = False
        self.user.user_permissions.add(
            Permission.objects.get(content_type__app_label='wagtailadmin', codename='access_admin')
        )
        self.user.save()

        response = self.client.get(self.url)
        self.assertEqual(response.status_code, 200)

        html = response.content.decode()
        self.assertInHTML("<p>You don't have permission to add tags to these documents</p>", html)

        for document in self.documents:
            self.assertInHTML('<li>{document_title}</li>'.format(document_title=document.title), html)

        response = self.client.post(self.url, self.post_data)

        # New tags should not be added to the documents
        for document in self.documents:
            self.assertCountEqual(get_tag_list(Document.objects.get(id=document.id)), [])

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_bulk_actions/test_bulk_move.py" startline="78" endline="99" pcid="1950">
    def test_bulk_move_bad_permissions(self):
        # Remove privileges from user
        self.user.is_superuser = False
        self.user.user_permissions.add(
            Permission.objects.get(content_type__app_label='wagtailadmin', codename='access_admin')
        )
        self.user.save()

        # Get move page
        response = self.client.get(self.url)

        self.assertEqual(response.status_code, 200)

        html = response.content.decode()

        self.assertInHTML("<p>You don't have permission to move these pages</p>", html)

        for child_page in self.pages_to_be_moved:
            self.assertInHTML('<li>{page_title}</li>'.format(page_title=child_page.title), html)

        self.assertTagInHTML('''<form action="{}" method="POST"></form>'''.format(self.url), html, count=0)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_bulk_actions/test_bulk_delete.py" startline="86" endline="112" pcid="1976">
    def test_page_delete_bad_permissions(self):
        # Remove privileges from user
        self.user.is_superuser = False
        self.user.user_permissions.add(
            Permission.objects.get(content_type__app_label='wagtailadmin', codename='access_admin')
        )
        self.user.save()

        # Get delete page
        response = self.client.get(self.url)

        # Check that the user received a 200 redirect response
        self.assertEqual(response.status_code, 200)

        # Check that the deletion has not happened
        for child_page in self.child_pages:
            self.assertTrue(SimplePage.objects.filter(id=child_page.id).exists())

        html = response.content.decode()

        self.assertInHTML("<p>You don't have permission to delete these pages</p>", html)

        for child_page in self.pages_to_be_deleted:
            self.assertInHTML('<li>{page_title}</li>'.format(page_title=child_page.title), html)

        self.assertTagInHTML('''<form action="{}" method="POST"></form>'''.format(self.url), html, count=0)

</source>
</class>

<class classid="98" nclones="2" nlines="16" similarity="82">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_bulk_actions/test_bulk_unpublish.py" startline="83" endline="113" pcid="1938">
    def test_unpublish_view_post(self):
        """
        This posts to the unpublish view and checks that the page was unpublished
        """
        # Connect a mock signal handler to page_unpublished signal
        mock_handler = mock.MagicMock()
        page_unpublished.connect(mock_handler)

        # Post to the unpublish page
        response = self.client.post(self.url)

        # Should be redirected to explorer page
        self.assertEqual(response.status_code, 302)

        # Check that the child pages were unpublished
        for child_page in self.pages_to_be_unpublished:
            self.assertFalse(SimplePage.objects.get(id=child_page.id).live)

        # Check that the child pages not to be unpublished remain
        for child_page in self.pages_not_to_be_unpublished:
            self.assertTrue(SimplePage.objects.get(id=child_page.id).live)

        # Check that the page_unpublished signal was fired
        self.assertEqual(mock_handler.call_count, len(self.pages_to_be_unpublished))

        for i, child_page in enumerate(self.pages_to_be_unpublished):
            mock_call = mock_handler.mock_calls[i][2]
            self.assertEqual(mock_call['sender'], child_page.specific_class)
            self.assertEqual(mock_call['instance'], child_page)
            self.assertIsInstance(mock_call['instance'], child_page.specific_class)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_bulk_actions/test_bulk_publish.py" startline="90" endline="122" pcid="1963">
    def test_publish_view_post(self):
        """
        This posts to the publish view and checks that the page was published
        """
        # Connect a mock signal handler to page_published signal
        mock_handler = mock.MagicMock()
        page_published.connect(mock_handler)

        # Post to the publish page
        response = self.client.post(self.url)

        # Should be redirected to explorer page
        self.assertEqual(response.status_code, 302)

        # Check that the child pages were published
        for child_page in self.pages_to_be_published:
            published_page = SimplePage.objects.get(id=child_page.id)
            self.assertTrue(published_page.live)
            self.assertIn("Hello updated", published_page.content)

        # Check that the child pages not to be published remain
        for child_page in self.pages_not_to_be_published:
            self.assertFalse(Page.objects.get(id=child_page.id).live)

        # Check that the page_published signal was fired
        self.assertEqual(mock_handler.call_count, len(self.pages_to_be_published))

        for i, child_page in enumerate(self.pages_to_be_published):
            mock_call = mock_handler.mock_calls[i][2]
            self.assertEqual(mock_call['sender'], child_page.specific_class)
            self.assertEqual(mock_call['instance'], child_page)
            self.assertIsInstance(mock_call['instance'], child_page.specific_class)

</source>
</class>

<class classid="99" nclones="2" nlines="22" similarity="95">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_bulk_actions/test_bulk_unpublish.py" startline="167" endline="200" pcid="1944">
    def setUp(self):
        # Find root page
        self.root_page = Page.objects.get(id=2)

        self.child_pages = [
            SimplePage(title=f"Hello world!-{i}", slug=f"hello-world-{i}", content=f"hello-{i}")
            for i in range(1, 5)
        ]
        # first three child pages will be unpublished
        self.pages_to_be_unpublished = self.child_pages[:3]
        self.pages_not_to_be_unpublished = self.child_pages[3:]
        for child_page in self.child_pages:
            self.root_page.add_child(instance=child_page)

        # map of the form { page: [child_pages] } to be added
        self.grandchildren_pages = {
            self.pages_to_be_unpublished[0]: [SimplePage(title="Hello world!-a", slug="hello-world-a", content="hello-a")],
            self.pages_to_be_unpublished[1]: [
                SimplePage(title="Hello world!-b", slug="hello-world-b", content="hello-b"),
                SimplePage(title="Hello world!-c", slug="hello-world-c", content="hello-c")
            ]
        }

        for child_page, grandchild_pages in self.grandchildren_pages.items():
            for grandchild_page in grandchild_pages:
                child_page.add_child(instance=grandchild_page)

        self.url = reverse('wagtail_bulk_action', args=('wagtailcore', 'page', 'unpublish', )) + '?'
        for child_page in self.pages_to_be_unpublished:
            self.url += f'&id={child_page.id}'
        self.redirect_url = reverse('wagtailadmin_explore', args=(self.root_page.id, ))

        self.user = self.login()

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_bulk_actions/test_bulk_delete.py" startline="18" endline="52" pcid="1973">
    def setUp(self):
        # Find root page
        self.root_page = Page.objects.get(id=2)

        # Add child pages
        self.child_pages = [
            SimplePage(title=f"Hello world!-{i}", slug=f"hello-world-{i}", content=f"hello-{i}")
            for i in range(1, 5)
        ]
        # first three child pages will be deleted
        self.pages_to_be_deleted = self.child_pages[:3]
        self.pages_not_to_be_deleted = self.child_pages[3:]
        for child_page in self.child_pages:
            self.root_page.add_child(instance=child_page)

        # map of the form { page: [child_pages] } to be added
        self.grandchildren_pages = {
            self.pages_to_be_deleted[0]: [SimplePage(title="Hello world!-a", slug="hello-world-a", content="hello-a")],
            self.pages_to_be_deleted[1]: [
                SimplePage(title="Hello world!-b", slug="hello-world-b", content="hello-b"),
                SimplePage(title="Hello world!-c", slug="hello-world-c", content="hello-c")
            ]
        }

        for child_page, grandchild_pages in self.grandchildren_pages.items():
            for grandchild_page in grandchild_pages:
                child_page.add_child(instance=grandchild_page)

        self.url = reverse('wagtail_bulk_action', args=('wagtailcore', 'page', 'delete', )) + '?'
        for child_page in self.pages_to_be_deleted:
            self.url += f'&id={child_page.id}'

        # Login
        self.user = self.login()

</source>
</class>

<class classid="100" nclones="2" nlines="22" similarity="76">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_bulk_actions/test_bulk_move.py" startline="19" endline="65" pcid="1948">
    def setUp(self):
        # Find root page
        self.root_page = Page.objects.get(id=2)

        # Create three sections
        self.section_a = SimplePage(title="Section A", slug="section-a", content="hello")
        self.root_page.add_child(instance=self.section_a)

        self.section_b = SimplePage(title="Section B", slug="section-b", content="hello")
        self.root_page.add_child(instance=self.section_b)

        self.section_c = SimplePage(title="Section C", slug="section-c", content="hello")
        self.root_page.add_child(instance=self.section_c)

        # Add test page A into section A
        self.test_page_a = SimplePage(title="Hello world!", slug="hello-world-a", content="hello")
        self.section_a.add_child(instance=self.test_page_a)

        # Add test page B into section C
        self.test_page_b = SimplePage(title="Hello world!", slug="hello-world-b", content="hello")
        self.section_c.add_child(instance=self.test_page_b)

        # Add test page B_1 into section C
        self.test_page_b_1 = SimplePage(title="Hello world!", slug="hello-world-b-1", content="hello")
        self.section_c.add_child(instance=self.test_page_b_1)

        # Add test page A_1 into section C having same slug as test page A
        self.test_page_a_1 = SimplePage(title="Hello world!", slug="hello-world-a", content="hello")
        self.section_c.add_child(instance=self.test_page_a_1)

        # Add unpublished page to the root with a child page
        self.unpublished_page = SimplePage(title="Unpublished", slug="unpublished", content="hello")
        sub_page = SimplePage(title="Sub Page", slug="sub-page", content="child")
        self.root_page.add_child(instance=self.unpublished_page)
        self.unpublished_page.add_child(instance=sub_page)

        # unpublish pages last (used to validate the edit only permission)
        self.unpublished_page.unpublish()
        sub_page.unpublish()

        self.pages_to_be_moved = [self.test_page_b, self.test_page_b_1]

        self.url = reverse('wagtail_bulk_action', args=('wagtailcore', 'page', 'move', )) + f'?id={self.test_page_b.id}&id={self.test_page_b_1.id}'

        # Login
        self.user = self.login()

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_move_page.py" startline="20" endline="54" pcid="1987">
    def setUp(self):
        # Find root page
        self.root_page = Page.objects.get(id=2)

        # Create three sections
        self.section_a = SimplePage(title="Section A", slug="section-a", content="hello")
        self.root_page.add_child(instance=self.section_a)

        self.section_b = SimplePage(title="Section B", slug="section-b", content="hello")
        self.root_page.add_child(instance=self.section_b)

        self.section_c = SimplePage(title="Section C", slug="section-c", content="hello")
        self.root_page.add_child(instance=self.section_c)

        # Add test page A into section A
        self.test_page_a = SimplePage(title="Hello world!", slug="hello-world", content="hello")
        self.section_a.add_child(instance=self.test_page_a)

        # Add test page B into section C
        self.test_page_b = SimplePage(title="Hello world!", slug="hello-world", content="hello")
        self.section_c.add_child(instance=self.test_page_b)

        # Add unpublished page to the root with a child page
        self.unpublished_page = SimplePage(title="Unpublished", slug="unpublished", content="hello")
        sub_page = SimplePage(title="Sub Page", slug="sub-page", content="child")
        self.root_page.add_child(instance=self.unpublished_page)
        self.unpublished_page.add_child(instance=sub_page)

        # unpublish pages last (used to validate the edit only permission)
        self.unpublished_page.unpublish()
        sub_page.unpublish()

        # Login
        self.user = self.login()

</source>
</class>

<class classid="101" nclones="2" nlines="18" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_bulk_actions/test_bulk_move.py" startline="203" endline="228" pcid="1955">
    def test_before_bulk_move_hook(self):

        def hook_func(request, action_type, pages, action_class_instance):
            self.assertEqual(action_type, 'move')
            self.assertIsInstance(request, HttpRequest)
            self.assertIsInstance(action_class_instance, PageBulkAction)
            for i, page in enumerate(pages):
                self.assertEqual(page.id, self.pages_to_be_moved[i].id)

            return HttpResponse("Overridden!")

        with self.register_hook('before_bulk_action', hook_func):
            response = self.client.post(self.url, {'chooser': self.section_b.id})

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")

        self.assertEqual(
            Page.objects.get(id=self.test_page_b.id).get_parent().id,
            self.section_c.id
        )
        self.assertEqual(
            Page.objects.get(id=self.test_page_b_1.id).get_parent().id,
            self.section_c.id
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_bulk_actions/test_bulk_move.py" startline="229" endline="254" pcid="1957">
    def test_after_bulk_move_hook(self):

        def hook_func(request, action_type, pages, action_class_instance):
            self.assertEqual(action_type, 'move')
            self.assertIsInstance(request, HttpRequest)
            self.assertIsInstance(action_class_instance, PageBulkAction)
            for i, page in enumerate(pages):
                self.assertEqual(page.id, self.pages_to_be_moved[i].id)

            return HttpResponse("Overridden!")

        with self.register_hook('after_bulk_action', hook_func):
            response = self.client.post(self.url, {'chooser': self.section_b.id})

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")

        # pages should be moved
        self.assertEqual(
            Page.objects.get(id=self.test_page_b.id).get_parent().id,
            self.section_b.id
        )
        self.assertEqual(
            Page.objects.get(id=self.test_page_b_1.id).get_parent().id,
            self.section_b.id
        )
</source>
</class>

<class classid="102" nclones="2" nlines="27" similarity="85">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_bulk_actions/test_bulk_delete.py" startline="113" endline="152" pcid="1977">
    def test_bulk_delete_post(self):
        # Connect a mock signal handler to page_unpublished signal
        mock_handler = mock.MagicMock()
        page_unpublished.connect(mock_handler)

        # Post
        response = self.client.post(self.url)

        # Should be redirected to explorer page
        self.assertEqual(response.status_code, 302)

        # treebeard should report no consistency problems with the tree
        self.assertFalse(any(Page.find_problems()), 'treebeard found consistency problems')

        # Check that the child pages to be deleted are gone
        for child_page in self.pages_to_be_deleted:
            self.assertFalse(SimplePage.objects.filter(id=child_page.id).exists())

        # Check that the child pages not to be deleted remain
        for child_page in self.pages_not_to_be_deleted:
            self.assertTrue(SimplePage.objects.filter(id=child_page.id).exists())

        # Check that the page_unpublished signal was fired for all pages
        num_descendants = sum(len(i) for i in self.grandchildren_pages.values())
        self.assertEqual(mock_handler.call_count, len(self.pages_to_be_deleted) + num_descendants)

        i = 0
        for child_page in self.pages_to_be_deleted:
            mock_call = mock_handler.mock_calls[i][2]
            i += 1
            self.assertEqual(mock_call['sender'], child_page.specific_class)
            self.assertEqual(mock_call['instance'], child_page)
            self.assertIsInstance(mock_call['instance'], child_page.specific_class)
            for grandchildren_page in self.grandchildren_pages.get(child_page, []):
                mock_call = mock_handler.mock_calls[i][2]
                i += 1
                self.assertEqual(mock_call['sender'], grandchildren_page.specific_class)
                self.assertEqual(mock_call['instance'], grandchildren_page)
                self.assertIsInstance(mock_call['instance'], grandchildren_page.specific_class)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_bulk_actions/test_bulk_delete.py" startline="153" endline="201" pcid="1978">
    def test_bulk_delete_notlive_post(self):
        # Same as above, but this makes sure the page_unpublished signal is not fired
        # for the page that is not live when it is deleted

        # Unpublish the first child page
        page_to_be_unpublished = self.pages_to_be_deleted[0]
        page_to_be_unpublished.unpublish(user=self.user)

        # Connect a mock signal handler to page_unpublished signal
        mock_handler = mock.MagicMock()
        page_unpublished.connect(mock_handler)

        # Post
        response = self.client.post(self.url)

        # Should be redirected to explorer page
        self.assertEqual(response.status_code, 302)

        # treebeard should report no consistency problems with the tree
        self.assertFalse(any(Page.find_problems()), 'treebeard found consistency problems')

        # Check that the child pages to be deleted are gone
        for child_page in self.pages_to_be_deleted:
            self.assertFalse(SimplePage.objects.filter(id=child_page.id).exists())

        # Check that the child pages not to be deleted remain
        for child_page in self.pages_not_to_be_deleted:
            self.assertTrue(SimplePage.objects.filter(id=child_page.id).exists())

        # Check that the page_unpublished signal was not fired
        num_descendants = sum(len(v) for v in self.grandchildren_pages.values())
        self.assertEqual(mock_handler.call_count, len(self.pages_to_be_deleted) + num_descendants - 1)

        # check that only signals for other pages are fired
        i = 0
        for child_page in self.pages_to_be_deleted:
            if child_page.id != page_to_be_unpublished.id:
                mock_call = mock_handler.mock_calls[i][2]
                i += 1
                self.assertEqual(mock_call['sender'], child_page.specific_class)
                self.assertEqual(mock_call['instance'], child_page)
                self.assertIsInstance(mock_call['instance'], child_page.specific_class)
            for grandchildren_page in self.grandchildren_pages.get(child_page, []):
                mock_call = mock_handler.mock_calls[i][2]
                i += 1
                self.assertEqual(mock_call['sender'], grandchildren_page.specific_class)
                self.assertEqual(mock_call['instance'], grandchildren_page)
                self.assertIsInstance(mock_call['instance'], grandchildren_page.specific_class)

</source>
</class>

<class classid="103" nclones="3" nlines="12" similarity="76">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_move_page.py" startline="170" endline="183" pcid="1995">
    def test_before_move_page_hook(self):
        def hook_func(request, page, destination):
            self.assertIsInstance(request, HttpRequest)
            self.assertIsInstance(page.specific, SimplePage)
            self.assertIsInstance(destination.specific, SimplePage)

            return HttpResponse("Overridden!")

        with self.register_hook('before_move_page', hook_func):
            response = self.client.get(reverse('wagtailadmin_pages:move_confirm', args=(self.test_page_a.id, self.section_b.id)))

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_move_page.py" startline="184" endline="203" pcid="1997">
    def test_before_move_page_hook_post(self):
        def hook_func(request, page, destination):
            self.assertIsInstance(request, HttpRequest)
            self.assertIsInstance(page.specific, SimplePage)
            self.assertIsInstance(destination.specific, SimplePage)

            return HttpResponse("Overridden!")

        with self.register_hook('before_move_page', hook_func):
            response = self.client.post(reverse('wagtailadmin_pages:move_confirm', args=(self.test_page_a.id, self.section_b.id)))

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")

        # page should not be moved
        self.assertEqual(
            Page.objects.get(id=self.test_page_a.id).get_parent().id,
            self.section_a.id
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_move_page.py" startline="204" endline="221" pcid="1999">
    def test_after_move_page_hook(self):
        def hook_func(request, page):
            self.assertIsInstance(request, HttpRequest)
            self.assertIsInstance(page.specific, SimplePage)

            return HttpResponse("Overridden!")

        with self.register_hook('after_move_page', hook_func):
            response = self.client.post(reverse('wagtailadmin_pages:move_confirm', args=(self.test_page_a.id, self.section_b.id)))

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")

        # page should be moved
        self.assertEqual(
            Page.objects.get(id=self.test_page_a.id).get_parent().id,
            self.section_b.id
        )
</source>
</class>

<class classid="104" nclones="3" nlines="20" similarity="81">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_page_search.py" startline="99" endline="124" pcid="2011">
    def test_search_order_by_title(self):
        root_page = Page.objects.get(id=2)
        new_event = SingleEventPage(
            title="Lunar event",
            location='the moon', audience='public',
            cost='free', date_from='2001-01-01',
            latest_revision_created_at=local_datetime(2016, 1, 1)
        )
        root_page.add_child(instance=new_event)

        new_event_2 = SingleEventPage(
            title="A Lunar event",
            location='the moon', audience='public',
            cost='free', date_from='2001-01-01',
            latest_revision_created_at=local_datetime(2016, 1, 1)
        )
        root_page.add_child(instance=new_event_2)

        response = self.get({'q': 'Lunar', 'ordering': 'title'})
        page_ids = [page.id for page in response.context['pages']]
        self.assertEqual(page_ids, [new_event_2.id, new_event.id])

        response = self.get({'q': 'Lunar', 'ordering': '-title'})
        page_ids = [page.id for page in response.context['pages']]
        self.assertEqual(page_ids, [new_event.id, new_event_2.id])

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_page_search.py" startline="151" endline="178" pcid="2013">
    def test_search_order_by_status(self):
        root_page = Page.objects.get(id=2)
        live_event = SingleEventPage(
            title="Lunar event",
            location='the moon', audience='public',
            cost='free', date_from='2001-01-01',
            latest_revision_created_at=local_datetime(2016, 1, 1),
            live=True
        )
        root_page.add_child(instance=live_event)

        draft_event = SingleEventPage(
            title="Lunar event",
            location='the moon', audience='public',
            cost='free', date_from='2001-01-01',
            latest_revision_created_at=local_datetime(2016, 1, 1),
            live=False
        )
        root_page.add_child(instance=draft_event)

        response = self.get({'q': 'Lunar', 'ordering': 'live'})
        page_ids = [page.id for page in response.context['pages']]
        self.assertEqual(page_ids, [draft_event.id, live_event.id])

        response = self.get({'q': 'Lunar', 'ordering': '-live'})
        page_ids = [page.id for page in response.context['pages']]
        self.assertEqual(page_ids, [live_event.id, draft_event.id])

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_page_search.py" startline="125" endline="150" pcid="2012">
    def test_search_order_by_updated(self):
        root_page = Page.objects.get(id=2)
        new_event = SingleEventPage(
            title="Lunar event",
            location='the moon', audience='public',
            cost='free', date_from='2001-01-01',
            latest_revision_created_at=local_datetime(2016, 1, 1)
        )
        root_page.add_child(instance=new_event)

        new_event_2 = SingleEventPage(
            title="Lunar event 2",
            location='the moon', audience='public',
            cost='free', date_from='2001-01-01',
            latest_revision_created_at=local_datetime(2015, 1, 1)
        )
        root_page.add_child(instance=new_event_2)

        response = self.get({'q': 'Lunar', 'ordering': 'latest_revision_created_at'})
        page_ids = [page.id for page in response.context['pages']]
        self.assertEqual(page_ids, [new_event_2.id, new_event.id])

        response = self.get({'q': 'Lunar', 'ordering': '-latest_revision_created_at'})
        page_ids = [page.id for page in response.context['pages']]
        self.assertEqual(page_ids, [new_event.id, new_event_2.id])

</source>
</class>

<class classid="105" nclones="2" nlines="11" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_preview.py" startline="64" endline="78" pcid="2016">
def clear_edit_handler(page_cls):
    def decorator(fn):
        @wraps(fn)
        def decorated(*args, **kwargs):
            # Clear any old EditHandlers generated
            page_cls.get_edit_handler.cache_clear()
            try:
                fn(*args, **kwargs)
            finally:
                # Clear the bad EditHandler generated just now
                page_cls.get_edit_handler.cache_clear()
        return decorated
    return decorator


</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_edit_handlers.py" startline="151" endline="165" pcid="2499">
def clear_edit_handler(page_cls):
    def decorator(fn):
        @wraps(fn)
        def decorated(*args, **kwargs):
            # Clear any old EditHandlers generated
            page_cls.get_edit_handler.cache_clear()
            try:
                fn(*args, **kwargs)
            finally:
                # Clear the bad EditHandler generated just now
                page_cls.get_edit_handler.cache_clear()
        return decorated
    return decorator


</source>
</class>

<class classid="106" nclones="2" nlines="14" similarity="92">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_preview.py" startline="125" endline="146" pcid="2020">
    def test_preview_on_create_with_m2m_field(self):
        preview_url = reverse('wagtailadmin_pages:preview_on_add',
                              args=('tests', 'eventpage', self.home_page.id))
        response = self.client.post(preview_url, self.post_data)

        # Check the JSON response
        self.assertEqual(response.status_code, 200)
        self.assertJSONEqual(response.content.decode(), {'is_valid': True})

        # Check the user can refresh the preview
        preview_session_key = 'wagtail-preview-tests-eventpage-{}'.format(self.home_page.id)
        self.assertTrue(preview_session_key in self.client.session)

        response = self.client.get(preview_url)

        # Check the HTML response
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'tests/event_page.html')
        self.assertContains(response, "Beach party")
        self.assertContains(response, "<li>Parties</li>")
        self.assertContains(response, "<li>Holidays</li>")

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/pages/test_preview.py" startline="147" endline="168" pcid="2021">
    def test_preview_on_edit_with_m2m_field(self):
        preview_url = reverse('wagtailadmin_pages:preview_on_edit',
                              args=(self.event_page.id,))
        response = self.client.post(preview_url, self.post_data)

        # Check the JSON response
        self.assertEqual(response.status_code, 200)
        self.assertJSONEqual(response.content.decode(), {'is_valid': True})

        # Check the user can refresh the preview
        preview_session_key = 'wagtail-preview-{}'.format(self.event_page.id)
        self.assertTrue(preview_session_key in self.client.session)

        response = self.client.get(preview_url)

        # Check the HTML response
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'tests/event_page.html')
        self.assertContains(response, "Beach party")
        self.assertContains(response, "<li>Parties</li>")
        self.assertContains(response, "<li>Holidays</li>")

</source>
</class>

<class classid="107" nclones="2" nlines="10" similarity="90">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_rich_text.py" startline="706" endline="718" pcid="2113">
    def test_default_features(self):
        widget = HalloRichTextArea()

        result = widget.render(
            'foo',
            '<p>a <a linktype="page" id="3">page</a> and a <a linktype="document" id="1">document</a></p>',
            {'id': 'id_foo'},
        )
        soup = BeautifulSoup(result, 'html.parser')
        result_value = soup.textarea.string

        self.assertHTMLEqual(result_value, '<p>a <a data-linktype="page" data-id="3" data-parent-id="2" href="/events/">page</a> and a <a data-linktype="document" data-id="1" href="/documents/1/test.pdf">document</a></p>')

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_rich_text.py" startline="719" endline="732" pcid="2114">
    def test_custom_features(self):
        widget = HalloRichTextArea(features=['h1', 'link', 'somethingijustmadeup'])

        result = widget.render(
            'foo',
            '<p>a <a linktype="page" id="3">page</a> and a <a linktype="document" id="1">document</a></p>',
            {'id': 'id_foo'},
        )
        soup = BeautifulSoup(result, 'html.parser')
        result_value = soup.textarea.string

        self.assertHTMLEqual(result_value, '<p>a <a data-linktype="page" data-id="3" data-parent-id="2" href="/events/">page</a> and a <a>document</a></p>')


</source>
</class>

<class classid="108" nclones="2" nlines="14" similarity="84">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_filters.py" startline="33" endline="56" pcid="2234">
    def test_with_relation(self):

        class UserForm(forms.Form):
            users = FilteredModelChoiceField(
                queryset=User.objects.order_by(User.USERNAME_FIELD), filter_field='id_group', filter_accessor='groups'
            )

        form = UserForm()
        html = str(form['users'])
        expected_html = """
            <select name="users" data-widget="filtered-select" data-filter-field="id_group" required id="id_users">
                <option value="" selected>---------</option>
                <option value="%(david)s" data-filter-value="%(musicians)s,%(actors)s">%(david_username)s</option>
                <option value="%(kevin)s" data-filter-value="%(actors)s">%(kevin_username)s</option>
                <option value="%(morten)s" data-filter-value="%(musicians)s">%(morten_username)s</option>
            </select>
        """ % {
            'david': self.david.pk, 'kevin': self.kevin.pk, 'morten': self.morten.pk,
            'musicians': self.musicians.pk, 'actors': self.actors.pk,
            'david_username': self.david.get_username(), 'kevin_username': self.kevin.get_username(),
            'morten_username': self.morten.get_username(),
        }
        self.assertHTMLEqual(html, expected_html)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_filters.py" startline="57" endline="80" pcid="2235">
    def test_with_callable(self):

        class UserForm(forms.Form):
            users = FilteredModelChoiceField(
                queryset=User.objects.order_by(User.USERNAME_FIELD), filter_field='id_group',
                filter_accessor=lambda user: user.groups.all()
            )

        form = UserForm()
        html = str(form['users'])
        expected_html = """
            <select name="users" data-widget="filtered-select" data-filter-field="id_group" required id="id_users">
                <option value="" selected>---------</option>
                <option value="%(david)s" data-filter-value="%(musicians)s,%(actors)s">%(david_username)s</option>
                <option value="%(kevin)s" data-filter-value="%(actors)s">%(kevin_username)s</option>
                <option value="%(morten)s" data-filter-value="%(musicians)s">%(morten_username)s</option>
            </select>
        """ % {
            'david': self.david.pk, 'kevin': self.kevin.pk, 'morten': self.morten.pk,
            'musicians': self.musicians.pk, 'actors': self.actors.pk,
            'david_username': self.david.get_username(), 'kevin_username': self.kevin.get_username(),
            'morten_username': self.morten.get_username(),
        }
        self.assertHTMLEqual(html, expected_html)
</source>
</class>

<class classid="109" nclones="4" nlines="12" similarity="83">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_collections_views.py" startline="111" endline="126" pcid="2312">
    def test_marketing_user_with_change_permission(self):
        # Grant the marketing group permission to make changes to their collections
        GroupCollectionPermission.objects.create(
            group=self.marketing_group,
            collection=self.marketing_collection,
            permission=self.change_permission
        )

        response = self.get()
        self.assertEqual(response.status_code, 200)
        self.assertEqual(
            [collection.name for collection in response.context['object_list']],
            ['Marketing', 'Digital Marketing', 'Direct Mail Marketing'])
        self.assertNotContains(response, "Finance")
        self.assertNotContains(response, "Add a collection")

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_collections_views.py" startline="159" endline="175" pcid="2315">
    def test_marketing_user_with_add_permission_on_root(self):
        # Grant the marketing group permission to add to root colection
        GroupCollectionPermission.objects.create(
            group=self.marketing_group,
            collection=self.root_collection,
            permission=self.add_permission
        )

        response = self.get()
        self.assertEqual(response.status_code, 200)
        # (Root should not be shown)
        self.assertEqual(
            [collection.name for collection in response.context['object_list']],
            ['Finance', 'Marketing', 'Digital Marketing', 'Direct Mail Marketing'])
        self.assertContains(response, "Add a collection")


</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_collections_views.py" startline="143" endline="158" pcid="2314">
    def test_marketing_user_with_delete_permission(self):
        # Grant the marketing group permission to add to their collections
        GroupCollectionPermission.objects.create(
            group=self.marketing_group,
            collection=self.marketing_collection,
            permission=self.delete_permission
        )

        response = self.get()
        self.assertEqual(response.status_code, 200)
        self.assertEqual(
            [collection.name for collection in response.context['object_list']],
            ['Marketing', 'Digital Marketing', 'Direct Mail Marketing'])
        self.assertNotContains(response, "Finance")
        self.assertNotContains(response, "Add a collection")

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_collections_views.py" startline="127" endline="142" pcid="2313">
    def test_marketing_user_with_add_permission(self):
        # Grant the marketing group permission to add to their collections
        GroupCollectionPermission.objects.create(
            group=self.marketing_group,
            collection=self.marketing_collection,
            permission=self.add_permission
        )

        response = self.get()
        self.assertEqual(response.status_code, 200)
        self.assertEqual(
            [collection.name for collection in response.context['object_list']],
            ['Marketing', 'Digital Marketing', 'Direct Mail Marketing'])
        self.assertNotContains(response, "Finance")
        self.assertContains(response, "Add a collection")

</source>
</class>

<class classid="110" nclones="4" nlines="11" similarity="70">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_collections_views.py" startline="192" endline="208" pcid="2320">
    def test_post(self):
        response = self.post({
            'name': "Holiday snaps",
            'parent': self.root_collection.id,
        })

        # Should redirect back to index
        self.assertRedirects(response, reverse('wagtailadmin_collections:index'))

        # Check that the collection was created and is a child of root
        self.assertEqual(Collection.objects.filter(name="Holiday snaps").count(), 1)
        self.assertEqual(
            Collection.objects.get(name="Holiday snaps").get_parent(),
            self.root_collection
        )


</source>
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_admin_views.py" startline="452" endline="470" pcid="5152">
    def test_add(self):
        response = self.post({
            'title': "Test image",
            'file': SimpleUploadedFile('test.png', get_test_image_file().file.getvalue()),
        })

        # User should be redirected back to the index
        self.assertRedirects(response, reverse('wagtailimages:index'))

        # Image should be created in the 'evil plans' collection,
        # despite there being no collection field in the form, because that's the
        # only one the user has access to
        self.assertTrue(Image.objects.filter(title="Test image").exists())
        self.assertEqual(
            Image.objects.get(title="Test image").collection,
            self.evil_plans_collection
        )


</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_collections_views.py" startline="225" endline="247" pcid="2325">
    def test_marketing_user_with_add_permission(self):
        # Grant the marketing group permission to manage their collection
        GroupCollectionPermission.objects.create(
            group=self.marketing_group,
            collection=self.marketing_collection,
            permission=self.add_permission
        )

        response = self.post({
            'name': "Affiliate Marketing",
            'parent': self.marketing_collection.id,
        })

        # Should redirect back to index
        self.assertRedirects(response, reverse('wagtailadmin_collections:index'))

        # Check that the collection was created and is a child of Marketing
        self.assertEqual(Collection.objects.filter(name="Affiliate Marketing").count(), 1)
        self.assertEqual(
            Collection.objects.get(name="Affiliate Marketing").get_parent(),
            self.marketing_collection
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_collections_views.py" startline="248" endline="266" pcid="2326">
    def test_marketing_user_cannot_add_outside_their_hierarchy(self):
        # Grant the marketing group permission to manage their collection
        GroupCollectionPermission.objects.create(
            group=self.marketing_group,
            collection=self.marketing_collection,
            permission=self.add_permission
        )

        # This user can't add to root collection
        response = self.post({
            'name': "Affiliate Marketing",
            'parent': self.root_collection.id,
        })
        self.assertEqual(
            response.context['form'].errors['parent'],
            ['Select a valid choice. That choice is not one of the available choices.']
        )


</source>
</class>

<class classid="111" nclones="4" nlines="12" similarity="83">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_compare.py" startline="19" endline="32" pcid="2381">
    def test_hasnt_changed(self):
        comparison = self.comparison_class(
            SimplePage._meta.get_field('content'),
            SimplePage(content="Content"),
            SimplePage(content="Content"),
        )

        self.assertTrue(comparison.is_field)
        self.assertFalse(comparison.is_child_relation)
        self.assertEqual(comparison.field_label(), "Content")
        self.assertEqual(comparison.htmldiff(), 'Content')
        self.assertIsInstance(comparison.htmldiff(), SafeString)
        self.assertFalse(comparison.has_changed())

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_compare.py" startline="480" endline="493" pcid="2408">
    def test_hasnt_changed(self):
        comparison = self.comparison_class(
            EventPage._meta.get_field('audience'),
            EventPage(audience="public"),
            EventPage(audience="public"),
        )

        self.assertTrue(comparison.is_field)
        self.assertFalse(comparison.is_child_relation)
        self.assertEqual(comparison.field_label(), "Audience")
        self.assertEqual(comparison.htmldiff(), 'Public')
        self.assertIsInstance(comparison.htmldiff(), SafeString)
        self.assertFalse(comparison.has_changed())

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_compare.py" startline="623" endline="636" pcid="2418">
    def test_hasnt_changed(self):
        comparison = self.comparison_class(
            EventPage._meta.get_field('feed_image'),
            EventPage(feed_image=self.test_image_1),
            EventPage(feed_image=self.test_image_1),
        )

        self.assertTrue(comparison.is_field)
        self.assertFalse(comparison.is_child_relation)
        self.assertEqual(comparison.field_label(), "Feed image")
        self.assertEqual(comparison.htmldiff(), 'Test image 1')
        self.assertIsInstance(comparison.htmldiff(), SafeString)
        self.assertFalse(comparison.has_changed())

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_compare.py" startline="671" endline="684" pcid="2421">
    def test_hasnt_changed(self):
        comparison = self.comparison_class(
            SnippetChooserModelWithCustomPrimaryKey._meta.get_field('advertwithcustomprimarykey'),
            self.test_obj_1,
            self.test_obj_1,
        )

        self.assertTrue(comparison.is_field)
        self.assertFalse(comparison.is_child_relation)
        self.assertEqual(comparison.field_label(), 'Advertwithcustomprimarykey')
        self.assertEqual(comparison.htmldiff(), 'Advert 1')
        self.assertIsInstance(comparison.htmldiff(), SafeString)
        self.assertFalse(comparison.has_changed())

</source>
</class>

<class classid="112" nclones="17" nlines="16" similarity="73">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_compare.py" startline="137" endline="156" pcid="2390">
    def test_hasnt_changed(self):
        field = StreamPage._meta.get_field('body')

        comparison = self.comparison_class(
            field,
            StreamPage(body=StreamValue(field.stream_block, [
                ('text', "Content", '1'),
            ])),
            StreamPage(body=StreamValue(field.stream_block, [
                ('text', "Content", '1'),
            ])),
        )

        self.assertTrue(comparison.is_field)
        self.assertFalse(comparison.is_child_relation)
        self.assertEqual(comparison.field_label(), "Body")
        self.assertEqual(comparison.htmldiff(), '<div class="comparison__child-object">Content</div>')
        self.assertIsInstance(comparison.htmldiff(), SafeString)
        self.assertFalse(comparison.has_changed())

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_compare.py" startline="212" endline="232" pcid="2394">
    def test_edit_block(self):
        field = StreamPage._meta.get_field('body')

        comparison = self.comparison_class(
            field,
            StreamPage(body=StreamValue(field.stream_block, [
                ('text', "Content", '1'),
                ('text', "Content Foo", '2'),
                ('text', "Content Bar", '3'),
            ])),
            StreamPage(body=StreamValue(field.stream_block, [
                ('text', "Content", '1'),
                ('text', "Content Baz", '2'),
                ('text', "Content Bar", '3'),
            ])),
        )

        self.assertEqual(comparison.htmldiff(), '<div class="comparison__child-object">Content</div>\n<div class="comparison__child-object">Content <span class="deletion">Foo</span><span class="addition">Baz</span></div>\n<div class="comparison__child-object">Content Bar</div>')
        self.assertIsInstance(comparison.htmldiff(), SafeString)
        self.assertTrue(comparison.has_changed())

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_compare.py" startline="300" endline="315" pcid="2399">
    def test_htmldiff_richtext_strips_tags_on_change(self):
        field = StreamPage._meta.get_field('body')

        comparison = self.comparison_class(
            field,
            StreamPage(body=StreamValue(field.stream_block, [
                ('rich_text', "I <b>really</b> like Wagtail &lt;3", '1'),
            ])),
            StreamPage(body=StreamValue(field.stream_block, [
                ('rich_text', 'I <b>really</b> like evil code &gt;_&lt; <script type="text/javascript">doSomethingBad();</script>', '1'),
            ])),
        )

        self.assertEqual(comparison.htmldiff(), '<div class="comparison__child-object">I really like <span class="deletion">Wagtail &lt;3</span><span class="addition">evil code &gt;_&lt; doSomethingBad();</span></div>')
        self.assertIsInstance(comparison.htmldiff(), SafeString)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_compare.py" startline="350" endline="364" pcid="2402">
    def test_htmldiff_raw_html_escapes_value_on_change(self):
        field = StreamPage._meta.get_field('body')

        comparison = self.comparison_class(
            field,
            StreamPage(body=StreamValue(field.stream_block, [
                ('raw_html', "Original<i>ish</i> content", '1'),
            ])),
            StreamPage(body=StreamValue(field.stream_block, [
                ('raw_html', '<script type="text/javascript">doSomethingBad();</script>', '1'),
            ])),
        )
        self.assertEqual(comparison.htmldiff(), '<div class="comparison__child-object"><span class="deletion">Original&lt;i&gt;ish&lt;/i&gt; content</span><span class="addition">&lt;script type=&quot;text/javascript&quot;&gt;doSomethingBad();&lt;/script&gt;</span></div>')
        self.assertIsInstance(comparison.htmldiff(), SafeString)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_compare.py" startline="316" endline="332" pcid="2400">
    def test_htmldiff_richtext_strips_tags_on_addition(self):
        field = StreamPage._meta.get_field('body')

        comparison = self.comparison_class(
            field,
            StreamPage(body=StreamValue(field.stream_block, [
                ('rich_text', "Original <em>and unchanged</em> content", '1'),
            ])),
            StreamPage(body=StreamValue(field.stream_block, [
                ('rich_text', "Original <em>and unchanged</em> content", '1'),
                ('rich_text', 'I <b>really</b> like evil code &gt;_&lt; <script type="text/javascript">doSomethingBad();</script>', '2'),
            ])),
        )

        self.assertEqual(comparison.htmldiff(), '<div class="comparison__child-object">Original and unchanged content</div>\n<div class="comparison__child-object addition">I really like evil code &gt;_&lt; doSomethingBad();</div>')
        self.assertIsInstance(comparison.htmldiff(), SafeString)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_compare.py" startline="283" endline="299" pcid="2398">
    def test_htmldiff_escapes_value_on_deletion(self):
        field = StreamPage._meta.get_field('body')

        comparison = self.comparison_class(
            field,
            StreamPage(body=StreamValue(field.stream_block, [
                ('text', "Original <em>and unchanged</em> content", '1'),
                ('text', '<script type="text/javascript">doSomethingBad();</script>', '2'),
            ])),
            StreamPage(body=StreamValue(field.stream_block, [
                ('text', "Original <em>and unchanged</em> content", '1'),
            ])),
        )

        self.assertEqual(comparison.htmldiff(), '<div class="comparison__child-object">Original &lt;em&gt;and unchanged&lt;/em&gt; content</div>\n<div class="comparison__child-object deletion">&lt;script type=&quot;text/javascript&quot;&gt;doSomethingBad();&lt;/script&gt;</div>')
        self.assertIsInstance(comparison.htmldiff(), SafeString)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_compare.py" startline="266" endline="282" pcid="2397">
    def test_htmldiff_escapes_value_on_addition(self):
        field = StreamPage._meta.get_field('body')

        comparison = self.comparison_class(
            field,
            StreamPage(body=StreamValue(field.stream_block, [
                ('text', "Original <em>and unchanged</em> content", '1'),
            ])),
            StreamPage(body=StreamValue(field.stream_block, [
                ('text', "Original <em>and unchanged</em> content", '1'),
                ('text', '<script type="text/javascript">doSomethingBad();</script>', '2'),
            ])),
        )

        self.assertEqual(comparison.htmldiff(), '<div class="comparison__child-object">Original &lt;em&gt;and unchanged&lt;/em&gt; content</div>\n<div class="comparison__child-object addition">&lt;script type=&quot;text/javascript&quot;&gt;doSomethingBad();&lt;/script&gt;</div>')
        self.assertIsInstance(comparison.htmldiff(), SafeString)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_compare.py" startline="233" endline="249" pcid="2395">
    def test_has_changed_richtext(self):
        field = StreamPage._meta.get_field('body')

        comparison = self.comparison_class(
            field,
            StreamPage(body=StreamValue(field.stream_block, [
                ('rich_text', "<b>Original</b> content", '1'),
            ])),
            StreamPage(body=StreamValue(field.stream_block, [
                ('rich_text', "Modified <i>content</i>", '1'),
            ])),
        )

        self.assertEqual(comparison.htmldiff(), '<div class="comparison__child-object"><span class="deletion">Original</span><span class="addition">Modified</span> content</div>')
        self.assertIsInstance(comparison.htmldiff(), SafeString)
        self.assertTrue(comparison.has_changed())

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_compare.py" startline="333" endline="349" pcid="2401">
    def test_htmldiff_richtext_strips_tags_on_deletion(self):
        field = StreamPage._meta.get_field('body')

        comparison = self.comparison_class(
            field,
            StreamPage(body=StreamValue(field.stream_block, [
                ('rich_text', "Original <em>and unchanged</em> content", '1'),
                ('rich_text', 'I <b>really</b> like evil code &gt;_&lt; <script type="text/javascript">doSomethingBad();</script>', '2'),
            ])),
            StreamPage(body=StreamValue(field.stream_block, [
                ('rich_text', "Original <em>and unchanged</em> content", '1'),
            ])),
        )

        self.assertEqual(comparison.htmldiff(), '<div class="comparison__child-object">Original and unchanged content</div>\n<div class="comparison__child-object deletion">I really like evil code &gt;_&lt; doSomethingBad();</div>')
        self.assertIsInstance(comparison.htmldiff(), SafeString)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_compare.py" startline="157" endline="173" pcid="2391">
    def test_has_changed(self):
        field = StreamPage._meta.get_field('body')

        comparison = self.comparison_class(
            field,
            StreamPage(body=StreamValue(field.stream_block, [
                ('text', "Original content", '1'),
            ])),
            StreamPage(body=StreamValue(field.stream_block, [
                ('text', "Modified content", '1'),
            ])),
        )

        self.assertEqual(comparison.htmldiff(), '<div class="comparison__child-object"><span class="deletion">Original</span><span class="addition">Modified</span> content</div>')
        self.assertIsInstance(comparison.htmldiff(), SafeString)
        self.assertTrue(comparison.has_changed())

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_compare.py" startline="365" endline="380" pcid="2403">
    def test_htmldiff_raw_html_escapes_value_on_addition(self):
        field = StreamPage._meta.get_field('body')

        comparison = self.comparison_class(
            field,
            StreamPage(body=StreamValue(field.stream_block, [
                ('raw_html', "Original <em>and unchanged</em> content", '1'),
            ])),
            StreamPage(body=StreamValue(field.stream_block, [
                ('raw_html', "Original <em>and unchanged</em> content", '1'),
                ('raw_html', '<script type="text/javascript">doSomethingBad();</script>', '2'),
            ])),
        )
        self.assertEqual(comparison.htmldiff(), '<div class="comparison__child-object">Original &lt;em&gt;and unchanged&lt;/em&gt; content</div>\n<div class="comparison__child-object addition">&lt;script type=&quot;text/javascript&quot;&gt;doSomethingBad();&lt;/script&gt;</div>')
        self.assertIsInstance(comparison.htmldiff(), SafeString)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_compare.py" startline="174" endline="191" pcid="2392">
    def test_add_block(self):
        field = StreamPage._meta.get_field('body')

        comparison = self.comparison_class(
            field,
            StreamPage(body=StreamValue(field.stream_block, [
                ('text', "Content", '1'),
            ])),
            StreamPage(body=StreamValue(field.stream_block, [
                ('text', "Content", '1'),
                ('text', "New Content", '2'),
            ])),
        )

        self.assertEqual(comparison.htmldiff(), '<div class="comparison__child-object">Content</div>\n<div class="comparison__child-object addition">New Content</div>')
        self.assertIsInstance(comparison.htmldiff(), SafeString)
        self.assertTrue(comparison.has_changed())

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_compare.py" startline="192" endline="211" pcid="2393">
    def test_delete_block(self):
        field = StreamPage._meta.get_field('body')

        comparison = self.comparison_class(
            field,
            StreamPage(body=StreamValue(field.stream_block, [
                ('text', "Content", '1'),
                ('text', "Content Foo", '2'),
                ('text', "Content Bar", '3'),
            ])),
            StreamPage(body=StreamValue(field.stream_block, [
                ('text', "Content", '1'),
                ('text', "Content Bar", '3'),
            ])),
        )

        self.assertEqual(comparison.htmldiff(), '<div class="comparison__child-object">Content</div>\n<div class="comparison__child-object deletion">Content Foo</div>\n<div class="comparison__child-object">Content Bar</div>')
        self.assertIsInstance(comparison.htmldiff(), SafeString)
        self.assertTrue(comparison.has_changed())

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_compare.py" startline="381" endline="396" pcid="2404">
    def test_htmldiff_raw_html_escapes_value_on_deletion(self):
        field = StreamPage._meta.get_field('body')

        comparison = self.comparison_class(
            field,
            StreamPage(body=StreamValue(field.stream_block, [
                ('raw_html', "Original <em>and unchanged</em> content", '1'),
                ('raw_html', '<script type="text/javascript">doSomethingBad();</script>', '2'),
            ])),
            StreamPage(body=StreamValue(field.stream_block, [
                ('raw_html', "Original <em>and unchanged</em> content", '1'),
            ])),
        )
        self.assertEqual(comparison.htmldiff(), '<div class="comparison__child-object">Original &lt;em&gt;and unchanged&lt;/em&gt; content</div>\n<div class="comparison__child-object deletion">&lt;script type=&quot;text/javascript&quot;&gt;doSomethingBad();&lt;/script&gt;</div>')
        self.assertIsInstance(comparison.htmldiff(), SafeString)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_compare.py" startline="250" endline="265" pcid="2396">
    def test_htmldiff_escapes_value_on_change(self):
        field = StreamPage._meta.get_field('body')

        comparison = self.comparison_class(
            field,
            StreamPage(body=StreamValue(field.stream_block, [
                ('text', "I <b>really</b> like original<i>ish</i> content", '1'),
            ])),
            StreamPage(body=StreamValue(field.stream_block, [
                ('text', 'I <b>really</b> like evil code <script type="text/javascript">doSomethingBad();</script>', '1'),
            ])),
        )

        self.assertEqual(comparison.htmldiff(), '<div class="comparison__child-object">I &lt;b&gt;really&lt;/b&gt; like <span class="deletion">original&lt;i&gt;ish&lt;/i&gt; content</span><span class="addition">evil code &lt;script type=&quot;text/javascript&quot;&gt;doSomethingBad();&lt;/script&gt;</span></div>')
        self.assertIsInstance(comparison.htmldiff(), SafeString)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_compare.py" startline="397" endline="421" pcid="2405">
    def test_compare_structblock(self):
        field = StreamPage._meta.get_field('body')

        comparison = self.comparison_class(
            field,
            StreamPage(body=StreamValue(field.stream_block, [
                ('product', {'name': 'a packet of rolos', 'price': '75p'}, '1'),
            ])),
            StreamPage(body=StreamValue(field.stream_block, [
                ('product', {'name': 'a packet of rolos', 'price': '85p'}, '1'),
            ])),
        )

        expected = """
            <div class="comparison__child-object"><dl>
                <dt>Name</dt>
                <dd>a packet of rolos</dd>
                <dt>Price</dt>
                <dd><span class="deletion">75p</span><span class="addition">85p</span></dd>
            </dl></div>
        """
        self.assertHTMLEqual(comparison.htmldiff(), expected)
        self.assertIsInstance(comparison.htmldiff(), SafeString)
        self.assertTrue(comparison.has_changed())

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_compare.py" startline="422" endline="443" pcid="2406">
    def test_compare_nested_streamblock_uses_comparison_class(self):
        field = StreamPage._meta.get_field('body')
        stream_block = field.stream_block.child_blocks['books']
        comparison = self.comparison_class(
            field,
            StreamPage(body=StreamValue(field.stream_block, [
                ('books', StreamValue(stream_block, [('title', 'The Old Man and the Sea', '10')]), '1'),
            ])),
            StreamPage(body=StreamValue(field.stream_block, [
                ('books', StreamValue(stream_block, [('author', 'Oscar Wilde', '11')]), '1'),
            ])),
        )
        expected = """
            <div class="comparison__child-object">
                <div class="comparison__child-object addition">Oscar Wilde</div>\n
                <div class="comparison__child-object deletion">The Old Man and the Sea</div>
            </div>
        """
        self.assertHTMLEqual(comparison.htmldiff(), expected)
        self.assertIsInstance(comparison.htmldiff(), SafeString)
        self.assertTrue(comparison.has_changed())

</source>
</class>

<class classid="113" nclones="2" nlines="13" similarity="78">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_compare.py" startline="531" endline="548" pcid="2412">
    def test_hasnt_changed(self):
        a = TaggedPage()
        a.tags.add('wagtail')
        a.tags.add('bird')

        b = TaggedPage()
        b.tags.add('wagtail')
        b.tags.add('bird')

        comparison = self.comparison_class(TaggedPage._meta.get_field('tags'), a, b)

        self.assertTrue(comparison.is_field)
        self.assertFalse(comparison.is_child_relation)
        self.assertEqual(comparison.field_label(), "Tags")
        self.assertEqual(comparison.htmldiff(), 'wagtail, bird')
        self.assertIsInstance(comparison.htmldiff(), SafeString)
        self.assertFalse(comparison.has_changed())

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_compare.py" startline="549" endline="564" pcid="2413">
    def test_has_changed(self):
        a = TaggedPage()
        a.tags.add('wagtail')
        a.tags.add('bird')

        b = TaggedPage()
        b.tags.add('wagtail')
        b.tags.add('motacilla')

        comparison = self.comparison_class(TaggedPage._meta.get_field('tags'), a, b)

        self.assertEqual(comparison.htmldiff(), 'wagtail, <span class="deletion">bird</span>, <span class="addition">motacilla</span>')
        self.assertIsInstance(comparison.htmldiff(), SafeString)
        self.assertTrue(comparison.has_changed())


</source>
</class>

<class classid="114" nclones="2" nlines="12" similarity="76">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_compare.py" startline="574" endline="591" pcid="2415">
    def test_hasnt_changed(self):
        christmas_event = EventPage.objects.get(url_path='/home/events/christmas/')
        saint_patrick_event = EventPage.objects.get(url_path='/home/events/saint-patrick/')

        christmas_event.categories = [self.meetings_category, self.parties_category]
        saint_patrick_event.categories = [self.meetings_category, self.parties_category]

        comparison = self.comparison_class(
            EventPage._meta.get_field('categories'), christmas_event, saint_patrick_event
        )

        self.assertTrue(comparison.is_field)
        self.assertFalse(comparison.is_child_relation)
        self.assertEqual(comparison.field_label(), "Categories")
        self.assertFalse(comparison.has_changed())
        self.assertEqual(comparison.htmldiff(), 'Meetings, Parties')
        self.assertIsInstance(comparison.htmldiff(), SafeString)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_compare.py" startline="592" endline="607" pcid="2416">
    def test_has_changed(self):
        christmas_event = EventPage.objects.get(url_path='/home/events/christmas/')
        saint_patrick_event = EventPage.objects.get(url_path='/home/events/saint-patrick/')

        christmas_event.categories = [self.meetings_category, self.parties_category]
        saint_patrick_event.categories = [self.meetings_category, self.holidays_category]

        comparison = self.comparison_class(
            EventPage._meta.get_field('categories'), christmas_event, saint_patrick_event
        )

        self.assertTrue(comparison.has_changed())
        self.assertEqual(comparison.htmldiff(), 'Meetings, <span class="deletion">Parties</span>, <span class="addition">Holidays</span>')
        self.assertIsInstance(comparison.htmldiff(), SafeString)


</source>
</class>

<class classid="115" nclones="5" nlines="34" similarity="70">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_compare.py" startline="701" endline="740" pcid="2423">
    def test_hasnt_changed(self):
        # Two event pages with speaker called "Father Christmas". Neither of
        # the speaker objects have an ID so this tests that the code can match
        # the two together by field content.
        event_page = EventPage(title="Event page", slug="event")
        event_page.speakers.add(EventPageSpeaker(
            first_name="Father",
            last_name="Christmas",
        ))

        modified_event_page = EventPage(title="Event page", slug="event")
        modified_event_page.speakers.add(EventPageSpeaker(
            first_name="Father",
            last_name="Christmas",
        ))

        comparison = self.comparison_class(
            EventPage._meta.get_field('speaker'),
            [
                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('first_name')),
                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('last_name')),
            ],
            event_page,
            modified_event_page,
        )

        self.assertFalse(comparison.is_field)
        self.assertTrue(comparison.is_child_relation)
        self.assertEqual(comparison.field_label(), "Speaker")
        self.assertFalse(comparison.has_changed())

        # Check mapping
        objs_a = list(comparison.val_a.all())
        objs_b = list(comparison.val_b.all())
        map_forwards, map_backwards, added, deleted = comparison.get_mapping(objs_a, objs_b)
        self.assertEqual(map_forwards, {0: 0})
        self.assertEqual(map_backwards, {0: 0})
        self.assertEqual(added, [])
        self.assertEqual(deleted, [])

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_compare.py" startline="788" endline="836" pcid="2425">
    def test_has_changed_with_same_id(self):
        # Father Christmas renamed to Santa Claus, but this time the ID of the
        # child object remained the same. It should now be detected as the same
        # object
        event_page = EventPage(title="Event page", slug="event")
        event_page.speakers.add(EventPageSpeaker(
            id=1,
            first_name="Father",
            last_name="Christmas",
            sort_order=0,
        ))

        modified_event_page = EventPage(title="Event page", slug="event")
        modified_event_page.speakers.add(EventPageSpeaker(
            id=1,
            first_name="Santa",
            last_name="Claus",
            sort_order=0,
        ))
        modified_event_page.speakers.add(EventPageSpeaker(
            first_name="Father",
            last_name="Ted",
            sort_order=1,
        ))

        comparison = self.comparison_class(
            EventPage._meta.get_field('speaker'),
            [
                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('first_name')),
                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('last_name')),
            ],
            event_page,
            modified_event_page,
        )

        self.assertFalse(comparison.is_field)
        self.assertTrue(comparison.is_child_relation)
        self.assertEqual(comparison.field_label(), "Speaker")
        self.assertTrue(comparison.has_changed())

        # Check mapping
        objs_a = list(comparison.val_a.all())
        objs_b = list(comparison.val_b.all())
        map_forwards, map_backwards, added, deleted = comparison.get_mapping(objs_a, objs_b)
        self.assertEqual(map_forwards, {0: 0})  # Map Father Christmas to Santa Claus
        self.assertEqual(map_backwards, {0: 0})  # Map Santa Claus to Father Christmas
        self.assertEqual(added, [1])  # Add Father Ted
        self.assertEqual(deleted, [])

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_compare.py" startline="1017" endline="1056" pcid="2432">
    def test_has_changed_with_same_id(self):
        # Head Count was changed but the PK of the child object remained the same.
        # It should be detected as the same object

        event_page = EventPage(title="Semi Finals", slug="semi-finals-2018")
        event_page.head_counts.add(HeadCountRelatedModelUsingPK(
            custom_id=1,
            head_count=22,
        ))

        modified_event_page = EventPage(title="Semi Finals", slug="semi-finals-2018")
        modified_event_page.head_counts.add(HeadCountRelatedModelUsingPK(
            custom_id=1,
            head_count=23,
        ))
        modified_event_page.head_counts.add(HeadCountRelatedModelUsingPK(
            head_count=25,
        ))

        comparison = self.comparison_class(
            EventPage._meta.get_field('head_counts'),
            [partial(self.field_comparison_class, HeadCountRelatedModelUsingPK._meta.get_field('head_count'))],
            event_page,
            modified_event_page,
        )

        self.assertFalse(comparison.is_field)
        self.assertTrue(comparison.is_child_relation)
        self.assertEqual(comparison.field_label(), 'Head counts')
        self.assertTrue(comparison.has_changed())

        # Check mapping
        objs_a = list(comparison.val_a.all())
        objs_b = list(comparison.val_b.all())
        map_forwards, map_backwards, added, deleted = comparison.get_mapping(objs_a, objs_b)
        self.assertEqual(map_forwards, {0: 0})  # map head count 22 to 23
        self.assertEqual(map_backwards, {0: 0})  # map head count 23 to 22
        self.assertEqual(added, [1])  # add second head count
        self.assertEqual(deleted, [])

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_compare.py" startline="741" endline="787" pcid="2424">
    def test_has_changed(self):
        # Father Christmas renamed to Santa Claus. And Father Ted added.
        # Father Christmas should be mapped to Father Ted because they
        # are most alike. Santa claus should be displayed as "new"
        event_page = EventPage(title="Event page", slug="event")
        event_page.speakers.add(EventPageSpeaker(
            first_name="Father",
            last_name="Christmas",
            sort_order=0,
        ))

        modified_event_page = EventPage(title="Event page", slug="event")
        modified_event_page.speakers.add(EventPageSpeaker(
            first_name="Santa",
            last_name="Claus",
            sort_order=0,
        ))
        modified_event_page.speakers.add(EventPageSpeaker(
            first_name="Father",
            last_name="Ted",
            sort_order=1,
        ))

        comparison = self.comparison_class(
            EventPage._meta.get_field('speaker'),
            [
                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('first_name')),
                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('last_name')),
            ],
            event_page,
            modified_event_page,
        )

        self.assertFalse(comparison.is_field)
        self.assertTrue(comparison.is_child_relation)
        self.assertEqual(comparison.field_label(), "Speaker")
        self.assertTrue(comparison.has_changed())

        # Check mapping
        objs_a = list(comparison.val_a.all())
        objs_b = list(comparison.val_b.all())
        map_forwards, map_backwards, added, deleted = comparison.get_mapping(objs_a, objs_b)
        self.assertEqual(map_forwards, {0: 1})  # Map Father Christmas to Father Ted
        self.assertEqual(map_backwards, {1: 0})  # Map Father Ted ot Father Christmas
        self.assertEqual(added, [0])  # Add Santa Claus
        self.assertEqual(deleted, [])

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_compare.py" startline="837" endline="878" pcid="2426">
    def test_hasnt_changed_with_different_id(self):
        # Both of the child objects have the same field content but have a
        # different ID so they should be detected as separate objects
        event_page = EventPage(title="Event page", slug="event")
        event_page.speakers.add(EventPageSpeaker(
            id=1,
            first_name="Father",
            last_name="Christmas",
        ))

        modified_event_page = EventPage(title="Event page", slug="event")
        modified_event_page.speakers.add(EventPageSpeaker(
            id=2,
            first_name="Father",
            last_name="Christmas",
        ))

        comparison = self.comparison_class(
            EventPage._meta.get_field('speaker'),
            [
                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('first_name')),
                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('last_name')),
            ],
            event_page,
            modified_event_page,
        )

        self.assertFalse(comparison.is_field)
        self.assertTrue(comparison.is_child_relation)
        self.assertEqual(comparison.field_label(), "Speaker")
        self.assertTrue(comparison.has_changed())

        # Check mapping
        objs_a = list(comparison.val_a.all())
        objs_b = list(comparison.val_b.all())
        map_forwards, map_backwards, added, deleted = comparison.get_mapping(objs_a, objs_b)
        self.assertEqual(map_forwards, {})
        self.assertEqual(map_backwards, {})
        self.assertEqual(added, [0])  # Add new Father Christmas
        self.assertEqual(deleted, [0])  # Delete old Father Christmas


</source>
</class>

<class classid="116" nclones="5" nlines="22" similarity="78">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_compare.py" startline="883" endline="909" pcid="2427">
    def test_same_object(self):
        obj_a = EventPageSpeaker(
            first_name="Father",
            last_name="Christmas",
        )

        obj_b = EventPageSpeaker(
            first_name="Father",
            last_name="Christmas",
        )

        comparison = self.comparison_class(
            EventPageSpeaker,
            [
                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('first_name')),
                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('last_name')),
            ],
            obj_a,
            obj_b,
        )

        self.assertFalse(comparison.is_addition())
        self.assertFalse(comparison.is_deletion())
        self.assertFalse(comparison.has_changed())
        self.assertEqual(comparison.get_position_change(), 0)
        self.assertEqual(comparison.get_num_differences(), 0)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_compare.py" startline="966" endline="987" pcid="2430">
    def test_addition(self):
        obj = EventPageSpeaker(
            first_name="Father",
            last_name="Christmas",
        )

        comparison = self.comparison_class(
            EventPageSpeaker,
            [
                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('first_name')),
                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('last_name')),
            ],
            None,
            obj,
        )

        self.assertTrue(comparison.is_addition())
        self.assertFalse(comparison.is_deletion())
        self.assertFalse(comparison.has_changed())
        self.assertIsNone(comparison.get_position_change(), 0)
        self.assertEqual(comparison.get_num_differences(), 0)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_compare.py" startline="988" endline="1010" pcid="2431">
    def test_deletion(self):
        obj = EventPageSpeaker(
            first_name="Father",
            last_name="Christmas",
        )

        comparison = self.comparison_class(
            EventPageSpeaker,
            [
                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('first_name')),
                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('last_name')),
            ],
            obj,
            None,
        )

        self.assertFalse(comparison.is_addition())
        self.assertTrue(comparison.is_deletion())
        self.assertFalse(comparison.has_changed())
        self.assertIsNone(comparison.get_position_change())
        self.assertEqual(comparison.get_num_differences(), 0)


</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_compare.py" startline="937" endline="965" pcid="2429">
    def test_moved_object(self):
        obj_a = EventPageSpeaker(
            first_name="Father",
            last_name="Christmas",
            sort_order=1,
        )

        obj_b = EventPageSpeaker(
            first_name="Father",
            last_name="Christmas",
            sort_order=5,
        )

        comparison = self.comparison_class(
            EventPageSpeaker,
            [
                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('first_name')),
                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('last_name')),
            ],
            obj_a,
            obj_b,
        )

        self.assertFalse(comparison.is_addition())
        self.assertFalse(comparison.is_deletion())
        self.assertFalse(comparison.has_changed())
        self.assertEqual(comparison.get_position_change(), 4)
        self.assertEqual(comparison.get_num_differences(), 0)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_compare.py" startline="910" endline="936" pcid="2428">
    def test_different_object(self):
        obj_a = EventPageSpeaker(
            first_name="Father",
            last_name="Christmas",
        )

        obj_b = EventPageSpeaker(
            first_name="Santa",
            last_name="Claus",
        )

        comparison = self.comparison_class(
            EventPageSpeaker,
            [
                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('first_name')),
                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('last_name')),
            ],
            obj_a,
            obj_b,
        )

        self.assertFalse(comparison.is_addition())
        self.assertFalse(comparison.is_deletion())
        self.assertTrue(comparison.has_changed())
        self.assertEqual(comparison.get_position_change(), 0)
        self.assertEqual(comparison.get_num_differences(), 2)

</source>
</class>

<class classid="117" nclones="8" nlines="11" similarity="70">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_contentstate.py" startline="46" endline="61" pcid="2436">
    def test_paragraphs(self):
        converter = ContentstateConverter(features=[])
        result = json.loads(converter.from_database_format(
            '''
            <p data-block-key='00000'>Hello world!</p>
            <p data-block-key='00001'>Goodbye world!</p>
            '''
        ))
        self.assertContentStateEqual(result, {
            'entityMap': {},
            'blocks': [
                {'inlineStyleRanges': [], 'text': 'Hello world!', 'depth': 0, 'type': 'unstyled', 'key': '00000', 'entityRanges': []},
                {'inlineStyleRanges': [], 'text': 'Goodbye world!', 'depth': 0, 'type': 'unstyled', 'key': '00001', 'entityRanges': []},
            ]
        }, match_keys=True)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_contentstate.py" startline="62" endline="79" pcid="2437">
    def test_unknown_block_becomes_paragraph(self):
        converter = ContentstateConverter(features=[])
        result = json.loads(converter.from_database_format(
            '''
            <foo>Hello world!</foo>
            <foo>I said hello world!</foo>
            <p>Goodbye world!</p>
            '''
        ))
        self.assertContentStateEqual(result, {
            'entityMap': {},
            'blocks': [
                {'inlineStyleRanges': [], 'text': 'Hello world!', 'depth': 0, 'type': 'unstyled', 'key': '00000', 'entityRanges': []},
                {'inlineStyleRanges': [], 'text': 'I said hello world!', 'depth': 0, 'type': 'unstyled', 'key': '00000', 'entityRanges': []},
                {'inlineStyleRanges': [], 'text': 'Goodbye world!', 'depth': 0, 'type': 'unstyled', 'key': '00000', 'entityRanges': []},
            ]
        })

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_contentstate.py" startline="694" endline="708" pcid="2463">
    def test_br_element_in_paragraph(self):
        converter = ContentstateConverter(features=[])
        result = json.loads(converter.from_database_format(
            '''
            <p>before<br/>after</p>
            '''
        ))
        self.assertContentStateEqual(result, {
            'entityMap': {},
            'blocks': [
                {'key': '00000', 'inlineStyleRanges': [], 'entityRanges': [], 'depth': 0, 'text': 'before\nafter',
                 'type': 'unstyled'}
            ],
        })

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_contentstate.py" startline="709" endline="725" pcid="2464">
    def test_br_element_between_paragraphs(self):
        converter = ContentstateConverter(features=[])
        result = json.loads(converter.from_database_format(
            '''
            <p>before</p>
            <br />
            <p>after</p>
            '''
        ))
        self.assertContentStateEqual(result, {
            'entityMap': {},
            'blocks': [
                {'key': '00000', 'inlineStyleRanges': [], 'entityRanges': [], 'depth': 0, 'text': 'before', 'type': 'unstyled'},
                {'key': '00000', 'inlineStyleRanges': [], 'entityRanges': [], 'depth': 0, 'text': 'after', 'type': 'unstyled'}
            ],
        })

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_contentstate.py" startline="764" endline="781" pcid="2467">
    def test_collapse_targeted_whitespace_characters(self):
        # We expect all targeted whitespace characters (one or more consecutively)
        # to be replaced by a single space. (\xa0 is a non-breaking whitespace)
        converter = ContentstateConverter(features=[])
        result = json.loads(converter.from_database_format(
            '''
            <p>Multiple whitespaces:     should  be reduced</p>
            <p>Multiple non-breaking whitespace characters:  \xa0\xa0\xa0  should be preserved</p>
            '''
        ))
        self.assertContentStateEqual(result, {
            'entityMap': {},
            'blocks': [
                {'inlineStyleRanges': [], 'text': 'Multiple whitespaces: should be reduced', 'depth': 0, 'type': 'unstyled', 'key': '00000', 'entityRanges': []},
                {'inlineStyleRanges': [], 'text': 'Multiple non-breaking whitespace characters: \xa0\xa0\xa0 should be preserved', 'depth': 0, 'type': 'unstyled', 'key': '00000', 'entityRanges': []},
            ]
        })

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_contentstate.py" startline="80" endline="101" pcid="2438">
    def test_bare_text_becomes_paragraph(self):
        converter = ContentstateConverter(features=[])
        result = json.loads(converter.from_database_format(
            '''
            before
            <p>paragraph</p>
            between
            <p>paragraph</p>
            after
            '''
        ))
        self.assertContentStateEqual(result, {
            'entityMap': {},
            'blocks': [
                {'inlineStyleRanges': [], 'text': 'before', 'depth': 0, 'type': 'unstyled', 'key': '00000', 'entityRanges': []},
                {'inlineStyleRanges': [], 'text': 'paragraph', 'depth': 0, 'type': 'unstyled', 'key': '00000', 'entityRanges': []},
                {'inlineStyleRanges': [], 'text': 'between', 'depth': 0, 'type': 'unstyled', 'key': '00000', 'entityRanges': []},
                {'inlineStyleRanges': [], 'text': 'paragraph', 'depth': 0, 'type': 'unstyled', 'key': '00000', 'entityRanges': []},
                {'inlineStyleRanges': [], 'text': 'after', 'depth': 0, 'type': 'unstyled', 'key': '00000', 'entityRanges': []},
            ]
        })

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_contentstate.py" startline="977" endline="991" pcid="2477">
    def test_paragraphs_retain_keys(self):
        converter = ContentstateConverter(features=[])
        contentState = json.dumps({
            'entityMap': {},
            'blocks': [
                {'inlineStyleRanges': [], 'text': 'Hello world!', 'depth': 0, 'type': 'unstyled', 'key': '00000', 'entityRanges': []},
                {'inlineStyleRanges': [], 'text': 'Goodbye world!', 'depth': 0, 'type': 'unstyled', 'key': '00001', 'entityRanges': []},
            ]
        })
        result = converter.to_database_format(contentState)
        self.assertHTMLEqual(result, '''
            <p data-block-key='00000'>Hello world!</p>
            <p data-block-key='00001'>Goodbye world!</p>
            ''')

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_contentstate.py" startline="216" endline="245" pcid="2445">
    def test_nested_list(self):
        converter = ContentstateConverter(features=['h1', 'ul'])
        result = json.loads(converter.from_database_format(
            '''
            <h1 data-block-key='00000'>Shopping list</h1>
            <ul>
                <li data-block-key='00001'>Milk</li>
                <li data-block-key='00002'>
                    Flour
                    <ul>
                        <li data-block-key='00003'>Plain</li>
                        <li data-block-key='00004'>Self-raising</li>
                    </ul>
                </li>
                <li data-block-key='00005'>Eggs</li>
            </ul>
            '''
        ))
        self.assertContentStateEqual(result, {
            'entityMap': {},
            'blocks': [
                {'inlineStyleRanges': [], 'text': 'Shopping list', 'depth': 0, 'type': 'header-one', 'key': '00000', 'entityRanges': []},
                {'inlineStyleRanges': [], 'text': 'Milk', 'depth': 0, 'type': 'unordered-list-item', 'key': '00001', 'entityRanges': []},
                {'inlineStyleRanges': [], 'text': 'Flour', 'depth': 0, 'type': 'unordered-list-item', 'key': '00002', 'entityRanges': []},
                {'inlineStyleRanges': [], 'text': 'Plain', 'depth': 1, 'type': 'unordered-list-item', 'key': '00003', 'entityRanges': []},
                {'inlineStyleRanges': [], 'text': 'Self-raising', 'depth': 1, 'type': 'unordered-list-item', 'key': '00004', 'entityRanges': []},
                {'inlineStyleRanges': [], 'text': 'Eggs', 'depth': 0, 'type': 'unordered-list-item', 'key': '00005', 'entityRanges': []},
            ]
        }, match_keys=True)

</source>
</class>

<class classid="118" nclones="5" nlines="12" similarity="71">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_contentstate.py" startline="116" endline="134" pcid="2440">
    def test_inline_styles(self):
        converter = ContentstateConverter(features=['bold', 'italic'])
        result = json.loads(converter.from_database_format(
            '''
            <p>You <b>do <em>not</em> talk</b> about Fight Club.</p>
            '''
        ))
        self.assertContentStateEqual(result, {
            'entityMap': {},
            'blocks': [
                {
                    'inlineStyleRanges': [
                        {'offset': 4, 'length': 11, 'style': 'BOLD'}, {'offset': 7, 'length': 3, 'style': 'ITALIC'}
                    ],
                    'text': 'You do not talk about Fight Club.', 'depth': 0, 'type': 'unstyled', 'key': '00000', 'entityRanges': []
                },
            ]
        })

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_contentstate.py" startline="135" endline="153" pcid="2441">
    def test_inline_styles_at_top_level(self):
        converter = ContentstateConverter(features=['bold', 'italic'])
        result = json.loads(converter.from_database_format(
            '''
            You <b>do <em>not</em> talk</b> about Fight Club.
            '''
        ))
        self.assertContentStateEqual(result, {
            'entityMap': {},
            'blocks': [
                {
                    'inlineStyleRanges': [
                        {'offset': 4, 'length': 11, 'style': 'BOLD'}, {'offset': 7, 'length': 3, 'style': 'ITALIC'}
                    ],
                    'text': 'You do not talk about Fight Club.', 'depth': 0, 'type': 'unstyled', 'key': '00000', 'entityRanges': []
                },
            ]
        })

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_contentstate.py" startline="154" endline="171" pcid="2442">
    def test_inline_styles_at_start_of_bare_block(self):
        converter = ContentstateConverter(features=['bold', 'italic'])
        result = json.loads(converter.from_database_format(
            '''<b>Seriously</b>, stop talking about <i>Fight Club</i> already.'''
        ))
        self.assertContentStateEqual(result, {
            'entityMap': {},
            'blocks': [
                {
                    'inlineStyleRanges': [
                        {'offset': 0, 'length': 9, 'style': 'BOLD'},
                        {'offset': 30, 'length': 10, 'style': 'ITALIC'},
                    ],
                    'text': 'Seriously, stop talking about Fight Club already.', 'depth': 0, 'type': 'unstyled', 'key': '00000', 'entityRanges': []
                },
            ]
        })

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_contentstate.py" startline="191" endline="215" pcid="2444">
    def test_ordered_list(self):
        converter = ContentstateConverter(features=['h1', 'ol', 'bold', 'italic'])
        result = json.loads(converter.from_database_format(
            '''
            <h1 data-block-key='00000'>The rules of Fight Club</h1>
            <ol>
                <li data-block-key='00001'>You do not talk about Fight Club.</li>
                <li data-block-key='00002'>You <b>do <em>not</em> talk</b> about Fight Club.</li>
            </ol>
            '''
        ))
        self.assertContentStateEqual(result, {
            'entityMap': {},
            'blocks': [
                {'inlineStyleRanges': [], 'text': 'The rules of Fight Club', 'depth': 0, 'type': 'header-one', 'key': '00000', 'entityRanges': []},
                {'inlineStyleRanges': [], 'text': 'You do not talk about Fight Club.', 'depth': 0, 'type': 'ordered-list-item', 'key': '00001', 'entityRanges': []},
                {
                    'inlineStyleRanges': [
                        {'offset': 4, 'length': 11, 'style': 'BOLD'}, {'offset': 7, 'length': 3, 'style': 'ITALIC'}
                    ],
                    'text': 'You do not talk about Fight Club.', 'depth': 0, 'type': 'ordered-list-item', 'key': '00002', 'entityRanges': []
                },
            ]
        }, match_keys=True)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_contentstate.py" startline="172" endline="190" pcid="2443">
    def test_inline_styles_depend_on_features(self):
        converter = ContentstateConverter(features=['italic', 'just-made-it-up'])
        result = json.loads(converter.from_database_format(
            '''
            <p>You <b>do <em>not</em> talk</b> about Fight Club.</p>
            '''
        ))
        self.assertContentStateEqual(result, {
            'entityMap': {},
            'blocks': [
                {
                    'inlineStyleRanges': [
                        {'offset': 7, 'length': 3, 'style': 'ITALIC'}
                    ],
                    'text': 'You do not talk about Fight Club.', 'depth': 0, 'type': 'unstyled', 'key': '00000', 'entityRanges': []
                },
            ]
        })

</source>
</class>

<class classid="119" nclones="11" nlines="12" similarity="75">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_contentstate.py" startline="246" endline="264" pcid="2446">
    def test_external_link(self):
        converter = ContentstateConverter(features=['link'])
        result = json.loads(converter.from_database_format(
            '''
            <p>an <a href="http://wagtail.org">external</a> link</p>
            '''
        ))
        self.assertContentStateEqual(result, {
            'entityMap': {
                '0': {'mutability': 'MUTABLE', 'type': 'LINK', 'data': {'url': 'http://wagtail.org'}}
            },
            'blocks': [
                {
                    'inlineStyleRanges': [], 'text': 'an external link', 'depth': 0, 'type': 'unstyled', 'key': '00000',
                    'entityRanges': [{'offset': 3, 'length': 8, 'key': 0}]
                },
            ]
        })

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_contentstate.py" startline="349" endline="370" pcid="2451">
    def test_link_to_root_page(self):
        converter = ContentstateConverter(features=['link'])
        result = json.loads(converter.from_database_format(
            '''
            <p>an <a linktype="page" id="1">internal</a> link</p>
            '''
        ))
        self.assertContentStateEqual(result, {
            'entityMap': {
                '0': {
                    'mutability': 'MUTABLE', 'type': 'LINK',
                    'data': {'id': 1, 'url': None, 'parentId': None}
                }
            },
            'blocks': [
                {
                    'inlineStyleRanges': [], 'text': 'an internal link', 'depth': 0, 'type': 'unstyled', 'key': '00000',
                    'entityRanges': [{'offset': 3, 'length': 8, 'key': 0}]
                },
            ]
        })

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_contentstate.py" startline="303" endline="324" pcid="2449">
    def test_page_link(self):
        converter = ContentstateConverter(features=['link'])
        result = json.loads(converter.from_database_format(
            '''
            <p>an <a linktype="page" id="3">internal</a> link</p>
            '''
        ))
        self.assertContentStateEqual(result, {
            'entityMap': {
                '0': {
                    'mutability': 'MUTABLE', 'type': 'LINK',
                    'data': {'id': 3, 'url': '/events/', 'parentId': 2}
                }
            },
            'blocks': [
                {
                    'inlineStyleRanges': [], 'text': 'an internal link', 'depth': 0, 'type': 'unstyled', 'key': '00000',
                    'entityRanges': [{'offset': 3, 'length': 8, 'key': 0}]
                },
            ]
        })

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_contentstate.py" startline="960" endline="976" pcid="2476">
    def test_reject_javascript_link(self):
        converter = ContentstateConverter(features=['link'])
        contentstate_json = json.dumps({
            'entityMap': {
                '0': {'mutability': 'MUTABLE', 'type': 'LINK', 'data': {'url': "javascript:alert('oh no')"}}
            },
            'blocks': [
                {
                    'inlineStyleRanges': [], 'text': 'an external link', 'depth': 0, 'type': 'unstyled', 'key': '00000',
                    'entityRanges': [{'offset': 3, 'length': 8, 'key': 0}]
                },
            ]
        })

        result = converter.to_database_format(contentstate_json)
        self.assertEqual(result, '<p data-block-key="00000">an <a>external</a> link</p>')

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_contentstate.py" startline="926" endline="942" pcid="2474">
    def test_external_link(self):
        converter = ContentstateConverter(features=['link'])
        contentstate_json = json.dumps({
            'entityMap': {
                '0': {'mutability': 'MUTABLE', 'type': 'LINK', 'data': {'url': 'http://wagtail.org'}}
            },
            'blocks': [
                {
                    'inlineStyleRanges': [], 'text': 'an external link', 'depth': 0, 'type': 'unstyled', 'key': '00000',
                    'entityRanges': [{'offset': 3, 'length': 8, 'key': 0}]
                },
            ]
        })

        result = converter.to_database_format(contentstate_json)
        self.assertEqual(result, '<p data-block-key="00000">an <a href="http://wagtail.org">external</a> link</p>')

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_contentstate.py" startline="943" endline="959" pcid="2475">
    def test_local_link(self):
        converter = ContentstateConverter(features=['link'])
        contentstate_json = json.dumps({
            'entityMap': {
                '0': {'mutability': 'MUTABLE', 'type': 'LINK', 'data': {'url': '/some/local/path/'}}
            },
            'blocks': [
                {
                    'inlineStyleRanges': [], 'text': 'an external link', 'depth': 0, 'type': 'unstyled', 'key': '00000',
                    'entityRanges': [{'offset': 3, 'length': 8, 'key': 0}]
                },
            ]
        })

        result = converter.to_database_format(contentstate_json)
        self.assertEqual(result, '<p data-block-key="00000">an <a href="/some/local/path/">external</a> link</p>')

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_contentstate.py" startline="415" endline="436" pcid="2454">
    def test_document_link_with_missing_id(self):
        converter = ContentstateConverter(features=['document-link'])
        result = json.loads(converter.from_database_format(
            '''
            <p>a <a linktype="document">document</a> link</p>
            '''
        ))
        self.assertContentStateEqual(result, {
            'entityMap': {
                '0': {
                    'mutability': 'MUTABLE', 'type': 'DOCUMENT',
                    'data': {}
                }
            },
            'blocks': [
                {
                    'inlineStyleRanges': [], 'text': 'a document link', 'depth': 0, 'type': 'unstyled', 'key': '00000',
                    'entityRanges': [{'offset': 2, 'length': 8, 'key': 0}]
                },
            ]
        })

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_contentstate.py" startline="393" endline="414" pcid="2453">
    def test_broken_document_link(self):
        converter = ContentstateConverter(features=['document-link'])
        result = json.loads(converter.from_database_format(
            '''
            <p>a <a linktype="document" id="9999">document</a> link</p>
            '''
        ))
        self.assertContentStateEqual(result, {
            'entityMap': {
                '0': {
                    'mutability': 'MUTABLE', 'type': 'DOCUMENT',
                    'data': {'id': 9999}
                }
            },
            'blocks': [
                {
                    'inlineStyleRanges': [], 'text': 'a document link', 'depth': 0, 'type': 'unstyled', 'key': '00000',
                    'entityRanges': [{'offset': 2, 'length': 8, 'key': 0}]
                },
            ]
        })

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_contentstate.py" startline="371" endline="392" pcid="2452">
    def test_document_link(self):
        converter = ContentstateConverter(features=['document-link'])
        result = json.loads(converter.from_database_format(
            '''
            <p>a <a linktype="document" id="1">document</a> link</p>
            '''
        ))
        self.assertContentStateEqual(result, {
            'entityMap': {
                '0': {
                    'mutability': 'MUTABLE', 'type': 'DOCUMENT',
                    'data': {'id': 1, 'url': '/documents/1/test.pdf', 'filename': 'test.pdf'}
                }
            },
            'blocks': [
                {
                    'inlineStyleRanges': [], 'text': 'a document link', 'depth': 0, 'type': 'unstyled', 'key': '00000',
                    'entityRanges': [{'offset': 2, 'length': 8, 'key': 0}]
                },
            ]
        })

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_contentstate.py" startline="265" endline="281" pcid="2447">
    def test_link_in_bare_text(self):
        converter = ContentstateConverter(features=['link'])
        result = json.loads(converter.from_database_format(
            '''an <a href="http://wagtail.org">external</a> link'''
        ))
        self.assertContentStateEqual(result, {
            'entityMap': {
                '0': {'mutability': 'MUTABLE', 'type': 'LINK', 'data': {'url': 'http://wagtail.org'}}
            },
            'blocks': [
                {
                    'inlineStyleRanges': [], 'text': 'an external link', 'depth': 0, 'type': 'unstyled', 'key': '00000',
                    'entityRanges': [{'offset': 3, 'length': 8, 'key': 0}]
                },
            ]
        })

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_contentstate.py" startline="325" endline="348" pcid="2450">
    def test_broken_page_link(self):
        converter = ContentstateConverter(features=['link'])
        result = json.loads(converter.from_database_format(
            '''
            <p>an <a linktype="page" id="9999">internal</a> link</p>
            '''
        ))
        self.assertContentStateEqual(result, {
            'entityMap': {
                '0': {
                    'mutability': 'MUTABLE', 'type': 'LINK',
                    'data': {
                        'id': 9999, 'url': None, 'parentId': None,
                    }
                }
            },
            'blocks': [
                {
                    'inlineStyleRanges': [], 'text': 'an internal link', 'depth': 0, 'type': 'unstyled', 'key': '00000',
                    'entityRanges': [{'offset': 3, 'length': 8, 'key': 0}]
                },
            ]
        })

</source>
</class>

<class classid="120" nclones="5" nlines="13" similarity="78">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_contentstate.py" startline="437" endline="459" pcid="2455">
    def test_image_embed(self):
        converter = ContentstateConverter(features=['image'])
        result = json.loads(converter.from_database_format(
            '''
            <p>before</p>
            <embed embedtype="image" alt="an image" id="1" format="left" />
            <p>after</p>
            '''
        ))
        self.assertContentStateEqual(result, {
            'blocks': [
                {'key': '00000', 'inlineStyleRanges': [], 'entityRanges': [], 'depth': 0, 'text': 'before', 'type': 'unstyled'},
                {'key': '00000', 'inlineStyleRanges': [], 'entityRanges': [{'key': 0, 'offset': 0, 'length': 1}], 'depth': 0, 'text': ' ', 'type': 'atomic'},
                {'key': '00000', 'inlineStyleRanges': [], 'entityRanges': [], 'depth': 0, 'text': 'after', 'type': 'unstyled'}
            ],
            'entityMap': {
                '0': {
                    'data': {'format': 'left', 'alt': 'an image', 'id': '1', 'src': '/media/not-found'},
                    'mutability': 'IMMUTABLE', 'type': 'IMAGE'
                }
            }
        })

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_contentstate.py" startline="622" endline="644" pcid="2460">
    def test_hr(self):
        converter = ContentstateConverter(features=['hr'])
        result = json.loads(converter.from_database_format(
            '''
            <p>before</p>
            <hr />
            <p>after</p>
            '''
        ))
        self.assertContentStateEqual(result, {
            'blocks': [
                {'key': '00000', 'inlineStyleRanges': [], 'entityRanges': [], 'depth': 0, 'text': 'before', 'type': 'unstyled'},
                {'key': '00000', 'inlineStyleRanges': [], 'entityRanges': [{'key': 0, 'offset': 0, 'length': 1}], 'depth': 0, 'text': ' ', 'type': 'atomic'},
                {'key': '00000', 'inlineStyleRanges': [], 'entityRanges': [], 'depth': 0, 'text': 'after', 'type': 'unstyled'}
            ],
            'entityMap': {
                '0': {
                    'data': {},
                    'mutability': 'IMMUTABLE', 'type': 'HORIZONTAL_RULE'
                }
            }
        })

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_contentstate.py" startline="835" endline="857" pcid="2471">
    def test_image_inside_paragraph(self):
        # In Draftail's data model, images are block-level elements and therefore
        # split up preceding / following text into their own paragraphs
        converter = ContentstateConverter(features=['image'])
        result = json.loads(converter.from_database_format(
            '''
            <p>before <embed embedtype="image" alt="an image" id="1" format="left" /> after</p>
            '''
        ))
        self.assertContentStateEqual(result, {
            'blocks': [
                {'key': '00000', 'inlineStyleRanges': [], 'entityRanges': [], 'depth': 0, 'text': 'before', 'type': 'unstyled'},
                {'key': '00000', 'inlineStyleRanges': [], 'entityRanges': [{'key': 0, 'offset': 0, 'length': 1}], 'depth': 0, 'text': ' ', 'type': 'atomic'},
                {'key': '00000', 'inlineStyleRanges': [], 'entityRanges': [], 'depth': 0, 'text': 'after', 'type': 'unstyled'}
            ],
            'entityMap': {
                '0': {
                    'data': {'format': 'left', 'alt': 'an image', 'id': '1', 'src': '/media/not-found'},
                    'mutability': 'IMMUTABLE', 'type': 'IMAGE'
                }
            }
        })

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_contentstate.py" startline="726" endline="749" pcid="2465">
    def test_block_element_in_empty_paragraph(self):
        converter = ContentstateConverter(features=['hr'])
        result = json.loads(converter.from_database_format(
            '''
            <p><hr /></p>
            '''
        ))
        # ignoring the paragraph completely would probably be better,
        # but we'll settle for an empty preceding paragraph and not crashing as the next best thing...
        # (and if it's the first/last block we actually do want a spacer paragraph anyhow)
        self.assertContentStateEqual(result, {
            'blocks': [
                {'key': '00000', 'inlineStyleRanges': [], 'entityRanges': [], 'depth': 0, 'text': '', 'type': 'unstyled'},
                {'key': '00000', 'inlineStyleRanges': [], 'entityRanges': [{'key': 0, 'offset': 0, 'length': 1}], 'depth': 0, 'text': ' ', 'type': 'atomic'},
                {'key': '00000', 'inlineStyleRanges': [], 'entityRanges': [], 'depth': 0, 'text': '', 'type': 'unstyled'},
            ],
            'entityMap': {
                '0': {
                    'data': {},
                    'mutability': 'IMMUTABLE', 'type': 'HORIZONTAL_RULE'
                }
            }
        })

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_contentstate.py" startline="673" endline="693" pcid="2462">
    def test_block_element_in_paragraph(self):
        converter = ContentstateConverter(features=['hr'])
        result = json.loads(converter.from_database_format(
            '''
            <p>before<hr />after</p>
            '''
        ))
        self.assertContentStateEqual(result, {
            'blocks': [
                {'key': '00000', 'inlineStyleRanges': [], 'entityRanges': [], 'depth': 0, 'text': 'before', 'type': 'unstyled'},
                {'key': '00000', 'inlineStyleRanges': [], 'entityRanges': [{'key': 0, 'offset': 0, 'length': 1}], 'depth': 0, 'text': ' ', 'type': 'atomic'},
                {'key': '00000', 'inlineStyleRanges': [], 'entityRanges': [], 'depth': 0, 'text': 'after', 'type': 'unstyled'}
            ],
            'entityMap': {
                '0': {
                    'data': {},
                    'mutability': 'IMMUTABLE', 'type': 'HORIZONTAL_RULE'
                }
            }
        })

</source>
</class>

<class classid="121" nclones="4" nlines="21" similarity="73">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_contentstate.py" startline="460" endline="487" pcid="2456">
    def test_add_spacer_paragraph_between_image_embeds(self):
        converter = ContentstateConverter(features=['image'])
        result = json.loads(converter.from_database_format(
            '''
            <embed embedtype="image" alt="an image" id="1" format="left" />
            <embed embedtype="image" alt="an image" id="1" format="left" />
            '''
        ))
        self.assertContentStateEqual(result, {
            'blocks': [
                {'key': '00000', 'inlineStyleRanges': [], 'entityRanges': [], 'depth': 0, 'text': '', 'type': 'unstyled'},
                {'key': '00000', 'inlineStyleRanges': [], 'entityRanges': [{'key': 0, 'offset': 0, 'length': 1}], 'depth': 0, 'text': ' ', 'type': 'atomic'},
                {'key': '00000', 'inlineStyleRanges': [], 'entityRanges': [], 'depth': 0, 'text': '', 'type': 'unstyled'},
                {'key': '00000', 'inlineStyleRanges': [], 'entityRanges': [{'key': 1, 'offset': 0, 'length': 1}], 'depth': 0, 'text': ' ', 'type': 'atomic'},
                {'key': '00000', 'inlineStyleRanges': [], 'entityRanges': [], 'depth': 0, 'text': '', 'type': 'unstyled'},
            ],
            'entityMap': {
                '0': {
                    'data': {'format': 'left', 'alt': 'an image', 'id': '1', 'src': '/media/not-found'},
                    'mutability': 'IMMUTABLE', 'type': 'IMAGE'
                },
                '1': {
                    'data': {'format': 'left', 'alt': 'an image', 'id': '1', 'src': '/media/not-found'},
                    'mutability': 'IMMUTABLE', 'type': 'IMAGE'
                },
            }
        })

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_contentstate.py" startline="858" endline="889" pcid="2472">
    def test_image_inside_style(self):
        # https://github.com/wagtail/wagtail/issues/4602 - ensure that an <embed> inside
        # an inline style is handled. This is not valid in Draftail as images are block-level,
        # but should be handled without errors, splitting the image into its own block
        converter = ContentstateConverter(features=['image', 'italic'])
        result = json.loads(converter.from_database_format(
            '''
            <p><i>before <embed embedtype="image" alt="an image" id="1" format="left" /> after</i></p>
            <p><i><embed embedtype="image" alt="an image" id="1" format="left" /></i></p>
            '''
        ))
        self.assertContentStateEqual(result, {
            'blocks': [
                {'key': '00000', 'inlineStyleRanges': [{'offset': 0, 'length': 6, 'style': 'ITALIC'}], 'entityRanges': [], 'depth': 0, 'text': 'before', 'type': 'unstyled'},
                {'key': '00000', 'inlineStyleRanges': [], 'entityRanges': [{'key': 0, 'offset': 0, 'length': 1}], 'depth': 0, 'text': ' ', 'type': 'atomic'},
                {'key': '00000', 'inlineStyleRanges': [{'offset': 0, 'length': 5, 'style': 'ITALIC'}], 'entityRanges': [], 'depth': 0, 'text': 'after', 'type': 'unstyled'},
                {'key': '00000', 'inlineStyleRanges': [{'offset': 0, 'length': 0, 'style': 'ITALIC'}], 'entityRanges': [], 'depth': 0, 'text': '', 'type': 'unstyled'},
                {'key': '00000', 'inlineStyleRanges': [], 'entityRanges': [{'key': 1, 'offset': 0, 'length': 1}], 'depth': 0, 'text': ' ', 'type': 'atomic'},
                {'key': '00000', 'inlineStyleRanges': [{'offset': 0, 'length': 0, 'style': 'ITALIC'}], 'entityRanges': [], 'depth': 0, 'text': '', 'type': 'unstyled'},
            ],
            'entityMap': {
                '0': {
                    'data': {'format': 'left', 'alt': 'an image', 'id': '1', 'src': '/media/not-found'},
                    'mutability': 'IMMUTABLE', 'type': 'IMAGE'
                },
                '1': {
                    'data': {'format': 'left', 'alt': 'an image', 'id': '1', 'src': '/media/not-found'},
                    'mutability': 'IMMUTABLE', 'type': 'IMAGE'
                },
            }
        })

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_contentstate.py" startline="645" endline="672" pcid="2461">
    def test_add_spacer_paragraph_between_hrs(self):
        converter = ContentstateConverter(features=['hr'])
        result = json.loads(converter.from_database_format(
            '''
            <hr />
            <hr />
            '''
        ))
        self.assertContentStateEqual(result, {
            'blocks': [
                {'key': '00000', 'inlineStyleRanges': [], 'entityRanges': [], 'depth': 0, 'text': '', 'type': 'unstyled'},
                {'key': '00000', 'inlineStyleRanges': [], 'entityRanges': [{'key': 0, 'offset': 0, 'length': 1}], 'depth': 0, 'text': ' ', 'type': 'atomic'},
                {'key': '00000', 'inlineStyleRanges': [], 'entityRanges': [], 'depth': 0, 'text': '', 'type': 'unstyled'},
                {'key': '00000', 'inlineStyleRanges': [], 'entityRanges': [{'key': 1, 'offset': 0, 'length': 1}], 'depth': 0, 'text': ' ', 'type': 'atomic'},
                {'key': '00000', 'inlineStyleRanges': [], 'entityRanges': [], 'depth': 0, 'text': '', 'type': 'unstyled'},
            ],
            'entityMap': {
                '0': {
                    'data': {},
                    'mutability': 'IMMUTABLE', 'type': 'HORIZONTAL_RULE'
                },
                '1': {
                    'data': {},
                    'mutability': 'IMMUTABLE', 'type': 'HORIZONTAL_RULE'
                },
            }
        })

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_contentstate.py" startline="890" endline="924" pcid="2473">
    def test_image_inside_link(self):
        # https://github.com/wagtail/wagtail/issues/4602 - ensure that an <embed> inside
        # a link is handled. This is not valid in Draftail as images are block-level,
        # but should be handled without errors, splitting the image into its own block
        converter = ContentstateConverter(features=['image', 'link'])
        result = json.loads(converter.from_database_format(
            '''
            <p><a href="https://wagtail.org">before <embed embedtype="image" alt="an image" id="1" format="left" /> after</a></p>
            <p><a href="https://wagtail.org"><embed embedtype="image" alt="an image" id="1" format="left" /></a></p>
            '''
        ))
        self.assertContentStateEqual(result, {
            'blocks': [
                {'key': '00000', 'inlineStyleRanges': [], 'entityRanges': [{'key': 0, 'offset': 0, 'length': 6}], 'depth': 0, 'text': 'before', 'type': 'unstyled'},
                {'key': '00000', 'inlineStyleRanges': [], 'entityRanges': [{'key': 1, 'offset': 0, 'length': 1}], 'depth': 0, 'text': ' ', 'type': 'atomic'},
                {'key': '00000', 'inlineStyleRanges': [], 'entityRanges': [{'key': 0, 'offset': 0, 'length': 5}], 'depth': 0, 'text': 'after', 'type': 'unstyled'},
                {'key': '00000', 'inlineStyleRanges': [], 'entityRanges': [{'key': 2, 'offset': 0, 'length': 0}], 'depth': 0, 'text': '', 'type': 'unstyled'},
                {'key': '00000', 'inlineStyleRanges': [], 'entityRanges': [{'key': 3, 'offset': 0, 'length': 1}], 'depth': 0, 'text': ' ', 'type': 'atomic'},
                {'key': '00000', 'inlineStyleRanges': [], 'entityRanges': [{'key': 2, 'offset': 0, 'length': 0}], 'depth': 0, 'text': '', 'type': 'unstyled'},
            ],
            'entityMap': {
                '0': {'mutability': 'MUTABLE', 'type': 'LINK', 'data': {'url': 'https://wagtail.org'}},
                '1': {
                    'data': {'format': 'left', 'alt': 'an image', 'id': '1', 'src': '/media/not-found'},
                    'mutability': 'IMMUTABLE', 'type': 'IMAGE'
                },
                '2': {'mutability': 'MUTABLE', 'type': 'LINK', 'data': {'url': 'https://wagtail.org'}},
                '3': {
                    'data': {'format': 'left', 'alt': 'an image', 'id': '1', 'src': '/media/not-found'},
                    'mutability': 'IMMUTABLE', 'type': 'IMAGE'
                },
            }
        })


</source>
</class>

<class classid="122" nclones="3" nlines="10" similarity="70">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_edit_handlers.py" startline="41" endline="60" pcid="2492">
    def test_get_form_for_model(self):
        EventPageForm = get_form_for_model(EventPage, form_class=WagtailAdminPageForm)
        form = EventPageForm()

        # form should be a subclass of WagtailAdminModelForm
        self.assertTrue(issubclass(EventPageForm, WagtailAdminModelForm))
        # form should contain a title field (from the base Page)
        self.assertEqual(type(form.fields['title']), forms.CharField)
        # and 'date_from' from EventPage
        self.assertEqual(type(form.fields['date_from']), forms.DateField)
        # the widget should be overridden with AdminDateInput as per FORM_FIELD_OVERRIDES
        self.assertEqual(type(form.fields['date_from'].widget), AdminDateInput)

        # treebeard's 'path' field should be excluded
        self.assertNotIn('path', form.fields)

        # all child relations become formsets by default
        self.assertIn('speakers', form.formsets)
        self.assertIn('related_links', form.formsets)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_edit_handlers.py" startline="76" endline="90" pcid="2494">
    def test_get_form_for_model_with_specific_fields(self):
        EventPageForm = get_form_for_model(
            EventPage, form_class=WagtailAdminPageForm, fields=['date_from'],
            formsets=['speakers'])
        form = EventPageForm()

        # form should contain date_from but not title
        self.assertEqual(type(form.fields['date_from']), forms.DateField)
        self.assertEqual(type(form.fields['date_from'].widget), AdminDateInput)
        self.assertNotIn('title', form.fields)

        # formsets should include speakers but not related_links
        self.assertIn('speakers', form.formsets)
        self.assertNotIn('related_links', form.formsets)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_edit_handlers.py" startline="91" endline="108" pcid="2495">
    def test_get_form_for_model_with_excluded_fields(self):
        EventPageForm = get_form_for_model(
            EventPage, form_class=WagtailAdminPageForm,
            exclude=['title'], exclude_formsets=['related_links'])
        form = EventPageForm()

        # form should contain date_from but not title
        self.assertEqual(type(form.fields['date_from']), forms.DateField)
        self.assertEqual(type(form.fields['date_from'].widget), AdminDateInput)
        self.assertNotIn('title', form.fields)

        # 'path' is not excluded any more, as the excluded fields were overridden
        self.assertIn('path', form.fields)

        # formsets should include speakers but not related_links
        self.assertIn('speakers', form.formsets)
        self.assertNotIn('related_links', form.formsets)

</source>
</class>

<class classid="123" nclones="3" nlines="14" similarity="78">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_edit_handlers.py" startline="324" endline="350" pcid="2513">
    def test_render(self):
        EventPageForm = self.event_page_tabbed_interface.get_form_class()
        event = EventPage(title='Abergavenny sheepdog trials')
        form = EventPageForm(instance=event)

        tabbed_interface = self.event_page_tabbed_interface.bind_to(
            instance=event,
            form=form,
        )

        result = tabbed_interface.render()

        # result should contain tab buttons
        self.assertIn('<a href="#tab-event-details" class="active" data-tab="event-details">Event details</a>', result)
        self.assertIn('<a href="#tab-speakers" class="" data-tab="speakers">Speakers</a>', result)

        # result should contain tab panels
        self.assertIn('<div class="tab-content">', result)
        self.assertIn('<section id="tab-event-details" class="shiny active" role="tabpanel" aria-labelledby="tab-label-event-details" data-tab="event-details">', result)
        self.assertIn('<section id="tab-speakers" class=" " role="tabpanel" aria-labelledby="tab-label-speakers" data-tab="speakers">', result)

        # result should contain rendered content from descendants
        self.assertIn('Abergavenny sheepdog trials</textarea>', result)

        # this result should not include fields that are not covered by the panel definition
        self.assertNotIn('signup_link', result)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_edit_handlers.py" startline="398" endline="425" pcid="2518">
    def test_render(self):
        EventPageForm = self.event_page_object_list.get_form_class()
        event = EventPage(title='Abergavenny sheepdog trials')
        form = EventPageForm(instance=event)

        object_list = self.event_page_object_list.bind_to(
            instance=event,
            form=form,
        )

        result = object_list.render()

        # result should contain ObjectList furniture
        self.assertIn('<ul class="objects">', result)

        # result should contain labels for children
        self.assertInHTML('<label for="id_date_from">Start date</label>', result)

        # result should include help text for children
        self.assertInHTML('<div class="object-help help"> <svg class="icon icon-help default" aria-hidden="true" focusable="false"><use href="#icon-help"></use></svg> Not required if event is on a single day</div>', result)

        # result should contain rendered content from descendants
        self.assertIn('Abergavenny sheepdog trials</textarea>', result)

        # this result should not include fields that are not covered by the panel definition
        self.assertNotIn('signup_link', result)


</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_edit_handlers.py" startline="356" endline="373" pcid="2515">
    def test_render_form_content(self):
        EventPageForm = self.event_page_tabbed_interface.get_form_class()
        event = EventPage(title='Abergavenny sheepdog trials')
        form = EventPageForm(instance=event)

        tabbed_interface = self.event_page_tabbed_interface.bind_to(
            instance=event,
            form=form,
        )

        result = tabbed_interface.render_form_content()
        # rendered output should contain field content as above
        self.assertIn('Abergavenny sheepdog trials</textarea>', result)
        # rendered output should NOT include fields that are in the model but not represented
        # in the panel definition
        self.assertNotIn('signup_link', result)


</source>
</class>

<class classid="124" nclones="9" nlines="14" similarity="73">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_edit_handlers.py" startline="462" endline="488" pcid="2522">
    def test_render_as_object(self):
        form = self.EventPageForm(
            {'title': 'Pontypridd sheepdog trials', 'date_from': '2014-07-20', 'date_to': '2014-07-22'},
            instance=self.event)

        form.is_valid()

        field_panel = self.end_date_panel.bind_to(
            instance=self.event,
            form=form,
        )
        result = field_panel.render_as_object()

        # check that label appears as a legend in the 'object' wrapper,
        # but not as a field label (that would be provided by ObjectList instead)
        self.assertIn('<legend>End date</legend>', result)
        self.assertNotIn('<label for="id_date_to">End date:</label>', result)

        # check that help text is not included (it's provided by ObjectList instead)
        self.assertNotIn('Not required if event is on a single day', result)

        # check that the populated form field is included
        self.assertIn('value="2014-07-22"', result)

        # there should be no errors on this field
        self.assertNotIn('<p class="error-message">', result)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_edit_handlers.py" startline="565" endline="583" pcid="2528">
    def test_render_as_object(self):
        form = self.EventPageForm(
            {'title': 'Pontypridd sheepdog trials', 'date_from': '2014-07-20', 'date_to': '2014-07-22'},
            instance=self.event)

        form.is_valid()

        field_panel = self.dates_panel.bind_to(
            instance=self.event,
            form=form,
        )
        result = field_panel.render_as_object()

        # check that the populated form field is included
        self.assertIn('value="2014-07-22"', result)

        # there should be no errors on this field
        self.assertNotIn('<p class="error-message">', result)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_edit_handlers.py" startline="489" endline="514" pcid="2523">
    def test_render_as_field(self):
        form = self.EventPageForm(
            {'title': 'Pontypridd sheepdog trials', 'date_from': '2014-07-20', 'date_to': '2014-07-22'},
            instance=self.event)

        form.is_valid()

        field_panel = self.end_date_panel.bind_to(
            instance=self.event,
            form=form,
        )
        result = field_panel.render_as_field()

        # check that label is output in the 'field' style
        self.assertIn('<label for="id_date_to">End date:</label>', result)
        self.assertNotIn('<legend>End date</legend>', result)

        # check that help text is included
        self.assertIn('Not required if event is on a single day', result)

        # check that the populated form field is included
        self.assertIn('value="2014-07-22"', result)

        # there should be no errors on this field
        self.assertNotIn('<p class="error-message">', result)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_edit_handlers.py" startline="519" endline="534" pcid="2525">
    def test_error_message_is_rendered(self):
        form = self.EventPageForm(
            {'title': 'Pontypridd sheepdog trials', 'date_from': '2014-07-20', 'date_to': '2014-07-33'},
            instance=self.event)

        form.is_valid()

        field_panel = self.end_date_panel.bind_to(
            instance=self.event,
            form=form,
        )
        result = field_panel.render_as_field()

        self.assertIn('<p class="error-message">', result)
        self.assertIn('<span>Enter a valid date.</span>', result)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_edit_handlers.py" startline="629" endline="644" pcid="2531">
    def test_add_col_when_wrong_in_panel_def(self):
        form = self.EventPageForm(
            {'title': 'Pontypridd sheepdog trials', 'date_from': '2014-07-20', 'date_to': '2014-07-33'},
            instance=self.event)

        form.is_valid()

        field_panel = self.dates_panel.bind_to(
            instance=self.event,
            form=form,
        )

        result = field_panel.render_as_field()

        self.assertIn('<li class="field-col coltwo col6', result)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_edit_handlers.py" startline="613" endline="628" pcid="2530">
    def test_error_message_is_rendered(self):
        form = self.EventPageForm(
            {'title': 'Pontypridd sheepdog trials', 'date_from': '2014-07-20', 'date_to': '2014-07-33'},
            instance=self.event)

        form.is_valid()

        field_panel = self.dates_panel.bind_to(
            instance=self.event,
            form=form,
        )
        result = field_panel.render_as_field()

        self.assertIn('<p class="error-message">', result)
        self.assertIn('<span>Enter a valid date.</span>', result)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_edit_handlers.py" startline="645" endline="661" pcid="2532">
    def test_added_col_doesnt_change_siblings(self):
        form = self.EventPageForm(
            {'title': 'Pontypridd sheepdog trials', 'date_from': '2014-07-20', 'date_to': '2014-07-33'},
            instance=self.event)

        form.is_valid()

        field_panel = self.dates_panel.bind_to(
            instance=self.event,
            form=form,
        )

        result = field_panel.render_as_field()

        self.assertIn('<li class="field-col col4', result)


</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_edit_handlers.py" startline="678" endline="697" pcid="2534">
    def test_render_as_object(self):
        form = self.EventPageForm(
            {'title': 'Pontypridd sheepdog trials', 'date_from': '2014-07-20', 'date_to': '2014-07-22'},
            instance=self.event)

        form.is_valid()

        field_panel = self.dates_panel.bind_to(
            instance=self.event,
            form=form,
        )
        result = field_panel.render_as_object()

        # check that the populated form field is included
        self.assertIn('value="2014-07-20"', result)

        # there should be no errors on this field
        self.assertNotIn('<p class="error-message">', result)


</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_edit_handlers.py" startline="584" endline="612" pcid="2529">
    def test_render_as_field(self):
        form = self.EventPageForm(
            {'title': 'Pontypridd sheepdog trials', 'date_from': '2014-07-20', 'date_to': '2014-07-22'},
            instance=self.event)

        form.is_valid()

        field_panel = self.dates_panel.bind_to(
            instance=self.event,
            form=form,
        )
        result = field_panel.render_as_field()

        # check that label is output in the 'field' style
        self.assertIn('<label for="id_date_to">End date:</label>', result)
        self.assertNotIn('<legend>End date</legend>', result)

        # check that label is overridden with the 'heading' argument
        self.assertIn('<label for="id_date_from">Start:</label>', result)

        # check that help text is included
        self.assertIn('Not required if event is on a single day', result)

        # check that the populated form field is included
        self.assertIn('value="2014-07-22"', result)

        # there should be no errors on this field
        self.assertNotIn('<p class="error-message">', result)

</source>
</class>

<class classid="125" nclones="2" nlines="12" similarity="83">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_edit_handlers.py" startline="550" endline="564" pcid="2527">
    def setUp(self):
        self.request = RequestFactory().get('/')
        user = AnonymousUser()  # technically, Anonymous users cannot access the admin
        self.request.user = user

        self.EventPageForm = get_form_for_model(
            EventPage, form_class=WagtailAdminPageForm, formsets=[])
        self.event = EventPage(title='Abergavenny sheepdog trials',
                               date_from=date(2014, 7, 20), date_to=date(2014, 7, 21))

        self.dates_panel = FieldRowPanel([
            FieldPanel('date_from', classname='col4', heading="Start"),
            FieldPanel('date_to', classname='coltwo'),
        ]).bind_to(model=EventPage, request=self.request)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_edit_handlers.py" startline="663" endline="677" pcid="2533">
    def setUp(self):
        self.request = RequestFactory().get('/')
        user = AnonymousUser()  # technically, Anonymous users cannot access the admin
        self.request.user = user

        self.EventPageForm = get_form_for_model(
            EventPage, form_class=WagtailAdminPageForm, formsets=[])
        self.event = EventPage(title='Abergavenny sheepdog trials',
                               date_from=date(2014, 7, 19), date_to=date(2014, 7, 21))

        self.dates_panel = FieldRowPanel([
            FieldPanel('date_from'),
            ImageChooserPanel('feed_image'),
        ]).bind_to(model=EventPage, request=self.request)

</source>
</class>

<class classid="126" nclones="2" nlines="12" similarity="91">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_edit_handlers.py" startline="736" endline="754" pcid="2538">
    def test_render_js_init_with_can_choose_root_true(self):
        # construct an alternative page chooser panel object, with can_choose_root=True

        my_page_object_list = ObjectList([
            PageChooserPanel('page', can_choose_root=True)
        ]).bind_to(model=PageChooserModel)
        my_page_chooser_panel = my_page_object_list.children[0]
        PageChooserForm = my_page_object_list.get_form_class()

        form = PageChooserForm(instance=self.test_instance)
        page_chooser_panel = my_page_chooser_panel.bind_to(
            instance=self.test_instance, form=form, request=self.request)
        result = page_chooser_panel.render_as_field()

        # the canChooseRoot flag on createPageChooser should now be true
        expected_js = 'createPageChooser("{id}", {parent}, {{"model_names": ["{model}"], "can_choose_root": true, "user_perms": null}});'.format(
            id="id_page", model="wagtailcore.page", parent=self.events_index_page.id)
        self.assertIn(expected_js, result)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_edit_handlers.py" startline="787" endline="804" pcid="2543">
    def test_override_page_type(self):
        # Model has a foreign key to Page, but we specify EventPage in the PageChooserPanel
        # to restrict the chooser to that page type
        my_page_object_list = ObjectList([
            PageChooserPanel('page', 'tests.EventPage')
        ]).bind_to(model=EventPageChooserModel)
        my_page_chooser_panel = my_page_object_list.children[0]
        PageChooserForm = my_page_object_list.get_form_class()
        form = PageChooserForm(instance=self.test_instance)
        page_chooser_panel = my_page_chooser_panel.bind_to(
            instance=self.test_instance, form=form, request=self.request)

        result = page_chooser_panel.render_as_field()
        expected_js = 'createPageChooser("{id}", {parent}, {{"model_names": ["{model}"], "can_choose_root": false, "user_perms": null}});'.format(
            id="id_page", model="tests.eventpage", parent=self.events_index_page.id)

        self.assertIn(expected_js, result)

</source>
</class>

<class classid="127" nclones="2" nlines="31" similarity="75">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_edit_handlers.py" startline="856" endline="905" pcid="2549">
    def test_render(self):
        """
        Check that the inline panel renders the panels set on the model
        when no 'panels' parameter is passed in the InlinePanel definition
        """
        speaker_object_list = ObjectList([
            InlinePanel('speakers', label="Speakers", classname="classname-for-speakers")
        ]).bind_to(model=EventPage, request=self.request)
        EventPageForm = speaker_object_list.get_form_class()

        # SpeakerInlinePanel should instruct the form class to include a 'speakers' formset
        self.assertEqual(['speakers'], list(EventPageForm.formsets.keys()))

        event_page = EventPage.objects.get(slug='christmas')

        form = EventPageForm(instance=event_page)
        panel = speaker_object_list.bind_to(instance=event_page, form=form)

        result = panel.render_as_field()

        self.assertIn('<li class="object classname-for-speakers">', result)
        self.assertIn('<label for="id_speakers-0-first_name">Name:</label>', result)
        self.assertIn('value="Father"', result)
        self.assertIn('<label for="id_speakers-0-last_name">Surname:</label>', result)
        self.assertIn('<label for="id_speakers-0-image">Image:</label>', result)
        self.assertIn('Choose an image', result)

        # rendered panel must also contain hidden fields for id, DELETE and ORDER
        self.assertTagInHTML(
            '<input id="id_speakers-0-id" name="speakers-0-id" type="hidden">',
            result, allow_extra_attrs=True
        )
        self.assertTagInHTML(
            '<input id="id_speakers-0-DELETE" name="speakers-0-DELETE" type="hidden">',
            result, allow_extra_attrs=True
        )
        self.assertTagInHTML(
            '<input id="id_speakers-0-ORDER" name="speakers-0-ORDER" type="hidden">',
            result, allow_extra_attrs=True
        )

        # rendered panel must contain maintenance form for the formset
        self.assertTagInHTML(
            '<input id="id_speakers-TOTAL_FORMS" name="speakers-TOTAL_FORMS" type="hidden">',
            result, allow_extra_attrs=True
        )

        # rendered panel must include the JS initializer
        self.assertIn('var panel = InlinePanel({', result)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_edit_handlers.py" startline="906" endline="963" pcid="2550">
    def test_render_with_panel_overrides(self):
        """
        Check that inline panel renders the panels listed in the InlinePanel definition
        where one is specified
        """
        speaker_object_list = ObjectList([
            InlinePanel('speakers', label="Speakers", panels=[
                FieldPanel('first_name', widget=forms.Textarea),
                ImageChooserPanel('image'),
            ]),
        ]).bind_to(model=EventPage, request=self.request)
        speaker_inline_panel = speaker_object_list.children[0]
        EventPageForm = speaker_object_list.get_form_class()

        # speaker_inline_panel should instruct the form class to include a 'speakers' formset
        self.assertEqual(['speakers'], list(EventPageForm.formsets.keys()))

        event_page = EventPage.objects.get(slug='christmas')

        form = EventPageForm(instance=event_page)
        panel = speaker_inline_panel.bind_to(instance=event_page, form=form)

        result = panel.render_as_field()

        # rendered panel should contain first_name rendered as a text area, but no last_name field
        self.assertIn('<label for="id_speakers-0-first_name">Name:</label>', result)
        self.assertIn('Father</textarea>', result)
        self.assertNotIn('<label for="id_speakers-0-last_name">Surname:</label>', result)

        # test for #338: surname field should not be rendered as a 'stray' label-less field
        self.assertTagInHTML('<input id="id_speakers-0-last_name">', result, count=0, allow_extra_attrs=True)

        self.assertIn('<label for="id_speakers-0-image">Image:</label>', result)
        self.assertIn('Choose an image', result)

        # rendered panel must also contain hidden fields for id, DELETE and ORDER
        self.assertTagInHTML(
            '<input id="id_speakers-0-id" name="speakers-0-id" type="hidden">',
            result, allow_extra_attrs=True
        )
        self.assertTagInHTML(
            '<input id="id_speakers-0-DELETE" name="speakers-0-DELETE" type="hidden">',
            result, allow_extra_attrs=True
        )
        self.assertTagInHTML(
            '<input id="id_speakers-0-ORDER" name="speakers-0-ORDER" type="hidden">',
            result, allow_extra_attrs=True
        )

        # rendered panel must contain maintenance form for the formset
        self.assertTagInHTML(
            '<input id="id_speakers-TOTAL_FORMS" name="speakers-TOTAL_FORMS" type="hidden">',
            result, allow_extra_attrs=True
        )

        # render_js_init must provide the JS initializer
        self.assertIn('var panel = InlinePanel({', panel.render_js_init())

</source>
</class>

<class classid="128" nclones="2" nlines="22" similarity="72">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_edit_handlers.py" startline="1210" endline="1233" pcid="2566">
    def test_users_can_edit_comment_positions(self):
        form = self.EventPageForm({
            'comments-TOTAL_FORMS': 1,
            'comments-INITIAL_FORMS': 1,
            'comments-MIN_NUM_FORMS': 0,
            'comments-MAX_NUM_FORMS': 1000,
            'comments-0-id': self.comment.pk,
            'comments-0-text': self.comment.text,
            'comments-0-contentpath': self.comment.contentpath,
            'comments-0-position': 'a_new_position',  # Try to change the position of a comment
            'comments-0-DELETE': 0,
            'comments-0-replies-TOTAL_FORMS': 0,
            'comments-0-replies-INITIAL_FORMS': 0,
            'comments-0-replies-MIN_NUM_FORMS': 0,
            'comments-0-replies-MAX_NUM_FORMS': 1000,
        },
            instance=self.event_page
        )

        comment_form = form.formsets['comments'].forms[0]
        self.assertTrue(comment_form.is_valid())
        # Users can change the positions of other users' comments within a field
        # eg by editing a rich text field

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_edit_handlers.py" startline="1235" endline="1262" pcid="2567">
    def test_comment_resolve(self):
        form = self.EventPageForm({
            'comments-TOTAL_FORMS': 1,
            'comments-INITIAL_FORMS': 1,
            'comments-MIN_NUM_FORMS': 0,
            'comments-MAX_NUM_FORMS': 1000,
            'comments-0-id': self.comment.pk,
            'comments-0-text': self.comment.text,
            'comments-0-contentpath': self.comment.contentpath,
            'comments-0-resolved': 1,
            'comments-0-replies-TOTAL_FORMS': 0,
            'comments-0-replies-INITIAL_FORMS': 0,
            'comments-0-replies-MIN_NUM_FORMS': 0,
            'comments-0-replies-MAX_NUM_FORMS': 1000,
        },
            instance=self.event_page
        )
        comment_form = form.formsets['comments'].forms[0]
        self.assertTrue(comment_form.is_valid())
        comment_form.save()
        resolved_comment = Comment.objects.get(pk=self.comment.pk)
        self.assertEqual(resolved_comment.resolved_by, self.commenting_user)

        if settings.USE_TZ:
            self.assertEqual(resolved_comment.resolved_at, datetime(2017, 1, 1, 12, 0, 0, tzinfo=utc))
        else:
            self.assertEqual(resolved_comment.resolved_at, datetime(2017, 1, 1, 12, 0, 0))

</source>
</class>

<class classid="129" nclones="2" nlines="15" similarity="73">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_privacy.py" startline="98" endline="125" pcid="2575">
    def test_set_password_restriction(self):
        """
        This tests that setting a password restriction using the set_privacy view works
        """
        post_data = {
            'restriction_type': 'password',
            'password': 'helloworld',
            'groups': [],
        }
        response = self.client.post(reverse('wagtailadmin_pages:set_privacy', args=(self.public_page.id, )), post_data)

        # Check response
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, '"is_public": false')

        # Check that a page restriction has been created
        self.assertTrue(PageViewRestriction.objects.filter(page=self.public_page).exists())
        restriction = PageViewRestriction.objects.get(page=self.public_page)

        # Check that the password is set correctly
        self.assertEqual(restriction.password, 'helloworld')

        # Check that the restriction_type is set correctly
        self.assertEqual(restriction.restriction_type, 'password')

        # Be sure there are no groups set
        self.assertEqual(restriction.groups.count(), 0)

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/test_privacy.py" startline="178" endline="209" pcid="2579">
    def test_set_group_restriction(self):
        """
        This tests that setting a group restriction using the set_privacy view works
        """
        post_data = {
            'restriction_type': 'groups',
            'password': '',
            'groups': [self.group.id, self.group2.id],
        }
        response = self.client.post(reverse('wagtailadmin_pages:set_privacy', args=(self.public_page.id, )), post_data)

        # Check response
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, '"is_public": false')

        # Check that a page restriction has been created
        self.assertTrue(PageViewRestriction.objects.filter(page=self.public_page).exists())

        restriction = PageViewRestriction.objects.get(page=self.public_page)

        # restriction_type should be 'groups'
        self.assertEqual(restriction.restriction_type, 'groups')

        # Be sure there is no password set
        self.assertEqual(restriction.password, '')

        # Check that the groups are set correctly
        self.assertEqual(
            set(PageViewRestriction.objects.get(page=self.public_page).groups.all()),
            set([self.group, self.group2])
        )

</source>
</class>

<class classid="130" nclones="2" nlines="11" similarity="90">
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/ui/test_tables.py" startline="19" endline="42" pcid="2593">
    def test_table_render(self):
        data = [
            {'first_name': 'Paul', 'last_name': 'Simon'},
            {'first_name': 'Art', 'last_name': 'Garfunkel'},
        ]

        table = Table([
            Column('first_name'),
            Column('last_name'),
        ], data)

        html = self.render_component(table)
        self.assertHTMLEqual(html, '''
            <table class="listing">
                <thead>
                    <tr><th>First name</th><th>Last name</th></tr>
                </thead>
                <tbody>
                    <tr><td>Paul</td><td>Simon</td></tr>
                    <tr><td>Art</td><td>Garfunkel</td></tr>
                </tbody>
            </table>
        ''')

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/tests/ui/test_tables.py" startline="43" endline="68" pcid="2594">
    def test_table_render_with_width(self):
        data = [
            {'first_name': 'Paul', 'last_name': 'Simon'},
            {'first_name': 'Art', 'last_name': 'Garfunkel'},
        ]

        table = Table([
            Column('first_name'),
            Column('last_name', width='75%'),
        ], data)

        html = self.render_component(table)
        self.assertHTMLEqual(html, '''
            <table class="listing">
                <col />
                <col width="75%" />
                <thead>
                    <tr><th>First name</th><th>Last name</th></tr>
                </thead>
                <tbody>
                    <tr><td>Paul</td><td>Simon</td></tr>
                    <tr><td>Art</td><td>Garfunkel</td></tr>
                </tbody>
            </table>
        ''')

</source>
</class>

<class classid="131" nclones="2" nlines="10" similarity="90">
<source file="systems/wagtail-2.16.1/wagtail/admin/viewsets/model.py" startline="36" endline="46" pcid="2626">
    def add_view(self):
        return self.add_view_class.as_view(
            model=self.model,
            permission_policy=self.permission_policy,
            form_class=self.get_form_class(),
            index_url_name=self.get_url_name('index'),
            add_url_name=self.get_url_name('add'),
            edit_url_name=self.get_url_name('edit'),
            header_icon=self.icon,
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/viewsets/model.py" startline="48" endline="58" pcid="2627">
    def edit_view(self):
        return self.edit_view_class.as_view(
            model=self.model,
            permission_policy=self.permission_policy,
            form_class=self.get_form_class(for_update=True),
            index_url_name=self.get_url_name('index'),
            edit_url_name=self.get_url_name('edit'),
            delete_url_name=self.get_url_name('delete'),
            header_icon=self.icon,
        )

</source>
</class>

<class classid="132" nclones="5" nlines="10" similarity="90">
<source file="systems/wagtail-2.16.1/wagtail/admin/api/actions/revert_to_page_revision.py" startline="29" endline="40" pcid="2642">
    def execute(self, instance, data):
        action = self._action_from_data(instance, data)

        try:
            new_revision = action.execute()
        except DjangoValidationError as e:
            raise ValidationError(e.message_dict)
        except RevertToPageRevisionError as e:
            raise BadRequestError(e.args[0])

        serializer = self.view.get_serializer(new_revision.as_page_object())
        return Response(serializer.data, status=status.HTTP_200_OK)
</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/api/actions/create_alias.py" startline="37" endline="48" pcid="2655">
    def execute(self, instance, data):
        action = self._action_from_data(instance, data)

        try:
            new_page = action.execute()
        except DjangoValidationError as e:
            raise ValidationError(e.message_dict)
        except CreatePageAliasIntegrityError as e:
            raise BadRequestError(e.args[0])

        serializer = self.view.get_serializer(new_page)
        return Response(serializer.data, status=status.HTTP_201_CREATED)
</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/api/actions/copy_for_translation.py" startline="38" endline="49" pcid="2659">
    def execute(self, instance, data):
        action = self._action_from_data(instance, data)

        try:
            translated_page = action.execute()
        except DjangoValidationError as e:
            raise ValidationError(e.message_dict)
        except ParentNotTranslatedError as e:
            raise BadRequestError(e.args[0])

        serializer = self.view.get_serializer(translated_page)
        return Response(serializer.data, status=status.HTTP_201_CREATED)
</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/api/actions/convert_alias.py" startline="19" endline="30" pcid="2649">
    def execute(self, instance, data):
        action = self._action_from_data(instance, data)

        try:
            new_page = action.execute()
        except DjangoValidationError as e:
            raise ValidationError(e.message_dict)
        except ConvertAliasPageError as e:
            raise BadRequestError(e.args[0])

        serializer = self.view.get_serializer(new_page)
        return Response(serializer.data, status=status.HTTP_200_OK)
</source>
<source file="systems/wagtail-2.16.1/wagtail/admin/api/actions/copy.py" startline="56" endline="67" pcid="2647">
    def execute(self, instance, data):
        action = self._action_from_data(instance, data)

        try:
            new_page = action.execute()
        except DjangoValidationError as e:
            raise ValidationError(e.message_dict)
        except CopyPageIntegrityError as e:
            raise BadRequestError(e.args[0])

        serializer = self.view.get_serializer(new_page)
        return Response(serializer.data, status=status.HTTP_201_CREATED)
</source>
</class>

<class classid="133" nclones="4" nlines="11" similarity="78">
<source file="systems/wagtail-2.16.1/wagtail/admin/widgets/chooser.py" startline="144" endline="156" pcid="2721">
    def render_html(self, name, value_data, attrs):
        value_data = value_data or {}
        original_field_html = super().render_html(name, value_data.get('id'), attrs)

        return render_to_string("wagtailadmin/widgets/page_chooser.html", {
            'widget': self,
            'original_field_html': original_field_html,
            'attrs': attrs,
            'value': bool(value_data),  # only used by chooser.html to identify blank values
            'display_title': value_data.get('display_title', ''),
            'edit_url': value_data.get('edit_url', ''),
        })

</source>
<source file="systems/wagtail-2.16.1/wagtail/documents/widgets.py" startline="39" endline="51" pcid="4866">
    def render_html(self, name, value_data, attrs):
        value_data = value_data or {}
        original_field_html = super().render_html(name, value_data.get('id'), attrs)

        return render_to_string("wagtaildocs/widgets/document_chooser.html", {
            'widget': self,
            'original_field_html': original_field_html,
            'attrs': attrs,
            'value': bool(value_data),  # only used by chooser.html to identify blank values
            'display_title': value_data.get('title', ''),
            'edit_url': value_data.get('edit_url', ''),
        })

</source>
<source file="systems/wagtail-2.16.1/wagtail/snippets/widgets.py" startline="47" endline="64" pcid="3120">
    def render_html(self, name, value_data, attrs):
        value_data = value_data or {}

        original_field_html = super().render_html(name, value_data.get('id'), attrs)
        chooser_url = reverse(
            'wagtailsnippets:choose', args=[self.target_model._meta.app_label, self.target_model._meta.model_name]
        )

        return render_to_string("wagtailsnippets/widgets/snippet_chooser.html", {
            'widget': self,
            'original_field_html': original_field_html,
            'attrs': attrs,
            'value': bool(value_data),  # only used by chooser.html to identify blank values
            'display_title': value_data.get('string', ''),
            'edit_url': value_data.get('edit_url', ''),
            'chooser_url': chooser_url,
        })

</source>
<source file="systems/wagtail-2.16.1/wagtail/images/widgets.py" startline="47" endline="60" pcid="5419">
    def render_html(self, name, value_data, attrs):
        value_data = value_data or {}
        original_field_html = super().render_html(name, value_data.get('id'), attrs)

        return render_to_string("wagtailimages/widgets/image_chooser.html", {
            'widget': self,
            'original_field_html': original_field_html,
            'attrs': attrs,
            'value': bool(value_data),  # only used by chooser.html to identify blank values
            'title': value_data.get('title', ''),
            'preview': value_data.get('preview', {}),
            'edit_url': value_data.get('edit_url', ''),
        })

</source>
</class>

<class classid="134" nclones="2" nlines="13" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/snippets/tests.py" startline="337" endline="353" pcid="2916">
    def test_create_with_tags(self):
        tags = ['hello', 'world']
        response = self.post(post_data={'text': 'test_advert',
                                        'url': 'http://example.com/',
                                        'tags': ', '.join(tags)})

        self.assertRedirects(response, reverse('wagtailsnippets:list',
                                               args=('tests', 'advert')))

        snippet = Advert.objects.get(text='test_advert')

        expected_tags = list(Tag.objects.order_by('name').filter(name__in=tags))
        self.assertEqual(len(expected_tags), 2)
        self.assertEqual(
            list(snippet.tags.order_by('name')),
            expected_tags)

</source>
<source file="systems/wagtail-2.16.1/wagtail/snippets/tests.py" startline="607" endline="623" pcid="2947">
    def test_edit_with_tags(self):
        tags = ['hello', 'world']
        response = self.post(post_data={'text': 'edited_test_advert',
                                        'url': 'http://www.example.com/edited',
                                        'tags': ', '.join(tags)})

        self.assertRedirects(response, reverse('wagtailsnippets:list',
                                               args=('tests', 'advert')))

        snippet = Advert.objects.get(text='edited_test_advert')

        expected_tags = list(Tag.objects.order_by('name').filter(name__in=tags))
        self.assertEqual(len(expected_tags), 2)
        self.assertEqual(
            list(snippet.tags.order_by('name')),
            expected_tags)

</source>
</class>

<class classid="135" nclones="2" nlines="14" similarity="85">
<source file="systems/wagtail-2.16.1/wagtail/snippets/tests.py" startline="377" endline="395" pcid="2920">
    def test_before_create_snippet_hook_post(self):
        def hook_func(request, model):
            self.assertIsInstance(request, HttpRequest)
            self.assertEqual(model, Advert)
            return HttpResponse("Overridden!")

        with self.register_hook('before_create_snippet', hook_func):
            post_data = {
                'text': 'Hook test',
                'url': 'http://www.example.com/'
            }
            response = self.post(post_data=post_data)

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")

        # Request intercepted before advert was created
        self.assertFalse(Advert.objects.exists())

</source>
<source file="systems/wagtail-2.16.1/wagtail/snippets/tests.py" startline="396" endline="415" pcid="2922">
    def test_after_create_snippet_hook(self):
        def hook_func(request, instance):
            self.assertIsInstance(request, HttpRequest)
            self.assertEqual(instance.text, 'Hook test')
            self.assertEqual(instance.url, 'http://www.example.com/')
            return HttpResponse("Overridden!")

        with self.register_hook('after_create_snippet', hook_func):
            post_data = {
                'text': 'Hook test',
                'url': 'http://www.example.com/'
            }
            response = self.post(post_data=post_data)

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")

        # Request intercepted after advert was created
        self.assertTrue(Advert.objects.exists())

</source>
</class>

<class classid="136" nclones="2" nlines="15" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/snippets/tests.py" startline="416" endline="437" pcid="2924">
    def test_register_snippet_action_menu_item(self):
        class TestSnippetActionMenuItem(ActionMenuItem):
            label = "Test"
            name = "test"
            icon_name = "undo"
            classname = 'action-secondary'

            def is_shown(self, context):
                return True

        def hook_func(model):
            return TestSnippetActionMenuItem(order=0)

        with self.register_hook('register_snippet_action_menu_item', hook_func):
            get_base_snippet_action_menu_items.cache_clear()

            response = self.get()

        get_base_snippet_action_menu_items.cache_clear()

        self.assertContains(response, '<button type="submit" name="test" value="Test" class="button action-secondary"><svg class="icon icon-undo icon" aria-hidden="true" focusable="false"><use href="#icon-undo"></use></svg>Test</button>', html=True)

</source>
<source file="systems/wagtail-2.16.1/wagtail/snippets/tests.py" startline="674" endline="695" pcid="2954">
    def test_register_snippet_action_menu_item(self):
        class TestSnippetActionMenuItem(ActionMenuItem):
            label = "Test"
            name = "test"
            icon_name = "undo"
            classname = 'action-secondary'

            def is_shown(self, context):
                return True

        def hook_func(model):
            return TestSnippetActionMenuItem(order=0)

        with self.register_hook('register_snippet_action_menu_item', hook_func):
            get_base_snippet_action_menu_items.cache_clear()

            response = self.get()

        get_base_snippet_action_menu_items.cache_clear()

        self.assertContains(response, '<button type="submit" name="test" value="Test" class="button action-secondary"><svg class="icon icon-undo icon" aria-hidden="true" focusable="false"><use href="#icon-undo"></use></svg>Test</button>', html=True)

</source>
</class>

<class classid="137" nclones="2" nlines="11" similarity="72">
<source file="systems/wagtail-2.16.1/wagtail/snippets/tests.py" startline="577" endline="590" pcid="2944">
    def test_edit_with_limited_permissions(self):
        self.user.is_superuser = False
        self.user.user_permissions.add(
            Permission.objects.get(content_type__app_label='wagtailadmin', codename='access_admin')
        )
        self.user.save()

        response = self.post(post_data={'text': 'test text',
                                        'url': 'http://www.example.com/'})
        self.assertEqual(response.status_code, 302)

        url_finder = AdminURLFinder(self.user)
        self.assertEqual(url_finder.get_edit_url(self.test_snippet), None)

</source>
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_admin_views.py" startline="592" endline="606" pcid="5164">
    def test_edit_with_limited_permissions(self):
        self.user.is_superuser = False
        self.user.user_permissions.add(
            Permission.objects.get(content_type__app_label='wagtailadmin', codename='access_admin')
        )
        self.user.save()

        response = self.post({
            'title': "Edited",
        })
        self.assertEqual(response.status_code, 302)

        url_finder = AdminURLFinder(self.user)
        self.assertEqual(url_finder.get_edit_url(self.image), None)

</source>
</class>

<class classid="138" nclones="3" nlines="14" similarity="80">
<source file="systems/wagtail-2.16.1/wagtail/snippets/tests.py" startline="853" endline="869" pcid="2974">
    def test_before_delete_snippet_hook_get(self):
        advert = Advert.objects.create(
            url='http://www.example.com/',
            text='Test hook',
        )

        def hook_func(request, instances):
            self.assertIsInstance(request, HttpRequest)
            self.assertQuerysetEqual(instances, ["<Advert: Test hook>"])
            return HttpResponse("Overridden!")

        with self.register_hook('before_delete_snippet', hook_func):
            response = self.client.get(reverse('wagtailsnippets:delete', args=['tests', 'advert', quote(advert.pk)]))

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")

</source>
<source file="systems/wagtail-2.16.1/wagtail/snippets/tests.py" startline="892" endline="914" pcid="2978">
    def test_after_delete_snippet_hook(self):
        advert = Advert.objects.create(
            url='http://www.example.com/',
            text='Test hook',
        )

        def hook_func(request, instances):
            self.assertIsInstance(request, HttpRequest)
            self.assertQuerysetEqual(instances, ["<Advert: Test hook>"])
            return HttpResponse("Overridden!")

        with self.register_hook('after_delete_snippet', hook_func):
            response = self.client.post(
                reverse('wagtailsnippets:delete', args=('tests', 'advert', quote(advert.pk), ))
            )

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")

        # Request intercepted after advert was deleted
        self.assertFalse(Advert.objects.filter(pk=advert.pk).exists())


</source>
<source file="systems/wagtail-2.16.1/wagtail/snippets/tests.py" startline="870" endline="891" pcid="2976">
    def test_before_delete_snippet_hook_post(self):
        advert = Advert.objects.create(
            url='http://www.example.com/',
            text='Test hook',
        )

        def hook_func(request, instances):
            self.assertIsInstance(request, HttpRequest)
            self.assertQuerysetEqual(instances, ["<Advert: Test hook>"])
            return HttpResponse("Overridden!")

        with self.register_hook('before_delete_snippet', hook_func):
            response = self.client.post(
                reverse('wagtailsnippets:delete', args=('tests', 'advert', quote(advert.pk), ))
            )

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, b"Overridden!")

        # Request intercepted before advert was deleted
        self.assertTrue(Advert.objects.filter(pk=advert.pk).exists())

</source>
</class>

<class classid="139" nclones="2" nlines="17" similarity="83">
<source file="systems/wagtail-2.16.1/wagtail/snippets/tests.py" startline="976" endline="995" pcid="2986">
    def setUp(self):
        self.request = RequestFactory().get('/')
        user = AnonymousUser()  # technically, Anonymous users cannot access the admin
        self.request.user = user

        model = SnippetChooserModel
        self.advert_text = 'Test advert text'
        test_snippet = model.objects.create(
            advert=Advert.objects.create(text=self.advert_text))

        self.edit_handler = get_snippet_edit_handler(model)
        self.form_class = self.edit_handler.get_form_class()
        form = self.form_class(instance=test_snippet)
        edit_handler = self.edit_handler.bind_to(
            instance=test_snippet, form=form, request=self.request)

        self.snippet_chooser_panel = [
            panel for panel in edit_handler.children
            if getattr(panel, 'field_name', None) == 'advert'][0]

</source>
<source file="systems/wagtail-2.16.1/wagtail/snippets/tests.py" startline="1661" endline="1684" pcid="3067">
    def setUp(self):
        self.request = RequestFactory().get('/')
        user = AnonymousUser()  # technically, Anonymous users cannot access the admin
        self.request.user = user

        model = SnippetChooserModelWithCustomPrimaryKey
        self.advert_text = 'Test advert text'
        test_snippet = model.objects.create(
            advertwithcustomprimarykey=AdvertWithCustomPrimaryKey.objects.create(
                advert_id="advert/02",
                text=self.advert_text
            )
        )

        self.edit_handler = get_snippet_edit_handler(model)
        self.form_class = self.edit_handler.get_form_class()
        form = self.form_class(instance=test_snippet)
        edit_handler = self.edit_handler.bind_to(
            instance=test_snippet, form=form, request=self.request)

        self.snippet_chooser_panel = [
            panel for panel in edit_handler.children
            if getattr(panel, 'field_name', None) == 'advertwithcustomprimarykey'][0]

</source>
</class>

<class classid="140" nclones="2" nlines="12" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/snippets/tests.py" startline="1005" endline="1019" pcid="2989">
    def test_render_as_empty_field(self):
        test_snippet = SnippetChooserModel()
        form = self.form_class(instance=test_snippet)
        edit_handler = self.edit_handler.bind_to(
            instance=test_snippet, form=form, request=self.request)

        snippet_chooser_panel = [
            panel for panel in edit_handler.children
            if getattr(panel, 'field_name', None) == 'advert'
        ][0]

        field_html = snippet_chooser_panel.render_as_field()
        self.assertIn("Choose advert", field_html)
        self.assertIn("Choose another advert", field_html)

</source>
<source file="systems/wagtail-2.16.1/wagtail/snippets/tests.py" startline="1694" endline="1708" pcid="3070">
    def test_render_as_empty_field(self):
        test_snippet = SnippetChooserModelWithCustomPrimaryKey()
        form = self.form_class(instance=test_snippet)
        edit_handler = self.edit_handler.bind_to(
            instance=test_snippet, form=form, request=self.request)

        snippet_chooser_panel = [
            panel for panel in edit_handler.children
            if getattr(panel, 'field_name', None) == 'advertwithcustomprimarykey'
        ][0]

        field_html = snippet_chooser_panel.render_as_field()
        self.assertIn("Choose advert with custom primary key", field_html)
        self.assertIn("Choose another advert with custom primary key", field_html)

</source>
</class>

<class classid="141" nclones="2" nlines="10" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/snippets/tests.py" startline="1235" endline="1248" pcid="3018">
    def setUp(self):
        self.test_snippet = Advert.objects.get(pk=1)

        # Create a user with add_advert permission but not change_advert
        user = self.create_user(
            username='addonly',
            email='addonly@example.com',
            password='password'
        )
        add_permission = Permission.objects.get(content_type__app_label='tests', codename='add_advert')
        admin_permission = Permission.objects.get(content_type__app_label='wagtailadmin', codename='access_admin')
        user.user_permissions.add(add_permission, admin_permission)
        self.login(username='addonly', password='password')

</source>
<source file="systems/wagtail-2.16.1/wagtail/snippets/tests.py" startline="1286" endline="1299" pcid="3024">
    def setUp(self):
        self.test_snippet = Advert.objects.get(pk=1)

        # Create a user with change_advert permission but not add_advert
        user = self.create_user(
            username='changeonly',
            email='changeonly@example.com',
            password='password'
        )
        change_permission = Permission.objects.get(content_type__app_label='tests', codename='change_advert')
        admin_permission = Permission.objects.get(content_type__app_label='wagtailadmin', codename='access_admin')
        user.user_permissions.add(change_permission, admin_permission)
        self.login(username='changeonly', password='password')

</source>
</class>

<class classid="142" nclones="2" nlines="62" similarity="75">
<source file="systems/wagtail-2.16.1/wagtail/snippets/views/snippets.py" startline="187" endline="277" pcid="3092">
def create(request, app_label, model_name):
    model = get_snippet_model_from_url_params(app_label, model_name)

    permission = get_permission_name('add', model)
    if not request.user.has_perm(permission):
        raise PermissionDenied

    for fn in hooks.get_hooks('before_create_snippet'):
        result = fn(request, model)
        if hasattr(result, 'status_code'):
            return result

    instance = model()

    # Set locale of the new instance
    if issubclass(model, TranslatableMixin):
        selected_locale = request.GET.get('locale')
        if selected_locale:
            instance.locale = get_object_or_404(Locale, language_code=selected_locale)
        else:
            instance.locale = Locale.get_default()

    # Make edit handler
    edit_handler = get_snippet_edit_handler(model)
    edit_handler = edit_handler.bind_to(request=request)
    form_class = edit_handler.get_form_class()

    if request.method == 'POST':
        form = form_class(request.POST, request.FILES, instance=instance)

        if form.is_valid():
            with transaction.atomic():
                form.save()
                log(instance=instance, action='wagtail.create')

            messages.success(
                request,
                _("%(snippet_type)s '%(instance)s' created.") % {
                    'snippet_type': capfirst(model._meta.verbose_name),
                    'instance': instance
                },
                buttons=[
                    messages.button(reverse(
                        'wagtailsnippets:edit', args=(app_label, model_name, quote(instance.pk))
                    ), _('Edit'))
                ]
            )

            for fn in hooks.get_hooks('after_create_snippet'):
                result = fn(request, instance)
                if hasattr(result, 'status_code'):
                    return result

            urlquery = ''
            if isinstance(instance, TranslatableMixin) and instance.locale is not Locale.get_default():
                urlquery = '?locale=' + instance.locale.language_code

            return redirect(reverse('wagtailsnippets:list', args=[app_label, model_name]) + urlquery)
        else:
            messages.validation_error(
                request, _("The snippet could not be created due to errors."), form
            )
    else:
        form = form_class(instance=instance)

    edit_handler = edit_handler.bind_to(instance=instance, form=form)

    context = {
        'model_opts': model._meta,
        'edit_handler': edit_handler,
        'form': form,
        'action_menu': SnippetActionMenu(request, view='create', model=model),
        'locale': None,
        'translations': [],
    }

    if getattr(settings, 'WAGTAIL_I18N_ENABLED', False) and issubclass(model, TranslatableMixin):
        context.update({
            'locale': instance.locale,
            'translations': [
                {
                    'locale': locale,
                    'url': reverse('wagtailsnippets:add', args=[app_label, model_name]) + '?locale=' + locale.language_code
                }
                for locale in Locale.objects.all().exclude(id=instance.locale.id)
            ],
        })

    return TemplateResponse(request, 'wagtailsnippets/snippets/create.html', context)


</source>
<source file="systems/wagtail-2.16.1/wagtail/snippets/views/snippets.py" startline="278" endline="358" pcid="3093">
def edit(request, app_label, model_name, pk):
    model = get_snippet_model_from_url_params(app_label, model_name)

    permission = get_permission_name('change', model)
    if not request.user.has_perm(permission):
        raise PermissionDenied

    instance = get_object_or_404(model, pk=unquote(pk))

    for fn in hooks.get_hooks('before_edit_snippet'):
        result = fn(request, instance)
        if hasattr(result, 'status_code'):
            return result

    edit_handler = get_snippet_edit_handler(model)
    edit_handler = edit_handler.bind_to(instance=instance, request=request)
    form_class = edit_handler.get_form_class()

    if request.method == 'POST':
        form = form_class(request.POST, request.FILES, instance=instance)

        if form.is_valid():
            with transaction.atomic():
                form.save()
                log(instance=instance, action='wagtail.edit')

            messages.success(
                request,
                _("%(snippet_type)s '%(instance)s' updated.") % {
                    'snippet_type': capfirst(model._meta.verbose_name),
                    'instance': instance
                },
                buttons=[
                    messages.button(reverse(
                        'wagtailsnippets:edit', args=(app_label, model_name, quote(instance.pk))
                    ), _('Edit'))
                ]
            )

            for fn in hooks.get_hooks('after_edit_snippet'):
                result = fn(request, instance)
                if hasattr(result, 'status_code'):
                    return result

            return redirect('wagtailsnippets:list', app_label, model_name)
        else:
            messages.validation_error(
                request, _("The snippet could not be saved due to errors."), form
            )
    else:
        form = form_class(instance=instance)

    edit_handler = edit_handler.bind_to(form=form)
    latest_log_entry = log_registry.get_logs_for_instance(instance).first()

    context = {
        'model_opts': model._meta,
        'instance': instance,
        'edit_handler': edit_handler,
        'form': form,
        'action_menu': SnippetActionMenu(request, view='edit', instance=instance),
        'locale': None,
        'translations': [],
        'latest_log_entry': latest_log_entry,
    }

    if getattr(settings, 'WAGTAIL_I18N_ENABLED', False) and issubclass(model, TranslatableMixin):
        context.update({
            'locale': instance.locale,
            'translations': [
                {
                    'locale': translation.locale,
                    'url': reverse('wagtailsnippets:edit', args=[app_label, model_name, quote(translation.pk)])
                }
                for translation in instance.get_translations().select_related('locale')
            ],
        })

    return TemplateResponse(request, 'wagtailsnippets/snippets/edit.html', context)


</source>
</class>

<class classid="143" nclones="3" nlines="10" similarity="90">
<source file="systems/wagtail-2.16.1/wagtail/snippets/blocks.py" startline="21" endline="31" pcid="3128">
    def get_form_state(self, value):
        value_data = self.widget.get_value_data(value)
        if value_data is None:
            return None
        else:
            return {
                'id': value_data['id'],
                'edit_link': value_data['edit_url'],
                'string': value_data['string'],
            }

</source>
<source file="systems/wagtail-2.16.1/wagtail/documents/blocks.py" startline="18" endline="28" pcid="4880">
    def get_form_state(self, value):
        value_data = self.widget.get_value_data(value)
        if value_data is None:
            return None
        else:
            return {
                'id': value_data['id'],
                'edit_link': value_data['edit_url'],
                'title': value_data['title'],
            }

</source>
<source file="systems/wagtail-2.16.1/wagtail/images/blocks.py" startline="21" endline="32" pcid="5463">
    def get_form_state(self, value):
        value_data = self.widget.get_value_data(value)
        if value_data is None:
            return None
        else:
            return {
                'id': value_data['id'],
                'edit_link': value_data['edit_url'],
                'title': value_data['title'],
                'preview': value_data['preview'],
            }

</source>
</class>

<class classid="144" nclones="2" nlines="10" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/api/v2/signal_handlers.py" startline="30" endline="43" pcid="3357">
def register_signal_handlers():
    Image = get_image_model()
    Document = get_document_model()

    for model in get_page_models():
        page_published.connect(purge_page_from_cache, sender=model)
        page_unpublished.connect(purge_page_from_cache, sender=model)

    post_save.connect(purge_image_from_cache, sender=Image)
    post_delete.connect(purge_image_from_cache, sender=Image)
    post_save.connect(purge_document_from_cache, sender=Document)
    post_delete.connect(purge_document_from_cache, sender=Document)


</source>
<source file="systems/wagtail-2.16.1/wagtail/api/v2/signal_handlers.py" startline="44" endline="55" pcid="3358">
def unregister_signal_handlers():
    Image = get_image_model()
    Document = get_document_model()

    for model in get_page_models():
        page_published.disconnect(purge_page_from_cache, sender=model)
        page_unpublished.disconnect(purge_page_from_cache, sender=model)

    post_save.disconnect(purge_image_from_cache, sender=Image)
    post_delete.disconnect(purge_image_from_cache, sender=Image)
    post_save.disconnect(purge_document_from_cache, sender=Document)
    post_delete.disconnect(purge_document_from_cache, sender=Document)
</source>
</class>

<class classid="145" nclones="4" nlines="17" similarity="76">
<source file="systems/wagtail-2.16.1/wagtail/api/v2/filters.py" startline="142" endline="167" pcid="3432">
    def filter_queryset(self, request, queryset, view):
        if 'child_of' in request.GET:
            try:
                parent_page_id = int(request.GET['child_of'])
                if parent_page_id < 0:
                    raise ValueError()

                parent_page = view.get_base_queryset().get(id=parent_page_id)
            except ValueError:
                if request.GET['child_of'] == 'root':
                    parent_page = view.get_root_page()
                else:
                    raise BadRequestError("child_of must be a positive integer")
            except Page.DoesNotExist:
                raise BadRequestError("parent page doesn't exist")

            queryset = queryset.child_of(parent_page)

            # Save the parent page on the queryset. This is required for the page
            # explorer, which needs to pass the parent page into
            # `construct_explorer_page_queryset` hook functions
            queryset._filtered_by_child_of = parent_page

        return queryset


</source>
<source file="systems/wagtail-2.16.1/wagtail/api/v2/filters.py" startline="196" endline="218" pcid="3434">
    def filter_queryset(self, request, queryset, view):
        if 'descendant_of' in request.GET:
            if hasattr(queryset, '_filtered_by_child_of'):
                raise BadRequestError("filtering by descendant_of with child_of is not supported")
            try:
                parent_page_id = int(request.GET['descendant_of'])
                if parent_page_id < 0:
                    raise ValueError()

                parent_page = view.get_base_queryset().get(id=parent_page_id)
            except ValueError:
                if request.GET['descendant_of'] == 'root':
                    parent_page = view.get_root_page()
                else:
                    raise BadRequestError("descendant_of must be a positive integer")
            except Page.DoesNotExist:
                raise BadRequestError("ancestor page doesn't exist")

            queryset = queryset.descendant_of(parent_page)

        return queryset


</source>
<source file="systems/wagtail-2.16.1/wagtail/api/v2/filters.py" startline="224" endline="249" pcid="3435">
    def filter_queryset(self, request, queryset, view):
        if 'translation_of' in request.GET:
            try:
                page_id = int(request.GET['translation_of'])
                if page_id < 0:
                    raise ValueError()

                page = view.get_base_queryset().get(id=page_id)
            except ValueError:
                if request.GET['translation_of'] == 'root':
                    page = view.get_root_page()
                else:
                    raise BadRequestError("translation_of must be a positive integer")
            except Page.DoesNotExist:
                raise BadRequestError("translation_of page doesn't exist")

            _filtered_by_child_of = getattr(queryset, '_filtered_by_child_of', None)

            queryset = queryset.translation_of(page)

            if _filtered_by_child_of:
                queryset._filtered_by_child_of = _filtered_by_child_of

        return queryset


</source>
<source file="systems/wagtail-2.16.1/wagtail/api/v2/filters.py" startline="173" endline="190" pcid="3433">
    def filter_queryset(self, request, queryset, view):
        if 'ancestor_of' in request.GET:
            try:
                descendant_page_id = int(request.GET['ancestor_of'])
                if descendant_page_id < 0:
                    raise ValueError()

                descendant_page = view.get_base_queryset().get(id=descendant_page_id)
            except ValueError:
                raise BadRequestError("ancestor_of must be a positive integer")
            except Page.DoesNotExist:
                raise BadRequestError("descendant page doesn't exist")

            queryset = queryset.ancestor_of(descendant_page)

        return queryset


</source>
</class>

<class classid="146" nclones="3" nlines="22" similarity="76">
<source file="systems/wagtail-2.16.1/wagtail/embeds/wagtail_hooks.py" startline="35" endline="69" pcid="3443">
def register_embed_feature(features):
    # define a handler for converting <embed embedtype="media"> tags into frontend HTML
    features.register_embed_type(MediaEmbedHandler)

    # define a hallo.js plugin to use when the 'embed' feature is active
    features.register_editor_plugin(
        'hallo', 'embed',
        HalloPlugin(
            name='hallowagtailembeds',
            js=[
                'wagtailembeds/js/embed-chooser-modal.js',
                'wagtailembeds/js/hallo-plugins/hallo-wagtailembeds.js',
            ],
        )
    )

    # define how to convert between editorhtml's representation of embeds and
    # the database representation
    features.register_converter_rule('editorhtml', 'embed', EditorHTMLEmbedConversionRule)

    # define a draftail plugin to use when the 'embed' feature is active
    features.register_editor_plugin(
        'draftail', 'embed', draftail_features.EntityFeature({
            'type': 'EMBED',
            'icon': 'media',
            'description': _('Embed'),
        }, js=['wagtailembeds/js/embed-chooser-modal.js'])
    )

    # define how to convert between contentstate's representation of embeds and
    # the database representation-
    features.register_converter_rule('contentstate', 'embed', ContentstateMediaConversionRule)

    # add 'embed' to the set of on-by-default rich text features
    features.default_features.append('embed')
</source>
<source file="systems/wagtail-2.16.1/wagtail/images/wagtail_hooks.py" startline="67" endline="112" pcid="4889">
def register_image_feature(features):
    # define a handler for converting <embed embedtype="image"> tags into frontend HTML
    features.register_embed_type(ImageEmbedHandler)

    # define a hallo.js plugin to use when the 'image' feature is active
    features.register_editor_plugin(
        'hallo', 'image',
        HalloPlugin(
            name='hallowagtailimage',
            js=[
                'wagtailimages/js/image-chooser-modal.js',
                'wagtailimages/js/hallo-plugins/hallo-wagtailimage.js',
            ],
        )
    )

    # define how to convert between editorhtml's representation of images and
    # the database representation
    features.register_converter_rule('editorhtml', 'image', EditorHTMLImageConversionRule)

    # define a draftail plugin to use when the 'image' feature is active
    features.register_editor_plugin(
        'draftail', 'image', draftail_features.EntityFeature({
            'type': 'IMAGE',
            'icon': 'image',
            'description': gettext('Image'),
            # We do not want users to be able to copy-paste hotlinked images into rich text.
            # Keep only the attributes Wagtail needs.
            'attributes': ['id', 'src', 'alt', 'format'],
            # Keep only images which are from Wagtail.
            'whitelist': {
                'id': True,
            }
        }, js=[
            'wagtailimages/js/image-chooser-modal.js',
        ])
    )

    # define how to convert between contentstate's representation of images and
    # the database representation
    features.register_converter_rule('contentstate', 'image', ContentstateImageConversionRule)

    # add 'image' to the set of on-by-default rich text features
    features.default_features.append('image')


</source>
<source file="systems/wagtail-2.16.1/wagtail/documents/wagtail_hooks.py" startline="74" endline="104" pcid="4653">
def register_document_feature(features):
    features.register_link_type(DocumentLinkHandler)

    features.register_editor_plugin(
        'hallo', 'document-link',
        HalloPlugin(
            name='hallowagtaildoclink',
            js=[
                'wagtaildocs/js/document-chooser-modal.js',
                'wagtaildocs/js/hallo-plugins/hallo-wagtaildoclink.js',
            ],
        )
    )
    features.register_editor_plugin(
        'draftail', 'document-link', draftail_features.EntityFeature({
            'type': 'DOCUMENT',
            'icon': 'doc-full',
            'description': gettext('Document'),
        }, js=['wagtaildocs/js/document-chooser-modal.js'])
    )

    features.register_converter_rule(
        'editorhtml', 'document-link', EditorHTMLDocumentLinkConversionRule
    )
    features.register_converter_rule(
        'contentstate', 'document-link', ContentstateDocumentLinkConversionRule
    )

    features.default_features.append('document-link')


</source>
</class>

<class classid="147" nclones="4" nlines="20" similarity="72">
<source file="systems/wagtail-2.16.1/wagtail/embeds/tests/test_rich_text.py" startline="24" endline="53" pcid="3453">
    def test_expand_db_attributes_for_editor(self, get_embed):
        get_embed.return_value = Embed(
            url='http://www.youtube.com/watch/',
            max_width=None,
            type='video',
            html='test html',
            title='test title',
            author_name='test author name',
            provider_name='test provider name',
            thumbnail_url='http://test/thumbnail.url',
            width=1000,
            height=1000,
        )

        result = EditorHtmlMediaEmbedHandler.expand_db_attributes({
            'url': 'http://www.youtube.com/watch/',
        })
        self.assertIn(
            (
                '<div class="embed-placeholder" contenteditable="false" data-embedtype="media"'
                ' data-url="http://www.youtube.com/watch/">'
            ),
            result
        )
        self.assertIn('<h3>test title</h3>', result)
        self.assertIn('<p>URL: http://www.youtube.com/watch/</p>', result)
        self.assertIn('<p>Provider: test provider name</p>', result)
        self.assertIn('<p>Author: test author name</p>', result)
        self.assertIn('<img src="http://test/thumbnail.url" alt="test title">', result)

</source>
<source file="systems/wagtail-2.16.1/wagtail/embeds/tests/test_rich_text.py" startline="66" endline="85" pcid="3455">
    def test_expand_db_attributes_for_frontend_responsive(self, get_embed):
        get_embed.return_value = Embed(
            url='http://www.youtube.com/watch/',
            max_width=None,
            type='video',
            html='test html',
            title='test title',
            author_name='test author name',
            provider_name='test provider name',
            thumbnail_url='http://test/thumbnail.url',
            width=1000,
            height=1000,
        )

        result = FrontendMediaEmbedHandler.expand_db_attributes({
            'url': 'http://www.youtube.com/watch/',
        })
        self.assertIn('test html', result)
        self.assertIn('class="responsive-object"', result)

</source>
<source file="systems/wagtail-2.16.1/wagtail/embeds/tests/test_rich_text.py" startline="87" endline="106" pcid="3456">
    def test_expand_db_attributes_for_frontend_nonresponsive(self, get_embed):
        get_embed.return_value = Embed(
            url='http://www.youtube.com/watch/',
            max_width=None,
            type='video',
            html='test html',
            title='test title',
            author_name='test author name',
            provider_name='test provider name',
            thumbnail_url='http://test/thumbnail.url',
            width=1000,
            height=1000,
        )

        result = FrontendMediaEmbedHandler.expand_db_attributes({
            'url': 'http://www.youtube.com/watch/',
        })
        self.assertIn('test html', result)
        self.assertNotIn('class="responsive-object"', result)

</source>
<source file="systems/wagtail-2.16.1/wagtail/embeds/tests/test_rich_text.py" startline="116" endline="132" pcid="3458">
    def test_expand_html_escaping_end_to_end(self, get_embed):
        get_embed.return_value = Embed(
            url='http://www.youtube.com/watch/',
            max_width=None,
            type='video',
            html='test html',
            title='test title',
            author_name='test author name',
            provider_name='test provider name',
            thumbnail_url='http://test/thumbnail.url',
            width=1000,
            height=1000,
        )

        result = expand_db_html('<p>1 2 <embed embedtype="media" url="https://www.youtube.com/watch?v=O7D-1RG-VRk&amp;t=25" /> 3 4</p>')
        self.assertIn('test html', result)
        get_embed.assert_called_with('https://www.youtube.com/watch?v=O7D-1RG-VRk&t=25', None, None)
</source>
</class>

<class classid="148" nclones="3" nlines="24" similarity="76">
<source file="systems/wagtail-2.16.1/wagtail/embeds/tests/test_embeds.py" startline="437" endline="461" pcid="3495">
    def test_oembed_return_values(self, loads, urlopen):
        urlopen.return_value = self.dummy_response
        loads.return_value = {
            'type': 'something',
            'url': 'http://www.example.com',
            'title': 'test_title',
            'author_name': 'test_author',
            'provider_name': 'test_provider_name',
            'thumbnail_url': 'test_thumbail_url',
            'width': 'test_width',
            'height': 'test_height',
            'html': 'test_html'
        }
        result = OEmbedFinder().find_embed("http://www.youtube.com/watch/")
        self.assertEqual(result, {
            'type': 'something',
            'title': 'test_title',
            'author_name': 'test_author',
            'provider_name': 'test_provider_name',
            'thumbnail_url': 'test_thumbail_url',
            'width': 'test_width',
            'height': 'test_height',
            'html': 'test_html'
        })

</source>
<source file="systems/wagtail-2.16.1/wagtail/embeds/tests/test_embeds.py" startline="496" endline="523" pcid="3497">
    def test_oembed_cache_until_as_string(self, loads, urlopen, now):
        urlopen.return_value = self.dummy_response
        loads.return_value = {
            'type': 'something',
            'url': 'http://www.example.com',
            'title': 'test_title',
            'author_name': 'test_author',
            'provider_name': 'test_provider_name',
            'thumbnail_url': 'test_thumbail_url',
            'width': 'test_width',
            'height': 'test_height',
            'html': 'test_html',
            'cache_age': '3600'
        }
        now.return_value = make_aware(datetime.datetime(2001, 2, 3))
        result = OEmbedFinder().find_embed("http://www.youtube.com/watch/")
        self.assertEqual(result, {
            'type': 'something',
            'title': 'test_title',
            'author_name': 'test_author',
            'provider_name': 'test_provider_name',
            'thumbnail_url': 'test_thumbail_url',
            'width': 'test_width',
            'height': 'test_height',
            'html': 'test_html',
            'cache_until': make_aware(datetime.datetime(2001, 2, 3, hour=1))
        })

</source>
<source file="systems/wagtail-2.16.1/wagtail/embeds/tests/test_embeds.py" startline="465" endline="492" pcid="3496">
    def test_oembed_cache_until(self, loads, urlopen, now):
        urlopen.return_value = self.dummy_response
        loads.return_value = {
            'type': 'something',
            'url': 'http://www.example.com',
            'title': 'test_title',
            'author_name': 'test_author',
            'provider_name': 'test_provider_name',
            'thumbnail_url': 'test_thumbail_url',
            'width': 'test_width',
            'height': 'test_height',
            'html': 'test_html',
            'cache_age': 3600
        }
        now.return_value = make_aware(datetime.datetime(2001, 2, 3))
        result = OEmbedFinder().find_embed("http://www.youtube.com/watch/")
        self.assertEqual(result, {
            'type': 'something',
            'title': 'test_title',
            'author_name': 'test_author',
            'provider_name': 'test_provider_name',
            'thumbnail_url': 'test_thumbail_url',
            'width': 'test_width',
            'height': 'test_height',
            'html': 'test_html',
            'cache_until': make_aware(datetime.datetime(2001, 2, 3, hour=1))
        })

</source>
</class>

<class classid="149" nclones="2" nlines="18" similarity="88">
<source file="systems/wagtail-2.16.1/wagtail/embeds/tests/test_embeds.py" startline="567" endline="589" pcid="3504">
    def test_instagram_oembed_return_values(self, urlopen):
        urlopen.return_value = self.dummy_response
        result = InstagramOEmbedFinder(app_id='123', app_secret='abc').find_embed("https://instagr.am/p/CHeRxmnDSYe/")
        self.assertEqual(result, {
            'type': 'something',
            'title': 'test_title',
            'author_name': 'test_author',
            'provider_name': 'Instagram',
            'thumbnail_url': 'test_thumbail_url',
            'width': 'test_width',
            'height': 'test_height',
            'html': '<blockquote class="instagram-media">Content</blockquote>'
        })
        # check that a request was made with the expected URL / authentication
        request = urlopen.call_args[0][0]
        # check that a request was made with the expected URL / authentication
        request = urlopen.call_args[0][0]
        self.assertEqual(
            request.get_full_url(),
            "https://graph.facebook.com/v11.0/instagram_oembed?url=https%3A%2F%2Finstagr.am%2Fp%2FCHeRxmnDSYe%2F&format=json"
        )
        self.assertEqual(request.get_header('Authorization'), "Bearer 123|abc")

</source>
<source file="systems/wagtail-2.16.1/wagtail/embeds/tests/test_embeds.py" startline="633" endline="653" pcid="3511">
    def test_facebook_oembed_return_values(self, urlopen):
        urlopen.return_value = self.dummy_response
        result = FacebookOEmbedFinder(app_id='123', app_secret='abc').find_embed("https://fb.watch/ABC123eew/")
        self.assertEqual(result, {
            'type': 'something',
            'title': 'test_title',
            'author_name': 'test_author',
            'provider_name': 'Facebook',
            'thumbnail_url': None,
            'width': 'test_width',
            'height': 'test_height',
            'html': '<blockquote class="facebook-media">Content</blockquote>'
        })
        # check that a request was made with the expected URL / authentication
        request = urlopen.call_args[0][0]
        self.assertEqual(
            request.get_full_url(),
            "https://graph.facebook.com/v11.0/oembed_video?url=https%3A%2F%2Ffb.watch%2FABC123eew%2F&format=json"
        )
        self.assertEqual(request.get_header('Authorization'), "Bearer 123|abc")

</source>
</class>

<class classid="150" nclones="2" nlines="10" similarity="80">
<source file="systems/wagtail-2.16.1/wagtail/embeds/tests/test_embeds.py" startline="805" endline="818" pcid="3524">
    def test_clean_required(self, get_embed):
        get_embed.return_value = Embed(html='<h1>Hello world!</h1>')

        block = EmbedBlock()

        cleaned_value = block.clean(
            EmbedValue('https://www.youtube.com/watch?v=_U79Wc965vw'))
        self.assertIsInstance(cleaned_value, EmbedValue)
        self.assertEqual(cleaned_value.url,
                         'https://www.youtube.com/watch?v=_U79Wc965vw')

        with self.assertRaisesMessage(ValidationError, ''):
            block.clean(None)

</source>
<source file="systems/wagtail-2.16.1/wagtail/embeds/tests/test_embeds.py" startline="820" endline="833" pcid="3525">
    def test_clean_non_required(self, get_embed):
        get_embed.return_value = Embed(html='<h1>Hello world!</h1>')

        block = EmbedBlock(required=False)

        cleaned_value = block.clean(
            EmbedValue('https://www.youtube.com/watch?v=_U79Wc965vw'))
        self.assertIsInstance(cleaned_value, EmbedValue)
        self.assertEqual(cleaned_value.url,
                         'https://www.youtube.com/watch?v=_U79Wc965vw')

        cleaned_value = block.clean(None)
        self.assertIsNone(cleaned_value)

</source>
</class>

<class classid="151" nclones="2" nlines="34" similarity="81">
<source file="systems/wagtail-2.16.1/wagtail/embeds/finders/instagram.py" startline="40" endline="83" pcid="3536">
    def find_embed(self, url, max_width=None, max_height=None):
        params = {'url': url, 'format': 'json'}
        if max_width:
            params['maxwidth'] = max_width
        if max_height:
            params['maxheight'] = max_height
        if self.omitscript:
            params['omitscript'] = 'true'

        # Configure request
        request = Request(self.INSTAGRAM_ENDPOINT + '?' + urlencode(params))
        request.add_header('Authorization', f'Bearer {self.app_id}|{self.app_secret}')

        # Perform request
        try:
            r = urllib_request.urlopen(request)
        except (HTTPError, URLError) as e:
            if isinstance(e, HTTPError) and e.code == 404:
                raise EmbedNotFoundException
            elif isinstance(e, HTTPError) and e.code in [400, 401, 403]:
                raise AccessDeniedInstagramOEmbedException
            else:
                raise EmbedNotFoundException
        oembed = json.loads(r.read().decode('utf-8'))

        # Convert photos into HTML
        if oembed['type'] == 'photo':
            html = '<img src="%s" alt="">' % (oembed["url"],)
        else:
            html = oembed.get('html')

        # Return embed as a dict
        return {
            'title': oembed['title'] if 'title' in oembed else '',
            'author_name': oembed['author_name'] if 'author_name' in oembed else '',
            'provider_name': oembed['provider_name'] if 'provider_name' in oembed else 'Instagram',
            'type': oembed['type'],
            'thumbnail_url': oembed.get('thumbnail_url'),
            'width': oembed.get('width'),
            'height': oembed.get('height'),
            'html': html,
        }


</source>
<source file="systems/wagtail-2.16.1/wagtail/embeds/finders/facebook.py" startline="75" endline="117" pcid="3540">
    def find_embed(self, url, max_width=None, max_height=None):
        # Find provider
        endpoint = self._get_endpoint(url)
        if endpoint is None:
            raise EmbedNotFoundException

        params = {'url': url, 'format': 'json'}
        if max_width:
            params['maxwidth'] = max_width
        if max_height:
            params['maxheight'] = max_height
        if self.omitscript:
            params['omitscript'] = 'true'

        # Configure request
        request = Request(endpoint + '?' + urlencode(params))
        request.add_header('Authorization', f'Bearer {self.app_id}|{self.app_secret}')

        # Perform request
        try:
            r = urllib_request.urlopen(request)
        except (HTTPError, URLError) as e:
            if isinstance(e, HTTPError) and e.code == 404:
                raise EmbedNotFoundException
            elif isinstance(e, HTTPError) and e.code in [400, 401, 403]:
                raise AccessDeniedFacebookOEmbedException
            else:
                raise EmbedNotFoundException
        oembed = json.loads(r.read().decode('utf-8'))

        # Return embed as a dict
        return {
            'title': oembed['title'] if 'title' in oembed else '',
            'author_name': oembed['author_name'] if 'author_name' in oembed else '',
            'provider_name': oembed['provider_name'] if 'provider_name' in oembed else 'Facebook',
            'type': oembed['type'],
            'thumbnail_url': oembed.get('thumbnail_url'),
            'width': oembed.get('width'),
            'height': oembed.get('height'),
            'html': oembed.get('html'),
        }


</source>
</class>

<class classid="152" nclones="3" nlines="12" similarity="81">
<source file="systems/wagtail-2.16.1/wagtail/core/wagtail_hooks.py" startline="79" endline="93" pcid="3571">
def describe_collection_children(collection):
    descendant_count = collection.get_descendants().count()
    if descendant_count:
        url = reverse('wagtailadmin_collections:index')
        return {
            'count': descendant_count,
            'count_text': ngettext(
                "%(count)s descendant collection",
                "%(count)s descendant collections",
                descendant_count
            ) % {'count': descendant_count},
            'url': url,
        }


</source>
<source file="systems/wagtail-2.16.1/wagtail/images/wagtail_hooks.py" startline="175" endline="189" pcid="4897">
def describe_collection_docs(collection):
    images_count = get_image_model().objects.filter(collection=collection).count()
    if images_count:
        url = reverse('wagtailimages:index') + ('?collection_id=%d' % collection.id)
        return {
            'count': images_count,
            'count_text': ngettext(
                "%(count)s image",
                "%(count)s images",
                images_count
            ) % {'count': images_count},
            'url': url,
        }


</source>
<source file="systems/wagtail-2.16.1/wagtail/documents/wagtail_hooks.py" startline="150" endline="164" pcid="4660">
def describe_collection_docs(collection):
    docs_count = get_document_model().objects.filter(collection=collection).count()
    if docs_count:
        url = reverse('wagtaildocs:index') + ('?collection_id=%d' % collection.id)
        return {
            'count': docs_count,
            'count_text': ngettext(
                "%(count)s document",
                "%(count)s documents",
                docs_count
            ) % {'count': docs_count},
            'url': url,
        }


</source>
</class>

<class classid="153" nclones="2" nlines="14" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/core/wagtail_hooks.py" startline="215" endline="229" pcid="3581">
        def format_message(self, log_entry):
            try:
                if log_entry.data['revision']['has_live_version']:
                    return _('Revision %(revision_id)s from %(created_at)s scheduled for publishing at %(go_live_at)s.') % {
                        'revision_id': log_entry.data['revision']['id'],
                        'created_at': log_entry.data['revision']['created'],
                        'go_live_at': log_entry.data['revision']['go_live_at'],
                    }
                else:
                    return _('Page scheduled for publishing at %(go_live_at)s') % {
                        'go_live_at': log_entry.data['revision']['go_live_at'],
                    }
            except KeyError:
                return _('Page scheduled for publishing')

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/wagtail_hooks.py" startline="234" endline="248" pcid="3582">
        def format_message(self, log_entry):
            try:
                if log_entry.data['revision']['has_live_version']:
                    return _('Revision %(revision_id)s from %(created_at)s unscheduled from publishing at %(go_live_at)s.') % {
                        'revision_id': log_entry.data['revision']['id'],
                        'created_at': log_entry.data['revision']['created'],
                        'go_live_at': log_entry.data['revision']['go_live_at'],
                    }
                else:
                    return _('Page unscheduled for publishing at %(go_live_at)s') % {
                        'go_live_at': log_entry.data['revision']['go_live_at'],
                    }
            except KeyError:
                return _('Page unscheduled from publishing')

</source>
</class>

<class classid="154" nclones="2" nlines="61" similarity="88">
<source file="systems/wagtail-2.16.1/wagtail/core/migrations/0002_initial_data.py" startline="5" endline="79" pcid="3716">
def initial_data(apps, schema_editor):
    ContentType = apps.get_model('contenttypes.ContentType')
    Group = apps.get_model('auth.Group')
    Page = apps.get_model('wagtailcore.Page')
    Site = apps.get_model('wagtailcore.Site')
    GroupPagePermission = apps.get_model('wagtailcore.GroupPagePermission')

    # Create page content type
    page_content_type, created = ContentType.objects.get_or_create(
        model='page',
        app_label='wagtailcore'
    )

    # Create root page
    root = Page.objects.create(
        title="Root",
        slug='root',
        content_type=page_content_type,
        path='0001',
        depth=1,
        numchild=1,
        url_path='/',
    )

    # Create homepage
    homepage = Page.objects.create(
        title="Welcome to your new Wagtail site!",
        slug='home',
        content_type=page_content_type,
        path='00010001',
        depth=2,
        numchild=0,
        url_path='/home/',
    )

    # Create default site
    Site.objects.create(
        hostname='localhost',
        root_page_id=homepage.id,
        is_default_site=True
    )

    # Create auth groups
    moderators_group = Group.objects.create(name='Moderators')
    editors_group = Group.objects.create(name='Editors')

    # Create group permissions
    GroupPagePermission.objects.create(
        group=moderators_group,
        page=root,
        permission_type='add',
    )
    GroupPagePermission.objects.create(
        group=moderators_group,
        page=root,
        permission_type='edit',
    )
    GroupPagePermission.objects.create(
        group=moderators_group,
        page=root,
        permission_type='publish',
    )

    GroupPagePermission.objects.create(
        group=editors_group,
        page=root,
        permission_type='add',
    )
    GroupPagePermission.objects.create(
        group=editors_group,
        page=root,
        permission_type='edit',
    )


</source>
<source file="systems/wagtail-2.16.1/wagtail/core/migrations/0001_squashed_0016_change_page_url_path_to_text_field.py" startline="9" endline="90" pcid="3732">
def initial_data(apps, schema_editor):
    ContentType = apps.get_model('contenttypes.ContentType')
    Group = apps.get_model('auth.Group')
    Page = apps.get_model('wagtailcore.Page')
    Site = apps.get_model('wagtailcore.Site')
    GroupPagePermission = apps.get_model('wagtailcore.GroupPagePermission')

    # Create page content type
    page_content_type, created = ContentType.objects.get_or_create(
        model='page',
        app_label='wagtailcore'
    )

    # Create root page
    root = Page.objects.create(
        title="Root",
        slug='root',
        content_type=page_content_type,
        path='0001',
        depth=1,
        numchild=1,
        url_path='/',
    )

    # Create homepage
    homepage = Page.objects.create(
        title="Welcome to your new Wagtail site!",
        slug='home',
        content_type=page_content_type,
        path='00010001',
        depth=2,
        numchild=0,
        url_path='/home/',
    )

    # Create default site
    Site.objects.get_or_create(
        hostname='localhost',
        root_page_id=homepage.id,
        is_default_site=True
    )

    # Create auth groups
    moderators_group, created = Group.objects.get_or_create(name='Moderators')
    editors_group, created = Group.objects.get_or_create(name='Editors')

    # Create group permissions
    GroupPagePermission.objects.create(
        group=moderators_group,
        page=root,
        permission_type='add',
    )
    GroupPagePermission.objects.create(
        group=moderators_group,
        page=root,
        permission_type='edit',
    )
    GroupPagePermission.objects.create(
        group=moderators_group,
        page=root,
        permission_type='publish',
    )

    GroupPagePermission.objects.create(
        group=editors_group,
        page=root,
        permission_type='add',
    )
    GroupPagePermission.objects.create(
        group=editors_group,
        page=root,
        permission_type='edit',
    )

    # 0005 - add_page_lock_permission_to_moderators
    GroupPagePermission.objects.create(
        group=moderators_group,
        page=root,
        permission_type='lock',
    )


</source>
</class>

<class classid="155" nclones="3" nlines="17" similarity="78">
<source file="systems/wagtail-2.16.1/wagtail/core/actions/revert_to_page_revision.py" startline="21" endline="40" pcid="3735">
    def __init__(
        self,
        page,
        revision,
        user=None,
        log_action="wagtail.revert",
        submitted_for_moderation=False,
        approved_go_live_at=None,
        changed=True,
        clean=True,
    ):
        self.page = page
        self.revision = revision
        self.user = user
        self.log_action = log_action
        self.submitted_for_moderation = submitted_for_moderation
        self.approved_go_live_at = approved_go_live_at
        self.changed = changed
        self.clean = clean

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/actions/copy_for_translation.py" startline="46" endline="63" pcid="3755">
    def __init__(
        self,
        page,
        locale,
        copy_parents=False,
        alias=False,
        exclude_fields=None,
        user=None,
        include_subtree=False,
    ):
        self.page = page
        self.locale = locale
        self.copy_parents = copy_parents
        self.alias = alias
        self.exclude_fields = exclude_fields
        self.user = user
        self.include_subtree = include_subtree

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/actions/unpublish_page.py" startline="21" endline="36" pcid="3738">
    def __init__(
        self,
        page,
        set_expired=False,
        commit=True,
        user=None,
        log_action=True,
        include_descendants=False,
    ):
        self.page = page
        self.set_expired = set_expired
        self.commit = commit
        self.user = user
        self.log_action = log_action
        self.include_descendants = include_descendants

</source>
</class>

<class classid="156" nclones="2" nlines="27" similarity="72">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_privacy.py" startline="20" endline="60" pcid="3762">
    def test_anonymous_user_must_authenticate(self):
        response = self.client.get('/secret-plans/')
        self.assertEqual(response.templates[0].name, 'wagtailcore/password_required.html')

        submit_url = "/_util/authenticate_with_password/%d/%d/" % (self.view_restriction.id, self.secret_plans_page.id)
        self.assertContains(response, '<form action="%s"' % submit_url)
        self.assertContains(
            response,
            '<input id="id_return_url" name="return_url" type="hidden" value="/secret-plans/" />',
            html=True
        )

        # posting the wrong password should redisplay the password page
        response = self.client.post(submit_url, {
            'password': 'wrongpassword',
            'return_url': '/secret-plans/',
        })
        self.assertEqual(response.templates[0].name, 'wagtailcore/password_required.html')
        self.assertContains(response, '<form action="%s"' % submit_url)

        # posting the correct password should redirect back to return_url
        response = self.client.post(submit_url, {
            'password': 'swordfish',
            'return_url': '/secret-plans/',
        })
        self.assertRedirects(response, '/secret-plans/')

        # now requests to /secret-plans/ should pass authentication
        response = self.client.get('/secret-plans/')
        self.assertEqual(response.templates[0].name, 'tests/simple_page.html')

        self.client.logout()

        # posting an invalid return_url will redirect to default login redirect
        with self.settings(LOGIN_REDIRECT_URL='/'):
            response = self.client.post(submit_url, {
                'password': 'swordfish',
                'return_url': 'https://invaliddomain.com',
            })
            self.assertRedirects(response, '/')

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_privacy.py" startline="61" endline="95" pcid="3763">
    def test_view_restrictions_apply_to_subpages(self):
        underpants_page = Page.objects.get(url_path='/home/secret-plans/steal-underpants/')
        response = self.client.get('/secret-plans/steal-underpants/')

        # check that we're overriding the default password_required template for this page type
        self.assertEqual(response.templates[0].name, 'tests/event_page_password_required.html')

        submit_url = "/_util/authenticate_with_password/%d/%d/" % (self.view_restriction.id, underpants_page.id)
        self.assertContains(response, '<title>Steal underpants</title>')
        self.assertContains(response, '<form action="%s"' % submit_url)
        self.assertContains(
            response,
            '<input id="id_return_url" name="return_url" type="hidden" value="/secret-plans/steal-underpants/" />',
            html=True
        )

        # posting the wrong password should redisplay the password page
        response = self.client.post(submit_url, {
            'password': 'wrongpassword',
            'return_url': '/secret-plans/steal-underpants/',
        })
        self.assertEqual(response.templates[0].name, 'tests/event_page_password_required.html')
        self.assertContains(response, '<form action="%s"' % submit_url)

        # posting the correct password should redirect back to return_url
        response = self.client.post(submit_url, {
            'password': 'swordfish',
            'return_url': '/secret-plans/steal-underpants/',
        })
        self.assertRedirects(response, '/secret-plans/steal-underpants/')

        # now requests to /secret-plans/ should pass authentication
        response = self.client.get('/secret-plans/steal-underpants/')
        self.assertEqual(response.templates[0].name, 'tests/event_page.html')

</source>
</class>

<class classid="157" nclones="2" nlines="13" similarity="78">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_privacy.py" startline="96" endline="111" pcid="3764">
    def test_view_restrictions_apply_to_aliases(self):
        secret_plans_page = Page.objects.get(url_path='/home/secret-plans/')
        secret_plans_alias_page = secret_plans_page.create_alias(update_slug='alias-secret-plans')

        response = self.client.get('/alias-secret-plans/')

        self.assertEqual(response.templates[0].name, 'wagtailcore/password_required.html')

        submit_url = "/_util/authenticate_with_password/%d/%d/" % (self.view_restriction.id, secret_plans_alias_page.id)
        self.assertContains(response, '<form action="%s"' % submit_url)
        self.assertContains(
            response,
            '<input id="id_return_url" name="return_url" type="hidden" value="/alias-secret-plans/" />',
            html=True
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_privacy.py" startline="112" endline="132" pcid="3765">
    def test_view_restrictions_apply_to_subpages_of_aliases(self):
        secret_plans_page = Page.objects.get(url_path='/home/secret-plans/')
        secret_plans_alias_page = secret_plans_page.create_alias(update_slug='alias-secret-plans')

        underpants_page = Page.objects.get(url_path='/home/secret-plans/steal-underpants/')
        underpants_alias_page = underpants_page.create_alias(parent=secret_plans_alias_page)

        response = self.client.get('/alias-secret-plans/steal-underpants/')

        # check that we're overriding the default password_required template for this page type
        self.assertEqual(response.templates[0].name, 'tests/event_page_password_required.html')

        submit_url = "/_util/authenticate_with_password/%d/%d/" % (self.view_restriction.id, underpants_alias_page.id)
        self.assertContains(response, '<title>Steal underpants</title>')
        self.assertContains(response, '<form action="%s"' % submit_url)
        self.assertContains(
            response,
            '<input id="id_return_url" name="return_url" type="hidden" value="/alias-secret-plans/steal-underpants/" />',
            html=True
        )

</source>
</class>

<class classid="158" nclones="2" nlines="20" similarity="72">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_rich_text.py" startline="147" endline="175" pcid="3790">
    def test_should_follow_default_behaviour(self):
        # we always have default `page` rules registered.
        rules = {
            'page': lambda attrs: '<a href="/article/{}">'.format(attrs['id'])
        }
        rewriter = LinkRewriter(rules)

        page_type_link = rewriter('<a linktype="page" id="3">')
        self.assertEqual(page_type_link, '<a href="/article/3">')

        # but it should also be able to handle other supported
        # link types (email, external, anchor) even if no rules is provided
        external_type_link = rewriter('<a href="https://wagtail.org/">')
        self.assertEqual(external_type_link, '<a href="https://wagtail.org/">')
        email_type_link = rewriter('<a href="mailto:test@wagtail.org">')
        self.assertEqual(email_type_link, '<a href="mailto:test@wagtail.org">')
        anchor_type_link = rewriter('<a href="#test">')
        self.assertEqual(anchor_type_link, '<a href="#test">')

        # As well as link which don't have any linktypes
        link_without_linktype = rewriter('<a data-link="https://wagtail.org">')
        self.assertEqual(link_without_linktype, '<a data-link="https://wagtail.org">')

        # But should not handle if a custom linktype is mentioned but no
        # associate rules are registered.
        link_with_custom_linktype = rewriter('<a linktype="custom" href="https://wagtail.org">')
        self.assertNotEqual(link_with_custom_linktype, '<a href="https://wagtail.org">')
        self.assertEqual(link_with_custom_linktype, '<a>')

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_rich_text.py" startline="176" endline="209" pcid="3791">
    def test_supported_type_should_follow_given_rules(self):
        # we always have `page` rules by default
        rules = {
            'page': lambda attrs: '<a href="/article/{}">'.format(attrs['id']),
            'external': lambda attrs: '<a rel="nofollow" href="{}">'.format(attrs['href']),
            'email': lambda attrs: '<a data-email="true" href="{}">'.format(attrs['href']),
            'anchor': lambda attrs: '<a data-anchor="true" href="{}">'.format(attrs['href']),
            'custom': lambda attrs: '<a data-phone="true" href="{}">'.format(attrs['href']),
        }
        rewriter = LinkRewriter(rules)

        page_type_link = rewriter('<a linktype="page" id="3">')
        self.assertEqual(page_type_link, '<a href="/article/3">')

        # It should call appropriate rule supported linktypes (external or email)
        # based on the href value
        external_type_link = rewriter('<a href="https://wagtail.org/">')
        self.assertEqual(external_type_link, '<a rel="nofollow" href="https://wagtail.org/">')
        external_type_link_http = rewriter('<a href="http://wagtail.org/">')
        self.assertEqual(external_type_link_http, '<a rel="nofollow" href="http://wagtail.org/">')
        email_type_link = rewriter('<a href="mailto:test@wagtail.org">')
        self.assertEqual(email_type_link, '<a data-email="true" href="mailto:test@wagtail.org">')
        anchor_type_link = rewriter('<a href="#test">')
        self.assertEqual(anchor_type_link, '<a data-anchor="true" href="#test">')

        # But not the unsupported ones.
        link_with_no_linktype = rewriter('<a href="tel:+4917640206387">')
        self.assertEqual(link_with_no_linktype, '<a href="tel:+4917640206387">')

        # Also call the rule if a custom linktype is mentioned.
        link_with_custom_linktype = rewriter('<a linktype="custom" href="tel:+4917640206387">')
        self.assertEqual(link_with_custom_linktype, '<a data-phone="true" href="tel:+4917640206387">')


</source>
</class>

<class classid="159" nclones="2" nlines="10" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_jinja2.py" startline="69" endline="87" pcid="3802">
    def test_block_render_result_is_safe(self):
        """
        Ensure that any results of template rendering in block.render are marked safe
        so that they don't get double-escaped when inserted into a parent template (#2541)
        """
        stream_block = blocks.StreamBlock([
            ('paragraph', blocks.CharBlock(template='tests/jinja2/paragraph.html'))
        ])

        stream_value = stream_block.to_python([
            {'type': 'paragraph', 'value': 'hello world'},
        ])

        result = render_to_string('tests/jinja2/stream.html', {
            'value': stream_value,
        })

        self.assertIn('<p>hello world</p>', result)

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_jinja2.py" startline="88" endline="106" pcid="3803">
    def test_rich_text_is_safe(self):
        """
        Ensure that RichText values are marked safe
        so that they don't get double-escaped when inserted into a parent template (#2542)
        """
        stream_block = blocks.StreamBlock([
            ('paragraph', blocks.RichTextBlock(template='tests/jinja2/rich_text.html'))
        ])
        stream_value = stream_block.to_python([
            {'type': 'paragraph', 'value': '<p>Merry <a linktype="page" id="4">Christmas</a>!</p>'},
        ])

        result = render_to_string('tests/jinja2/stream.html', {
            'value': stream_value,
        })

        self.assertIn('<p>Merry <a href="/events/christmas/">Christmas</a>!</p>', result)


</source>
</class>

<class classid="160" nclones="3" nlines="28" similarity="72">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_telepath.py" startline="109" endline="142" pcid="3820">
    def test_object_references(self):
        beyonce = Artist("Beyonc")
        jay_z = Artist("Jay-Z")
        discography = [
            Album("Dangerously in Love", [beyonce]),
            Album("Everything Is Love", [beyonce, jay_z]),
        ]
        ctx = JSContext()
        result = ctx.pack(discography)

        self.assertEqual(result, [
            {
                '_type': 'music.Album',
                '_args': [
                    "Dangerously in Love",
                    [
                        {'_type': 'music.Artist', '_args': ["Beyonc"], '_id': 0},
                    ]
                ]
            },
            {
                '_type': 'music.Album',
                '_args': [
                    "Everything Is Love",
                    [
                        {'_ref': 0},
                        {'_type': 'music.Artist', '_args': ["Jay-Z"]},
                    ]
                ]
            },
        ])

        self.assertIn('music_player.js', str(ctx.media))

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_telepath.py" startline="213" endline="248" pcid="3823">
    def test_avoid_primitive_value_references_for_short_strings(self):
        beyonce_name = "Beyonc"
        beyonce = Artist(beyonce_name)
        discography = [
            Album("Dangerously in Love", [beyonce]),
            Album(beyonce_name, [beyonce]),
        ]
        ctx = JSContext()
        result = ctx.pack(discography)

        self.assertEqual(result, [
            {
                '_type': 'music.Album',
                '_args': [
                    "Dangerously in Love",
                    [
                        {
                            '_type': 'music.Artist',
                            '_args': ["Beyonc"],
                            '_id': 1,
                        },
                    ]
                ]
            },
            {
                '_type': 'music.Album',
                '_args': [
                    "Beyonc",
                    [
                        {'_ref': 1},
                    ]
                ]
            },
        ])


</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_telepath.py" startline="178" endline="212" pcid="3822">
    def test_primitive_value_references(self):
        beyonce_name = "Beyonc Giselle Knowles-Carter"
        beyonce = Artist(beyonce_name)
        discography = [
            Album("Dangerously in Love", [beyonce]),
            Album(beyonce_name, [beyonce]),
        ]
        ctx = JSContext()
        result = ctx.pack(discography)

        self.assertEqual(result, [
            {
                '_type': 'music.Album',
                '_args': [
                    "Dangerously in Love",
                    [
                        {
                            '_type': 'music.Artist',
                            '_args': [{'_val': "Beyonc Giselle Knowles-Carter", '_id': 0}],
                            '_id': 1,
                        },
                    ]
                ]
            },
            {
                '_type': 'music.Album',
                '_args': [
                    {'_ref': 0},
                    [
                        {'_ref': 1},
                    ]
                ]
            },
        ])

</source>
</class>

<class classid="161" nclones="4" nlines="40" similarity="72">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_permissions.py" startline="25" endline="88" pcid="3833">
    def test_nonpublisher_page_permissions(self):
        event_editor = get_user_model().objects.get(email='eventeditor@example.com')
        homepage = Page.objects.get(url_path='/home/')
        christmas_page = EventPage.objects.get(url_path='/home/events/christmas/')
        unpublished_event_page = EventPage.objects.get(url_path='/home/events/tentative-unpublished-event/')
        someone_elses_event_page = EventPage.objects.get(url_path='/home/events/someone-elses-event/')
        board_meetings_page = BusinessSubIndex.objects.get(url_path='/home/events/businessy-events/board-meetings/')

        homepage_perms = homepage.permissions_for_user(event_editor)
        christmas_page_perms = christmas_page.permissions_for_user(event_editor)
        unpub_perms = unpublished_event_page.permissions_for_user(event_editor)
        someone_elses_event_perms = someone_elses_event_page.permissions_for_user(event_editor)
        board_meetings_perms = board_meetings_page.permissions_for_user(event_editor)

        self.assertFalse(homepage_perms.can_add_subpage())
        self.assertTrue(christmas_page_perms.can_add_subpage())
        self.assertTrue(unpub_perms.can_add_subpage())
        self.assertTrue(someone_elses_event_perms.can_add_subpage())

        self.assertFalse(homepage_perms.can_edit())
        self.assertTrue(christmas_page_perms.can_edit())
        self.assertTrue(unpub_perms.can_edit())
        # basic 'add' permission doesn't allow editing pages owned by someone else
        self.assertFalse(someone_elses_event_perms.can_edit())

        self.assertFalse(homepage_perms.can_delete())
        self.assertFalse(christmas_page_perms.can_delete())  # cannot delete because it is published
        self.assertTrue(unpub_perms.can_delete())
        self.assertFalse(someone_elses_event_perms.can_delete())

        self.assertFalse(homepage_perms.can_publish())
        self.assertFalse(christmas_page_perms.can_publish())
        self.assertFalse(unpub_perms.can_publish())

        self.assertFalse(homepage_perms.can_unpublish())
        self.assertFalse(christmas_page_perms.can_unpublish())
        self.assertFalse(unpub_perms.can_unpublish())

        self.assertFalse(homepage_perms.can_publish_subpage())
        self.assertFalse(christmas_page_perms.can_publish_subpage())
        self.assertFalse(unpub_perms.can_publish_subpage())

        self.assertFalse(homepage_perms.can_reorder_children())
        self.assertFalse(christmas_page_perms.can_reorder_children())
        self.assertFalse(unpub_perms.can_reorder_children())

        self.assertFalse(homepage_perms.can_move())
        # cannot move because this would involve unpublishing from its current location
        self.assertFalse(christmas_page_perms.can_move())
        self.assertTrue(unpub_perms.can_move())
        self.assertFalse(someone_elses_event_perms.can_move())

        # cannot move because this would involve unpublishing from its current location
        self.assertFalse(christmas_page_perms.can_move_to(unpublished_event_page))
        self.assertTrue(unpub_perms.can_move_to(christmas_page))
        self.assertFalse(unpub_perms.can_move_to(homepage))  # no permission to create pages at destination
        self.assertFalse(unpub_perms.can_move_to(unpublished_event_page))  # cannot make page a child of itself
        # cannot move because the subpage_types rule of BusinessSubIndex forbids EventPage as a subpage
        self.assertFalse(unpub_perms.can_move_to(board_meetings_page))

        self.assertTrue(board_meetings_perms.can_move())
        # cannot move because the parent_page_types rule of BusinessSubIndex forbids EventPage as a parent
        self.assertFalse(board_meetings_perms.can_move_to(christmas_page))

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_permissions.py" startline="145" endline="203" pcid="3835">
    def test_publish_page_permissions_without_edit(self):
        event_moderator = get_user_model().objects.get(email='eventmoderator@example.com')

        # Remove 'edit' permission from the event_moderator group
        GroupPagePermission.objects.filter(group__name='Event moderators', permission_type='edit').delete()

        homepage = Page.objects.get(url_path='/home/')
        christmas_page = EventPage.objects.get(url_path='/home/events/christmas/')
        unpublished_event_page = EventPage.objects.get(url_path='/home/events/tentative-unpublished-event/')
        # 'someone else's event' is owned by eventmoderator
        moderator_event_page = EventPage.objects.get(url_path='/home/events/someone-elses-event/')

        homepage_perms = homepage.permissions_for_user(event_moderator)
        christmas_page_perms = christmas_page.permissions_for_user(event_moderator)
        unpub_perms = unpublished_event_page.permissions_for_user(event_moderator)
        moderator_event_perms = moderator_event_page.permissions_for_user(event_moderator)

        # we still have add permission within events
        self.assertFalse(homepage_perms.can_add_subpage())
        self.assertTrue(christmas_page_perms.can_add_subpage())

        # add permission lets us edit our own event
        self.assertFalse(christmas_page_perms.can_edit())
        self.assertTrue(moderator_event_perms.can_edit())

        # with add + publish permissions, can delete a published page owned by us
        self.assertTrue(moderator_event_perms.can_delete())
        # but NOT a page owned by someone else (which would require edit permission)
        self.assertFalse(christmas_page_perms.can_delete())
        # ...even an unpublished one
        self.assertFalse(unpub_perms.can_delete())

        # we can still publish/unpublish events regardless of owner
        self.assertFalse(homepage_perms.can_publish())
        self.assertTrue(christmas_page_perms.can_publish())
        self.assertTrue(unpub_perms.can_publish())

        self.assertFalse(homepage_perms.can_unpublish())
        self.assertTrue(christmas_page_perms.can_unpublish())
        self.assertFalse(unpub_perms.can_unpublish())  # cannot unpublish a page that isn't published

        self.assertFalse(homepage_perms.can_publish_subpage())
        self.assertTrue(christmas_page_perms.can_publish_subpage())
        self.assertTrue(unpub_perms.can_publish_subpage())

        # reorder permission is considered equivalent to publish permission
        # (so we can do it on pages we can't edit)
        self.assertFalse(homepage_perms.can_reorder_children())
        self.assertTrue(christmas_page_perms.can_reorder_children())
        self.assertTrue(unpub_perms.can_reorder_children())

        # moving requires edit permission
        self.assertFalse(homepage_perms.can_move())
        self.assertFalse(christmas_page_perms.can_move())
        self.assertTrue(moderator_event_perms.can_move())
        # and add permission on the destination
        self.assertFalse(moderator_event_perms.can_move_to(homepage))
        self.assertTrue(moderator_event_perms.can_move_to(unpublished_event_page))

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_permissions.py" startline="89" endline="144" pcid="3834">
    def test_publisher_page_permissions(self):
        event_moderator = get_user_model().objects.get(email='eventmoderator@example.com')
        homepage = Page.objects.get(url_path='/home/')
        christmas_page = EventPage.objects.get(url_path='/home/events/christmas/')
        unpublished_event_page = EventPage.objects.get(url_path='/home/events/tentative-unpublished-event/')
        board_meetings_page = BusinessSubIndex.objects.get(url_path='/home/events/businessy-events/board-meetings/')

        homepage_perms = homepage.permissions_for_user(event_moderator)
        christmas_page_perms = christmas_page.permissions_for_user(event_moderator)
        unpub_perms = unpublished_event_page.permissions_for_user(event_moderator)
        board_meetings_perms = board_meetings_page.permissions_for_user(event_moderator)

        self.assertFalse(homepage_perms.can_add_subpage())
        self.assertTrue(christmas_page_perms.can_add_subpage())
        self.assertTrue(unpub_perms.can_add_subpage())

        self.assertFalse(homepage_perms.can_edit())
        self.assertTrue(christmas_page_perms.can_edit())
        self.assertTrue(unpub_perms.can_edit())

        self.assertFalse(homepage_perms.can_delete())
        # can delete a published page because we have publish permission
        self.assertTrue(christmas_page_perms.can_delete())
        self.assertTrue(unpub_perms.can_delete())

        self.assertFalse(homepage_perms.can_publish())
        self.assertTrue(christmas_page_perms.can_publish())
        self.assertTrue(unpub_perms.can_publish())

        self.assertFalse(homepage_perms.can_unpublish())
        self.assertTrue(christmas_page_perms.can_unpublish())
        self.assertFalse(unpub_perms.can_unpublish())  # cannot unpublish a page that isn't published

        self.assertFalse(homepage_perms.can_publish_subpage())
        self.assertTrue(christmas_page_perms.can_publish_subpage())
        self.assertTrue(unpub_perms.can_publish_subpage())

        self.assertFalse(homepage_perms.can_reorder_children())
        self.assertTrue(christmas_page_perms.can_reorder_children())
        self.assertTrue(unpub_perms.can_reorder_children())

        self.assertFalse(homepage_perms.can_move())
        self.assertTrue(christmas_page_perms.can_move())
        self.assertTrue(unpub_perms.can_move())

        self.assertTrue(christmas_page_perms.can_move_to(unpublished_event_page))
        self.assertTrue(unpub_perms.can_move_to(christmas_page))
        self.assertFalse(unpub_perms.can_move_to(homepage))  # no permission to create pages at destination
        self.assertFalse(unpub_perms.can_move_to(unpublished_event_page))  # cannot make page a child of itself
        # cannot move because the subpage_types rule of BusinessSubIndex forbids EventPage as a subpage
        self.assertFalse(unpub_perms.can_move_to(board_meetings_page))

        self.assertTrue(board_meetings_perms.can_move())
        # cannot move because the parent_page_types rule of BusinessSubIndex forbids EventPage as a parent
        self.assertFalse(board_meetings_perms.can_move_to(christmas_page))

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_permissions.py" startline="265" endline="310" pcid="3840">
    def test_superuser_has_full_permissions(self):
        user = get_user_model().objects.get(email='superuser@example.com')
        homepage = Page.objects.get(url_path='/home/').specific
        root = Page.objects.get(url_path='/').specific
        unpublished_event_page = EventPage.objects.get(url_path='/home/events/tentative-unpublished-event/')
        board_meetings_page = BusinessSubIndex.objects.get(url_path='/home/events/businessy-events/board-meetings/')

        homepage_perms = homepage.permissions_for_user(user)
        root_perms = root.permissions_for_user(user)
        unpub_perms = unpublished_event_page.permissions_for_user(user)
        board_meetings_perms = board_meetings_page.permissions_for_user(user)

        self.assertTrue(homepage_perms.can_add_subpage())
        self.assertTrue(root_perms.can_add_subpage())

        self.assertTrue(homepage_perms.can_edit())
        self.assertFalse(root_perms.can_edit())  # root is not a real editable page, even to superusers

        self.assertTrue(homepage_perms.can_delete())
        self.assertFalse(root_perms.can_delete())

        self.assertTrue(homepage_perms.can_publish())
        self.assertFalse(root_perms.can_publish())

        self.assertTrue(homepage_perms.can_unpublish())
        self.assertFalse(root_perms.can_unpublish())
        self.assertFalse(unpub_perms.can_unpublish())

        self.assertTrue(homepage_perms.can_publish_subpage())
        self.assertTrue(root_perms.can_publish_subpage())

        self.assertTrue(homepage_perms.can_reorder_children())
        self.assertTrue(root_perms.can_reorder_children())

        self.assertTrue(homepage_perms.can_move())
        self.assertFalse(root_perms.can_move())

        self.assertTrue(homepage_perms.can_move_to(root))
        self.assertFalse(homepage_perms.can_move_to(unpublished_event_page))

        # cannot move because the subpage_types rule of BusinessSubIndex forbids EventPage as a subpage
        self.assertFalse(unpub_perms.can_move_to(board_meetings_page))
        self.assertTrue(board_meetings_perms.can_move())
        # cannot move because the parent_page_types rule of BusinessSubIndex forbids EventPage as a parent
        self.assertFalse(board_meetings_perms.can_move_to(unpublished_event_page))

</source>
</class>

<class classid="162" nclones="5" nlines="21" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_permissions.py" startline="342" endline="368" pcid="3842">
    def test_editable_pages_for_user_with_add_permission(self):
        event_editor = get_user_model().objects.get(email='eventeditor@example.com')
        homepage = Page.objects.get(url_path='/home/')
        christmas_page = EventPage.objects.get(url_path='/home/events/christmas/')
        unpublished_event_page = EventPage.objects.get(url_path='/home/events/tentative-unpublished-event/')
        someone_elses_event_page = EventPage.objects.get(url_path='/home/events/someone-elses-event/')

        user_perms = UserPagePermissionsProxy(event_editor)
        editable_pages = user_perms.editable_pages()
        can_edit_pages = user_perms.can_edit_pages()
        publishable_pages = user_perms.publishable_pages()
        can_publish_pages = user_perms.can_publish_pages()

        self.assertFalse(editable_pages.filter(id=homepage.id).exists())
        self.assertTrue(editable_pages.filter(id=christmas_page.id).exists())
        self.assertTrue(editable_pages.filter(id=unpublished_event_page.id).exists())
        self.assertFalse(editable_pages.filter(id=someone_elses_event_page.id).exists())

        self.assertTrue(can_edit_pages)

        self.assertFalse(publishable_pages.filter(id=homepage.id).exists())
        self.assertFalse(publishable_pages.filter(id=christmas_page.id).exists())
        self.assertFalse(publishable_pages.filter(id=unpublished_event_page.id).exists())
        self.assertFalse(publishable_pages.filter(id=someone_elses_event_page.id).exists())

        self.assertFalse(can_publish_pages)

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_permissions.py" startline="418" endline="444" pcid="3846">
    def test_editable_pages_for_user_with_edit_permission(self):
        event_moderator = get_user_model().objects.get(email='eventmoderator@example.com')
        homepage = Page.objects.get(url_path='/home/')
        christmas_page = EventPage.objects.get(url_path='/home/events/christmas/')
        unpublished_event_page = EventPage.objects.get(url_path='/home/events/tentative-unpublished-event/')
        someone_elses_event_page = EventPage.objects.get(url_path='/home/events/someone-elses-event/')

        user_perms = UserPagePermissionsProxy(event_moderator)
        editable_pages = user_perms.editable_pages()
        can_edit_pages = user_perms.can_edit_pages()
        publishable_pages = user_perms.publishable_pages()
        can_publish_pages = user_perms.can_publish_pages()

        self.assertFalse(editable_pages.filter(id=homepage.id).exists())
        self.assertTrue(editable_pages.filter(id=christmas_page.id).exists())
        self.assertTrue(editable_pages.filter(id=unpublished_event_page.id).exists())
        self.assertTrue(editable_pages.filter(id=someone_elses_event_page.id).exists())

        self.assertTrue(can_edit_pages)

        self.assertFalse(publishable_pages.filter(id=homepage.id).exists())
        self.assertTrue(publishable_pages.filter(id=christmas_page.id).exists())
        self.assertTrue(publishable_pages.filter(id=unpublished_event_page.id).exists())
        self.assertTrue(publishable_pages.filter(id=someone_elses_event_page.id).exists())

        self.assertTrue(can_publish_pages)

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_permissions.py" startline="499" endline="525" pcid="3849">
    def test_editable_pages_for_non_editing_user(self):
        user = get_user_model().objects.get(email='admin_only_user@example.com')
        homepage = Page.objects.get(url_path='/home/')
        christmas_page = EventPage.objects.get(url_path='/home/events/christmas/')
        unpublished_event_page = EventPage.objects.get(url_path='/home/events/tentative-unpublished-event/')
        someone_elses_event_page = EventPage.objects.get(url_path='/home/events/someone-elses-event/')

        user_perms = UserPagePermissionsProxy(user)
        editable_pages = user_perms.editable_pages()
        can_edit_pages = user_perms.can_edit_pages()
        publishable_pages = user_perms.publishable_pages()
        can_publish_pages = user_perms.can_publish_pages()

        self.assertFalse(editable_pages.filter(id=homepage.id).exists())
        self.assertFalse(editable_pages.filter(id=christmas_page.id).exists())
        self.assertFalse(editable_pages.filter(id=unpublished_event_page.id).exists())
        self.assertFalse(editable_pages.filter(id=someone_elses_event_page.id).exists())

        self.assertFalse(can_edit_pages)

        self.assertFalse(publishable_pages.filter(id=homepage.id).exists())
        self.assertFalse(publishable_pages.filter(id=christmas_page.id).exists())
        self.assertFalse(publishable_pages.filter(id=unpublished_event_page.id).exists())
        self.assertFalse(publishable_pages.filter(id=someone_elses_event_page.id).exists())

        self.assertFalse(can_publish_pages)

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_permissions.py" startline="445" endline="471" pcid="3847">
    def test_editable_pages_for_inactive_user(self):
        user = get_user_model().objects.get(email='inactiveuser@example.com')
        homepage = Page.objects.get(url_path='/home/')
        christmas_page = EventPage.objects.get(url_path='/home/events/christmas/')
        unpublished_event_page = EventPage.objects.get(url_path='/home/events/tentative-unpublished-event/')
        someone_elses_event_page = EventPage.objects.get(url_path='/home/events/someone-elses-event/')

        user_perms = UserPagePermissionsProxy(user)
        editable_pages = user_perms.editable_pages()
        can_edit_pages = user_perms.can_edit_pages()
        publishable_pages = user_perms.publishable_pages()
        can_publish_pages = user_perms.can_publish_pages()

        self.assertFalse(editable_pages.filter(id=homepage.id).exists())
        self.assertFalse(editable_pages.filter(id=christmas_page.id).exists())
        self.assertFalse(editable_pages.filter(id=unpublished_event_page.id).exists())
        self.assertFalse(editable_pages.filter(id=someone_elses_event_page.id).exists())

        self.assertFalse(can_edit_pages)

        self.assertFalse(publishable_pages.filter(id=homepage.id).exists())
        self.assertFalse(publishable_pages.filter(id=christmas_page.id).exists())
        self.assertFalse(publishable_pages.filter(id=unpublished_event_page.id).exists())
        self.assertFalse(publishable_pages.filter(id=someone_elses_event_page.id).exists())

        self.assertFalse(can_publish_pages)

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_permissions.py" startline="472" endline="498" pcid="3848">
    def test_editable_pages_for_superuser(self):
        user = get_user_model().objects.get(email='superuser@example.com')
        homepage = Page.objects.get(url_path='/home/')
        christmas_page = EventPage.objects.get(url_path='/home/events/christmas/')
        unpublished_event_page = EventPage.objects.get(url_path='/home/events/tentative-unpublished-event/')
        someone_elses_event_page = EventPage.objects.get(url_path='/home/events/someone-elses-event/')

        user_perms = UserPagePermissionsProxy(user)
        editable_pages = user_perms.editable_pages()
        can_edit_pages = user_perms.can_edit_pages()
        publishable_pages = user_perms.publishable_pages()
        can_publish_pages = user_perms.can_publish_pages()

        self.assertTrue(editable_pages.filter(id=homepage.id).exists())
        self.assertTrue(editable_pages.filter(id=christmas_page.id).exists())
        self.assertTrue(editable_pages.filter(id=unpublished_event_page.id).exists())
        self.assertTrue(editable_pages.filter(id=someone_elses_event_page.id).exists())

        self.assertTrue(can_edit_pages)

        self.assertTrue(publishable_pages.filter(id=homepage.id).exists())
        self.assertTrue(publishable_pages.filter(id=christmas_page.id).exists())
        self.assertTrue(publishable_pages.filter(id=unpublished_event_page.id).exists())
        self.assertTrue(publishable_pages.filter(id=someone_elses_event_page.id).exists())

        self.assertTrue(can_publish_pages)

</source>
</class>

<class classid="163" nclones="4" nlines="10" similarity="70">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_permissions.py" startline="369" endline="386" pcid="3843">
    def test_explorable_pages(self):
        event_editor = get_user_model().objects.get(email='eventeditor@example.com')
        christmas_page = EventPage.objects.get(url_path='/home/events/christmas/')
        unpublished_event_page = EventPage.objects.get(url_path='/home/events/tentative-unpublished-event/')
        someone_elses_event_page = EventPage.objects.get(url_path='/home/events/someone-elses-event/')
        about_us_page = Page.objects.get(url_path='/home/about-us/')

        user_perms = UserPagePermissionsProxy(event_editor)
        explorable_pages = user_perms.explorable_pages()

        # Verify all pages below /home/events/ are explorable
        self.assertTrue(explorable_pages.filter(id=christmas_page.id).exists())
        self.assertTrue(explorable_pages.filter(id=unpublished_event_page.id).exists())
        self.assertTrue(explorable_pages.filter(id=someone_elses_event_page.id).exists())

        # Verify page outside /events/ tree are not explorable
        self.assertFalse(explorable_pages.filter(id=about_us_page.id).exists())

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_permissions.py" startline="404" endline="417" pcid="3845">
    def test_explorable_pages_with_permission_gap_in_hierarchy(self):
        corporate_editor = get_user_model().objects.get(email='corporateeditor@example.com')
        user_perms = UserPagePermissionsProxy(corporate_editor)

        about_us_page = Page.objects.get(url_path='/home/about-us/')
        businessy_events = Page.objects.get(url_path='/home/events/businessy-events/')
        events_page = Page.objects.get(url_path='/home/events/')

        explorable_pages = user_perms.explorable_pages()

        self.assertTrue(explorable_pages.filter(id=about_us_page.id).exists())
        self.assertTrue(explorable_pages.filter(id=businessy_events.id).exists())
        self.assertTrue(explorable_pages.filter(id=events_page.id).exists())

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_queryset.py" startline="457" endline="477" pcid="4418">
    def test_not_public(self):
        events_index = Page.objects.get(url_path='/home/events/')
        event = Page.objects.get(url_path='/home/events/christmas/')
        homepage = Page.objects.get(url_path='/home/')

        # Add PageViewRestriction to events_index
        PageViewRestriction.objects.create(page=events_index, password='hello')

        with self.assertNumQueries(4):
            # Get public pages
            pages = Page.objects.not_public()

            # Check that the homepage is not in the results
            self.assertFalse(pages.filter(id=homepage.id).exists())

            # Check that the events index is in the results
            self.assertTrue(pages.filter(id=events_index.id).exists())

            # Check that the event is in the results
            self.assertTrue(pages.filter(id=event.id).exists())

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_queryset.py" startline="436" endline="456" pcid="4417">
    def test_public(self):
        events_index = Page.objects.get(url_path='/home/events/')
        event = Page.objects.get(url_path='/home/events/christmas/')
        homepage = Page.objects.get(url_path='/home/')

        # Add PageViewRestriction to events_index
        PageViewRestriction.objects.create(page=events_index, password='hello')

        with self.assertNumQueries(4):
            # Get public pages
            pages = Page.objects.public()

            # Check that the homepage is in the results
            self.assertTrue(pages.filter(id=homepage.id).exists())

            # Check that the events index is not in the results
            self.assertFalse(pages.filter(id=events_index.id).exists())

            # Check that the event is not in the results
            self.assertFalse(pages.filter(id=event.id).exists())

</source>
</class>

<class classid="164" nclones="3" nlines="12" similarity="83">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_permissions.py" startline="558" endline="575" pcid="3853">
    def test_lock_page_for_moderator_whole_locked_page_without_unlock_permission(self):
        user = get_user_model().objects.get(email='eventmoderator@example.com')
        christmas_page = EventPage.objects.get(url_path='/home/events/christmas/')

        # Lock the page
        christmas_page.locked = True
        christmas_page.locked_by = user
        christmas_page.locked_at = timezone.now()
        christmas_page.save()

        GroupPagePermission.objects.filter(group__name='Event moderators', permission_type='unlock').delete()

        perms = UserPagePermissionsProxy(user).for_page(christmas_page)

        # Unlike in the previous test, the user can unlock this page as it was them who locked
        self.assertTrue(perms.can_lock())
        self.assertTrue(perms.can_unlock())

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_permissions.py" startline="640" endline="659" pcid="3859">
    def test_page_locked_for_locked_page_with_global_lock_enabled(self):
        user = get_user_model().objects.get(email='eventmoderator@example.com')
        christmas_page = EventPage.objects.get(url_path='/home/events/christmas/')

        # Lock the page
        christmas_page.locked = True
        christmas_page.locked_by = user
        christmas_page.locked_at = timezone.now()
        christmas_page.save()

        perms = UserPagePermissionsProxy(user).for_page(christmas_page)

        # The user who locked the page should now also see the page as locked
        self.assertTrue(perms.page_locked())

        # Other users should see the page as locked, like before
        other_user = get_user_model().objects.get(email='eventeditor@example.com')
        other_perms = UserPagePermissionsProxy(other_user).for_page(christmas_page)
        self.assertTrue(other_perms.page_locked())

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_permissions.py" startline="619" endline="638" pcid="3858">
    def test_page_locked_for_locked_page(self):
        user = get_user_model().objects.get(email='eventmoderator@example.com')
        christmas_page = EventPage.objects.get(url_path='/home/events/christmas/')

        # Lock the page
        christmas_page.locked = True
        christmas_page.locked_by = user
        christmas_page.locked_at = timezone.now()
        christmas_page.save()

        perms = UserPagePermissionsProxy(user).for_page(christmas_page)

        # The user who locked the page shouldn't see the page as locked
        self.assertFalse(perms.page_locked())

        # Other users should see the page as locked
        other_user = get_user_model().objects.get(email='eventeditor@example.com')
        other_perms = UserPagePermissionsProxy(other_user).for_page(christmas_page)
        self.assertTrue(other_perms.page_locked())

</source>
</class>

<class classid="165" nclones="2" nlines="14" similarity="85">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_permissions.py" startline="660" endline="686" pcid="3860">
    def test_page_locked_in_workflow(self):
        workflow, task = self.create_workflow_and_task()
        editor = get_user_model().objects.get(email='eventeditor@example.com')
        moderator = get_user_model().objects.get(email='eventmoderator@example.com')
        superuser = get_user_model().objects.get(email='superuser@example.com')
        christmas_page = EventPage.objects.get(url_path='/home/events/christmas/')
        christmas_page.save_revision()
        workflow.start(christmas_page, editor)

        moderator_perms = UserPagePermissionsProxy(moderator).for_page(christmas_page)

        # the moderator is in the group assigned to moderate the task, so the page should
        # not be locked for them
        self.assertFalse(moderator_perms.page_locked())

        superuser_perms = UserPagePermissionsProxy(superuser).for_page(christmas_page)

        # superusers can moderate any GroupApprovalTask, so the page should not be locked
        # for them
        self.assertFalse(superuser_perms.page_locked())

        editor_perms = UserPagePermissionsProxy(editor).for_page(christmas_page)

        # the editor is not in the group assigned to moderate the task, so the page should
        # be locked for them
        self.assertTrue(editor_perms.page_locked())

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_permissions.py" startline="687" endline="708" pcid="3861">
    def test_page_lock_in_workflow(self):
        workflow, task = self.create_workflow_and_task()
        editor = get_user_model().objects.get(email='eventeditor@example.com')
        moderator = get_user_model().objects.get(email='eventmoderator@example.com')
        christmas_page = EventPage.objects.get(url_path='/home/events/christmas/')
        christmas_page.save_revision()
        workflow.start(christmas_page, editor)

        moderator_perms = UserPagePermissionsProxy(moderator).for_page(christmas_page)

        # the moderator is in the group assigned to moderate the task, so they can lock the page, but can't unlock it
        # unless they're the locker
        self.assertTrue(moderator_perms.can_lock())
        self.assertFalse(moderator_perms.can_unlock())

        editor_perms = UserPagePermissionsProxy(editor).for_page(christmas_page)

        # the editor is not in the group assigned to moderate the task, so they can't lock or unlock the page
        self.assertFalse(editor_perms.can_lock())
        self.assertFalse(editor_perms.can_unlock())


</source>
</class>

<class classid="166" nclones="3" nlines="15" similarity="72">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_utils.py" startline="29" endline="45" pcid="3914">
    def test_string_to_ascii(self):
        test_cases = [
            (u'30 \U0001d5c4\U0001d5c6/\U0001d5c1', '30 km/h'),
            (u'\u5317\u4EB0', 'BeiJing'),
            ('      ', 'a a i i u u e'),
            ('                     ', 'A B G D E Z E Y T\' Zh I L Kh Ts K H Dz Gh Ch M Y N'),
            ('!', 'Sport!'),
            ('Straenbahn', 'Strassenbahn'),
            ('Hello world', 'Hello world'),
            ('                ', 'A a A a A a C c C c C c C c D d D'),
            ('', '[ShanMai]'),
        ]

        for (original, expected_result) in test_cases:
            self.assertEqual(string_to_ascii(original), expected_result)


</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_utils.py" startline="79" endline="99" pcid="3917">
    def test_strings_with_latin_chars(self):
        test_cases = [
            ('', ''),
            ('???', ''),
            ('using-Hyphen', 'using_hyphen'),
            ('endash', 'endash'),  # unicode non-letter characters stripped
            ('  emdash ', 'emdash'),  # unicode non-letter characters stripped
            ('horizontalBAR', 'horizontalbar'),  # unicode non-letter characters stripped
            ('Hello world', 'hello_world'),
            ('Hello_world', 'hello_world'),
            ('Hell wrld', 'hello_world'),
            ('Hello   world', 'hello_world'),
            ('   Hello world   ', 'hello_world'),
            ('Hello, world!', 'hello_world'),
            ('Hello*world', 'helloworld'),
            ('Screenshot_2020-05-29 Screenshot(1).png', 'screenshot_2020_05_29_screenshot1png')
        ]

        for (original, expected_result) in test_cases:
            self.assertEqual(safe_snake_case(original), expected_result)

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_utils.py" startline="48" endline="65" pcid="3915">
    def test_behaves_same_as_slugify_for_latin_chars(self):
        test_cases = [
            ('', ''),
            ('???', ''),
            ('Hello world', 'hello-world'),
            ('Hello_world', 'hello_world'),
            ('Hell wrld', 'hello-world'),
            ('Hello   world', 'hello-world'),
            ('   Hello world   ', 'hello-world'),
            ('Hello, world!', 'hello-world'),
            ('Hello*world', 'helloworld'),
            ('Helloworld', 'helloworld'),
        ]

        for (original, expected_result) in test_cases:
            self.assertEqual(slugify(original), expected_result)
            self.assertEqual(cautious_slugify(original), expected_result)

</source>
</class>

<class classid="167" nclones="2" nlines="18" similarity="72">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_utils.py" startline="236" endline="254" pcid="3931">
    def test_get_supported_content_language_variant(self):
        g = get_supported_content_language_variant
        self.assertEqual(g('en'), 'en')
        self.assertEqual(g('en-gb'), 'en')
        self.assertEqual(g('de'), 'de')
        self.assertEqual(g('de-at'), 'de-at')
        self.assertEqual(g('de-ch'), 'de')
        self.assertEqual(g('pt-br'), 'pt-br')
        self.assertEqual(g('pt'), 'pt-br')
        self.assertEqual(g('pt-pt'), 'pt-br')
        with self.assertRaises(LookupError):
            g('pt', strict=True)
        with self.assertRaises(LookupError):
            g('pt-pt', strict=True)
        with self.assertRaises(LookupError):
            g('xyz')
        with self.assertRaises(LookupError):
            g('xy-zz')

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_utils.py" startline="259" endline="278" pcid="3932">
    def test_uses_wagtail_content_languages(self):
        # be sure it's not using Django's LANGUAGES
        g = get_supported_content_language_variant
        self.assertEqual(g('en'), 'en')
        self.assertEqual(g('en-gb'), 'en')
        self.assertEqual(g('de'), 'de')
        self.assertEqual(g('de-at'), 'de')
        self.assertEqual(g('de-ch'), 'de')
        with self.assertRaises(LookupError):
            g('pt-br')
        with self.assertRaises(LookupError):
            g('pt')
        with self.assertRaises(LookupError):
            g('pt-pt')
        with self.assertRaises(LookupError):
            g('xyz')
        with self.assertRaises(LookupError):
            g('xy-zz')


</source>
</class>

<class classid="168" nclones="6" nlines="13" similarity="71">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_permission_policies.py" startline="282" endline="298" pcid="3987">
    def test_user_has_permission(self):
        # All active authenticated users have permission to do everything;
        # inactive and anonymous users have permission to do nothing
        self.assertUserPermissionMatrix([
            (self.superuser, True, True, True, True),
            (self.inactive_superuser, False, False, False, False),
            (self.image_adder, True, True, True, True),
            (self.oneoff_image_adder, True, True, True, True),
            (self.inactive_image_adder, False, False, False, False),
            (self.image_changer, True, True, True, True),
            (self.oneoff_image_changer, True, True, True, True),
            (self.inactive_image_changer, False, False, False, False),
            (self.oneoff_image_deleter, True, True, True, True),
            (self.useless_user, True, True, True, True),
            (self.anonymous_user, False, False, False, False),
        ])

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_collection_permission_policies.py" startline="1029" endline="1039" pcid="4360">
    def test_user_has_permission(self):
        self.assertUserPermissionMatrix([
            (self.superuser, True, True, True, True),
            (self.inactive_superuser, False, False, False, False),
            (self.report_changer, False, True, False, False),
            (self.report_adder, True, False, False, False),
            (self.report_deleter, False, False, True, False),
            (self.useless_user, False, False, False, False),
            (self.anonymous_user, False, False, False, False),
        ])

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_collection_permission_policies.py" startline="131" endline="142" pcid="4334">
    def test_user_has_permission(self):
        self.assertUserPermissionMatrix([
            (self.superuser, True, True, True, True),
            (self.inactive_superuser, False, False, False, False),
            (self.doc_changer, False, True, False, False),
            (self.inactive_doc_changer, False, False, False, False),
            (self.report_changer, False, True, False, False),
            (self.report_adder, True, False, False, False),
            (self.useless_user, False, False, False, False),
            (self.anonymous_user, False, False, False, False),
        ])

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_permission_policies.py" startline="507" endline="542" pcid="3998">
    def test_user_has_permission(self):
        self.assertUserPermissionMatrix([
            # Superuser has permission to do everything
            (self.superuser, True, True, True, True),

            # Inactive superuser can do nothing
            (self.inactive_superuser, False, False, False, False),

            # User with 'add' permission via group can only add
            (self.image_adder, True, False, False, False),

            # User with 'add' permission via user can only add
            (self.oneoff_image_adder, True, False, False, False),

            # Inactive user with 'add' permission can do nothing
            (self.inactive_image_adder, False, False, False, False),

            # User with 'change' permission via group can only change
            (self.image_changer, False, True, False, False),

            # User with 'change' permission via user can only change
            (self.oneoff_image_changer, False, True, False, False),

            # Inactive user with 'add' permission can do nothing
            (self.inactive_image_changer, False, False, False, False),

            # User with 'delete' permission can only delete
            (self.oneoff_image_deleter, False, False, True, False),

            # User with no permissions can do nothing
            (self.useless_user, False, False, False, False),

            # Anonymous user can do nothing
            (self.anonymous_user, False, False, False, False),
        ])

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_permission_policies.py" startline="881" endline="918" pcid="4009">
    def test_user_has_permission(self):
        self.assertUserPermissionMatrix([
            # Superuser has permission to do everything
            (self.superuser, True, True, True, True),

            # Inactive superuser can do nothing
            (self.inactive_superuser, False, False, False, False),

            # User with 'add' permission via group can add,
            # and by extension, change and delete their own instances
            (self.image_adder, True, True, True, False),

            # User with 'add' permission via user can add,
            # and by extension, change and delete their own instances
            (self.oneoff_image_adder, True, True, True, False),

            # Inactive user with 'add' permission can do nothing
            (self.inactive_image_adder, False, False, False, False),

            # User with 'change' permission via group can change and delete but not add
            (self.image_changer, False, True, True, False),

            # User with 'change' permission via user can change and delete but not add
            (self.oneoff_image_changer, False, True, True, False),

            # Inactive user with 'change' permission can do nothing
            (self.inactive_image_changer, False, False, False, False),

            # 'delete' permission is ignored for this policy
            (self.oneoff_image_deleter, False, False, False, False),

            # User with no permission can do nothing
            (self.useless_user, False, False, False, False),

            # Anonymous user can do nothing
            (self.anonymous_user, False, False, False, False),
        ])

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_collection_permission_policies.py" startline="523" endline="534" pcid="4347">
    def test_user_has_permission(self):
        self.assertUserPermissionMatrix([
            (self.superuser, True, True, True, True),
            (self.inactive_superuser, False, False, False, False),
            (self.doc_changer, False, True, True, False),
            (self.inactive_doc_changer, False, False, False, False),
            (self.report_changer, False, True, True, False),
            (self.report_adder, True, True, True, False),
            (self.useless_user, False, False, False, False),
            (self.anonymous_user, False, False, False, False),
        ])

</source>
</class>

<class classid="169" nclones="11" nlines="12" similarity="70">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_permission_policies.py" startline="316" endline="329" pcid="3989">
    def test_users_with_permission(self):
        # all active users have permission
        users_with_add_permission = self.policy.users_with_permission('add')

        self.assertResultSetEqual(users_with_add_permission, [
            self.superuser,
            self.image_adder,
            self.oneoff_image_adder,
            self.image_changer,
            self.oneoff_image_changer,
            self.oneoff_image_deleter,
            self.useless_user,
        ])

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_permission_policies.py" startline="330" endline="345" pcid="3990">
    def test_users_with_any_permission(self):
        # all active users have permission
        users_with_add_or_change_permission = self.policy.users_with_any_permission(
            ['add', 'change']
        )

        self.assertResultSetEqual(users_with_add_or_change_permission, [
            self.superuser,
            self.image_adder,
            self.oneoff_image_adder,
            self.image_changer,
            self.oneoff_image_changer,
            self.oneoff_image_deleter,
            self.useless_user,
        ])

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_permission_policies.py" startline="587" endline="603" pcid="4000">
    def test_users_with_permission(self):
        users_with_add_permission = self.policy.users_with_permission('add')

        self.assertResultSetEqual(users_with_add_permission, [
            self.superuser,
            self.image_adder,
            self.oneoff_image_adder,
        ])

        users_with_change_permission = self.policy.users_with_permission('change')

        self.assertResultSetEqual(users_with_change_permission, [
            self.superuser,
            self.image_changer,
            self.oneoff_image_changer,
        ])

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_collection_permission_policies.py" startline="567" endline="582" pcid="4350">
    def test_users_with_permission(self):
        users_with_change_permission = self.policy.users_with_permission('change')

        self.assertResultSetEqual(users_with_change_permission, [
            self.superuser,
            self.doc_changer,
            self.report_changer,
            self.report_adder,
        ])

        users_with_custom_permission = self.policy.users_with_permission('frobnicate')

        self.assertResultSetEqual(users_with_custom_permission, [
            self.superuser,
        ])

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_permission_policies.py" startline="485" endline="501" pcid="3996">
    def test_users_with_any_permission_for_instance(self):
        # all active users have permission
        users_with_change_or_del_permission = self.policy.users_with_any_permission_for_instance(
            ['change', 'delete'], self.useless_image
        )

        self.assertResultSetEqual(users_with_change_or_del_permission, [
            self.superuser,
            self.image_adder,
            self.oneoff_image_adder,
            self.image_changer,
            self.oneoff_image_changer,
            self.oneoff_image_deleter,
            self.useless_user,
        ])


</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_permission_policies.py" startline="469" endline="484" pcid="3995">
    def test_users_with_permission_for_instance(self):
        # all active users have permission
        users_with_change_permission = self.policy.users_with_permission_for_instance(
            'change', self.useless_image
        )

        self.assertResultSetEqual(users_with_change_permission, [
            self.superuser,
            self.image_adder,
            self.oneoff_image_adder,
            self.image_changer,
            self.oneoff_image_changer,
            self.oneoff_image_deleter,
            self.useless_user,
        ])

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_collection_permission_policies.py" startline="172" endline="186" pcid="4337">
    def test_users_with_permission(self):
        users_with_change_permission = self.policy.users_with_permission('change')

        self.assertResultSetEqual(users_with_change_permission, [
            self.superuser,
            self.doc_changer,
            self.report_changer,
        ])

        users_with_custom_permission = self.policy.users_with_permission('frobnicate')

        self.assertResultSetEqual(users_with_custom_permission, [
            self.superuser,
        ])

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_permission_policies.py" startline="999" endline="1021" pcid="4012">
    def test_users_with_any_permission(self):
        users_with_add_or_change_permission = self.policy.users_with_any_permission(
            ['add', 'change']
        )

        self.assertResultSetEqual(users_with_add_or_change_permission, [
            self.superuser,
            self.image_adder,
            self.oneoff_image_adder,
            self.image_changer,
            self.oneoff_image_changer,
        ])

        users_with_add_or_frobnicate_permission = self.policy.users_with_any_permission(
            ['add', 'frobnicate']
        )

        self.assertResultSetEqual(users_with_add_or_frobnicate_permission, [
            self.superuser,
            self.image_adder,
            self.oneoff_image_adder,
        ])

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_collection_permission_policies.py" startline="1065" endline="1078" pcid="4363">
    def test_users_with_permission(self):
        users_with_change_permission = self.policy.users_with_permission('change')

        self.assertResultSetEqual(users_with_change_permission, [
            self.superuser,
            self.report_changer,
        ])

        users_with_custom_permission = self.policy.users_with_permission('frobnicate')

        self.assertResultSetEqual(users_with_custom_permission, [
            self.superuser,
        ])

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_permission_policies.py" startline="843" endline="862" pcid="4006">
    def test_users_with_permission_for_instance(self):
        users_with_change_permission = self.policy.users_with_permission_for_instance(
            'change', self.useless_image
        )

        self.assertResultSetEqual(users_with_change_permission, [
            self.superuser,
            self.image_changer,
            self.oneoff_image_changer,
        ])

        users_with_delete_permission = self.policy.users_with_permission_for_instance(
            'delete', self.useless_image
        )

        self.assertResultSetEqual(users_with_delete_permission, [
            self.superuser,
            self.oneoff_image_deleter,
        ])

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_permission_policies.py" startline="604" endline="627" pcid="4001">
    def test_users_with_any_permission(self):
        users_with_add_or_change_permission = self.policy.users_with_any_permission(
            ['add', 'change']
        )

        self.assertResultSetEqual(users_with_add_or_change_permission, [
            self.superuser,
            self.image_adder,
            self.oneoff_image_adder,
            self.image_changer,
            self.oneoff_image_changer,
        ])

        users_with_change_or_delete_permission = self.policy.users_with_any_permission(
            ['change', 'delete']
        )

        self.assertResultSetEqual(users_with_change_or_delete_permission, [
            self.superuser,
            self.image_changer,
            self.oneoff_image_changer,
            self.oneoff_image_deleter,
        ])

</source>
</class>

<class classid="170" nclones="5" nlines="15" similarity="71">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_permission_policies.py" startline="346" endline="363" pcid="3991">
    def test_user_has_permission_for_instance(self):
        # Permissions for this policy are applied at the model level,
        # so rules for a specific instance will match rules for the
        # model as a whole
        self.assertUserInstancePermissionMatrix(self.adder_image, [
            (self.superuser, True, True, True),
            (self.inactive_superuser, False, False, False),
            (self.image_adder, True, True, True),
            (self.oneoff_image_adder, True, True, True),
            (self.inactive_image_adder, False, False, False),
            (self.image_changer, True, True, True),
            (self.oneoff_image_changer, True, True, True),
            (self.inactive_image_changer, False, False, False),
            (self.oneoff_image_deleter, True, True, True),
            (self.useless_user, True, True, True),
            (self.anonymous_user, False, False, False),
        ])

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_permission_policies.py" startline="628" endline="645" pcid="4002">
    def test_user_has_permission_for_instance(self):
        # Permissions for this policy are applied at the model level,
        # so rules for a specific instance will match rules for the
        # model as a whole
        self.assertUserInstancePermissionMatrix(self.adder_image, [
            (self.superuser, True, True, True),
            (self.inactive_superuser, False, False, False),
            (self.image_adder, False, False, False),
            (self.oneoff_image_adder, False, False, False),
            (self.inactive_image_adder, False, False, False),
            (self.image_changer, True, False, False),
            (self.oneoff_image_changer, True, False, False),
            (self.inactive_image_changer, False, False, False),
            (self.oneoff_image_deleter, False, True, False),
            (self.useless_user, False, False, False),
            (self.anonymous_user, False, False, False),
        ])

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_collection_permission_policies.py" startline="1090" endline="1109" pcid="4365">
    def test_user_has_permission_for_instance(self):
        # Reports collection is editable - as are its children
        self.assertUserInstancePermissionMatrix(self.reports_collection, [
            (self.superuser, True, True, True),
            (self.inactive_superuser, False, False, False),
            (self.report_changer, True, False, False),
            (self.report_deleter, False, True, False),
            (self.useless_user, False, False, False),
            (self.anonymous_user, False, False, False),
        ])

        self.assertUserInstancePermissionMatrix(self.reports_2020_collection, [
            (self.superuser, True, True, True),
            (self.inactive_superuser, False, False, False),
            (self.report_changer, True, False, False),
            (self.report_deleter, False, True, False),
            (self.useless_user, False, False, False),
            (self.anonymous_user, False, False, False),
        ])

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_collection_permission_policies.py" startline="1079" endline="1089" pcid="4364">
    def test_only_superuser_has_permission_for_root_collection(self):
        self.assertUserInstancePermissionMatrix(self.root_collection, [
            (self.superuser, True, True, True),
            (self.inactive_superuser, False, False, False),
            (self.report_changer, False, False, False),
            (self.report_adder, False, False, False),
            (self.report_deleter, False, False, False),
            (self.useless_user, False, False, False),
            (self.anonymous_user, False, False, False),
        ])

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_collection_permission_policies.py" startline="187" endline="213" pcid="4338">
    def test_user_has_permission_for_instance(self):
        # document in the root is only editable by users with permissions
        # on the root collection
        self.assertUserInstancePermissionMatrix(self.changer_doc, [
            (self.superuser, True, True, True),
            (self.inactive_superuser, False, False, False),
            (self.doc_changer, True, False, False),
            (self.inactive_doc_changer, False, False, False),
            (self.report_changer, False, False, False),
            (self.report_adder, False, False, False),
            (self.useless_user, False, False, False),
            (self.anonymous_user, False, False, False),
        ])

        # document in 'reports' is editable by users with permissions
        # on 'reports' or the root collection
        self.assertUserInstancePermissionMatrix(self.useless_report, [
            (self.superuser, True, True, True),
            (self.inactive_superuser, False, False, False),
            (self.doc_changer, True, False, False),
            (self.inactive_doc_changer, False, False, False),
            (self.report_changer, True, False, False),
            (self.report_adder, False, False, False),
            (self.useless_user, False, False, False),
            (self.anonymous_user, False, False, False),
        ])

</source>
</class>

<class classid="171" nclones="3" nlines="14" similarity="76">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_permission_policies.py" startline="364" endline="392" pcid="3992">
    def test_user_has_any_permission_for_instance(self):
        # superuser has permission
        self.assertTrue(
            self.policy.user_has_any_permission_for_instance(
                self.superuser, ['change', 'delete'], self.adder_image
            )
        )

        # inactive user has no permission
        self.assertFalse(
            self.policy.user_has_any_permission_for_instance(
                self.inactive_superuser, ['change', 'delete'], self.adder_image
            )
        )

        # ordinary user has permission
        self.assertTrue(
            self.policy.user_has_any_permission_for_instance(
                self.useless_user, ['change', 'delete'], self.adder_image
            )
        )

        # anonymous user has no permission
        self.assertFalse(
            self.policy.user_has_any_permission_for_instance(
                self.anonymous_user, ['change', 'delete'], self.adder_image
            )
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_collection_permission_policies.py" startline="622" endline="652" pcid="4352">
    def test_user_has_any_permission_for_instance(self):
        self.assertTrue(
            self.policy.user_has_any_permission_for_instance(
                self.report_changer, ['change', 'delete'], self.useless_report
            )
        )

        self.assertFalse(
            self.policy.user_has_any_permission_for_instance(
                self.report_changer, ['change', 'delete'], self.changer_doc
            )
        )

        self.assertFalse(
            self.policy.user_has_any_permission_for_instance(
                self.report_adder, ['change', 'delete'], self.changer_doc
            )
        )

        self.assertTrue(
            self.policy.user_has_any_permission_for_instance(
                self.report_adder, ['change', 'delete'], self.adder_report
            )
        )

        self.assertFalse(
            self.policy.user_has_any_permission_for_instance(
                self.anonymous_user, ['change', 'delete'], self.changer_doc
            )
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_collection_permission_policies.py" startline="214" endline="232" pcid="4339">
    def test_user_has_any_permission_for_instance(self):
        self.assertTrue(
            self.policy.user_has_any_permission_for_instance(
                self.report_changer, ['change', 'delete'], self.useless_report
            )
        )

        self.assertFalse(
            self.policy.user_has_any_permission_for_instance(
                self.report_changer, ['change', 'delete'], self.changer_doc
            )
        )

        self.assertFalse(
            self.policy.user_has_any_permission_for_instance(
                self.anonymous_user, ['change', 'delete'], self.changer_doc
            )
        )

</source>
</class>

<class classid="172" nclones="2" nlines="20" similarity="80">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_permission_policies.py" startline="393" endline="430" pcid="3993">
    def test_instances_user_has_permission_for(self):
        all_images = [
            self.adder_image, self.useless_image, self.anonymous_image
        ]
        no_images = []

        # the set of images editable by superuser includes all images
        self.assertResultSetEqual(
            self.policy.instances_user_has_permission_for(
                self.superuser, 'change'
            ),
            all_images
        )

        # the set of images editable by inactive superuser includes no images
        self.assertResultSetEqual(
            self.policy.instances_user_has_permission_for(
                self.inactive_superuser, 'change'
            ),
            no_images
        )

        # the set of images editable by ordinary user includes all images
        self.assertResultSetEqual(
            self.policy.instances_user_has_permission_for(
                self.useless_user, 'change'
            ),
            all_images
        )

        # the set of images editable by anonymous user includes no images
        self.assertResultSetEqual(
            self.policy.instances_user_has_permission_for(
                self.anonymous_user, 'change'
            ),
            no_images
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_permission_policies.py" startline="431" endline="468" pcid="3994">
    def test_instances_user_has_any_permission_for(self):
        all_images = [
            self.adder_image, self.useless_image, self.anonymous_image
        ]
        no_images = []

        # the set of images editable by superuser includes all images
        self.assertResultSetEqual(
            self.policy.instances_user_has_any_permission_for(
                self.superuser, ['change', 'delete']
            ),
            all_images
        )

        # the set of images editable by inactive superuser includes no images
        self.assertResultSetEqual(
            self.policy.instances_user_has_any_permission_for(
                self.inactive_superuser, ['change', 'delete']
            ),
            no_images
        )

        # the set of images editable by ordinary user includes all images
        self.assertResultSetEqual(
            self.policy.instances_user_has_any_permission_for(
                self.useless_user, ['change', 'delete']
            ),
            all_images
        )

        # the set of images editable by anonymous user includes no images
        self.assertResultSetEqual(
            self.policy.instances_user_has_any_permission_for(
                self.anonymous_user, ['change', 'delete']
            ),
            no_images
        )

</source>
</class>

<class classid="173" nclones="4" nlines="15" similarity="76">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_permission_policies.py" startline="543" endline="586" pcid="3999">
    def test_user_has_any_permission(self):
        # Superuser can do everything
        self.assertTrue(
            self.policy.user_has_any_permission(self.superuser, ['add', 'change'])
        )

        # Inactive superuser can do nothing
        self.assertFalse(
            self.policy.user_has_any_permission(self.inactive_superuser, ['add', 'change'])
        )

        # Only one of the permissions in the list needs to pass
        # in order for user_has_any_permission to return true
        self.assertTrue(
            self.policy.user_has_any_permission(self.image_adder, ['add', 'change'])
        )
        self.assertTrue(
            self.policy.user_has_any_permission(self.oneoff_image_adder, ['add', 'change'])
        )
        self.assertTrue(
            self.policy.user_has_any_permission(self.image_changer, ['add', 'change'])
        )

        # User with some permission, but not the ones in the list,
        # should return false
        self.assertFalse(
            self.policy.user_has_any_permission(self.image_changer, ['add', 'delete'])
        )

        # Inactive user with the appropriate permissions can do nothing
        self.assertFalse(
            self.policy.user_has_any_permission(self.inactive_image_adder, ['add', 'delete'])
        )

        # User with no permissions can do nothing
        self.assertFalse(
            self.policy.user_has_any_permission(self.useless_user, ['add', 'change'])
        )

        # Anonymous user can do nothing
        self.assertFalse(
            self.policy.user_has_any_permission(self.anonymous_user, ['add', 'change'])
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_permission_policies.py" startline="919" endline="959" pcid="4010">
    def test_user_has_any_permission(self):
        # Superuser can do everything
        self.assertTrue(
            self.policy.user_has_any_permission(self.superuser, ['add', 'change'])
        )

        # Inactive superuser can do nothing
        self.assertFalse(
            self.policy.user_has_any_permission(self.inactive_superuser, ['add', 'change'])
        )

        # Only one of the permissions in the list needs to pass
        # in order for user_has_any_permission to return true
        self.assertTrue(
            self.policy.user_has_any_permission(self.image_changer, ['add', 'change'])
        )
        self.assertTrue(
            self.policy.user_has_any_permission(self.oneoff_image_changer, ['add', 'change'])
        )

        # User with some permission, but not the ones in the list,
        # should return false
        self.assertFalse(
            self.policy.user_has_any_permission(self.oneoff_image_deleter, ['add', 'change'])
        )

        # Inactive user with the appropriate permissions can do nothing
        self.assertFalse(
            self.policy.user_has_any_permission(self.inactive_image_changer, ['add', 'delete'])
        )

        # User with no permissions can do nothing
        self.assertFalse(
            self.policy.user_has_any_permission(self.useless_user, ['add', 'change'])
        )

        # Anonymous user can do nothing
        self.assertFalse(
            self.policy.user_has_any_permission(self.anonymous_user, ['add', 'change'])
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_collection_permission_policies.py" startline="535" endline="554" pcid="4348">
    def test_user_has_any_permission(self):
        self.assertTrue(
            self.policy.user_has_any_permission(self.superuser, ['add', 'change'])
        )
        self.assertFalse(
            self.policy.user_has_any_permission(self.inactive_superuser, ['add', 'change'])
        )
        self.assertTrue(
            self.policy.user_has_any_permission(self.report_changer, ['add', 'delete'])
        )
        self.assertTrue(
            self.policy.user_has_any_permission(self.report_adder, ['add', 'change'])
        )
        self.assertTrue(
            self.policy.user_has_any_permission(self.report_adder, ['change', 'delete'])
        )
        self.assertFalse(
            self.policy.user_has_any_permission(self.anonymous_user, ['add', 'change'])
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_collection_permission_policies.py" startline="143" endline="159" pcid="4335">
    def test_user_has_any_permission(self):
        self.assertTrue(
            self.policy.user_has_any_permission(self.superuser, ['add', 'change'])
        )
        self.assertFalse(
            self.policy.user_has_any_permission(self.inactive_superuser, ['add', 'change'])
        )
        self.assertTrue(
            self.policy.user_has_any_permission(self.report_changer, ['add', 'change'])
        )
        self.assertTrue(
            self.policy.user_has_any_permission(self.report_adder, ['add', 'change'])
        )
        self.assertFalse(
            self.policy.user_has_any_permission(self.anonymous_user, ['add', 'change'])
        )

</source>
</class>

<class classid="174" nclones="2" nlines="25" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_permission_policies.py" startline="646" endline="702" pcid="4003">
    def test_user_has_any_permission_for_instance(self):
        # Superuser can do everything
        self.assertTrue(
            self.policy.user_has_any_permission_for_instance(
                self.superuser, ['change', 'delete'], self.adder_image
            )
        )

        # Inactive superuser can do nothing
        self.assertFalse(
            self.policy.user_has_any_permission_for_instance(
                self.inactive_superuser, ['change', 'delete'], self.adder_image
            )
        )

        # Only one of the permissions in the list needs to pass
        # in order for user_has_any_permission to return true
        self.assertTrue(
            self.policy.user_has_any_permission_for_instance(
                self.image_changer, ['change', 'delete'], self.adder_image
            )
        )
        self.assertTrue(
            self.policy.user_has_any_permission_for_instance(
                self.oneoff_image_changer, ['change', 'delete'], self.adder_image
            )
        )

        # User with some permission, but not the ones in the list,
        # should return false
        self.assertFalse(
            self.policy.user_has_any_permission_for_instance(
                self.image_adder, ['change', 'delete'], self.adder_image
            )
        )

        # Inactive user with the appropriate permissions can do nothing
        self.assertFalse(
            self.policy.user_has_any_permission_for_instance(
                self.inactive_image_changer, ['change', 'delete'], self.adder_image
            )
        )

        # User with no permissions can do nothing
        self.assertFalse(
            self.policy.user_has_any_permission_for_instance(
                self.useless_user, ['change', 'delete'], self.adder_image
            )
        )

        # Anonymous user can do nothing
        self.assertFalse(
            self.policy.user_has_any_permission_for_instance(
                self.anonymous_user, ['change', 'delete'], self.adder_image
            )
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_permission_policies.py" startline="1105" endline="1161" pcid="4014">
    def test_user_has_any_permission_for_instance(self):
        # Superuser can do everything
        self.assertTrue(
            self.policy.user_has_any_permission_for_instance(
                self.superuser, ['change', 'delete'], self.adder_image
            )
        )

        # Inactive superuser can do nothing
        self.assertFalse(
            self.policy.user_has_any_permission_for_instance(
                self.inactive_superuser, ['change', 'delete'], self.adder_image
            )
        )

        # Only one of the permissions in the list needs to pass
        # in order for user_has_any_permission to return true
        self.assertTrue(
            self.policy.user_has_any_permission_for_instance(
                self.image_changer, ['change', 'frobnicate'], self.adder_image
            )
        )
        self.assertTrue(
            self.policy.user_has_any_permission_for_instance(
                self.oneoff_image_changer, ['change', 'frobnicate'], self.adder_image
            )
        )

        # User with some permission, but not the ones in the list,
        # should return false
        self.assertFalse(
            self.policy.user_has_any_permission_for_instance(
                self.oneoff_image_deleter, ['change', 'delete'], self.adder_image
            )
        )

        # Inactive user with the appropriate permissions can do nothing
        self.assertFalse(
            self.policy.user_has_any_permission_for_instance(
                self.inactive_image_changer, ['change', 'delete'], self.adder_image
            )
        )

        # User with no permissions can do nothing
        self.assertFalse(
            self.policy.user_has_any_permission_for_instance(
                self.useless_user, ['change', 'delete'], self.adder_image
            )
        )

        # Anonymous user can do nothing
        self.assertFalse(
            self.policy.user_has_any_permission_for_instance(
                self.anonymous_user, ['change', 'delete'], self.adder_image
            )
        )

</source>
</class>

<class classid="175" nclones="4" nlines="36" similarity="75">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_permission_policies.py" startline="703" endline="772" pcid="4004">
    def test_instances_user_has_permission_for(self):
        all_images = [
            self.adder_image, self.useless_image, self.anonymous_image
        ]
        no_images = []

        # the set of images editable by superuser includes all images
        self.assertResultSetEqual(
            self.policy.instances_user_has_permission_for(
                self.superuser, 'change'
            ),
            all_images
        )

        # the set of images editable by inactive superuser includes no images
        self.assertResultSetEqual(
            self.policy.instances_user_has_permission_for(
                self.inactive_superuser, 'change'
            ),
            no_images
        )

        # given the relevant model permission at the group level, a user can edit all images
        self.assertResultSetEqual(
            self.policy.instances_user_has_permission_for(
                self.image_changer, 'change'
            ),
            all_images
        )

        # given the relevant model permission at the user level, a user can edit all images
        self.assertResultSetEqual(
            self.policy.instances_user_has_permission_for(
                self.oneoff_image_changer, 'change'
            ),
            all_images
        )

        # a user with no permission can edit no images
        self.assertResultSetEqual(
            self.policy.instances_user_has_permission_for(
                self.useless_user, 'change'
            ),
            no_images
        )

        # an inactive user with the relevant permission can edit no images
        self.assertResultSetEqual(
            self.policy.instances_user_has_permission_for(
                self.inactive_image_changer, 'change'
            ),
            no_images
        )

        # a user with permission, but not the matching one, can edit no images
        self.assertResultSetEqual(
            self.policy.instances_user_has_permission_for(
                self.image_changer, 'delete'
            ),
            no_images
        )

        # the set of images editable by anonymous user includes no images
        self.assertResultSetEqual(
            self.policy.instances_user_has_permission_for(
                self.anonymous_user, 'change'
            ),
            no_images
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_permission_policies.py" startline="1239" endline="1308" pcid="4016">
    def test_instances_user_has_any_permission_for(self):
        all_images = [
            self.adder_image, self.useless_image, self.anonymous_image
        ]
        no_images = []

        # the set of images editable by superuser includes all images
        self.assertResultSetEqual(
            self.policy.instances_user_has_any_permission_for(
                self.superuser, ['change', 'delete']
            ),
            all_images
        )

        # the set of images editable by inactive superuser includes no images
        self.assertResultSetEqual(
            self.policy.instances_user_has_any_permission_for(
                self.inactive_superuser, ['change', 'delete']
            ),
            no_images
        )

        # a user with 'add' permission can change/delete their own images
        self.assertResultSetEqual(
            self.policy.instances_user_has_any_permission_for(
                self.image_adder, ['delete', 'frobnicate']
            ),
            [self.adder_image]
        )

        # a user with 'edit' permission can change/delete all images
        self.assertResultSetEqual(
            self.policy.instances_user_has_any_permission_for(
                self.oneoff_image_changer, ['delete', 'frobnicate']
            ),
            all_images
        )

        # a user with no permission can edit no images
        self.assertResultSetEqual(
            self.policy.instances_user_has_any_permission_for(
                self.useless_user, ['change', 'delete']
            ),
            no_images
        )

        # an inactive user with the relevant permission can edit no images
        self.assertResultSetEqual(
            self.policy.instances_user_has_any_permission_for(
                self.inactive_image_changer, ['change', 'delete']
            ),
            no_images
        )

        # a user with permission, but not the matching one, can edit no images
        self.assertResultSetEqual(
            self.policy.instances_user_has_any_permission_for(
                self.oneoff_image_deleter, ['change', 'delete']
            ),
            no_images
        )

        # the set of images editable by anonymous user includes no images
        self.assertResultSetEqual(
            self.policy.instances_user_has_any_permission_for(
                self.anonymous_user, ['change', 'delete']
            ),
            no_images
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_permission_policies.py" startline="1162" endline="1238" pcid="4015">
    def test_instances_user_has_permission_for(self):
        all_images = [
            self.adder_image, self.useless_image, self.anonymous_image
        ]
        no_images = []

        # the set of images editable by superuser includes all images
        self.assertResultSetEqual(
            self.policy.instances_user_has_permission_for(
                self.superuser, 'change'
            ),
            all_images
        )

        # the set of images editable by inactive superuser includes no images
        self.assertResultSetEqual(
            self.policy.instances_user_has_permission_for(
                self.inactive_superuser, 'change'
            ),
            no_images
        )

        # a user with 'add' permission can change their own images
        self.assertResultSetEqual(
            self.policy.instances_user_has_permission_for(
                self.image_adder, 'change'
            ),
            [self.adder_image]
        )
        # a user with 'add' permission can also delete their own images
        self.assertResultSetEqual(
            self.policy.instances_user_has_permission_for(
                self.image_adder, 'delete'
            ),
            [self.adder_image]
        )

        # a user with 'change' permission can change all images
        self.assertResultSetEqual(
            self.policy.instances_user_has_permission_for(
                self.image_changer, 'change'
            ),
            all_images
        )

        # ditto for 'change' permission assigned at the user level
        self.assertResultSetEqual(
            self.policy.instances_user_has_permission_for(
                self.oneoff_image_changer, 'change'
            ),
            all_images
        )

        # an inactive user with the relevant permission can edit no images
        self.assertResultSetEqual(
            self.policy.instances_user_has_permission_for(
                self.inactive_image_changer, 'change'
            ),
            no_images
        )

        # a user with no permission can edit no images
        self.assertResultSetEqual(
            self.policy.instances_user_has_permission_for(
                self.useless_user, 'change'
            ),
            no_images
        )

        # the set of images editable by anonymous user includes no images
        self.assertResultSetEqual(
            self.policy.instances_user_has_permission_for(
                self.anonymous_user, 'change'
            ),
            no_images
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_permission_policies.py" startline="773" endline="842" pcid="4005">
    def test_instances_user_has_any_permission_for(self):
        all_images = [
            self.adder_image, self.useless_image, self.anonymous_image
        ]
        no_images = []

        # the set of images editable by superuser includes all images
        self.assertResultSetEqual(
            self.policy.instances_user_has_any_permission_for(
                self.superuser, ['change', 'delete']
            ),
            all_images
        )

        # the set of images editable by inactive superuser includes no images
        self.assertResultSetEqual(
            self.policy.instances_user_has_any_permission_for(
                self.inactive_superuser, ['change', 'delete']
            ),
            no_images
        )

        # given the relevant model permission at the group level, a user can edit all images
        self.assertResultSetEqual(
            self.policy.instances_user_has_any_permission_for(
                self.image_changer, ['change', 'delete']
            ),
            all_images
        )

        # given the relevant model permission at the user level, a user can edit all images
        self.assertResultSetEqual(
            self.policy.instances_user_has_any_permission_for(
                self.oneoff_image_changer, ['change', 'delete']
            ),
            all_images
        )

        # a user with no permission can edit no images
        self.assertResultSetEqual(
            self.policy.instances_user_has_any_permission_for(
                self.useless_user, ['change', 'delete']
            ),
            no_images
        )

        # an inactive user with the relevant permission can edit no images
        self.assertResultSetEqual(
            self.policy.instances_user_has_any_permission_for(
                self.inactive_image_changer, ['change', 'delete']
            ),
            no_images
        )

        # a user with permission, but not the matching one, can edit no images
        self.assertResultSetEqual(
            self.policy.instances_user_has_any_permission_for(
                self.image_adder, ['change', 'delete']
            ),
            no_images
        )

        # the set of images editable by anonymous user includes no images
        self.assertResultSetEqual(
            self.policy.instances_user_has_any_permission_for(
                self.anonymous_user, ['change', 'delete']
            ),
            no_images
        )

</source>
</class>

<class classid="176" nclones="2" nlines="36" similarity="77">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_permission_policies.py" startline="1022" endline="1104" pcid="4013">
    def test_user_has_permission_for_instance(self):
        # Test permissions for an image owned by image_adder
        self.assertUserInstancePermissionMatrix(self.adder_image, [
            # superuser can do everything
            (self.superuser, True, True, True),

            # inactive superuser can do nothing
            (self.inactive_superuser, False, False, False),

            # image_adder can change and delete their own images,
            # but not perform custom actions
            (self.image_adder, True, True, False),

            # user with add permission cannot edit images owned by others
            (self.oneoff_image_adder, False, False, False),

            # inactive user with 'add' permission can do nothing
            (self.inactive_image_adder, False, False, False),

            # user with change permission can change and delete all images
            (self.image_changer, True, True, False),

            # likewise for change permission specified at the user level
            (self.oneoff_image_changer, True, True, False),

            # inactive user with 'change' permission can do nothing
            (self.inactive_image_changer, False, False, False),

            # delete permissions are ignored
            (self.oneoff_image_deleter, False, False, False),

            # user with no permissions can do nothing
            (self.useless_user, False, False, False),

            # anonymous user can do nothing
            (self.anonymous_user, False, False, False),
        ])

        # Test permissions for an image owned by useless_user
        self.assertUserInstancePermissionMatrix(self.useless_image, [
            # superuser can do everything
            (self.superuser, True, True, True),

            # image_adder cannot edit images owned by others
            (self.image_adder, False, False, False),
            (self.oneoff_image_adder, False, False, False),

            # user with change permission can change and delete all images
            (self.image_changer, True, True, False),
            (self.oneoff_image_changer, True, True, False),

            # inactive users can do nothing
            (self.inactive_superuser, False, False, False),
            (self.inactive_image_adder, False, False, False),
            (self.inactive_image_changer, False, False, False),

            # delete permissions are ignored
            (self.oneoff_image_deleter, False, False, False),

            # user with no permissions can do nothing, even on images
            # they own
            (self.useless_user, False, False, False),

            # anonymous user can do nothing
            (self.anonymous_user, False, False, False),
        ])

        # Instances with a null owner should always follow the same rules
        # as 'an instance owned by someone else'
        self.assertUserInstancePermissionMatrix(self.anonymous_image, [
            (self.superuser, True, True, True),
            (self.image_adder, False, False, False),
            (self.oneoff_image_adder, False, False, False),
            (self.image_changer, True, True, False),
            (self.oneoff_image_changer, True, True, False),
            (self.inactive_superuser, False, False, False),
            (self.inactive_image_adder, False, False, False),
            (self.inactive_image_changer, False, False, False),
            (self.oneoff_image_deleter, False, False, False),
            (self.useless_user, False, False, False),
            (self.anonymous_user, False, False, False),
        ])

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_collection_permission_policies.py" startline="583" endline="621" pcid="4351">
    def test_user_has_permission_for_instance(self):
        # document in the root is only editable by users with permissions
        # on the root collection
        self.assertUserInstancePermissionMatrix(self.changer_doc, [
            (self.superuser, True, True, True),
            (self.inactive_superuser, False, False, False),
            (self.doc_changer, True, True, False),
            (self.inactive_doc_changer, False, False, False),
            (self.report_changer, False, False, False),
            (self.report_adder, False, False, False),
            (self.useless_user, False, False, False),
            (self.anonymous_user, False, False, False),
        ])

        # document in 'reports' is editable by users with permissions
        # on 'reports' or the root collection
        self.assertUserInstancePermissionMatrix(self.useless_report, [
            (self.superuser, True, True, True),
            (self.inactive_superuser, False, False, False),
            (self.doc_changer, True, True, False),
            (self.inactive_doc_changer, False, False, False),
            (self.report_changer, True, True, False),
            (self.report_adder, False, False, False),
            (self.useless_user, False, False, False),
            (self.anonymous_user, False, False, False),
        ])

        # adder_report is editable by its owner (who only has 'add' permission)
        self.assertUserInstancePermissionMatrix(self.adder_report, [
            (self.superuser, True, True, True),
            (self.inactive_superuser, False, False, False),
            (self.doc_changer, True, True, False),
            (self.inactive_doc_changer, False, False, False),
            (self.report_changer, True, True, False),
            (self.report_adder, True, True, False),
            (self.useless_user, False, False, False),
            (self.anonymous_user, False, False, False),
        ])

</source>
</class>

<class classid="177" nclones="2" nlines="17" similarity="94">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_workflow.py" startline="196" endline="213" pcid="4080">
    def test_workflow_resets_when_new_revision_created(self):
        # test that a Workflow on its second Task returns to its first task (upon WorkflowState.update()) if a new revision is created
        data = self.start_workflow_on_homepage()
        workflow_state = data['workflow_state']
        task_1 = data['task_1']
        task_2 = data['task_2']
        page = data['page']
        task_state = workflow_state.current_task_state
        task_state.task.on_action(task_state, user=None, action_name='approve')
        self.assertEqual(workflow_state.current_task_state.task, task_2)
        page.save_revision()
        workflow_state.refresh_from_db()
        task_state = workflow_state.current_task_state
        task_state.task.on_action(task_state, user=None, action_name='approve')
        workflow_state.refresh_from_db()
        task_state = workflow_state.current_task_state
        self.assertEqual(task_state.task, task_1)

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_workflow.py" startline="215" endline="233" pcid="4081">
    def test_workflow_does_not_reset_when_new_revision_created_if_reapproval_turned_off(self):
        # test that a Workflow on its second Task does not return to its first task (upon approval) if a new revision is created
        data = self.start_workflow_on_homepage()
        workflow_state = data['workflow_state']
        task_1 = data['task_1']
        task_2 = data['task_2']
        page = data['page']
        task_state = workflow_state.current_task_state
        task_state.task.on_action(task_state, user=None, action_name='approve')
        self.assertEqual(workflow_state.current_task_state.task, task_2)
        page.save_revision()
        workflow_state.refresh_from_db()
        task_state = workflow_state.current_task_state
        task_state.task.on_action(task_state, user=None, action_name='approve')
        workflow_state.refresh_from_db()
        task_state = workflow_state.current_task_state
        self.assertNotEqual(task_state.task, task_1)
        self.assertEqual(workflow_state.status, workflow_state.STATUS_APPROVED)

</source>
</class>

<class classid="178" nclones="2" nlines="11" similarity="81">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_signals.py" startline="61" endline="81" pcid="4091">
    def test_signal_not_emitted_on_title_change(self):
        # Connect a mock signal handler to the signal
        handler = mock.MagicMock()
        page_slug_changed.connect(handler)

        try:
            self.test_page.title = 'Goodnight Moon!'
            self.test_page.save()
            # NOTE: Even though we're not expecting anything to happen here,
            # we need to invoke the callbacks in run_on_commit the same way
            # the same way we do in ``test_signal_emitted_on_slug_change``,
            # otherwise this test wouldn't prove anything.
            for _, func in connection.run_on_commit:
                func()
        finally:
            # Disconnect mock handler to prevent cross-test pollution
            page_slug_changed.disconnect(handler)

        # Check the signal was NOT fired
        self.assertEqual(handler.call_count, 0)

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_signals.py" startline="82" endline="100" pcid="4092">
    def test_signal_not_emitted_on_page_move(self):
        # Connect a mock signal handler to the signal
        handler = mock.MagicMock()
        page_slug_changed.connect(handler)

        try:
            self.test_page.move(self.section_b, pos="last-child")
            # NOTE: Even though we're not expecting anything to happen here,
            # we need to invoke the callbacks in run_on_commit the same way
            # the same way we do in ``test_signal_emitted_on_slug_change``,
            # otherwise this test wouldn't prove anything.
            for _, func in connection.run_on_commit:
                func()
        finally:
            # Disconnect mock handler to prevent cross-test pollution
            page_slug_changed.disconnect(handler)

        # Check the signal was NOT fired
        self.assertEqual(handler.call_count, 0)
</source>
</class>

<class classid="179" nclones="2" nlines="10" similarity="90">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_model.py" startline="66" endline="80" pcid="4124">
    def test_slug_is_autogenerated(self):
        homepage = Page.objects.get(url_path='/home/')

        # slug should be auto-assigned to a slugified version of the title
        hello_page = SimplePage(title="Hello world", content="hello")
        homepage.add_child(instance=hello_page)
        retrieved_page = Page.objects.get(id=hello_page.id)
        self.assertEqual(retrieved_page.slug, 'hello-world')

        # auto-generated slug should receive a suffix to make it unique
        events_page = SimplePage(title="Events", content="hello")
        homepage.add_child(instance=events_page)
        retrieved_page = Page.objects.get(id=events_page.id)
        self.assertEqual(retrieved_page.slug, 'events-2')

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_model.py" startline="123" endline="136" pcid="4131">
    def test_draft_title_is_autopopulated(self):
        homepage = Page.objects.get(url_path='/home/')

        hello_page = SimplePage(title="Hello world", content="hello")
        homepage.add_child(instance=hello_page)
        retrieved_page = Page.objects.get(id=hello_page.id)
        self.assertEqual(retrieved_page.draft_title, "Hello world")

        hello_page = SimplePage(title="Hello world", draft_title="Hello world edited", content="hello")
        homepage.add_child(instance=hello_page)
        retrieved_page = Page.objects.get(id=hello_page.id)
        self.assertEqual(retrieved_page.draft_title, "Hello world edited")


</source>
</class>

<class classid="180" nclones="4" nlines="19" similarity="77">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_model.py" startline="246" endline="269" pcid="4143">
    def test_urls(self):
        default_site = Site.objects.get(is_default_site=True)
        homepage = Page.objects.get(url_path='/home/')
        christmas_page = Page.objects.get(url_path='/home/events/christmas/')

        # Basic installation only has one site configured, so page.url will return local URLs
        self.assertEqual(
            homepage.get_url_parts(),
            (default_site.id, 'http://localhost', '/')
        )
        self.assertEqual(homepage.full_url, 'http://localhost/')
        self.assertEqual(homepage.url, '/')
        self.assertEqual(homepage.relative_url(default_site), '/')
        self.assertEqual(homepage.get_site(), default_site)

        self.assertEqual(
            christmas_page.get_url_parts(),
            (default_site.id, 'http://localhost', '/events/christmas/')
        )
        self.assertEqual(christmas_page.full_url, 'http://localhost/events/christmas/')
        self.assertEqual(christmas_page.url, '/events/christmas/')
        self.assertEqual(christmas_page.relative_url(default_site), '/events/christmas/')
        self.assertEqual(christmas_page.get_site(), default_site)

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_model.py" startline="509" endline="538" pcid="4158">
    def test_urls_with_different_language_tree(self):
        default_site = Site.objects.get(is_default_site=True)
        homepage = Page.objects.get(url_path='/home/')
        christmas_page = Page.objects.get(url_path='/home/events/christmas/')

        fr_locale = Locale.objects.create(language_code="fr")
        fr_homepage = homepage.copy_for_translation(fr_locale)
        fr_christmas_page = christmas_page.copy_for_translation(fr_locale, copy_parents=True)
        fr_christmas_page.slug = 'noel'
        fr_christmas_page.save(update_fields=['slug'])

        # Basic installation only has one site configured, so page.url will return local URLs
        self.assertEqual(
            fr_homepage.get_url_parts(),
            (default_site.id, 'http://localhost', '/fr/')
        )
        self.assertEqual(fr_homepage.full_url, 'http://localhost/fr/')
        self.assertEqual(fr_homepage.url, '/fr/')
        self.assertEqual(fr_homepage.relative_url(default_site), '/fr/')
        self.assertEqual(fr_homepage.get_site(), default_site)

        self.assertEqual(
            fr_christmas_page.get_url_parts(),
            (default_site.id, 'http://localhost', '/fr/events/noel/')
        )
        self.assertEqual(fr_christmas_page.full_url, 'http://localhost/fr/events/noel/')
        self.assertEqual(fr_christmas_page.url, '/fr/events/noel/')
        self.assertEqual(fr_christmas_page.relative_url(default_site), '/fr/events/noel/')
        self.assertEqual(fr_christmas_page.get_site(), default_site)

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_model.py" startline="452" endline="475" pcid="4153">
    def test_urls(self, expected_language_code='en'):
        default_site = Site.objects.get(is_default_site=True)
        homepage = Page.objects.get(url_path='/home/')
        christmas_page = Page.objects.get(url_path='/home/events/christmas/')

        # Basic installation only has one site configured, so page.url will return local URLs
        # self.assertEqual(
        #     homepage.get_url_parts(),
        #     (default_site.id, 'http://localhost', f'/{expected_language_code}/')
        # )
        self.assertEqual(homepage.full_url, f'http://localhost/{expected_language_code}/')
        self.assertEqual(homepage.url, f'/{expected_language_code}/')
        self.assertEqual(homepage.relative_url(default_site), f'/{expected_language_code}/')
        self.assertEqual(homepage.get_site(), default_site)

        self.assertEqual(
            christmas_page.get_url_parts(),
            (default_site.id, 'http://localhost', f'/{expected_language_code}/events/christmas/')
        )
        self.assertEqual(christmas_page.full_url, f'http://localhost/{expected_language_code}/events/christmas/')
        self.assertEqual(christmas_page.url, f'/{expected_language_code}/events/christmas/')
        self.assertEqual(christmas_page.relative_url(default_site), f'/{expected_language_code}/events/christmas/')
        self.assertEqual(christmas_page.get_site(), default_site)

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_model.py" startline="334" endline="357" pcid="4146">
    def test_urls_with_non_root_urlconf(self):
        default_site = Site.objects.get(is_default_site=True)
        homepage = Page.objects.get(url_path='/home/')
        christmas_page = Page.objects.get(url_path='/home/events/christmas/')

        # Basic installation only has one site configured, so page.url will return local URLs
        self.assertEqual(
            homepage.get_url_parts(),
            (default_site.id, 'http://localhost', '/site/')
        )
        self.assertEqual(homepage.full_url, 'http://localhost/site/')
        self.assertEqual(homepage.url, '/site/')
        self.assertEqual(homepage.relative_url(default_site), '/site/')
        self.assertEqual(homepage.get_site(), default_site)

        self.assertEqual(
            christmas_page.get_url_parts(),
            (default_site.id, 'http://localhost', '/site/events/christmas/')
        )
        self.assertEqual(christmas_page.full_url, 'http://localhost/site/events/christmas/')
        self.assertEqual(christmas_page.url, '/site/events/christmas/')
        self.assertEqual(christmas_page.relative_url(default_site), '/site/events/christmas/')
        self.assertEqual(christmas_page.get_site(), default_site)

</source>
</class>

<class classid="181" nclones="2" nlines="36" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_model.py" startline="281" endline="332" pcid="4145">
    def test_urls_with_multiple_sites(self):
        events_page = Page.objects.get(url_path='/home/events/')
        events_site = Site.objects.create(hostname='events.example.com', root_page=events_page)

        # An underscore is not valid according to RFC 1034/1035
        # and will raise a DisallowedHost Exception
        second_events_site = Site.objects.create(
            hostname='second-events.example.com', root_page=events_page)

        default_site = Site.objects.get(is_default_site=True)
        homepage = Page.objects.get(url_path='/home/')
        christmas_page = Page.objects.get(url_path='/home/events/christmas/')

        # with multiple sites, page.url will return full URLs to ensure that
        # they work across sites
        self.assertEqual(
            homepage.get_url_parts(),
            (default_site.id, 'http://localhost', '/')
        )
        self.assertEqual(homepage.full_url, 'http://localhost/')
        self.assertEqual(homepage.url, 'http://localhost/')
        self.assertEqual(homepage.relative_url(default_site), '/')
        self.assertEqual(homepage.relative_url(events_site), 'http://localhost/')
        self.assertEqual(homepage.get_site(), default_site)

        self.assertEqual(
            christmas_page.get_url_parts(),
            (events_site.id, 'http://events.example.com', '/christmas/')
        )
        self.assertEqual(christmas_page.full_url, 'http://events.example.com/christmas/')
        self.assertEqual(christmas_page.url, 'http://events.example.com/christmas/')
        self.assertEqual(christmas_page.relative_url(default_site), 'http://events.example.com/christmas/')
        self.assertEqual(christmas_page.relative_url(events_site), '/christmas/')
        self.assertEqual(christmas_page.get_site(), events_site)

        request = HttpRequest()
        request.META['HTTP_HOST'] = events_site.hostname
        request.META['SERVER_PORT'] = events_site.port

        self.assertEqual(
            christmas_page.get_url_parts(request=request),
            (events_site.id, 'http://events.example.com', '/christmas/')
        )

        request2 = HttpRequest()
        request2.META['HTTP_HOST'] = second_events_site.hostname
        request2.META['SERVER_PORT'] = second_events_site.port
        self.assertEqual(
            christmas_page.get_url_parts(request=request2),
            (second_events_site.id, 'http://second-events.example.com', '/christmas/')
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_model.py" startline="540" endline="593" pcid="4159">
    def test_urls_with_multiple_sites(self):
        events_page = Page.objects.get(url_path='/home/events/')
        events_site = Site.objects.create(hostname='events.example.com', root_page=events_page)

        # An underscore is not valid according to RFC 1034/1035
        # and will raise a DisallowedHost Exception
        second_events_site = Site.objects.create(
            hostname='second-events.example.com', root_page=events_page)

        default_site = Site.objects.get(is_default_site=True)
        homepage = Page.objects.get(url_path='/home/')
        christmas_page = Page.objects.get(url_path='/home/events/christmas/')

        # with multiple sites, page.url will return full URLs to ensure that
        # they work across sites
        self.assertEqual(
            homepage.get_url_parts(),
            (default_site.id, 'http://localhost', '/en/')
        )
        self.assertEqual(homepage.full_url, 'http://localhost/en/')
        self.assertEqual(homepage.url, 'http://localhost/en/')
        self.assertEqual(homepage.relative_url(default_site), '/en/')
        self.assertEqual(homepage.relative_url(events_site), 'http://localhost/en/')
        self.assertEqual(homepage.get_site(), default_site)

        self.assertEqual(
            christmas_page.get_url_parts(),
            (events_site.id, 'http://events.example.com', '/en/christmas/')
        )
        self.assertEqual(christmas_page.full_url, 'http://events.example.com/en/christmas/')
        self.assertEqual(christmas_page.url, 'http://events.example.com/en/christmas/')
        self.assertEqual(christmas_page.relative_url(default_site), 'http://events.example.com/en/christmas/')
        self.assertEqual(christmas_page.relative_url(events_site), '/en/christmas/')
        self.assertEqual(christmas_page.get_site(), events_site)

        request = HttpRequest()
        request.META['HTTP_HOST'] = events_site.hostname
        request.META['SERVER_PORT'] = events_site.port

        self.assertEqual(
            christmas_page.get_url_parts(request=request),
            (events_site.id, 'http://events.example.com', '/en/christmas/')
        )

        request2 = HttpRequest()
        request2.META['HTTP_HOST'] = second_events_site.hostname
        request2.META['SERVER_PORT'] = second_events_site.port
        self.assertEqual(
            christmas_page.get_url_parts(request=request2),
            (second_events_site.id, 'http://second-events.example.com', '/en/christmas/')
        )

    # Override CACHES so we don't generate any cache-related SQL queries (tests use DatabaseCache
    # otherwise) and so cache.get will always return None.
</source>
</class>

<class classid="182" nclones="2" nlines="18" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_model.py" startline="414" endline="442" pcid="4152">
    def test_request_scope_site_root_paths_cache(self):
        homepage = Page.objects.get(url_path='/home/')
        christmas_page = EventPage.objects.get(url_path='/home/events/christmas/')

        # without a request, get_url should only issue 1 SQL query
        with self.assertNumQueries(1):
            self.assertEqual(homepage.get_url(), '/')
        # subsequent calls with the same page should generate no SQL queries
        with self.assertNumQueries(0):
            self.assertEqual(homepage.get_url(), '/')
        # subsequent calls with a different page will still generate 1 SQL query
        with self.assertNumQueries(1):
            self.assertEqual(christmas_page.get_url(), '/events/christmas/')

        # with a request, the first call to get_url should issue 1 SQL query
        request = HttpRequest()
        request.META['HTTP_HOST'] = "dummy"
        request.META['SERVER_PORT'] = "8888"
        # first call with "balnk" request issues a extra query for the Site.find_for_request() call
        with self.assertNumQueries(2):
            self.assertEqual(homepage.get_url(request=request), '/')
        # subsequent calls should issue no SQL queries
        with self.assertNumQueries(0):
            self.assertEqual(homepage.get_url(request=request), '/')
        # even if called on a different page
        with self.assertNumQueries(0):
            self.assertEqual(christmas_page.get_url(request=request), '/events/christmas/')


</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_model.py" startline="596" endline="624" pcid="4160">
    def test_request_scope_site_root_paths_cache(self):
        homepage = Page.objects.get(url_path='/home/')
        christmas_page = EventPage.objects.get(url_path='/home/events/christmas/')

        # without a request, get_url should only issue 2 SQL queries
        with self.assertNumQueries(2):
            self.assertEqual(homepage.get_url(), '/en/')
        # subsequent calls with the same page should generate no SQL queries
        with self.assertNumQueries(0):
            self.assertEqual(homepage.get_url(), '/en/')
        # subsequent calls with a different page will still generate 2 SQL queries
        with self.assertNumQueries(2):
            self.assertEqual(christmas_page.get_url(), '/en/events/christmas/')

        # with a request, the first call to get_url should issue 1 SQL query
        request = HttpRequest()
        request.META['HTTP_HOST'] = "dummy"
        request.META['SERVER_PORT'] = "8888"
        # first call with "balnk" request issues a extra query for the Site.find_for_request() call
        with self.assertNumQueries(3):
            self.assertEqual(homepage.get_url(request=request), '/en/')
        # subsequent calls should issue no SQL queries
        with self.assertNumQueries(0):
            self.assertEqual(homepage.get_url(request=request), '/en/')
        # even if called on a different page
        with self.assertNumQueries(0):
            self.assertEqual(christmas_page.get_url(request=request), '/en/events/christmas/')


</source>
</class>

<class classid="183" nclones="2" nlines="17" similarity="72">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_model.py" startline="825" endline="851" pcid="4180">
    def test_publish_method_will_set_live_revision(self):
        page = Page.objects.get(id=2)

        revision = page.save_revision()
        revision.publish()

        page.refresh_from_db()
        self.assertEqual(page.live_revision, revision)
        if settings.USE_TZ:
            self.assertEqual(
                page.last_published_at, datetime.datetime(2017, 1, 1, 12, 0, 0, tzinfo=pytz.utc)
            )
            # first_published_at should not change
            self.assertEqual(
                page.first_published_at, datetime.datetime(2014, 1, 1, 12, 0, 0, tzinfo=pytz.utc)
            )
        else:
            self.assertEqual(
                # interpret the "2017-01-01 12:00:00" in freeze_time above as a naive local date
                page.last_published_at, datetime.datetime(2017, 1, 1, 12, 0, 0)
            )
            # first_published_at should not change
            self.assertEqual(
                # convert the "2014-01-01T12:00:00.000Z" in the test fixture to a naive local time
                page.first_published_at, timezone.make_naive(datetime.datetime(2014, 1, 1, 12, 0, 0, tzinfo=pytz.utc))
            )

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_model.py" startline="853" endline="882" pcid="4181">
    def test_unpublish_method_will_clean_live_revision(self):
        page = Page.objects.get(id=2)

        revision = page.save_revision()
        revision.publish()

        page.refresh_from_db()

        page.unpublish()

        page.refresh_from_db()
        self.assertIsNone(page.live_revision)
        # first_published_at / last_published_at should remain unchanged on unpublish
        if settings.USE_TZ:
            self.assertEqual(
                page.first_published_at, datetime.datetime(2014, 1, 1, 12, 0, 0, tzinfo=pytz.utc)
            )
            self.assertEqual(
                page.last_published_at, datetime.datetime(2017, 1, 1, 12, 0, 0, tzinfo=pytz.utc)
            )
        else:
            self.assertEqual(
                # convert the "2014-01-01T12:00:00.000Z" in the test fixture to a naive local time
                page.first_published_at, timezone.make_naive(datetime.datetime(2014, 1, 1, 12, 0, 0, tzinfo=pytz.utc))
            )
            self.assertEqual(
                # interpret the "2017-01-01 12:00:00" in freeze_time above as a naive local date
                page.last_published_at, datetime.datetime(2017, 1, 1, 12, 0, 0)
            )

</source>
</class>

<class classid="184" nclones="2" nlines="12" similarity="91">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_model.py" startline="958" endline="979" pcid="4186">
    def test_default(self):
        # Field values are fetched from the database, hence the query
        with self.assertNumQueries(1):
            result = self.page.get_specific()

        # The returned instance is the correct type
        self.assertIsInstance(result, SimplePage)

        # Generic page field values can be accessed for free
        with self.assertNumQueries(0):
            self.assertEqual(result.id, self.page.id)
            self.assertEqual(result.title, self.page.title)

        # Specific model fields values are available without additional queries
        with self.assertNumQueries(0):
            self.assertTrue(result.content)

        # All non-field attributes should have been copied over...
        for attr in ('foo', 'bar', 'baz'):
            with self.subTest(attribute=attr):
                self.assertIs(getattr(result, attr), getattr(self.page, attr))

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_model.py" startline="980" endline="1001" pcid="4187">
    def test_deferred(self):
        # Field values are NOT fetched from the database, hence no query
        with self.assertNumQueries(0):
            result = self.page.get_specific(deferred=True)

        # The returned instance is the correct type
        self.assertIsInstance(result, SimplePage)

        # Generic page field values can be accessed for free
        with self.assertNumQueries(0):
            self.assertEqual(result.id, self.page.id)
            self.assertEqual(result.title, self.page.title)

        # But, specific model fields values are NOT available without additional queries
        with self.assertNumQueries(1):
            self.assertTrue(result.content)

        # All non-field attributes should have been copied over...
        for attr in ('foo', 'bar', 'baz'):
            with self.subTest(attribute=attr):
                self.assertIs(getattr(result, attr), getattr(self.page, attr))

</source>
</class>

<class classid="185" nclones="2" nlines="10" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_model.py" startline="1038" endline="1053" pcid="4192">
    def test_specific_cached_property(self):
        # invoking several times to demonstrate that field values
        # are fetched only once from the database, and each time the
        # same object is returned
        with self.assertNumQueries(1):
            result = self.page.specific
            result_2 = self.page.specific
            result_3 = self.page.specific
            self.assertIs(result, result_2)
            self.assertIs(result, result_3)

        self.assertIsInstance(result, SimplePage)
        # Specific model fields values are available without additional queries
        with self.assertNumQueries(0):
            self.assertTrue(result.content)

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_model.py" startline="1054" endline="1069" pcid="4193">
    def test_specific_deferred_cached_property(self):
        # invoking several times to demonstrate that the property
        # returns the same object (without any queries)
        with self.assertNumQueries(0):
            result = self.page.specific_deferred
            result_2 = self.page.specific_deferred
            result_3 = self.page.specific_deferred
            self.assertIs(result, result_2)
            self.assertIs(result, result_3)

        self.assertIsInstance(result, SimplePage)
        # Specific model fields values are not available without additional queries
        with self.assertNumQueries(1):
            self.assertTrue(result.content)


</source>
</class>

<class classid="186" nclones="3" nlines="12" similarity="71">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_model.py" startline="1090" endline="1114" pcid="4195">
    def test_copy_page_copies_child_objects(self):
        christmas_event = EventPage.objects.get(url_path='/home/events/christmas/')

        # Copy it
        new_christmas_event = christmas_event.copy(
            update_attrs={'title': "New christmas event", 'slug': 'new-christmas-event'}
        )

        # Check that the speakers were copied
        self.assertEqual(new_christmas_event.speakers.count(), 1, "Child objects weren't copied")

        # Check that the speakers weren't removed from old page
        self.assertEqual(christmas_event.speakers.count(), 1, "Child objects were removed from the original page")

        # Check that advert placements were also copied (there's a gotcha here, since the advert_placements
        # relation is defined on Page, not EventPage)
        self.assertEqual(
            new_christmas_event.advert_placements.count(), 1, "Child objects defined on the superclass weren't copied"
        )
        self.assertEqual(
            christmas_event.advert_placements.count(),
            1,
            "Child objects defined on the superclass were removed from the original page"
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_model.py" startline="1800" endline="1822" pcid="4229">
    def test_create_alias_copies_child_objects(self):
        christmas_event = EventPage.objects.get(url_path='/home/events/christmas/')

        # Copy it
        new_christmas_event = christmas_event.create_alias(update_slug='new-christmas-event')

        # Check that the speakers were copied
        self.assertEqual(new_christmas_event.speakers.count(), 1, "Child objects weren't copied")

        # Check that the speakers weren't removed from old page
        self.assertEqual(christmas_event.speakers.count(), 1, "Child objects were removed from the original page")

        # Check that advert placements were also copied (there's a gotcha here, since the advert_placements
        # relation is defined on Page, not EventPage)
        self.assertEqual(
            new_christmas_event.advert_placements.count(), 1, "Child objects defined on the superclass weren't copied"
        )
        self.assertEqual(
            christmas_event.advert_placements.count(),
            1,
            "Child objects defined on the superclass were removed from the original page"
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_model.py" startline="1171" endline="1197" pcid="4198">
    def test_copy_page_does_not_copy_child_objects_if_accessor_name_in_exclude_fields(self):
        christmas_event = EventPage.objects.get(url_path='/home/events/christmas/')

        # Copy the page as in `test_copy_page_copies_child_objects()``, but using exclude_fields
        # to prevent 'advert_placements' from being copied to the new version
        new_christmas_event = christmas_event.copy(
            update_attrs={'title': "New christmas event", 'slug': 'new-christmas-event'},
            exclude_fields=['advert_placements']
        )

        # Check that the speakers were copied
        self.assertEqual(new_christmas_event.speakers.count(), 1, "Child objects weren't copied")

        # Check that the speakers weren't removed from old page
        self.assertEqual(christmas_event.speakers.count(), 1, "Child objects were removed from the original page")

        # Check that advert placements were NOT copied over, but were not removed from the old page
        self.assertFalse(
            new_christmas_event.advert_placements.exists(),
            "Child objects were copied despite accessor_name being specified in `exclude_fields`"
        )
        self.assertEqual(
            christmas_event.advert_placements.count(),
            1,
            "Child objects defined on the superclass were removed from the original page"
        )

</source>
</class>

<class classid="187" nclones="2" nlines="19" similarity="89">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_model.py" startline="1115" endline="1149" pcid="4196">
    def test_copy_page_copies_parental_relations(self):
        """Test that a page will be copied with parental many to many relations intact."""
        christmas_event = EventPage.objects.get(url_path='/home/events/christmas/')
        summer_category = EventCategory.objects.create(name='Summer')
        holiday_category = EventCategory.objects.create(name='Holidays')

        # add parental many to many relations
        christmas_event.categories = (summer_category, holiday_category)
        christmas_event.save()

        # Copy it
        new_christmas_event = christmas_event.copy(
            update_attrs={'title': "New christmas event", 'slug': 'new-christmas-event'}
        )

        # check that original eventt is untouched
        self.assertEqual(
            christmas_event.categories.count(),
            2,
            "Child objects (parental many to many) defined on the superclass were removed from the original page"
        )

        # check that parental many to many are copied
        self.assertEqual(
            new_christmas_event.categories.count(),
            2,
            "Child objects (parental many to many) weren't copied"
        )

        # check that the original and copy are related to the same categories
        self.assertEqual(
            new_christmas_event.categories.all().in_bulk(),
            christmas_event.categories.all().in_bulk()
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_model.py" startline="1823" endline="1855" pcid="4230">
    def test_create_alias_copies_parental_relations(self):
        """Test that a page will be copied with parental many to many relations intact."""
        christmas_event = EventPage.objects.get(url_path='/home/events/christmas/')
        summer_category = EventCategory.objects.create(name='Summer')
        holiday_category = EventCategory.objects.create(name='Holidays')

        # add parental many to many relations
        christmas_event.categories = (summer_category, holiday_category)
        christmas_event.save()

        # Copy it
        new_christmas_event = christmas_event.create_alias(update_slug='new-christmas-event')

        # check that original eventt is untouched
        self.assertEqual(
            christmas_event.categories.count(),
            2,
            "Child objects (parental many to many) defined on the superclass were removed from the original page"
        )

        # check that parental many to many are copied
        self.assertEqual(
            new_christmas_event.categories.count(),
            2,
            "Child objects (parental many to many) weren't copied"
        )

        # check that the original and copy are related to the same categories
        self.assertEqual(
            new_christmas_event.categories.all().in_bulk(),
            christmas_event.categories.all().in_bulk()
        )

</source>
</class>

<class classid="188" nclones="2" nlines="13" similarity="92">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_model.py" startline="1483" endline="1507" pcid="4212">
    def test_copy_multi_table_inheritance(self):
        saint_patrick_event = SingleEventPage.objects.get(url_path='/home/events/saint-patrick/')

        # Copy it
        new_saint_patrick_event = saint_patrick_event.copy(update_attrs={'slug': 'new-saint-patrick'})

        # Check that new_saint_patrick_event is correct
        self.assertIsInstance(new_saint_patrick_event, SingleEventPage)
        self.assertEqual(new_saint_patrick_event.excerpt, saint_patrick_event.excerpt)

        # Check that new_saint_patrick_event is a different page, including parents from both EventPage and Page
        self.assertNotEqual(saint_patrick_event.id, new_saint_patrick_event.id)
        self.assertNotEqual(saint_patrick_event.eventpage_ptr.id, new_saint_patrick_event.eventpage_ptr.id)
        self.assertNotEqual(
            saint_patrick_event.eventpage_ptr.page_ptr.id,
            new_saint_patrick_event.eventpage_ptr.page_ptr.id
        )

        # Check that the url path was updated
        self.assertEqual(new_saint_patrick_event.url_path, '/home/events/new-saint-patrick/')

        # Check that both parent instance exists
        self.assertIsInstance(EventPage.objects.get(id=new_saint_patrick_event.id), EventPage)
        self.assertIsInstance(Page.objects.get(id=new_saint_patrick_event.id), Page)

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_model.py" startline="1938" endline="1962" pcid="4237">
    def test_create_alias_multi_table_inheritance(self):
        saint_patrick_event = SingleEventPage.objects.get(url_path='/home/events/saint-patrick/')

        # Copy it
        new_saint_patrick_event = saint_patrick_event.create_alias(update_slug='new-saint-patrick')

        # Check that new_saint_patrick_event is correct
        self.assertIsInstance(new_saint_patrick_event, SingleEventPage)
        self.assertEqual(new_saint_patrick_event.excerpt, saint_patrick_event.excerpt)

        # Check that new_saint_patrick_event is a different page, including parents from both EventPage and Page
        self.assertNotEqual(saint_patrick_event.id, new_saint_patrick_event.id)
        self.assertNotEqual(saint_patrick_event.eventpage_ptr.id, new_saint_patrick_event.eventpage_ptr.id)
        self.assertNotEqual(
            saint_patrick_event.eventpage_ptr.page_ptr.id,
            new_saint_patrick_event.eventpage_ptr.page_ptr.id
        )

        # Check that the url path was updated
        self.assertEqual(new_saint_patrick_event.url_path, '/home/events/new-saint-patrick/')

        # Check that both parent instance exists
        self.assertIsInstance(EventPage.objects.get(id=new_saint_patrick_event.id), EventPage)
        self.assertIsInstance(Page.objects.get(id=new_saint_patrick_event.id), Page)

</source>
</class>

<class classid="189" nclones="3" nlines="18" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_model.py" startline="1508" endline="1537" pcid="4213">
    def test_copy_page_copies_tags(self):
        # create and publish a TaggedPage under Events
        event_index = Page.objects.get(url_path='/home/events/')
        tagged_page = TaggedPage(title='My tagged page', slug='my-tagged-page')
        tagged_page.tags.add('wagtail', 'bird')
        event_index.add_child(instance=tagged_page)
        tagged_page.save_revision().publish()

        old_tagged_item_ids = [item.id for item in tagged_page.tagged_items.all()]
        # there should be two items here, with defined (truthy) IDs
        self.assertEqual(len(old_tagged_item_ids), 2)
        self.assertTrue(all(old_tagged_item_ids))

        # copy to underneath homepage
        homepage = Page.objects.get(url_path='/home/')
        new_tagged_page = tagged_page.copy(to=homepage)

        self.assertNotEqual(tagged_page.id, new_tagged_page.id)

        # new page should also have two tags
        new_tagged_item_ids = [item.id for item in new_tagged_page.tagged_items.all()]
        self.assertEqual(len(new_tagged_item_ids), 2)
        self.assertTrue(all(new_tagged_item_ids))

        # new tagged_item IDs should differ from old ones
        self.assertTrue(all([
            item_id not in old_tagged_item_ids
            for item_id in new_tagged_item_ids
        ]))

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_model.py" startline="1538" endline="1567" pcid="4214">
    def test_copy_subclassed_page_copies_tags(self):
        # create and publish a TaggedGrandchildPage under Events
        event_index = Page.objects.get(url_path='/home/events/')
        sub_tagged_page = TaggedGrandchildPage(title='My very special tagged page', slug='my-special-tagged-page')
        sub_tagged_page.tags.add('wagtail', 'bird')
        event_index.add_child(instance=sub_tagged_page)
        sub_tagged_page.save_revision().publish()

        old_tagged_item_ids = [item.id for item in sub_tagged_page.tagged_items.all()]
        # there should be two items here, with defined (truthy) IDs
        self.assertEqual(len(old_tagged_item_ids), 2)
        self.assertTrue(all(old_tagged_item_ids))

        # copy to underneath homepage
        homepage = Page.objects.get(url_path='/home/')
        new_sub_tagged_page = sub_tagged_page.copy(to=homepage)

        self.assertNotEqual(sub_tagged_page.id, new_sub_tagged_page.id)

        # new page should also have two tags
        new_tagged_item_ids = [item.id for item in new_sub_tagged_page.tagged_items.all()]
        self.assertEqual(len(new_tagged_item_ids), 2)
        self.assertTrue(all(new_tagged_item_ids))

        # new tagged_item IDs should differ from old ones
        self.assertTrue(all([
            item_id not in old_tagged_item_ids
            for item_id in new_tagged_item_ids
        ]))

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_model.py" startline="1963" endline="1992" pcid="4238">
    def test_create_alias_copies_tags(self):
        # create and publish a TaggedPage under Events
        event_index = Page.objects.get(url_path='/home/events/')
        tagged_page = TaggedPage(title='My tagged page', slug='my-tagged-page')
        tagged_page.tags.add('wagtail', 'bird')
        event_index.add_child(instance=tagged_page)
        tagged_page.save_revision().publish()

        old_tagged_item_ids = [item.id for item in tagged_page.tagged_items.all()]
        # there should be two items here, with defined (truthy) IDs
        self.assertEqual(len(old_tagged_item_ids), 2)
        self.assertTrue(all(old_tagged_item_ids))

        # copy to underneath homepage
        homepage = Page.objects.get(url_path='/home/')
        new_tagged_page = tagged_page.create_alias(parent=homepage)

        self.assertNotEqual(tagged_page.id, new_tagged_page.id)

        # new page should also have two tags
        new_tagged_item_ids = [item.id for item in new_tagged_page.tagged_items.all()]
        self.assertEqual(len(new_tagged_item_ids), 2)
        self.assertTrue(all(new_tagged_item_ids))

        # new tagged_item IDs should differ from old ones
        self.assertTrue(all([
            item_id not in old_tagged_item_ids
            for item_id in new_tagged_item_ids
        ]))

</source>
</class>

<class classid="190" nclones="4" nlines="12" similarity="75">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_model.py" startline="1568" endline="1588" pcid="4215">
    def test_copy_page_with_m2m_relations(self):
        # create and publish a ManyToManyBlogPage under Events
        event_index = Page.objects.get(url_path='/home/events/')
        category = BlogCategory.objects.create(name='Birds')
        advert = Advert.objects.create(url='http://www.heinz.com/', text="beanz meanz heinz")

        blog_page = ManyToManyBlogPage(title='My blog page', slug='my-blog-page')
        event_index.add_child(instance=blog_page)

        blog_page.adverts.add(advert)
        BlogCategoryBlogPage.objects.create(category=category, page=blog_page)
        blog_page.save_revision().publish()

        # copy to underneath homepage
        homepage = Page.objects.get(url_path='/home/')
        new_blog_page = blog_page.copy(to=homepage)

        # M2M relations are not formally supported, so for now we're only interested in
        # the copy operation as a whole succeeding, rather than the child objects being copied
        self.assertNotEqual(blog_page.id, new_blog_page.id)

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_model.py" startline="2014" endline="2031" pcid="4240">
    def test_create_alias_with_generic_foreign_key(self):
        # create and publish a GenericSnippetPage under Events
        event_index = Page.objects.get(url_path='/home/events/')
        advert = Advert.objects.create(url='http://www.heinz.com/', text="beanz meanz heinz")

        page = GenericSnippetPage(title='My snippet page', slug='my-snippet-page')
        page.snippet_content_object = advert
        event_index.add_child(instance=page)

        page.save_revision().publish()

        # copy to underneath homepage
        homepage = Page.objects.get(url_path='/home/')
        new_page = page.create_alias(parent=homepage)

        self.assertNotEqual(page.id, new_page.id)
        self.assertEqual(new_page.snippet_content_object, advert)

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_model.py" startline="1993" endline="2013" pcid="4239">
    def test_create_alias_with_m2m_relations(self):
        # create and publish a ManyToManyBlogPage under Events
        event_index = Page.objects.get(url_path='/home/events/')
        category = BlogCategory.objects.create(name='Birds')
        advert = Advert.objects.create(url='http://www.heinz.com/', text="beanz meanz heinz")

        blog_page = ManyToManyBlogPage(title='My blog page', slug='my-blog-page')
        event_index.add_child(instance=blog_page)

        blog_page.adverts.add(advert)
        BlogCategoryBlogPage.objects.create(category=category, page=blog_page)
        blog_page.save_revision().publish()

        # copy to underneath homepage
        homepage = Page.objects.get(url_path='/home/')
        new_blog_page = blog_page.create_alias(parent=homepage)

        # M2M relations are not formally supported, so for now we're only interested in
        # the copy operation as a whole succeeding, rather than the child objects being copied
        self.assertNotEqual(blog_page.id, new_blog_page.id)

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_model.py" startline="1589" endline="1606" pcid="4216">
    def test_copy_page_with_generic_foreign_key(self):
        # create and publish a GenericSnippetPage under Events
        event_index = Page.objects.get(url_path='/home/events/')
        advert = Advert.objects.create(url='http://www.heinz.com/', text="beanz meanz heinz")

        page = GenericSnippetPage(title='My snippet page', slug='my-snippet-page')
        page.snippet_content_object = advert
        event_index.add_child(instance=page)

        page.save_revision().publish()

        # copy to underneath homepage
        homepage = Page.objects.get(url_path='/home/')
        new_page = page.copy(to=homepage)

        self.assertNotEqual(page.id, new_page.id)
        self.assertEqual(new_page.snippet_content_object, advert)

</source>
</class>

<class classid="191" nclones="2" nlines="12" similarity="91">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_model.py" startline="1619" endline="1633" pcid="4218">
    def test_copy_page_with_additional_excluded_fields(self):
        homepage = Page.objects.get(url_path='/home/')
        page = homepage.add_child(instance=PageWithExcludedCopyField(
            title='Discovery',
            slug='disco',
            content='NCC-1031',
            special_field='Context is for Kings'))
        new_page = page.copy(to=homepage, update_attrs={'slug': 'disco-2'})

        self.assertEqual(page.title, new_page.title)
        self.assertNotEqual(page.id, new_page.id)
        self.assertNotEqual(page.path, new_page.path)
        # special_field is in the list to be excluded
        self.assertNotEqual(page.special_field, new_page.special_field)

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_model.py" startline="2045" endline="2059" pcid="4242">
    def test_create_alias_with_additional_excluded_fields(self):
        homepage = Page.objects.get(url_path='/home/')
        page = homepage.add_child(instance=PageWithExcludedCopyField(
            title='Discovery',
            slug='disco',
            content='NCC-1031',
            special_field='Context is for Kings'))
        new_page = page.create_alias(parent=homepage, update_slug='disco-2')

        self.assertEqual(page.title, new_page.title)
        self.assertNotEqual(page.id, new_page.id)
        self.assertNotEqual(page.path, new_page.path)
        # special_field is in the list to be excluded
        self.assertNotEqual(page.special_field, new_page.special_field)

</source>
</class>

<class classid="192" nclones="2" nlines="31" similarity="93">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_model.py" startline="1634" endline="1693" pcid="4219">
    def test_copy_page_with_excluded_parental_and_child_relations(self):
        """Test that a page will be copied with parental and child relations removed if excluded."""

        try:
            # modify excluded fields for this test
            EventPage.exclude_fields_in_copy = ['advert_placements', 'categories', 'signup_link']

            # set up data
            christmas_event = EventPage.objects.get(url_path='/home/events/christmas/')
            summer_category = EventCategory.objects.create(name='Summer')
            holiday_category = EventCategory.objects.create(name='Holidays')

            # add URL (to test excluding a basic field)
            christmas_event.signup_link = "https://christmas-is-awesome.com/rsvp"

            # add parental many to many relations
            christmas_event.categories = (summer_category, holiday_category)
            christmas_event.save()

            # Copy it
            new_christmas_event = christmas_event.copy(
                update_attrs={'title': "New christmas event", 'slug': 'new-christmas-event'}
            )

            # check that the signup_link was NOT copied
            self.assertEqual(christmas_event.signup_link, "https://christmas-is-awesome.com/rsvp")
            self.assertEqual(new_christmas_event.signup_link, '')

            # check that original event is untouched
            self.assertEqual(
                christmas_event.categories.count(),
                2,
                "Child objects (parental many to many) defined on the superclass were removed from the original page"
            )

            # check that parental many to many are NOT copied
            self.assertEqual(
                new_christmas_event.categories.count(),
                0,
                "Child objects (parental many to many) were copied but should be excluded"
            )

            # check that child objects on original event were left untouched
            self.assertEqual(
                christmas_event.advert_placements.count(),
                1,
                "Child objects defined on the original superclass were edited when copied"
            )

            # check that child objects were NOT copied
            self.assertEqual(
                new_christmas_event.advert_placements.count(),
                0,
                "Child objects defined on the superclass were copied and should not be"
            )

        finally:
            # reset excluded fields for future tests
            EventPage.exclude_fields_in_copy = []

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_model.py" startline="2061" endline="2119" pcid="4243">
    def test_create_alias_with_excluded_parental_and_child_relations(self):
        """Test that a page will be copied with parental and child relations removed if excluded."""

        try:
            # modify excluded fields for this test
            EventPage.exclude_fields_in_copy = ['advert_placements', 'categories', 'signup_link']

            # set up data
            christmas_event = EventPage.objects.get(url_path='/home/events/christmas/')
            summer_category = EventCategory.objects.create(name='Summer')
            holiday_category = EventCategory.objects.create(name='Holidays')

            # add URL (to test excluding a basic field)
            christmas_event.signup_link = "https://christmas-is-awesome.com/rsvp"

            # add parental many to many relations
            christmas_event.categories = (summer_category, holiday_category)
            christmas_event.save()

            # Copy it
            new_christmas_event = christmas_event.create_alias(update_slug='new-christmas-event')

            # check that the signup_link was NOT copied
            self.assertEqual(christmas_event.signup_link, "https://christmas-is-awesome.com/rsvp")
            self.assertEqual(new_christmas_event.signup_link, '')

            # check that original event is untouched
            self.assertEqual(
                christmas_event.categories.count(),
                2,
                "Child objects (parental many to many) defined on the superclass were removed from the original page"
            )

            # check that parental many to many are NOT copied
            self.assertEqual(
                new_christmas_event.categories.count(),
                0,
                "Child objects (parental many to many) were copied but should be excluded"
            )

            # check that child objects on original event were left untouched
            self.assertEqual(
                christmas_event.advert_placements.count(),
                1,
                "Child objects defined on the original superclass were edited when copied"
            )

            # check that child objects were NOT copied
            self.assertEqual(
                new_christmas_event.advert_placements.count(),
                0,
                "Child objects defined on the superclass were copied and should not be"
            )

        finally:
            # reset excluded fields for future tests
            EventPage.exclude_fields_in_copy = []


</source>
</class>

<class classid="193" nclones="2" nlines="11" similarity="72">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_model.py" startline="1721" endline="1736" pcid="4223">
    def test_copy_unpublished_not_emits_signal(self):
        """Test that copying of an unpublished page not emits a page_published signal."""
        homepage = Page.objects.get(url_path='/home/')
        homepage.live = False
        homepage.save()

        signal_fired = False

        def page_published_handler(sender, instance, **kwargs):
            nonlocal signal_fired
            signal_fired = True
        page_published.connect(page_published_handler)

        homepage.copy(update_attrs={'slug': 'new_slug'})
        self.assertFalse(signal_fired)

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_model.py" startline="1737" endline="1752" pcid="4225">
    def test_copy_keep_live_false_not_emits_signal(self):
        """Test that copying of a live page with keep_live=False not emits a page_published signal."""
        homepage = Page.objects.get(url_path='/home/')
        signal_fired = False

        def page_published_handler(sender, instance, **kwargs):
            nonlocal signal_fired
            signal_fired = True
        page_published.connect(page_published_handler)

        homepage.copy(
            keep_live=False,
            update_attrs={'slug': 'new_slug'}
        )
        self.assertFalse(signal_fired)

</source>
</class>

<class classid="194" nclones="2" nlines="10" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_model.py" startline="2377" endline="2392" pcid="4256">
    def test_can_exist_under(self):
        self.assertTrue(SimplePage.can_exist_under(SimplePage()))

        # StandardIndex should only be allowed under a Page
        self.assertTrue(StandardIndex.can_exist_under(Page()))
        self.assertFalse(StandardIndex.can_exist_under(SimplePage()))

        # The Business pages are quite restrictive in their structure
        self.assertTrue(BusinessSubIndex.can_exist_under(BusinessIndex()))
        self.assertTrue(BusinessChild.can_exist_under(BusinessIndex()))
        self.assertTrue(BusinessChild.can_exist_under(BusinessSubIndex()))

        self.assertFalse(BusinessSubIndex.can_exist_under(SimplePage()))
        self.assertFalse(BusinessSubIndex.can_exist_under(BusinessSubIndex()))
        self.assertFalse(BusinessChild.can_exist_under(SimplePage()))

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_model.py" startline="2393" endline="2411" pcid="4257">
    def test_can_create_at(self):
        # Pages are not `is_creatable`, and should not be creatable
        self.assertFalse(Page.can_create_at(Page()))

        # SimplePage can be created under a simple page
        self.assertTrue(SimplePage.can_create_at(SimplePage()))

        # StandardIndex can be created under a Page, but not a SimplePage
        self.assertTrue(StandardIndex.can_create_at(Page()))
        self.assertFalse(StandardIndex.can_create_at(SimplePage()))

        # The Business pages are quite restrictive in their structure
        self.assertTrue(BusinessSubIndex.can_create_at(BusinessIndex()))
        self.assertTrue(BusinessChild.can_create_at(BusinessIndex()))
        self.assertTrue(BusinessChild.can_create_at(BusinessSubIndex()))

        self.assertFalse(BusinessChild.can_create_at(SimplePage()))
        self.assertFalse(BusinessSubIndex.can_create_at(SimplePage()))

</source>
</class>

<class classid="195" nclones="3" nlines="21" similarity="95">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_model.py" startline="2630" endline="2654" pcid="4275">
    def test_make_preview_request_for_accessible_page(self):
        event_index = Page.objects.get(url_path='/home/events/')
        response = event_index.make_preview_request()
        self.assertEqual(response.status_code, 200)
        request = response.context_data['request']

        # request should have the correct path and hostname for this page
        self.assertEqual(request.path, '/events/')
        self.assertEqual(request.META['HTTP_HOST'], 'localhost')

        # check other env vars required by the WSGI spec
        self.assertEqual(request.META['REQUEST_METHOD'], 'GET')
        self.assertEqual(request.META['SCRIPT_NAME'], '')
        self.assertEqual(request.META['PATH_INFO'], '/events/')
        self.assertEqual(request.META['SERVER_NAME'], 'localhost')
        self.assertEqual(request.META['SERVER_PORT'], 80)
        self.assertEqual(request.META['SERVER_PROTOCOL'], 'HTTP/1.1')
        self.assertEqual(request.META['wsgi.version'], (1, 0))
        self.assertEqual(request.META['wsgi.url_scheme'], 'http')
        self.assertIn('wsgi.input', request.META)
        self.assertIn('wsgi.errors', request.META)
        self.assertIn('wsgi.multithread', request.META)
        self.assertIn('wsgi.multiprocess', request.META)
        self.assertIn('wsgi.run_once', request.META)

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_model.py" startline="2682" endline="2708" pcid="4277">
    def test_make_preview_request_for_accessible_page_non_standard_port(self):
        Site.objects.update(port=8888)

        event_index = Page.objects.get(url_path='/home/events/')
        response = event_index.make_preview_request()
        self.assertEqual(response.status_code, 200)
        request = response.context_data['request']

        # request should have the correct path and hostname for this page
        self.assertEqual(request.path, '/events/')
        self.assertEqual(request.META['HTTP_HOST'], 'localhost:8888')

        # check other env vars required by the WSGI spec
        self.assertEqual(request.META['REQUEST_METHOD'], 'GET')
        self.assertEqual(request.META['SCRIPT_NAME'], '')
        self.assertEqual(request.META['PATH_INFO'], '/events/')
        self.assertEqual(request.META['SERVER_NAME'], 'localhost')
        self.assertEqual(request.META['SERVER_PORT'], 8888)
        self.assertEqual(request.META['SERVER_PROTOCOL'], 'HTTP/1.1')
        self.assertEqual(request.META['wsgi.version'], (1, 0))
        self.assertEqual(request.META['wsgi.url_scheme'], 'http')
        self.assertIn('wsgi.input', request.META)
        self.assertIn('wsgi.errors', request.META)
        self.assertIn('wsgi.multithread', request.META)
        self.assertIn('wsgi.multiprocess', request.META)
        self.assertIn('wsgi.run_once', request.META)

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_model.py" startline="2655" endline="2681" pcid="4276">
    def test_make_preview_request_for_accessible_page_https(self):
        Site.objects.update(port=443)

        event_index = Page.objects.get(url_path='/home/events/')
        response = event_index.make_preview_request()
        self.assertEqual(response.status_code, 200)
        request = response.context_data['request']

        # request should have the correct path and hostname for this page
        self.assertEqual(request.path, '/events/')
        self.assertEqual(request.META['HTTP_HOST'], 'localhost')

        # check other env vars required by the WSGI spec
        self.assertEqual(request.META['REQUEST_METHOD'], 'GET')
        self.assertEqual(request.META['SCRIPT_NAME'], '')
        self.assertEqual(request.META['PATH_INFO'], '/events/')
        self.assertEqual(request.META['SERVER_NAME'], 'localhost')
        self.assertEqual(request.META['SERVER_PORT'], 443)
        self.assertEqual(request.META['SERVER_PROTOCOL'], 'HTTP/1.1')
        self.assertEqual(request.META['wsgi.version'], (1, 0))
        self.assertEqual(request.META['wsgi.url_scheme'], 'https')
        self.assertIn('wsgi.input', request.META)
        self.assertIn('wsgi.errors', request.META)
        self.assertIn('wsgi.multithread', request.META)
        self.assertIn('wsgi.multiprocess', request.META)
        self.assertIn('wsgi.run_once', request.META)

</source>
</class>

<class classid="196" nclones="2" nlines="10" similarity="90">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_management_commands.py" startline="76" endline="98" pcid="4305">
    def test_detects_orphans(self):
        events_index = Page.objects.get(url_path='/home/events/')
        christmas_page = EventPage.objects.get(url_path='/home/events/christmas/')

        # Delete the events index badly
        self.badly_delete_page(events_index)

        # Check that christmas_page is still in the tree
        self.assertTrue(Page.objects.filter(id=christmas_page.id).exists())

        # Call command
        output = self.run_command()

        # Check that the issues were detected
        output_string = output.read()
        self.assertIn("Incorrect numchild value found for pages: [2]", output_string)
        # Note that page ID 15 was also deleted, but is not picked up here, as
        # it is a child of 14.
        self.assertIn("Orphaned pages found: [4, 5, 6, 9, 13, 15]", output_string)

        # Check that christmas_page is still in the tree
        self.assertTrue(Page.objects.filter(id=christmas_page.id).exists())

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_management_commands.py" startline="99" endline="120" pcid="4306">
    def test_deletes_orphans(self):
        events_index = Page.objects.get(url_path='/home/events/')
        christmas_page = EventPage.objects.get(url_path='/home/events/christmas/')

        # Delete the events index badly
        self.badly_delete_page(events_index)

        # Check that christmas_page is still in the tree
        self.assertTrue(Page.objects.filter(id=christmas_page.id).exists())

        # Call command
        # delete_orphans simulates a user pressing "y" at the prompt
        output = self.run_command(delete_orphans=True)

        # Check that the issues were detected
        output_string = output.read()
        self.assertIn("Incorrect numchild value found for pages: [2]", output_string)
        self.assertIn("7 orphaned pages deleted.", output_string)

        # Check that christmas_page has been deleted
        self.assertFalse(Page.objects.filter(id=christmas_page.id).exists())

</source>
</class>

<class classid="197" nclones="2" nlines="28" similarity="89">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_management_commands.py" startline="193" endline="232" pcid="4315">
    def test_go_live_page_will_be_published(self):
        # Connect a mock signal handler to page_published signal
        signal_fired = [False]
        signal_page = [None]

        def page_published_handler(sender, instance, **kwargs):
            signal_fired[0] = True
            signal_page[0] = instance

        page_published.connect(page_published_handler)

        page = SimplePage(
            title="Hello world!",
            slug="hello-world",
            content="hello",
            live=False,
            has_unpublished_changes=True,
            go_live_at=timezone.now() - timedelta(days=1),
        )
        self.root_page.add_child(instance=page)

        page.save_revision(approved_go_live_at=timezone.now() - timedelta(days=1))

        p = Page.objects.get(slug='hello-world')
        self.assertFalse(p.live)
        self.assertTrue(PageRevision.objects.filter(page=p).exclude(approved_go_live_at__isnull=True).exists())

        management.call_command('publish_scheduled_pages')

        p = Page.objects.get(slug='hello-world')
        self.assertTrue(p.live)
        self.assertTrue(p.first_published_at)
        self.assertFalse(p.has_unpublished_changes)
        self.assertFalse(PageRevision.objects.filter(page=p).exclude(approved_go_live_at__isnull=True).exists())

        # Check that the page_published signal was fired
        self.assertTrue(signal_fired[0])
        self.assertEqual(signal_page[0], page)
        self.assertEqual(signal_page[0], signal_page[0].specific)

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_management_commands.py" startline="278" endline="313" pcid="4319">
    def test_expired_page_will_be_unpublished(self):
        # Connect a mock signal handler to page_unpublished signal
        signal_fired = [False]
        signal_page = [None]

        def page_unpublished_handler(sender, instance, **kwargs):
            signal_fired[0] = True
            signal_page[0] = instance

        page_unpublished.connect(page_unpublished_handler)

        page = SimplePage(
            title="Hello world!",
            slug="hello-world",
            content="hello",
            live=True,
            has_unpublished_changes=False,
            expire_at=timezone.now() - timedelta(days=1),
        )
        self.root_page.add_child(instance=page)

        p = Page.objects.get(slug='hello-world')
        self.assertTrue(p.live)

        management.call_command('publish_scheduled_pages')

        p = Page.objects.get(slug='hello-world')
        self.assertFalse(p.live)
        self.assertTrue(p.has_unpublished_changes)
        self.assertTrue(p.expired)

        # Check that the page_published signal was fired
        self.assertTrue(signal_fired[0])
        self.assertEqual(signal_page[0], page)
        self.assertEqual(signal_page[0], signal_page[0].specific)

</source>
</class>

<class classid="198" nclones="3" nlines="16" similarity="70">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_management_commands.py" startline="256" endline="277" pcid="4318">
    def test_future_go_live_page_will_not_be_published(self):
        page = SimplePage(
            title="Hello world!",
            slug="hello-world",
            content="hello",
            live=False,
            go_live_at=timezone.now() + timedelta(days=1),
        )
        self.root_page.add_child(instance=page)

        page.save_revision(approved_go_live_at=timezone.now() - timedelta(days=1))

        p = Page.objects.get(slug='hello-world')
        self.assertFalse(p.live)
        self.assertTrue(PageRevision.objects.filter(page=p).exclude(approved_go_live_at__isnull=True).exists())

        management.call_command('publish_scheduled_pages')

        p = Page.objects.get(slug='hello-world')
        self.assertFalse(p.live)
        self.assertTrue(PageRevision.objects.filter(page=p).exclude(approved_go_live_at__isnull=True).exists())

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_management_commands.py" startline="333" endline="354" pcid="4322">
    def test_expired_pages_are_dropped_from_mod_queue(self):
        page = SimplePage(
            title="Hello world!",
            slug="hello-world",
            content="hello",
            live=False,
            expire_at=timezone.now() - timedelta(days=1),
        )
        self.root_page.add_child(instance=page)

        page.save_revision(submitted_for_moderation=True)

        p = Page.objects.get(slug='hello-world')
        self.assertFalse(p.live)
        self.assertTrue(PageRevision.objects.filter(page=p, submitted_for_moderation=True).exists())

        management.call_command('publish_scheduled_pages')

        p = Page.objects.get(slug='hello-world')
        self.assertFalse(PageRevision.objects.filter(page=p, submitted_for_moderation=True).exists())


</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_management_commands.py" startline="314" endline="332" pcid="4321">
    def test_future_expired_page_will_not_be_unpublished(self):
        page = SimplePage(
            title="Hello world!",
            slug="hello-world",
            content="hello",
            live=True,
            expire_at=timezone.now() + timedelta(days=1),
        )
        self.root_page.add_child(instance=page)

        p = Page.objects.get(slug='hello-world')
        self.assertTrue(p.live)

        management.call_command('publish_scheduled_pages')

        p = Page.objects.get(slug='hello-world')
        self.assertTrue(p.live)
        self.assertFalse(p.expired)

</source>
</class>

<class classid="199" nclones="4" nlines="42" similarity="70">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_collection_permission_policies.py" startline="233" endline="284" pcid="4340">
    def test_instances_user_has_permission_for(self):
        self.assertResultSetEqual(
            self.policy.instances_user_has_permission_for(
                self.superuser, 'change',
            ),
            [
                self.changer_doc, self.changer_report, self.adder_report,
                self.useless_report, self.anonymous_report
            ]
        )

        self.assertResultSetEqual(
            self.policy.instances_user_has_permission_for(
                self.inactive_superuser, 'change',
            ),
            []
        )

        self.assertResultSetEqual(
            self.policy.instances_user_has_permission_for(
                self.doc_changer, 'change',
            ),
            [
                self.changer_doc, self.changer_report, self.adder_report,
                self.useless_report, self.anonymous_report
            ]
        )

        self.assertResultSetEqual(
            self.policy.instances_user_has_permission_for(
                self.report_changer, 'change',
            ),
            [
                self.changer_report, self.useless_report, self.adder_report,
                self.anonymous_report
            ]
        )

        self.assertResultSetEqual(
            self.policy.instances_user_has_permission_for(
                self.useless_user, 'change',
            ),
            []
        )

        self.assertResultSetEqual(
            self.policy.instances_user_has_permission_for(
                self.anonymous_user, 'change',
            ),
            []
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_collection_permission_policies.py" startline="653" endline="713" pcid="4353">
    def test_instances_user_has_permission_for(self):
        self.assertResultSetEqual(
            self.policy.instances_user_has_permission_for(
                self.superuser, 'change',
            ),
            [
                self.changer_doc, self.changer_report, self.adder_report,
                self.useless_report, self.anonymous_report
            ]
        )

        self.assertResultSetEqual(
            self.policy.instances_user_has_permission_for(
                self.inactive_superuser, 'change',
            ),
            []
        )

        self.assertResultSetEqual(
            self.policy.instances_user_has_permission_for(
                self.doc_changer, 'change',
            ),
            [
                self.changer_doc, self.changer_report, self.adder_report,
                self.useless_report, self.anonymous_report
            ]
        )

        self.assertResultSetEqual(
            self.policy.instances_user_has_permission_for(
                self.report_changer, 'change',
            ),
            [
                self.changer_report, self.useless_report, self.adder_report,
                self.anonymous_report
            ]
        )

        self.assertResultSetEqual(
            self.policy.instances_user_has_permission_for(
                self.useless_user, 'change',
            ),
            []
        )

        self.assertResultSetEqual(
            self.policy.instances_user_has_permission_for(
                self.anonymous_user, 'change',
            ),
            []
        )

        self.assertResultSetEqual(
            self.policy.instances_user_has_permission_for(
                self.report_adder, 'change',
            ),
            [
                self.adder_report,
            ]
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_collection_permission_policies.py" startline="839" endline="895" pcid="4357">
    def test_collections_user_has_permission_for(self):
        self.assertResultSetEqual(
            self.policy.collections_user_has_permission_for(
                self.superuser, 'change',
            ),
            [self.root_collection, self.reports_collection]
        )

        self.assertResultSetEqual(
            self.policy.collections_user_has_permission_for(
                self.inactive_superuser, 'change',
            ),
            []
        )

        self.assertResultSetEqual(
            self.policy.collections_user_has_permission_for(
                self.doc_changer, 'change',
            ),
            [self.root_collection, self.reports_collection]
        )

        self.assertResultSetEqual(
            self.policy.collections_user_has_permission_for(
                self.report_changer, 'change',
            ),
            [self.reports_collection]
        )

        self.assertResultSetEqual(
            self.policy.collections_user_has_permission_for(
                self.report_adder, 'change',
            ),
            [self.reports_collection]
        )

        self.assertResultSetEqual(
            self.policy.collections_user_has_permission_for(
                self.report_adder, 'add',
            ),
            [self.reports_collection]
        )

        self.assertResultSetEqual(
            self.policy.collections_user_has_permission_for(
                self.useless_user, 'change',
            ),
            []
        )

        self.assertResultSetEqual(
            self.policy.collections_user_has_permission_for(
                self.anonymous_user, 'change',
            ),
            []
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_collection_permission_policies.py" startline="401" endline="457" pcid="4344">
    def test_collections_user_has_permission_for(self):
        self.assertResultSetEqual(
            self.policy.collections_user_has_permission_for(
                self.superuser, 'change',
            ),
            [self.root_collection, self.reports_collection]
        )

        self.assertResultSetEqual(
            self.policy.collections_user_has_permission_for(
                self.inactive_superuser, 'change',
            ),
            []
        )

        self.assertResultSetEqual(
            self.policy.collections_user_has_permission_for(
                self.doc_changer, 'change',
            ),
            [self.root_collection, self.reports_collection]
        )

        self.assertResultSetEqual(
            self.policy.collections_user_has_permission_for(
                self.report_changer, 'change',
            ),
            [self.reports_collection]
        )

        self.assertResultSetEqual(
            self.policy.collections_user_has_permission_for(
                self.report_adder, 'change',
            ),
            []
        )

        self.assertResultSetEqual(
            self.policy.collections_user_has_permission_for(
                self.report_adder, 'add',
            ),
            [self.reports_collection]
        )

        self.assertResultSetEqual(
            self.policy.collections_user_has_permission_for(
                self.useless_user, 'change',
            ),
            []
        )

        self.assertResultSetEqual(
            self.policy.collections_user_has_permission_for(
                self.anonymous_user, 'change',
            ),
            []
        )

</source>
</class>

<class classid="200" nclones="2" nlines="35" similarity="81">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_collection_permission_policies.py" startline="285" endline="336" pcid="4341">
    def test_instances_user_has_any_permission_for(self):
        self.assertResultSetEqual(
            self.policy.instances_user_has_any_permission_for(
                self.superuser, ['change', 'delete']
            ),
            [
                self.changer_doc, self.changer_report, self.adder_report,
                self.useless_report, self.anonymous_report
            ]
        )

        self.assertResultSetEqual(
            self.policy.instances_user_has_any_permission_for(
                self.inactive_superuser, ['change', 'delete']
            ),
            []
        )

        self.assertResultSetEqual(
            self.policy.instances_user_has_any_permission_for(
                self.doc_changer, ['change', 'delete']
            ),
            [
                self.changer_doc, self.changer_report, self.adder_report,
                self.useless_report, self.anonymous_report
            ]
        )

        self.assertResultSetEqual(
            self.policy.instances_user_has_any_permission_for(
                self.report_changer, ['change', 'delete']
            ),
            [
                self.changer_report, self.adder_report,
                self.useless_report, self.anonymous_report
            ]
        )

        self.assertResultSetEqual(
            self.policy.instances_user_has_any_permission_for(
                self.useless_user, ['change', 'delete']
            ),
            []
        )

        self.assertResultSetEqual(
            self.policy.instances_user_has_any_permission_for(
                self.anonymous_user, ['change', 'delete']
            ),
            []
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_collection_permission_policies.py" startline="714" endline="774" pcid="4354">
    def test_instances_user_has_any_permission_for(self):
        self.assertResultSetEqual(
            self.policy.instances_user_has_any_permission_for(
                self.superuser, ['change', 'delete']
            ),
            [
                self.changer_doc, self.changer_report, self.adder_report,
                self.useless_report, self.anonymous_report
            ]
        )

        self.assertResultSetEqual(
            self.policy.instances_user_has_any_permission_for(
                self.inactive_superuser, ['change', 'delete']
            ),
            []
        )

        self.assertResultSetEqual(
            self.policy.instances_user_has_any_permission_for(
                self.doc_changer, ['change', 'delete']
            ),
            [
                self.changer_doc, self.changer_report, self.adder_report,
                self.useless_report, self.anonymous_report
            ]
        )

        self.assertResultSetEqual(
            self.policy.instances_user_has_any_permission_for(
                self.report_changer, ['change', 'delete']
            ),
            [
                self.changer_report, self.adder_report,
                self.useless_report, self.anonymous_report
            ]
        )

        self.assertResultSetEqual(
            self.policy.instances_user_has_any_permission_for(
                self.useless_user, ['change', 'delete']
            ),
            []
        )

        self.assertResultSetEqual(
            self.policy.instances_user_has_any_permission_for(
                self.anonymous_user, ['change', 'delete']
            ),
            []
        )

        self.assertResultSetEqual(
            self.policy.instances_user_has_any_permission_for(
                self.report_adder, ['change', 'delete'],
            ),
            [
                self.adder_report,
            ]
        )

</source>
</class>

<class classid="201" nclones="2" nlines="21" similarity="95">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_collection_permission_policies.py" startline="337" endline="368" pcid="4342">
    def test_users_with_permission_for_instance(self):
        self.assertResultSetEqual(
            self.policy.users_with_permission_for_instance('change', self.changer_doc),
            [
                self.superuser, self.doc_changer
            ]
        )
        self.assertResultSetEqual(
            self.policy.users_with_permission_for_instance('change', self.adder_report),
            [
                self.superuser, self.doc_changer, self.report_changer
            ]
        )
        self.assertResultSetEqual(
            self.policy.users_with_permission_for_instance('change', self.changer_report),
            [
                self.superuser, self.doc_changer, self.report_changer
            ]
        )
        self.assertResultSetEqual(
            self.policy.users_with_permission_for_instance('change', self.useless_report),
            [
                self.superuser, self.doc_changer, self.report_changer
            ]
        )
        self.assertResultSetEqual(
            self.policy.users_with_permission_for_instance('change', self.anonymous_report),
            [
                self.superuser, self.doc_changer, self.report_changer
            ]
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_collection_permission_policies.py" startline="775" endline="806" pcid="4355">
    def test_users_with_permission_for_instance(self):
        self.assertResultSetEqual(
            self.policy.users_with_permission_for_instance('change', self.changer_doc),
            [
                self.superuser, self.doc_changer
            ]
        )
        self.assertResultSetEqual(
            self.policy.users_with_permission_for_instance('change', self.changer_report),
            [
                self.superuser, self.doc_changer, self.report_changer
            ]
        )
        self.assertResultSetEqual(
            self.policy.users_with_permission_for_instance('change', self.adder_report),
            [
                self.superuser, self.doc_changer, self.report_changer, self.report_adder
            ]
        )
        self.assertResultSetEqual(
            self.policy.users_with_permission_for_instance('change', self.useless_report),
            [
                self.superuser, self.doc_changer, self.report_changer
            ]
        )
        self.assertResultSetEqual(
            self.policy.users_with_permission_for_instance('change', self.anonymous_report),
            [
                self.superuser, self.doc_changer, self.report_changer
            ]
        )

</source>
</class>

<class classid="202" nclones="2" nlines="20" similarity="90">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_collection_permission_policies.py" startline="369" endline="400" pcid="4343">
    def test_users_with_any_permission_for_instance(self):
        self.assertResultSetEqual(
            self.policy.users_with_any_permission_for_instance(
                ['change', 'delete'], self.changer_doc
            ),
            [
                self.superuser, self.doc_changer
            ]
        )
        self.assertResultSetEqual(
            self.policy.users_with_any_permission_for_instance(
                ['change', 'delete'], self.adder_report
            ),
            [
                self.superuser, self.doc_changer, self.report_changer
            ]
        )
        self.assertResultSetEqual(
            self.policy.users_with_any_permission_for_instance(
                ['change', 'delete'], self.useless_report
            ),
            [
                self.superuser, self.doc_changer, self.report_changer
            ]
        )
        self.assertResultSetEqual(
            self.policy.users_with_any_permission_for_instance(
                ['delete', 'frobnicate'], self.useless_report
            ),
            [self.superuser]
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_collection_permission_policies.py" startline="807" endline="838" pcid="4356">
    def test_users_with_any_permission_for_instance(self):
        self.assertResultSetEqual(
            self.policy.users_with_any_permission_for_instance(
                ['change', 'delete'], self.changer_doc
            ),
            [
                self.superuser, self.doc_changer
            ]
        )
        self.assertResultSetEqual(
            self.policy.users_with_any_permission_for_instance(
                ['change', 'delete'], self.adder_report
            ),
            [
                self.superuser, self.doc_changer, self.report_changer, self.report_adder
            ]
        )
        self.assertResultSetEqual(
            self.policy.users_with_any_permission_for_instance(
                ['change', 'delete'], self.useless_report
            ),
            [
                self.superuser, self.doc_changer, self.report_changer
            ]
        )
        self.assertResultSetEqual(
            self.policy.users_with_any_permission_for_instance(
                ['delete', 'frobnicate'], self.useless_report
            ),
            [self.superuser, self.doc_changer, self.report_changer]
        )

</source>
</class>

<class classid="203" nclones="2" nlines="33" similarity="96">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_collection_permission_policies.py" startline="458" endline="515" pcid="4345">
    def test_collections_user_has_any_permission_for(self):
        self.assertResultSetEqual(
            self.policy.collections_user_has_any_permission_for(
                self.superuser, ['change', 'delete']
            ),
            [self.root_collection, self.reports_collection]
        )

        self.assertResultSetEqual(
            self.policy.collections_user_has_any_permission_for(
                self.inactive_superuser, ['change', 'delete']
            ),
            []
        )

        self.assertResultSetEqual(
            self.policy.collections_user_has_any_permission_for(
                self.doc_changer, ['change', 'delete']
            ),
            [self.root_collection, self.reports_collection]
        )

        self.assertResultSetEqual(
            self.policy.collections_user_has_any_permission_for(
                self.report_changer, ['change', 'delete']
            ),
            [self.reports_collection]
        )

        self.assertResultSetEqual(
            self.policy.collections_user_has_any_permission_for(
                self.report_adder, ['change', 'delete']
            ),
            []
        )

        self.assertResultSetEqual(
            self.policy.collections_user_has_any_permission_for(
                self.report_adder, ['add', 'delete']
            ),
            [self.reports_collection]
        )

        self.assertResultSetEqual(
            self.policy.collections_user_has_any_permission_for(
                self.useless_user, ['change', 'delete']
            ),
            []
        )

        self.assertResultSetEqual(
            self.policy.collections_user_has_any_permission_for(
                self.anonymous_user, ['change', 'delete']
            ),
            []
        )


</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_collection_permission_policies.py" startline="896" endline="953" pcid="4358">
    def test_collections_user_has_any_permission_for(self):
        self.assertResultSetEqual(
            self.policy.collections_user_has_any_permission_for(
                self.superuser, ['change', 'delete']
            ),
            [self.root_collection, self.reports_collection]
        )

        self.assertResultSetEqual(
            self.policy.collections_user_has_any_permission_for(
                self.inactive_superuser, ['change', 'delete']
            ),
            []
        )

        self.assertResultSetEqual(
            self.policy.collections_user_has_any_permission_for(
                self.doc_changer, ['change', 'delete']
            ),
            [self.root_collection, self.reports_collection]
        )

        self.assertResultSetEqual(
            self.policy.collections_user_has_any_permission_for(
                self.report_changer, ['change', 'delete']
            ),
            [self.reports_collection]
        )

        self.assertResultSetEqual(
            self.policy.collections_user_has_any_permission_for(
                self.report_adder, ['change', 'delete']
            ),
            [self.reports_collection]
        )

        self.assertResultSetEqual(
            self.policy.collections_user_has_any_permission_for(
                self.report_adder, ['add', 'delete']
            ),
            [self.reports_collection]
        )

        self.assertResultSetEqual(
            self.policy.collections_user_has_any_permission_for(
                self.useless_user, ['change', 'delete']
            ),
            []
        )

        self.assertResultSetEqual(
            self.policy.collections_user_has_any_permission_for(
                self.anonymous_user, ['change', 'delete']
            ),
            []
        )


</source>
</class>

<class classid="204" nclones="2" nlines="13" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_collection_permission_policies.py" startline="1132" endline="1152" pcid="4367">
    def test_instances_user_has_permission_for(self):
        self.assertResultSetEqual(
            self.policy.instances_user_has_permission_for(self.superuser, 'change'),
            [self.root_collection, self.reports_collection, self.reports_2020_collection]
        )

        self.assertResultSetEqual(
            self.policy.instances_user_has_permission_for(self.report_adder, 'add'),
            [self.reports_collection, self.reports_2020_collection]
        )

        self.assertResultSetEqual(
            self.policy.instances_user_has_permission_for(self.report_adder, 'change'),
            []
        )

        self.assertResultSetEqual(
            self.policy.instances_user_has_permission_for(self.inactive_superuser, 'change'),
            []
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_collection_permission_policies.py" startline="1199" endline="1219" pcid="4371">
    def test_collections_user_has_permission_for(self):
        self.assertResultSetEqual(
            self.policy.collections_user_has_permission_for(self.superuser, 'change'),
            [self.root_collection, self.reports_collection, self.reports_2020_collection]
        )

        self.assertResultSetEqual(
            self.policy.collections_user_has_permission_for(self.report_adder, 'add'),
            [self.reports_collection, self.reports_2020_collection]
        )

        self.assertResultSetEqual(
            self.policy.collections_user_has_permission_for(self.report_adder, 'change'),
            []
        )

        self.assertResultSetEqual(
            self.policy.collections_user_has_permission_for(self.inactive_superuser, 'change'),
            []
        )

</source>
</class>

<class classid="205" nclones="2" nlines="10" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_collection_permission_policies.py" startline="1153" endline="1168" pcid="4368">
    def test_instances_user_has_any_permission_for(self):
        self.assertResultSetEqual(
            self.policy.instances_user_has_any_permission_for(self.superuser, ['add', 'change']),
            [self.root_collection, self.reports_collection, self.reports_2020_collection]
        )

        self.assertResultSetEqual(
            self.policy.instances_user_has_any_permission_for(self.report_adder, ['add', 'change']),
            [self.reports_collection, self.reports_2020_collection]
        )

        self.assertResultSetEqual(
            self.policy.instances_user_has_any_permission_for(self.inactive_superuser, ['add', 'change']),
            []
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_collection_permission_policies.py" startline="1220" endline="1234" pcid="4372">
    def test_collections_user_has_any_permission_for(self):
        self.assertResultSetEqual(
            self.policy.collections_user_has_any_permission_for(self.superuser, ['add', 'change']),
            [self.root_collection, self.reports_collection, self.reports_2020_collection]
        )

        self.assertResultSetEqual(
            self.policy.collections_user_has_any_permission_for(self.report_adder, ['add', 'change']),
            [self.reports_collection, self.reports_2020_collection]
        )

        self.assertResultSetEqual(
            self.policy.collections_user_has_any_permission_for(self.inactive_superuser, ['add', 'change']),
            []
        )
</source>
</class>

<class classid="206" nclones="2" nlines="12" similarity="75">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_queryset.py" startline="308" endline="329" pcid="4410">
    def test_type_with_multiple_models(self):
        pages = Page.objects.type(EventPage, SimplePage)

        # Check that all objects are EventPages or SimplePages
        for page in pages:
            self.assertTrue(
                isinstance(page.specific, (EventPage, SimplePage))
            )

        # Check that "someone elses event" is in the results
        event = Page.objects.get(url_path='/home/events/someone-elses-event/')
        self.assertIn(event, pages)

        # Check that "Saint Patrick" (an instance of SingleEventPage, a subclass of EventPage)
        # is in the results
        event = Page.objects.get(url_path='/home/events/saint-patrick/')
        self.assertIn(event, pages)

        # Check that "About us" (an instance of SimplePage) is in the results
        about_us = Page.objects.get(url_path='/home/about-us/')
        self.assertIn(about_us, pages)

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_queryset.py" startline="378" endline="402" pcid="4414">
    def test_exact_type_with_multiple_models(self):
        pages = Page.objects.exact_type(EventPage, Page)

        # Check that all objects are EventPages or Pages (and not a subclass)
        for page in pages:
            self.assertIn(page.specific_class, (EventPage, Page))

        # Check that "someone elses event" is in the results
        event = Page.objects.get(url_path='/home/events/someone-elses-event/')
        self.assertIn(event, pages)

        # Check that "Saint Patrick" (an instance of SingleEventPage, a subclass of EventPage
        # and Page) is NOT in the results
        single_event = Page.objects.get(url_path='/home/events/saint-patrick/')
        self.assertNotIn(single_event, pages)

        # Check that the homepage (a generic Page only) is in the results
        homepage = Page.objects.get(url_path='/home/')
        self.assertIn(homepage, pages)

        # Check that "About us" (an instance of SimplePage, a subclass of Page)
        # is NOT in the results
        about_us = Page.objects.get(url_path='/home/about-us/')
        self.assertNotIn(about_us, pages)

</source>
</class>

<class classid="207" nclones="2" nlines="11" similarity="81">
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_queryset.py" startline="704" endline="721" pcid="4432">
    def test_filtering_before_specific(self):
        # This will get the other events, and then christmas
        # 'someone-elses-event' and the tentative event are unpublished.

        with self.assertNumQueries(0):
            qs = Page.objects.live().order_by('-url_path')[:3].specific()

        with self.assertNumQueries(3):
            # Metadata, EventIndex and EventPage
            pages = list(qs)

        self.assertEqual(len(pages), 3)

        self.assertEqual(pages, [
            Page.objects.get(url_path='/home/other/special-event/').specific,
            Page.objects.get(url_path='/home/other/').specific,
            Page.objects.get(url_path='/home/events/christmas/').specific])

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/tests/test_page_queryset.py" startline="722" endline="740" pcid="4433">
    def test_filtering_after_specific(self):
        # This will get the other events, and then christmas
        # 'someone-elses-event' and the tentative event are unpublished.

        with self.assertNumQueries(0):
            qs = Page.objects.specific().live().in_menu().order_by('-url_path')[:4]

        with self.assertNumQueries(4):
            # Metadata, EventIndex, EventPage, SimplePage.
            pages = list(qs)

        self.assertEqual(len(pages), 4)

        self.assertEqual(pages, [
            Page.objects.get(url_path='/home/other/').specific,
            Page.objects.get(url_path='/home/events/christmas/').specific,
            Page.objects.get(url_path='/home/events/').specific,
            Page.objects.get(url_path='/home/about-us/').specific])

</source>
</class>

<class classid="208" nclones="2" nlines="13" similarity="71">
<source file="systems/wagtail-2.16.1/wagtail/core/permission_policies/base.py" startline="300" endline="316" pcid="4535">
    def user_has_any_permission_for_instance(self, user, actions, instance):
        if 'change' in actions or 'delete' in actions:
            if user.has_perm(self._get_permission_name('change')):
                return True
            elif (
                user.has_perm(self._get_permission_name('add'))
                and getattr(instance, self.owner_field_name) == user
            ):
                return True
            else:
                return False
        else:
            # 'change' and 'delete' are the only actions that are well-defined
            # for specific instances. Other actions are only available to
            # active superusers.
            return user.is_active and user.is_superuser

</source>
<source file="systems/wagtail-2.16.1/wagtail/core/permission_policies/collections.py" startline="256" endline="274" pcid="4556">
    def user_has_any_permission_for_instance(self, user, actions, instance):
        if 'change' in actions or 'delete' in actions:
            if self._check_perm(user, ['change'], collection=instance.collection):
                return True
            elif (
                self._check_perm(user, ['add'], collection=instance.collection)
                and getattr(instance, self.owner_field_name) == user
            ):
                return True
            else:
                return False
        elif 'choose' in actions:
            return self._check_perm(user, ['choose'], collection=instance.collection)
        else:
            # 'change' and 'delete' are the only actions that are well-defined
            # for specific instances. Other actions are only available to
            # active superusers.
            return user.is_active and user.is_superuser

</source>
</class>

<class classid="209" nclones="2" nlines="21" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/documents/migrations/0002_initial_data.py" startline="5" endline="36" pcid="4665">
def add_document_permissions_to_admin_groups(apps, schema_editor):
    ContentType = apps.get_model('contenttypes.ContentType')
    Permission = apps.get_model('auth.Permission')
    Group = apps.get_model('auth.Group')

    # Get document permissions
    document_content_type, _created = ContentType.objects.get_or_create(
        model='document',
        app_label='wagtaildocs'
    )

    add_document_permission, _created = Permission.objects.get_or_create(
        content_type=document_content_type,
        codename='add_document',
        defaults={'name': 'Can add document'}
    )
    change_document_permission, _created = Permission.objects.get_or_create(
        content_type=document_content_type,
        codename='change_document',
        defaults={'name': 'Can change document'}
    )
    delete_document_permission, _created = Permission.objects.get_or_create(
        content_type=document_content_type,
        codename='delete_document',
        defaults={'name': 'Can delete document'}
    )

    # Assign it to Editors and Moderators groups
    for group in Group.objects.filter(name__in=['Editors', 'Moderators']):
        group.permissions.add(add_document_permission, change_document_permission, delete_document_permission)


</source>
<source file="systems/wagtail-2.16.1/wagtail/images/migrations/0002_initial_data.py" startline="5" endline="36" pcid="4911">
def add_image_permissions_to_admin_groups(apps, schema_editor):
    ContentType = apps.get_model('contenttypes.ContentType')
    Permission = apps.get_model('auth.Permission')
    Group = apps.get_model('auth.Group')

    # Get image permissions
    image_content_type, _created = ContentType.objects.get_or_create(
        model='image',
        app_label='wagtailimages'
    )

    add_image_permission, _created = Permission.objects.get_or_create(
        content_type=image_content_type,
        codename='add_image',
        defaults={'name': 'Can add image'}
    )
    change_image_permission, _created = Permission.objects.get_or_create(
        content_type=image_content_type,
        codename='change_image',
        defaults={'name': 'Can change image'}
    )
    delete_image_permission, _created = Permission.objects.get_or_create(
        content_type=image_content_type,
        codename='delete_image',
        defaults={'name': 'Can delete image'}
    )

    # Assign it to Editors and Moderators groups
    for group in Group.objects.filter(name__in=['Editors', 'Moderators']):
        group.permissions.add(add_image_permission, change_image_permission, delete_image_permission)


</source>
</class>

<class classid="210" nclones="4" nlines="10" similarity="90">
<source file="systems/wagtail-2.16.1/wagtail/documents/migrations/0006_copy_document_permissions_to_collections.py" startline="5" endline="19" pcid="4667">
def get_document_permissions(apps):
    # return a queryset of the 'add_document' and 'change_document' permissions
    Permission = apps.get_model('auth.Permission')
    ContentType = apps.get_model('contenttypes.ContentType')

    document_content_type, _created = ContentType.objects.get_or_create(
        model='document',
        app_label='wagtaildocs',
    )
    return Permission.objects.filter(
        content_type=document_content_type,
        codename__in=['add_document', 'change_document']
    )


</source>
<source file="systems/wagtail-2.16.1/wagtail/images/migrations/0012_copy_image_permissions_to_collections.py" startline="5" endline="19" pcid="4913">
def get_image_permissions(apps):
    # return a queryset of the 'add_image' and 'change_image' permissions
    Permission = apps.get_model('auth.Permission')
    ContentType = apps.get_model('contenttypes.ContentType')

    image_content_type, _created = ContentType.objects.get_or_create(
        model='image',
        app_label='wagtailimages',
    )
    return Permission.objects.filter(
        content_type=image_content_type,
        codename__in=['add_image', 'change_image']
    )


</source>
<source file="systems/wagtail-2.16.1/wagtail/images/migrations/0023_add_choose_permissions.py" startline="46" endline="59" pcid="4918">
def get_choose_permission(apps):
    Permission = apps.get_model('auth.Permission')
    ContentType = apps.get_model('contenttypes.ContentType')

    image_content_type, _created = ContentType.objects.get_or_create(
        model='image',
        app_label='wagtailimages',
    )
    return Permission.objects.filter(
        content_type=image_content_type,
        codename__in=['choose_image']
    ).first()


</source>
<source file="systems/wagtail-2.16.1/wagtail/documents/migrations/0011_add_choose_permissions.py" startline="46" endline="59" pcid="4672">
def get_choose_permission(apps):
    Permission = apps.get_model('auth.Permission')
    ContentType = apps.get_model('contenttypes.ContentType')

    document_content_type, _created = ContentType.objects.get_or_create(
        model='document',
        app_label='wagtaildocs',
    )
    return Permission.objects.filter(
        content_type=document_content_type,
        codename__in=['choose_document']
    ).first()


</source>
</class>

<class classid="211" nclones="4" nlines="11" similarity="83">
<source file="systems/wagtail-2.16.1/wagtail/documents/migrations/0006_copy_document_permissions_to_collections.py" startline="20" endline="35" pcid="4668">
def copy_document_permissions_to_collections(apps, schema_editor):
    Collection = apps.get_model('wagtailcore.Collection')
    Group = apps.get_model('auth.Group')
    GroupCollectionPermission = apps.get_model('wagtailcore.GroupCollectionPermission')

    root_collection = Collection.objects.get(depth=1)

    for permission in get_document_permissions(apps):
        for group in Group.objects.filter(permissions=permission):
            GroupCollectionPermission.objects.create(
                group=group,
                collection=root_collection,
                permission=permission
            )


</source>
<source file="systems/wagtail-2.16.1/wagtail/images/migrations/0012_copy_image_permissions_to_collections.py" startline="20" endline="35" pcid="4914">
def copy_image_permissions_to_collections(apps, schema_editor):
    Collection = apps.get_model('wagtailcore.Collection')
    Group = apps.get_model('auth.Group')
    GroupCollectionPermission = apps.get_model('wagtailcore.GroupCollectionPermission')

    root_collection = Collection.objects.get(depth=1)

    for permission in get_image_permissions(apps):
        for group in Group.objects.filter(permissions=permission):
            GroupCollectionPermission.objects.create(
                group=group,
                collection=root_collection,
                permission=permission
            )


</source>
<source file="systems/wagtail-2.16.1/wagtail/documents/migrations/0011_add_choose_permissions.py" startline="60" endline="76" pcid="4673">
def copy_choose_permission_to_collections(apps, _schema_editor):
    Collection = apps.get_model('wagtailcore.Collection')
    Group = apps.get_model('auth.Group')
    GroupCollectionPermission = apps.get_model('wagtailcore.GroupCollectionPermission')

    root_collection = Collection.objects.get(depth=1)

    permission = get_choose_permission(apps)
    if permission:
        for group in Group.objects.filter(permissions=permission):
            GroupCollectionPermission.objects.create(
                group=group,
                collection=root_collection,
                permission=permission
            )


</source>
<source file="systems/wagtail-2.16.1/wagtail/images/migrations/0023_add_choose_permissions.py" startline="60" endline="76" pcid="4919">
def copy_choose_permission_to_collections(apps, _schema_editor):
    Collection = apps.get_model('wagtailcore.Collection')
    Group = apps.get_model('auth.Group')
    GroupCollectionPermission = apps.get_model('wagtailcore.GroupCollectionPermission')

    root_collection = Collection.objects.get(depth=1)

    permission = get_choose_permission(apps)
    if permission:
        for group in Group.objects.filter(permissions=permission):
            GroupCollectionPermission.objects.create(
                group=group,
                collection=root_collection,
                permission=permission
            )


</source>
</class>

<class classid="212" nclones="2" nlines="11" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/documents/views/multiple.py" startline="113" endline="130" pcid="4686">

    def save_object(self, form):
        # assign the file content from uploaded_doc to the image object, to ensure it gets saved to
        # Document's storage

        self.object.file.save(os.path.basename(self.upload.file.name), self.upload.file.file, save=False)
        self.object.uploaded_by_user = self.request.user
        self.object.file_size = self.object.file.size
        self.object.file.open()
        self.object.file.seek(0)
        self.object._set_file_hash(self.object.file.read())
        self.object.file.seek(0)
        form.save()

        # Reindex the document to make sure all tags are indexed
        for backend in get_search_backends():
            backend.add(self.object)

</source>
<source file="systems/wagtail-2.16.1/wagtail/images/views/multiple.py" startline="113" endline="130" pcid="4939">

    def save_object(self, form):
        # assign the file content from uploaded_image to the image object, to ensure it gets saved to
        # Image's storage

        self.object.file.save(os.path.basename(self.upload.file.name), self.upload.file.file, save=False)
        self.object.uploaded_by_user = self.request.user
        self.object.file_size = self.object.file.size
        self.object.file.open()
        self.object.file.seek(0)
        self.object._set_file_hash(self.object.file.read())
        self.object.file.seek(0)
        form.save()

        # Reindex the image to make sure all tags are indexed
        for backend in get_search_backends():
            backend.add(self.object)

</source>
</class>

<class classid="213" nclones="2" nlines="18" similarity="88">
<source file="systems/wagtail-2.16.1/wagtail/documents/views/documents.py" startline="85" endline="107" pcid="4701">
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)

        collections = permission_policy.collections_user_has_any_permission_for(
            self.request.user, ['add', 'change']
        )
        if len(collections) < 2:
            collections = None

        Document = get_document_model()

        context.update({
            'search_form': self.form,
            'popular_tags': popular_tags_for_model(get_document_model()),
            'user_can_add': permission_policy.user_has_permission(self.request.user, 'add'),
            'collections': collections,
            'current_collection': self.current_collection,
            'app_label': Document._meta.app_label,
            'model_name': Document._meta.model_name,
        })
        return context


</source>
<source file="systems/wagtail-2.16.1/wagtail/images/views/images.py" startline="95" endline="118" pcid="4958">
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)

        collections = permission_policy.collections_user_has_any_permission_for(
            self.request.user, ['add', 'change']
        )
        if len(collections) < 2:
            collections = None

        Image = get_image_model()

        context.update({
            'search_form': self.form,
            'popular_tags': popular_tags_for_model(get_image_model()),
            'current_tag': self.current_tag,
            'collections': collections,
            'current_collection': self.current_collection,
            'user_can_add': permission_policy.user_has_permission(self.request.user, 'add'),
            'app_label': Image._meta.app_label,
            'model_name': Image._meta.model_name,
        })
        return context


</source>
</class>

<class classid="214" nclones="2" nlines="23" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/documents/views/documents.py" startline="113" endline="146" pcid="4702">
def add(request):
    Document = get_document_model()
    DocumentForm = get_document_form(Document)

    if request.method == 'POST':
        doc = Document(uploaded_by_user=request.user)
        form = DocumentForm(request.POST, request.FILES, instance=doc, user=request.user)
        if form.is_valid():
            doc.file_size = doc.file.size

            # Set new document file hash
            doc.file.seek(0)
            doc._set_file_hash(doc.file.read())
            doc.file.seek(0)

            form.save()

            # Reindex the document to make sure all tags are indexed
            search_index.insert_or_update_object(doc)

            messages.success(request, _("Document '{0}' added.").format(doc.title), buttons=[
                messages.button(reverse('wagtaildocs:edit', args=(doc.id,)), _('Edit'))
            ])
            return redirect('wagtaildocs:index')
        else:
            messages.error(request, _("The document could not be saved due to errors."))
    else:
        form = DocumentForm(user=request.user)

    return TemplateResponse(request, "wagtaildocs/documents/add.html", {
        'form': form,
    })


</source>
<source file="systems/wagtail-2.16.1/wagtail/images/views/images.py" startline="299" endline="333" pcid="4964">
def add(request):
    ImageModel = get_image_model()
    ImageForm = get_image_form(ImageModel)

    if request.method == 'POST':
        image = ImageModel(uploaded_by_user=request.user)
        form = ImageForm(request.POST, request.FILES, instance=image, user=request.user)
        if form.is_valid():
            # Set image file size
            image.file_size = image.file.size

            # Set image file hash
            image.file.seek(0)
            image._set_file_hash(image.file.read())
            image.file.seek(0)

            form.save()

            # Reindex the image to make sure all tags are indexed
            search_index.insert_or_update_object(image)

            messages.success(request, _("Image '{0}' added.").format(image.title), buttons=[
                messages.button(reverse('wagtailimages:edit', args=(image.id,)), _('Edit'))
            ])
            return redirect('wagtailimages:index')
        else:
            messages.error(request, _("The image could not be created due to errors."))
    else:
        form = ImageForm(user=request.user)

    return TemplateResponse(request, "wagtailimages/images/add.html", {
        'form': form,
    })


</source>
</class>

<class classid="215" nclones="2" nlines="55" similarity="73">
<source file="systems/wagtail-2.16.1/wagtail/documents/views/documents.py" startline="148" endline="224" pcid="4703">
def edit(request, document_id):
    Document = get_document_model()
    DocumentForm = get_document_form(Document)

    doc = get_object_or_404(Document, id=document_id)

    if not permission_policy.user_has_permission_for_instance(request.user, 'change', doc):
        raise PermissionDenied

    next_url = get_valid_next_url_from_request(request)

    if request.method == 'POST':
        original_file = doc.file
        form = DocumentForm(request.POST, request.FILES, instance=doc, user=request.user)
        if form.is_valid():
            if 'file' in form.changed_data:
                doc = form.save(commit=False)
                doc.file_size = doc.file.size

                # Set new document file hash
                doc.file.seek(0)
                doc._set_file_hash(doc.file.read())
                doc.file.seek(0)
                doc.save()
                form.save_m2m()

                # If providing a new document file, delete the old one.
                # NB Doing this via original_file.delete() clears the file field,
                # which definitely isn't what we want...
                original_file.storage.delete(original_file.name)
            else:
                doc = form.save()

            # Reindex the document to make sure all tags are indexed
            search_index.insert_or_update_object(doc)

            edit_url = reverse('wagtaildocs:edit', args=(doc.id,))
            redirect_url = 'wagtaildocs:index'
            if next_url:
                edit_url = f"{edit_url}?{urlencode({'next': next_url})}"
                redirect_url = next_url

            messages.success(request, _("Document '{0}' updated").format(doc.title), buttons=[
                messages.button(edit_url, _('Edit'))
            ])
            return redirect(redirect_url)
        else:
            messages.error(request, _("The document could not be saved due to errors."))
    else:
        form = DocumentForm(instance=doc, user=request.user)

    try:
        local_path = doc.file.path
    except NotImplementedError:
        # Document is hosted externally (eg, S3)
        local_path = None

    if local_path:
        # Give error if document file doesn't exist
        if not os.path.isfile(local_path):
            messages.error(
                request,
                _("The file could not be found. Please change the source or delete the document"),
                buttons=[messages.button(reverse('wagtaildocs:delete', args=(doc.id,)), _('Delete'))]
            )

    return TemplateResponse(request, "wagtaildocs/documents/edit.html", {
        'document': doc,
        'filesize': doc.get_file_size(),
        'form': form,
        'user_can_delete': permission_policy.user_has_permission_for_instance(
            request.user, 'delete', doc
        ),
        'next': next_url,
    })


</source>
<source file="systems/wagtail-2.16.1/wagtail/images/views/images.py" startline="124" endline="207" pcid="4959">
def edit(request, image_id):
    Image = get_image_model()
    ImageForm = get_image_form(Image)

    image = get_object_or_404(Image, id=image_id)

    if not permission_policy.user_has_permission_for_instance(request.user, 'change', image):
        raise PermissionDenied

    next_url = get_valid_next_url_from_request(request)

    if request.method == 'POST':
        original_file = image.file
        form = ImageForm(request.POST, request.FILES, instance=image, user=request.user)
        if form.is_valid():
            if 'file' in form.changed_data:
                # Set new image file size
                image.file_size = image.file.size

                # Set new image file hash
                image.file.seek(0)
                image._set_file_hash(image.file.read())
                image.file.seek(0)

            form.save()

            if 'file' in form.changed_data:
                # if providing a new image file, delete the old one and all renditions.
                # NB Doing this via original_file.delete() clears the file field,
                # which definitely isn't what we want...
                original_file.storage.delete(original_file.name)
                image.renditions.all().delete()

            # Reindex the image to make sure all tags are indexed
            search_index.insert_or_update_object(image)

            edit_url = reverse('wagtailimages:edit', args=(image.id,))
            redirect_url = 'wagtailimages:index'
            if next_url:
                edit_url = f"{edit_url}?{urlencode({'next': next_url})}"
                redirect_url = next_url

            messages.success(request, _("Image '{0}' updated.").format(image.title), buttons=[
                messages.button(edit_url, _('Edit again'))
            ])
            return redirect(redirect_url)
        else:
            messages.error(request, _("The image could not be saved due to errors."))
    else:
        form = ImageForm(instance=image, user=request.user)

    # Check if we should enable the frontend url generator
    try:
        reverse('wagtailimages_serve', args=('foo', '1', 'bar'))
        url_generator_enabled = True
    except NoReverseMatch:
        url_generator_enabled = False

    if image.is_stored_locally():
        # Give error if image file doesn't exist
        if not os.path.isfile(image.file.path):
            messages.error(request, _(
                "The source image file could not be found. Please change the source or delete the image."
            ).format(image.title), buttons=[
                messages.button(reverse('wagtailimages:delete', args=(image.id,)), _('Delete'))
            ])

    try:
        filesize = image.get_file_size()
    except SourceImageIOError:
        filesize = None

    return TemplateResponse(request, "wagtailimages/images/edit.html", {
        'image': image,
        'form': form,
        'url_generator_enabled': url_generator_enabled,
        'filesize': filesize,
        'user_can_delete': permission_policy.user_has_permission_for_instance(
            request.user, 'delete', image
        ),
        'next': next_url,
    })


</source>
</class>

<class classid="216" nclones="2" nlines="14" similarity="85">
<source file="systems/wagtail-2.16.1/wagtail/documents/views/documents.py" startline="226" endline="245" pcid="4704">
def delete(request, document_id):
    Document = get_document_model()
    doc = get_object_or_404(Document, id=document_id)

    if not permission_policy.user_has_permission_for_instance(request.user, 'delete', doc):
        raise PermissionDenied

    next_url = get_valid_next_url_from_request(request)

    if request.method == 'POST':
        doc.delete()
        messages.success(request, _("Document '{0}' deleted.").format(doc.title))
        return redirect(next_url) if next_url else redirect('wagtaildocs:index')

    return TemplateResponse(request, "wagtaildocs/documents/confirm_delete.html", {
        'document': doc,
        'next': next_url,
    })


</source>
<source file="systems/wagtail-2.16.1/wagtail/images/views/images.py" startline="279" endline="297" pcid="4963">
def delete(request, image_id):
    image = get_object_or_404(get_image_model(), id=image_id)

    if not permission_policy.user_has_permission_for_instance(request.user, 'delete', image):
        raise PermissionDenied

    next_url = get_valid_next_url_from_request(request)

    if request.method == 'POST':
        image.delete()
        messages.success(request, _("Image '{0}' deleted.").format(image.title))
        return redirect(next_url) if next_url else redirect('wagtailimages:index')

    return TemplateResponse(request, "wagtailimages/images/confirm_delete.html", {
        'image': image,
        'next': next_url,
    })


</source>
</class>

<class classid="217" nclones="2" nlines="19" similarity="84">
<source file="systems/wagtail-2.16.1/wagtail/documents/tests/test_views.py" startline="58" endline="89" pcid="4725">
    def test_non_local_filesystem_content_disposition_header(
        self, mock_get_object_or_404, mock_hooks
    ):
        """
        Tests the 'Content-Disposition' header in a response when using a
        storage backend that doesn't expose filesystem paths.
        """
        # Create a mock document with no local file to hit the correct code path
        mock_doc = mock.Mock()
        mock_doc.filename = self.document.filename
        mock_doc.content_type = self.document.content_type
        mock_doc.content_disposition = self.document.content_disposition
        mock_doc.file = StringIO('file-like object' * 10)
        mock_doc.file.path = None
        mock_doc.file.url = None
        mock_doc.file.size = 30
        mock_get_object_or_404.return_value = mock_doc

        # Bypass 'before_serve_document' hooks
        mock_hooks.get_hooks.return_value = []

        response = self.get()

        self.assertEqual(response.status_code, 200)

        self.assertEqual(
            response['Content-Disposition'],
            "attachment; filename={0}; filename*=UTF-8''{0}".format(
                urllib.parse.quote(self.document.filename)
            )
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/documents/tests/test_views.py" startline="92" endline="121" pcid="4726">
    def test_non_local_filesystem_inline_content_disposition_header(
        self, mock_get_object_or_404, mock_hooks
    ):
        """
        Tests the 'Content-Disposition' header in a response when using a
        storage backend that doesn't expose filesystem paths.
        """
        # Create a mock document with no local file to hit the correct code path
        mock_doc = mock.Mock()
        mock_doc.filename = self.pdf_document.filename
        mock_doc.content_type = self.pdf_document.content_type
        mock_doc.content_disposition = self.pdf_document.content_disposition
        mock_doc.file = StringIO('file-like object' * 10)
        mock_doc.file.path = None
        mock_doc.file.url = None
        mock_doc.file.size = 30
        mock_get_object_or_404.return_value = mock_doc

        # Bypass 'before_serve_document' hooks
        mock_hooks.get_hooks.return_value = []

        response = self.get(self.pdf_document)

        self.assertEqual(response.status_code, 200)

        self.assertEqual(
            response['Content-Disposition'],
            "inline"
        )

</source>
</class>

<class classid="218" nclones="2" nlines="11" similarity="90">
<source file="systems/wagtail-2.16.1/wagtail/documents/tests/test_document_chooser.py" startline="81" endline="100" pcid="4768">
    def test_chooser_docs_exist(self):
        # given an editor with access to admin panel
        self.login_as_editor()
        # and a document in the database
        doc_title = 'document.pdf'
        Document.objects.create(title=doc_title)

        # when opening chooser
        response = self.get()

        # then chooser template is used
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'wagtaildocs/chooser/chooser.html')
        # and document is displayed
        self.assertContains(response, doc_title)
        # and no hints are displayed
        self.assertNotContains(response, self._NO_DOCS_TEXT)
        self.assertNotContains(response, self._NO_COLLECTION_DOCS_TEXT)
        self.assertNotContains(response, self._UPLOAD_ONE_TEXT)

</source>
<source file="systems/wagtail-2.16.1/wagtail/documents/tests/test_document_chooser.py" startline="188" endline="207" pcid="4773">
    def test_results_docs_exist(self):
        # given a superuser
        self.login_as_superuser()
        # and a document in the database
        doc_title = 'document.pdf'
        Document.objects.create(title=doc_title)

        # when searching for any documents at chooser panel
        response = self.get({'q': ''})

        # then results template is used
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'wagtaildocs/chooser/results.html')
        # and document is displayed
        self.assertContains(response, doc_title)
        # and no hints are displayed
        self.assertNotContains(response, self._NO_DOCS_TEXT)
        self.assertNotContains(response, self._NO_COLLECTION_DOCS_TEXT)
        self.assertNotContains(response, self._UPLOAD_ONE_TEXT)

</source>
</class>

<class classid="219" nclones="2" nlines="12" similarity="83">
<source file="systems/wagtail-2.16.1/wagtail/documents/tests/test_document_chooser.py" startline="237" endline="257" pcid="4776">
    def test_results_no_collection_docs_upload_allowed(self):
        # given a superuser
        self.login_as_superuser()
        # and a document in a collection
        root_id = get_root_collection_id()
        root = Collection.objects.get(id=root_id)
        doc_title = 'document.pdf'
        Document.objects.create(title=doc_title, collection=root)

        # when searching for documents in another collection at chooser panel
        non_root_id = root_id + 10**10
        response = self.get({'q': '', 'collection_id': non_root_id})

        # then results template is used
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'wagtaildocs/chooser/results.html')
        # and the following hint is displayed:
        # "You haven't uploaded any documents in this collection. Why not upload one now?"
        self.assertContains(response, self._NO_COLLECTION_DOCS_TEXT)
        self.assertContains(response, self._UPLOAD_ONE_TEXT)

</source>
<source file="systems/wagtail-2.16.1/wagtail/documents/tests/test_document_chooser.py" startline="258" endline="275" pcid="4777">
    def test_results_no_collection_docs_upload_forbidden(self):
        # given an editor with access to admin panel
        self.login_as_editor()
        # and a document in a collection
        root_id = get_root_collection_id()
        root = Collection.objects.get(id=root_id)
        Document.objects.create(collection=root)

        # when searching for documents in another collection at chooser panel
        non_root_id = root_id + 10**10
        response = self.get({'q': '', 'collection_id': non_root_id})

        # then results template is used
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'wagtaildocs/chooser/results.html')
        # and hint "You haven't uploaded any documents in this collection." is displayed
        self.assertContains(response, self._NO_COLLECTION_DOCS_TEXT)
        self.assertNotContains(response, self._UPLOAD_ONE_TEXT)
</source>
</class>

<class classid="220" nclones="2" nlines="15" similarity="73">
<source file="systems/wagtail-2.16.1/wagtail/documents/tests/test_search.py" startline="28" endline="48" pcid="4780">
    def add_document(self, **params):
        # Build a fake file
        fake_file = ContentFile(b"A boring example document")
        fake_file.name = 'test.txt'

        # Submit
        post_data = {
            'title': "Test document",
            'file': fake_file,
        }
        post_data.update(params)
        response = self.client.post(reverse('wagtaildocs:add'), post_data)

        # User should be redirected back to the index
        self.assertRedirects(response, reverse('wagtaildocs:index'))

        # Document should be created
        doc = models.Document.objects.filter(title=post_data['title'])
        self.assertTrue(doc.exists())
        return doc.first()

</source>
<source file="systems/wagtail-2.16.1/wagtail/documents/tests/test_search.py" startline="49" endline="76" pcid="4781">
    def edit_document(self, **params):
        # Build a fake file
        fake_file = ContentFile(b"A boring example document")
        fake_file.name = 'test.txt'

        # Create a document without tags to edit
        document = models.Document.objects.create(title="Test document", file=fake_file)

        # Build another fake file
        another_fake_file = ContentFile(b"A boring example document")
        another_fake_file.name = 'test.txt'

        # Submit
        post_data = {
            'title': "Test document changed!",
            'file': another_fake_file,
        }
        post_data.update(params)
        response = self.client.post(reverse('wagtaildocs:edit', args=(document.id,)), post_data)

        # User should be redirected back to the index
        self.assertRedirects(response, reverse('wagtaildocs:index'))

        # Document should be changed
        doc = models.Document.objects.filter(title=post_data['title'])
        self.assertTrue(doc.exists())
        return doc.first()

</source>
</class>

<class classid="221" nclones="4" nlines="11" similarity="72">
<source file="systems/wagtail-2.16.1/wagtail/documents/tests/test_bulk_actions/test_bulk_add_to_collection.py" startline="14" endline="25" pcid="4829">
    def setUp(self):
        self.user = self.login()
        self.root_collection = Collection.get_first_root_node()
        self.dest_collection = self.root_collection.add_child(name="Destination")
        self.documents = [
            Document.objects.create(title=f"Test document - {i}") for i in range(1, 6)
        ]
        self.url = reverse('wagtail_bulk_action', args=('wagtaildocs', 'document', 'add_to_collection',)) + '?'
        for document in self.documents:
            self.url += f'id={document.id}&'
        self.post_data = {'collection': str(self.dest_collection.id)}

</source>
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_bulk_actions/test_bulk_add_to_collection.py" startline="16" endline="27" pcid="5274">
    def setUp(self):
        self.user = self.login()
        self.root_collection = Collection.get_first_root_node()
        self.dest_collection = self.root_collection.add_child(name="Destination")
        self.images = [
            Image.objects.create(title=f"Test image - {i}", file=test_file) for i in range(1, 6)
        ]
        self.url = reverse('wagtail_bulk_action', args=('wagtailimages', 'image', 'add_to_collection',)) + '?'
        for image in self.images:
            self.url += f'id={image.id}&'
        self.post_data = {'collection': str(self.dest_collection.id)}

</source>
<source file="systems/wagtail-2.16.1/wagtail/documents/tests/test_bulk_actions/test_bulk_add_tags.py" startline="17" endline="27" pcid="4834">
    def setUp(self):
        self.user = self.login()
        self.new_tags = ['first', 'second']
        self.documents = [
            Document.objects.create(title=f"Test document - {i}") for i in range(1, 6)
        ]
        self.url = reverse('wagtail_bulk_action', args=('wagtaildocs', 'document', 'add_tags',)) + '?'
        for document in self.documents:
            self.url += f'id={document.id}&'
        self.post_data = {'tags': ','.join(self.new_tags)}

</source>
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_bulk_actions/test_bulk_add_tags.py" startline="19" endline="29" pcid="5279">
    def setUp(self):
        self.user = self.login()
        self.new_tags = ['first', 'second']
        self.images = [
            Image.objects.create(title=f"Test image - {i}", file=test_file) for i in range(1, 6)
        ]
        self.url = reverse('wagtail_bulk_action', args=('wagtailimages', 'image', 'add_tags',)) + '?'
        for image in self.images:
            self.url += f'id={image.id}&'
        self.post_data = {'tags': ','.join(self.new_tags)}

</source>
</class>

<class classid="222" nclones="3" nlines="10" similarity="80">
<source file="systems/wagtail-2.16.1/wagtail/documents/forms.py" startline="43" endline="59" pcid="4862">
def get_document_form(model):
    fields = model.admin_form_fields
    if 'collection' not in fields:
        # force addition of the 'collection' field, because leaving it out can
        # cause dubious results when multiple collections exist (e.g adding the
        # document to the root collection where the user may not have permission) -
        # and when only one collection exists, it will get hidden anyway.
        fields = list(fields) + ['collection']

    return modelform_factory(
        model,
        form=get_document_base_form(),
        fields=fields,
        formfield_callback=formfield_for_dbfield,
    )


</source>
<source file="systems/wagtail-2.16.1/wagtail/documents/forms.py" startline="60" endline="75" pcid="4863">
def get_document_multi_form(model):
    # edit form for use within the multiple uploader; consists of all fields from
    # model.admin_form_fields except file

    fields = [field for field in model.admin_form_fields if field != 'file']
    if 'collection' not in fields:
        fields.append('collection')

    return modelform_factory(
        model,
        form=get_document_base_form(),
        fields=fields,
        formfield_callback=formfield_for_dbfield,
    )


</source>
<source file="systems/wagtail-2.16.1/wagtail/images/forms.py" startline="56" endline="72" pcid="5414">
def get_image_form(model):
    fields = model.admin_form_fields
    if 'collection' not in fields:
        # force addition of the 'collection' field, because leaving it out can
        # cause dubious results when multiple collections exist (e.g adding the
        # document to the root collection where the user may not have permission) -
        # and when only one collection exists, it will get hidden anyway.
        fields = list(fields) + ['collection']

    return modelform_factory(
        model,
        form=get_image_base_form(),
        fields=fields,
        formfield_callback=formfield_for_dbfield,
    )


</source>
</class>

<class classid="223" nclones="2" nlines="10" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/documents/__init__.py" startline="23" endline="38" pcid="4883">
def get_document_model():
    """
    Get the document model from the ``WAGTAILDOCS_DOCUMENT_MODEL`` setting.
    Defaults to the standard :class:`~wagtail.documents.models.Document` model
    if no custom model is defined.
    """
    from django.apps import apps
    model_string = get_document_model_string()
    try:
        return apps.get_model(model_string, require_ready=False)
    except ValueError:
        raise ImproperlyConfigured("WAGTAILDOCS_DOCUMENT_MODEL must be of the form 'app_label.model_name'")
    except LookupError:
        raise ImproperlyConfigured(
            "WAGTAILDOCS_DOCUMENT_MODEL refers to model '%s' that has not been installed" % model_string
        )
</source>
<source file="systems/wagtail-2.16.1/wagtail/images/__init__.py" startline="23" endline="39" pcid="5469">
def get_image_model():
    """
    Get the image model from the ``WAGTAILIMAGES_IMAGE_MODEL`` setting.
    Useful for developers making Wagtail plugins that need the image model.
    Defaults to the standard :class:`~wagtail.images.models.Image` model
    if no custom model is defined.
    """
    from django.apps import apps
    model_string = get_image_model_string()
    try:
        return apps.get_model(model_string, require_ready=False)
    except ValueError:
        raise ImproperlyConfigured("WAGTAILIMAGES_IMAGE_MODEL must be of the form 'app_label.model_name'")
    except LookupError:
        raise ImproperlyConfigured(
            "WAGTAILIMAGES_IMAGE_MODEL refers to model '%s' that has not been installed" % model_string
        )
</source>
</class>

<class classid="224" nclones="4" nlines="12" similarity="83">
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_rich_text.py" startline="28" endline="43" pcid="5000">
    def test_expand_db_attributes_for_editor(self):
        Image.objects.create(id=1, title='Test', file=get_test_image_file())
        result = EditorHtmlImageEmbedHandler.expand_db_attributes({
            'id': 1,
            'alt': 'test-alt',
            'format': 'left',
        })
        self.assertTagInHTML(
            (
                '<img data-embedtype="image" data-id="1" data-format="left" '
                'data-alt="test-alt" class="richtext-image left" />'
            ),
            result,
            allow_extra_attrs=True
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_rich_text.py" startline="84" endline="96" pcid="5004">
    def test_expand_db_attributes_for_frontend(self):
        Image.objects.create(id=1, title='Test', file=get_test_image_file())
        result = FrontendImageEmbedHandler.expand_db_attributes({
            'id': 1,
            'alt': 'test-alt',
            'format': 'left',
        })
        self.assertTagInHTML(
            '<img class="richtext-image left" />',
            result,
            allow_extra_attrs=True
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_rich_text.py" startline="67" endline="82" pcid="5003">
    def test_expand_db_attributes_for_editor_with_missing_alt(self):
        Image.objects.create(id=1, title='Test', file=get_test_image_file())
        result = EditorHtmlImageEmbedHandler.expand_db_attributes({
            'id': 1,
            'format': 'left',
        })
        self.assertTagInHTML(
            (
                '<img data-embedtype="image" data-id="1" data-format="left" data-alt="" '
                'class="richtext-image left" />'
            ),
            result,
            allow_extra_attrs=True
        )


</source>
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_rich_text.py" startline="50" endline="66" pcid="5002">
    def test_expand_db_attributes_for_editor_escapes_alt_text(self):
        Image.objects.create(id=1, title='Test', file=get_test_image_file())
        result = EditorHtmlImageEmbedHandler.expand_db_attributes({
            'id': 1,
            'alt': 'Arthur "two sheds" Jackson',
            'format': 'left',
        })

        self.assertTagInHTML(
            (
                '<img data-embedtype="image" data-id="1" data-format="left" '
                'data-alt="Arthur &quot;two sheds&quot; Jackson" class="richtext-image left" />'
            ),
            result, allow_extra_attrs=True)

        self.assertIn('alt="Arthur &quot;two sheds&quot; Jackson"', result)

</source>
</class>

<class classid="225" nclones="2" nlines="15" similarity="93">
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_jinja2.py" startline="16" endline="36" pcid="5008">
    def setUp(self):
        self.engine = engines['jinja2']

        self.image = Image.objects.create(
            title="Test image",
            file=get_test_image_file(),
        )

        # Create an image with a missing file, by deserializing fom a python object
        # (which bypasses FileField's attempt to read the file)
        self.bad_image = list(serializers.deserialize('python', [{
            'fields': {
                'title': 'missing image',
                'height': 100,
                'file': 'original_images/missing-image.jpg',
                'width': 100,
            },
            'model': 'wagtailimages.image'
        }]))[0].object
        self.bad_image.save()

</source>
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_blocks.py" startline="14" endline="32" pcid="5024">
    def setUp(self):
        self.image = Image.objects.create(
            title="Test image",
            file=get_test_image_file(),
        )

        # Create an image with a missing file, by deserializing fom a python object
        # (which bypasses FileField's attempt to read the file)
        self.bad_image = list(serializers.deserialize('python', [{
            'fields': {
                'title': 'missing image',
                'height': 100,
                'file': 'original_images/missing-image.jpg',
                'width': 100,
            },
            'model': 'wagtailimages.image'
        }]))[0].object
        self.bad_image.save()

</source>
</class>

<class classid="226" nclones="2" nlines="13" similarity="85">
<source file="systems/wagtail-2.16.1/wagtail/images/tests/tests.py" startline="546" endline="559" pcid="5090">
    def test_fields(self):
        form = get_image_form(Image)

        self.assertEqual(list(form.base_fields.keys()), [
            'title',
            'file',
            'collection',
            'tags',
            'focal_point_x',
            'focal_point_y',
            'focal_point_width',
            'focal_point_height',
        ])

</source>
<source file="systems/wagtail-2.16.1/wagtail/images/tests/tests.py" startline="560" endline="575" pcid="5091">
    def test_admin_form_fields_attribute(self):
        form = get_image_form(CustomImage)

        self.assertEqual(list(form.base_fields.keys()), [
            'title',
            'file',
            'collection',
            'tags',
            'focal_point_x',
            'focal_point_y',
            'focal_point_width',
            'focal_point_height',
            'caption',
            'fancy_caption',
        ])

</source>
</class>

<class classid="227" nclones="2" nlines="14" similarity="73">
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_admin_views.py" startline="259" endline="284" pcid="5140">
    def test_add(self):
        response = self.post({
            'title': "Test image",
            'file': SimpleUploadedFile('test.png', get_test_image_file().file.getvalue()),
        })

        # Should redirect back to index
        self.assertRedirects(response, reverse('wagtailimages:index'))

        # Check that the image was created
        images = Image.objects.filter(title="Test image")
        self.assertEqual(images.count(), 1)

        # Test that size was populated correctly
        image = images.first()
        self.assertEqual(image.width, 640)
        self.assertEqual(image.height, 480)

        # Test that the file_size/hash fields were set
        self.assertTrue(image.file_size)
        self.assertTrue(image.file_hash)

        # Test that it was placed in the root collection
        root_collection = Collection.get_first_root_node()
        self.assertEqual(image.collection, root_collection)

</source>
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_admin_views.py" startline="1172" endline="1193" pcid="5214">
    def test_upload(self):
        response = self.client.post(reverse('wagtailimages:chooser_upload'), {
            'image-chooser-upload-title': "Test image",
            'image-chooser-upload-file': SimpleUploadedFile('test.png', get_test_image_file().file.getvalue()),
        })

        # Check response
        self.assertEqual(response.status_code, 200)

        # Check that the image was created
        images = Image.objects.filter(title="Test image")
        self.assertEqual(images.count(), 1)

        # Test that size was populated correctly
        image = images.first()
        self.assertEqual(image.width, 640)
        self.assertEqual(image.height, 480)

        # Test that the file_size/hash fields were set
        self.assertTrue(image.file_size)
        self.assertTrue(image.file_hash)

</source>
</class>

<class classid="228" nclones="2" nlines="13" similarity="71">
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_admin_views.py" startline="311" endline="331" pcid="5143">
    def test_add_too_large_file(self):
        file_content = get_test_image_file().file.getvalue()

        response = self.post({
            'title': "Test image",
            'file': SimpleUploadedFile('test.png', file_content),
        })

        # Shouldn't redirect anywhere
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'wagtailimages/images/add.html')

        # The form should have an error
        self.assertFormError(
            response, 'form', 'file',
            "This file is too big ({file_size}). Maximum filesize {max_file_size}.".format(
                file_size=filesizeformat(len(file_content)),
                max_file_size=filesizeformat(1),
            )
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_admin_views.py" startline="333" endline="350" pcid="5144">
    def test_add_too_many_pixels(self):
        file_content = get_test_image_file().file.getvalue()

        response = self.post({
            'title': "Test image",
            'file': SimpleUploadedFile('test.png', file_content),
        })

        # Shouldn't redirect anywhere
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'wagtailimages/images/add.html')

        # The form should have an error
        self.assertFormError(
            response, 'form', 'file',
            'This file has too many pixels (307200). Maximum pixels 1.'
        )

</source>
</class>

<class classid="229" nclones="3" nlines="15" similarity="77">
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_admin_views.py" startline="373" endline="397" pcid="5146">
    def test_unique_together_validation_error(self):
        root_collection = Collection.get_first_root_node()
        evil_plans_collection = root_collection.add_child(name="Evil plans")

        # another image with a title to collide with
        CustomImage.objects.create(
            title="Test image",
            file=get_test_image_file(),
            collection=evil_plans_collection
        )

        response = self.post({
            'title': "Test image",
            'file': SimpleUploadedFile('test.png', get_test_image_file().file.getvalue()),
            'collection': evil_plans_collection.id,
        })

        # Shouldn't redirect anywhere
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'wagtailimages/images/add.html')

        # error message should be output on the page as a non-field error
        self.assertContains(response, "Custom image with this Title and Collection already exists.")


</source>
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_admin_views.py" startline="1255" endline="1278" pcid="5219">
    def test_unique_together_validation(self):
        root_collection = Collection.get_first_root_node()
        evil_plans_collection = root_collection.add_child(name="Evil plans")
        # another image with a title to collide with
        CustomImage.objects.create(
            title="Test image",
            file=get_test_image_file(),
            collection=evil_plans_collection
        )

        response = self.client.post(reverse('wagtailimages:chooser_upload'), {
            'image-chooser-upload-title': "Test image",
            'image-chooser-upload-file': SimpleUploadedFile('test.png', get_test_image_file().file.getvalue()),
            'image-chooser-upload-collection': evil_plans_collection.id
        })

        # Shouldn't redirect anywhere
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'wagtailimages/chooser/upload_form.html')

        # The form should have an error
        self.assertContains(response, "Custom image with this Title and Collection already exists.")


</source>
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_admin_views.py" startline="762" endline="791" pcid="5175">
    def test_unique_together_validation_error(self):
        root_collection = Collection.get_first_root_node()
        evil_plans_collection = root_collection.add_child(name="Evil plans")

        # Create an image to edit
        self.image = CustomImage.objects.create(
            title="Test image",
            file=get_test_image_file(),
        )

        # another image with a title to collide with
        CustomImage.objects.create(
            title="Edited",
            file=get_test_image_file(),
            collection=evil_plans_collection
        )

        response = self.post({
            'title': "Edited",
            'collection': evil_plans_collection.id,
        })

        # Shouldn't redirect anywhere
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'wagtailimages/images/edit.html')

        # error message should be output on the page as a non-field error
        self.assertContains(response, "Custom image with this Title and Collection already exists.")


</source>
</class>

<class classid="230" nclones="2" nlines="19" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_admin_views.py" startline="399" endline="426" pcid="5147">
    def setUp(self):
        add_image_permission = Permission.objects.get(
            content_type__app_label='wagtailimages', codename='add_image'
        )
        admin_permission = Permission.objects.get(
            content_type__app_label='wagtailadmin', codename='access_admin'
        )

        root_collection = Collection.get_first_root_node()
        self.evil_plans_collection = root_collection.add_child(name="Evil plans")

        conspirators_group = Group.objects.create(name="Evil conspirators")
        conspirators_group.permissions.add(admin_permission)
        GroupCollectionPermission.objects.create(
            group=conspirators_group,
            collection=self.evil_plans_collection,
            permission=add_image_permission
        )

        user = self.create_user(
            username='moriarty',
            email='moriarty@example.com',
            password='password'
        )
        user.groups.add(conspirators_group)

        self.login(username='moriarty', password='password')

</source>
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_admin_views.py" startline="1280" endline="1307" pcid="5220">
    def setUp(self):
        add_image_permission = Permission.objects.get(
            content_type__app_label='wagtailimages', codename='add_image'
        )
        admin_permission = Permission.objects.get(
            content_type__app_label='wagtailadmin', codename='access_admin'
        )

        root_collection = Collection.get_first_root_node()
        self.evil_plans_collection = root_collection.add_child(name="Evil plans")

        conspirators_group = Group.objects.create(name="Evil conspirators")
        conspirators_group.permissions.add(admin_permission)
        GroupCollectionPermission.objects.create(
            group=conspirators_group,
            collection=self.evil_plans_collection,
            permission=add_image_permission
        )

        user = self.create_user(
            username='moriarty',
            email='moriarty@example.com',
            password='password'
        )
        user.groups.add(conspirators_group)

        self.login(username='moriarty', password='password')

</source>
</class>

<class classid="231" nclones="2" nlines="13" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_admin_views.py" startline="607" endline="626" pcid="5165">
    def test_edit_with_new_image_file(self):
        file_content = get_test_image_file().file.getvalue()

        # Change the file size/hash of the image
        self.image.file_size = 100000
        self.image.file_hash = 'abcedf'
        self.image.save()

        response = self.post({
            'title': "Edited",
            'file': SimpleUploadedFile('new.png', file_content),
        })

        # Should redirect back to index
        self.assertRedirects(response, reverse('wagtailimages:index'))

        self.update_from_db()
        self.assertNotEqual(self.image.file_size, 100000)
        self.assertNotEqual(self.image.file_hash, 'abcedf')

</source>
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_admin_views.py" startline="628" endline="647" pcid="5166">
    def test_edit_with_new_image_file_and_external_storage(self):
        file_content = get_test_image_file().file.getvalue()

        # Change the file size/hash of the image
        self.image.file_size = 100000
        self.image.file_hash = 'abcedf'
        self.image.save()

        response = self.post({
            'title': "Edited",
            'file': SimpleUploadedFile('new.png', file_content),
        })

        # Should redirect back to index
        self.assertRedirects(response, reverse('wagtailimages:index'))

        self.update_from_db()
        self.assertNotEqual(self.image.file_size, 100000)
        self.assertNotEqual(self.image.file_hash, 'abcedf')

</source>
</class>

<class classid="232" nclones="2" nlines="26" similarity="96">
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_admin_views.py" startline="682" endline="716" pcid="5172">
    def test_reupload_same_name(self):
        """
        Checks that reuploading the image file with the same file name
        changes the file name, to avoid browser cache issues (see #3817).
        """
        old_file = self.image.file
        old_size = self.image.file_size
        old_data = self.get_content()

        old_rendition = self.image.get_rendition('fill-5x5')
        old_rendition_data = self.get_content(old_rendition.file)

        new_name = self.image.filename
        new_file = SimpleUploadedFile(
            new_name, get_test_image_file(colour='red').file.getvalue())
        new_size = new_file.size

        response = self.post({
            'title': self.image.title, 'file': new_file,
        })
        self.assertRedirects(response, reverse('wagtailimages:index'))
        self.update_from_db()
        self.assertFalse(self.storage.exists(old_file.name))
        self.assertTrue(self.storage.exists(self.image.file.name))
        self.assertNotEqual(self.image.file.name,
                            'original_images/' + new_name)
        self.assertNotEqual(self.image.file_size, old_size)
        self.assertEqual(self.image.file_size, new_size)
        self.assertNotEqual(self.get_content(), old_data)

        new_rendition = self.image.get_rendition('fill-5x5')
        self.assertNotEqual(old_rendition.file.name, new_rendition.file.name)
        self.assertNotEqual(self.get_content(new_rendition.file),
                            old_rendition_data)

</source>
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_admin_views.py" startline="717" endline="751" pcid="5173">
    def test_reupload_different_name(self):
        """
        Checks that reuploading the image file with a different file name
        correctly uses the new file name.
        """
        old_file = self.image.file
        old_size = self.image.file_size
        old_data = self.get_content()

        old_rendition = self.image.get_rendition('fill-5x5')
        old_rendition_data = self.get_content(old_rendition.file)

        new_name = 'test_reupload_different_name.png'
        new_file = SimpleUploadedFile(
            new_name, get_test_image_file(colour='red').file.getvalue())
        new_size = new_file.size

        response = self.post({
            'title': self.image.title, 'file': new_file,
        })
        self.assertRedirects(response, reverse('wagtailimages:index'))
        self.update_from_db()
        self.assertFalse(self.storage.exists(old_file.name))
        self.assertTrue(self.storage.exists(self.image.file.name))
        self.assertEqual(self.image.file.name,
                         'original_images/' + new_name)
        self.assertNotEqual(self.image.file_size, old_size)
        self.assertEqual(self.image.file_size, new_size)
        self.assertNotEqual(self.get_content(), old_data)

        new_rendition = self.image.get_rendition('fill-5x5')
        self.assertNotEqual(old_rendition.file.name, new_rendition.file.name)
        self.assertNotEqual(self.get_content(new_rendition.file),
                            old_rendition_data)

</source>
</class>

<class classid="233" nclones="2" nlines="16" similarity="93">
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_admin_views.py" startline="1018" endline="1038" pcid="5195">
    def test_construct_queryset_hook_browse(self):
        image = Image.objects.create(
            title="Test image shown",
            file=get_test_image_file(),
            uploaded_by_user=self.user,
        )
        Image.objects.create(
            title="Test image not shown",
            file=get_test_image_file(),
        )

        def filter_images(images, request):
            # Filter on `uploaded_by_user` because it is
            # the only default FilterField in search_fields
            return images.filter(uploaded_by_user=self.user)

        with self.register_hook('construct_image_chooser_queryset', filter_images):
            response = self.get()
        self.assertEqual(len(response.context['images']), 1)
        self.assertEqual(response.context['images'][0], image)

</source>
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_admin_views.py" startline="1039" endline="1060" pcid="5197">
    def test_construct_queryset_hook_search(self):
        image = Image.objects.create(
            title="Test image shown",
            file=get_test_image_file(),
            uploaded_by_user=self.user,
        )
        Image.objects.create(
            title="Test image not shown",
            file=get_test_image_file(),
        )

        def filter_images(images, request):
            # Filter on `uploaded_by_user` because it is
            # the only default FilterField in search_fields
            return images.filter(uploaded_by_user=self.user)

        with self.register_hook('construct_image_chooser_queryset', filter_images):
            response = self.get({'q': 'Test'})
        self.assertEqual(len(response.context['images']), 1)
        self.assertEqual(response.context['images'][0], image)


</source>
</class>

<class classid="234" nclones="2" nlines="11" similarity="90">
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_admin_views.py" startline="1206" endline="1221" pcid="5216">
    def test_select_format_flag_after_upload_form_error(self):
        submit_url = reverse('wagtailimages:chooser_upload') + '?select_format=true'
        response = self.client.post(submit_url, {
            'image-chooser-upload-title': "Test image",
            'image-chooser-upload-file': SimpleUploadedFile('not_an_image.txt', b'this is not an image'),
        })

        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'wagtailimages/chooser/upload_form.html')
        self.assertFormError(response, 'form', 'file', 'Upload a valid image. The file you uploaded was either not an image or a corrupted image.')

        # the action URL of the re-rendered form should include the select_format=true parameter
        # (NB the HTML in the response is embedded in a JS string, so need to escape accordingly)
        expected_action_attr = 'action=\\"%s\\"' % submit_url
        self.assertContains(response, expected_action_attr)

</source>
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_admin_views.py" startline="1222" endline="1240" pcid="5217">
    def test_select_format_flag_after_upload_form_error_bad_extension(self):
        """
        Check the error message is accruate for a valid imate bug invalid file extension.
        """
        submit_url = reverse('wagtailimages:chooser_upload') + '?select_format=true'
        response = self.client.post(submit_url, {
            'image-chooser-upload-title': "accidental markdown extension",
            'image-chooser-upload-file': SimpleUploadedFile('not-an-image.md', get_test_image_file().file.getvalue()),
        })

        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'wagtailimages/chooser/upload_form.html')
        self.assertFormError(response, 'form', 'file', 'Not a supported image format. Supported formats: GIF, JPEG, PNG, WEBP.')

        # the action URL of the re-rendered form should include the select_format=true parameter
        # (NB the HTML in the response is embedded in a JS string, so need to escape accordingly)
        expected_action_attr = 'action=\\"%s\\"' % submit_url
        self.assertContains(response, expected_action_attr)

</source>
</class>

<class classid="235" nclones="2" nlines="21" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_admin_views.py" startline="1386" endline="1409" pcid="5227">
    def test_add_error_max_file_size_escaped(self):
        url = reverse('wagtailimages:add_multiple')
        template_name = 'wagtailimages/multiple/add.html'
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, template_name)

        value = "Too big. <br/><br/><a href='/admin/images/add/'>Try this.</a>"
        response_content = force_str(response.content)
        self.assertNotIn(value, response_content)
        self.assertNotIn(escapejs(value), response_content)

        request = RequestFactory().get(url)
        request.user = self.user
        context = response.context_data.copy()
        context['error_max_file_size'] = mark_safe(force_str(value))
        data = render_to_string(
            template_name,
            context=context,
            request=request,
        )
        self.assertNotIn(value, data)
        self.assertIn(escapejs(value), data)

</source>
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_admin_views.py" startline="1410" endline="1433" pcid="5228">
    def test_add_error_accepted_file_types_escaped(self):
        url = reverse('wagtailimages:add_multiple')
        template_name = 'wagtailimages/multiple/add.html'
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, template_name)

        value = "Invalid image type. <a href='/help'>Get help.</a>"
        response_content = force_str(response.content)
        self.assertNotIn(value, response_content)
        self.assertNotIn(escapejs(value), response_content)

        request = RequestFactory().get(url)
        request.user = self.user
        context = response.context_data.copy()
        context['error_accepted_file_types'] = mark_safe(force_str(value))
        data = render_to_string(
            template_name,
            context=context,
            request=request,
        )
        self.assertNotIn(value, data)
        self.assertIn(escapejs(value), data)

</source>
</class>

<class classid="236" nclones="3" nlines="23" similarity="70">
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_admin_views.py" startline="1434" endline="1472" pcid="5229">
    def test_add_post(self):
        """
        This tests that a POST request to the add view saves the image and returns an edit form
        """
        response = self.client.post(reverse('wagtailimages:add_multiple'), {
            'title': 'test title',
            'files[]': SimpleUploadedFile('test.png', get_test_image_file().file.getvalue()),
        })

        # Check response
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response['Content-Type'], 'application/json')
        self.assertTemplateUsed(response, 'wagtailadmin/generic/multiple_upload/edit_form.html')

        # Check image
        self.assertIn('image', response.context)
        self.assertEqual(response.context['image'].title, 'test title')
        self.assertTrue(response.context['image'].file_size)
        self.assertTrue(response.context['image'].file_hash)

        # Check image title
        image = get_image_model().objects.get(title='test title')
        self.assertNotIn('title', image.filename)
        self.assertIn('.png', image.filename)

        # Check form
        self.assertIn('form', response.context)
        self.assertEqual(response.context['edit_action'], '/admin/images/multiple/%d/' % response.context['image'].id)
        self.assertEqual(response.context['delete_action'], '/admin/images/multiple/%d/delete/' % response.context['image'].id)
        self.assertEqual(response.context['form'].initial['title'], 'test title')

        # Check JSON
        response_json = json.loads(response.content.decode())
        self.assertIn('form', response_json)
        self.assertIn('image_id', response_json)
        self.assertIn('success', response_json)
        self.assertEqual(response_json['image_id'], response.context['image'].id)
        self.assertTrue(response_json['success'])

</source>
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_admin_views.py" startline="1686" endline="1718" pcid="5241">
    def test_add_post(self):
        """
        This tests that a POST request to the add view saves the image and returns an edit form
        """
        response = self.client.post(reverse('wagtailimages:add_multiple'), {
            'files[]': SimpleUploadedFile('test.png', get_test_image_file().file.getvalue()),
        })

        # Check response
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response['Content-Type'], 'application/json')
        self.assertTemplateUsed(response, 'wagtailadmin/generic/multiple_upload/edit_form.html')

        # Check image
        self.assertIn('image', response.context)
        self.assertEqual(response.context['image'].title, 'test.png')
        self.assertTrue(response.context['image'].file_size)
        self.assertTrue(response.context['image'].file_hash)

        # Check form
        self.assertIn('form', response.context)
        self.assertEqual(response.context['form'].initial['title'], 'test.png')
        self.assertIn('caption', response.context['form'].fields)
        self.assertNotIn('not_editable_field', response.context['form'].fields)
        self.assertEqual(response.context['edit_action'], '/admin/images/multiple/%d/' % response.context['image'].id)
        self.assertEqual(response.context['delete_action'], '/admin/images/multiple/%d/delete/' % response.context['image'].id)

        # Check JSON
        response_json = json.loads(response.content.decode())
        self.assertIn('form', response_json)
        self.assertIn('success', response_json)
        self.assertTrue(response_json['success'])

</source>
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_admin_views.py" startline="1888" endline="1928" pcid="5249">
    def test_add_post(self):
        """
        A POST request to the add view should create an UploadedImage rather than an image,
        as we do not have enough data to pass CustomImageWithAuthor's validation yet
        """
        image_count_before = CustomImageWithAuthor.objects.count()
        uploaded_image_count_before = UploadedImage.objects.count()

        response = self.client.post(reverse('wagtailimages:add_multiple'), {
            'files[]': SimpleUploadedFile('test.png', get_test_image_file().file.getvalue()),
        })

        image_count_after = CustomImageWithAuthor.objects.count()
        uploaded_image_count_after = UploadedImage.objects.count()

        # an UploadedImage should have been created now, but not a CustomImageWithAuthor
        self.assertEqual(image_count_after, image_count_before)
        self.assertEqual(uploaded_image_count_after, uploaded_image_count_before + 1)

        # Check response
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response['Content-Type'], 'application/json')
        self.assertTemplateUsed(response, 'wagtailadmin/generic/multiple_upload/edit_form.html')

        # Check image
        self.assertIn('uploaded_image', response.context)
        self.assertTrue(response.context['uploaded_image'].file.name)

        # Check form
        self.assertIn('form', response.context)
        self.assertEqual(response.context['form'].initial['title'], 'test.png')
        self.assertIn('author', response.context['form'].fields)
        self.assertEqual(response.context['edit_action'], '/admin/images/multiple/create_from_uploaded_image/%d/' % response.context['uploaded_image'].id)
        self.assertEqual(response.context['delete_action'], '/admin/images/multiple/delete_upload/%d/' % response.context['uploaded_image'].id)

        # Check JSON
        response_json = json.loads(response.content.decode())
        self.assertIn('form', response_json)
        self.assertIn('success', response_json)
        self.assertTrue(response_json['success'])

</source>
</class>

<class classid="237" nclones="4" nlines="14" similarity="92">
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_admin_views.py" startline="1513" endline="1535" pcid="5232">
    def test_add_post_badfile(self):
        """
        The add view must check that the uploaded file is a valid image
        """
        response = self.client.post(reverse('wagtailimages:add_multiple'), {
            'files[]': SimpleUploadedFile('test.png', b"This is not an image!"),
        })

        # Check response
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response['Content-Type'], 'application/json')

        # Check JSON
        response_json = json.loads(response.content.decode())
        self.assertNotIn('image_id', response_json)
        self.assertNotIn('form', response_json)
        self.assertIn('success', response_json)
        self.assertIn('error_message', response_json)
        self.assertFalse(response_json['success'])
        self.assertEqual(
            response_json['error_message'], 'Upload a valid image. The file you uploaded was either not an image or a corrupted image.'
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_admin_views.py" startline="1536" endline="1558" pcid="5233">
    def test_add_post_bad_extension(self):
        """
        The add view must check that the uploaded file extension is a valid
        """
        response = self.client.post(reverse('wagtailimages:add_multiple'), {
            'files[]': SimpleUploadedFile('test.txt', get_test_image_file().file.getvalue()),
        })

        # Check response
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response['Content-Type'], 'application/json')

        # Check JSON
        response_json = json.loads(response.content.decode())
        self.assertNotIn('image_id', response_json)
        self.assertNotIn('form', response_json)
        self.assertIn('success', response_json)
        self.assertIn('error_message', response_json)
        self.assertFalse(response_json['success'])
        self.assertEqual(
            response_json['error_message'], 'Not a supported image format. Supported formats: GIF, JPEG, PNG, WEBP.'
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_admin_views.py" startline="1719" endline="1741" pcid="5242">
    def test_add_post_badfile(self):
        """
        The add view must check that the uploaded file is a valid image
        """
        response = self.client.post(reverse('wagtailimages:add_multiple'), {
            'files[]': SimpleUploadedFile('test.png', b"This is not an image!"),
        })

        # Check response
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response['Content-Type'], 'application/json')

        # Check JSON
        response_json = json.loads(response.content.decode())
        self.assertNotIn('image_id', response_json)
        self.assertNotIn('form', response_json)
        self.assertIn('success', response_json)
        self.assertIn('error_message', response_json)
        self.assertFalse(response_json['success'])
        self.assertEqual(
            response_json['error_message'], 'Upload a valid image. The file you uploaded was either not an image or a corrupted image.'
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_admin_views.py" startline="1929" endline="1951" pcid="5250">
    def test_add_post_badfile(self):
        """
        The add view must check that the uploaded file is a valid image
        """
        response = self.client.post(reverse('wagtailimages:add_multiple'), {
            'files[]': SimpleUploadedFile('test.png', b"This is not an image!"),
        })

        # Check response
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response['Content-Type'], 'application/json')

        # Check JSON
        response_json = json.loads(response.content.decode())
        self.assertNotIn('image_id', response_json)
        self.assertNotIn('form', response_json)
        self.assertIn('success', response_json)
        self.assertIn('error_message', response_json)
        self.assertFalse(response_json['success'])
        self.assertEqual(
            response_json['error_message'], "Upload a valid image. The file you uploaded was either not an image or a corrupted image."
        )

</source>
</class>

<class classid="238" nclones="3" nlines="16" similarity="81">
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_admin_views.py" startline="1569" endline="1595" pcid="5235">
    def test_edit_post(self):
        """
        This tests that a POST request to the edit view edits the image
        """
        # Send request
        response = self.client.post(reverse('wagtailimages:edit_multiple', args=(self.image.id, )), {
            ('image-%d-title' % self.image.id): "New title!",
            ('image-%d-tags' % self.image.id): "cromarty, finisterre",
        })

        # Check response
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response['Content-Type'], 'application/json')

        # Check JSON
        response_json = json.loads(response.content.decode())
        self.assertIn('image_id', response_json)
        self.assertNotIn('form', response_json)
        self.assertIn('success', response_json)
        self.assertEqual(response_json['image_id'], self.image.id)
        self.assertTrue(response_json['success'])

        # test that changes have been applied to the image
        image = Image.objects.get(id=self.image.id)
        self.assertEqual(image.title, "New title!")
        self.assertIn('cromarty', image.tags.names())

</source>
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_admin_views.py" startline="1596" endline="1622" pcid="5236">
    def test_edit_post_validation_error(self):
        """
        This tests that a POST request to the edit page returns a json document with "success=False"
        and a form with the validation error indicated
        """
        # Send request
        response = self.client.post(reverse('wagtailimages:edit_multiple', args=(self.image.id, )), {
            ('image-%d-title' % self.image.id): "",  # Required
            ('image-%d-tags' % self.image.id): "",
        })

        # Check response
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response['Content-Type'], 'application/json')
        self.assertTemplateUsed(response, 'wagtailadmin/generic/multiple_upload/edit_form.html')

        # Check that a form error was raised
        self.assertFormError(response, 'form', 'title', "This field is required.")

        # Check JSON
        response_json = json.loads(response.content.decode())
        self.assertIn('image_id', response_json)
        self.assertIn('form', response_json)
        self.assertIn('success', response_json)
        self.assertEqual(response_json['image_id'], self.image.id)
        self.assertFalse(response_json['success'])

</source>
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_admin_views.py" startline="1772" endline="1800" pcid="5244">
    def test_edit_post(self):
        """
        This tests that a POST request to the edit view edits the image
        """
        # Send request
        response = self.client.post(reverse('wagtailimages:edit_multiple', args=(self.image.id, )), {
            ('image-%d-title' % self.image.id): "New title!",
            ('image-%d-tags' % self.image.id): "footwear, dystopia",
            ('image-%d-caption' % self.image.id): "a boot stamping on a human face, forever",
        })

        # Check response
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response['Content-Type'], 'application/json')

        # Check JSON
        response_json = json.loads(response.content.decode())
        self.assertIn('image_id', response_json)
        self.assertNotIn('form', response_json)
        self.assertIn('success', response_json)
        self.assertEqual(response_json['image_id'], self.image.id)
        self.assertTrue(response_json['success'])

        # check that image has been updated
        new_image = CustomImage.objects.get(id=self.image.id)
        self.assertEqual(new_image.title, "New title!")
        self.assertEqual(new_image.caption, "a boot stamping on a human face, forever")
        self.assertIn('footwear', new_image.tags.names())

</source>
</class>

<class classid="239" nclones="2" nlines="12" similarity="91">
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_admin_views.py" startline="1633" endline="1656" pcid="5238">
    def test_delete_post(self):
        """
        This tests that a POST request to the delete view deletes the image
        """
        # Send request
        response = self.client.post(reverse(
            'wagtailimages:delete_multiple', args=(self.image.id, )
        ))

        # Check response
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response['Content-Type'], 'application/json')

        # Make sure the image is deleted
        self.assertFalse(Image.objects.filter(id=self.image.id).exists())

        # Check JSON
        response_json = json.loads(response.content.decode())
        self.assertIn('image_id', response_json)
        self.assertIn('success', response_json)
        self.assertEqual(response_json['image_id'], self.image.id)
        self.assertTrue(response_json['success'])


</source>
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_admin_views.py" startline="1835" endline="1861" pcid="5246">
    def test_delete_post(self):
        """
        This tests that a POST request to the delete view deletes the image
        """
        # Send request
        response = self.client.post(reverse(
            'wagtailimages:delete_multiple', args=(self.image.id, )
        ))

        # Check response
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response['Content-Type'], 'application/json')

        # Make sure the image is deleted
        self.assertFalse(Image.objects.filter(id=self.image.id).exists())

        # Check JSON
        response_json = json.loads(response.content.decode())
        self.assertIn('image_id', response_json)
        self.assertIn('success', response_json)
        self.assertEqual(response_json['image_id'], self.image.id)
        self.assertTrue(response_json['success'])

        # check that image has been deleted
        self.assertEqual(CustomImage.objects.filter(id=self.image.id).count(), 0)


</source>
</class>

<class classid="240" nclones="9" nlines="10" similarity="90">
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_image_operations.py" startline="546" endline="559" pcid="5314">
    def test_webp_lossless(self):
        fil = Filter(spec='width-400|format-webp-lossless')
        image = Image.objects.create(
            title="Test image",
            file=get_test_image_file(),
        )

        f = BytesIO()
        with patch('PIL.Image.Image.save') as save:
            fil.run(image, f)

        # quality=80 is default for Williw and PIL libs
        save.assert_called_with(f, 'WEBP', quality=80, lossless=True)

</source>
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_image_operations.py" startline="654" endline="666" pcid="5323">
    def test_default_quality(self):
        fil = Filter(spec='width-400|format-webp')
        image = Image.objects.create(
            title="Test image",
            file=get_test_image_file_jpeg(),
        )

        f = BytesIO()
        with patch('PIL.Image.Image.save') as save:
            fil.run(image, f)

        save.assert_called_with(f, 'WEBP', quality=85, lossless=False)

</source>
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_image_operations.py" startline="623" endline="635" pcid="5321">
    def test_jpeg_quality_setting(self):
        fil = Filter(spec='width-400')
        image = Image.objects.create(
            title="Test image",
            file=get_test_image_file_jpeg(),
        )

        f = BytesIO()
        with patch('PIL.Image.Image.save') as save:
            fil.run(image, f)

        save.assert_called_with(f, 'JPEG', quality=50, optimize=True, progressive=True)

</source>
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_image_operations.py" startline="707" endline="719" pcid="5328">
    def test_webp_quality_setting(self):
        fil = Filter(spec='width-400|format-webp')
        image = Image.objects.create(
            title="Test image",
            file=get_test_image_file_jpeg(),
        )

        f = BytesIO()
        with patch('PIL.Image.Image.save') as save:
            fil.run(image, f)

        save.assert_called_with(f, 'WEBP', quality=50, lossless=False)

</source>
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_image_operations.py" startline="667" endline="679" pcid="5324">
    def test_webp_quality_filter(self):
        fil = Filter(spec='width-400|webpquality-40|format-webp')
        image = Image.objects.create(
            title="Test image",
            file=get_test_image_file_jpeg(),
        )

        f = BytesIO()
        with patch('PIL.Image.Image.save') as save:
            fil.run(image, f)

        save.assert_called_with(f, 'WEBP', quality=40, lossless=False)

</source>
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_image_operations.py" startline="723" endline="736" pcid="5329">
    def test_jpeg_quality_filter_overrides_setting(self):
        fil = Filter(spec='width-400|webpquality-40|format-webp')
        image = Image.objects.create(
            title="Test image",
            file=get_test_image_file_jpeg(),
        )

        f = BytesIO()
        with patch('PIL.Image.Image.save') as save:
            fil.run(image, f)

        save.assert_called_with(f, 'WEBP', quality=40, lossless=False)


</source>
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_image_operations.py" startline="583" endline="595" pcid="5317">
    def test_jpeg_quality_filter(self):
        fil = Filter(spec='width-400|jpegquality-40')
        image = Image.objects.create(
            title="Test image",
            file=get_test_image_file_jpeg(),
        )

        f = BytesIO()
        with patch('PIL.Image.Image.save') as save:
            fil.run(image, f)

        save.assert_called_with(f, 'JPEG', quality=40, optimize=True, progressive=True)

</source>
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_image_operations.py" startline="639" endline="652" pcid="5322">
    def test_jpeg_quality_filter_overrides_setting(self):
        fil = Filter(spec='width-400|jpegquality-40')
        image = Image.objects.create(
            title="Test image",
            file=get_test_image_file_jpeg(),
        )

        f = BytesIO()
        with patch('PIL.Image.Image.save') as save:
            fil.run(image, f)

        save.assert_called_with(f, 'JPEG', quality=40, optimize=True, progressive=True)


</source>
<source file="systems/wagtail-2.16.1/wagtail/images/tests/test_image_operations.py" startline="570" endline="582" pcid="5316">
    def test_default_quality(self):
        fil = Filter(spec='width-400')
        image = Image.objects.create(
            title="Test image",
            file=get_test_image_file_jpeg(),
        )

        f = BytesIO()
        with patch('PIL.Image.Image.save') as save:
            fil.run(image, f)

        save.assert_called_with(f, 'JPEG', quality=85, optimize=True, progressive=True)

</source>
</class>

<class classid="241" nclones="2" nlines="12" similarity="83">
<source file="systems/wagtail-2.16.1/wagtail/search/tests/elasticsearch_common_tests.py" startline="65" endline="81" pcid="5583">
    def test_ascii_folding(self):
        book = models.Book.objects.create(
            title="ll",
            publication_date=date(2017, 10, 19),
            number_of_pages=1
        )

        index = self.backend.get_index_for_model(models.Book)
        index.add_item(book)
        index.refresh()

        results = self.backend.search("Hello", models.Book)

        self.assertUnsortedListEqual([r.title for r in results], [
            "ll"
        ])

</source>
<source file="systems/wagtail-2.16.1/wagtail/search/tests/elasticsearch_common_tests.py" startline="95" endline="116" pcid="5585">
    def test_search_with_hyphen(self):
        """
        This tests that punctuation characters are treated the same
        way in both indexing and querying.

        See: https://github.com/wagtail/wagtail/issues/937
        """
        book = models.Book.objects.create(
            title="Harry Potter and the Half-Blood Prince",
            publication_date=date(2009, 7, 15),
            number_of_pages=607
        )

        index = self.backend.get_index_for_model(models.Book)
        index.add_item(book)
        index.refresh()

        results = self.backend.search("Half-Blood", models.Book)
        self.assertUnsortedListEqual([r.title for r in results], [
            "Harry Potter and the Half-Blood Prince",
        ])

</source>
</class>

<class classid="242" nclones="3" nlines="18" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_elasticsearch5_backend.py" startline="365" endline="387" pcid="5636">
    def construct_search_response(self, results):
        return {
            '_shards': {'failed': 0, 'successful': 5, 'total': 5},
            'hits': {
                'hits': [
                    {
                        '_id': 'searchtests_book:' + str(result),
                        '_index': 'wagtail',
                        '_score': 1,
                        '_type': 'searchtests_book',
                        'fields': {
                            'pk': [str(result)],
                        }
                    }
                    for result in results
                ],
                'max_score': 1,
                'total': len(results)
            },
            'timed_out': False,
            'took': 2
        }

</source>
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_elasticsearch7_backend.py" startline="365" endline="387" pcid="5713">
    def construct_search_response(self, results):
        return {
            '_shards': {'failed': 0, 'successful': 5, 'total': 5},
            'hits': {
                'hits': [
                    {
                        '_id': 'searchtests_book:' + str(result),
                        '_index': 'wagtail',
                        '_score': 1,
                        '_type': 'searchtests_book',
                        'fields': {
                            'pk': [str(result)],
                        }
                    }
                    for result in results
                ],
                'max_score': 1,
                'total': len(results)
            },
            'timed_out': False,
            'took': 2
        }

</source>
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_elasticsearch6_backend.py" startline="365" endline="387" pcid="5780">
    def construct_search_response(self, results):
        return {
            '_shards': {'failed': 0, 'successful': 5, 'total': 5},
            'hits': {
                'hits': [
                    {
                        '_id': 'searchtests_book:' + str(result),
                        '_index': 'wagtail',
                        '_score': 1,
                        '_type': 'searchtests_book',
                        'fields': {
                            'pk': [str(result)],
                        }
                    }
                    for result in results
                ],
                'max_score': 1,
                'total': len(results)
            },
            'timed_out': False,
            'took': 2
        }

</source>
</class>

<class classid="243" nclones="15" nlines="11" similarity="72">
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_elasticsearch5_backend.py" startline="389" endline="403" pcid="5637">
    def test_basic_search(self, search):
        search.return_value = self.construct_search_response([])
        results = self.get_results()

        list(results)  # Performs search

        search.assert_any_call(
            body={'query': 'QUERY'},
            _source=False,
            stored_fields='pk',
            index='wagtail__searchtests_book',
            scroll='2m',
            size=100
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_elasticsearch7_backend.py" startline="438" endline="452" pcid="5717">
    def test_slice_results_multiple_times(self, search):
        search.return_value = self.construct_search_response([])
        results = self.get_results()[10:][:10]

        list(results)  # Performs search

        search.assert_any_call(
            from_=10,
            body={'query': 'QUERY'},
            _source=False,
            stored_fields='pk',
            index='wagtail__searchtests_book',
            size=10
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_elasticsearch6_backend.py" startline="389" endline="403" pcid="5781">
    def test_basic_search(self, search):
        search.return_value = self.construct_search_response([])
        results = self.get_results()

        list(results)  # Performs search

        search.assert_any_call(
            body={'query': 'QUERY'},
            _source=False,
            stored_fields='pk',
            index='wagtail__searchtests_book',
            scroll='2m',
            size=100
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_elasticsearch6_backend.py" startline="405" endline="420" pcid="5782">
    def test_get_single_item(self, search):
        # Need to return something to prevent index error
        search.return_value = self.construct_search_response([1])
        results = self.get_results()

        results[10]  # Performs search

        search.assert_any_call(
            from_=10,
            body={'query': 'QUERY'},
            _source=False,
            stored_fields='pk',
            index='wagtail__searchtests_book',
            size=1
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_elasticsearch5_backend.py" startline="405" endline="420" pcid="5638">
    def test_get_single_item(self, search):
        # Need to return something to prevent index error
        search.return_value = self.construct_search_response([1])
        results = self.get_results()

        results[10]  # Performs search

        search.assert_any_call(
            from_=10,
            body={'query': 'QUERY'},
            _source=False,
            stored_fields='pk',
            index='wagtail__searchtests_book',
            size=1
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_elasticsearch7_backend.py" startline="422" endline="436" pcid="5716">
    def test_slice_results(self, search):
        search.return_value = self.construct_search_response([])
        results = self.get_results()[1:4]

        list(results)  # Performs search

        search.assert_any_call(
            from_=1,
            body={'query': 'QUERY'},
            _source=False,
            stored_fields='pk',
            index='wagtail__searchtests_book',
            size=3
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_elasticsearch5_backend.py" startline="422" endline="436" pcid="5639">
    def test_slice_results(self, search):
        search.return_value = self.construct_search_response([])
        results = self.get_results()[1:4]

        list(results)  # Performs search

        search.assert_any_call(
            from_=1,
            body={'query': 'QUERY'},
            _source=False,
            stored_fields='pk',
            index='wagtail__searchtests_book',
            size=3
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_elasticsearch7_backend.py" startline="405" endline="420" pcid="5715">
    def test_get_single_item(self, search):
        # Need to return something to prevent index error
        search.return_value = self.construct_search_response([1])
        results = self.get_results()

        results[10]  # Performs search

        search.assert_any_call(
            from_=10,
            body={'query': 'QUERY'},
            _source=False,
            stored_fields='pk',
            index='wagtail__searchtests_book',
            size=1
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_elasticsearch6_backend.py" startline="438" endline="452" pcid="5784">
    def test_slice_results_multiple_times(self, search):
        search.return_value = self.construct_search_response([])
        results = self.get_results()[10:][:10]

        list(results)  # Performs search

        search.assert_any_call(
            from_=10,
            body={'query': 'QUERY'},
            _source=False,
            stored_fields='pk',
            index='wagtail__searchtests_book',
            size=10
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_elasticsearch6_backend.py" startline="422" endline="436" pcid="5783">
    def test_slice_results(self, search):
        search.return_value = self.construct_search_response([])
        results = self.get_results()[1:4]

        list(results)  # Performs search

        search.assert_any_call(
            from_=1,
            body={'query': 'QUERY'},
            _source=False,
            stored_fields='pk',
            index='wagtail__searchtests_book',
            size=3
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_elasticsearch5_backend.py" startline="438" endline="452" pcid="5640">
    def test_slice_results_multiple_times(self, search):
        search.return_value = self.construct_search_response([])
        results = self.get_results()[10:][:10]

        list(results)  # Performs search

        search.assert_any_call(
            from_=10,
            body={'query': 'QUERY'},
            _source=False,
            stored_fields='pk',
            index='wagtail__searchtests_book',
            size=10
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_elasticsearch7_backend.py" startline="389" endline="403" pcid="5714">
    def test_basic_search(self, search):
        search.return_value = self.construct_search_response([])
        results = self.get_results()

        list(results)  # Performs search

        search.assert_any_call(
            body={'query': 'QUERY'},
            _source=False,
            stored_fields='pk',
            index='wagtail__searchtests_book',
            scroll='2m',
            size=100
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_elasticsearch6_backend.py" startline="454" endline="469" pcid="5785">
    def test_slice_results_and_get_item(self, search):
        # Need to return something to prevent index error
        search.return_value = self.construct_search_response([1])
        results = self.get_results()[10:]

        results[10]  # Performs search

        search.assert_any_call(
            from_=20,
            body={'query': 'QUERY'},
            _source=False,
            stored_fields='pk',
            index='wagtail__searchtests_book',
            size=1
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_elasticsearch5_backend.py" startline="454" endline="469" pcid="5641">
    def test_slice_results_and_get_item(self, search):
        # Need to return something to prevent index error
        search.return_value = self.construct_search_response([1])
        results = self.get_results()[10:]

        results[10]  # Performs search

        search.assert_any_call(
            from_=20,
            body={'query': 'QUERY'},
            _source=False,
            stored_fields='pk',
            index='wagtail__searchtests_book',
            size=1
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_elasticsearch7_backend.py" startline="454" endline="469" pcid="5718">
    def test_slice_results_and_get_item(self, search):
        # Need to return something to prevent index error
        search.return_value = self.construct_search_response([1])
        results = self.get_results()[10:]

        results[10]  # Performs search

        search.assert_any_call(
            from_=20,
            body={'query': 'QUERY'},
            _source=False,
            stored_fields='pk',
            index='wagtail__searchtests_book',
            size=1
        )

</source>
</class>

<class classid="244" nclones="2" nlines="37" similarity="73">
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_elasticsearch5_backend.py" startline="542" endline="580" pcid="5651">
    def test_get_mapping(self):
        # Build mapping
        mapping = self.es_mapping.get_mapping()

        # Check
        expected_result = {
            'searchtests_book': {
                'properties': {
                    'pk': {'type': 'keyword', 'store': True, 'include_in_all': False},
                    'content_type': {'type': 'keyword', 'include_in_all': False},
                    '_partials': {'analyzer': 'edgengram_analyzer', 'search_analyzer': 'standard', 'include_in_all': False, 'type': 'text'},
                    'title': {'type': 'text', 'boost': 2.0, 'include_in_all': True, 'analyzer': 'edgengram_analyzer', 'search_analyzer': 'standard'},
                    'title_edgengrams': {'type': 'text', 'include_in_all': False, 'analyzer': 'edgengram_analyzer', 'search_analyzer': 'standard'},
                    'title_filter': {'type': 'keyword', 'include_in_all': False},
                    'authors': {
                        'type': 'nested',
                        'properties': {
                            'name': {'type': 'text', 'include_in_all': True},
                            'name_edgengrams': {'analyzer': 'edgengram_analyzer', 'include_in_all': False, 'search_analyzer': 'standard', 'type': 'text'},
                            'date_of_birth_filter': {'type': 'date', 'include_in_all': False},
                        },
                    },
                    'authors_filter': {'type': 'integer', 'include_in_all': False},
                    'publication_date_filter': {'type': 'date', 'include_in_all': False},
                    'number_of_pages_filter': {'type': 'integer', 'include_in_all': False},
                    'tags': {
                        'type': 'nested',
                        'properties': {
                            'name': {'type': 'text', 'include_in_all': True},
                            'slug_filter': {'type': 'keyword', 'include_in_all': False},
                        },
                    },
                    'tags_filter': {'type': 'integer', 'include_in_all': False}
                }
            }
        }

        self.assertDictEqual(mapping, expected_result)

</source>
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_elasticsearch5_backend.py" startline="635" endline="691" pcid="5657">
    def test_get_mapping(self):
        # Build mapping
        mapping = self.es_mapping.get_mapping()

        # Check
        expected_result = {
            'searchtests_book_searchtests_novel': {
                'properties': {
                    # New
                    'searchtests_novel__setting': {'type': 'text', 'include_in_all': True, 'analyzer': 'edgengram_analyzer', 'search_analyzer': 'standard'},
                    'searchtests_novel__protagonist': {
                        'type': 'nested',
                        'properties': {
                            'name': {'type': 'text', 'boost': 0.5, 'include_in_all': True},
                            'novel_id_filter': {'type': 'integer', 'include_in_all': False}
                        }
                    },
                    'searchtests_novel__protagonist_id_filter': {'type': 'integer', 'include_in_all': False},
                    'searchtests_novel__characters': {
                        'type': 'nested',
                        'properties': {
                            'name': {'type': 'text', 'boost': 0.25, 'include_in_all': True}
                        }
                    },

                    # Inherited
                    'pk': {'type': 'keyword', 'store': True, 'include_in_all': False},
                    'content_type': {'type': 'keyword', 'include_in_all': False},
                    '_partials': {'analyzer': 'edgengram_analyzer', 'search_analyzer': 'standard', 'include_in_all': False, 'type': 'text'},
                    'title': {'type': 'text', 'boost': 2.0, 'include_in_all': True, 'analyzer': 'edgengram_analyzer', 'search_analyzer': 'standard'},
                    'title_edgengrams': {'type': 'text', 'include_in_all': False, 'analyzer': 'edgengram_analyzer', 'search_analyzer': 'standard'},
                    'title_filter': {'type': 'keyword', 'include_in_all': False},
                    'authors': {
                        'type': 'nested',
                        'properties': {
                            'name': {'type': 'text', 'include_in_all': True},
                            'name_edgengrams': {'analyzer': 'edgengram_analyzer', 'include_in_all': False, 'search_analyzer': 'standard', 'type': 'text'},
                            'date_of_birth_filter': {'type': 'date', 'include_in_all': False},
                        },
                    },
                    'authors_filter': {'type': 'integer', 'include_in_all': False},
                    'publication_date_filter': {'type': 'date', 'include_in_all': False},
                    'number_of_pages_filter': {'type': 'integer', 'include_in_all': False},
                    'tags': {
                        'type': 'nested',
                        'properties': {
                            'name': {'type': 'text', 'include_in_all': True},
                            'slug_filter': {'type': 'keyword', 'include_in_all': False},
                        },
                    },
                    'tags_filter': {'type': 'integer', 'include_in_all': False}
                }
            }
        }

        self.assertDictEqual(mapping, expected_result)

</source>
</class>

<class classid="245" nclones="3" nlines="22" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_elasticsearch5_backend.py" startline="584" endline="616" pcid="5653">
    def test_get_document(self):
        # Get document
        document = self.es_mapping.get_document(self.obj)

        # Sort partials
        if '_partials' in document:
            document['_partials'].sort()

        # Check
        expected_result = {
            'pk': '4',
            'content_type': ["searchtests.Book"],
            '_partials': ['J. R. R. Tolkien', 'The Fellowship of the Ring', 'The Fellowship of the Ring'],
            'title': 'The Fellowship of the Ring',
            'title_edgengrams': 'The Fellowship of the Ring',
            'title_filter': 'The Fellowship of the Ring',
            'authors': [
                {
                    'name': 'J. R. R. Tolkien',
                    'name_edgengrams': 'J. R. R. Tolkien',
                    'date_of_birth_filter': datetime.date(1892, 1, 3)
                }
            ],
            'authors_filter': [2],
            'publication_date_filter': datetime.date(1954, 7, 29),
            'number_of_pages_filter': 423,
            'tags': [],
            'tags_filter': []
        }

        self.assertDictEqual(document, expected_result)


</source>
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_elasticsearch7_backend.py" startline="583" endline="615" pcid="5730">
    def test_get_document(self):
        # Get document
        document = self.es_mapping.get_document(self.obj)

        # Sort edgengrams
        if '_edgengrams' in document:
            document['_edgengrams'].sort()

        # Check
        expected_result = {
            'pk': '4',
            'content_type': ["searchtests.Book"],
            '_edgengrams': ['J. R. R. Tolkien', 'The Fellowship of the Ring', 'The Fellowship of the Ring'],
            'title': 'The Fellowship of the Ring',
            'title_edgengrams': 'The Fellowship of the Ring',
            'title_filter': 'The Fellowship of the Ring',
            'authors': [
                {
                    'name': 'J. R. R. Tolkien',
                    'name_edgengrams': 'J. R. R. Tolkien',
                    'date_of_birth_filter': datetime.date(1892, 1, 3)
                }
            ],
            'authors_filter': [2],
            'publication_date_filter': datetime.date(1954, 7, 29),
            'number_of_pages_filter': 423,
            'tags': [],
            'tags_filter': []
        }

        self.assertDictEqual(document, expected_result)


</source>
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_elasticsearch6_backend.py" startline="585" endline="617" pcid="5797">
    def test_get_document(self):
        # Get document
        document = self.es_mapping.get_document(self.obj)

        # Sort edgengrams
        if '_edgengrams' in document:
            document['_edgengrams'].sort()

        # Check
        expected_result = {
            'pk': '4',
            'content_type': ["searchtests.Book"],
            '_edgengrams': ['J. R. R. Tolkien', 'The Fellowship of the Ring', 'The Fellowship of the Ring'],
            'title': 'The Fellowship of the Ring',
            'title_edgengrams': 'The Fellowship of the Ring',
            'title_filter': 'The Fellowship of the Ring',
            'authors': [
                {
                    'name': 'J. R. R. Tolkien',
                    'name_edgengrams': 'J. R. R. Tolkien',
                    'date_of_birth_filter': datetime.date(1892, 1, 3)
                }
            ],
            'authors_filter': [2],
            'publication_date_filter': datetime.date(1954, 7, 29),
            'number_of_pages_filter': 423,
            'tags': [],
            'tags_filter': []
        }

        self.assertDictEqual(document, expected_result)


</source>
</class>

<class classid="246" nclones="3" nlines="36" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_elasticsearch5_backend.py" startline="698" endline="756" pcid="5659">
    def test_get_document(self):
        # Build document
        document = self.es_mapping.get_document(self.obj)

        # Sort partials
        if '_partials' in document:
            document['_partials'].sort()

        # Sort characters
        if 'searchtests_novel__characters' in document:
            document['searchtests_novel__characters'].sort(key=lambda c: c['name'])

        # Check
        expected_result = {
            # New
            'searchtests_novel__setting': "Middle Earth",
            'searchtests_novel__protagonist': {
                'name': "Frodo Baggins",
                'novel_id_filter': 4
            },
            'searchtests_novel__protagonist_id_filter': 8,
            'searchtests_novel__characters': [
                {
                    'name': "Bilbo Baggins"
                },
                {
                    'name': "Frodo Baggins"
                },
                {
                    'name': "Gandalf"
                }
            ],

            # Changed
            'content_type': ["searchtests.Novel", "searchtests.Book"],
            '_partials': ['J. R. R. Tolkien', 'Middle Earth', 'The Fellowship of the Ring', 'The Fellowship of the Ring'],

            # Inherited
            'pk': '4',
            'title': 'The Fellowship of the Ring',
            'title_edgengrams': 'The Fellowship of the Ring',
            'title_filter': 'The Fellowship of the Ring',
            'authors': [
                {
                    'name': 'J. R. R. Tolkien',
                    'name_edgengrams': 'J. R. R. Tolkien',
                    'date_of_birth_filter': datetime.date(1892, 1, 3)
                }
            ],
            'authors_filter': [2],
            'publication_date_filter': datetime.date(1954, 7, 29),
            'number_of_pages_filter': 423,
            'tags': [],
            'tags_filter': []
        }

        self.assertDictEqual(document, expected_result)


</source>
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_elasticsearch6_backend.py" startline="700" endline="758" pcid="5803">
    def test_get_document(self):
        # Build document
        document = self.es_mapping.get_document(self.obj)

        # Sort edgengrams
        if '_edgengrams' in document:
            document['_edgengrams'].sort()

        # Sort characters
        if 'searchtests_novel__characters' in document:
            document['searchtests_novel__characters'].sort(key=lambda c: c['name'])

        # Check
        expected_result = {
            # New
            'searchtests_novel__setting': "Middle Earth",
            'searchtests_novel__protagonist': {
                'name': "Frodo Baggins",
                'novel_id_filter': 4
            },
            'searchtests_novel__protagonist_id_filter': 8,
            'searchtests_novel__characters': [
                {
                    'name': "Bilbo Baggins"
                },
                {
                    'name': "Frodo Baggins"
                },
                {
                    'name': "Gandalf"
                }
            ],

            # Changed
            'content_type': ["searchtests.Novel", "searchtests.Book"],
            '_edgengrams': ['J. R. R. Tolkien', 'Middle Earth', 'The Fellowship of the Ring', 'The Fellowship of the Ring'],

            # Inherited
            'pk': '4',
            'title': 'The Fellowship of the Ring',
            'title_edgengrams': 'The Fellowship of the Ring',
            'title_filter': 'The Fellowship of the Ring',
            'authors': [
                {
                    'name': 'J. R. R. Tolkien',
                    'name_edgengrams': 'J. R. R. Tolkien',
                    'date_of_birth_filter': datetime.date(1892, 1, 3)
                }
            ],
            'authors_filter': [2],
            'publication_date_filter': datetime.date(1954, 7, 29),
            'number_of_pages_filter': 423,
            'tags': [],
            'tags_filter': []
        }

        self.assertDictEqual(document, expected_result)


</source>
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_elasticsearch7_backend.py" startline="696" endline="754" pcid="5736">
    def test_get_document(self):
        # Build document
        document = self.es_mapping.get_document(self.obj)

        # Sort edgengrams
        if '_edgengrams' in document:
            document['_edgengrams'].sort()

        # Sort characters
        if 'searchtests_novel__characters' in document:
            document['searchtests_novel__characters'].sort(key=lambda c: c['name'])

        # Check
        expected_result = {
            # New
            'searchtests_novel__setting': "Middle Earth",
            'searchtests_novel__protagonist': {
                'name': "Frodo Baggins",
                'novel_id_filter': 4
            },
            'searchtests_novel__protagonist_id_filter': 8,
            'searchtests_novel__characters': [
                {
                    'name': "Bilbo Baggins"
                },
                {
                    'name': "Frodo Baggins"
                },
                {
                    'name': "Gandalf"
                }
            ],

            # Changed
            'content_type': ["searchtests.Novel", "searchtests.Book"],
            '_edgengrams': ['J. R. R. Tolkien', 'Middle Earth', 'The Fellowship of the Ring', 'The Fellowship of the Ring'],

            # Inherited
            'pk': '4',
            'title': 'The Fellowship of the Ring',
            'title_edgengrams': 'The Fellowship of the Ring',
            'title_filter': 'The Fellowship of the Ring',
            'authors': [
                {
                    'name': 'J. R. R. Tolkien',
                    'name_edgengrams': 'J. R. R. Tolkien',
                    'date_of_birth_filter': datetime.date(1892, 1, 3)
                }
            ],
            'authors_filter': [2],
            'publication_date_filter': datetime.date(1954, 7, 29),
            'number_of_pages_filter': 423,
            'tags': [],
            'tags_filter': []
        }

        self.assertDictEqual(document, expected_result)


</source>
</class>

<class classid="247" nclones="3" nlines="12" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_elasticsearch5_backend.py" startline="759" endline="775" pcid="5660">
    def test_default_settings(self, Elasticsearch):
        Elasticsearch5SearchBackend(params={})

        Elasticsearch.assert_called_with(
            hosts=[
                {
                    'host': 'localhost',
                    'port': 9200,
                    'url_prefix': '',
                    'use_ssl': False,
                    'verify_certs': False,
                    'http_auth': None
                }
            ],
            timeout=10
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_elasticsearch6_backend.py" startline="761" endline="777" pcid="5804">
    def test_default_settings(self, Elasticsearch):
        Elasticsearch6SearchBackend(params={})

        Elasticsearch.assert_called_with(
            hosts=[
                {
                    'host': 'localhost',
                    'port': 9200,
                    'url_prefix': '',
                    'use_ssl': False,
                    'verify_certs': False,
                    'http_auth': None
                }
            ],
            timeout=10
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_elasticsearch7_backend.py" startline="757" endline="773" pcid="5737">
    def test_default_settings(self, Elasticsearch):
        Elasticsearch7SearchBackend(params={})

        Elasticsearch.assert_called_with(
            hosts=[
                {
                    'host': 'localhost',
                    'port': 9200,
                    'url_prefix': '',
                    'use_ssl': False,
                    'verify_certs': False,
                    'http_auth': None
                }
            ],
            timeout=10
        )

</source>
</class>

<class classid="248" nclones="3" nlines="18" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_elasticsearch5_backend.py" startline="776" endline="799" pcid="5661">
    def test_hosts(self, Elasticsearch):
        Elasticsearch5SearchBackend(params={
            'HOSTS': [
                {
                    'host': '127.0.0.1',
                    'port': 9300,
                    'use_ssl': True,
                    'verify_certs': True,
                }
            ]
        })

        Elasticsearch.assert_called_with(
            hosts=[
                {
                    'host': '127.0.0.1',
                    'port': 9300,
                    'use_ssl': True,
                    'verify_certs': True,
                }
            ],
            timeout=10
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_elasticsearch6_backend.py" startline="778" endline="801" pcid="5805">
    def test_hosts(self, Elasticsearch):
        Elasticsearch6SearchBackend(params={
            'HOSTS': [
                {
                    'host': '127.0.0.1',
                    'port': 9300,
                    'use_ssl': True,
                    'verify_certs': True,
                }
            ]
        })

        Elasticsearch.assert_called_with(
            hosts=[
                {
                    'host': '127.0.0.1',
                    'port': 9300,
                    'use_ssl': True,
                    'verify_certs': True,
                }
            ],
            timeout=10
        )

</source>
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_elasticsearch7_backend.py" startline="774" endline="797" pcid="5738">
    def test_hosts(self, Elasticsearch):
        Elasticsearch7SearchBackend(params={
            'HOSTS': [
                {
                    'host': '127.0.0.1',
                    'port': 9300,
                    'use_ssl': True,
                    'verify_certs': True,
                }
            ]
        })

        Elasticsearch.assert_called_with(
            hosts=[
                {
                    'host': '127.0.0.1',
                    'port': 9300,
                    'use_ssl': True,
                    'verify_certs': True,
                }
            ],
            timeout=10
        )

</source>
</class>

<class classid="249" nclones="3" nlines="44" similarity="100">
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_elasticsearch5_backend.py" startline="800" endline="847" pcid="5662">
    def test_urls(self, Elasticsearch):
        # This test backwards compatibility with old URLS setting
        Elasticsearch5SearchBackend(params={
            'URLS': [
                'http://localhost:12345',
                'https://127.0.0.1:54321',
                'http://username:password@elasticsearch.mysite.com',
                'https://elasticsearch.mysite.com/hello',
            ],
        })

        Elasticsearch.assert_called_with(
            hosts=[
                {
                    'host': 'localhost',
                    'port': 12345,
                    'url_prefix': '',
                    'use_ssl': False,
                    'verify_certs': False,
                    'http_auth': None,
                },
                {
                    'host': '127.0.0.1',
                    'port': 54321,
                    'url_prefix': '',
                    'use_ssl': True,
                    'verify_certs': True,
                    'http_auth': None,
                },
                {
                    'host': 'elasticsearch.mysite.com',
                    'port': 80,
                    'url_prefix': '',
                    'use_ssl': False,
                    'verify_certs': False,
                    'http_auth': ('username', 'password')
                },
                {
                    'host': 'elasticsearch.mysite.com',
                    'port': 443,
                    'url_prefix': '/hello',
                    'use_ssl': True,
                    'verify_certs': True,
                    'http_auth': None,
                },
            ],
            timeout=10
        )
</source>
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_elasticsearch7_backend.py" startline="798" endline="845" pcid="5739">
    def test_urls(self, Elasticsearch):
        # This test backwards compatibility with old URLS setting
        Elasticsearch7SearchBackend(params={
            'URLS': [
                'http://localhost:12345',
                'https://127.0.0.1:54321',
                'http://username:password@elasticsearch.mysite.com',
                'https://elasticsearch.mysite.com/hello',
            ],
        })

        Elasticsearch.assert_called_with(
            hosts=[
                {
                    'host': 'localhost',
                    'port': 12345,
                    'url_prefix': '',
                    'use_ssl': False,
                    'verify_certs': False,
                    'http_auth': None,
                },
                {
                    'host': '127.0.0.1',
                    'port': 54321,
                    'url_prefix': '',
                    'use_ssl': True,
                    'verify_certs': True,
                    'http_auth': None,
                },
                {
                    'host': 'elasticsearch.mysite.com',
                    'port': 80,
                    'url_prefix': '',
                    'use_ssl': False,
                    'verify_certs': False,
                    'http_auth': ('username', 'password')
                },
                {
                    'host': 'elasticsearch.mysite.com',
                    'port': 443,
                    'url_prefix': '/hello',
                    'use_ssl': True,
                    'verify_certs': True,
                    'http_auth': None,
                },
            ],
            timeout=10
        )
</source>
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_elasticsearch6_backend.py" startline="802" endline="849" pcid="5806">
    def test_urls(self, Elasticsearch):
        # This test backwards compatibility with old URLS setting
        Elasticsearch6SearchBackend(params={
            'URLS': [
                'http://localhost:12345',
                'https://127.0.0.1:54321',
                'http://username:password@elasticsearch.mysite.com',
                'https://elasticsearch.mysite.com/hello',
            ],
        })

        Elasticsearch.assert_called_with(
            hosts=[
                {
                    'host': 'localhost',
                    'port': 12345,
                    'url_prefix': '',
                    'use_ssl': False,
                    'verify_certs': False,
                    'http_auth': None,
                },
                {
                    'host': '127.0.0.1',
                    'port': 54321,
                    'url_prefix': '',
                    'use_ssl': True,
                    'verify_certs': True,
                    'http_auth': None,
                },
                {
                    'host': 'elasticsearch.mysite.com',
                    'port': 80,
                    'url_prefix': '',
                    'use_ssl': False,
                    'verify_certs': False,
                    'http_auth': ('username', 'password')
                },
                {
                    'host': 'elasticsearch.mysite.com',
                    'port': 443,
                    'url_prefix': '/hello',
                    'use_ssl': True,
                    'verify_certs': True,
                    'http_auth': None,
                },
            ],
            timeout=10
        )
</source>
</class>

<class classid="250" nclones="2" nlines="10" similarity="90">
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_index_functions.py" startline="81" endline="95" pcid="5671">
    def test_catches_index_error(self, backend):
        obj = models.Book.objects.create(title="Test", publication_date=date(2017, 10, 18), number_of_pages=100)

        backend().add.side_effect = ValueError("Test")
        backend().reset_mock()

        with self.assertLogs('wagtail.search.index', level='ERROR') as cm:
            index.insert_or_update_object(obj)

        self.assertEqual(len(cm.output), 1)
        self.assertIn("Exception raised while adding <Book: Test> into the 'default' search backend", cm.output[0])
        self.assertIn("Traceback (most recent call last):", cm.output[0])
        self.assertIn("ValueError: Test", cm.output[0])


</source>
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_index_functions.py" startline="119" endline="133" pcid="5674">
    def test_catches_index_error(self, backend):
        obj = models.Book.objects.create(title="Test", publication_date=date(2017, 10, 18), number_of_pages=100)
        backend().reset_mock()

        backend().delete.side_effect = ValueError("Test")

        with self.assertLogs('wagtail.search.index', level='ERROR') as cm:
            index.remove_object(obj)

        self.assertEqual(len(cm.output), 1)
        self.assertIn("Exception raised while deleting <Book: Test> from the 'default' search backend", cm.output[0])
        self.assertIn("Traceback (most recent call last):", cm.output[0])
        self.assertIn("ValueError: Test", cm.output[0])


</source>
</class>

<class classid="251" nclones="4" nlines="37" similarity="73">
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_elasticsearch7_backend.py" startline="542" endline="579" pcid="5728">
    def test_get_mapping(self):
        # Build mapping
        mapping = self.es_mapping.get_mapping()

        # Check
        expected_result = {
            'properties': {
                'pk': {'type': 'keyword', 'store': True},
                'content_type': {'type': 'keyword'},
                '_all_text': {'type': 'text'},
                '_edgengrams': {'analyzer': 'edgengram_analyzer', 'search_analyzer': 'standard', 'type': 'text'},
                'title': {'type': 'text', 'boost': 2.0, 'copy_to': '_all_text', 'analyzer': 'edgengram_analyzer', 'search_analyzer': 'standard'},
                'title_edgengrams': {'type': 'text', 'analyzer': 'edgengram_analyzer', 'search_analyzer': 'standard'},
                'title_filter': {'type': 'keyword'},
                'authors': {
                    'type': 'nested',
                    'properties': {
                        'name': {'type': 'text', 'copy_to': '_all_text'},
                        'name_edgengrams': {'analyzer': 'edgengram_analyzer', 'search_analyzer': 'standard', 'type': 'text'},
                        'date_of_birth_filter': {'type': 'date'},
                    },
                },
                'authors_filter': {'type': 'integer'},
                'publication_date_filter': {'type': 'date'},
                'number_of_pages_filter': {'type': 'integer'},
                'tags': {
                    'type': 'nested',
                    'properties': {
                        'name': {'type': 'text', 'copy_to': '_all_text'},
                        'slug_filter': {'type': 'keyword'},
                    },
                },
                'tags_filter': {'type': 'integer'}
            }
        }

        self.assertDictEqual(mapping, expected_result)

</source>
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_elasticsearch7_backend.py" startline="634" endline="689" pcid="5734">
    def test_get_mapping(self):
        # Build mapping
        mapping = self.es_mapping.get_mapping()

        # Check
        expected_result = {
            'properties': {
                # New
                'searchtests_novel__setting': {'type': 'text', 'copy_to': '_all_text', 'analyzer': 'edgengram_analyzer', 'search_analyzer': 'standard'},
                'searchtests_novel__protagonist': {
                    'type': 'nested',
                    'properties': {
                        'name': {'type': 'text', 'boost': 0.5, 'copy_to': '_all_text'},
                        'novel_id_filter': {'type': 'integer'}
                    }
                },
                'searchtests_novel__protagonist_id_filter': {'type': 'integer'},
                'searchtests_novel__characters': {
                    'type': 'nested',
                    'properties': {
                        'name': {'type': 'text', 'boost': 0.25, 'copy_to': '_all_text'}
                    }
                },

                # Inherited
                'pk': {'type': 'keyword', 'store': True},
                'content_type': {'type': 'keyword'},
                '_all_text': {'type': 'text'},
                '_edgengrams': {'analyzer': 'edgengram_analyzer', 'search_analyzer': 'standard', 'type': 'text'},
                'title': {'type': 'text', 'boost': 2.0, 'copy_to': '_all_text', 'analyzer': 'edgengram_analyzer', 'search_analyzer': 'standard'},
                'title_edgengrams': {'type': 'text', 'analyzer': 'edgengram_analyzer', 'search_analyzer': 'standard'},
                'title_filter': {'type': 'keyword'},
                'authors': {
                    'type': 'nested',
                    'properties': {
                        'name': {'type': 'text', 'copy_to': '_all_text'},
                        'name_edgengrams': {'analyzer': 'edgengram_analyzer', 'search_analyzer': 'standard', 'type': 'text'},
                        'date_of_birth_filter': {'type': 'date'},
                    },
                },
                'authors_filter': {'type': 'integer'},
                'publication_date_filter': {'type': 'date'},
                'number_of_pages_filter': {'type': 'integer'},
                'tags': {
                    'type': 'nested',
                    'properties': {
                        'name': {'type': 'text', 'copy_to': '_all_text'},
                        'slug_filter': {'type': 'keyword'},
                    },
                },
                'tags_filter': {'type': 'integer'}
            }
        }

        self.assertDictEqual(mapping, expected_result)

</source>
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_elasticsearch6_backend.py" startline="542" endline="581" pcid="5795">
    def test_get_mapping(self):
        # Build mapping
        mapping = self.es_mapping.get_mapping()

        # Check
        expected_result = {
            'doc': {
                'properties': {
                    'pk': {'type': 'keyword', 'store': True},
                    'content_type': {'type': 'keyword'},
                    '_all_text': {'type': 'text'},
                    '_edgengrams': {'analyzer': 'edgengram_analyzer', 'search_analyzer': 'standard', 'type': 'text'},
                    'title': {'type': 'text', 'boost': 2.0, 'copy_to': '_all_text', 'analyzer': 'edgengram_analyzer', 'search_analyzer': 'standard'},
                    'title_edgengrams': {'type': 'text', 'analyzer': 'edgengram_analyzer', 'search_analyzer': 'standard'},
                    'title_filter': {'type': 'keyword'},
                    'authors': {
                        'type': 'nested',
                        'properties': {
                            'name': {'type': 'text', 'copy_to': '_all_text'},
                            'name_edgengrams': {'analyzer': 'edgengram_analyzer', 'search_analyzer': 'standard', 'type': 'text'},
                            'date_of_birth_filter': {'type': 'date'},
                        },
                    },
                    'authors_filter': {'type': 'integer'},
                    'publication_date_filter': {'type': 'date'},
                    'number_of_pages_filter': {'type': 'integer'},
                    'tags': {
                        'type': 'nested',
                        'properties': {
                            'name': {'type': 'text', 'copy_to': '_all_text'},
                            'slug_filter': {'type': 'keyword'},
                        },
                    },
                    'tags_filter': {'type': 'integer'}
                }
            }
        }

        self.assertDictEqual(mapping, expected_result)

</source>
<source file="systems/wagtail-2.16.1/wagtail/search/tests/test_elasticsearch6_backend.py" startline="636" endline="693" pcid="5801">
    def test_get_mapping(self):
        # Build mapping
        mapping = self.es_mapping.get_mapping()

        # Check
        expected_result = {
            'doc': {
                'properties': {
                    # New
                    'searchtests_novel__setting': {'type': 'text', 'copy_to': '_all_text', 'analyzer': 'edgengram_analyzer', 'search_analyzer': 'standard'},
                    'searchtests_novel__protagonist': {
                        'type': 'nested',
                        'properties': {
                            'name': {'type': 'text', 'boost': 0.5, 'copy_to': '_all_text'},
                            'novel_id_filter': {'type': 'integer'}
                        }
                    },
                    'searchtests_novel__protagonist_id_filter': {'type': 'integer'},
                    'searchtests_novel__characters': {
                        'type': 'nested',
                        'properties': {
                            'name': {'type': 'text', 'boost': 0.25, 'copy_to': '_all_text'}
                        }
                    },

                    # Inherited
                    'pk': {'type': 'keyword', 'store': True},
                    'content_type': {'type': 'keyword'},
                    '_all_text': {'type': 'text'},
                    '_edgengrams': {'analyzer': 'edgengram_analyzer', 'search_analyzer': 'standard', 'type': 'text'},
                    'title': {'type': 'text', 'boost': 2.0, 'copy_to': '_all_text', 'analyzer': 'edgengram_analyzer', 'search_analyzer': 'standard'},
                    'title_edgengrams': {'type': 'text', 'analyzer': 'edgengram_analyzer', 'search_analyzer': 'standard'},
                    'title_filter': {'type': 'keyword'},
                    'authors': {
                        'type': 'nested',
                        'properties': {
                            'name': {'type': 'text', 'copy_to': '_all_text'},
                            'name_edgengrams': {'analyzer': 'edgengram_analyzer', 'search_analyzer': 'standard', 'type': 'text'},
                            'date_of_birth_filter': {'type': 'date'},
                        },
                    },
                    'authors_filter': {'type': 'integer'},
                    'publication_date_filter': {'type': 'date'},
                    'number_of_pages_filter': {'type': 'integer'},
                    'tags': {
                        'type': 'nested',
                        'properties': {
                            'name': {'type': 'text', 'copy_to': '_all_text'},
                            'slug_filter': {'type': 'keyword'},
                        },
                    },
                    'tags_filter': {'type': 'integer'}
                }
            }
        }

        self.assertDictEqual(mapping, expected_result)

</source>
</class>

<class classid="252" nclones="2" nlines="10" similarity="90">
<source file="systems/wagtail-2.16.1/wagtail/search/index.py" startline="149" endline="170" pcid="5853">
def insert_or_update_object(instance):
    indexed_instance = get_indexed_instance(instance)

    if indexed_instance:
        for backend_name, backend in get_search_backends_with_name(with_auto_update=True):
            try:
                backend.add(indexed_instance)
            except Exception:
                # Log all errors
                logger.exception("Exception raised while adding %r into the '%s' search backend", indexed_instance, backend_name)

                # Catch exceptions for backends that use an external service like Elasticsearch
                # This is to prevent data loss if that external service was to go down and the user's
                # save request was to fail.
                # But note that we don't want this for database backends though as an error during a
                # database transaction will require the transaction to be rolled back anyway. So If
                # we caught the error here, the request will only crash again when the next database
                # query is made but then the error message wouldn't be very informative.
                if not backend.catch_indexing_errors:
                    raise


</source>
<source file="systems/wagtail-2.16.1/wagtail/search/index.py" startline="171" endline="187" pcid="5854">
def remove_object(instance):
    indexed_instance = get_indexed_instance(instance, check_exists=False)

    if indexed_instance:
        for backend_name, backend in get_search_backends_with_name(with_auto_update=True):
            try:
                backend.delete(indexed_instance)
            except Exception:
                # Log all errors
                logger.exception("Exception raised while deleting %r from the '%s' search backend", indexed_instance, backend_name)

                # Only catch the exception if the backend requires this
                # See the comments in insert_or_update_object for an explanation
                if not backend.catch_indexing_errors:
                    raise


</source>
</class>

</clones>
