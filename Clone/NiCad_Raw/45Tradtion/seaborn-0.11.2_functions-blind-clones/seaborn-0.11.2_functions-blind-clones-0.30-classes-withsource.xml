<clones>
<systeminfo processor="nicad6" system="seaborn-0.11.2" granularity="functions-blind" threshold="30%" minlines="10" maxlines="2500"/>
<cloneinfo npcs="661" npairs="46"/>
<runinfo ncompares="17499" cputime="56647"/>
<classinfo nclasses="33"/>

<class classid="1" nclones="2" nlines="16" similarity="87">
<source file="systems/seaborn-0.11.2/seaborn/tests/test_axisgrid.py" startline="214" endline="236" pcid="111">
    def test_legend_data(self):

        g = ag.FacetGrid(self.df, hue="a")
        g.map(plt.plot, "x", "y")
        g.add_legend()
        palette = color_palette(n_colors=3)

        assert g._legend.get_title().get_text() == "a"

        a_levels = sorted(self.df.a.unique())

        lines = g._legend.get_lines()
        assert len(lines) == len(a_levels)

        for line, hue in zip(lines, palette):
            assert line.get_color() == hue

        labels = g._legend.get_texts()
        assert len(labels) == len(a_levels)

        for label, level in zip(labels, a_levels):
            assert label.get_text() == level

</source>
<source file="systems/seaborn-0.11.2/seaborn/tests/test_axisgrid.py" startline="262" endline="285" pcid="113">
    def test_get_boolean_legend_data(self):

        self.df["b_bool"] = self.df.b == "m"
        g = ag.FacetGrid(self.df, hue="b_bool")
        g.map(plt.plot, "x", "y")
        g.add_legend()
        palette = color_palette(n_colors=2)

        assert g._legend.get_title().get_text() == "b_bool"

        b_levels = list(map(str, categorical_order(self.df.b_bool)))

        lines = g._legend.get_lines()
        assert len(lines) == len(b_levels)

        for line, hue in zip(lines, palette):
            assert line.get_color() == hue

        labels = g._legend.get_texts()
        assert len(labels) == len(b_levels)

        for label, level in zip(labels, b_levels):
            assert label.get_text() == level

</source>
</class>

<class classid="2" nclones="2" nlines="16" similarity="87">
<source file="systems/seaborn-0.11.2/seaborn/tests/test_axisgrid.py" startline="593" endline="615" pcid="132">
    def test_palette(self):

        rcmod.set()

        g = ag.FacetGrid(self.df, hue="c")
        assert g._colors == color_palette(n_colors=len(self.df.c.unique()))

        g = ag.FacetGrid(self.df, hue="d")
        assert g._colors == color_palette("husl", len(self.df.d.unique()))

        g = ag.FacetGrid(self.df, hue="c", palette="Set2")
        assert g._colors == color_palette("Set2", len(self.df.c.unique()))

        dict_pal = dict(t="red", u="green", v="blue")
        list_pal = color_palette(["red", "green", "blue"], 3)
        g = ag.FacetGrid(self.df, hue="c", palette=dict_pal)
        assert g._colors == list_pal

        list_pal = color_palette(["green", "blue", "red"], 3)
        g = ag.FacetGrid(self.df, hue="c", hue_order=list("uvt"),
                         palette=dict_pal)
        assert g._colors == list_pal

</source>
<source file="systems/seaborn-0.11.2/seaborn/tests/test_axisgrid.py" startline="1048" endline="1070" pcid="161">
    def test_palette(self):

        rcmod.set()

        g = ag.PairGrid(self.df, hue="a")
        assert g.palette == color_palette(n_colors=len(self.df.a.unique()))

        g = ag.PairGrid(self.df, hue="b")
        assert g.palette == color_palette("husl", len(self.df.b.unique()))

        g = ag.PairGrid(self.df, hue="a", palette="Set2")
        assert g.palette == color_palette("Set2", len(self.df.a.unique()))

        dict_pal = dict(a="red", b="green", c="blue")
        list_pal = color_palette(["red", "green", "blue"])
        g = ag.PairGrid(self.df, hue="a", palette=dict_pal)
        assert g.palette == list_pal

        list_pal = color_palette(["blue", "red", "green"])
        g = ag.PairGrid(self.df, hue="a", hue_order=list("cab"),
                        palette=dict_pal)
        assert g.palette == list_pal

</source>
</class>

<class classid="3" nclones="2" nlines="24" similarity="87">
<source file="systems/seaborn-0.11.2/seaborn/tests/test_axisgrid.py" startline="792" endline="819" pcid="149">
    def test_map(self):

        vars = ["x", "y", "z"]
        g1 = ag.PairGrid(self.df)
        g1.map(plt.scatter)

        for i, axes_i in enumerate(g1.axes):
            for j, ax in enumerate(axes_i):
                x_in = self.df[vars[j]]
                y_in = self.df[vars[i]]
                x_out, y_out = ax.collections[0].get_offsets().T
                npt.assert_array_equal(x_in, x_out)
                npt.assert_array_equal(y_in, y_out)

        g2 = ag.PairGrid(self.df, hue="a")
        g2.map(plt.scatter)

        for i, axes_i in enumerate(g2.axes):
            for j, ax in enumerate(axes_i):
                x_in = self.df[vars[j]]
                y_in = self.df[vars[i]]
                for k, k_level in enumerate(self.df.a.unique()):
                    x_in_k = x_in[self.df.a == k_level]
                    y_in_k = y_in[self.df.a == k_level]
                    x_out, y_out = ax.collections[k].get_offsets().T
                npt.assert_array_equal(x_in_k, x_out)
                npt.assert_array_equal(y_in_k, y_out)

</source>
<source file="systems/seaborn-0.11.2/seaborn/tests/test_axisgrid.py" startline="1173" endline="1202" pcid="165">
    def test_nondefault_index(self):

        df = self.df.copy().set_index("b")

        plot_vars = ["x", "y", "z"]
        g1 = ag.PairGrid(df)
        g1.map(plt.scatter)

        for i, axes_i in enumerate(g1.axes):
            for j, ax in enumerate(axes_i):
                x_in = self.df[plot_vars[j]]
                y_in = self.df[plot_vars[i]]
                x_out, y_out = ax.collections[0].get_offsets().T
                npt.assert_array_equal(x_in, x_out)
                npt.assert_array_equal(y_in, y_out)

        g2 = ag.PairGrid(df, hue="a")
        g2.map(plt.scatter)

        for i, axes_i in enumerate(g2.axes):
            for j, ax in enumerate(axes_i):
                x_in = self.df[plot_vars[j]]
                y_in = self.df[plot_vars[i]]
                for k, k_level in enumerate(self.df.a.unique()):
                    x_in_k = x_in[self.df.a == k_level]
                    y_in_k = y_in[self.df.a == k_level]
                    x_out, y_out = ax.collections[k].get_offsets().T
                    npt.assert_array_equal(x_in_k, x_out)
                    npt.assert_array_equal(y_in_k, y_out)

</source>
</class>

<class classid="4" nclones="3" nlines="13" similarity="71">
<source file="systems/seaborn-0.11.2/seaborn/tests/test_axisgrid.py" startline="835" endline="852" pcid="151">
    def test_map_lower(self):

        vars = ["x", "y", "z"]
        g = ag.PairGrid(self.df)
        g.map_lower(plt.scatter)

        for i, j in zip(*np.tril_indices_from(g.axes, -1)):
            ax = g.axes[i, j]
            x_in = self.df[vars[j]]
            y_in = self.df[vars[i]]
            x_out, y_out = ax.collections[0].get_offsets().T
            npt.assert_array_equal(x_in, x_out)
            npt.assert_array_equal(y_in, y_out)

        for i, j in zip(*np.triu_indices_from(g.axes)):
            ax = g.axes[i, j]
            assert len(ax.collections) == 0

</source>
<source file="systems/seaborn-0.11.2/seaborn/tests/test_axisgrid.py" startline="853" endline="870" pcid="152">
    def test_map_upper(self):

        vars = ["x", "y", "z"]
        g = ag.PairGrid(self.df)
        g.map_upper(plt.scatter)

        for i, j in zip(*np.triu_indices_from(g.axes, 1)):
            ax = g.axes[i, j]
            x_in = self.df[vars[j]]
            y_in = self.df[vars[i]]
            x_out, y_out = ax.collections[0].get_offsets().T
            npt.assert_array_equal(x_in, x_out)
            npt.assert_array_equal(y_in, y_out)

        for i, j in zip(*np.tril_indices_from(g.axes)):
            ax = g.axes[i, j]
            assert len(ax.collections) == 0

</source>
<source file="systems/seaborn-0.11.2/seaborn/tests/test_axisgrid.py" startline="871" endline="885" pcid="153">
    def test_map_mixed_funcsig(self):

        vars = ["x", "y", "z"]
        g = ag.PairGrid(self.df, vars=vars)
        g.map_lower(scatterplot)
        g.map_upper(plt.scatter)

        for i, j in zip(*np.triu_indices_from(g.axes, 1)):
            ax = g.axes[i, j]
            x_in = self.df[vars[j]]
            y_in = self.df[vars[i]]
            x_out, y_out = ax.collections[0].get_offsets().T
            npt.assert_array_equal(x_in, x_out)
            npt.assert_array_equal(y_in, y_out)

</source>
</class>

<class classid="5" nclones="4" nlines="24" similarity="76">
<source file="systems/seaborn-0.11.2/seaborn/tests/test_axisgrid.py" startline="997" endline="1026" pcid="158">
    def test_map_diag_and_offdiag(self):

        vars = ["x", "y", "z"]
        g = ag.PairGrid(self.df)
        g.map_offdiag(plt.scatter)
        g.map_diag(plt.hist)

        for ax in g.diag_axes:
            assert len(ax.patches) == 10

        for i, j in zip(*np.triu_indices_from(g.axes, 1)):
            ax = g.axes[i, j]
            x_in = self.df[vars[j]]
            y_in = self.df[vars[i]]
            x_out, y_out = ax.collections[0].get_offsets().T
            npt.assert_array_equal(x_in, x_out)
            npt.assert_array_equal(y_in, y_out)

        for i, j in zip(*np.tril_indices_from(g.axes, -1)):
            ax = g.axes[i, j]
            x_in = self.df[vars[j]]
            y_in = self.df[vars[i]]
            x_out, y_out = ax.collections[0].get_offsets().T
            npt.assert_array_equal(x_in, x_out)
            npt.assert_array_equal(y_in, y_out)

        for i, j in zip(*np.diag_indices_from(g.axes)):
            ax = g.axes[i, j]
            assert len(ax.collections) == 0

</source>
<source file="systems/seaborn-0.11.2/seaborn/tests/test_axisgrid.py" startline="1323" endline="1350" pcid="171">
    def test_pairplot_diag_kde(self):

        vars = ["x", "y", "z"]
        g = ag.pairplot(self.df, diag_kind="kde")

        for ax in g.diag_axes:
            assert len(ax.collections) == 1

        for i, j in zip(*np.triu_indices_from(g.axes, 1)):
            ax = g.axes[i, j]
            x_in = self.df[vars[j]]
            y_in = self.df[vars[i]]
            x_out, y_out = ax.collections[0].get_offsets().T
            npt.assert_array_equal(x_in, x_out)
            npt.assert_array_equal(y_in, y_out)

        for i, j in zip(*np.tril_indices_from(g.axes, -1)):
            ax = g.axes[i, j]
            x_in = self.df[vars[j]]
            y_in = self.df[vars[i]]
            x_out, y_out = ax.collections[0].get_offsets().T
            npt.assert_array_equal(x_in, x_out)
            npt.assert_array_equal(y_in, y_out)

        for i, j in zip(*np.diag_indices_from(g.axes)):
            ax = g.axes[i, j]
            assert len(ax.collections) == 0

</source>
<source file="systems/seaborn-0.11.2/seaborn/tests/test_axisgrid.py" startline="1275" endline="1308" pcid="169">
    def test_pairplot_reg(self):

        vars = ["x", "y", "z"]
        g = ag.pairplot(self.df, diag_kind="hist", kind="reg")

        for ax in g.diag_axes:
            assert len(ax.patches)

        for i, j in zip(*np.triu_indices_from(g.axes, 1)):
            ax = g.axes[i, j]
            x_in = self.df[vars[j]]
            y_in = self.df[vars[i]]
            x_out, y_out = ax.collections[0].get_offsets().T
            npt.assert_array_equal(x_in, x_out)
            npt.assert_array_equal(y_in, y_out)

            assert len(ax.lines) == 1
            assert len(ax.collections) == 2

        for i, j in zip(*np.tril_indices_from(g.axes, -1)):
            ax = g.axes[i, j]
            x_in = self.df[vars[j]]
            y_in = self.df[vars[i]]
            x_out, y_out = ax.collections[0].get_offsets().T
            npt.assert_array_equal(x_in, x_out)
            npt.assert_array_equal(y_in, y_out)

            assert len(ax.lines) == 1
            assert len(ax.collections) == 2

        for i, j in zip(*np.diag_indices_from(g.axes)):
            ax = g.axes[i, j]
            assert len(ax.collections) == 0

</source>
<source file="systems/seaborn-0.11.2/seaborn/tests/test_axisgrid.py" startline="1241" endline="1274" pcid="168">
    def test_pairplot(self):

        vars = ["x", "y", "z"]
        g = ag.pairplot(self.df)

        for ax in g.diag_axes:
            assert len(ax.patches) > 1

        for i, j in zip(*np.triu_indices_from(g.axes, 1)):
            ax = g.axes[i, j]
            x_in = self.df[vars[j]]
            y_in = self.df[vars[i]]
            x_out, y_out = ax.collections[0].get_offsets().T
            npt.assert_array_equal(x_in, x_out)
            npt.assert_array_equal(y_in, y_out)

        for i, j in zip(*np.tril_indices_from(g.axes, -1)):
            ax = g.axes[i, j]
            x_in = self.df[vars[j]]
            y_in = self.df[vars[i]]
            x_out, y_out = ax.collections[0].get_offsets().T
            npt.assert_array_equal(x_in, x_out)
            npt.assert_array_equal(y_in, y_out)

        for i, j in zip(*np.diag_indices_from(g.axes)):
            ax = g.axes[i, j]
            assert len(ax.collections) == 0

        g = ag.pairplot(self.df, hue="a")
        n = len(self.df.a.unique())

        for ax in g.diag_axes:
            assert len(ax.collections) == n

</source>
</class>

<class classid="6" nclones="2" nlines="30" similarity="100">
<source file="systems/seaborn-0.11.2/seaborn/tests/test_axisgrid.py" startline="1087" endline="1129" pcid="163">
    def test_hue_order(self):

        order = list("dcab")
        g = ag.PairGrid(self.df, hue="a", hue_order=order)
        g.map(plt.plot)

        for line, level in zip(g.axes[1, 0].lines, order):
            x, y = line.get_xydata().T
            npt.assert_array_equal(x, self.df.loc[self.df.a == level, "x"])
            npt.assert_array_equal(y, self.df.loc[self.df.a == level, "y"])

        plt.close("all")

        g = ag.PairGrid(self.df, hue="a", hue_order=order)
        g.map_diag(plt.plot)

        for line, level in zip(g.axes[0, 0].lines, order):
            x, y = line.get_xydata().T
            npt.assert_array_equal(x, self.df.loc[self.df.a == level, "x"])
            npt.assert_array_equal(y, self.df.loc[self.df.a == level, "x"])

        plt.close("all")

        g = ag.PairGrid(self.df, hue="a", hue_order=order)
        g.map_lower(plt.plot)

        for line, level in zip(g.axes[1, 0].lines, order):
            x, y = line.get_xydata().T
            npt.assert_array_equal(x, self.df.loc[self.df.a == level, "x"])
            npt.assert_array_equal(y, self.df.loc[self.df.a == level, "y"])

        plt.close("all")

        g = ag.PairGrid(self.df, hue="a", hue_order=order)
        g.map_upper(plt.plot)

        for line, level in zip(g.axes[0, 1].lines, order):
            x, y = line.get_xydata().T
            npt.assert_array_equal(x, self.df.loc[self.df.a == level, "y"])
            npt.assert_array_equal(y, self.df.loc[self.df.a == level, "x"])

        plt.close("all")

</source>
<source file="systems/seaborn-0.11.2/seaborn/tests/test_axisgrid.py" startline="1130" endline="1172" pcid="164">
    def test_hue_order_missing_level(self):

        order = list("dcaeb")
        g = ag.PairGrid(self.df, hue="a", hue_order=order)
        g.map(plt.plot)

        for line, level in zip(g.axes[1, 0].lines, order):
            x, y = line.get_xydata().T
            npt.assert_array_equal(x, self.df.loc[self.df.a == level, "x"])
            npt.assert_array_equal(y, self.df.loc[self.df.a == level, "y"])

        plt.close("all")

        g = ag.PairGrid(self.df, hue="a", hue_order=order)
        g.map_diag(plt.plot)

        for line, level in zip(g.axes[0, 0].lines, order):
            x, y = line.get_xydata().T
            npt.assert_array_equal(x, self.df.loc[self.df.a == level, "x"])
            npt.assert_array_equal(y, self.df.loc[self.df.a == level, "x"])

        plt.close("all")

        g = ag.PairGrid(self.df, hue="a", hue_order=order)
        g.map_lower(plt.plot)

        for line, level in zip(g.axes[1, 0].lines, order):
            x, y = line.get_xydata().T
            npt.assert_array_equal(x, self.df.loc[self.df.a == level, "x"])
            npt.assert_array_equal(y, self.df.loc[self.df.a == level, "y"])

        plt.close("all")

        g = ag.PairGrid(self.df, hue="a", hue_order=order)
        g.map_upper(plt.plot)

        for line, level in zip(g.axes[0, 1].lines, order):
            x, y = line.get_xydata().T
            npt.assert_array_equal(x, self.df.loc[self.df.a == level, "y"])
            npt.assert_array_equal(y, self.df.loc[self.df.a == level, "x"])

        plt.close("all")

</source>
</class>

<class classid="7" nclones="4" nlines="17" similarity="72">
<source file="systems/seaborn-0.11.2/seaborn/tests/test_categorical.py" startline="437" endline="460" pcid="232">
    def test_single_layer_stats(self):

        p = cat._CategoricalStatPlotter()

        g = pd.Series(np.repeat(list("abc"), 100))
        y = pd.Series(np.random.RandomState(0).randn(300))

        p.establish_variables(g, y)
        p.estimate_statistic(np.mean, 95, 10000, None)

        assert p.statistic.shape == (3,)
        assert p.confint.shape == (3, 2)

        npt.assert_array_almost_equal(p.statistic,
                                      y.groupby(g).mean())

        for ci, (_, grp_y) in zip(p.confint, y.groupby(g)):
            sem = stats.sem(grp_y)
            mean = grp_y.mean()
            stats.norm.ppf(.975)
            half_ci = stats.norm.ppf(.975) * sem
            ci_want = mean - half_ci, mean + half_ci
            npt.assert_array_almost_equal(ci_want, ci, 2)

</source>
<source file="systems/seaborn-0.11.2/seaborn/tests/test_categorical.py" startline="507" endline="531" pcid="235">
    def test_nested_stats(self):

        p = cat._CategoricalStatPlotter()

        g = pd.Series(np.repeat(list("abc"), 100))
        h = pd.Series(np.tile(list("xy"), 150))
        y = pd.Series(np.random.RandomState(0).randn(300))

        p.establish_variables(g, y, h)
        p.estimate_statistic(np.mean, 95, 50000, None)

        assert p.statistic.shape == (3, 2)
        assert p.confint.shape == (3, 2, 2)

        npt.assert_array_almost_equal(p.statistic,
                                      y.groupby([g, h]).mean().unstack())

        for ci_g, (_, grp_y) in zip(p.confint, y.groupby(g)):
            for ci, hue_y in zip(ci_g, [grp_y[::2], grp_y[1::2]]):
                sem = stats.sem(hue_y)
                mean = hue_y.mean()
                half_ci = stats.norm.ppf(.975) * sem
                ci_want = mean - half_ci, mean + half_ci
                npt.assert_array_almost_equal(ci_want, ci, 2)

</source>
<source file="systems/seaborn-0.11.2/seaborn/tests/test_categorical.py" startline="602" endline="623" pcid="239">
    def test_sd_error_bars(self):

        p = cat._CategoricalStatPlotter()

        g = pd.Series(np.repeat(list("abc"), 100))
        y = pd.Series(np.random.RandomState(0).randn(300))

        p.establish_variables(g, y)
        p.estimate_statistic(np.mean, "sd", None, None)

        assert p.statistic.shape == (3,)
        assert p.confint.shape == (3, 2)

        npt.assert_array_almost_equal(p.statistic,
                                      y.groupby(g).mean())

        for ci, (_, grp_y) in zip(p.confint, y.groupby(g)):
            mean = grp_y.mean()
            half_ci = np.std(grp_y)
            ci_want = mean - half_ci, mean + half_ci
            npt.assert_array_almost_equal(ci_want, ci, 2)

</source>
<source file="systems/seaborn-0.11.2/seaborn/tests/test_categorical.py" startline="624" endline="647" pcid="240">
    def test_nested_sd_error_bars(self):

        p = cat._CategoricalStatPlotter()

        g = pd.Series(np.repeat(list("abc"), 100))
        h = pd.Series(np.tile(list("xy"), 150))
        y = pd.Series(np.random.RandomState(0).randn(300))

        p.establish_variables(g, y, h)
        p.estimate_statistic(np.mean, "sd", None, None)

        assert p.statistic.shape == (3, 2)
        assert p.confint.shape == (3, 2, 2)

        npt.assert_array_almost_equal(p.statistic,
                                      y.groupby([g, h]).mean().unstack())

        for ci_g, (_, grp_y) in zip(p.confint, y.groupby(g)):
            for ci, hue_y in zip(ci_g, [grp_y[::2], grp_y[1::2]]):
                mean = hue_y.mean()
                half_ci = np.std(hue_y)
                ci_want = mean - half_ci, mean + half_ci
                npt.assert_array_almost_equal(ci_want, ci, 2)

</source>
</class>

<class classid="8" nclones="2" nlines="12" similarity="100">
<source file="systems/seaborn-0.11.2/seaborn/tests/test_categorical.py" startline="756" endline="771" pcid="243">
    def test_hue_offsets(self):

        p = cat._BoxPlotter(**self.default_kws)
        p.establish_variables("g", "y", hue="h", data=self.df)
        npt.assert_array_equal(p.hue_offsets, [-.2, .2])

        kws = self.default_kws.copy()
        kws["width"] = .6
        p = cat._BoxPlotter(**kws)
        p.establish_variables("g", "y", hue="h", data=self.df)
        npt.assert_array_equal(p.hue_offsets, [-.15, .15])

        p = cat._BoxPlotter(**kws)
        p.establish_variables("h", "y", "g", data=self.df)
        npt.assert_array_almost_equal(p.hue_offsets, [-.2, 0, .2])

</source>
<source file="systems/seaborn-0.11.2/seaborn/tests/test_categorical.py" startline="2827" endline="2842" pcid="337">
    def test_hue_offsets(self):

        p = cat._LVPlotter(**self.default_kws)
        p.establish_variables("g", "y", hue="h", data=self.df)
        npt.assert_array_equal(p.hue_offsets, [-.2, .2])

        kws = self.default_kws.copy()
        kws["width"] = .6
        p = cat._LVPlotter(**kws)
        p.establish_variables("g", "y", hue="h", data=self.df)
        npt.assert_array_equal(p.hue_offsets, [-.15, .15])

        p = cat._LVPlotter(**kws)
        p.establish_variables("h", "y", "g", data=self.df)
        npt.assert_array_almost_equal(p.hue_offsets, [-.2, 0, .2])

</source>
</class>

<class classid="9" nclones="2" nlines="11" similarity="100">
<source file="systems/seaborn-0.11.2/seaborn/tests/test_categorical.py" startline="784" endline="799" pcid="245">
    def test_box_colors(self):

        ax = cat.boxplot(x="g", y="y", data=self.df, saturation=1)
        pal = palettes.color_palette(n_colors=3)
        for patch, color in zip(ax.artists, pal):
            assert patch.get_facecolor()[:3] == color

        plt.close("all")

        ax = cat.boxplot(x="g", y="y", hue="h", data=self.df, saturation=1)
        pal = palettes.color_palette(n_colors=2)
        for patch, color in zip(ax.artists, pal * 2):
            assert patch.get_facecolor()[:3] == color

        plt.close("all")

</source>
<source file="systems/seaborn-0.11.2/seaborn/tests/test_categorical.py" startline="2857" endline="2872" pcid="339">
    def test_box_colors(self):

        ax = cat.boxenplot(x="g", y="y", data=self.df, saturation=1)
        pal = palettes.color_palette(n_colors=3)
        for patch, color in zip(ax.artists, pal):
            assert patch.get_facecolor()[:3] == color

        plt.close("all")

        ax = cat.boxenplot(x="g", y="y", hue="h", data=self.df, saturation=1)
        pal = palettes.color_palette(n_colors=2)
        for patch, color in zip(ax.artists, pal * 2):
            assert patch.get_facecolor()[:3] == color

        plt.close("all")

</source>
</class>

<class classid="10" nclones="2" nlines="12" similarity="100">
<source file="systems/seaborn-0.11.2/seaborn/tests/test_categorical.py" startline="806" endline="823" pcid="247">
    def test_missing_data(self):

        x = ["a", "a", "b", "b", "c", "c", "d", "d"]
        h = ["x", "y", "x", "y", "x", "y", "x", "y"]
        y = self.rs.randn(8)
        y[-2:] = np.nan

        ax = cat.boxplot(x=x, y=y)
        assert len(ax.artists) == 3

        plt.close("all")

        y[-1] = 0
        ax = cat.boxplot(x=x, y=y, hue=h)
        assert len(ax.artists) == 7

        plt.close("all")

</source>
<source file="systems/seaborn-0.11.2/seaborn/tests/test_categorical.py" startline="2899" endline="2916" pcid="342">
    def test_missing_data(self):

        x = ["a", "a", "b", "b", "c", "c", "d", "d"]
        h = ["x", "y", "x", "y", "x", "y", "x", "y"]
        y = self.rs.randn(8)
        y[-2:] = np.nan

        ax = cat.boxenplot(x=x, y=y)
        assert len(ax.lines) == 3

        plt.close("all")

        y[-1] = 0
        ax = cat.boxenplot(x=x, y=y, hue=h)
        assert len(ax.lines) == 7

        plt.close("all")

</source>
</class>

<class classid="11" nclones="2" nlines="14" similarity="100">
<source file="systems/seaborn-0.11.2/seaborn/tests/test_categorical.py" startline="824" endline="840" pcid="248">
    def test_unaligned_index(self):

        f, (ax1, ax2) = plt.subplots(2)
        cat.boxplot(x=self.g, y=self.y, ax=ax1)
        cat.boxplot(x=self.g, y=self.y_perm, ax=ax2)
        for l1, l2 in zip(ax1.lines, ax2.lines):
            assert np.array_equal(l1.get_xydata(), l2.get_xydata())

        f, (ax1, ax2) = plt.subplots(2)
        hue_order = self.h.unique()
        cat.boxplot(x=self.g, y=self.y, hue=self.h,
                    hue_order=hue_order, ax=ax1)
        cat.boxplot(x=self.g, y=self.y_perm, hue=self.h,
                    hue_order=hue_order, ax=ax2)
        for l1, l2 in zip(ax1.lines, ax2.lines):
            assert np.array_equal(l1.get_xydata(), l2.get_xydata())

</source>
<source file="systems/seaborn-0.11.2/seaborn/tests/test_categorical.py" startline="2882" endline="2898" pcid="341">
    def test_unaligned_index(self):

        f, (ax1, ax2) = plt.subplots(2)
        cat.boxenplot(x=self.g, y=self.y, ax=ax1)
        cat.boxenplot(x=self.g, y=self.y_perm, ax=ax2)
        for l1, l2 in zip(ax1.lines, ax2.lines):
            assert np.array_equal(l1.get_xydata(), l2.get_xydata())

        f, (ax1, ax2) = plt.subplots(2)
        hue_order = self.h.unique()
        cat.boxenplot(x=self.g, y=self.y, hue=self.h,
                      hue_order=hue_order, ax=ax1)
        cat.boxenplot(x=self.g, y=self.y_perm, hue=self.h,
                      hue_order=hue_order, ax=ax2)
        for l1, l2 in zip(ax1.lines, ax2.lines):
            assert np.array_equal(l1.get_xydata(), l2.get_xydata())

</source>
</class>

<class classid="12" nclones="2" nlines="26" similarity="100">
<source file="systems/seaborn-0.11.2/seaborn/tests/test_categorical.py" startline="869" endline="902" pcid="250">
    def test_axes_annotation(self):

        ax = cat.boxplot(x="g", y="y", data=self.df)
        assert ax.get_xlabel() == "g"
        assert ax.get_ylabel() == "y"
        assert ax.get_xlim() == (-.5, 2.5)
        npt.assert_array_equal(ax.get_xticks(), [0, 1, 2])
        npt.assert_array_equal([l.get_text() for l in ax.get_xticklabels()],
                               ["a", "b", "c"])

        plt.close("all")

        ax = cat.boxplot(x="g", y="y", hue="h", data=self.df)
        assert ax.get_xlabel() == "g"
        assert ax.get_ylabel() == "y"
        npt.assert_array_equal(ax.get_xticks(), [0, 1, 2])
        npt.assert_array_equal([l.get_text() for l in ax.get_xticklabels()],
                               ["a", "b", "c"])
        npt.assert_array_equal([l.get_text() for l in ax.legend_.get_texts()],
                               ["m", "n"])

        plt.close("all")

        ax = cat.boxplot(x="y", y="g", data=self.df, orient="h")
        assert ax.get_xlabel() == "y"
        assert ax.get_ylabel() == "g"
        assert ax.get_ylim() == (2.5, -.5)
        npt.assert_array_equal(ax.get_yticks(), [0, 1, 2])
        npt.assert_array_equal([l.get_text() for l in ax.get_yticklabels()],
                               ["a", "b", "c"])

        plt.close("all")


</source>
<source file="systems/seaborn-0.11.2/seaborn/tests/test_categorical.py" startline="2963" endline="2995" pcid="344">
    def test_axes_annotation(self):

        ax = cat.boxenplot(x="g", y="y", data=self.df)
        assert ax.get_xlabel() == "g"
        assert ax.get_ylabel() == "y"
        assert ax.get_xlim() == (-.5, 2.5)
        npt.assert_array_equal(ax.get_xticks(), [0, 1, 2])
        npt.assert_array_equal([l.get_text() for l in ax.get_xticklabels()],
                               ["a", "b", "c"])

        plt.close("all")

        ax = cat.boxenplot(x="g", y="y", hue="h", data=self.df)
        assert ax.get_xlabel() == "g"
        assert ax.get_ylabel() == "y"
        npt.assert_array_equal(ax.get_xticks(), [0, 1, 2])
        npt.assert_array_equal([l.get_text() for l in ax.get_xticklabels()],
                               ["a", "b", "c"])
        npt.assert_array_equal([l.get_text() for l in ax.legend_.get_texts()],
                               ["m", "n"])

        plt.close("all")

        ax = cat.boxenplot(x="y", y="g", data=self.df, orient="h")
        assert ax.get_xlabel() == "y"
        assert ax.get_ylabel() == "g"
        assert ax.get_ylim() == (2.5, -.5)
        npt.assert_array_equal(ax.get_yticks(), [0, 1, 2])
        npt.assert_array_equal([l.get_text() for l in ax.get_yticklabels()],
                               ["a", "b", "c"])

        plt.close("all")

</source>
</class>

<class classid="13" nclones="2" nlines="26" similarity="84">
<source file="systems/seaborn-0.11.2/seaborn/tests/test_categorical.py" startline="920" endline="958" pcid="252">
    def test_no_observations(self):

        p = cat._ViolinPlotter(**self.default_kws)

        x = ["a", "a", "b"]
        y = self.rs.randn(3)
        y[-1] = np.nan
        p.establish_variables(x, y)
        p.estimate_densities("scott", 2, "area", True, 20)

        assert len(p.support[0]) == 20
        assert len(p.support[1]) == 0

        assert len(p.density[0]) == 20
        assert len(p.density[1]) == 1

        assert p.density[1].item() == 1

        p.estimate_densities("scott", 2, "count", True, 20)
        assert p.density[1].item() == 0

        x = ["a"] * 4 + ["b"] * 2
        y = self.rs.randn(6)
        h = ["m", "n"] * 2 + ["m"] * 2

        p.establish_variables(x, y, hue=h)
        p.estimate_densities("scott", 2, "area", True, 20)

        assert len(p.support[1][0]) == 20
        assert len(p.support[1][1]) == 0

        assert len(p.density[1][0]) == 20
        assert len(p.density[1][1]) == 1

        assert p.density[1][1].item() == 1

        p.estimate_densities("scott", 2, "count", False, 20)
        assert p.density[1][1].item() == 0

</source>
<source file="systems/seaborn-0.11.2/seaborn/tests/test_categorical.py" startline="959" endline="996" pcid="253">
    def test_single_observation(self):

        p = cat._ViolinPlotter(**self.default_kws)

        x = ["a", "a", "b"]
        y = self.rs.randn(3)
        p.establish_variables(x, y)
        p.estimate_densities("scott", 2, "area", True, 20)

        assert len(p.support[0]) == 20
        assert len(p.support[1]) == 1

        assert len(p.density[0]) == 20
        assert len(p.density[1]) == 1

        assert p.density[1].item() == 1

        p.estimate_densities("scott", 2, "count", True, 20)
        assert p.density[1].item() == .5

        x = ["b"] * 4 + ["a"] * 3
        y = self.rs.randn(7)
        h = (["m", "n"] * 4)[:-1]

        p.establish_variables(x, y, hue=h)
        p.estimate_densities("scott", 2, "area", True, 20)

        assert len(p.support[1][0]) == 20
        assert len(p.support[1][1]) == 1

        assert len(p.density[1][0]) == 20
        assert len(p.density[1][1]) == 1

        assert p.density[1][1].item() == 1

        p.estimate_densities("scott", 2, "count", False, 20)
        assert p.density[1][1].item() == .5

</source>
</class>

<class classid="14" nclones="2" nlines="26" similarity="72">
<source file="systems/seaborn-0.11.2/seaborn/tests/test_categorical.py" startline="1394" endline="1424" pcid="268">
    def test_draw_violinplots_no_observations(self):

        kws = self.default_kws.copy()
        kws["inner"] = None

        # Test single layer of grouping
        x = ["a", "a", "b"]
        y = self.rs.randn(3)
        y[-1] = np.nan
        kws.update(x=x, y=y)
        p = cat._ViolinPlotter(**kws)

        _, ax = plt.subplots()
        p.draw_violins(ax)
        assert len(ax.collections) == 1
        assert len(ax.lines) == 0
        plt.close("all")

        # Test nested hue grouping
        x = ["a"] * 4 + ["b"] * 2
        y = self.rs.randn(6)
        h = ["m", "n"] * 2 + ["m"] * 2
        kws.update(x=x, y=y, hue=h)
        p = cat._ViolinPlotter(**kws)

        _, ax = plt.subplots()
        p.draw_violins(ax)
        assert len(ax.collections) == 3
        assert len(ax.lines) == 0
        plt.close("all")

</source>
<source file="systems/seaborn-0.11.2/seaborn/tests/test_categorical.py" startline="1425" endline="1464" pcid="269">
    def test_draw_violinplots_single_observations(self):

        kws = self.default_kws.copy()
        kws["inner"] = None

        # Test single layer of grouping
        x = ["a", "a", "b"]
        y = self.rs.randn(3)
        kws.update(x=x, y=y)
        p = cat._ViolinPlotter(**kws)

        _, ax = plt.subplots()
        p.draw_violins(ax)
        assert len(ax.collections) == 1
        assert len(ax.lines) == 1
        plt.close("all")

        # Test nested hue grouping
        x = ["b"] * 4 + ["a"] * 3
        y = self.rs.randn(7)
        h = (["m", "n"] * 4)[:-1]
        kws.update(x=x, y=y, hue=h)
        p = cat._ViolinPlotter(**kws)

        _, ax = plt.subplots()
        p.draw_violins(ax)
        assert len(ax.collections) == 3
        assert len(ax.lines) == 1
        plt.close("all")

        # Test nested hue grouping with split
        kws["split"] = True
        p = cat._ViolinPlotter(**kws)

        _, ax = plt.subplots()
        p.draw_violins(ax)
        assert len(ax.collections) == 3
        assert len(ax.lines) == 1
        plt.close("all")

</source>
</class>

<class classid="15" nclones="2" nlines="29" similarity="70">
<source file="systems/seaborn-0.11.2/seaborn/tests/test_categorical.py" startline="1465" endline="1506" pcid="270">
    def test_violinplots(self):

        # Smoke test the high level violinplot options

        cat.violinplot(x="y", data=self.df)
        plt.close("all")

        cat.violinplot(y="y", data=self.df)
        plt.close("all")

        cat.violinplot(x="g", y="y", data=self.df)
        plt.close("all")

        cat.violinplot(x="y", y="g", data=self.df, orient="h")
        plt.close("all")

        cat.violinplot(x="g", y="y", hue="h", data=self.df)
        plt.close("all")

        order = list("nabc")
        cat.violinplot(x="g", y="y", hue="h", order=order, data=self.df)
        plt.close("all")

        order = list("omn")
        cat.violinplot(x="g", y="y", hue="h", hue_order=order, data=self.df)
        plt.close("all")

        cat.violinplot(x="y", y="g", hue="h", data=self.df, orient="h")
        plt.close("all")

        for inner in ["box", "quart", "point", "stick", None]:
            cat.violinplot(x="g", y="y", data=self.df, inner=inner)
            plt.close("all")

            cat.violinplot(x="g", y="y", hue="h", data=self.df, inner=inner)
            plt.close("all")

            cat.violinplot(x="g", y="y", hue="h", data=self.df,
                           inner=inner, split=True)
            plt.close("all")


</source>
<source file="systems/seaborn-0.11.2/seaborn/tests/test_categorical.py" startline="2917" endline="2962" pcid="343">
    def test_boxenplots(self):

        # Smoke test the high level boxenplot options

        cat.boxenplot(x="y", data=self.df)
        plt.close("all")

        cat.boxenplot(y="y", data=self.df)
        plt.close("all")

        cat.boxenplot(x="g", y="y", data=self.df)
        plt.close("all")

        cat.boxenplot(x="y", y="g", data=self.df, orient="h")
        plt.close("all")

        cat.boxenplot(x="g", y="y", hue="h", data=self.df)
        plt.close("all")

        for scale in ("linear", "area", "exponential"):
            cat.boxenplot(x="g", y="y", hue="h", scale=scale, data=self.df)
            plt.close("all")

        for depth in ("proportion", "tukey", "trustworthy"):
            cat.boxenplot(x="g", y="y", hue="h", k_depth=depth, data=self.df)
            plt.close("all")

        order = list("nabc")
        cat.boxenplot(x="g", y="y", hue="h", order=order, data=self.df)
        plt.close("all")

        order = list("omn")
        cat.boxenplot(x="g", y="y", hue="h", hue_order=order, data=self.df)
        plt.close("all")

        cat.boxenplot(x="y", y="g", hue="h", data=self.df, orient="h")
        plt.close("all")

        cat.boxenplot(x="y", y="g", hue="h", data=self.df, orient="h",
                      palette="Set2")
        plt.close("all")

        cat.boxenplot(x="y", y="g", hue="h", data=self.df,
                      orient="h", color="b")
        plt.close("all")

</source>
</class>

<class classid="16" nclones="2" nlines="11" similarity="72">
<source file="systems/seaborn-0.11.2/seaborn/tests/test_categorical.py" startline="1610" endline="1626" pcid="277">
    def test_dodge_nested_stripplot_vertical(self):

        pal = palettes.color_palette()

        ax = cat.stripplot(x="g", y="y", hue="h", data=self.df,
                           jitter=False, dodge=True)
        for i, (_, group_vals) in enumerate(self.y.groupby(self.g)):
            for j, (_, vals) in enumerate(group_vals.groupby(self.h)):

                x, y = ax.collections[i * 2 + j].get_offsets().T

                npt.assert_array_equal(x, np.ones(len(x)) * i + [-.2, .2][j])
                npt.assert_array_equal(y, vals)

                fc = ax.collections[i * 2 + j].get_facecolors()[0, :3]
                assert tuple(fc) == pal[j]

</source>
<source file="systems/seaborn-0.11.2/seaborn/tests/test_categorical.py" startline="1811" endline="1825" pcid="291">
    def test_dodge_nested_swarmplot_horizontal(self):

        pal = palettes.color_palette()

        ax = cat.swarmplot(x="y", y="g", hue="h", data=self.df,
                           orient="h", dodge=True)
        for i, (_, group_vals) in enumerate(self.y.groupby(self.g)):
            for j, (_, vals) in enumerate(group_vals.groupby(self.h)):

                x, y = ax.collections[i * 2 + j].get_offsets().T
                npt.assert_array_almost_equal(x, np.sort(vals))

                fc = ax.collections[i * 2 + j].get_facecolors()[0, :3]
                assert tuple(fc) == pal[j]

</source>
</class>

<class classid="17" nclones="2" nlines="14" similarity="92">
<source file="systems/seaborn-0.11.2/seaborn/tests/test_categorical.py" startline="1826" endline="1846" pcid="292">
    def test_nested_swarmplot_vertical(self):

        ax = cat.swarmplot(x="g", y="y", hue="h", data=self.df)

        pal = palettes.color_palette()
        hue_names = self.h.unique().tolist()
        grouped_hues = list(self.h.groupby(self.g))

        for i, (_, vals) in enumerate(self.y.groupby(self.g)):

            points = ax.collections[i]
            x, y = points.get_offsets().T
            sorter = np.argsort(vals)
            npt.assert_array_almost_equal(y, vals.iloc[sorter])

            _, hue_vals = grouped_hues[i]
            for hue, fc in zip(hue_vals.values[sorter.values],
                               points.get_facecolors()):

                assert tuple(fc[:3]) == pal[hue_names.index(hue)]

</source>
<source file="systems/seaborn-0.11.2/seaborn/tests/test_categorical.py" startline="1847" endline="1867" pcid="293">
    def test_nested_swarmplot_horizontal(self):

        ax = cat.swarmplot(x="y", y="g", hue="h", data=self.df, orient="h")

        pal = palettes.color_palette()
        hue_names = self.h.unique().tolist()
        grouped_hues = list(self.h.groupby(self.g))

        for i, (_, vals) in enumerate(self.y.groupby(self.g)):

            points = ax.collections[i]
            x, y = points.get_offsets().T
            sorter = np.argsort(vals)
            npt.assert_array_almost_equal(x, vals.iloc[sorter])

            _, hue_vals = grouped_hues[i]
            for hue, fc in zip(hue_vals.values[sorter.values],
                               points.get_facecolors()):

                assert tuple(fc[:3]) == pal[hue_names.index(hue)]

</source>
</class>

<class classid="18" nclones="2" nlines="16" similarity="93">
<source file="systems/seaborn-0.11.2/seaborn/tests/test_categorical.py" startline="1932" endline="1953" pcid="296">
    def test_draw_vertical_bars(self):

        kws = self.default_kws.copy()
        kws.update(x="g", y="y", data=self.df)
        p = cat._BarPlotter(**kws)

        f, ax = plt.subplots()
        p.draw_bars(ax, {})

        assert len(ax.patches) == len(p.plot_data)
        assert len(ax.lines) == len(p.plot_data)

        for bar, color in zip(ax.patches, p.colors):
            assert bar.get_facecolor()[:-1] == color

        positions = np.arange(len(p.plot_data)) - p.width / 2
        for bar, pos, stat in zip(ax.patches, positions, p.statistic):
            assert bar.get_x() == pos
            assert bar.get_width() == p.width
            assert bar.get_y() == 0
            assert bar.get_height() == stat

</source>
<source file="systems/seaborn-0.11.2/seaborn/tests/test_categorical.py" startline="1954" endline="1975" pcid="297">
    def test_draw_horizontal_bars(self):

        kws = self.default_kws.copy()
        kws.update(x="y", y="g", orient="h", data=self.df)
        p = cat._BarPlotter(**kws)

        f, ax = plt.subplots()
        p.draw_bars(ax, {})

        assert len(ax.patches) == len(p.plot_data)
        assert len(ax.lines) == len(p.plot_data)

        for bar, color in zip(ax.patches, p.colors):
            assert bar.get_facecolor()[:-1] == color

        positions = np.arange(len(p.plot_data)) - p.width / 2
        for bar, pos, stat in zip(ax.patches, positions, p.statistic):
            assert bar.get_y() == pos
            assert bar.get_height() == p.width
            assert bar.get_x() == 0
            assert bar.get_width() == stat

</source>
</class>

<class classid="19" nclones="2" nlines="20" similarity="95">
<source file="systems/seaborn-0.11.2/seaborn/tests/test_categorical.py" startline="1976" endline="2002" pcid="298">
    def test_draw_nested_vertical_bars(self):

        kws = self.default_kws.copy()
        kws.update(x="g", y="y", hue="h", data=self.df)
        p = cat._BarPlotter(**kws)

        f, ax = plt.subplots()
        p.draw_bars(ax, {})

        n_groups, n_hues = len(p.plot_data), len(p.hue_names)
        assert len(ax.patches) == n_groups * n_hues
        assert len(ax.lines) == n_groups * n_hues

        for bar in ax.patches[:n_groups]:
            assert bar.get_facecolor()[:-1] == p.colors[0]
        for bar in ax.patches[n_groups:]:
            assert bar.get_facecolor()[:-1] == p.colors[1]

        positions = np.arange(len(p.plot_data))
        for bar, pos in zip(ax.patches[:n_groups], positions):
            assert bar.get_x() == approx(pos - p.width / 2)
            assert bar.get_width() == approx(p.nested_width)

        for bar, stat in zip(ax.patches, p.statistic.T.flat):
            assert bar.get_y() == approx(0)
            assert bar.get_height() == approx(stat)

</source>
<source file="systems/seaborn-0.11.2/seaborn/tests/test_categorical.py" startline="2003" endline="2029" pcid="299">
    def test_draw_nested_horizontal_bars(self):

        kws = self.default_kws.copy()
        kws.update(x="y", y="g", hue="h", orient="h", data=self.df)
        p = cat._BarPlotter(**kws)

        f, ax = plt.subplots()
        p.draw_bars(ax, {})

        n_groups, n_hues = len(p.plot_data), len(p.hue_names)
        assert len(ax.patches) == n_groups * n_hues
        assert len(ax.lines) == n_groups * n_hues

        for bar in ax.patches[:n_groups]:
            assert bar.get_facecolor()[:-1] == p.colors[0]
        for bar in ax.patches[n_groups:]:
            assert bar.get_facecolor()[:-1] == p.colors[1]

        positions = np.arange(len(p.plot_data))
        for bar, pos in zip(ax.patches[:n_groups], positions):
            assert bar.get_y() == approx(pos - p.width / 2)
            assert bar.get_height() == approx(p.nested_width)

        for bar, stat in zip(ax.patches, p.statistic.T.flat):
            assert bar.get_x() == approx(0)
            assert bar.get_width() == approx(stat)

</source>
</class>

<class classid="20" nclones="2" nlines="20" similarity="81">
<source file="systems/seaborn-0.11.2/seaborn/tests/test_categorical.py" startline="2058" endline="2082" pcid="301">
    def test_unaligned_index(self):

        f, (ax1, ax2) = plt.subplots(2)
        cat.barplot(x=self.g, y=self.y, ci="sd", ax=ax1)
        cat.barplot(x=self.g, y=self.y_perm, ci="sd", ax=ax2)
        for l1, l2 in zip(ax1.lines, ax2.lines):
            assert approx(l1.get_xydata()) == l2.get_xydata()
        for p1, p2 in zip(ax1.patches, ax2.patches):
            assert approx(p1.get_xy()) == p2.get_xy()
            assert approx(p1.get_height()) == p2.get_height()
            assert approx(p1.get_width()) == p2.get_width()

        f, (ax1, ax2) = plt.subplots(2)
        hue_order = self.h.unique()
        cat.barplot(x=self.g, y=self.y, hue=self.h,
                    hue_order=hue_order, ci="sd", ax=ax1)
        cat.barplot(x=self.g, y=self.y_perm, hue=self.h,
                    hue_order=hue_order, ci="sd", ax=ax2)
        for l1, l2 in zip(ax1.lines, ax2.lines):
            assert approx(l1.get_xydata()) == l2.get_xydata()
        for p1, p2 in zip(ax1.patches, ax2.patches):
            assert approx(p1.get_xy()) == p2.get_xy()
            assert approx(p1.get_height()) == p2.get_height()
            assert approx(p1.get_width()) == p2.get_width()

</source>
<source file="systems/seaborn-0.11.2/seaborn/tests/test_categorical.py" startline="2311" endline="2331" pcid="311">
    def test_unaligned_index(self):

        f, (ax1, ax2) = plt.subplots(2)
        cat.pointplot(x=self.g, y=self.y, ci="sd", ax=ax1)
        cat.pointplot(x=self.g, y=self.y_perm, ci="sd", ax=ax2)
        for l1, l2 in zip(ax1.lines, ax2.lines):
            assert approx(l1.get_xydata()) == l2.get_xydata()
        for p1, p2 in zip(ax1.collections, ax2.collections):
            assert approx(p1.get_offsets()) == p2.get_offsets()

        f, (ax1, ax2) = plt.subplots(2)
        hue_order = self.h.unique()
        cat.pointplot(x=self.g, y=self.y, hue=self.h,
                      hue_order=hue_order, ci="sd", ax=ax1)
        cat.pointplot(x=self.g, y=self.y_perm, hue=self.h,
                      hue_order=hue_order, ci="sd", ax=ax2)
        for l1, l2 in zip(ax1.lines, ax2.lines):
            assert approx(l1.get_xydata()) == l2.get_xydata()
        for p1, p2 in zip(ax1.collections, ax2.collections):
            assert approx(p1.get_offsets()) == p2.get_offsets()

</source>
</class>

<class classid="21" nclones="2" nlines="16" similarity="87">
<source file="systems/seaborn-0.11.2/seaborn/tests/test_categorical.py" startline="2201" endline="2222" pcid="306">
    def test_draw_vertical_points(self):

        kws = self.default_kws.copy()
        kws.update(x="g", y="y", data=self.df)
        p = cat._PointPlotter(**kws)

        f, ax = plt.subplots()
        p.draw_points(ax)

        assert len(ax.collections) == 1
        assert len(ax.lines) == len(p.plot_data) + 1
        points = ax.collections[0]
        assert len(points.get_offsets()) == len(p.plot_data)

        x, y = points.get_offsets().T
        npt.assert_array_equal(x, np.arange(len(p.plot_data)))
        npt.assert_array_equal(y, p.statistic)

        for got_color, want_color in zip(points.get_facecolors(),
                                         p.colors):
            npt.assert_array_equal(got_color[:-1], want_color)

</source>
<source file="systems/seaborn-0.11.2/seaborn/tests/test_categorical.py" startline="2223" endline="2244" pcid="307">
    def test_draw_horizontal_points(self):

        kws = self.default_kws.copy()
        kws.update(x="y", y="g", orient="h", data=self.df)
        p = cat._PointPlotter(**kws)

        f, ax = plt.subplots()
        p.draw_points(ax)

        assert len(ax.collections) == 1
        assert len(ax.lines) == len(p.plot_data) + 1
        points = ax.collections[0]
        assert len(points.get_offsets()) == len(p.plot_data)

        x, y = points.get_offsets().T
        npt.assert_array_equal(x, p.statistic)
        npt.assert_array_equal(y, np.arange(len(p.plot_data)))

        for got_color, want_color in zip(points.get_facecolors(),
                                         p.colors):
            npt.assert_array_equal(got_color[:-1], want_color)

</source>
</class>

<class classid="22" nclones="2" nlines="17" similarity="88">
<source file="systems/seaborn-0.11.2/seaborn/tests/test_categorical.py" startline="2245" endline="2269" pcid="308">
    def test_draw_vertical_nested_points(self):

        kws = self.default_kws.copy()
        kws.update(x="g", y="y", hue="h", data=self.df)
        p = cat._PointPlotter(**kws)

        f, ax = plt.subplots()
        p.draw_points(ax)

        assert len(ax.collections) == 2
        assert len(ax.lines) == len(p.plot_data) * len(p.hue_names) + len(p.hue_names)

        for points, numbers, color in zip(ax.collections,
                                          p.statistic.T,
                                          p.colors):

            assert len(points.get_offsets()) == len(p.plot_data)

            x, y = points.get_offsets().T
            npt.assert_array_equal(x, np.arange(len(p.plot_data)))
            npt.assert_array_equal(y, numbers)

            for got_color in points.get_facecolors():
                npt.assert_array_equal(got_color[:-1], color)

</source>
<source file="systems/seaborn-0.11.2/seaborn/tests/test_categorical.py" startline="2270" endline="2294" pcid="309">
    def test_draw_horizontal_nested_points(self):

        kws = self.default_kws.copy()
        kws.update(x="y", y="g", hue="h", orient="h", data=self.df)
        p = cat._PointPlotter(**kws)

        f, ax = plt.subplots()
        p.draw_points(ax)

        assert len(ax.collections) == 2
        assert len(ax.lines) == len(p.plot_data) * len(p.hue_names) + len(p.hue_names)

        for points, numbers, color in zip(ax.collections,
                                          p.statistic.T,
                                          p.colors):

            assert len(points.get_offsets()) == len(p.plot_data)

            x, y = points.get_offsets().T
            npt.assert_array_equal(x, numbers)
            npt.assert_array_equal(y, np.arange(len(p.plot_data)))

            for got_color in points.get_facecolors():
                npt.assert_array_equal(got_color[:-1], color)

</source>
</class>

<class classid="23" nclones="2" nlines="19" similarity="73">
<source file="systems/seaborn-0.11.2/seaborn/tests/test_matrix.py" startline="388" endline="415" pcid="414">
    def test_heatmap_ticklabel_rotation(self):

        f, ax = plt.subplots(figsize=(2, 2))
        mat.heatmap(self.df_norm, xticklabels=1, yticklabels=1, ax=ax)

        for t in ax.get_xticklabels():
            assert t.get_rotation() == 0

        for t in ax.get_yticklabels():
            assert t.get_rotation() == 90

        plt.close(f)

        df = self.df_norm.copy()
        df.columns = [str(c) * 10 for c in df.columns]
        df.index = [i * 10 for i in df.index]

        f, ax = plt.subplots(figsize=(2, 2))
        mat.heatmap(df, xticklabels=1, yticklabels=1, ax=ax)

        for t in ax.get_xticklabels():
            assert t.get_rotation() == 90

        for t in ax.get_yticklabels():
            assert t.get_rotation() == 0

        plt.close(f)

</source>
<source file="systems/seaborn-0.11.2/seaborn/tests/test_matrix.py" startline="679" endline="706" pcid="433">
    def test_dendrogram_ticklabel_rotation(self):
        f, ax = plt.subplots(figsize=(2, 2))
        mat.dendrogram(self.df_norm, ax=ax)

        for t in ax.get_xticklabels():
            assert t.get_rotation() == 0

        plt.close(f)

        df = self.df_norm.copy()
        df.columns = [str(c) * 10 for c in df.columns]
        df.index = [i * 10 for i in df.index]

        f, ax = plt.subplots(figsize=(2, 2))
        mat.dendrogram(df, ax=ax)

        for t in ax.get_xticklabels():
            assert t.get_rotation() == 90

        plt.close(f)

        f, ax = plt.subplots(figsize=(2, 2))
        mat.dendrogram(df.T, axis=0, rotate=True)
        for t in ax.get_yticklabels():
            assert t.get_rotation() == 0
        plt.close(f)


</source>
</class>

<class classid="24" nclones="2" nlines="14" similarity="75">
<source file="systems/seaborn-0.11.2/seaborn/tests/test_matrix.py" startline="933" endline="948" pcid="453">
    def test_cluster_false(self):
        kws = self.default_kws.copy()
        kws['row_cluster'] = False
        kws['col_cluster'] = False

        cm = mat.clustermap(self.df_norm, **kws)
        assert len(cm.ax_row_dendrogram.lines) == 0
        assert len(cm.ax_col_dendrogram.lines) == 0

        assert len(cm.ax_row_dendrogram.get_xticks()) == 0
        assert len(cm.ax_row_dendrogram.get_yticks()) == 0
        assert len(cm.ax_col_dendrogram.get_xticks()) == 0
        assert len(cm.ax_col_dendrogram.get_yticks()) == 0

        pdt.assert_frame_equal(cm.data2d, self.df_norm)

</source>
<source file="systems/seaborn-0.11.2/seaborn/tests/test_matrix.py" startline="959" endline="978" pcid="455">
    def test_cluster_false_row_col_colors(self):
        kws = self.default_kws.copy()
        kws['row_cluster'] = False
        kws['col_cluster'] = False
        kws['row_colors'] = self.row_colors
        kws['col_colors'] = self.col_colors

        cm = mat.clustermap(self.df_norm, **kws)
        assert len(cm.ax_row_dendrogram.lines) == 0
        assert len(cm.ax_col_dendrogram.lines) == 0

        assert len(cm.ax_row_dendrogram.get_xticks()) == 0
        assert len(cm.ax_row_dendrogram.get_yticks()) == 0
        assert len(cm.ax_col_dendrogram.get_xticks()) == 0
        assert len(cm.ax_col_dendrogram.get_yticks()) == 0
        assert len(cm.ax_row_colors.collections) == 1
        assert len(cm.ax_col_colors.collections) == 1

        pdt.assert_frame_equal(cm.data2d, self.df_norm)

</source>
</class>

<class classid="25" nclones="2" nlines="20" similarity="71">
<source file="systems/seaborn-0.11.2/seaborn/tests/test_matrix.py" startline="979" endline="1001" pcid="456">
    def test_row_col_colors_df(self):
        kws = self.default_kws.copy()
        kws['row_colors'] = pd.DataFrame({'row_1': list(self.row_colors),
                                          'row_2': list(self.row_colors)},
                                         index=self.df_norm.index,
                                         columns=['row_1', 'row_2'])
        kws['col_colors'] = pd.DataFrame({'col_1': list(self.col_colors),
                                          'col_2': list(self.col_colors)},
                                         index=self.df_norm.columns,
                                         columns=['col_1', 'col_2'])

        cm = mat.clustermap(self.df_norm, **kws)

        row_labels = [l.get_text() for l in
                      cm.ax_row_colors.get_xticklabels()]
        assert cm.row_color_labels == ['row_1', 'row_2']
        assert row_labels == cm.row_color_labels

        col_labels = [l.get_text() for l in
                      cm.ax_col_colors.get_yticklabels()]
        assert cm.col_color_labels == ['col_1', 'col_2']
        assert col_labels == cm.col_color_labels

</source>
<source file="systems/seaborn-0.11.2/seaborn/tests/test_matrix.py" startline="1040" endline="1068" pcid="459">
    def test_row_col_colors_df_one_axis(self):
        # Test case with only row annotation.
        kws1 = self.default_kws.copy()
        kws1['row_colors'] = pd.DataFrame({'row_1': list(self.row_colors),
                                           'row_2': list(self.row_colors)},
                                          index=self.df_norm.index,
                                          columns=['row_1', 'row_2'])

        cm1 = mat.clustermap(self.df_norm, **kws1)

        row_labels = [l.get_text() for l in
                      cm1.ax_row_colors.get_xticklabels()]
        assert cm1.row_color_labels == ['row_1', 'row_2']
        assert row_labels == cm1.row_color_labels

        # Test case with only col annotation.
        kws2 = self.default_kws.copy()
        kws2['col_colors'] = pd.DataFrame({'col_1': list(self.col_colors),
                                           'col_2': list(self.col_colors)},
                                          index=self.df_norm.columns,
                                          columns=['col_1', 'col_2'])

        cm2 = mat.clustermap(self.df_norm, **kws2)

        col_labels = [l.get_text() for l in
                      cm2.ax_col_colors.get_yticklabels()]
        assert cm2.col_color_labels == ['col_1', 'col_2']
        assert col_labels == cm2.col_color_labels

</source>
</class>

<class classid="26" nclones="2" nlines="16" similarity="75">
<source file="systems/seaborn-0.11.2/seaborn/tests/test_matrix.py" startline="1002" endline="1024" pcid="457">
    def test_row_col_colors_df_shuffled(self):
        # Tests if colors are properly matched, even if given in wrong order

        m, n = self.df_norm.shape
        shuffled_inds = [self.df_norm.index[i] for i in
                         list(range(0, m, 2)) + list(range(1, m, 2))]
        shuffled_cols = [self.df_norm.columns[i] for i in
                         list(range(0, n, 2)) + list(range(1, n, 2))]

        kws = self.default_kws.copy()

        row_colors = pd.DataFrame({'row_annot': list(self.row_colors)},
                                  index=self.df_norm.index)
        kws['row_colors'] = row_colors.loc[shuffled_inds]

        col_colors = pd.DataFrame({'col_annot': list(self.col_colors)},
                                  index=self.df_norm.columns)
        kws['col_colors'] = col_colors.loc[shuffled_cols]

        cm = mat.clustermap(self.df_norm, **kws)
        assert list(cm.col_colors)[0] == list(self.col_colors)
        assert list(cm.row_colors)[0] == list(self.row_colors)

</source>
<source file="systems/seaborn-0.11.2/seaborn/tests/test_matrix.py" startline="1086" endline="1109" pcid="461">
    def test_row_col_colors_series_shuffled(self):
        # Tests if colors are properly matched, even if given in wrong order

        m, n = self.df_norm.shape
        shuffled_inds = [self.df_norm.index[i] for i in
                         list(range(0, m, 2)) + list(range(1, m, 2))]
        shuffled_cols = [self.df_norm.columns[i] for i in
                         list(range(0, n, 2)) + list(range(1, n, 2))]

        kws = self.default_kws.copy()

        row_colors = pd.Series(list(self.row_colors), name='row_annot',
                               index=self.df_norm.index)
        kws['row_colors'] = row_colors.loc[shuffled_inds]

        col_colors = pd.Series(list(self.col_colors), name='col_annot',
                               index=self.df_norm.columns)
        kws['col_colors'] = col_colors.loc[shuffled_cols]

        cm = mat.clustermap(self.df_norm, **kws)

        assert list(cm.col_colors) == list(self.col_colors)
        assert list(cm.row_colors) == list(self.row_colors)

</source>
</class>

<class classid="27" nclones="2" nlines="13" similarity="100">
<source file="systems/seaborn-0.11.2/seaborn/tests/test_palettes.py" startline="153" endline="169" pcid="488">
    def test_hls_values(self):

        pal1 = palettes.hls_palette(6, h=0)
        pal2 = palettes.hls_palette(6, h=.5)
        pal2 = pal2[3:] + pal2[:3]
        npt.assert_array_almost_equal(pal1, pal2)

        pal_dark = palettes.hls_palette(5, l=.2)  # noqa
        pal_bright = palettes.hls_palette(5, l=.8)  # noqa
        npt.assert_array_less(list(map(sum, pal_dark)),
                              list(map(sum, pal_bright)))

        pal_flat = palettes.hls_palette(5, s=.1)
        pal_bold = palettes.hls_palette(5, s=.9)
        npt.assert_array_less(list(map(np.std, pal_flat)),
                              list(map(np.std, pal_bold)))

</source>
<source file="systems/seaborn-0.11.2/seaborn/tests/test_palettes.py" startline="170" endline="186" pcid="489">
    def test_husl_values(self):

        pal1 = palettes.husl_palette(6, h=0)
        pal2 = palettes.husl_palette(6, h=.5)
        pal2 = pal2[3:] + pal2[:3]
        npt.assert_array_almost_equal(pal1, pal2)

        pal_dark = palettes.husl_palette(5, l=.2)  # noqa
        pal_bright = palettes.husl_palette(5, l=.8)  # noqa
        npt.assert_array_less(list(map(sum, pal_dark)),
                              list(map(sum, pal_bright)))

        pal_flat = palettes.husl_palette(5, s=.1)
        pal_bold = palettes.husl_palette(5, s=.9)
        npt.assert_array_less(list(map(np.std, pal_flat)),
                              list(map(np.std, pal_bold)))

</source>
</class>

<class classid="28" nclones="2" nlines="18" similarity="100">
<source file="systems/seaborn-0.11.2/seaborn/tests/test_palettes.py" startline="230" endline="255" pcid="495">
    def test_light_palette(self):

        n = 4
        pal_forward = palettes.light_palette("red", n)
        pal_reverse = palettes.light_palette("red", n, reverse=True)
        assert np.allclose(pal_forward, pal_reverse[::-1])

        red = mpl.colors.colorConverter.to_rgb("red")
        assert pal_forward[-1] == red

        pal_f_from_string = palettes.color_palette("light:red", n)
        assert pal_forward[3] == pal_f_from_string[3]

        pal_r_from_string = palettes.color_palette("light:red_r", n)
        assert pal_reverse[3] == pal_r_from_string[3]

        pal_cmap = palettes.light_palette("blue", as_cmap=True)
        assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)

        pal_cmap_from_string = palettes.color_palette("light:blue", as_cmap=True)
        assert pal_cmap(.8) == pal_cmap_from_string(.8)

        pal_cmap = palettes.light_palette("blue", as_cmap=True, reverse=True)
        pal_cmap_from_string = palettes.color_palette("light:blue_r", as_cmap=True)
        assert pal_cmap(.8) == pal_cmap_from_string(.8)

</source>
<source file="systems/seaborn-0.11.2/seaborn/tests/test_palettes.py" startline="256" endline="281" pcid="496">
    def test_dark_palette(self):

        n = 4
        pal_forward = palettes.dark_palette("red", n)
        pal_reverse = palettes.dark_palette("red", n, reverse=True)
        assert np.allclose(pal_forward, pal_reverse[::-1])

        red = mpl.colors.colorConverter.to_rgb("red")
        assert pal_forward[-1] == red

        pal_f_from_string = palettes.color_palette("dark:red", n)
        assert pal_forward[3] == pal_f_from_string[3]

        pal_r_from_string = palettes.color_palette("dark:red_r", n)
        assert pal_reverse[3] == pal_r_from_string[3]

        pal_cmap = palettes.dark_palette("blue", as_cmap=True)
        assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)

        pal_cmap_from_string = palettes.color_palette("dark:blue", as_cmap=True)
        assert pal_cmap(.8) == pal_cmap_from_string(.8)

        pal_cmap = palettes.dark_palette("blue", as_cmap=True, reverse=True)
        pal_cmap_from_string = palettes.color_palette("dark:blue_r", as_cmap=True)
        assert pal_cmap(.8) == pal_cmap_from_string(.8)

</source>
</class>

<class classid="29" nclones="2" nlines="12" similarity="100">
<source file="systems/seaborn-0.11.2/seaborn/tests/test_rcmod.py" startline="83" endline="98" pcid="577">
    def test_style_context_manager(self):

        rcmod.set_style("darkgrid")
        orig_params = rcmod.axes_style()
        context_params = rcmod.axes_style("whitegrid")

        with rcmod.axes_style("whitegrid"):
            self.assert_rc_params(context_params)
        self.assert_rc_params(orig_params)

        @rcmod.axes_style("whitegrid")
        def func():
            self.assert_rc_params(context_params)
        func()
        self.assert_rc_params(orig_params)

</source>
<source file="systems/seaborn-0.11.2/seaborn/tests/test_rcmod.py" startline="209" endline="225" pcid="591">
    def test_context_context_manager(self):

        rcmod.set_context("notebook")
        orig_params = rcmod.plotting_context()
        context_params = rcmod.plotting_context("paper")

        with rcmod.plotting_context("paper"):
            self.assert_rc_params(context_params)
        self.assert_rc_params(orig_params)

        @rcmod.plotting_context("paper")
        def func():
            self.assert_rc_params(context_params)
        func()
        self.assert_rc_params(orig_params)


</source>
</class>

<class classid="30" nclones="2" nlines="13" similarity="85">
<source file="systems/seaborn-0.11.2/seaborn/widgets.py" startline="107" endline="122" pcid="618">
        def choose_sequential(name=opts, n=(2, 18),
                              desat=FloatSlider(min=0, max=1, value=1),
                              variant=variants):
            if variant == "reverse":
                name += "_r"
            elif variant == "dark":
                name += "_d"

            if as_cmap:
                colors = color_palette(name, 256, desat)
                _update_lut(cmap, np.c_[colors, np.ones(256)])
                _show_cmap(cmap)
            else:
                pal[:] = color_palette(name, n, desat)
                palplot(pal)

</source>
<source file="systems/seaborn-0.11.2/seaborn/widgets.py" startline="129" endline="141" pcid="619">
        def choose_diverging(name=opts, n=(2, 16),
                             desat=FloatSlider(min=0, max=1, value=1),
                             variant=variants):
            if variant == "reverse":
                name += "_r"
            if as_cmap:
                colors = color_palette(name, 256, desat)
                _update_lut(cmap, np.c_[colors, np.ones(256)])
                _show_cmap(cmap)
            else:
                pal[:] = color_palette(name, n, desat)
                palplot(pal)

</source>
</class>

<class classid="31" nclones="2" nlines="49" similarity="100">
<source file="systems/seaborn-0.11.2/seaborn/widgets.py" startline="157" endline="241" pcid="621">
def choose_dark_palette(input="husl", as_cmap=False):
    """Launch an interactive widget to create a dark sequential palette.

    This corresponds with the :func:`dark_palette` function. This kind
    of palette is good for data that range between relatively uninteresting
    low values and interesting high values.

    Requires IPython 2+ and must be used in the notebook.

    Parameters
    ----------
    input : {'husl', 'hls', 'rgb'}
        Color space for defining the seed value. Note that the default is
        different than the default input for :func:`dark_palette`.
    as_cmap : bool
        If True, the return value is a matplotlib colormap rather than a
        list of discrete colors.

    Returns
    -------
    pal or cmap : list of colors or matplotlib colormap
        Object that can be passed to plotting functions.

    See Also
    --------
    dark_palette : Create a sequential palette with dark low values.
    light_palette : Create a sequential palette with bright low values.
    cubehelix_palette : Create a sequential palette or colormap using the
                        cubehelix system.

    """
    pal = []
    if as_cmap:
        cmap = _init_mutable_colormap()

    if input == "rgb":
        @interact
        def choose_dark_palette_rgb(r=(0., 1.),
                                    g=(0., 1.),
                                    b=(0., 1.),
                                    n=(3, 17)):
            color = r, g, b
            if as_cmap:
                colors = dark_palette(color, 256, input="rgb")
                _update_lut(cmap, colors)
                _show_cmap(cmap)
            else:
                pal[:] = dark_palette(color, n, input="rgb")
                palplot(pal)

    elif input == "hls":
        @interact
        def choose_dark_palette_hls(h=(0., 1.),
                                    l=(0., 1.),  # noqa: E741
                                    s=(0., 1.),
                                    n=(3, 17)):
            color = h, l, s
            if as_cmap:
                colors = dark_palette(color, 256, input="hls")
                _update_lut(cmap, colors)
                _show_cmap(cmap)
            else:
                pal[:] = dark_palette(color, n, input="hls")
                palplot(pal)

    elif input == "husl":
        @interact
        def choose_dark_palette_husl(h=(0, 359),
                                     s=(0, 99),
                                     l=(0, 99),  # noqa: E741
                                     n=(3, 17)):
            color = h, s, l
            if as_cmap:
                colors = dark_palette(color, 256, input="husl")
                _update_lut(cmap, colors)
                _show_cmap(cmap)
            else:
                pal[:] = dark_palette(color, n, input="husl")
                palplot(pal)

    if as_cmap:
        return cmap
    return pal


</source>
<source file="systems/seaborn-0.11.2/seaborn/widgets.py" startline="242" endline="326" pcid="625">
def choose_light_palette(input="husl", as_cmap=False):
    """Launch an interactive widget to create a light sequential palette.

    This corresponds with the :func:`light_palette` function. This kind
    of palette is good for data that range between relatively uninteresting
    low values and interesting high values.

    Requires IPython 2+ and must be used in the notebook.

    Parameters
    ----------
    input : {'husl', 'hls', 'rgb'}
        Color space for defining the seed value. Note that the default is
        different than the default input for :func:`light_palette`.
    as_cmap : bool
        If True, the return value is a matplotlib colormap rather than a
        list of discrete colors.

    Returns
    -------
    pal or cmap : list of colors or matplotlib colormap
        Object that can be passed to plotting functions.

    See Also
    --------
    light_palette : Create a sequential palette with bright low values.
    dark_palette : Create a sequential palette with dark low values.
    cubehelix_palette : Create a sequential palette or colormap using the
                        cubehelix system.

    """
    pal = []
    if as_cmap:
        cmap = _init_mutable_colormap()

    if input == "rgb":
        @interact
        def choose_light_palette_rgb(r=(0., 1.),
                                     g=(0., 1.),
                                     b=(0., 1.),
                                     n=(3, 17)):
            color = r, g, b
            if as_cmap:
                colors = light_palette(color, 256, input="rgb")
                _update_lut(cmap, colors)
                _show_cmap(cmap)
            else:
                pal[:] = light_palette(color, n, input="rgb")
                palplot(pal)

    elif input == "hls":
        @interact
        def choose_light_palette_hls(h=(0., 1.),
                                     l=(0., 1.),  # noqa: E741
                                     s=(0., 1.),
                                     n=(3, 17)):
            color = h, l, s
            if as_cmap:
                colors = light_palette(color, 256, input="hls")
                _update_lut(cmap, colors)
                _show_cmap(cmap)
            else:
                pal[:] = light_palette(color, n, input="hls")
                palplot(pal)

    elif input == "husl":
        @interact
        def choose_light_palette_husl(h=(0, 359),
                                      s=(0, 99),
                                      l=(0, 99),  # noqa: E741
                                      n=(3, 17)):
            color = h, s, l
            if as_cmap:
                colors = light_palette(color, 256, input="husl")
                _update_lut(cmap, colors)
                _show_cmap(cmap)
            else:
                pal[:] = light_palette(color, n, input="husl")
                palplot(pal)

    if as_cmap:
        return cmap
    return pal


</source>
</class>

<class classid="32" nclones="3" nlines="12" similarity="75">
<source file="systems/seaborn-0.11.2/seaborn/widgets.py" startline="194" endline="206" pcid="622">
        def choose_dark_palette_rgb(r=(0., 1.),
                                    g=(0., 1.),
                                    b=(0., 1.),
                                    n=(3, 17)):
            color = r, g, b
            if as_cmap:
                colors = dark_palette(color, 256, input="rgb")
                _update_lut(cmap, colors)
                _show_cmap(cmap)
            else:
                pal[:] = dark_palette(color, n, input="rgb")
                palplot(pal)

</source>
<source file="systems/seaborn-0.11.2/seaborn/widgets.py" startline="224" endline="236" pcid="624">
        def choose_dark_palette_husl(h=(0, 359),
                                     s=(0, 99),
                                     l=(0, 99),  # noqa: E741
                                     n=(3, 17)):
            color = h, s, l
            if as_cmap:
                colors = dark_palette(color, 256, input="husl")
                _update_lut(cmap, colors)
                _show_cmap(cmap)
            else:
                pal[:] = dark_palette(color, n, input="husl")
                palplot(pal)

</source>
<source file="systems/seaborn-0.11.2/seaborn/widgets.py" startline="209" endline="221" pcid="623">
        def choose_dark_palette_hls(h=(0., 1.),
                                    l=(0., 1.),  # noqa: E741
                                    s=(0., 1.),
                                    n=(3, 17)):
            color = h, l, s
            if as_cmap:
                colors = dark_palette(color, 256, input="hls")
                _update_lut(cmap, colors)
                _show_cmap(cmap)
            else:
                pal[:] = dark_palette(color, n, input="hls")
                palplot(pal)

</source>
</class>

<class classid="33" nclones="3" nlines="12" similarity="75">
<source file="systems/seaborn-0.11.2/seaborn/widgets.py" startline="279" endline="291" pcid="626">
        def choose_light_palette_rgb(r=(0., 1.),
                                     g=(0., 1.),
                                     b=(0., 1.),
                                     n=(3, 17)):
            color = r, g, b
            if as_cmap:
                colors = light_palette(color, 256, input="rgb")
                _update_lut(cmap, colors)
                _show_cmap(cmap)
            else:
                pal[:] = light_palette(color, n, input="rgb")
                palplot(pal)

</source>
<source file="systems/seaborn-0.11.2/seaborn/widgets.py" startline="294" endline="306" pcid="627">
        def choose_light_palette_hls(h=(0., 1.),
                                     l=(0., 1.),  # noqa: E741
                                     s=(0., 1.),
                                     n=(3, 17)):
            color = h, l, s
            if as_cmap:
                colors = light_palette(color, 256, input="hls")
                _update_lut(cmap, colors)
                _show_cmap(cmap)
            else:
                pal[:] = light_palette(color, n, input="hls")
                palplot(pal)

</source>
<source file="systems/seaborn-0.11.2/seaborn/widgets.py" startline="309" endline="321" pcid="628">
        def choose_light_palette_husl(h=(0, 359),
                                      s=(0, 99),
                                      l=(0, 99),  # noqa: E741
                                      n=(3, 17)):
            color = h, s, l
            if as_cmap:
                colors = light_palette(color, 256, input="husl")
                _update_lut(cmap, colors)
                _show_cmap(cmap)
            else:
                pal[:] = light_palette(color, n, input="husl")
                palplot(pal)

</source>
</class>

</clones>
