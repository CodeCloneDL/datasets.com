<clones>
<systeminfo processor="nicad6" system="certbot-1.25.0" granularity="functions-blind" threshold="30%" minlines="10" maxlines="2500"/>
<cloneinfo npcs="1258" npairs="79"/>
<runinfo ncompares="28589" cputime="49809"/>
<classinfo nclasses="15"/>

<class classid="1" nclones="2" nlines="13" similarity="100">
<source file="systems/certbot-1.25.0/certbot-apache/certbot_apache/_internal/display_ops.py" startline="18" endline="41" pcid="4">
def select_vhost_multiple(vhosts: Optional[List[VirtualHost]]) -> List[VirtualHost]:
    """Select multiple Vhosts to install the certificate for

    :param vhosts: Available Apache VirtualHosts
    :type vhosts: :class:`list` of type `~VirtualHost`

    :returns: List of VirtualHosts
    :rtype: :class:`list`of type `~VirtualHost`
    """
    if not vhosts:
        return []
    tags_list = [vhost.display_repr()+"\n" for vhost in vhosts]
    # Remove the extra newline from the last entry
    if tags_list:
        tags_list[-1] = tags_list[-1][:-1]
    code, names = display_util.checklist(
        "Which VirtualHosts would you like to install the wildcard certificate for?",
        tags=tags_list, force_interactive=True)
    if code == display_util.OK:
        return_vhosts = _reversemap_vhosts(names, vhosts)
        return return_vhosts
    return []


</source>
<source file="systems/certbot-1.25.0/certbot-nginx/certbot_nginx/_internal/display_ops.py" startline="14" endline="35" pcid="316">
def select_vhost_multiple(vhosts: Optional[Iterable[VirtualHost]]) -> List[VirtualHost]:
    """Select multiple Vhosts to install the certificate for
    :param vhosts: Available Nginx VirtualHosts
    :type vhosts: :class:`list` of type `~obj.Vhost`
    :returns: List of VirtualHosts
    :rtype: :class:`list`of type `~obj.Vhost`
    """
    if not vhosts:
        return []
    tags_list = [vhost.display_repr()+"\n" for vhost in vhosts]
    # Remove the extra newline from the last entry
    if tags_list:
        tags_list[-1] = tags_list[-1][:-1]
    code, names = display_util.checklist(
        "Which server blocks would you like to modify?",
        tags=tags_list, force_interactive=True)
    if code == display_util.OK:
        return_vhosts = _reversemap_vhosts(names, vhosts)
        return return_vhosts
    return []


</source>
</class>

<class classid="2" nclones="2" nlines="10" similarity="70">
<source file="systems/certbot-1.25.0/certbot-apache/tests/parsernode_util_test.py" startline="34" endline="46" pcid="11">
    def test_unknown_parameter(self):
        params = self._setup_parsernode()
        params["unknown"] = "unknown"
        self.assertRaises(TypeError, util.parsernode_kwargs, params)

        params = self._setup_commentnode()
        params["unknown"] = "unknown"
        self.assertRaises(TypeError, util.commentnode_kwargs, params)

        params = self._setup_directivenode()
        params["unknown"] = "unknown"
        self.assertRaises(TypeError, util.directivenode_kwargs, params)

</source>
<source file="systems/certbot-1.25.0/certbot-apache/tests/parsernode_util_test.py" startline="100" endline="113" pcid="18">
    def test_missing_required(self):
        c_params = self._setup_commentnode()
        c_params.pop("comment")
        self.assertRaises(TypeError, util.commentnode_kwargs, c_params)

        d_params = self._setup_directivenode()
        d_params.pop("ancestor")
        self.assertRaises(TypeError, util.directivenode_kwargs, d_params)

        p_params = self._setup_parsernode()
        p_params.pop("filepath")
        self.assertRaises(TypeError, util.parsernode_kwargs, p_params)


</source>
</class>

<class classid="3" nclones="2" nlines="12" similarity="100">
<source file="systems/certbot-1.25.0/certbot-apache/tests/debian_test.py" startline="132" endline="146" pcid="54">
    def test_deploy_cert_newssl_no_fullchain(self):
        self.config = util.get_apache_configurator(
            self.config_path, self.vhost_path, self.config_dir,
            self.work_dir, version=(2, 4, 16))
        self.config = self.mock_deploy_cert(self.config)
        self.config.parser.modules["ssl_module"] = None
        self.config.parser.modules["mod_ssl.c"] = None

        # Get the default 443 vhost
        self.config.assoc["random.demo"] = self.vh_truth[1]
        self.assertRaises(errors.PluginError,
                          lambda: self.config.deploy_cert(
                              "random.demo", "example/cert.pem",
                              "example/key.pem"))

</source>
<source file="systems/certbot-1.25.0/certbot-apache/tests/debian_test.py" startline="147" endline="161" pcid="55">
    def test_deploy_cert_old_apache_no_chain(self):
        self.config = util.get_apache_configurator(
            self.config_path, self.vhost_path, self.config_dir,
            self.work_dir, version=(2, 4, 7))
        self.config = self.mock_deploy_cert(self.config)
        self.config.parser.modules["ssl_module"] = None
        self.config.parser.modules["mod_ssl.c"] = None

        # Get the default 443 vhost
        self.config.assoc["random.demo"] = self.vh_truth[1]
        self.assertRaises(errors.PluginError,
                          lambda: self.config.deploy_cert(
                              "random.demo", "example/cert.pem",
                              "example/key.pem"))

</source>
</class>

<class classid="4" nclones="2" nlines="10" similarity="70">
<source file="systems/certbot-1.25.0/certbot-apache/tests/dualnode_test.py" startline="71" endline="81" pcid="135">
    def test_set_parameters(self):
        pparams = mock.MagicMock()
        sparams = mock.MagicMock()
        pparams.parameters = ("a", "b")
        sparams.parameters = ("a", "b")
        self.directive.primary.set_parameters = pparams
        self.directive.secondary.set_parameters = sparams
        self.directive.set_parameters(("param", "seq"))
        self.assertIs(pparams.called, True)
        self.assertIs(sparams.called, True)

</source>
<source file="systems/certbot-1.25.0/certbot-apache/tests/dualnode_test.py" startline="91" endline="101" pcid="137">
    def test_unsaved_files(self):
        puns = mock.MagicMock()
        suns = mock.MagicMock()
        puns.return_value = assertions.PASS
        suns.return_value = assertions.PASS
        self.block.primary.unsaved_files = puns
        self.block.secondary.unsaved_files = suns
        self.block.unsaved_files()
        self.assertIs(puns.called, True)
        self.assertIs(suns.called, True)

</source>
</class>

<class classid="5" nclones="6" nlines="21" similarity="100">
<source file="systems/certbot-1.25.0/certbot-apache/tests/dualnode_test.py" startline="190" endline="212" pcid="145">
    def test_find_blocks_first_passing(self):
        youshallnotpass = [augeasparser.AugeasBlockNode(name="notpassing",
                                                        ancestor=self.block,
                                                        filepath="/path/to/whatever",
                                                        metadata=self.metadata)]
        youshallpass = [augeasparser.AugeasBlockNode(name=assertions.PASS,
                                                     ancestor=self.block,
                                                     filepath=assertions.PASS,
                                                     metadata=self.metadata)]
        find_blocks_primary = mock.MagicMock(return_value=youshallpass)
        find_blocks_secondary = mock.MagicMock(return_value=youshallnotpass)
        self.block.primary.find_blocks = find_blocks_primary
        self.block.secondary.find_blocks = find_blocks_secondary

        blocks = self.block.find_blocks("something")
        for block in blocks:
            try:
                assertions.assertEqual(block.primary, block.secondary)
            except AssertionError: # pragma: no cover
                self.fail("Assertion should have passed")
            self.assertIs(assertions.isPassDirective(block.primary), True)
            self.assertIs(assertions.isPassDirective(block.secondary), False)

</source>
<source file="systems/certbot-1.25.0/certbot-apache/tests/dualnode_test.py" startline="236" endline="258" pcid="147">
    def test_find_dirs_first_passing(self):
        notpassing = [augeasparser.AugeasDirectiveNode(name="notpassing",
                                                       ancestor=self.block,
                                                       filepath="/path/to/whatever",
                                                       metadata=self.metadata)]
        passing = [augeasparser.AugeasDirectiveNode(name=assertions.PASS,
                                                    ancestor=self.block,
                                                    filepath=assertions.PASS,
                                                    metadata=self.metadata)]
        find_dirs_primary = mock.MagicMock(return_value=passing)
        find_dirs_secondary = mock.MagicMock(return_value=notpassing)
        self.block.primary.find_directives = find_dirs_primary
        self.block.secondary.find_directives = find_dirs_secondary

        directives = self.block.find_directives("something")
        for directive in directives:
            try:
                assertions.assertEqual(directive.primary, directive.secondary)
            except AssertionError: # pragma: no cover
                self.fail("Assertion should have passed")
            self.assertIs(assertions.isPassDirective(directive.primary), True)
            self.assertIs(assertions.isPassDirective(directive.secondary), False)

</source>
<source file="systems/certbot-1.25.0/certbot-apache/tests/dualnode_test.py" startline="305" endline="327" pcid="150">
    def test_find_coms_second_passing(self):
        notpassing = [augeasparser.AugeasCommentNode(comment="notpassing",
                                                     ancestor=self.block,
                                                     filepath="/path/to/whatever",
                                                     metadata=self.metadata)]
        passing = [augeasparser.AugeasCommentNode(comment=assertions.PASS,
                                                  ancestor=self.block,
                                                  filepath=assertions.PASS,
                                                  metadata=self.metadata)]
        find_coms_primary = mock.MagicMock(return_value=notpassing)
        find_coms_secondary = mock.MagicMock(return_value=passing)
        self.block.primary.find_comments = find_coms_primary
        self.block.secondary.find_comments = find_coms_secondary

        comments = self.block.find_comments("something")
        for comment in comments:
            try:
                assertions.assertEqual(comment.primary, comment.secondary)
            except AssertionError: # pragma: no cover
                self.fail("Assertion should have passed")
            self.assertIs(assertions.isPassComment(comment.primary), False)
            self.assertIs(assertions.isPassComment(comment.secondary), True)

</source>
<source file="systems/certbot-1.25.0/certbot-apache/tests/dualnode_test.py" startline="213" endline="235" pcid="146">
    def test_find_blocks_second_passing(self):
        youshallnotpass = [augeasparser.AugeasBlockNode(name="notpassing",
                                                        ancestor=self.block,
                                                        filepath="/path/to/whatever",
                                                        metadata=self.metadata)]
        youshallpass = [augeasparser.AugeasBlockNode(name=assertions.PASS,
                                                     ancestor=self.block,
                                                     filepath=assertions.PASS,
                                                     metadata=self.metadata)]
        find_blocks_primary = mock.MagicMock(return_value=youshallnotpass)
        find_blocks_secondary = mock.MagicMock(return_value=youshallpass)
        self.block.primary.find_blocks = find_blocks_primary
        self.block.secondary.find_blocks = find_blocks_secondary

        blocks = self.block.find_blocks("something")
        for block in blocks:
            try:
                assertions.assertEqual(block.primary, block.secondary)
            except AssertionError: # pragma: no cover
                self.fail("Assertion should have passed")
            self.assertIs(assertions.isPassDirective(block.primary), False)
            self.assertIs(assertions.isPassDirective(block.secondary), True)

</source>
<source file="systems/certbot-1.25.0/certbot-apache/tests/dualnode_test.py" startline="259" endline="281" pcid="148">
    def test_find_dirs_second_passing(self):
        notpassing = [augeasparser.AugeasDirectiveNode(name="notpassing",
                                                       ancestor=self.block,
                                                       filepath="/path/to/whatever",
                                                       metadata=self.metadata)]
        passing = [augeasparser.AugeasDirectiveNode(name=assertions.PASS,
                                                    ancestor=self.block,
                                                    filepath=assertions.PASS,
                                                    metadata=self.metadata)]
        find_dirs_primary = mock.MagicMock(return_value=notpassing)
        find_dirs_secondary = mock.MagicMock(return_value=passing)
        self.block.primary.find_directives = find_dirs_primary
        self.block.secondary.find_directives = find_dirs_secondary

        directives = self.block.find_directives("something")
        for directive in directives:
            try:
                assertions.assertEqual(directive.primary, directive.secondary)
            except AssertionError: # pragma: no cover
                self.fail("Assertion should have passed")
            self.assertIs(assertions.isPassDirective(directive.primary), False)
            self.assertIs(assertions.isPassDirective(directive.secondary), True)

</source>
<source file="systems/certbot-1.25.0/certbot-apache/tests/dualnode_test.py" startline="282" endline="304" pcid="149">
    def test_find_coms_first_passing(self):
        notpassing = [augeasparser.AugeasCommentNode(comment="notpassing",
                                                     ancestor=self.block,
                                                     filepath="/path/to/whatever",
                                                     metadata=self.metadata)]
        passing = [augeasparser.AugeasCommentNode(comment=assertions.PASS,
                                                  ancestor=self.block,
                                                  filepath=assertions.PASS,
                                                  metadata=self.metadata)]
        find_coms_primary = mock.MagicMock(return_value=passing)
        find_coms_secondary = mock.MagicMock(return_value=notpassing)
        self.block.primary.find_comments = find_coms_primary
        self.block.secondary.find_comments = find_coms_secondary

        comments = self.block.find_comments("something")
        for comment in comments:
            try:
                assertions.assertEqual(comment.primary, comment.secondary)
            except AssertionError: # pragma: no cover
                self.fail("Assertion should have passed")
            self.assertIs(assertions.isPassComment(comment.primary), True)
            self.assertIs(assertions.isPassComment(comment.secondary), False)

</source>
</class>

<class classid="6" nclones="4" nlines="17" similarity="77">
<source file="systems/certbot-1.25.0/certbot-apache/tests/dualnode_test.py" startline="328" endline="347" pcid="151">
    def test_find_blocks_no_pass_equal(self):
        notpassing1 = [augeasparser.AugeasBlockNode(name="notpassing",
                                                    ancestor=self.block,
                                                    filepath="/path/to/whatever",
                                                    metadata=self.metadata)]
        notpassing2 = [augeasparser.AugeasBlockNode(name="notpassing",
                                                    ancestor=self.block,
                                                    filepath="/path/to/whatever",
                                                    metadata=self.metadata)]
        find_blocks_primary = mock.MagicMock(return_value=notpassing1)
        find_blocks_secondary = mock.MagicMock(return_value=notpassing2)
        self.block.primary.find_blocks = find_blocks_primary
        self.block.secondary.find_blocks = find_blocks_secondary

        blocks = self.block.find_blocks("anything")
        for block in blocks:
            with self.subTest(block=block):
                self.assertEqual(block.primary, block.secondary)
                self.assertIsNot(block.primary, block.secondary)

</source>
<source file="systems/certbot-1.25.0/certbot-apache/tests/dualnode_test.py" startline="368" endline="387" pcid="153">
    def test_find_comments_no_pass_equal(self):
        notpassing1 = [augeasparser.AugeasCommentNode(comment="notpassing",
                                                      ancestor=self.block,
                                                      filepath="/path/to/whatever",
                                                      metadata=self.metadata)]
        notpassing2 = [augeasparser.AugeasCommentNode(comment="notpassing",
                                                      ancestor=self.block,
                                                      filepath="/path/to/whatever",
                                                      metadata=self.metadata)]
        find_coms_primary = mock.MagicMock(return_value=notpassing1)
        find_coms_secondary = mock.MagicMock(return_value=notpassing2)
        self.block.primary.find_comments = find_coms_primary
        self.block.secondary.find_comments = find_coms_secondary

        comments = self.block.find_comments("anything")
        for comment in comments:
            with self.subTest(comment=comment):
                self.assertEqual(comment.primary, comment.secondary)
                self.assertIsNot(comment.primary, comment.secondary)

</source>
<source file="systems/certbot-1.25.0/certbot-apache/tests/dualnode_test.py" startline="388" endline="404" pcid="154">
    def test_find_blocks_no_pass_notequal(self):
        notpassing1 = [augeasparser.AugeasBlockNode(name="notpassing",
                                                    ancestor=self.block,
                                                    filepath="/path/to/whatever",
                                                    metadata=self.metadata)]
        notpassing2 = [augeasparser.AugeasBlockNode(name="different",
                                                    ancestor=self.block,
                                                    filepath="/path/to/whatever",
                                                    metadata=self.metadata)]
        find_blocks_primary = mock.MagicMock(return_value=notpassing1)
        find_blocks_secondary = mock.MagicMock(return_value=notpassing2)
        self.block.primary.find_blocks = find_blocks_primary
        self.block.secondary.find_blocks = find_blocks_secondary

        with self.assertRaises(AssertionError):
            _ = self.block.find_blocks("anything")

</source>
<source file="systems/certbot-1.25.0/certbot-apache/tests/dualnode_test.py" startline="348" endline="367" pcid="152">
    def test_find_dirs_no_pass_equal(self):
        notpassing1 = [augeasparser.AugeasDirectiveNode(name="notpassing",
                                                        ancestor=self.block,
                                                        filepath="/path/to/whatever",
                                                        metadata=self.metadata)]
        notpassing2 = [augeasparser.AugeasDirectiveNode(name="notpassing",
                                                        ancestor=self.block,
                                                        filepath="/path/to/whatever",
                                                        metadata=self.metadata)]
        find_dirs_primary = mock.MagicMock(return_value=notpassing1)
        find_dirs_secondary = mock.MagicMock(return_value=notpassing2)
        self.block.primary.find_directives = find_dirs_primary
        self.block.secondary.find_directives = find_dirs_secondary

        directives = self.block.find_directives("anything")
        for directive in directives:
            with self.subTest(directive=directive):
                self.assertEqual(directive.primary, directive.secondary)
                self.assertIsNot(directive.primary, directive.secondary)

</source>
</class>

<class classid="7" nclones="11" nlines="11" similarity="75">
<source file="systems/certbot-1.25.0/certbot-dns-gehirn/tests/dns_gehirn_test.py" startline="23" endline="43" pcid="159">
    def setUp(self):
        super().setUp()

        from certbot_dns_gehirn._internal.dns_gehirn import Authenticator

        path = os.path.join(self.tempdir, 'file.ini')
        dns_test_common.write(
            {"gehirn_api_token": API_TOKEN, "gehirn_api_secret": API_SECRET},
            path
        )

        self.config = mock.MagicMock(gehirn_credentials=path,
                                     gehirn_propagation_seconds=0)  # don't wait during tests

        self.auth = Authenticator(self.config, "gehirn")

        self.mock_client = mock.MagicMock()
        # _get_gehirn_client | pylint: disable=protected-access
        self.auth._get_gehirn_client = mock.MagicMock(return_value=self.mock_client)


</source>
<source file="systems/certbot-1.25.0/certbot-dns-dnsimple/tests/dns_dnsimple_test.py" startline="22" endline="39" pcid="473">
    def setUp(self):
        super().setUp()

        from certbot_dns_dnsimple._internal.dns_dnsimple import Authenticator

        path = os.path.join(self.tempdir, 'file.ini')
        dns_test_common.write({"dnsimple_token": TOKEN}, path)

        self.config = mock.MagicMock(dnsimple_credentials=path,
                                     dnsimple_propagation_seconds=0)  # don't wait during tests

        self.auth = Authenticator(self.config, "dnsimple")

        self.mock_client = mock.MagicMock()
        # _get_dnsimple_client | pylint: disable=protected-access
        self.auth._get_dnsimple_client = mock.MagicMock(return_value=self.mock_client)


</source>
<source file="systems/certbot-1.25.0/certbot-dns-luadns/tests/dns_luadns_test.py" startline="23" endline="40" pcid="180">
    def setUp(self):
        super().setUp()

        from certbot_dns_luadns._internal.dns_luadns import Authenticator

        path = os.path.join(self.tempdir, 'file.ini')
        dns_test_common.write({"luadns_email": EMAIL, "luadns_token": TOKEN}, path)

        self.config = mock.MagicMock(luadns_credentials=path,
                                     luadns_propagation_seconds=0)  # don't wait during tests

        self.auth = Authenticator(self.config, "luadns")

        self.mock_client = mock.MagicMock()
        # _get_luadns_client | pylint: disable=protected-access
        self.auth._get_luadns_client = mock.MagicMock(return_value=self.mock_client)


</source>
<source file="systems/certbot-1.25.0/certbot-dns-nsone/tests/dns_nsone_test.py" startline="23" endline="40" pcid="397">
    def setUp(self):
        super().setUp()

        from certbot_dns_nsone._internal.dns_nsone import Authenticator

        path = os.path.join(self.tempdir, 'file.ini')
        dns_test_common.write({"nsone_api_key": API_KEY}, path)

        self.config = mock.MagicMock(nsone_credentials=path,
                                     nsone_propagation_seconds=0)  # don't wait during tests

        self.auth = Authenticator(self.config, "nsone")

        self.mock_client = mock.MagicMock()
        # _get_nsone_client | pylint: disable=protected-access
        self.auth._get_nsone_client = mock.MagicMock(return_value=self.mock_client)


</source>
<source file="systems/certbot-1.25.0/certbot-dns-google/tests/dns_google_test.py" startline="28" endline="45" pcid="358">
    def setUp(self):
        super().setUp()

        from certbot_dns_google._internal.dns_google import Authenticator

        path = os.path.join(self.tempdir, 'file.json')
        open(path, "wb").close()

        super().setUp()
        self.config = mock.MagicMock(google_credentials=path,
                                     google_propagation_seconds=0)  # don't wait during tests

        self.auth = Authenticator(self.config, "google")

        self.mock_client = mock.MagicMock()
        # _get_google_client | pylint: disable=protected-access
        self.auth._get_google_client = mock.MagicMock(return_value=self.mock_client)

</source>
<source file="systems/certbot-1.25.0/certbot-dns-sakuracloud/tests/dns_sakuracloud_test.py" startline="23" endline="43" pcid="516">
    def setUp(self):
        super().setUp()

        from certbot_dns_sakuracloud._internal.dns_sakuracloud import Authenticator

        path = os.path.join(self.tempdir, 'file.ini')
        dns_test_common.write(
            {"sakuracloud_api_token": API_TOKEN, "sakuracloud_api_secret": API_SECRET},
            path
        )

        self.config = mock.MagicMock(sakuracloud_credentials=path,
                                     sakuracloud_propagation_seconds=0)  # don't wait during tests

        self.auth = Authenticator(self.config, "sakuracloud")

        self.mock_client = mock.MagicMock()
        # _get_sakuracloud_client | pylint: disable=protected-access
        self.auth._get_sakuracloud_client = mock.MagicMock(return_value=self.mock_client)


</source>
<source file="systems/certbot-1.25.0/certbot-dns-cloudxns/tests/dns_cloudxns_test.py" startline="28" endline="45" pcid="356">
    def setUp(self):
        super().setUp()

        from certbot_dns_cloudxns._internal.dns_cloudxns import Authenticator

        path = os.path.join(self.tempdir, 'file.ini')
        dns_test_common.write({"cloudxns_api_key": API_KEY, "cloudxns_secret_key": SECRET}, path)

        self.config = mock.MagicMock(cloudxns_credentials=path,
                                     cloudxns_propagation_seconds=0)  # don't wait during tests

        self.auth = Authenticator(self.config, "cloudxns")

        self.mock_client = mock.MagicMock()
        # _get_cloudxns_client | pylint: disable=protected-access
        self.auth._get_cloudxns_client = mock.MagicMock(return_value=self.mock_client)


</source>
<source file="systems/certbot-1.25.0/certbot-dns-dnsmadeeasy/tests/dns_dnsmadeeasy_test.py" startline="24" endline="43" pcid="1196">
    def setUp(self):
        super().setUp()

        from certbot_dns_dnsmadeeasy._internal.dns_dnsmadeeasy import Authenticator

        path = os.path.join(self.tempdir, 'file.ini')
        dns_test_common.write({"dnsmadeeasy_api_key": API_KEY,
                               "dnsmadeeasy_secret_key": SECRET_KEY},
                              path)

        self.config = mock.MagicMock(dnsmadeeasy_credentials=path,
                                     dnsmadeeasy_propagation_seconds=0)  # don't wait during tests

        self.auth = Authenticator(self.config, "dnsmadeeasy")

        self.mock_client = mock.MagicMock()
        # _get_dnsmadeeasy_client | pylint: disable=protected-access
        self.auth._get_dnsmadeeasy_client = mock.MagicMock(return_value=self.mock_client)


</source>
<source file="systems/certbot-1.25.0/certbot-dns-cloudflare/tests/dns_cloudflare_test.py" startline="27" endline="43" pcid="161">
    def setUp(self):
        from certbot_dns_cloudflare._internal.dns_cloudflare import Authenticator

        super().setUp()

        path = os.path.join(self.tempdir, 'file.ini')
        dns_test_common.write({"cloudflare_email": EMAIL, "cloudflare_api_key": API_KEY}, path)

        self.config = mock.MagicMock(cloudflare_credentials=path,
                                     cloudflare_propagation_seconds=0)  # don't wait during tests

        self.auth = Authenticator(self.config, "cloudflare")

        self.mock_client = mock.MagicMock()
        # _get_cloudflare_client | pylint: disable=protected-access
        self.auth._get_cloudflare_client = mock.MagicMock(return_value=self.mock_client)

</source>
<source file="systems/certbot-1.25.0/certbot-dns-rfc2136/tests/dns_rfc2136_test.py" startline="29" endline="45" pcid="318">
    def setUp(self):
        from certbot_dns_rfc2136._internal.dns_rfc2136 import Authenticator

        super().setUp()

        path = os.path.join(self.tempdir, 'file.ini')
        dns_test_common.write(VALID_CONFIG, path)

        self.config = mock.MagicMock(rfc2136_credentials=path,
                                     rfc2136_propagation_seconds=0)  # don't wait during tests

        self.auth = Authenticator(self.config, "rfc2136")

        self.mock_client = mock.MagicMock()
        # _get_rfc2136_client | pylint: disable=protected-access
        self.auth._get_rfc2136_client = mock.MagicMock(return_value=self.mock_client)

</source>
<source file="systems/certbot-1.25.0/certbot-dns-digitalocean/tests/dns_digitalocean_test.py" startline="23" endline="39" pcid="425">
    def setUp(self):
        from certbot_dns_digitalocean._internal.dns_digitalocean import Authenticator

        super().setUp()

        path = os.path.join(self.tempdir, 'file.ini')
        dns_test_common.write({"digitalocean_token": TOKEN}, path)

        self.config = mock.MagicMock(digitalocean_credentials=path,
                                     digitalocean_propagation_seconds=0)  # don't wait during tests

        self.auth = Authenticator(self.config, "digitalocean")

        self.mock_client = mock.MagicMock()
        # _get_digitalocean_client | pylint: disable=protected-access
        self.auth._get_digitalocean_client = mock.MagicMock(return_value=self.mock_client)

</source>
</class>

<class classid="8" nclones="2" nlines="12" similarity="75">
<source file="systems/certbot-1.25.0/certbot-dns-google/tests/dns_google_test.py" startline="179" endline="191" pcid="368">
    def test_add_txt_record_delete_old(self, unused_credential_mock):
        client, changes = self._setUp_client_with_mock(
            [{'managedZones': [{'id': self.zone}]}])
        # pylint: disable=line-too-long
        mock_get_rrs = "certbot_dns_google._internal.dns_google._GoogleClient.get_existing_txt_rrset"
        with mock.patch(mock_get_rrs) as mock_rrs:
            mock_rrs.return_value = {"rrdatas": ["sample-txt-contents"], "ttl": self.record_ttl}
            client.add_txt_record(DOMAIN, self.record_name, self.record_content, self.record_ttl)
            self.assertIs(changes.create.called, True)
            deletions = changes.create.call_args_list[0][1]["body"]["deletions"][0]
            self.assertIn("sample-txt-contents", deletions["rrdatas"])
            self.assertEqual(self.record_ttl, deletions["ttl"])

</source>
<source file="systems/certbot-1.25.0/certbot-dns-google/tests/dns_google_test.py" startline="195" endline="208" pcid="369">
    def test_add_txt_record_delete_old_ttl_case(self, unused_credential_mock):
        client, changes = self._setUp_client_with_mock(
            [{'managedZones': [{'id': self.zone}]}])
        # pylint: disable=line-too-long
        mock_get_rrs = "certbot_dns_google._internal.dns_google._GoogleClient.get_existing_txt_rrset"
        with mock.patch(mock_get_rrs) as mock_rrs:
            custom_ttl = 300
            mock_rrs.return_value = {"rrdatas": ["sample-txt-contents"], "ttl": custom_ttl}
            client.add_txt_record(DOMAIN, self.record_name, self.record_content, self.record_ttl)
            self.assertIs(changes.create.called, True)
            deletions = changes.create.call_args_list[0][1]["body"]["deletions"][0]
            self.assertIn("sample-txt-contents", deletions["rrdatas"])
            self.assertEqual(custom_ttl, deletions["ttl"]) #otherwise HTTP 412

</source>
</class>

<class classid="9" nclones="2" nlines="14" similarity="100">
<source file="systems/certbot-1.25.0/certbot/tests/lock_test.py" startline="112" endline="126" pcid="530">
    def test_unexpected_lockf_or_locking_err(self):
        if POSIX_MODE:
            mocked_function = 'certbot._internal.lock.fcntl.lockf'
        else:
            mocked_function = 'certbot._internal.lock.msvcrt.locking'
        msg = 'hi there'
        with mock.patch(mocked_function) as mock_lock:
            mock_lock.side_effect = IOError(msg)
            try:
                self._call(self.lock_path)
            except IOError as err:
                self.assertIn(msg, str(err))
            else:  # pragma: no cover
                self.fail('IOError not raised')

</source>
<source file="systems/certbot-1.25.0/certbot/tests/lock_test.py" startline="127" endline="143" pcid="531">
    def test_unexpected_os_err(self):
        if POSIX_MODE:
            mock_function = 'certbot._internal.lock.filesystem.os.stat'
        else:
            mock_function = 'certbot._internal.lock.msvcrt.locking'
        # The only expected errno are ENOENT and EACCES in lock module.
        msg = 'hi there'
        with mock.patch(mock_function) as mock_os:
            mock_os.side_effect = OSError(msg)
            try:
                self._call(self.lock_path)
            except OSError as err:
                self.assertIn(msg, str(err))
            else:  # pragma: no cover
                self.fail('OSError not raised')


</source>
</class>

<class classid="10" nclones="2" nlines="21" similarity="73">
<source file="systems/certbot-1.25.0/certbot/tests/compat/misc_test.py" startline="30" endline="56" pcid="623">
    def _test_common(self, returncode, stdout, stderr):
        given_command = "foo"
        given_name = "foo-hook"
        with mock.patch("certbot.compat.misc.subprocess.run") as mock_run:
            mock_run.return_value.stdout = stdout
            mock_run.return_value.stderr = stderr
            mock_run.return_value.returncode = returncode
            with mock.patch("certbot.compat.misc.logger") as mock_logger:
                self.assertEqual(self._call(given_name, given_command), (stderr, stdout))

        executed_command = mock_run.call_args[1].get(
            "args", mock_run.call_args[0][0])
        if os.name == 'nt':
            expected_command = ['powershell.exe', '-Command', given_command]
        else:
            expected_command = given_command
        self.assertEqual(executed_command, expected_command)

        mock_logger.info.assert_any_call("Running %s command: %s",
                                         given_name, given_command)
        if stdout:
            mock_logger.info.assert_any_call(mock.ANY, mock.ANY,
                                             mock.ANY, stdout)
        if stderr or returncode:
            self.assertIs(mock_logger.error.called, True)


</source>
<source file="systems/certbot-1.25.0/certbot/tests/compat/misc_test.py" startline="65" endline="87" pcid="625">
    def _test_common(self, returncode, stdout, stderr):
        given_command = "foo"
        given_name = "foo-hook"
        with mock.patch("certbot.compat.misc.subprocess.run") as mock_run:
            mock_run.return_value.stdout = stdout
            mock_run.return_value.stderr = stderr
            mock_run.return_value.returncode = returncode
            with mock.patch("certbot.compat.misc.logger") as mock_logger:
                self.assertEqual(self._call(given_name, given_command), (returncode, stderr, stdout))

        executed_command = mock_run.call_args[1].get(
            "args", mock_run.call_args[0][0])
        if os.name == 'nt':
            expected_command = ['powershell.exe', '-Command', given_command]
        else:
            expected_command = given_command
        self.assertEqual(executed_command, expected_command)
        self.assertEqual(executed_command, expected_command)

        mock_logger.info.assert_any_call("Running %s command: %s",
                                         given_name, given_command)


</source>
</class>

<class classid="11" nclones="2" nlines="15" similarity="93">
<source file="systems/certbot-1.25.0/certbot/tests/compat/filesystem_test.py" startline="154" endline="173" pcid="637">
    def test_umask_on_dir(self):
        previous_umask = filesystem.umask(0o022)

        try:
            dir1 = os.path.join(self.tempdir, 'probe1')
            filesystem.mkdir(dir1)
            self.assertIs(filesystem.check_mode(dir1, 0o755), True)

            filesystem.umask(0o077)

            dir2 = os.path.join(self.tempdir, 'dir2')
            filesystem.mkdir(dir2)
            self.assertIs(filesystem.check_mode(dir2, 0o700), True)

            dir3 = os.path.join(self.tempdir, 'dir3')
            filesystem.mkdir(dir3, mode=0o777)
            self.assertIs(filesystem.check_mode(dir3, 0o700), True)
        finally:
            filesystem.umask(previous_umask)

</source>
<source file="systems/certbot-1.25.0/certbot/tests/compat/filesystem_test.py" startline="174" endline="193" pcid="638">
    def test_umask_on_file(self):
        previous_umask = filesystem.umask(0o022)

        try:
            file1 = os.path.join(self.tempdir, 'probe1')
            UmaskTest._create_file(file1)
            self.assertIs(filesystem.check_mode(file1, 0o755), True)

            filesystem.umask(0o077)

            file2 = os.path.join(self.tempdir, 'probe2')
            UmaskTest._create_file(file2)
            self.assertIs(filesystem.check_mode(file2, 0o700), True)

            file3 = os.path.join(self.tempdir, 'probe3')
            UmaskTest._create_file(file3)
            self.assertIs(filesystem.check_mode(file3, 0o700), True)
        finally:
            filesystem.umask(previous_umask)

</source>
</class>

<class classid="12" nclones="2" nlines="13" similarity="71">
<source file="systems/certbot-1.25.0/certbot/tests/auth_handler_test.py" startline="127" endline="146" pcid="712">
    def test_name1_http_01_1_dns_1_acme_1(self):
        self.mock_net.poll.side_effect = _gen_mock_on_poll()
        self.mock_auth.get_chall_pref.return_value.append(challenges.DNS01)

        authzr = gen_dom_authzr(domain="0", challs=acme_util.CHALLENGES, combos=False)
        mock_order = mock.MagicMock(authorizations=[authzr])
        authzr = self.handler.handle_authorizations(mock_order, self.mock_config)

        self.assertEqual(self.mock_net.answer_challenge.call_count, 2)

        self.assertEqual(self.mock_net.poll.call_count, 1)

        self.assertEqual(self.mock_auth.cleanup.call_count, 1)
        # Test if list first element is http-01, use typ because it is an achall
        for achall in self.mock_auth.cleanup.call_args[0][0]:
            self.assertIn(achall.typ, ["http-01", "dns-01"])

        # Length of authorizations list
        self.assertEqual(len(authzr), 1)

</source>
<source file="systems/certbot-1.25.0/certbot/tests/auth_handler_test.py" startline="147" endline="167" pcid="713">
    def test_name1_http_01_1_dns_1_acme_2(self):
        self.mock_net.acme_version = 2
        self.mock_net.poll.side_effect = _gen_mock_on_poll()
        self.mock_auth.get_chall_pref.return_value.append(challenges.DNS01)

        authzr = gen_dom_authzr(domain="0", challs=acme_util.CHALLENGES, combos=False)
        mock_order = mock.MagicMock(authorizations=[authzr])
        authzr = self.handler.handle_authorizations(mock_order, self.mock_config)

        self.assertEqual(self.mock_net.answer_challenge.call_count, 1)

        self.assertEqual(self.mock_net.poll.call_count, 1)

        self.assertEqual(self.mock_auth.cleanup.call_count, 1)
        cleaned_up_achalls = self.mock_auth.cleanup.call_args[0][0]
        self.assertEqual(len(cleaned_up_achalls), 1)
        self.assertEqual(cleaned_up_achalls[0].typ, "http-01")

        # Length of authorizations list
        self.assertEqual(len(authzr), 1)

</source>
</class>

<class classid="13" nclones="2" nlines="20" similarity="73">
<source file="systems/certbot-1.25.0/certbot/tests/ocsp_test.py" startline="167" endline="190" pcid="918">
    def test_responder_is_issuer(self):
        issuer = x509.load_pem_x509_certificate(
            test_util.load_vector('ocsp_issuer_certificate.pem'), default_backend())

        with _ocsp_mock(ocsp_lib.OCSPCertStatus.REVOKED,
                        ocsp_lib.OCSPResponseStatus.SUCCESSFUL) as mocks:
            # OCSP response with ResponseID as Name
            mocks['mock_response'].return_value.responder_name = issuer.subject
            mocks['mock_response'].return_value.responder_key_hash = None
            self.checker.ocsp_revoked(self.cert_obj)
            # OCSP response with ResponseID as KeyHash
            key_hash = x509.SubjectKeyIdentifier.from_public_key(issuer.public_key()).digest
            mocks['mock_response'].return_value.responder_name = None
            mocks['mock_response'].return_value.responder_key_hash = key_hash
            self.checker.ocsp_revoked(self.cert_obj)

        # Here responder and issuer are the same. So only the signature of the OCSP
        # response is checked (using the issuer/responder public key).
        self.assertEqual(mocks['mock_check'].call_count, 2)
        self.assertEqual(mocks['mock_check'].call_args_list[0][0][0].public_numbers(),
            issuer.public_key().public_numbers())
        self.assertEqual(mocks['mock_check'].call_args_list[1][0][0].public_numbers(),
            issuer.public_key().public_numbers())

</source>
<source file="systems/certbot-1.25.0/certbot/tests/ocsp_test.py" startline="191" endline="221" pcid="919">
    def test_responder_is_authorized_delegate(self):
        issuer = x509.load_pem_x509_certificate(
            test_util.load_vector('ocsp_issuer_certificate.pem'), default_backend())
        responder = x509.load_pem_x509_certificate(
            test_util.load_vector('ocsp_responder_certificate.pem'), default_backend())

        with _ocsp_mock(ocsp_lib.OCSPCertStatus.REVOKED,
                        ocsp_lib.OCSPResponseStatus.SUCCESSFUL) as mocks:
            # OCSP response with ResponseID as Name
            mocks['mock_response'].return_value.responder_name = responder.subject
            mocks['mock_response'].return_value.responder_key_hash = None
            self.checker.ocsp_revoked(self.cert_obj)
            # OCSP response with ResponseID as KeyHash
            key_hash = x509.SubjectKeyIdentifier.from_public_key(responder.public_key()).digest
            mocks['mock_response'].return_value.responder_name = None
            mocks['mock_response'].return_value.responder_key_hash = key_hash
            self.checker.ocsp_revoked(self.cert_obj)

        # Here responder and issuer are not the same. Two signatures will be checked then,
        # first to verify the responder cert (using the issuer public key), second to
        # to verify the OCSP response itself (using the responder public key).
        self.assertEqual(mocks['mock_check'].call_count, 4)
        self.assertEqual(mocks['mock_check'].call_args_list[0][0][0].public_numbers(),
                         issuer.public_key().public_numbers())
        self.assertEqual(mocks['mock_check'].call_args_list[1][0][0].public_numbers(),
                         responder.public_key().public_numbers())
        self.assertEqual(mocks['mock_check'].call_args_list[2][0][0].public_numbers(),
                         issuer.public_key().public_numbers())
        self.assertEqual(mocks['mock_check'].call_args_list[3][0][0].public_numbers(),
                         responder.public_key().public_numbers())

</source>
</class>

<class classid="14" nclones="2" nlines="12" similarity="83">
<source file="systems/certbot-1.25.0/certbot/tests/storage_test.py" startline="366" endline="381" pcid="991">
    def test_update_all_links_to_partial_failure(self):
        def unlink_or_raise(path, real_unlink=os.unlink):
            # pylint: disable=missing-docstring
            basename = os.path.basename(path)
            if "fullchain" in basename and basename.startswith("prev"):
                raise ValueError
            real_unlink(path)

        self._write_out_ex_kinds()
        with mock.patch("certbot._internal.storage.os.unlink") as mock_unlink:
            mock_unlink.side_effect = unlink_or_raise
            self.assertRaises(ValueError, self.test_rc.update_all_links_to, 12)

        for kind in ALL_FOUR:
            self.assertEqual(self.test_rc.current_version(kind), 12)

</source>
<source file="systems/certbot-1.25.0/certbot/tests/storage_test.py" startline="382" endline="396" pcid="993">
    def test_update_all_links_to_full_failure(self):
        def unlink_or_raise(path, real_unlink=os.unlink):
            # pylint: disable=missing-docstring
            if "fullchain" in os.path.basename(path):
                raise ValueError
            real_unlink(path)

        self._write_out_ex_kinds()
        with mock.patch("certbot._internal.storage.os.unlink") as mock_unlink:
            mock_unlink.side_effect = unlink_or_raise
            self.assertRaises(ValueError, self.test_rc.update_all_links_to, 12)

        for kind in ALL_FOUR:
            self.assertEqual(self.test_rc.current_version(kind), 11)

</source>
</class>

<class classid="15" nclones="2" nlines="14" similarity="80">
<source file="systems/certbot-1.25.0/certbot-ci/certbot_integration_tests/certbot_tests/assertions.py" startline="164" endline="183" pcid="1209">
def assert_world_no_permissions(file: str) -> None:
    """
    Assert that the given file is not world-readable.
    :param str file: path of the file to check
    """
    if POSIX_MODE:
        mode_file_all = os.stat(file).st_mode & 0o007
        assert mode_file_all == 0
    else:
        security = win32security.GetFileSecurity(file, win32security.DACL_SECURITY_INFORMATION)
        dacl = security.GetSecurityDescriptorDacl()
        mode = dacl.GetEffectiveRightsFromAcl({
            'TrusteeForm': win32security.TRUSTEE_IS_SID,
            'TrusteeType': win32security.TRUSTEE_IS_USER,
            'Identifier': win32security.ConvertStringSidToSid(EVERYBODY_SID),
        })

        assert not mode


</source>
<source file="systems/certbot-1.25.0/certbot-ci/certbot_integration_tests/certbot_tests/assertions.py" startline="184" endline="203" pcid="1210">
def assert_world_read_permissions(file: str) -> None:
    """
    Assert that the given file is world-readable, but not world-writable or world-executable.
    :param str file: path of the file to check
    """
    if POSIX_MODE:
        mode_file_all = os.stat(file).st_mode & 0o007
        assert mode_file_all == 4
    else:
        security = win32security.GetFileSecurity(file, win32security.DACL_SECURITY_INFORMATION)
        dacl = security.GetSecurityDescriptorDacl()
        mode = dacl.GetEffectiveRightsFromAcl({
            'TrusteeForm': win32security.TRUSTEE_IS_SID,
            'TrusteeType': win32security.TRUSTEE_IS_USER,
            'Identifier': win32security.ConvertStringSidToSid(EVERYBODY_SID),
        })

        assert not mode & ntsecuritycon.FILE_GENERIC_WRITE
        assert not mode & ntsecuritycon.FILE_GENERIC_EXECUTE
        assert mode & ntsecuritycon.FILE_GENERIC_READ == ntsecuritycon.FILE_GENERIC_READ
</source>
</class>

</clones>
