<clones>
<systeminfo processor="nicad6" system="imgaug-0.4.0" granularity="functions-blind" threshold="30%" minlines="10" maxlines="2500"/>
<cloneinfo npcs="5585" npairs="2308"/>
<runinfo ncompares="832821" cputime="333012"/>
<classinfo nclasses="296"/>

<class classid="1" nclones="2" nlines="10" similarity="100">
<source file="systems/imgaug-0.4.0/imgaug/augmenters/weather.py" startline="381" endline="392" pcid="21">
    def get_parameters(self):
        """See :func:`~imgaug.augmenters.meta.Augmenter.get_parameters`."""
        return [self.intensity_mean,
                self.alpha_min,
                self.alpha_multiplier,
                self.alpha_size_px_max,
                self.alpha_freq_exponent,
                self.intensity_freq_exponent,
                self.sparsity,
                self.density_multiplier,
                self.intensity_coarse_scale]

</source>
<source file="systems/imgaug-0.4.0/imgaug/augmenters/weather.py" startline="888" endline="899" pcid="31">
        return batch

    def get_parameters(self):
        """See :func:`~imgaug.augmenters.meta.Augmenter.get_parameters`."""
        return [self.density,
                self.density_uniformity,
                self.flake_size,
                self.flake_size_uniformity,
                self.angle,
                self.speed,
                self.blur_sigma_fraction,
                self.blur_sigma_limits,
</source>
</class>

<class classid="2" nclones="2" nlines="18" similarity="72">
<source file="systems/imgaug-0.4.0/imgaug/augmenters/pillike.py" startline="1530" endline="1552" pcid="81">
    def __init__(self, cutoff=(0, 20), per_channel=False,
                 seed=None, name=None,
                 random_state="deprecated", deterministic="deprecated"):
        params1d = [
            iap.handle_discrete_param(
                cutoff, "cutoff", value_range=(0, 49), tuple_to_uniform=True,
                list_to_choice=True)
        ]
        func = autocontrast

        super(Autocontrast, self).__init__(
            func, params1d, per_channel,
            dtypes_allowed=["uint8"],
            dtypes_disallowed=["uint16", "uint32", "uint64",
                               "int8", "int16", "int32", "int64",
                               "float16", "float32", "float64",
                               "float16", "float32", "float64", "float96",
                               "float128", "float256", "bool"],
            seed=seed, name=name,
            random_state=random_state, deterministic=deterministic)


# Added in 0.4.0.
</source>
<source file="systems/imgaug-0.4.0/imgaug/augmenters/contrast.py" startline="746" endline="769" pcid="374">

    Same as in the previous example, but ``alpha`` is sampled once per image
    *and* channel.

    """
    def __init__(self, alpha=(0.6, 1.4), per_channel=False,
                 seed=None, name=None,
                 random_state="deprecated", deterministic="deprecated"):
        params1d = [
            iap.handle_continuous_param(
                alpha, "alpha", value_range=None, tuple_to_uniform=True,
                list_to_choice=True)
        ]
        func = adjust_contrast_linear

        super(LinearContrast, self).__init__(
            func, params1d, per_channel,
            dtypes_allowed=["uint8", "uint16", "uint32",
                            "int8", "int16", "int32",
                            "float16", "float32", "float64"],
            dtypes_disallowed=["uint64", "int64", "float96", "float128",
                               "float256", "bool"],
            seed=seed, name=name,
            random_state=random_state, deterministic=deterministic)
</source>
</class>

<class classid="3" nclones="2" nlines="10" similarity="80">
<source file="systems/imgaug-0.4.0/imgaug/augmenters/pillike.py" startline="1555" endline="1566" pcid="82">
    def __init__(self, func, factor, factor_value_range,
                 seed=None, name=None,
                 random_state="deprecated", deterministic="deprecated"):
        super(_EnhanceBase, self).__init__(
            seed=seed, name=name,
            random_state=random_state, deterministic=deterministic)
        self.func = func
        self.factor = iap.handle_continuous_param(
            factor, "factor", value_range=factor_value_range,
            tuple_to_uniform=True, list_to_choice=True)

    # Added in 0.4.0.
</source>
<source file="systems/imgaug-0.4.0/imgaug/augmenters/imgcorruptlike.py" startline="1006" endline="1018" pcid="141">
    def __init__(self, func, severity=1,
                 seed=None, name=None,
                 random_state="deprecated", deterministic="deprecated"):
        super(_ImgcorruptAugmenterBase, self).__init__(
            seed=seed, name=name,
            random_state=random_state, deterministic=deterministic)

        self.func = func
        self.severity = iap.handle_discrete_param(
            severity, "severity", value_range=(1, 5), tuple_to_uniform=True,
            list_to_choice=True, allow_floats=False)

    # Added in 0.4.0.
</source>
</class>

<class classid="4" nclones="2" nlines="33" similarity="84">
<source file="systems/imgaug-0.4.0/imgaug/augmenters/blend.py" startline="1154" endline="1196" pcid="185">
    def __init__(self, foreground=None, background=None, per_channel=False,
                 size_px_max=(2, 16), upscale_method=None,
                 iterations=(1, 3), aggregation_method="max",
                 sigmoid=True, sigmoid_thresh=None,
                 seed=None, name=None,
                 random_state="deprecated", deterministic="deprecated"):
        upscale_method_default = iap.Choice(["nearest", "linear", "cubic"],
                                            p=[0.05, 0.6, 0.35])
        sigmoid_thresh_default = iap.Normal(0.0, 5.0)

        noise = iap.SimplexNoise(
            size_px_max=size_px_max,
            upscale_method=(upscale_method
                            if upscale_method is not None
                            else upscale_method_default)
        )

        if iterations != 1:
            noise = iap.IterativeNoiseAggregator(
                noise,
                iterations=iterations,
                aggregation_method=aggregation_method
            )

        use_sigmoid = (
            sigmoid is True
            or (ia.is_single_number(sigmoid) and sigmoid >= 0.01))
        if use_sigmoid:
            noise = iap.Sigmoid.create_for_noise(
                noise,
                threshold=(sigmoid_thresh
                           if sigmoid_thresh is not None
                           else sigmoid_thresh_default),
                activated=sigmoid
            )

        super(BlendAlphaSimplexNoise, self).__init__(
            factor=noise, foreground=foreground, background=background,
            per_channel=per_channel,
            seed=seed, name=name,
            random_state=random_state, deterministic=deterministic)


</source>
<source file="systems/imgaug-0.4.0/imgaug/augmenters/blend.py" startline="1404" endline="1448" pcid="186">
    def __init__(self, exponent=(-4, 4), foreground=None, background=None,
                 per_channel=False, size_px_max=(4, 16), upscale_method=None,
                 iterations=(1, 3), aggregation_method=["avg", "max"],
                 sigmoid=0.5, sigmoid_thresh=None,
                 seed=None, name=None,
                 random_state="deprecated", deterministic="deprecated"):
        # pylint: disable=dangerous-default-value
        upscale_method_default = iap.Choice(["nearest", "linear", "cubic"],
                                            p=[0.05, 0.6, 0.35])
        sigmoid_thresh_default = iap.Normal(0.0, 5.0)

        noise = iap.FrequencyNoise(
            exponent=exponent,
            size_px_max=size_px_max,
            upscale_method=(upscale_method
                            if upscale_method is not None
                            else upscale_method_default)
        )

        if iterations != 1:
            noise = iap.IterativeNoiseAggregator(
                noise,
                iterations=iterations,
                aggregation_method=aggregation_method
            )

        use_sigmoid = (
            sigmoid is True
            or (ia.is_single_number(sigmoid) and sigmoid >= 0.01))
        if use_sigmoid:
            noise = iap.Sigmoid.create_for_noise(
                noise,
                threshold=(sigmoid_thresh
                           if sigmoid_thresh is not None
                           else sigmoid_thresh_default),
                activated=sigmoid
            )

        super(BlendAlphaFrequencyNoise, self).__init__(
            factor=noise, foreground=foreground, background=background,
            per_channel=per_channel,
            seed=seed, name=name,
            random_state=random_state, deterministic=deterministic)


</source>
</class>

<class classid="5" nclones="7" nlines="14" similarity="73">
<source file="systems/imgaug-0.4.0/imgaug/augmenters/blend.py" startline="1574" endline="1594" pcid="187">
    def __init__(self, foreground=None, background=None,
                 nb_bins=(5, 15), smoothness=(0.1, 0.3),
                 alpha=[0.0, 1.0], rotation_deg=(0, 360),
                 from_colorspace="RGB",
                 seed=None, name=None,
                 random_state="deprecated", deterministic="deprecated"):
        # pylint: disable=dangerous-default-value
        super(BlendAlphaSomeColors, self).__init__(
            SomeColorsMaskGen(
                nb_bins=nb_bins,
                smoothness=smoothness,
                alpha=alpha,
                rotation_deg=rotation_deg,
                from_colorspace=from_colorspace
            ),
            foreground=foreground,
            background=background,
            seed=seed, name=name,
            random_state=random_state, deterministic=deterministic)


</source>
<source file="systems/imgaug-0.4.0/imgaug/augmenters/blend.py" startline="1699" endline="1716" pcid="188">
    def __init__(self, foreground=None, background=None,
                 min_value=(0.0, 0.2), max_value=(0.8, 1.0),
                 start_at=(0.0, 0.2), end_at=(0.8, 1.0),
                 seed=None, name=None,
                 random_state="deprecated", deterministic="deprecated"):
        super(BlendAlphaHorizontalLinearGradient, self).__init__(
            HorizontalLinearGradientMaskGen(
                min_value=min_value,
                max_value=max_value,
                start_at=start_at,
                end_at=end_at
            ),
            foreground=foreground,
            background=background,
            seed=seed, name=name,
            random_state=random_state, deterministic=deterministic)


</source>
<source file="systems/imgaug-0.4.0/imgaug/augmenters/blend.py" startline="1828" endline="1845" pcid="189">
    def __init__(self, foreground=None, background=None,
                 min_value=(0.0, 0.2), max_value=(0.8, 1.0),
                 start_at=(0.0, 0.2), end_at=(0.8, 1.0),
                 seed=None, name=None,
                 random_state="deprecated", deterministic="deprecated"):
        super(BlendAlphaVerticalLinearGradient, self).__init__(
            VerticalLinearGradientMaskGen(
                min_value=min_value,
                max_value=max_value,
                start_at=start_at,
                end_at=end_at
            ),
            foreground=foreground,
            background=background,
            seed=seed, name=name,
            random_state=random_state, deterministic=deterministic)


</source>
<source file="systems/imgaug-0.4.0/imgaug/augmenters/blend.py" startline="1956" endline="1973" pcid="190">
    def __init__(self, nb_rows, nb_cols,
                 foreground=None, background=None,
                 alpha=[0.0, 1.0],
                 seed=None, name=None,
                 random_state="deprecated", deterministic="deprecated"):
        # pylint: disable=dangerous-default-value
        super(BlendAlphaRegularGrid, self).__init__(
            RegularGridMaskGen(
                nb_rows=nb_rows,
                nb_cols=nb_cols,
                alpha=alpha
            ),
            foreground=foreground,
            background=background,
            seed=seed, name=name,
            random_state=random_state, deterministic=deterministic)


</source>
<source file="systems/imgaug-0.4.0/imgaug/augmenters/blend.py" startline="2319" endline="2335" pcid="193">
    def __init__(self,
                 labels,
                 foreground=None, background=None,
                 nb_sample_labels=None,
                 seed=None, name=None,
                 random_state="deprecated", deterministic="deprecated"):
        super(BlendAlphaBoundingBoxes, self).__init__(
            BoundingBoxesMaskGen(
                labels=labels,
                nb_sample_labels=nb_sample_labels
            ),
            foreground=foreground,
            background=background,
            seed=seed, name=name,
            random_state=random_state, deterministic=deterministic)


</source>
<source file="systems/imgaug-0.4.0/imgaug/augmenters/blend.py" startline="2190" endline="2206" pcid="192">
    def __init__(self,
                 class_ids,
                 foreground=None, background=None,
                 nb_sample_classes=None,
                 seed=None, name=None,
                 random_state="deprecated", deterministic="deprecated"):
        super(BlendAlphaSegMapClassIds, self).__init__(
            SegMapClassIdsMaskGen(
                class_ids=class_ids,
                nb_sample_classes=nb_sample_classes
            ),
            foreground=foreground,
            background=background,
            seed=seed, name=name,
            random_state=random_state, deterministic=deterministic)


</source>
<source file="systems/imgaug-0.4.0/imgaug/augmenters/blend.py" startline="2060" endline="2074" pcid="191">
    def __init__(self, nb_rows, nb_cols,
                 foreground=None, background=None,
                 seed=None, name=None,
                 random_state="deprecated", deterministic="deprecated"):
        super(BlendAlphaCheckerboard, self).__init__(
            CheckerboardMaskGen(
                nb_rows=nb_rows,
                nb_cols=nb_cols
            ),
            foreground=foreground,
            background=background,
            seed=seed, name=name,
            random_state=random_state, deterministic=deterministic)


</source>
</class>

<class classid="6" nclones="2" nlines="18" similarity="72">
<source file="systems/imgaug-0.4.0/imgaug/augmenters/blend.py" startline="3433" endline="3454" pcid="226">
    def __init__(self, class_ids, nb_sample_classes=None):
        if nb_sample_classes is None:
            if ia.is_single_integer(class_ids):
                class_ids = [class_ids]
            assert isinstance(class_ids, list), (
                "Expected `class_ids` to be a single integer or a list of "
                "integers if `nb_sample_classes` is None. Got type `%s`. "
                "Set `nb_sample_classes` to e.g. an integer to enable "
                "stochastic parameters for `class_ids`." % (
                    type(class_ids).__name__,))
            self.class_ids = class_ids
            self.nb_sample_classes = None
        else:
            self.class_ids = iap.handle_discrete_param(
                class_ids, "class_ids", value_range=(0, None),
                tuple_to_uniform=True, list_to_choice=True,
                allow_floats=False)
            self.nb_sample_classes = iap.handle_discrete_param(
                nb_sample_classes, "nb_sample_classes", value_range=(0, None),
                tuple_to_uniform=True, list_to_choice=True,
                allow_floats=False)

</source>
<source file="systems/imgaug-0.4.0/imgaug/augmenters/blend.py" startline="3597" endline="3618" pcid="230">
    def __init__(self, labels=None, nb_sample_labels=None):
        if labels is None:
            self.labels = None
            self.nb_sample_labels = None
        elif nb_sample_labels is None:
            if ia.is_string(labels):
                labels = [labels]
            assert isinstance(labels, list), (
                "Expected `labels` a single string or a list of "
                "strings if `nb_sample_labels` is None. Got type `%s`. "
                "Set `nb_sample_labels` to e.g. an integer to enable "
                "stochastic parameters for `labels`." % (
                    type(labels).__name__,))
            self.labels = labels
            self.nb_sample_labels = None
        else:
            self.labels = iap.handle_categorical_string_param(labels, "labels")
            self.nb_sample_labels = iap.handle_discrete_param(
                nb_sample_labels, "nb_sample_labels", value_range=(0, None),
                tuple_to_uniform=True, list_to_choice=True,
                allow_floats=False)

</source>
</class>

<class classid="7" nclones="2" nlines="14" similarity="100">
<source file="systems/imgaug-0.4.0/imgaug/augmenters/blend.py" startline="3474" endline="3493" pcid="228">
    def _draw_samples(self, nb_rows, random_state):
        nb_sample_classes = self.nb_sample_classes
        if nb_sample_classes is None:
            assert isinstance(self.class_ids, list), (
                "Expected list got %s." % (type(self.class_ids).__name__,))
            return [self.class_ids] * nb_rows

        nb_sample_classes = nb_sample_classes.draw_samples(
            (nb_rows,), random_state=random_state)
        nb_sample_classes = np.clip(nb_sample_classes, 0, None)
        class_ids_raw = self.class_ids.draw_samples(
            (np.sum(nb_sample_classes),),
            random_state=random_state)

        class_ids = _split_1d_array_to_list(class_ids_raw, nb_sample_classes)

        return class_ids

    # TODO this could be simplified to something like:
    #      segmap.keep_only_classes(class_ids).draw_mask()
</source>
<source file="systems/imgaug-0.4.0/imgaug/augmenters/blend.py" startline="3642" endline="3661" pcid="232">
    def _draw_samples(self, nb_rows, random_state):
        nb_sample_labels = self.nb_sample_labels
        if nb_sample_labels is None:
            assert isinstance(self.labels, list), (
                "Expected list got %s." % (type(self.labels).__name__,))
            return [self.labels] * nb_rows

        nb_sample_labels = nb_sample_labels.draw_samples(
            (nb_rows,), random_state=random_state)
        nb_sample_labels = np.clip(nb_sample_labels, 0, None)
        labels_raw = self.labels.draw_samples(
            (np.sum(nb_sample_labels),),
            random_state=random_state)

        labels = _split_1d_array_to_list(labels_raw, nb_sample_labels)

        return labels

    # TODO this could be simplified to something like
    #      bbsoi.only_labels(labels).draw_mask()
</source>
</class>

<class classid="8" nclones="2" nlines="10" similarity="100">
<source file="systems/imgaug-0.4.0/imgaug/augmenters/blend.py" startline="3749" endline="3766" pcid="236">
def Alpha(factor=0, first=None, second=None, per_channel=False,
          seed=None, name=None,
          random_state="deprecated", deterministic="deprecated"):
    """See :class:`BlendAlpha`.

    Deprecated since 0.4.0.

    """
    # pylint: disable=invalid-name
    return BlendAlpha(
        factor=factor,
        foreground=first,
        background=second,
        per_channel=per_channel,
        seed=seed, name=name,
        random_state=random_state, deterministic=deterministic)


</source>
<source file="systems/imgaug-0.4.0/imgaug/augmenters/blend.py" startline="3773" endline="3790" pcid="237">
def AlphaElementwise(factor=0, first=None, second=None, per_channel=False,
                     seed=None, name=None,
                     random_state="deprecated", deterministic="deprecated"):
    """See :class:`BlendAlphaElementwise`.

    Deprecated since 0.4.0.

    """
    # pylint: disable=invalid-name
    return BlendAlphaElementwise(
        factor=factor,
        foreground=first,
        background=second,
        per_channel=per_channel,
        seed=seed, name=name,
        random_state=random_state, deterministic=deterministic)


</source>
</class>

<class classid="9" nclones="2" nlines="19" similarity="70">
<source file="systems/imgaug-0.4.0/imgaug/augmenters/blend.py" startline="3797" endline="3822" pcid="238">
def SimplexNoiseAlpha(first=None, second=None, per_channel=False,
                      size_px_max=(2, 16), upscale_method=None,
                      iterations=(1, 3), aggregation_method="max",
                      sigmoid=True, sigmoid_thresh=None,
                      seed=None, name=None,
                      random_state="deprecated", deterministic="deprecated"):
    """See :class:`BlendAlphaSimplexNoise`.

    Deprecated since 0.4.0.

    """
    # pylint: disable=invalid-name
    return BlendAlphaSimplexNoise(
        foreground=first,
        background=second,
        per_channel=per_channel,
        size_px_max=size_px_max,
        upscale_method=upscale_method,
        iterations=iterations,
        aggregation_method=aggregation_method,
        sigmoid=sigmoid,
        sigmoid_thresh=sigmoid_thresh,
        seed=seed, name=name,
        random_state=random_state, deterministic=deterministic)


</source>
<source file="systems/imgaug-0.4.0/imgaug/augmenters/blend.py" startline="3829" endline="3854" pcid="239">
def FrequencyNoiseAlpha(exponent=(-4, 4), first=None, second=None,
                        per_channel=False, size_px_max=(4, 16),
                        upscale_method=None,
                        iterations=(1, 3), aggregation_method=["avg", "max"],
                        sigmoid=0.5, sigmoid_thresh=None,
                        seed=None, name=None,
                        random_state="deprecated", deterministic="deprecated"):
    """See :class:`BlendAlphaFrequencyNoise`.

    Deprecated since 0.4.0.

    """
    # pylint: disable=invalid-name, dangerous-default-value
    return BlendAlphaFrequencyNoise(
        exponent=exponent,
        foreground=first,
        background=second,
        per_channel=per_channel,
        size_px_max=size_px_max,
        upscale_method=upscale_method,
        iterations=iterations,
        aggregation_method=aggregation_method,
        sigmoid=sigmoid,
        sigmoid_thresh=sigmoid_thresh,
        seed=seed, name=name,
        random_state=random_state, deterministic=deterministic)
</source>
</class>

<class classid="10" nclones="2" nlines="14" similarity="85">
<source file="systems/imgaug-0.4.0/imgaug/augmenters/segmentation.py" startline="933" endline="949" pcid="286">
    """

    def __init__(self, n_rows=(10, 30), n_cols=(10, 30),
                 p_drop_points=(0.0, 0.5), p_replace=(0.5, 1.0),
                 max_size=128, interpolation="linear",
                 seed=None, name=None,
                 random_state="deprecated", deterministic="deprecated"):
        super(RegularGridVoronoi, self).__init__(
            points_sampler=DropoutPointsSampler(
                RegularGridPointsSampler(n_rows, n_cols),
                p_drop_points
            ),
            p_replace=p_replace,
            max_size=max_size,
            interpolation=interpolation,
            seed=seed, name=name,
            random_state=random_state, deterministic=deterministic)
</source>
<source file="systems/imgaug-0.4.0/imgaug/augmenters/segmentation.py" startline="1115" endline="1131" pcid="287">
    """

    def __init__(self, n_rows_frac=(0.05, 0.15), n_cols_frac=(0.05, 0.15),
                 p_drop_points=(0.0, 0.5), p_replace=(0.5, 1.0),
                 max_size=None, interpolation="linear",
                 seed=None, name=None,
                 random_state="deprecated", deterministic="deprecated"):
        super(RelativeRegularGridVoronoi, self).__init__(
            points_sampler=DropoutPointsSampler(
                RelativeRegularGridPointsSampler(n_rows_frac, n_cols_frac),
                p_drop_points
            ),
            p_replace=p_replace,
            max_size=max_size,
            interpolation=interpolation,
            seed=seed, name=name,
            random_state=random_state, deterministic=deterministic)
</source>
</class>

<class classid="11" nclones="3" nlines="14" similarity="80">
<source file="systems/imgaug-0.4.0/imgaug/augmenters/convolutional.py" startline="310" endline="327" pcid="347">
    def __init__(self, alpha=(0.0, 0.2), lightness=(0.8, 1.2),
                 seed=None, name=None,
                 random_state="deprecated", deterministic="deprecated"):
        alpha_param = iap.handle_continuous_param(
            alpha, "alpha",
            value_range=(0, 1.0), tuple_to_uniform=True, list_to_choice=True)
        lightness_param = iap.handle_continuous_param(
            lightness, "lightness",
            value_range=(0, None), tuple_to_uniform=True, list_to_choice=True)

        matrix_gen = _SharpeningMatrixGenerator(alpha_param, lightness_param)

        super(Sharpen, self).__init__(
            matrix=matrix_gen,
            seed=seed, name=name,
            random_state=random_state, deterministic=deterministic)


</source>
<source file="systems/imgaug-0.4.0/imgaug/augmenters/convolutional.py" startline="651" endline="669" pcid="356">
    def __init__(self, alpha=(0.0, 0.75), direction=(0.0, 1.0),
                 seed=None, name=None,
                 random_state="deprecated", deterministic="deprecated"):
        alpha_param = iap.handle_continuous_param(
            alpha, "alpha",
            value_range=(0, 1.0), tuple_to_uniform=True, list_to_choice=True)
        direction_param = iap.handle_continuous_param(
            direction, "direction",
            value_range=None, tuple_to_uniform=True, list_to_choice=True)

        matrix_gen = _DirectedEdgeDetectMatrixGenerator(alpha_param,
                                                        direction_param)

        super(DirectedEdgeDetect, self).__init__(
            matrix=matrix_gen,
            seed=seed, name=name,
            random_state=random_state, deterministic=deterministic)


</source>
<source file="systems/imgaug-0.4.0/imgaug/augmenters/convolutional.py" startline="421" endline="438" pcid="350">
    def __init__(self, alpha=(0.0, 1.0), strength=(0.25, 1.0),
                 seed=None, name=None,
                 random_state="deprecated", deterministic="deprecated"):
        alpha_param = iap.handle_continuous_param(
            alpha, "alpha",
            value_range=(0, 1.0), tuple_to_uniform=True, list_to_choice=True)
        strength_param = iap.handle_continuous_param(
            strength, "strength",
            value_range=(0, None), tuple_to_uniform=True, list_to_choice=True)

        matrix_gen = _EmbossMatrixGenerator(alpha_param, strength_param)

        super(Emboss, self).__init__(
            matrix=matrix_gen,
            seed=seed, name=name,
            random_state=random_state, deterministic=deterministic)


</source>
</class>

<class classid="12" nclones="3" nlines="17" similarity="76">
<source file="systems/imgaug-0.4.0/imgaug/augmenters/convolutional.py" startline="333" endline="355" pcid="349">
    def __call__(self, _image, nb_channels, random_state):
        alpha_sample = self.alpha.draw_sample(random_state=random_state)
        assert 0 <= alpha_sample <= 1.0, (
            "Expected 'alpha' to be in the interval [0.0, 1.0], "
            "got %.4f." % (alpha_sample,))
        lightness_sample = self.lightness.draw_sample(random_state=random_state)
        matrix_nochange = np.array([
            [0, 0, 0],
            [0, 1, 0],
            [0, 0, 0]
        ], dtype=np.float32)
        matrix_effect = np.array([
            [-1, -1, -1],
            [-1, 8+lightness_sample, -1],
            [-1, -1, -1]
        ], dtype=np.float32)
        matrix = (
            (1-alpha_sample) * matrix_nochange
            + alpha_sample * matrix_effect
        )
        return [matrix] * nb_channels


</source>
<source file="systems/imgaug-0.4.0/imgaug/augmenters/convolutional.py" startline="537" endline="564" pcid="355">
    def __call__(self, _image, nb_channels, random_state):
        alpha_sample = self.alpha.draw_sample(random_state=random_state)
        assert 0 <= alpha_sample <= 1.0, (
            "Expected 'alpha' to be in the interval [0.0, 1.0], "
            "got %.4f." % (alpha_sample,))
        matrix_nochange = np.array([
            [0, 0, 0],
            [0, 1, 0],
            [0, 0, 0]
        ], dtype=np.float32)
        matrix_effect = np.array([
            [0, 1, 0],
            [1, -4, 1],
            [0, 1, 0]
        ], dtype=np.float32)
        matrix = (
            (1-alpha_sample) * matrix_nochange
            + alpha_sample * matrix_effect
        )
        return [matrix] * nb_channels


# TODO add tests
# TODO merge EdgeDetect and DirectedEdgeDetect?
# TODO deprecate and rename to AngledEdgeDetect
# TODO rename arg "direction" to "angle"
# TODO change direction/angle value range to (0, 360)
# TODO move this to edges.py?
</source>
<source file="systems/imgaug-0.4.0/imgaug/augmenters/convolutional.py" startline="444" endline="468" pcid="352">
    def __call__(self, _image, nb_channels, random_state):
        alpha_sample = self.alpha.draw_sample(random_state=random_state)
        assert 0 <= alpha_sample <= 1.0, (
            "Expected 'alpha' to be in the interval [0.0, 1.0], "
            "got %.4f." % (alpha_sample,))
        strength_sample = self.strength.draw_sample(random_state=random_state)
        matrix_nochange = np.array([
            [0, 0, 0],
            [0, 1, 0],
            [0, 0, 0]
        ], dtype=np.float32)
        matrix_effect = np.array([
            [-1-strength_sample, 0-strength_sample, 0],
            [0-strength_sample, 1, 0+strength_sample],
            [0, 0+strength_sample, 1+strength_sample]
        ], dtype=np.float32)
        matrix = (
            (1-alpha_sample) * matrix_nochange
            + alpha_sample * matrix_effect
        )
        return [matrix] * nb_channels


# TODO add tests
# TODO move this to edges.py?
</source>
</class>

<class classid="13" nclones="2" nlines="15" similarity="73">
<source file="systems/imgaug-0.4.0/imgaug/augmenters/contrast.py" startline="98" endline="174" pcid="367">
def adjust_contrast_gamma(arr, gamma):
    """
    Adjust image contrast by scaling pixel values to ``255*((v/255)**gamma)``.

    **Supported dtypes**:

        * ``uint8``: yes; fully tested (1) (2) (3)
        * ``uint16``: yes; tested (2) (3)
        * ``uint32``: yes; tested (2) (3)
        * ``uint64``: yes; tested (2) (3) (4)
        * ``int8``: limited; tested (2) (3) (5)
        * ``int16``: limited; tested (2) (3) (5)
        * ``int32``: limited; tested (2) (3) (5)
        * ``int64``: limited; tested (2) (3) (4) (5)
        * ``float16``: limited; tested (5)
        * ``float32``: limited; tested (5)
        * ``float64``: limited; tested (5)
        * ``float128``: no (6)
        * ``bool``: no (7)

        - (1) Handled by ``cv2``. Other dtypes are handled by ``skimage``.
        - (2) Normalization is done as ``I_ij/max``, where ``max`` is the
              maximum value of the dtype, e.g. 255 for ``uint8``. The
              normalization is reversed afterwards, e.g. ``result*255`` for
              ``uint8``.
        - (3) Integer-like values are not rounded after applying the contrast
              adjustment equation (before inverting the normalization to
              ``[0.0, 1.0]`` space), i.e. projection from continuous
              space to discrete happens according to floor function.
        - (4) Note that scikit-image doc says that integers are converted to
              ``float64`` values before applying the contrast normalization
              method. This might lead to inaccuracies for large 64bit integer
              values. Tests showed no indication of that happening though.
        - (5) Must not contain negative values. Values >=0 are fully supported.
        - (6) Leads to error in scikit-image.
        - (7) Does not make sense for contrast adjustments.

    Parameters
    ----------
    arr : numpy.ndarray
        Array for which to adjust the contrast. Dtype ``uint8`` is fastest.

    gamma : number
        Exponent for the contrast adjustment. Higher values darken the image.

    Returns
    -------
    numpy.ndarray
        Array with adjusted contrast.

    """
    if arr.size == 0:
        return np.copy(arr)

    # int8 is also possible according to docs
    # https://docs.opencv.org/3.0-beta/modules/core/doc/operations_on_arrays.html#cv2.LUT ,
    # but here it seemed like `d` was 0 for CV_8S, causing that to fail
    if arr.dtype.name == "uint8":
        min_value, _center_value, max_value = \
            iadt.get_value_range_of_dtype(arr.dtype)
        dynamic_range = max_value - min_value

        value_range = np.linspace(0, 1.0, num=dynamic_range+1,
                                  dtype=np.float32)

        # 255 * ((I_ij/255)**gamma)
        # using np.float32(.) here still works when the input is a numpy array
        # of size 1
        table = (min_value
                 + (value_range ** np.float32(gamma))
                 * dynamic_range)
        table = np.clip(table, min_value, max_value).astype(arr.dtype)
        arr_aug = ia.apply_lut(arr, table)
        return arr_aug
    return ski_exposure.adjust_gamma(arr, gamma)


</source>
<source file="systems/imgaug-0.4.0/imgaug/augmenters/contrast.py" startline="261" endline="340" pcid="369">
# TODO quite similar to the other adjust_contrast_*() functions, make DRY
# TODO add dtype gating
def adjust_contrast_log(arr, gain):
    """
    Adjust image contrast by scaling pixels to ``255*gain*log_2(1+v/255)``.

    **Supported dtypes**:

        * ``uint8``: yes; fully tested (1) (2) (3)
        * ``uint16``: yes; tested (2) (3)
        * ``uint32``: no; tested (2) (3) (8)
        * ``uint64``: no; tested (2) (3) (4) (8)
        * ``int8``: limited; tested (2) (3) (5)
        * ``int16``: limited; tested (2) (3) (5)
        * ``int32``: no; tested (2) (3) (5) (8)
        * ``int64``: no; tested (2) (3) (4) (5) (8)
        * ``float16``: limited; tested (5)
        * ``float32``: limited; tested (5)
        * ``float64``: limited; tested (5)
        * ``float128``: no (6)
        * ``bool``: no (7)

        - (1) Handled by ``cv2``. Other dtypes are handled by ``skimage``.
        - (2) Normalization is done as ``I_ij/max``, where ``max`` is the
              maximum value of the dtype, e.g. 255 for ``uint8``. The
              normalization is reversed afterwards, e.g. ``result*255`` for
              ``uint8``.
        - (3) Integer-like values are not rounded after applying the contrast
              adjustment equation (before inverting the normalization
              to ``[0.0, 1.0]`` space), i.e. projection from continuous
              space to discrete happens according to floor function.
        - (4) Note that scikit-image doc says that integers are converted to
              ``float64`` values before applying the contrast normalization
              method. This might lead to inaccuracies for large 64bit integer
              values. Tests showed no indication of that happening though.
        - (5) Must not contain negative values. Values >=0 are fully supported.
        - (6) Leads to error in scikit-image.
        - (7) Does not make sense for contrast adjustments.
        - (8) No longer supported since numpy 1.17. Previously: 'yes' for
              ``uint32``, ``uint64``; 'limited' for ``int32``, ``int64``.

    Parameters
    ----------
    arr : numpy.ndarray
        Array for which to adjust the contrast. Dtype ``uint8`` is fastest.

    gain : number
        Multiplier for the logarithm result. Values around 1.0 lead to a
        contrast-adjusted images. Values above 1.0 quickly lead to partially
        broken images due to exceeding the datatype's value range.

    Returns
    -------
    numpy.ndarray
        Array with adjusted contrast.

    """
    if arr.size == 0:
        return np.copy(arr)

    # int8 is also possible according to docs
    # https://docs.opencv.org/3.0-beta/modules/core/doc/operations_on_arrays.html#cv2.LUT ,
    # but here it seemed like `d` was 0 for CV_8S, causing that to fail
    if arr.dtype.name == "uint8":
        min_value, _center_value, max_value = \
            iadt.get_value_range_of_dtype(arr.dtype)
        dynamic_range = max_value - min_value

        value_range = np.linspace(0, 1.0, num=dynamic_range+1,
                                  dtype=np.float32)

        # 255 * 1/(1 + exp(gain*(cutoff - I_ij/255)))
        # using np.float32(.) here still works when the input is a numpy array
        # of size 1
        gain = np.float32(gain)
        table = min_value + dynamic_range * gain * np.log2(1 + value_range)
        table = np.clip(table, min_value, max_value).astype(arr.dtype)
        arr_aug = ia.apply_lut(arr, table)
        return arr_aug
    return ski_exposure.adjust_log(arr, gain=gain)
</source>
</class>

<class classid="14" nclones="2" nlines="15" similarity="93">
<source file="systems/imgaug-0.4.0/imgaug/augmenters/contrast.py" startline="481" endline="497" pcid="371">
    Same as in the previous example, but ``gamma`` is sampled once per image
    *and* channel.

    """

    def __init__(self, gamma=(0.7, 1.7), per_channel=False,
                 seed=None, name=None,
                 random_state="deprecated", deterministic="deprecated"):
        params1d = [iap.handle_continuous_param(
            gamma, "gamma", value_range=None, tuple_to_uniform=True,
            list_to_choice=True)]
        func = adjust_contrast_gamma
        super(GammaContrast, self).__init__(
            func, params1d, per_channel,
            dtypes_allowed=["uint8", "uint16", "uint32", "uint64",
                            "int8", "int16", "int32", "int64",
                            "float16", "float32", "float64"],
</source>
<source file="systems/imgaug-0.4.0/imgaug/augmenters/contrast.py" startline="667" endline="685" pcid="373">

    Same as in the previous example, but ``gain`` is sampled once per image
    *and* channel.

    """
    def __init__(self, gain=(0.4, 1.6), per_channel=False,
                 seed=None, name=None,
                 random_state="deprecated", deterministic="deprecated"):
        # TODO add inv parameter?
        params1d = [iap.handle_continuous_param(
            gain, "gain", value_range=(0, None), tuple_to_uniform=True,
            list_to_choice=True)]
        func = adjust_contrast_log

        super(LogContrast, self).__init__(
            func, params1d, per_channel,
            dtypes_allowed=["uint8", "uint16", "uint32", "uint64",
                            "int8", "int16", "int32", "int64",
                            "float16", "float32", "float64"],
</source>
</class>

<class classid="15" nclones="2" nlines="24" similarity="100">
<source file="systems/imgaug-0.4.0/imgaug/augmenters/contrast.py" startline="1274" endline="1305" pcid="382">

        self.intensity_channel_based_applier = _IntensityChannelBasedApplier(
            from_colorspace, to_colorspace)

    # Added in 0.4.0.
    def _augment_batch_(self, batch, random_state, parents, hooks):
        if batch.images is None:
            return batch

        images = batch.images

        iadt.gate_dtypes(
            images,
            allowed=["uint8"],
            disallowed=["bool",
                        "uint16", "uint32", "uint64", "uint128", "uint256",
                        "int8", "int16", "int32", "int64", "int128", "int256",
                        "float16", "float32", "float64", "float96", "float128",
                        "float256"],
            augmenter=self)

        def _augment_all_channels_clahe(images_normalized,
                                        random_state_derived):
            # pylint: disable=protected-access
            # TODO would .augment_batch() be sufficient here?
            batch_imgs = _BatchInAugmentation(
                images=images_normalized)
            return self.all_channel_clahe._augment_batch_(
                batch_imgs, random_state_derived, parents + [self],
                hooks
            ).images

</source>
<source file="systems/imgaug-0.4.0/imgaug/augmenters/contrast.py" startline="1547" endline="1578" pcid="389">
                name="%s_AllChannelsHistogramEqualization" % (name,))

        self.intensity_channel_based_applier = _IntensityChannelBasedApplier(
            from_colorspace, to_colorspace)

    # Added in 0.4.0.
    def _augment_batch_(self, batch, random_state, parents, hooks):
        if batch.images is None:
            return batch

        images = batch.images

        iadt.gate_dtypes(
            images,
            allowed=["uint8"],
            disallowed=["bool",
                        "uint16", "uint32", "uint64", "uint128", "uint256",
                        "int8", "int16", "int32", "int64", "int128", "int256",
                        "float16", "float32", "float64", "float96", "float128",
                        "float256"],
            augmenter=self)

        def _augment_all_channels_histogram_equalization(images_normalized,
                                                         random_state_derived):
            # pylint: disable=protected-access
            # TODO would .augment_batch() be sufficient here
            batch_imgs = _BatchInAugmentation(
                images=images_normalized)
            return self.all_channel_histogram_equalization._augment_batch_(
                batch_imgs, random_state_derived, parents + [self],
                hooks
            ).images
</source>
</class>

<class classid="16" nclones="2" nlines="30" similarity="93">
<source file="systems/imgaug-0.4.0/imgaug/external/poly_point_isect_py2py3.py" startline="875" endline="914" pcid="465">
    def succ_item(self, key, default=_sentinel):
        """Get successor (k,v) pair of key, raises KeyError if key is max key
        or key does not exist. optimized for pypy.
        """
        # removed graingets version, because it was little slower on CPython and much slower on pypy
        # this version runs about 4x faster with pypy than the Cython version
        # Note: Code sharing of succ_item() and ceiling_item() is possible, but has always a speed penalty.
        node = self._root
        succ_node = None
        while node is not None:
            cmp = self._cmp(self._cmp_data, key, node.key)
            if cmp == 0:
                break
            elif cmp < 0:
                if (succ_node is None) or self._cmp(self._cmp_data, node.key, succ_node.key) < 0:
                    succ_node = node
                node = node.left
            else:
                node = node.right

        if node is None:  # stay at dead end
            if default is _sentinel:
                raise KeyError(str(key))
            return default
        # found node of key
        if node.right is not None:
            # find smallest node of right subtree
            node = node.right
            while node.left is not None:
                node = node.left
            if succ_node is None:
                succ_node = node
            elif self._cmp(self._cmp_data, node.key, succ_node.key) < 0:
                succ_node = node
        elif succ_node is None:  # given key is biggest in tree
            if default is _sentinel:
                raise KeyError(str(key))
            return default
        return succ_node.key, succ_node.value

</source>
<source file="systems/imgaug-0.4.0/imgaug/external/poly_point_isect_py2py3.py" startline="915" endline="955" pcid="466">
    def prev_item(self, key, default=_sentinel):
        """Get predecessor (k,v) pair of key, raises KeyError if key is min key
        or key does not exist. optimized for pypy.
        """
        # removed graingets version, because it was little slower on CPython and much slower on pypy
        # this version runs about 4x faster with pypy than the Cython version
        # Note: Code sharing of prev_item() and floor_item() is possible, but has always a speed penalty.
        node = self._root
        prev_node = None

        while node is not None:
            cmp = self._cmp(self._cmp_data, key, node.key)
            if cmp == 0:
                break
            elif cmp < 0:
                node = node.left
            else:
                if (prev_node is None) or self._cmp(self._cmp_data, prev_node.key, node.key) < 0:
                    prev_node = node
                node = node.right

        if node is None:  # stay at dead end (None)
            if default is _sentinel:
                raise KeyError(str(key))
            return default
        # found node of key
        if node.left is not None:
            # find biggest node of left subtree
            node = node.left
            while node.right is not None:
                node = node.right
            if prev_node is None:
                prev_node = node
            elif self._cmp(self._cmp_data, prev_node.key, node.key) < 0:
                prev_node = node
        elif prev_node is None:  # given key is smallest in tree
            if default is _sentinel:
                raise KeyError(str(key))
            return default
        return prev_node.key, prev_node.value

</source>
</class>

<class classid="17" nclones="2" nlines="15" similarity="73">
<source file="systems/imgaug-0.4.0/imgaug/augmentables/normalization.py" startline="72" endline="96" pcid="499">
def _assert_many_arrays_ndim(arrs, ndim, shape_str, to_ntype):
    # For polygons, this can be a list of lists of arrays, hence we must
    # flatten the lists here.
    # itertools.chain.from_iterable() seems to flatten the arrays too, so it
    # cannot be used here.
    iterable_type_str = "iterable"
    if len(arrs) == 0:
        arrs_flat = []
    elif ia.is_np_array(arrs[0]):
        arrs_flat = arrs
    else:
        iterable_type_str = "iterable of iterable"
        arrs_flat = [arr for arrs_sublist in arrs for arr in arrs_sublist]

    if any([arr.ndim != ndim for arr in arrs_flat]):
        raise ValueError(
            "Tried to convert an %s of arrays to a list of "
            "%s. Expected each array to be of shape %s, "
            "i.e. to be %d-dimensional, but got dimensions %s "
            "instead (array shapes: %s)." % (
                iterable_type_str, to_ntype, shape_str, ndim,
                ", ".join([str(arr.ndim) for arr in arrs_flat]),
                ", ".join([str(arr.shape) for arr in arrs_flat])))


</source>
<source file="systems/imgaug-0.4.0/imgaug/augmentables/normalization.py" startline="106" endline="129" pcid="501">
def _assert_many_arrays_last_dim_exactly(arrs, size, to_ntype):
    # For polygons, this can be a list of lists of arrays, hence we must
    # flatten the lists here.
    # itertools.chain.from_iterable() seems to flatten the arrays too, so it
    # cannot be used here.
    iterable_type_str = "iterable"
    if len(arrs) == 0:
        arrs_flat = []
    elif ia.is_np_array(arrs[0]):
        arrs_flat = arrs
    else:
        iterable_type_str = "iterable of iterable"
        arrs_flat = [arr for arrs_sublist in arrs for arr in arrs_sublist]

    if any([arr.shape[-1] != size for arr in arrs_flat]):
        raise ValueError(
            "Tried to convert an %s of array to a list of %s. Expected the "
            "arrays' last dimensions to have size %d, but got %s instead "
            "(array shapes: %s)." % (
                iterable_type_str, to_ntype, size,
                ", ".join([str(arr.shape[-1]) for arr in arrs_flat]),
                ", ".join([str(arr.shape) for arr in arrs_flat])))


</source>
</class>

<class classid="18" nclones="2" nlines="67" similarity="85">
<source file="systems/imgaug-0.4.0/imgaug/augmentables/normalization.py" startline="233" endline="305" pcid="505">
def normalize_keypoints(inputs, shapes=None):
    # TODO get rid of this deferred import
    from imgaug.augmentables.kps import Keypoint, KeypointsOnImage

    shapes = _preprocess_shapes(shapes)
    ntype = estimate_keypoints_norm_type(inputs)
    _assert_exactly_n_shapes_partial = functools.partial(
        _assert_exactly_n_shapes,
        from_ntype=ntype, to_ntype="List[KeypointsOnImage]",
        shapes=shapes)

    if ntype == "None":
        return inputs
    if ntype in ["array[float]", "array[int]", "array[uint]"]:
        _assert_single_array_ndim(inputs, 3, "(N,K,2)", "KeypointsOnImage")
        _assert_single_array_last_dim_exactly(inputs, 2, "KeypointsOnImage")
        _assert_exactly_n_shapes_partial(n=len(inputs))
        return [
            KeypointsOnImage.from_xy_array(attr_i, shape=shape)
            for attr_i, shape
            in zip(inputs, shapes)
        ]
    if ntype == "tuple[number,size=2]":
        _assert_exactly_n_shapes_partial(n=1)
        return [KeypointsOnImage([Keypoint(x=inputs[0], y=inputs[1])],
                                 shape=shapes[0])]
    if ntype == "Keypoint":
        _assert_exactly_n_shapes_partial(n=1)
        return [KeypointsOnImage([inputs], shape=shapes[0])]
    if ntype == "KeypointsOnImage":
        return [inputs]
    if ntype == "iterable[empty]":
        return None
    if ntype in ["iterable-array[float]",
                 "iterable-array[int]",
                 "iterable-array[uint]"]:
        _assert_many_arrays_ndim(inputs, 2, "(K,2)", "KeypointsOnImage")
        _assert_many_arrays_last_dim_exactly(inputs, 2, "KeypointsOnImage")
        _assert_exactly_n_shapes_partial(n=len(inputs))
        return [
            KeypointsOnImage.from_xy_array(attr_i, shape=shape)
            for attr_i, shape
            in zip(inputs, shapes)
        ]
    if ntype == "iterable-tuple[number,size=2]":
        _assert_exactly_n_shapes_partial(n=1)
        return [KeypointsOnImage([Keypoint(x=x, y=y) for x, y in inputs],
                                 shape=shapes[0])]
    if ntype == "iterable-Keypoint":
        _assert_exactly_n_shapes_partial(n=1)
        return [KeypointsOnImage(inputs, shape=shapes[0])]
    if ntype == "iterable-KeypointsOnImage":
        return inputs
    if ntype == "iterable-iterable[empty]":
        return None
    if ntype == "iterable-iterable-tuple[number,size=2]":
        _assert_exactly_n_shapes_partial(n=len(inputs))
        return [
            KeypointsOnImage.from_xy_array(
                np.array(attr_i, dtype=np.float32),
                shape=shape)
            for attr_i, shape
            in zip(inputs, shapes)
        ]

    assert ntype == "iterable-iterable-Keypoint", (
        "Got unknown normalization type '%s'." % (ntype,))
    _assert_exactly_n_shapes_partial(n=len(inputs))
    return [KeypointsOnImage(attr_i, shape=shape)
            for attr_i, shape
            in zip(inputs, shapes)]


</source>
<source file="systems/imgaug-0.4.0/imgaug/augmentables/normalization.py" startline="306" endline="388" pcid="506">
def normalize_bounding_boxes(inputs, shapes=None):
    # TODO get rid of this deferred import
    from imgaug.augmentables.bbs import BoundingBox, BoundingBoxesOnImage

    shapes = _preprocess_shapes(shapes)
    ntype = estimate_bounding_boxes_norm_type(inputs)
    _assert_exactly_n_shapes_partial = functools.partial(
        _assert_exactly_n_shapes,
        from_ntype=ntype, to_ntype="List[BoundingBoxesOnImage]",
        shapes=shapes)

    if ntype == "None":
        return None
    if ntype in ["array[float]", "array[int]", "array[uint]"]:
        _assert_single_array_ndim(inputs, 3, "(N,B,4)", "BoundingBoxesOnImage")
        _assert_single_array_last_dim_exactly(
            inputs, 4, "BoundingBoxesOnImage")
        _assert_exactly_n_shapes_partial(n=len(inputs))
        return [
            BoundingBoxesOnImage.from_xyxy_array(attr_i, shape=shape)
            for attr_i, shape
            in zip(inputs, shapes)
        ]
    if ntype == "tuple[number,size=4]":
        _assert_exactly_n_shapes_partial(n=1)
        return [
            BoundingBoxesOnImage(
                [BoundingBox(
                    x1=inputs[0], y1=inputs[1],
                    x2=inputs[2], y2=inputs[3])],
                shape=shapes[0])
        ]
    if ntype == "BoundingBox":
        _assert_exactly_n_shapes_partial(n=1)
        return [BoundingBoxesOnImage([inputs], shape=shapes[0])]
    if ntype == "BoundingBoxesOnImage":
        return [inputs]
    if ntype == "iterable[empty]":
        return None
    if ntype in ["iterable-array[float]",
                 "iterable-array[int]",
                 "iterable-array[uint]"]:
        _assert_many_arrays_ndim(inputs, 2, "(B,4)", "BoundingBoxesOnImage")
        _assert_many_arrays_last_dim_exactly(inputs, 4, "BoundingBoxesOnImage")
        _assert_exactly_n_shapes_partial(n=len(inputs))
        return [
            BoundingBoxesOnImage.from_xyxy_array(attr_i, shape=shape)
            for attr_i, shape
            in zip(inputs, shapes)
        ]
    if ntype == "iterable-tuple[number,size=4]":
        _assert_exactly_n_shapes_partial(n=1)
        return [
            BoundingBoxesOnImage(
                [BoundingBox(x1=x1, y1=y1, x2=x2, y2=y2)
                 for x1, y1, x2, y2 in inputs],
                shape=shapes[0])
        ]
    if ntype == "iterable-BoundingBox":
        _assert_exactly_n_shapes_partial(n=1)
        return [BoundingBoxesOnImage(inputs, shape=shapes[0])]
    if ntype == "iterable-BoundingBoxesOnImage":
        return inputs
    if ntype == "iterable-iterable[empty]":
        return None
    if ntype == "iterable-iterable-tuple[number,size=4]":
        _assert_exactly_n_shapes_partial(n=len(inputs))
        return [
            BoundingBoxesOnImage.from_xyxy_array(
                np.array(attr_i, dtype=np.float32),
                shape=shape)
            for attr_i, shape
            in zip(inputs, shapes)
        ]

    assert ntype == "iterable-iterable-BoundingBox", (
        "Got unknown normalization type '%s'." % (ntype,))
    _assert_exactly_n_shapes_partial(n=len(inputs))
    return [BoundingBoxesOnImage(attr_i, shape=shape)
            for attr_i, shape
            in zip(inputs, shapes)]


</source>
</class>

<class classid="19" nclones="2" nlines="32" similarity="72">
<source file="systems/imgaug-0.4.0/imgaug/augmentables/normalization.py" startline="589" endline="628" pcid="511">
def invert_normalize_heatmaps(heatmaps, heatmaps_old):
    ntype = estimate_heatmaps_norm_type(heatmaps_old)
    if ntype == "None":
        assert heatmaps is None, (
            "Expected (normalized) 'heatmaps' to be None due (unnormalized) "
            "'heatmaps_old' being None. Got type %s instead." % (
                type(heatmaps),))
        return heatmaps
    if ntype == "array[float]":
        assert len(heatmaps) == heatmaps_old.shape[0], (
            "Expected as many heatmaps after normalization as before "
            "normalization. Got %d (after) and %d (before)." % (
                len(heatmaps), heatmaps_old.shape[0]))
        input_dtype = heatmaps_old.dtype
        return restore_dtype_and_merge(
            [hm_i.arr_0to1 for hm_i in heatmaps],
            input_dtype)
    if ntype == "HeatmapsOnImage":
        assert len(heatmaps) == 1, (
            "Expected as many heatmaps after normalization as before "
            "normalization. Got %d (after) and %d (before)." % (
                len(heatmaps), 1))
        return heatmaps[0]
    if ntype == "iterable[empty]":
        assert heatmaps is None, (
            "Expected heatmaps after normalization to be None, due to the "
            "heatmaps before normalization being an empty iterable. "
            "Got type %s instead." % (type(heatmaps),))
        return []
    if ntype == "iterable-array[float]":
        nonempty, _, _ = find_first_nonempty(heatmaps_old)
        input_dtype = nonempty.dtype
        return [restore_dtype_and_merge(hm_i.arr_0to1, input_dtype)
                for hm_i in heatmaps]

    assert ntype == "iterable-HeatmapsOnImage", (
        "Got unknown normalization type '%s'." % (ntype,))
    return heatmaps


</source>
<source file="systems/imgaug-0.4.0/imgaug/augmentables/normalization.py" startline="629" endline="671" pcid="512">
def invert_normalize_segmentation_maps(segmentation_maps,
                                       segmentation_maps_old):
    ntype = estimate_segmaps_norm_type(segmentation_maps_old)
    if ntype == "None":
        assert segmentation_maps is None, (
            "Expected (normalized) 'segmentation_maps' to be None due "
            "(unnormalized) 'segmentation_maps_old' being None. Got type %s "
            "instead." % (type(segmentation_maps),))
        return segmentation_maps
    if ntype in ["array[int]", "array[uint]", "array[bool]"]:
        assert len(segmentation_maps) == segmentation_maps_old.shape[0], (
            "Expected as many segmentation maps after normalization as before "
            "normalization. Got %d (after) and %d (before)." % (
                len(segmentation_maps), segmentation_maps_old.shape[0]))
        input_dtype = segmentation_maps_old.dtype
        return restore_dtype_and_merge(
            [segmap_i.get_arr() for segmap_i in segmentation_maps],
            input_dtype)
    if ntype == "SegmentationMapsOnImage":
        assert len(segmentation_maps) == 1, (
            "Expected as many segmentation maps after normalization as before "
            "normalization. Got %d (after) and %d (before)." % (
                len(segmentation_maps), 1))
        return segmentation_maps[0]
    if ntype == "iterable[empty]":
        assert segmentation_maps is None, (
            "Expected segmentation maps after normalization to be None, due "
            "to the segmentation maps before normalization being an empty "
            "iterable. Got type %s instead." % (type(segmentation_maps),))
        return []
    if ntype in ["iterable-array[int]",
                 "iterable-array[uint]",
                 "iterable-array[bool]"]:
        nonempty, _, _ = find_first_nonempty(segmentation_maps_old)
        input_dtype = nonempty.dtype
        return [restore_dtype_and_merge(segmap_i.get_arr(), input_dtype)
                for segmap_i in segmentation_maps]

    assert ntype == "iterable-SegmentationMapsOnImage", (
        "Got unknown normalization type '%s'." % (ntype,))
    return segmentation_maps


</source>
</class>

<class classid="20" nclones="2" nlines="23" similarity="91">
<source file="systems/imgaug-0.4.0/imgaug/augmentables/normalization.py" startline="1091" endline="1115" pcid="521">
def estimate_keypoints_norm_type(keypoints):
    type_str = estimate_normalization_type(keypoints)
    valid_type_strs = [
        "None",
        "array[float]",
        "array[int]",
        "array[uint]",
        "tuple[number,size=2]",
        "Keypoint",
        "KeypointsOnImage",
        "iterable[empty]",
        "iterable-array[float]",
        "iterable-array[int]",
        "iterable-array[uint]",
        "iterable-tuple[number,size=2]",
        "iterable-Keypoint",
        "iterable-KeypointsOnImage",
        "iterable-iterable[empty]",
        "iterable-iterable-tuple[number,size=2]",
        "iterable-iterable-Keypoint"
    ]
    _assert_is_of_norm_type(type_str, valid_type_strs, "keypoints")
    return type_str


</source>
<source file="systems/imgaug-0.4.0/imgaug/augmentables/normalization.py" startline="1116" endline="1141" pcid="522">
def estimate_bounding_boxes_norm_type(bounding_boxes):
    type_str = estimate_normalization_type(bounding_boxes)
    valid_type_strs = [
        "None",
        "array[float]",
        "array[int]",
        "array[uint]",
        "tuple[number,size=4]",
        "BoundingBox",
        "BoundingBoxesOnImage",
        "iterable[empty]",
        "iterable-array[float]",
        "iterable-array[int]",
        "iterable-array[uint]",
        "iterable-tuple[number,size=4]",
        "iterable-BoundingBox",
        "iterable-BoundingBoxesOnImage",
        "iterable-iterable[empty]",
        "iterable-iterable-tuple[number,size=4]",
        "iterable-iterable-BoundingBox"
    ]
    _assert_is_of_norm_type(
        type_str, valid_type_strs, "bounding_boxes")
    return type_str


</source>
</class>

<class classid="21" nclones="2" nlines="12" similarity="76">
<source file="systems/imgaug-0.4.0/imgaug/augmentables/lines.py" startline="780" endline="824" pcid="738">
    def draw_lines_heatmap_array(self, image_shape, alpha=1.0,
                                 size=1, antialiased=True,
                                 raise_if_out_of_image=False):
        """Draw the line segments of this line string as a heatmap array.

        Parameters
        ----------
        image_shape : tuple of int
            The shape of the image onto which to draw the line mask.

        alpha : float, optional
            Opacity of the line string. Higher values denote a more visible
            line string.

        size : int, optional
            Thickness of the line segments.

        antialiased : bool, optional
            Whether to draw the line with anti-aliasing activated.

        raise_if_out_of_image : bool, optional
            Whether to raise an error if the line string is fully
            outside of the image. If set to ``False``, no error will be
            raised and only the parts inside the image will be drawn.

        Returns
        -------
        ndarray
            ``float32`` array of shape `image_shape` (no channel axis) with
            drawn line string. All values are in the interval ``[0.0, 1.0]``.

        """
        assert len(image_shape) == 2 or (
            len(image_shape) == 3 and image_shape[-1] == 1), (
                "Expected (H,W) or (H,W,1) as image_shape, got %s." % (
                    image_shape,))

        arr = self.draw_lines_on_image(
            np.zeros(image_shape, dtype=np.uint8),
            color=255, alpha=alpha, size=size,
            antialiased=antialiased,
            raise_if_out_of_image=raise_if_out_of_image
        )
        return arr.astype(np.float32) / 255.0

</source>
<source file="systems/imgaug-0.4.0/imgaug/augmentables/lines.py" startline="825" endline="865" pcid="739">
    def draw_points_heatmap_array(self, image_shape, alpha=1.0,
                                  size=1, raise_if_out_of_image=False):
        """Draw the points of this line string as a heatmap array.

        Parameters
        ----------
        image_shape : tuple of int
            The shape of the image onto which to draw the point mask.

        alpha : float, optional
            Opacity of the line string points. Higher values denote a more
            visible points.

        size : int, optional
            Size of the points in pixels.

        raise_if_out_of_image : bool, optional
            Whether to raise an error if the line string is fully
            outside of the image. If set to ``False``, no error will be
            raised and only the parts inside the image will be drawn.

        Returns
        -------
        ndarray
            ``float32`` array of shape `image_shape` (no channel axis) with
            drawn line string points. All values are in the
            interval ``[0.0, 1.0]``.

        """
        assert len(image_shape) == 2 or (
            len(image_shape) == 3 and image_shape[-1] == 1), (
                "Expected (H,W) or (H,W,1) as image_shape, got %s." % (
                    image_shape,))

        arr = self.draw_points_on_image(
            np.zeros(image_shape, dtype=np.uint8),
            color=255, alpha=alpha, size=size,
            raise_if_out_of_image=raise_if_out_of_image
        )
        return arr.astype(np.float32) / 255.0

</source>
</class>

<class classid="22" nclones="3" nlines="11" similarity="72">
<source file="systems/imgaug-0.4.0/imgaug/random.py" startline="623" endline="644" pcid="842">
    def standard_exponential(self, size=None, dtype="float32", method="zig",
                             out=None):
        """Call :func:`numpy.random.Generator.standard_exponential`.

        .. note::

            Changed `dtype` argument default value from numpy's ``d`` to
            ``float32``.

        """
        if self._is_new_rng_style:
            return self.generator.standard_exponential(
                size=size, dtype=dtype, method=method, out=out)
        result = self.generator.standard_exponential(size=size).astype(dtype)
        if out is not None:
            assert out.dtype.name == result.dtype.name, (
                "Expected out array to have the same dtype as "
                "standard_exponential()'s result array. Got %s (out) and "
                "%s (result) instead." % (out.dtype.name, result.dtype.name))
            out[...] = result
        return result

</source>
<source file="systems/imgaug-0.4.0/imgaug/random.py" startline="667" endline="687" pcid="844">
    def standard_normal(self, size=None, dtype="float32", out=None):
        """Call :func:`numpy.random.Generator.standard_normal`.

        .. note::

            Changed `dtype` argument default value from numpy's ``d`` to
            ``float32``.

        """
        if self._is_new_rng_style:
            return self.generator.standard_normal(
                size=size, dtype=dtype, out=out)
        result = self.generator.standard_normal(size=size).astype(dtype)
        if out is not None:
            assert out.dtype.name == result.dtype.name, (
                "Expected out array to have the same dtype as "
                "standard_normal()'s result array. Got %s (out) and "
                "%s (result) instead." % (out.dtype.name, result.dtype.name))
            out[...] = result
        return result

</source>
<source file="systems/imgaug-0.4.0/imgaug/random.py" startline="645" endline="666" pcid="843">
    def standard_gamma(self, shape, size=None, dtype="float32", out=None):
        """Call :func:`numpy.random.Generator.standard_gamma`.

        .. note::

            Changed `dtype` argument default value from numpy's ``d`` to
            ``float32``.

        """
        if self._is_new_rng_style:
            return self.generator.standard_gamma(
                shape=shape, size=size, dtype=dtype, out=out)
        result = self.generator.standard_gamma(
            shape=shape, size=size).astype(dtype)
        if out is not None:
            assert out.dtype.name == result.dtype.name, (
                "Expected out array to have the same dtype as "
                "standard_gamma()'s result array. Got %s (out) and "
                "%s (result) instead." % (out.dtype.name, result.dtype.name))
            out[...] = result
        return result

</source>
</class>

<class classid="23" nclones="3" nlines="13" similarity="76">
<source file="systems/imgaug-0.4.0/imgaug/parameters.py" startline="1852" endline="1868" pcid="1001">
    def _draw_samples(self, size, random_state):
        rngs = random_state.duplicate(2)
        samples = self.other_param.draw_samples(size, random_state=rngs[0])

        elementwise = (
            self.elementwise
            and not isinstance(self.val, Deterministic))

        if elementwise:
            val_samples = self.val.draw_samples(size, random_state=rngs[1])
        else:
            val_samples = self.val.draw_sample(random_state=rngs[1])

        if elementwise:
            return np.multiply(samples, val_samples)
        return samples * val_samples

</source>
<source file="systems/imgaug-0.4.0/imgaug/parameters.py" startline="2099" endline="2114" pcid="1013">
    def _draw_samples(self, size, random_state):
        rngs = random_state.duplicate(2)
        samples = self.other_param.draw_samples(size, random_state=rngs[0])

        elementwise = (self.elementwise
                       and not isinstance(self.val, Deterministic))

        if elementwise:
            val_samples = self.val.draw_samples(size, random_state=rngs[1])
        else:
            val_samples = self.val.draw_sample(random_state=rngs[1])

        if elementwise:
            return np.subtract(samples, val_samples)
        return samples - val_samples

</source>
<source file="systems/imgaug-0.4.0/imgaug/parameters.py" startline="2024" endline="2039" pcid="1009">
    def _draw_samples(self, size, random_state):
        rngs = random_state.duplicate(2)
        samples = self.other_param.draw_samples(size, random_state=rngs[0])

        elementwise = (
            self.elementwise and not isinstance(self.val, Deterministic))

        if elementwise:
            val_samples = self.val.draw_samples(size, random_state=rngs[1])
        else:
            val_samples = self.val.draw_sample(random_state=rngs[1])

        if elementwise:
            return np.add(samples, val_samples)
        return samples + val_samples

</source>
</class>

<class classid="24" nclones="2" nlines="23" similarity="91">
<source file="systems/imgaug-0.4.0/imgaug/parameters.py" startline="2867" endline="2893" pcid="1044">
    def __init__(self, size_px_max=(2, 16),
                 upscale_method=["linear", "nearest"]):
        # pylint: disable=dangerous-default-value
        super(SimplexNoise, self).__init__()
        self.size_px_max = handle_discrete_param(
            size_px_max, "size_px_max", value_range=(1, 10000))

        if upscale_method == ia.ALL:
            self.upscale_method = Choice(["nearest", "linear", "area",
                                          "cubic"])
        elif ia.is_string(upscale_method):
            self.upscale_method = Deterministic(upscale_method)
        elif isinstance(upscale_method, list):
            assert len(upscale_method) >= 1, (
                "Expected at least one upscale method, "
                "got %d." % (len(upscale_method),))
            assert all([ia.is_string(val) for val in upscale_method]), (
                "Expected all upscale methods to be strings, got types %s." % (
                    ", ".join([str(type(v)) for v in upscale_method])))
            self.upscale_method = Choice(upscale_method)
        elif isinstance(upscale_method, StochasticParameter):
            self.upscale_method = upscale_method
        else:
            raise Exception(
                "Expected upscale_method to be string or list of strings or "
                "StochasticParameter, got %s." % (type(upscale_method),))

</source>
<source file="systems/imgaug-0.4.0/imgaug/parameters.py" startline="3069" endline="3097" pcid="1050">
    def __init__(self, exponent=(-4, 4), size_px_max=(4, 32),
                 upscale_method=["linear", "nearest"]):
        # pylint: disable=dangerous-default-value
        super(FrequencyNoise, self).__init__()
        self.exponent = handle_continuous_param(exponent, "exponent")
        self.size_px_max = handle_discrete_param(
            size_px_max, "size_px_max", value_range=(1, 10000))

        if upscale_method == ia.ALL:
            self.upscale_method = Choice(["nearest", "linear", "area",
                                          "cubic"])
        elif ia.is_string(upscale_method):
            self.upscale_method = Deterministic(upscale_method)
        elif isinstance(upscale_method, list):
            assert len(upscale_method) >= 1, (
                "Expected at least one upscale method, "
                "got %d." % (len(upscale_method),))
            assert all([ia.is_string(val) for val in upscale_method]), (
                "Expected all upscale methods to be strings, got types %s." % (
                    ", ".join([str(type(v)) for v in upscale_method])))
            self.upscale_method = Choice(upscale_method)
        elif isinstance(upscale_method, StochasticParameter):
            self.upscale_method = upscale_method
        else:
            raise Exception(
                "Expected upscale_method to be string or list of strings or "
                "StochasticParameter, got %s." % (type(upscale_method),))

    # TODO this is the same as in SimplexNoise, make DRY
</source>
</class>

<class classid="25" nclones="2" nlines="14" similarity="85">
<source file="systems/imgaug-0.4.0/imgaug/multicore.py" startline="285" endline="338" pcid="1071">
    def imap_batches(self, batches, chunksize=1, output_buffer_size=None):
        """
        Augment batches from a generator.

        Pattern for output buffer constraint is from
        https://stackoverflow.com/a/47058399.

        Parameters
        ----------
        batches : generator of imgaug.augmentables.batches.Batch
            The batches to augment, provided as a generator. Each call to the
            generator should yield exactly one batch.

        chunksize : None or int, optional
            Rough indicator of how many tasks should be sent to each worker.
            Increasing this number can improve performance.

        output_buffer_size : None or int, optional
            Max number of batches to handle *at the same time* in the *whole*
            pipeline (including already augmented batches that are waiting to
            be requested). If the buffer size is reached, no new batches will
            be loaded from `batches` until a produced (i.e. augmented) batch is
            consumed (i.e. requested from this method).
            The buffer is unlimited if this is set to ``None``. For large
            datasets, this should be set to an integer value to avoid filling
            the whole RAM if loading+augmentation happens faster than training.

            *New in version 0.3.0.*

        Yields
        ------
        imgaug.augmentables.batches.Batch
            Augmented batch.

        """
        self._assert_batches_is_generator(batches)

        # buffer is either None or a Semaphore
        output_buffer_left = _create_output_buffer_left(output_buffer_size)

        # TODO change this to 'yield from' once switched to 3.3+
        gen = self.pool.imap(
            _Pool_starworker,
            self._ibuffer_batch_loading(
                self._handle_batch_ids_gen(batches),
                output_buffer_left
            ),
            chunksize=chunksize)

        for batch in gen:
            yield batch
            if output_buffer_left is not None:
                output_buffer_left.release()

</source>
<source file="systems/imgaug-0.4.0/imgaug/multicore.py" startline="339" endline="392" pcid="1072">
    def imap_batches_unordered(self, batches, chunksize=1,
                               output_buffer_size=None):
        """Augment batches from a generator (without preservation of order).

        Pattern for output buffer constraint is from
        https://stackoverflow.com/a/47058399.

        Parameters
        ----------
        batches : generator of imgaug.augmentables.batches.Batch
            The batches to augment, provided as a generator. Each call to the
            generator should yield exactly one batch.

        chunksize : None or int, optional
            Rough indicator of how many tasks should be sent to each worker.
            Increasing this number can improve performance.

        output_buffer_size : None or int, optional
            Max number of batches to handle *at the same time* in the *whole*
            pipeline (including already augmented batches that are waiting to
            be requested). If the buffer size is reached, no new batches will
            be loaded from `batches` until a produced (i.e. augmented) batch is
            consumed (i.e. requested from this method).
            The buffer is unlimited if this is set to ``None``. For large
            datasets, this should be set to an integer value to avoid filling
            the whole RAM if loading+augmentation happens faster than training.

            *New in version 0.3.0.*

        Yields
        ------
        imgaug.augmentables.batches.Batch
            Augmented batch.

        """
        self._assert_batches_is_generator(batches)

        # buffer is either None or a Semaphore
        output_buffer_left = _create_output_buffer_left(output_buffer_size)

        gen = self.pool.imap_unordered(
            _Pool_starworker,
            self._ibuffer_batch_loading(
                self._handle_batch_ids_gen(batches),
                output_buffer_left
            ),
            chunksize=chunksize
        )

        for batch in gen:
            yield batch
            if output_buffer_left is not None:
                output_buffer_left.release()

</source>
</class>

<class classid="26" nclones="3" nlines="12" similarity="100">
<source file="systems/imgaug-0.4.0/checks/check_clouds.py" startline="9" endline="24" pcid="1107">
def main():
    for size in [0.1, 0.2, 1.0]:
        image = imageio.imread("https://upload.wikimedia.org/wikipedia/commons/8/89/Kukle%2CCzech_Republic..jpg",
                               format="jpg")
        image = ia.imresize_single_image(image, size, "cubic")
        print(image.shape)
        augs = [
            ("iaa.Clouds()", iaa.Clouds())
        ]

        for descr, aug in augs:
            print(descr)
            images_aug = aug.augment_images([image] * 64)
            ia.imshow(ia.draw_grid(images_aug))


</source>
<source file="systems/imgaug-0.4.0/checks/check_snowflakes.py" startline="9" endline="24" pcid="1114">
def main():
    for size in [0.1, 0.2, 1.0]:
        image = imageio.imread("https://upload.wikimedia.org/wikipedia/commons/8/89/Kukle%2CCzech_Republic..jpg",
                               format="jpg")
        image = ia.imresize_single_image(image, size, "cubic")
        print(image.shape)
        augs = [
            ("iaa.Snowflakes()", iaa.Snowflakes())
        ]

        for descr, aug in augs:
            print(descr)
            images_aug = aug.augment_images([image] * 64)
            ia.imshow(ia.draw_grid(images_aug))


</source>
<source file="systems/imgaug-0.4.0/checks/check_fog.py" startline="9" endline="24" pcid="1163">
def main():
    for size in [0.1, 0.2, 1.0]:
        image = imageio.imread("https://upload.wikimedia.org/wikipedia/commons/8/89/Kukle%2CCzech_Republic..jpg",
                               format="jpg")
        image = ia.imresize_single_image(image, size, "cubic")
        print(image.shape)
        augs = [
            ("iaa.Fog()", iaa.Fog())
        ]

        for descr, aug in augs:
            print(descr)
            images_aug = aug.augment_images([image] * 64)
            ia.imshow(ia.draw_grid(images_aug))


</source>
</class>

<class classid="27" nclones="2" nlines="76" similarity="100">
<source file="systems/imgaug-0.4.0/checks/check_elastic_transformation.py" startline="127" endline="219" pcid="1112">
    def map_coordinates(cls, image, dx, dy, order=1, cval=0, mode="constant"):
        # small debug message to be sure that the right function is executed
        print("map_coordinates() with scipy")

        if order == 0 and image.dtype.name in ["uint64", "int64"]:
            raise Exception(("dtypes uint64 and int64 are only supported in ElasticTransformation for order=0, "
                             + "got order=%d with dtype=%s.") % (order, image.dtype.name))

        input_dtype = image.dtype
        if image.dtype.name == "bool":
            image = image.astype(np.float32)
        elif order == 1 and image.dtype.name in ["int8", "int16", "int32"]:
            image = image.astype(np.float64)
        elif order >= 2 and image.dtype.name == "int8":
            image = image.astype(np.int16)
        elif order >= 2 and image.dtype.name == "int32":
            image = image.astype(np.float64)

        shrt_max = 32767
        backend = "cv2"
        if order == 0:
            bad_dtype_cv2 = (image.dtype.name in ["uint32", "uint64", "int64", "float128", "bool"])
        elif order == 1:
            bad_dtype_cv2 = (image.dtype.name in ["uint32", "uint64", "int8", "int16", "int32", "int64", "float128",
                                                  "bool"])
        else:
            bad_dtype_cv2 = (image.dtype.name in ["uint32", "uint64", "int8", "int32", "int64", "float128", "bool"])

        bad_dx_shape_cv2 = (dx.shape[0] >= shrt_max or dx.shape[1] >= shrt_max)
        bad_dy_shape_cv2 = (dy.shape[0] >= shrt_max or dy.shape[1] >= shrt_max)
        if bad_dtype_cv2 or bad_dx_shape_cv2 or bad_dy_shape_cv2:
            backend = "scipy"

        ia.do_assert(image.ndim == 3)
        result = np.copy(image)
        height, width = image.shape[0:2]
        # True was added here, only difference to usual code
        if True or backend == "scipy":
            h, w = image.shape[0:2]
            y, x = np.meshgrid(np.arange(h).astype(np.float32), np.arange(w).astype(np.float32), indexing='ij')
            x_shifted = x + (-1) * dx
            y_shifted = y + (-1) * dy

            for c in sm.xrange(image.shape[2]):
                remapped_flat = ndimage.interpolation.map_coordinates(
                    image[..., c],
                    (y_shifted.flatten(), x_shifted.flatten()),
                    order=order,
                    cval=cval,
                    mode=mode
                )
                remapped = remapped_flat.reshape((height, width))
                result[..., c] = remapped
        else:
            h, w, nb_channels = image.shape

            y, x = np.meshgrid(np.arange(h).astype(np.float32), np.arange(w).astype(np.float32), indexing='ij')
            x_shifted = x + (-1) * dx
            y_shifted = y + (-1) * dy

            if image.dtype.kind == "f":
                cval = float(cval)
            else:
                cval = int(cval)
            border_mode = cls._MAPPING_MODE_SCIPY_CV2[mode]
            interpolation = cls._MAPPING_ORDER_SCIPY_CV2[order]

            is_nearest_neighbour = (interpolation == cv2.INTER_NEAREST)
            map1, map2 = cv2.convertMaps(x_shifted, y_shifted, cv2.CV_16SC2, nninterpolation=is_nearest_neighbour)
            # remap only supports up to 4 channels
            if nb_channels <= 4:
                result = cv2.remap(image, map1, map2, interpolation=interpolation, borderMode=border_mode, borderValue=cval)
                if image.ndim == 3 and result.ndim == 2:
                    result = result[..., np.newaxis]
            else:
                current_chan_idx = 0
                result = []
                while current_chan_idx < nb_channels:
                    channels = image[..., current_chan_idx:current_chan_idx+4]
                    result_c =  cv2.remap(channels, map1, map2, interpolation=interpolation, borderMode=border_mode,
                                          borderValue=cval)
                    if result_c.ndim == 2:
                        result_c = result_c[..., np.newaxis]
                    result.append(result_c)
                    current_chan_idx += 4
                result = np.concatenate(result, axis=2)

        if result.dtype.name != input_dtype.name:
            result = meta.restore_dtypes_(result, input_dtype)

        return result


</source>
<source file="systems/imgaug-0.4.0/checks/check_elastic_transformation.py" startline="222" endline="314" pcid="1113">
    def map_coordinates(cls, image, dx, dy, order=1, cval=0, mode="constant"):
        # small debug message to be sure that the right function is executed
        print("map_coordinates() with cv2")

        if order == 0 and image.dtype.name in ["uint64", "int64"]:
            raise Exception(("dtypes uint64 and int64 are only supported in ElasticTransformation for order=0, "
                             + "got order=%d with dtype=%s.") % (order, image.dtype.name))

        input_dtype = image.dtype
        if image.dtype.name == "bool":
            image = image.astype(np.float32)
        elif order == 1 and image.dtype.name in ["int8", "int16", "int32"]:
            image = image.astype(np.float64)
        elif order >= 2 and image.dtype.name == "int8":
            image = image.astype(np.int16)
        elif order >= 2 and image.dtype.name == "int32":
            image = image.astype(np.float64)

        shrt_max = 32767
        backend = "cv2"
        if order == 0:
            bad_dtype_cv2 = (image.dtype.name in ["uint32", "uint64", "int64", "float128", "bool"])
        elif order == 1:
            bad_dtype_cv2 = (image.dtype.name in ["uint32", "uint64", "int8", "int16", "int32", "int64", "float128",
                                                  "bool"])
        else:
            bad_dtype_cv2 = (image.dtype.name in ["uint32", "uint64", "int8", "int32", "int64", "float128", "bool"])

        bad_dx_shape_cv2 = (dx.shape[0] >= shrt_max or dx.shape[1] >= shrt_max)
        bad_dy_shape_cv2 = (dy.shape[0] >= shrt_max or dy.shape[1] >= shrt_max)
        if bad_dtype_cv2 or bad_dx_shape_cv2 or bad_dy_shape_cv2:
            backend = "scipy"

        ia.do_assert(image.ndim == 3)
        result = np.copy(image)
        height, width = image.shape[0:2]
        # False was added here, only difference to usual code
        if False or backend == "scipy":
            h, w = image.shape[0:2]
            y, x = np.meshgrid(np.arange(h).astype(np.float32), np.arange(w).astype(np.float32), indexing='ij')
            x_shifted = x + (-1) * dx
            y_shifted = y + (-1) * dy

            for c in sm.xrange(image.shape[2]):
                remapped_flat = ndimage.interpolation.map_coordinates(
                    image[..., c],
                    (x_shifted.flatten(), y_shifted.flatten()),
                    order=order,
                    cval=cval,
                    mode=mode
                )
                remapped = remapped_flat.reshape((height, width))
                result[..., c] = remapped
        else:
            h, w, nb_channels = image.shape

            y, x = np.meshgrid(np.arange(h).astype(np.float32), np.arange(w).astype(np.float32), indexing='ij')
            x_shifted = x + (-1) * dx
            y_shifted = y + (-1) * dy

            if image.dtype.kind == "f":
                cval = float(cval)
            else:
                cval = int(cval)
            border_mode = cls._MAPPING_MODE_SCIPY_CV2[mode]
            interpolation = cls._MAPPING_ORDER_SCIPY_CV2[order]

            is_nearest_neighbour = (interpolation == cv2.INTER_NEAREST)
            map1, map2 = cv2.convertMaps(x_shifted, y_shifted, cv2.CV_16SC2, nninterpolation=is_nearest_neighbour)
            # remap only supports up to 4 channels
            if nb_channels <= 4:
                result = cv2.remap(image, map1, map2, interpolation=interpolation, borderMode=border_mode, borderValue=cval)
                if image.ndim == 3 and result.ndim == 2:
                    result = result[..., np.newaxis]
            else:
                current_chan_idx = 0
                result = []
                while current_chan_idx < nb_channels:
                    channels = image[..., current_chan_idx:current_chan_idx+4]
                    result_c =  cv2.remap(channels, map1, map2, interpolation=interpolation, borderMode=border_mode,
                                          borderValue=cval)
                    if result_c.ndim == 2:
                        result_c = result_c[..., np.newaxis]
                    result.append(result_c)
                    current_chan_idx += 4
                result = np.concatenate(result, axis=2)

        if result.dtype.name != input_dtype.name:
            result = meta.restore_dtypes_(result, input_dtype)

        return result


</source>
</class>

<class classid="28" nclones="2" nlines="19" similarity="78">
<source file="systems/imgaug-0.4.0/checks/check_solarize.py" startline="7" endline="37" pcid="1117">
def main():
    for size in [64, 128, 256, 512, 1024]:
        for threshold in [64, 128, 192]:
            time_iaa = timeit.timeit(
                "iaa.solarize(image, %d)" % (threshold,),
                number=1000,
                setup=(
                    "import imgaug as ia; "
                    "import imgaug.augmenters as iaa; "
                    "image = ia.quokka_square((%d, %d))" % (size, size))
            )
            time_pil = timeit.timeit(
                "np.asarray("
                "PIL.ImageOps.solarize(PIL.Image.fromarray(image), %d)"
                ")" % (threshold,),
                number=1000,
                setup=(
                    "import numpy as np; "
                    "import PIL.Image; "
                    "import PIL.ImageOps; "
                    "import imgaug as ia; "
                    "image = ia.quokka_square((%d, %d))" % (size, size))
            )
            print("[size=%04d, thresh=%03d] iaa=%.4f pil=%.4f" % (
                size, threshold, time_iaa, time_pil))

    image = ia.quokka_square((128, 128))
    images_aug = iaa.Solarize(1.0)(images=[image] * (5*5))
    ia.imshow(ia.draw_grid(images_aug))


</source>
<source file="systems/imgaug-0.4.0/checks/check_quantize_uniform_to_n_bits.py" startline="7" endline="40" pcid="1196">
def main():
    for size in [64, 128, 256, 512, 1024]:
        for nb_bits in [1, 2, 3, 4, 5, 6, 7, 8]:
            time_iaa = timeit.timeit(
                "iaa.quantize_uniform_to_n_bits(image, %d)" % (nb_bits,),
                number=1000,
                setup=(
                    "import imgaug as ia; "
                    "import imgaug.augmenters as iaa; "
                    "image = ia.quokka_square((%d, %d))" % (size, size))
            )
            time_pil = timeit.timeit(
                "np.asarray("
                "PIL.ImageOps.posterize(PIL.Image.fromarray(image), %d)"
                ")" % (nb_bits,),
                number=1000,
                setup=(
                    "import numpy as np; "
                    "import PIL.Image; "
                    "import PIL.ImageOps; "
                    "import imgaug as ia; "
                    "image = ia.quokka_square((%d, %d))" % (size, size))
            )
            print("[size=%04d, bits=%d] iaa=%.4f pil=%.4f" % (
                size, nb_bits, time_iaa, time_pil))

    image = ia.quokka_square((128, 128))
    images_q = [iaa.quantize_uniform_to_n_bits(image, nb_bits)
                for nb_bits
                in [1, 2, 3, 4, 5, 6, 7, 8]]

    ia.imshow(ia.draw_grid(images_q, cols=8, rows=1))


</source>
</class>

<class classid="29" nclones="2" nlines="25" similarity="81">
<source file="systems/imgaug-0.4.0/checks/check_median_blur.py" startline="14" endline="44" pcid="1126">
def main():
    image = data.astronaut()
    image = ia.imresize_single_image(image, (64, 64))
    print("image shape:", image.shape)
    print("Press any key or wait %d ms to proceed to the next image." % (TIME_PER_STEP,))

    k = [
        1,
        3,
        5,
        7,
        (3, 3),
        (1, 11)
    ]

    cv2.namedWindow("aug", cv2.WINDOW_NORMAL)
    cv2.resizeWindow("aug", 64*NB_AUGS_PER_IMAGE, 64)

    for ki in k:
        aug = iaa.MedianBlur(k=ki)
        img_aug = [aug.augment_image(image) for _ in range(NB_AUGS_PER_IMAGE)]
        img_aug = np.hstack(img_aug)
        print("dtype", img_aug.dtype, "averages", np.average(img_aug, axis=tuple(range(0, img_aug.ndim-1))))

        title = "k=%s" % (str(ki),)
        img_aug = ia.draw_text(img_aug, x=5, y=5, text=title)

        cv2.imshow("aug", img_aug[..., ::-1]) # here with rgb2bgr
        cv2.waitKey(TIME_PER_STEP)


</source>
<source file="systems/imgaug-0.4.0/checks/check_average_blur.py" startline="14" endline="48" pcid="1206">
def main():
    image = data.astronaut()
    image = ia.imresize_single_image(image, (64, 64))
    print("image shape:", image.shape)
    print("Press any key or wait %d ms to proceed to the next image." % (TIME_PER_STEP,))

    k = [
        1,
        2,
        4,
        8,
        16,
        (8, 8),
        (1, 8),
        ((1, 1), (8, 8)),
        ((1, 16), (1, 16)),
        ((1, 16), 1)
    ]

    cv2.namedWindow("aug", cv2.WINDOW_NORMAL)
    cv2.resizeWindow("aug", 64*NB_AUGS_PER_IMAGE, 64)

    for ki in k:
        aug = iaa.AverageBlur(k=ki)
        img_aug = [aug.augment_image(image) for _ in range(NB_AUGS_PER_IMAGE)]
        img_aug = np.hstack(img_aug)
        print("dtype", img_aug.dtype, "averages", np.average(img_aug, axis=tuple(range(0, img_aug.ndim-1))))

        title = "k=%s" % (str(ki),)
        img_aug = ia.draw_text(img_aug, x=5, y=5, text=title)

        cv2.imshow("aug", img_aug[..., ::-1])  # here with rgb2bgr
        cv2.waitKey(TIME_PER_STEP)


</source>
</class>

<class classid="30" nclones="3" nlines="15" similarity="80">
<source file="systems/imgaug-0.4.0/checks/check_readme_examples.py" startline="207" endline="228" pcid="1144">
def example_augment_images_and_bounding_boxes():
    print("Example: Augment Images and Bounding Boxes")
    import numpy as np
    import imgaug as ia
    import imgaug.augmenters as iaa

    images = np.zeros((2, 128, 128, 3), dtype=np.uint8)  # two example images
    images[:, 64, 64, :] = 255
    bbs = [
        [ia.BoundingBox(x1=10.5, y1=15.5, x2=30.5, y2=50.5)],
        [ia.BoundingBox(x1=10.5, y1=20.5, x2=50.5, y2=50.5),
         ia.BoundingBox(x1=40.5, y1=75.5, x2=70.5, y2=100.5)]
    ]

    seq = iaa.Sequential([
        iaa.AdditiveGaussianNoise(scale=0.05*255),
        iaa.Affine(translate_px={"x": (1, 5)})
    ])

    images_aug, bbs_aug = seq(images=images, bounding_boxes=bbs)


</source>
<source file="systems/imgaug-0.4.0/checks/check_readme_examples.py" startline="252" endline="273" pcid="1146">
def example_augment_images_and_linestrings():
    print("Example: Augment Images and LineStrings")
    import numpy as np
    import imgaug as ia
    import imgaug.augmenters as iaa

    images = np.zeros((2, 128, 128, 3), dtype=np.uint8)  # two example images
    images[:, 64, 64, :] = 255
    ls = [
        [ia.LineString([(10.5, 10.5), (50.5, 10.5), (50.5, 50.5)])],
        [ia.LineString([(0.0, 64.5), (64.5, 0.0), (128.0, 128.0), (64.5, 128.0),
                        (128.0, 0.0)])]
    ]

    seq = iaa.Sequential([
        iaa.AdditiveGaussianNoise(scale=0.05*255),
        iaa.Affine(translate_px={"x": (1, 5)})
    ])

    images_aug, ls_aug = seq(images=images, line_strings=ls)


</source>
<source file="systems/imgaug-0.4.0/checks/check_readme_examples.py" startline="230" endline="250" pcid="1145">
def example_augment_images_and_polygons():
    print("Example: Augment Images and Polygons")
    import numpy as np
    import imgaug as ia
    import imgaug.augmenters as iaa

    images = np.zeros((2, 128, 128, 3), dtype=np.uint8)  # two example images
    images[:, 64, 64, :] = 255
    polygons = [
        [ia.Polygon([(10.5, 10.5), (50.5, 10.5), (50.5, 50.5)])],
        [ia.Polygon([(0.0, 64.5), (64.5, 0.0), (128.0, 128.0), (64.5, 128.0)])]
    ]

    seq = iaa.Sequential([
        iaa.AdditiveGaussianNoise(scale=0.05*255),
        iaa.Affine(translate_px={"x": (1, 5)})
    ])

    images_aug, polygons_aug = seq(images=images, polygons=polygons)


</source>
</class>

<class classid="31" nclones="2" nlines="11" similarity="90">
<source file="systems/imgaug-0.4.0/checks/check_readme_examples.py" startline="275" endline="293" pcid="1147">
def example_augment_images_and_heatmaps():
    print("Example: Augment Images and Heatmaps")
    import numpy as np
    import imgaug.augmenters as iaa

    # Standard scenario: You have N RGB-images and additionally 21 heatmaps per
    # image. You want to augment each image and its heatmaps identically.
    images = np.random.randint(0, 255, (16, 128, 128, 3), dtype=np.uint8)
    heatmaps = np.random.random(size=(16, 64, 64, 1)).astype(np.float32)

    seq = iaa.Sequential([
        iaa.GaussianBlur((0, 3.0)),
        iaa.Affine(translate_px={"x": (-40, 40)}),
        iaa.Crop(px=(0, 10))
    ])

    images_aug, heatmaps_aug = seq(images=images, heatmaps=heatmaps)


</source>
<source file="systems/imgaug-0.4.0/checks/check_readme_examples.py" startline="295" endline="313" pcid="1148">
def example_augment_images_and_segmentation_maps():
    print("Example: Augment Images and Segmentation Maps")
    import numpy as np
    import imgaug.augmenters as iaa

    # Standard scenario: You have N=16 RGB-images and additionally one segmentation
    # map per image. You want to augment each image and its heatmaps identically.
    images = np.random.randint(0, 255, (16, 128, 128, 3), dtype=np.uint8)
    segmaps = np.random.randint(0, 10, size=(16, 64, 64, 1), dtype=np.int32)

    seq = iaa.Sequential([
        iaa.GaussianBlur((0, 3.0)),
        iaa.Affine(translate_px={"x": (-40, 40)}),
        iaa.Crop(px=(0, 10))
    ])

    images_aug, segmaps_aug = seq(images=images, segmentation_maps=segmaps)


</source>
</class>

<class classid="32" nclones="2" nlines="24" similarity="70">
<source file="systems/imgaug-0.4.0/checks/check_multicore_pool.py" startline="321" endline="353" pcid="1184">
def load_images(n_batches=10, sleep=0.0, draw_text=True):
    batch_size = 4
    astronaut = data.astronaut()
    astronaut = ia.imresize_single_image(astronaut, (64, 64))
    kps = ia.KeypointsOnImage([ia.Keypoint(x=15, y=25)], shape=astronaut.shape)

    counter = 0
    for i in range(n_batches):
        if draw_text:
            batch_images = []
            batch_kps = []
            for b in range(batch_size):
                astronaut_text = ia.draw_text(astronaut, x=0, y=0, text="%d" % (counter,), color=[0, 255, 0], size=16)
                batch_images.append(astronaut_text)
                batch_kps.append(kps)
                counter += 1
            batch = ia.Batch(
                images=np.array(batch_images, dtype=np.uint8),
                keypoints=batch_kps
            )
        else:
            if i == 0:
                batch_images = np.array([np.copy(astronaut) for _ in range(batch_size)], dtype=np.uint8)

            batch = ia.Batch(
                images=np.copy(batch_images),
                keypoints=[kps.deepcopy() for _ in range(batch_size)]
            )
        yield batch
        if sleep > 0:
            time.sleep(sleep)


</source>
<source file="systems/imgaug-0.4.0/checks/check_background_augmentation.py" startline="261" endline="283" pcid="1216">
def load_images(n_batches=10, sleep=0.0):
    batch_size = 4
    astronaut = data.astronaut()
    astronaut = ia.imresize_single_image(astronaut, (64, 64))
    kps = ia.KeypointsOnImage([ia.Keypoint(x=15, y=25)], shape=astronaut.shape)
    counter = 0
    for i in range(n_batches):
        batch_images = []
        batch_kps = []
        for b in range(batch_size):
            astronaut_text = ia.draw_text(astronaut, x=0, y=0, text="%d" % (counter,), color=[0, 255, 0], size=16)
            batch_images.append(astronaut_text)
            batch_kps.append(kps)
            counter += 1
        batch = ia.Batch(
            images=np.array(batch_images, dtype=np.uint8),
            keypoints=batch_kps
        )
        yield batch
        if sleep > 0:
            time.sleep(sleep)


</source>
</class>

<class classid="33" nclones="2" nlines="17" similarity="100">
<source file="systems/imgaug-0.4.0/checks/check_multicore_pool.py" startline="354" endline="374" pcid="1185">
def draw_grid(images_aug, keypoints_aug):
    if keypoints_aug is None:
        keypoints_aug = []
        for bidx in range(len(images_aug)):
            keypoints_aug.append([None for image in images_aug[bidx]])

    images_kps_batches = []
    for bidx in range(len(images_aug)):
        images_kps_batch = []
        for image, kps in zip(images_aug[bidx], keypoints_aug[bidx]):
            if kps is None:
                image_kps = image
            else:
                image_kps = kps.draw_on_image(image, size=5, color=[255, 0, 0])
            images_kps_batch.append(image_kps)
        images_kps_batches.extend(images_kps_batch)

    grid = ia.draw_grid(images_kps_batches, cols=len(images_aug[0]))
    return grid


</source>
<source file="systems/imgaug-0.4.0/checks/check_background_augmentation.py" startline="284" endline="304" pcid="1217">
def draw_grid(images_aug, keypoints_aug):
    if keypoints_aug is None:
        keypoints_aug = []
        for bidx in range(len(images_aug)):
            keypoints_aug.append([None for image in images_aug[bidx]])

    images_kps_batches = []
    for bidx in range(len(images_aug)):
        images_kps_batch = []
        for image, kps in zip(images_aug[bidx], keypoints_aug[bidx]):
            if kps is None:
                image_kps = image
            else:
                image_kps = kps.draw_on_image(image, size=5, color=[255, 0, 0])
            images_kps_batch.append(image_kps)
        images_kps_batches.extend(images_kps_batch)

    grid = ia.draw_grid(images_kps_batches, cols=len(images_aug[0]))
    return grid


</source>
</class>

<class classid="34" nclones="2" nlines="10" similarity="100">
<source file="systems/imgaug-0.4.0/test/test_imgaug.py" startline="102" endline="113" pcid="1221">
def test_is_single_integer():
    assert ia.is_single_integer("A") is False
    assert ia.is_single_integer(None) is False
    assert ia.is_single_integer(1.2) is False
    assert ia.is_single_integer(1.0) is False
    assert ia.is_single_integer(np.ones((1,), dtype=np.float32)[0]) is False
    assert ia.is_single_integer(1) is True
    assert ia.is_single_integer(1234) is True
    assert ia.is_single_integer(np.ones((1,), dtype=np.uint8)[0]) is True
    assert ia.is_single_integer(np.ones((1,), dtype=np.int32)[0]) is True


</source>
<source file="systems/imgaug-0.4.0/test/test_imgaug.py" startline="114" endline="125" pcid="1222">
def test_is_single_float():
    assert ia.is_single_float("A") is False
    assert ia.is_single_float(None) is False
    assert ia.is_single_float(1.2) is True
    assert ia.is_single_float(1.0) is True
    assert ia.is_single_float(np.ones((1,), dtype=np.float32)[0]) is True
    assert ia.is_single_float(1) is False
    assert ia.is_single_float(1234) is False
    assert ia.is_single_float(np.ones((1,), dtype=np.uint8)[0]) is False
    assert ia.is_single_float(np.ones((1,), dtype=np.int32)[0]) is False


</source>
</class>

<class classid="35" nclones="2" nlines="10" similarity="70">
<source file="systems/imgaug-0.4.0/test/test_imgaug.py" startline="164" endline="175" pcid="1226">
def test_is_string():
    class _Dummy(object):
        pass
    values_true = ["A", "BC", "1", ""]
    values_false = [-100, 1, 0, 1, 100, -1.2, -0.001, 0.0, 0.001, 1.2, 1e-4, True, False, (1.0, 2.0), [1.0, 2.0],
                    _Dummy(), np.zeros((1, 2), dtype=np.uint8)]
    for value in values_true:
        assert ia.is_string(value) is True
    for value in values_false:
        assert ia.is_string(value) is False


</source>
<source file="systems/imgaug-0.4.0/test/test_imgaug.py" startline="176" endline="187" pcid="1227">
def test_is_single_bool():
    class _Dummy(object):
        pass
    values_true = [False, True]
    values_false = [-100, 1, 0, 1, 100, -1.2, -0.001, 0.0, 0.001, 1.2, 1e-4, (1.0, 2.0), [1.0, 2.0], _Dummy(),
                    np.zeros((1, 2), dtype=np.uint8), np.zeros((1,), dtype=bool)]
    for value in values_true:
        assert ia.is_single_bool(value) is True
    for value in values_false:
        assert ia.is_single_bool(value) is False


</source>
</class>

<class classid="36" nclones="2" nlines="20" similarity="90">
<source file="systems/imgaug-0.4.0/test/test_imgaug.py" startline="188" endline="211" pcid="1228">
def test_is_integer_array():
    class _Dummy(object):
        pass
    values_true = [
        np.zeros((1, 2), dtype=np.uint8),
        np.zeros((100,), dtype=np.uint8),
        np.zeros((1, 2), dtype=np.uint16),
        np.zeros((1, 2), dtype=np.int32),
        np.zeros((1, 2), dtype=np.int64)
    ]
    values_false = [
        "A", "BC", "1", "", -100, 1, 0, 1, 100, -1.2, -0.001, 0.0, 0.001, 1.2, 1e-4, True, False,
        (1.0, 2.0), [1.0, 2.0], _Dummy(),
        np.zeros((1, 2), dtype=np.float16),
        np.zeros((100,), dtype=np.float32),
        np.zeros((1, 2), dtype=np.float64),
        np.zeros((1, 2), dtype=np.bool)
    ]
    for value in values_true:
        assert ia.is_integer_array(value) is True
    for value in values_false:
        assert ia.is_integer_array(value) is False


</source>
<source file="systems/imgaug-0.4.0/test/test_imgaug.py" startline="212" endline="236" pcid="1229">
def test_is_float_array():
    class _Dummy(object):
        pass

    values_true = [
        np.zeros((1, 2), dtype=np.float16),
        np.zeros((100,), dtype=np.float32),
        np.zeros((1, 2), dtype=np.float64)
    ]
    values_false = [
        "A", "BC", "1", "", -100, 1, 0, 1, 100, -1.2, -0.001, 0.0, 0.001, 1.2, 1e-4, True, False,
        (1.0, 2.0), [1.0, 2.0], _Dummy(),
        np.zeros((1, 2), dtype=np.uint8),
        np.zeros((100,), dtype=np.uint8),
        np.zeros((1, 2), dtype=np.uint16),
        np.zeros((1, 2), dtype=np.int32),
        np.zeros((1, 2), dtype=np.int64),
        np.zeros((1, 2), dtype=np.bool)
    ]
    for value in values_true:
        assert ia.is_float_array(value) is True
    for value in values_false:
        assert ia.is_float_array(value) is False


</source>
</class>

<class classid="37" nclones="2" nlines="13" similarity="100">
<source file="systems/imgaug-0.4.0/test/test_imgaug.py" startline="570" endline="591" pcid="1251">
def test_quokka_heatmap():
    # we are intentionally a bit looser here with atol=0.1, because apparently
    # on some systems there are small differences in what exactly is loaded,
    # see issue #414

    hm = ia.quokka_heatmap()
    assert hm.shape == (643, 960, 3)
    assert hm.arr_0to1.shape == (643, 960, 1)
    assert np.allclose(np.average(hm.arr_0to1), 0.57618505, rtol=0, atol=1e-3)

    hm = ia.quokka_heatmap(extract="square")
    assert hm.shape == (643, 643, 3)
    assert hm.arr_0to1.shape == (643, 643, 1)
    # TODO this value is 0.48026073 in python 2.7, while 0.48026952 in 3.7 -- why?
    assert np.allclose(np.average(hm.arr_0to1), 0.48026952, rtol=0, atol=1e-3)

    hm = ia.quokka_heatmap(size=(642, 959))
    assert hm.shape == (642, 959, 3)
    assert hm.arr_0to1.shape == (642, 959, 1)
    assert np.allclose(np.average(hm.arr_0to1), 0.5762454, rtol=0, atol=1e-3)


</source>
<source file="systems/imgaug-0.4.0/test/test_imgaug.py" startline="592" endline="608" pcid="1252">
def test_quokka_segmentation_map():
    segmap = ia.quokka_segmentation_map()
    assert segmap.shape == (643, 960, 3)
    assert segmap.arr.shape == (643, 960, 1)
    assert np.allclose(np.average(segmap.arr), 0.3016427, rtol=0, atol=1e-3)

    segmap = ia.quokka_segmentation_map(extract="square")
    assert segmap.shape == (643, 643, 3)
    assert segmap.arr.shape == (643, 643, 1)
    assert np.allclose(np.average(segmap.arr), 0.450353, rtol=0, atol=1e-3)

    segmap = ia.quokka_segmentation_map(size=(642, 959))
    assert segmap.shape == (642, 959, 3)
    assert segmap.arr.shape == (642, 959, 1)
    assert np.allclose(np.average(segmap.arr), 0.30160266, rtol=0, atol=1e-3)


</source>
</class>

<class classid="38" nclones="2" nlines="26" similarity="80">
<source file="systems/imgaug-0.4.0/test/test_imgaug.py" startline="609" endline="639" pcid="1253">
def test_quokka_keypoints():
    kpsoi = ia.quokka_keypoints()
    assert len(kpsoi.keypoints) > 0
    assert np.allclose(kpsoi.keypoints[0].x, 163.0)
    assert np.allclose(kpsoi.keypoints[0].y, 78.0)
    assert kpsoi.shape == (643, 960, 3)

    img = ia.quokka()
    patches = []
    for kp in kpsoi.keypoints:
        bb = ia.BoundingBox(x1=kp.x-1, x2=kp.x+2, y1=kp.y-1, y2=kp.y+2)
        patches.append(bb.extract_from_image(img))

    img_square = ia.quokka(extract="square")
    kpsoi_square = ia.quokka_keypoints(extract="square")
    assert len(kpsoi.keypoints) == len(kpsoi_square.keypoints)
    assert kpsoi_square.shape == (643, 643, 3)

    for kp, patch in zip(kpsoi_square.keypoints, patches):
        bb = ia.BoundingBox(x1=kp.x-1, x2=kp.x+2, y1=kp.y-1, y2=kp.y+2)
        patch_square = bb.extract_from_image(img_square)
        assert np.average(np.abs(patch.astype(np.float32) - patch_square.astype(np.float32))) < 1.0

    kpsoi_resized = ia.quokka_keypoints(size=(642, 959))
    assert kpsoi_resized.shape == (642, 959, 3)
    assert len(kpsoi.keypoints) == len(kpsoi_resized.keypoints)
    for kp, kp_resized in zip(kpsoi.keypoints, kpsoi_resized.keypoints):
        d = np.sqrt((kp.x - kp_resized.x) ** 2 + (kp.y - kp_resized.y) ** 2)
        assert d < 1.0


</source>
<source file="systems/imgaug-0.4.0/test/test_imgaug.py" startline="640" endline="671" pcid="1254">
def test_quokka_bounding_boxes():
    bbsoi = ia.quokka_bounding_boxes()
    assert len(bbsoi.bounding_boxes) > 0
    bb0 = bbsoi.bounding_boxes[0]
    assert np.allclose(bb0.x1, 148.0)
    assert np.allclose(bb0.y1, 50.0)
    assert np.allclose(bb0.x2, 550.0)
    assert np.allclose(bb0.y2, 642.0)
    assert bbsoi.shape == (643, 960, 3)

    img = ia.quokka()
    patches = []
    for bb in bbsoi.bounding_boxes:
        patches.append(bb.extract_from_image(img))

    img_square = ia.quokka(extract="square")
    bbsoi_square = ia.quokka_bounding_boxes(extract="square")
    assert len(bbsoi.bounding_boxes) == len(bbsoi_square.bounding_boxes)
    assert bbsoi_square.shape == (643, 643, 3)

    for bb, patch in zip(bbsoi_square.bounding_boxes, patches):
        patch_square = bb.extract_from_image(img_square)
        assert np.average(np.abs(patch.astype(np.float32) - patch_square.astype(np.float32))) < 1.0

    bbsoi_resized = ia.quokka_bounding_boxes(size=(642, 959))
    assert bbsoi_resized.shape == (642, 959, 3)
    assert len(bbsoi.bounding_boxes) == len(bbsoi_resized.bounding_boxes)
    for bb, bb_resized in zip(bbsoi.bounding_boxes, bbsoi_resized.bounding_boxes):
        d = np.sqrt((bb.center_x - bb_resized.center_x) ** 2 + (bb.center_y - bb_resized.center_y) ** 2)
        assert d < 1.0


</source>
</class>

<class classid="39" nclones="4" nlines="13" similarity="100">
<source file="systems/imgaug-0.4.0/test/test_imgaug.py" startline="1396" endline="1412" pcid="1261">
    assert arr_pooled.shape == (2, 2)
    assert arr_pooled.dtype == arr.dtype.type
    assert np.isclose(arr_pooled[0, 0], np.average([0, 1, 4, 5]))
    assert np.isclose(arr_pooled[0, 1], np.average([2, 2, 6, 6]))
    assert np.isclose(arr_pooled[1, 0], np.average([8, 9, 8, 9]))
    assert np.isclose(arr_pooled[1, 1], np.average([10, 10, 10, 10]))


# TODO add test that verifies the default padding mode
def test_avg_pool():
    # very basic test, as avg_pool() just calls pool(), which is tested in test_pool()
    arr = np.uint8([
        [0, 1, 2, 3],
        [4, 5, 6, 7],
        [8, 9, 10, 11],
        [12, 13, 14, 15]
    ])
</source>
<source file="systems/imgaug-0.4.0/test/test_imgaug.py" startline="1454" endline="1473" pcid="1264">
    assert arr_pooled.shape == (2, 2)
    assert arr_pooled.dtype == arr.dtype.type
    assert arr_pooled[0, 0] == int(np.min([0, 1, 4, 5]))
    assert arr_pooled[0, 1] == int(np.min([2, 3, 6, 7]))
    assert arr_pooled[1, 0] == int(np.min([8, 9, 12, 13]))
    assert arr_pooled[1, 1] == int(np.min([10, 11, 14, 15]))


# TODO add test that verifies the default padding mode
def test_median_pool():
    # very basic test, as median_pool() just calls pool(), which is tested in
    # test_pool()
    arr = np.uint8([
        [0, 1, 2, 3],
        [4, 5, 6, 7],
        [8, 9, 10, 11],
        [12, 13, 14, 15]
    ])

    arr_pooled = ia.median_pool(arr, 2)
</source>
<source file="systems/imgaug-0.4.0/test/test_imgaug.py" startline="1414" endline="1431" pcid="1262">
    assert arr_pooled.shape == (2, 2)
    assert arr_pooled.dtype == arr.dtype.type
    assert arr_pooled[0, 0] == int(np.average([0, 1, 4, 5]))
    assert arr_pooled[0, 1] == int(np.average([2, 3, 6, 7]))
    assert arr_pooled[1, 0] == int(np.average([8, 9, 12, 13]))
    assert arr_pooled[1, 1] == int(np.average([10, 11, 14, 15]))


# TODO add test that verifies the default padding mode
def test_max_pool():
    # very basic test, as max_pool() just calls pool(), which is tested in
    # test_pool()
    arr = np.uint8([
        [0, 1, 2, 3],
        [4, 5, 6, 7],
        [8, 9, 10, 11],
        [12, 13, 14, 15]
    ])
</source>
<source file="systems/imgaug-0.4.0/test/test_imgaug.py" startline="1433" endline="1452" pcid="1263">
    assert arr_pooled.shape == (2, 2)
    assert arr_pooled.dtype == arr.dtype.type
    assert arr_pooled[0, 0] == int(np.max([0, 1, 4, 5]))
    assert arr_pooled[0, 1] == int(np.max([2, 3, 6, 7]))
    assert arr_pooled[1, 0] == int(np.max([8, 9, 12, 13]))
    assert arr_pooled[1, 1] == int(np.max([10, 11, 14, 15]))


# TODO add test that verifies the default padding mode
def test_min_pool():
    # very basic test, as min_pool() just calls pool(), which is tested in
    # test_pool()
    arr = np.uint8([
        [0, 1, 2, 3],
        [4, 5, 6, 7],
        [8, 9, 10, 11],
        [12, 13, 14, 15]
    ])

    arr_pooled = ia.min_pool(arr, 2)
</source>
</class>

<class classid="40" nclones="3" nlines="14" similarity="73">
<source file="systems/imgaug-0.4.0/test/test_imgaug.py" startline="1669" endline="1688" pcid="1268">

    # no deprecated warning for calls to imgaug.<name>
    with warnings.catch_warnings(record=True) as caught_warnings:
        warnings.simplefilter("always")
        _kp = ia.Keypoint(x=1, y=2)
        assert len(caught_warnings) == 0


class Test_apply_lut(unittest.TestCase):
    def test_2d_image(self):
        table = np.mod(np.arange(256) + 10, 256).astype(np.uint8)

        image = np.uint8([
            [0, 50, 100, 245, 254, 255],
            [1, 51, 101, 246, 255, 0]
        ])

        image_aug = ia.apply_lut(image, table)

        expected = np.uint8([
</source>
<source file="systems/imgaug-0.4.0/test/test_imgaug.py" startline="1809" endline="1829" pcid="1272">
                                v_proj = tables_3d[v, c]
                                expected[y, x, c] = v_proj

                    assert np.array_equal(image_aug, expected)
                    if nb_channels < 512:
                        assert image_aug is image
                    assert image_aug.shape == (2, 6, nb_channels)
                    assert image_aug.dtype.name == "uint8"

    def test_image_is_noncontiguous(self):
        table = np.mod(np.arange(256) + 10, 256).astype(np.uint8)

        image = np.uint8([
            [0, 50, 100, 245, 254, 255],
            [1, 51, 101, 246, 255, 0]
        ])
        image = np.fliplr(image)
        assert image.flags["C_CONTIGUOUS"] is False

        image_aug = ia.apply_lut_(image, table)

</source>
<source file="systems/imgaug-0.4.0/test/test_imgaug.py" startline="1830" endline="1850" pcid="1273">
        expected = np.uint8([
            [10, 60, 110, 255, 8, 9],
            [11, 61, 111, 0, 9, 10]
        ])
        assert np.array_equal(np.fliplr(image_aug), expected)
        assert image_aug is not image  # non-contiguous should lead to copy
        assert image_aug.shape == (2, 6)
        assert image_aug.dtype.name == "uint8"

    def test_image_is_view(self):
        table = np.mod(np.arange(256) + 10, 256).astype(np.uint8)

        image = np.uint8([
            [0, 50, 100, 245, 254, 255],
            [1, 51, 101, 246, 255, 0]
        ])
        image = image[:, 1:4]
        assert image.flags["OWNDATA"] is False

        image_aug = ia.apply_lut_(image, table)

</source>
</class>

<class classid="41" nclones="2" nlines="21" similarity="81">
<source file="systems/imgaug-0.4.0/test/test_imgaug.py" startline="1690" endline="1716" pcid="1269">
            [11, 61, 111, 0, 9, 10]
        ])
        assert np.array_equal(image_aug, expected)
        assert image_aug is not image
        assert image_aug.shape == (2, 6)
        assert image_aug.dtype.name == "uint8"


class Test_apply_lut_(unittest.TestCase):
    def test_2d_image(self):
        table = np.mod(np.arange(256) + 10, 256).astype(np.uint8)
        tables = [
            ("array-1d", table),
            ("array-2d", table[:, np.newaxis]),
            ("array-3d", table[np.newaxis, :, np.newaxis]),
            ("list", [table])
        ]

        for subtable_descr, subtable in tables:
            with self.subTest(table_type=subtable_descr):
                image = np.uint8([
                    [0, 50, 100, 245, 254, 255],
                    [1, 51, 101, 246, 255, 0]
                ])

                image_aug = ia.apply_lut_(image, subtable)

</source>
<source file="systems/imgaug-0.4.0/test/test_imgaug.py" startline="1717" endline="1746" pcid="1270">
                expected = np.uint8([
                    [10, 60, 110, 255, 8, 9],
                    [11, 61, 111, 0, 9, 10]
                ])
                assert np.array_equal(image_aug, expected)
                assert image_aug is image
                assert image_aug.shape == (2, 6)
                assert image_aug.dtype.name == "uint8"

    def test_HW1_image(self):
        table = np.mod(np.arange(256) + 10, 256).astype(np.uint8)
        tables = [
            ("array-1d", table),
            ("array-2d", table[:, np.newaxis]),
            ("array-3d", table[np.newaxis, :, np.newaxis]),
            ("list", [table])
        ]

        for subtable_descr, subtable in tables:
            with self.subTest(table_type=subtable_descr):
                image = np.uint8([
                    [0, 50, 100, 245, 254, 255],
                    [1, 51, 101, 246, 255, 0]
                ])
                image = image[:, :, np.newaxis]

                image_aug = ia.apply_lut_(image, subtable)

                expected = np.uint8([
                    [10, 60, 110, 255, 8, 9],
</source>
</class>

<class classid="42" nclones="99" nlines="16" similarity="70">
<source file="systems/imgaug-0.4.0/test/test_imgaug.py" startline="1851" endline="1870" pcid="1274">
        expected = np.uint8([
            [60, 110, 255],
            [61, 111, 0]
        ])
        assert np.array_equal(image_aug, expected)
        assert image_aug is not image  # non-owndata should lead to copy
        assert image_aug.shape == (2, 3)
        assert image_aug.dtype.name == "uint8"

    def test_zero_sized_axes(self):
        table = np.mod(np.arange(256) + 10, 256).astype(np.uint8)
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_weather.py" startline="201" endline="221" pcid="1525">
    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.Clouds()

                image_aug = aug(image=image)

                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="2728" endline="2748" pcid="2952">
    def test_get_parameters(self):
        aug = iaa.Dropout2d(p=0.7, nb_keep_channels=2)
        params = aug.get_parameters()
        assert isinstance(params[0], iap.Binomial)
        assert np.isclose(params[0].p.value, 0.3)
        assert params[1] == 2

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.full(shape, 255, dtype=np.uint8)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_pillike.py" startline="493" endline="512" pcid="4080">

    def _test_zero_sized_axes(self, func):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)

                image_aug = func(image)

                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_convolutional.py" startline="206" endline="225" pcid="2409">
    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.Convolve(matrix=np.float32([[1]]))

                image_aug = aug(image=image)

                assert image_aug.shape == image.shape

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="3790" endline="3811" pcid="3007">
        except Exception:
            got_exception = True
        assert got_exception

        got_exception = False
        try:
            _aug = iaa.MultiplyElementwise(mul=1, per_channel="test")
        except Exception:
            got_exception = True
        assert got_exception

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="5281" endline="5305" pcid="1973">
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.PiecewiseAffine(scale=0.05, nb_rows=2, nb_cols=2)

                image_aug = aug(image=image)

                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape

    def test_zero_sized_axes_absolute_scale(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.PiecewiseAffine(scale=5, nb_rows=2, nb_cols=2,
                                          absolute_scale=True)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_pillike.py" startline="212" endline="231" pcid="4051">

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)

                image_aug = iaa.pillike.equalize(image)

                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="1956" endline="1977" pcid="3337">

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.full(shape, 0, dtype=np.uint8)
                aug = iaa.BlendAlphaRegularGrid(
                    nb_rows=2, nb_cols=3, foreground=iaa.TotalDropout(1.0))

                image_aug = aug(image=image)

                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="2757" endline="2776" pcid="3627">

                expected_height = shape[0] + 2
                expected_width = shape[1] + 2
                expected_shape = tuple([expected_height, expected_width]
                                       + list(shape[2:]))
                assert image_aug.shape == expected_shape

    def test_zero_sized_axes_keep_size(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="2770" endline="2789" pcid="1505">
        observed = iaa.quantize_uniform_(image_v, 2)

        assert observed.shape == (2, 4)
        assert observed.dtype.name == "uint8"
        assert np.array_equal(observed, expected)

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="5260" endline="5280" pcid="1972">

        observed = aug.augment_bounding_boxes(bbsoi)

        assert_cbaois_equal(observed, bbsoi)

    # ---------
    # zero-sized axes
    # ---------
    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="5407" endline="5428" pcid="3105">
        assert keypoints_equal(observed, expected)

        observed = aug_det.augment_keypoints(keypoints)
        expected = keypoints
        assert keypoints_equal(observed, expected)

    def test___init___bad_datatypes(self):
        # test exceptions for wrong parameter types
        got_exception = False
        try:
            _ = iaa.Invert(p="test")
        except Exception:
            got_exception = True
        assert got_exception

        got_exception = False
        try:
            _ = iaa.Invert(p=0.5, per_channel="test")
        except Exception:
            got_exception = True
        assert got_exception

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blur.py" startline="124" endline="142" pcid="2303">
    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)

                image_aug = iaa.blur_gaussian_(np.copy(image), 1.0)

                assert image_aug.shape == image.shape

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="2320" endline="2340" pcid="1468">
        for _ in sm.xrange(20):
            images_quantized.append(iaa.quantize_kmeans(image, 20))

        for image_quantized in images_quantized[1:]:
            assert np.array_equal(image_quantized, images_quantized[0])

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="8750" endline="8772" pcid="2216">
            (1, 0, 1)
        ]

        for shape in shapes:
            for keep_size in [False, True]:
                with self.subTest(shape=shape, keep_size=keep_size):
                    for _ in sm.xrange(10):
                        image = np.zeros(shape, dtype=np.uint8)
                        aug = iaa.Rot90([0, 2], keep_size=keep_size)

                        image_aug = aug(image=image)

                        assert image_aug.shape == shape

    def test_zero_sized_axes_k_1_or_3_no_keep_size(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="4263" endline="4284" pcid="3024">
        except Exception:
            got_exception = True
        assert got_exception

        got_exception = False
        try:
            _aug = iaa.ReplaceElementwise(mask=1, replacement=1, per_channel="test")
        except Exception:
            got_exception = True
        assert got_exception

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_pooling.py" startline="560" endline="580" pcid="2665">
    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.full(shape, 128, dtype=np.uint8)
                aug = self.augmenter(3)

                image_aug = aug(image=image)

                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blur.py" startline="1000" endline="1018" pcid="2343">
                image = np.zeros(shape, dtype=np.uint8)

                image_aug = iaa.AverageBlur(k=3)(image=image)

                assert image_aug.shape == image.shape

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blur.py" startline="1309" endline="1327" pcid="2358">
        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)

                image_aug = iaa.MedianBlur(k=3)(image=image)

                assert image_aug.shape == image.shape

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="973" endline="994" pcid="3228">

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.full(shape, 0, dtype=np.uint8)
                aug = iaa.BlendAlpha(1.0, iaa.Add(1), iaa.Add(100))

                image_aug = aug(image=image)

                assert np.all(image_aug == 1)
                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="97" endline="118" pcid="3145">
    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image_fg = np.full(shape, 0, dtype=np.uint8)
                image_bg = np.full(shape, 255, dtype=np.uint8)

                image_aug = blend.blend_alpha(image_fg, image_bg, 1.0)

                assert np.all(image_aug == 0)
                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="937" endline="958" pcid="2856">
        assert 150 < seen[0] < 250
        assert 150 < seen[1] < 250

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.Add(1)

                image_aug = aug(image=image)

                assert np.all(image_aug == 1)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="2013" endline="2034" pcid="3342">

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.full(shape, 0, dtype=np.uint8)
                aug = iaa.BlendAlphaCheckerboard(
                    nb_rows=2, nb_cols=3, foreground=iaa.TotalDropout(1.0))

                image_aug = aug(image=image)

                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="8728" endline="8749" pcid="2215">
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.Rot90(k=1)

                image_aug = aug(image=image)

                shape_expected = tuple([shape[1], shape[0]] + list(shape[2:]))
                assert np.all(image_aug == 0)
                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape_expected

    def test_zero_sized_axes_k_0_or_2(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="1427" endline="1448" pcid="2876">
        assert 150 < seen[0] < 250
        assert 150 < seen[1] < 250

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.AddElementwise(1)

                image_aug = aug(image=image)

                assert np.all(image_aug == 1)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_segmentation.py" startline="699" endline="721" pcid="2745">

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        sampler = iaa.RegularGridPointsSampler(50, 50)

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.full(shape, 128, dtype=np.uint8)
                aug = iaa.Voronoi(sampler, p_replace=1)

                image_aug = aug(image=image)

                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="3291" endline="3312" pcid="2989">
        except Exception:
            got_exception = True
        assert got_exception

        got_exception = False
        try:
            _ = iaa.Multiply(mul=1, per_channel="test")
        except Exception:
            got_exception = True
        assert got_exception

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_weather.py" startline="280" endline="300" pcid="1533">
    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.Fog()

                image_aug = aug(image=image)

                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="1836" endline="1857" pcid="3327">

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.full(shape, 0, dtype=np.uint8)
                aug = iaa.BlendAlphaHorizontalLinearGradient(
                    iaa.TotalDropout(1.0))

                image_aug = aug(image=image)

                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_segmentation.py" startline="144" endline="164" pcid="2704">
    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.full(shape, 128, dtype=np.uint8)
                aug = iaa.Superpixels(p_replace=1.0, n_segments=10)

                image_aug = aug(image=image)

                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="1897" endline="1918" pcid="3332">

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.full(shape, 0, dtype=np.uint8)
                aug = iaa.BlendAlphaVerticalLinearGradient(
                    iaa.TotalDropout(1.0))

                image_aug = aug(image=image)

                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="8773" endline="8793" pcid="2217">
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                for _ in sm.xrange(10):
                    image = np.zeros(shape, dtype=np.uint8)
                    aug = iaa.Rot90([1, 3], keep_size=False)

                    image_aug = aug(image=image)

                    shape_expected = tuple([shape[1], shape[0]]
                                           + list(shape[2:]))
                    assert image_aug.shape == shape_expected

    def test_zero_sized_axes_k_1_or_3_keep_size(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="1690" endline="1711" pcid="3316">

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.full(shape, 0, dtype=np.uint8)
                aug = iaa.BlendAlpha(1.0, iaa.Add(1), iaa.Add(100))

                image_aug = aug(image=image)

                assert np.all(image_aug == 1)
                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="2733" endline="2756" pcid="3626">
        cbaoi = ia.LineStringsOnImage([], shape=(2, 4, 3))
        self._test_pad_empty_cba("augment_line_strings", cbaoi)

    def test_pad_empty_bounding_boxes(self):
        cbaoi = ia.BoundingBoxesOnImage([], shape=(2, 4, 3))
        self._test_pad_empty_cba("augment_bounding_boxes", cbaoi)

    def test_zero_sized_axes_no_keep_size(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.Pad(px=1, keep_size=False)

                image_aug = aug(image=image)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="4536" endline="4559" pcid="3740">
        expected[0, :, 0] = 0
        assert observed.shape == (32, 32, 3)
        assert np.array_equal(observed.arr, expected)

    def test_get_parameters(self):
        aug = iaa.PadToFixedSize(width=20, height=10, pad_mode="edge",
                                 pad_cval=10, position="center")
        params = aug.get_parameters()
        assert params[0] == 20
        assert params[1] == 10
        assert params[2].value == "edge"
        assert params[3].value == 10
        assert np.isclose(params[4][0].value, 0.5)
        assert np.isclose(params[4][1].value, 0.5)

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="2694" endline="2717" pcid="3389">

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 0, 0),
            (1, 0, 0),
            (0, 1, 0),
            (0, 0, 1),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                batch = _BatchInAugmentation(images=[image])
                gen = iaa.HorizontalLinearGradientMaskGen()

                mask = gen.draw_masks(batch)[0]

                assert mask.shape == shape[0:2]
                assert mask.dtype.name == "float32"
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="9294" endline="9314" pcid="2249">
        hooks = ia.HooksImages(propagator=_propagator)

        observed1 = aug.augment_image(image)
        observed2 = aug.augment_image(image, hooks=hooks)

        image_plus50 = np.clip(image.astype(np.int32)+50, 0, 255)
        diff1 = np.abs(observed1[2:-2].astype(np.int32)
                       - image_plus50[2:-2].astype(np.int32))
        diff2 = np.abs(observed2[2:-2].astype(np.int32)
                       - image_plus50[2:-2].astype(np.int32))
        overlap_1_add = np.average(diff1 <= 1)
        overlap_2_add = np.average(diff2 <= 2)
        assert overlap_1_add >= 0.9
        assert overlap_2_add < 0.01

    def test_unusual_channel_numbers(self):
        with assertWarns(self, iaa.SuspiciousSingleImageShapeWarning):
            shapes = [
                (5, 5, 4),
                (5, 5, 5),
                (5, 5, 512),
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="7584" endline="7605" pcid="2119">
        img_aug_mask = img_aug > 255*0.1
        segmaps_aug_mask = ia.imresize_single_image(
            segmaps_aug.arr, (80, 80), interpolation="nearest") > 0
        same = np.sum(img_aug_mask == segmaps_aug_mask[:, :, 0])
        assert segmaps_aug.shape == (80, 80)
        assert segmaps_aug.arr.shape == (40, 40, 1)
        assert (same / img_aug_mask.size) >= 0.94

    # ---------
    # unusual channel numbers
    # ---------
    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="6468" endline="6489" pcid="2037">
            assert 0-tol <= y_min <= tol, "Got y_min=%.4f at %d" % (y_min, i)
            assert 0-tol <= x_min <= tol, "Got x_min=%.4f at %d" % (x_min, i)
            assert h-tol <= y_max <= h+tol, (
                "Got y_max=%.4f for h=%.2f at %d" % (y_max, h, i))
            assert w-tol <= x_max <= w+tol, (
                "Got x_max=%.4f for w=%.2f at %d" % (x_max, w, i))

    # ---------
    # unusual channel numbers
    # ---------
    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.PerspectiveTransform(scale=0.01)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="10058" endline="10083" pcid="2293">
                assert dist < 0.8

    def test_no_error_for_1x1_grids(self):
        aug = iaa.Jigsaw(nb_rows=1, nb_cols=1, max_steps=2)
        image = np.mod(np.arange(19*19*3), 255).astype(np.uint8)
        image = image.reshape((19, 19, 3))
        kpsoi = ia.KeypointsOnImage.from_xy_array([
            (0, 0),
            (5.5, 3.5),
            (4.0, 12.5),
            (11.1, 11.2),
            (12.1, 23.5)
        ], shape=(19, 19, 3))

        image_aug, kpsoi_aug = aug(image=image, keypoints=kpsoi)

        assert np.array_equal(image_aug, image)
        assert np.allclose(kpsoi_aug.to_xy_array(), kpsoi.to_xy_array())

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_weather.py" startline="222" endline="240" pcid="1526">
    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.Clouds()

                image_aug = aug(image=image)

                assert np.any(image_aug > 0)
                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_weather.py" startline="301" endline="319" pcid="1534">
    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.Fog()

                image_aug = aug(image=image)

                assert np.any(image_aug > 0)
                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="8708" endline="8727" pcid="2214">
        expected = self.lsoi_k1
        expected.line_strings = []
        assert_cbaois_equal(lsoi_aug, expected)

    def test_empty_bounding_boxes(self):
        aug = iaa.Rot90(k=1, keep_size=False)
        bbsoi = ia.BoundingBoxesOnImage([], shape=(4, 8, 3))

        bbsoi_aug = aug.augment_bounding_boxes(bbsoi)

        expected = self.bbsoi_k1
        expected.bounding_boxes = []
        assert_cbaois_equal(bbsoi_aug, expected)

    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="6490" endline="6515" pcid="2038">

                image_aug = aug(image=image)

                assert np.all(image_aug == 0)
                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape

    # ---------
    # zero-sized axes
    # ---------
    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            for keep_size in [False, True]:
                with self.subTest(shape=shape, keep_size=keep_size):
                    for _ in sm.xrange(3):
                        image = np.zeros(shape, dtype=np.uint8)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="3472" endline="3497" pcid="3442">

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 0, 0),
            (1, 0, 0),
            (0, 1, 0),
            (0, 0, 1),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                batch = _BatchInAugmentation(images=[image])
                child = iaa.HorizontalLinearGradientMaskGen()
                gen = iaa.InvertMaskGen(0.5, child)

                mask = gen.draw_masks(batch)[0]

                assert mask.shape == shape[0:2]
                assert mask.dtype.name == "float32"

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_pillike.py" startline="381" endline="402" pcid="4060">

    def _test_zero_sized_axes(self, func,
                              factors=(0.0, 0.4, 1.0)):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            for factor in factors:
                with self.subTest(shape=shape, factor=factor):
                    image = np.zeros(shape, dtype=np.uint8)

                    image_aug = func(image, factor=factor)

                    assert image_aug.dtype.name == "uint8"
                    assert image_aug.shape == shape
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="7606" endline="7631" pcid="2120">
                aug = iaa.ElasticTransformation(alpha=2.0, sigma=2.0)

                image_aug = aug(image=image)

                assert np.all(image_aug == 0)
                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape

    # ---------
    # zero-sized axes
    # ---------
    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            for keep_size in [False, True]:
                with self.subTest(shape=shape, keep_size=keep_size):
                    for _ in sm.xrange(3):
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_weather.py" startline="388" endline="404" pcid="1541">
    def test_zero_sized_axes(self):
        shapes = [
            (0, 0, 3),
            (0, 1, 3),
            (1, 0, 3)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.Snowflakes()

                image_aug = aug(image=image)

                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="3010" endline="3029" pcid="1860">
                                       atol=2)
                    assert np.allclose(image_aug[:, 2:3, 3:], 255, rtol=0,
                                       atol=2)
                    assert np.allclose(hm_aug_arr[:, 0:2, :], 0.5, rtol=0,
                                       atol=0.025)
                    assert np.allclose(hm_aug_arr[:, 2:3, :], 0.0, rtol=0,
                                       atol=0.025)

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for fit_output in [False, True]:
            for shape in shapes:
                with self.subTest(shape=shape, fit_output=fit_output):
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_weather.py" startline="496" endline="512" pcid="1551">
    def test_zero_sized_axes(self):
        shapes = [
            (0, 0, 3),
            (0, 1, 3),
            (1, 0, 3)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.Rain()

                image_aug = aug(image=image)

                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="959" endline="977" pcid="2857">
                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == image.shape

    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.Add(1)

                image_aug = aug(image=image)

                assert np.all(image_aug == 1)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="1449" endline="1467" pcid="2877">
                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == image.shape

    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.AddElementwise(1)

                image_aug = aug(image=image)

                assert np.all(image_aug == 1)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="3313" endline="3331" pcid="2990">
        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.ones(shape, dtype=np.uint8)
                aug = iaa.Multiply(1)

                image_aug = aug(image=image)

                assert np.all(image_aug == 2)
                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == image.shape

    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="3812" endline="3830" pcid="3008">
        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.ones(shape, dtype=np.uint8)
                aug = iaa.MultiplyElementwise(2)

                image_aug = aug(image=image)

                assert np.all(image_aug == 2)
                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == image.shape

    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="4285" endline="4303" pcid="3025">
        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.ReplaceElementwise(1.0, 1)

                image_aug = aug(image=image)

                assert np.all(image_aug == 1)
                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == image.shape

    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="5429" endline="5447" pcid="3106">
    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.Invert(1.0)

                image_aug = aug(image=image)

                assert np.all(image_aug == 255)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blur.py" startline="454" endline="471" pcid="2318">
        assert image_blurred.dtype.name == "uint8"
        assert not np.array_equal(image_blurred, image)

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)

                image_aug = iaa.blur_mean_shift_(np.copy(image), 1.0, 1.0)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="5857" endline="5873" pcid="3128">
        img_aug_c0 = iaa.JpegCompression(0).augment_image(img)
        img_aug_c100 = iaa.JpegCompression(100).augment_image(img)
        imgs_aug = aug.augment_images([img] * 4)
        assert np.array_equal(imgs_aug[0], img_aug_c0)
        assert np.array_equal(imgs_aug[1], img_aug_c100)
        assert np.array_equal(imgs_aug[2], img_aug_c0)
        assert np.array_equal(imgs_aug[3], img_aug_c100)

    def test_keypoints_dont_change(self):
        # test keypoints (not affected by augmenter)
        aug = iaa.JpegCompression(50)
        kps = ia.quokka_keypoints()
        kps_aug = aug.augment_keypoints([kps])[0]
        for kp, kp_aug in zip(kps.keypoints, kps_aug.keypoints):
            assert np.allclose([kp.x, kp.y], [kp_aug.x, kp_aug.y])

    def test_heatmaps_dont_change(self):
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_pillike.py" startline="319" endline="343" pcid="4056">

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            for cutoff in [0, 1, 10]:
                for ignore in [None, 0, 1, [0, 1, 10]]:
                    with self.subTest(shape=shape, cutoff=cutoff,
                                      ignore=ignore):
                        image = np.zeros(shape, dtype=np.uint8)

                        image_aug = iaa.pillike.autocontrast(image,
                                                             cutoff=cutoff,
                                                             ignore=ignore)

                        assert image_aug.dtype.name == "uint8"
                        assert image_aug.shape == shape
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="2341" endline="2359" pcid="1469">
                image_aug = iaa.quantize_kmeans(image, 2)

                assert np.all(image_aug == 0)
                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape

    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)

                image_aug = iaa.quantize_kmeans(image, 2)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="2790" endline="2808" pcid="1506">

                image_aug = iaa.quantize_uniform_(np.copy(image), 2)

                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape

    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)

                image_aug = iaa.quantize_uniform_(np.copy(image), 2)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="2170" endline="2195" pcid="3352">

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.full(shape, 255, dtype=np.uint8)
                bbs = [ia.BoundingBox(x1=1, y1=1, x2=5, y2=5, label="bb1"),
                       ia.BoundingBox(x1=-3, y1=4, x2=20, y2=8, label="bb2")]
                aug = iaa.BlendAlphaBoundingBoxes(
                    ["bb1"],
                    foreground=iaa.Multiply(0.0))

                image_aug, segmap_aug = aug(
                    image=image, bounding_boxes=[bbs])

                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_segmentation.py" startline="722" endline="741" pcid="2746">

    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

        sampler = iaa.RegularGridPointsSampler(50, 50)

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.full(shape, 128, dtype=np.uint8)
                aug = iaa.Voronoi(sampler, p_replace=1)

                image_aug = aug(image=image)

                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="1712" endline="1730" pcid="3317">

    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.full(shape, 0, dtype=np.uint8)
                aug = iaa.BlendAlpha(1.0, iaa.Add(1), iaa.Add(100))

                image_aug = aug(image=image)

                assert np.all(image_aug == 1)
                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="995" endline="1013" pcid="3229">

    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.full(shape, 0, dtype=np.uint8)
                aug = iaa.BlendAlpha(1.0, iaa.Add(1), iaa.Add(100))

                image_aug = aug(image=image)

                assert np.all(image_aug == 1)
                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_pooling.py" startline="581" endline="598" pcid="2666">
    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.full(shape, 128, dtype=np.uint8)
                aug = self.augmenter(3)

                image_aug = aug(image=image)

                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_segmentation.py" startline="165" endline="182" pcid="2705">
    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.full(shape, 128, dtype=np.uint8)
                aug = iaa.Superpixels(p_replace=1.0, n_segments=10)

                image_aug = aug(image=image)

                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_segmentation.py" startline="422" endline="448" pcid="2723">

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        cell_coordinates = np.float32([
            [1.0, 1.0],
            [3.0, 1.0]
        ])
        replace_mask = np.array([True, True], dtype=bool)

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.full(shape, 128, dtype=np.uint8)

                image_aug = iaa.segment_voronoi(image, cell_coordinates,
                                                replace_mask)

                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="2080" endline="2105" pcid="3347">

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.full(shape, 255, dtype=np.uint8)
                segmap_arr = np.zeros((2, 2, 1), dtype=np.int32)
                segmap_arr[0, 0] = 2
                aug = iaa.BlendAlphaSegMapClassIds(
                    2,
                    foreground=iaa.TotalDropout(1.0))

                image_aug, segmap_aug = aug(
                    image=image, segmentation_maps=[segmap_arr])

                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_flip.py" startline="413" endline="438" pcid="2525">
    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1),
            (0, 2),
            (2, 0),
            (0, 2, 0),
            (2, 0, 0),
            (0, 2, 1),
            (2, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = self.create_aug(1.0)

                image_aug = aug(image=image)

                assert image_aug.shape == image.shape

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blur.py" startline="985" endline="999" pcid="2342">
                if np.array_equal(observed, img_aug):
                    nb_seen[key] += 1
        # dont check sum here, because 0xX and Xx0 are all the same, i.e. much
        # higher sum than nb_iterations
        assert np.all([v > 0 for v in nb_seen.values()])

    def test_more_than_four_channels(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]
        for shape in shapes:
            with self.subTest(shape=shape):
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blur.py" startline="109" endline="123" pcid="2302">
    def test_more_than_four_channels(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]
        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)

                image_aug = iaa.blur_gaussian_(np.copy(image), 1.0)

                assert image_aug.shape == image.shape

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blur.py" startline="1294" endline="1308" pcid="2357">
            elif np.array_equal(observed, self.blur5x5):
                seen[1] += True
            else:
                raise Exception("Unexpected result in MedianBlur@2")
            if all(seen):
                break
        assert np.all(seen)

    def test_more_than_four_channels(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="1779" endline="1796" pcid="3322">

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0, 3),
            (0, 1, 3),
            (1, 0, 3)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.full(shape, 0, dtype=np.uint8)
                aug = iaa.BlendAlphaSomeColors(iaa.Add(1), iaa.Add(100))

                image_aug = aug(image=image)

                assert np.all(image_aug == 1)
                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="119" endline="137" pcid="3146">
    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image_fg = np.full(shape, 0, dtype=np.uint8)
                image_bg = np.full(shape, 255, dtype=np.uint8)

                image_aug = blend.blend_alpha(image_fg, image_bg, 1.0)

                assert np.all(image_aug == 0)
                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="5634" endline="5663" pcid="3836">
        observed = aug(keypoints=kpsoi)

        assert observed.keypoints[0].x == 2
        assert observed.keypoints[0].y == 4

    def test_get_parameters(self):
        aug = iaa.PadToMultiplesOf(width_multiple=1, height_multiple=2,
                                   pad_cval=5, pad_mode="edge",
                                   position="center")

        params = aug.get_parameters()

        assert params[0] == 1
        assert params[1] == 2
        assert params[2].value == "edge"
        assert params[3].value == 5
        assert np.isclose(params[4][0].value, 0.5)
        assert np.isclose(params[4][1].value, 0.5)

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1),
            (0, 2),
            (2, 0),
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="6026" endline="6055" pcid="3875">
        observed = aug(keypoints=kpsoi)

        assert observed.keypoints[0].x == 2
        assert observed.keypoints[0].y == 4

    def test_get_parameters(self):
        aug = iaa.PadToPowersOf(width_base=1, height_base=2,
                                pad_cval=5, pad_mode="edge",
                                position="center")

        params = aug.get_parameters()

        assert params[0] == 1
        assert params[1] == 2
        assert params[2].value == "edge"
        assert params[3].value == 5
        assert np.isclose(params[4][0].value, 0.5)
        assert np.isclose(params[4][1].value, 0.5)

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1),
            (0, 2),
            (2, 0),
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="3108" endline="3131" pcid="3416">

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 0, 0),
            (1, 0, 0),
            (0, 1, 0),
            (0, 0, 1),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                batch = _BatchInAugmentation(images=[image])
                gen = iaa.CheckerboardMaskGen(2, 2)

                mask = gen.draw_masks(batch)[0]

                assert mask.shape == shape[0:2]
                assert mask.dtype.name == "float32"
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="2964" endline="2987" pcid="3405">

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 0, 0),
            (1, 0, 0),
            (0, 1, 0),
            (0, 0, 1),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                batch = _BatchInAugmentation(images=[image])
                gen = iaa.RegularGridMaskGen(2, 2)

                mask = gen.draw_masks(batch)[0]

                assert mask.shape == shape[0:2]
                assert mask.dtype.name == "float32"
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="3400" endline="3425" pcid="3437">

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                bbs = [ia.BoundingBox(x1=1, y1=1, x2=5, y2=5, label="bb1"),
                       ia.BoundingBox(x1=-3, y1=4, x2=20, y2=8, label="bb2"),
                       ia.BoundingBox(x1=2, y1=2, x2=10, y2=10, label="bb3")]
                bbsoi = ia.BoundingBoxesOnImage(bbs, shape=shape)
                batch = _BatchInAugmentation(bounding_boxes=[bbsoi])
                gen = iaa.BoundingBoxesMaskGen("bb1")

                mask = gen.draw_masks(batch)[0]

                assert mask.shape == shape[0:2]
                assert mask.dtype.name == "float32"
                assert np.allclose(mask, 0.0)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_weather.py" startline="142" endline="159" pcid="1518">
    def test_zero_sized_axes(self):
        shapes = [
            (0, 0, 3),
            (0, 1, 3),
            (1, 0, 3)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.FastSnowyLandscape(100, 1.5,
                                             from_colorspace="RGB")

                image_aug = aug(image=image)

                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="2576" endline="2593" pcid="3379">

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0, 3),
            (0, 1, 3),
            (1, 0, 3)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                batch = _BatchInAugmentation(images=[image])
                gen = iaa.SomeColorsMaskGen()

                mask = gen.draw_masks(batch)[0]

                assert mask.shape == shape[0:2]
                assert mask.dtype.name == "float32"
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_segmentation.py" startline="1475" endline="1494" pcid="2804">

    def test_zero_sized_axes(self):
        shapes = [
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                sampler = iaa.UniformPointsSampler(1)

                points = sampler.sample_points([image], iarandom.RNG(1))[0]

                # TODO this is not the same as for
                #      (Relative)RegularGridPointsSampler, which returns in
                #      this case 0 points
                assert len(points) == 1
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_segmentation.py" startline="1495" endline="1511" pcid="2805">

    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                sampler = iaa.UniformPointsSampler(1)

                points = sampler.sample_points([image], iarandom.RNG(1))[0]

                assert len(points) == 1
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="182" endline="197" pcid="1286">
    def test_zero_sized_axes(self):
        shapes = [
            (0, 0, 3),
            (0, 1, 3),
            (1, 0, 3)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)

                image_aug = iaa.change_colorspace_(
                    np.copy(image), from_colorspace="RGB", to_colorspace="BGR")

                assert image_aug.shape == image.shape

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blur.py" startline="1353" endline="1367" pcid="2362">
        runtest_pickleable_uint8_img(aug, iterations=10)


# TODO extend these tests
class TestBilateralBlur(unittest.TestCase):
    def setUp(self):
        reseed()

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0, 3),
            (0, 1, 3),
            (1, 0, 3)
        ]

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_segmentation.py" startline="449" endline="473" pcid="2724">

    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

        cell_coordinates = np.float32([
            [1.0, 1.0],
            [3.0, 1.0]
        ])
        replace_mask = np.array([True, True], dtype=bool)

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.full(shape, 128, dtype=np.uint8)

                image_aug = iaa.segment_voronoi(image, cell_coordinates,
                                                replace_mask)

                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="5426" endline="5451" pcid="3815">
        aug = iaa.CropToMultiplesOf(height_multiple=5, width_multiple=2,
                                    position="center")

        observed = aug(keypoints=kpsoi)

        assert observed.keypoints[0].x == 2
        assert observed.keypoints[0].y == 2

    def test_get_parameters(self):
        aug = iaa.CropToMultiplesOf(width_multiple=1, height_multiple=2,
                                    position="center")

        params = aug.get_parameters()

        assert params[0] == 1
        assert params[1] == 2
        assert np.isclose(params[2][0].value, 0.5)
        assert np.isclose(params[2][1].value, 0.5)

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="6929" endline="6956" pcid="3958">
        segmaps_oi_nearest = self.segmaps_nearest

        segmaps_oi_aug = aug.augment_segmentation_maps([segmaps_oi])[0]

        assert segmaps_oi_aug.arr.shape == (4, 4, 1)
        assert np.array_equal(segmaps_oi_aug.arr, segmaps_oi_nearest.arr)

    def test_segmaps_specific_interpolation_set_to_no_resize(self):
        aug = iaa.KeepSizeByResize(
            self.children,
            interpolation="cubic",
            interpolation_segmaps=iaa.KeepSizeByResize.NO_RESIZE)
        segmaps_oi = self.segmaps

        segmaps_oi_aug = aug.augment_segmentation_maps([segmaps_oi])[0]

        assert segmaps_oi_aug.arr.shape == (3, 4, 1)
        assert np.array_equal(segmaps_oi_aug.arr, segmaps_oi.arr[1:, :, :])

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1),
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="3850" endline="3886" pcid="3690">
                # shape
                for warning in caught_warnings:
                    assert (
                        "crop amounts in CropAndPad"
                        in str(warning.message)
                    )

                expected_height = 0 if shape[0] == 0 else 1
                expected_width = 0 if shape[1] == 0 else 1
                expected_shape = tuple([expected_height, expected_width]
                                       + list(shape[2:]))
                assert image_aug.shape == expected_shape

    def test_zero_sized_axes_keep_size(self):
        # we also use height/width 2 here, because a height/width of 1 is
        # actually not changed due to prevent_zero_size
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1),
            (0, 2),
            (2, 0),
            (0, 2, 0),
            (2, 0, 0),
            (0, 2, 1),
            (2, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.Crop(px=1, keep_size=True)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="5819" endline="5844" pcid="3855">
        aug = iaa.CropToPowersOf(height_base=5, width_base=2,
                                 position="center")

        observed = aug(keypoints=kpsoi)

        assert observed.keypoints[0].x == 2
        assert observed.keypoints[0].y == 2

    def test_get_parameters(self):
        aug = iaa.CropToPowersOf(width_base=1, height_base=2,
                                 position="center")

        params = aug.get_parameters()

        assert params[0] == 1
        assert params[1] == 2
        assert np.isclose(params[2][0].value, 0.5)
        assert np.isclose(params[2][1].value, 0.5)

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="6182" endline="6208" pcid="3892">
    def test_keypoints(self):
        kps = [ia.Keypoint(x=2, y=3)]
        kpsoi = ia.KeypointsOnImage(kps, shape=(8, 8, 3))
        aug = iaa.CropToAspectRatio(2.0, position="center")

        observed = aug(keypoints=kpsoi)

        assert observed.keypoints[0].x == 2
        assert observed.keypoints[0].y == 1

    def test_get_parameters(self):
        aug = iaa.CropToAspectRatio(2.0, position="center")

        params = aug.get_parameters()

        assert np.isclose(params[0], 2.0)
        assert np.isclose(params[1][0].value, 0.5)
        assert np.isclose(params[1][1].value, 0.5)

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="5168" endline="5197" pcid="3792">
        segmaps_arr = np.ones((17, 17, 1), dtype=np.int32)
        segmaps = SegmentationMapsOnImage(segmaps_arr, shape=(34, 34, 3))

        observed = aug.augment_segmentation_maps([segmaps])[0]

        expected = np.ones((16, 16, 1), dtype=np.int32)
        assert observed.shape == (32, 32, 3)
        assert np.array_equal(observed.arr, expected)

    def test_get_parameters(self):
        aug = iaa.CropToFixedSize(width=20, height=10, position="center")
        params = aug.get_parameters()
        assert params[0] == 20
        assert params[1] == 10
        assert np.isclose(params[2][0].value, 0.5)
        assert np.isclose(params[2][1].value, 0.5)

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1),
            (0, 2),
            (2, 0),
            (0, 2, 0),
            (2, 0, 0),
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_segmentation.py" startline="1041" endline="1057" pcid="2769">

    def test_zero_sized_axes(self):
        shapes = [
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                sampler = iaa.RegularGridPointsSampler(1, 1)

                points = sampler.sample_points([image], iarandom.RNG(1))[0]

                assert len(points) == 1
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_segmentation.py" startline="1058" endline="1074" pcid="2770">

    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                sampler = iaa.RegularGridPointsSampler(1, 1)

                points = sampler.sample_points([image], iarandom.RNG(1))[0]

                assert len(points) == 1
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_segmentation.py" startline="1179" endline="1195" pcid="2781">

    def test_zero_sized_axes(self):
        shapes = [
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                sampler = iaa.RelativeRegularGridPointsSampler(0.01, 0.01)

                points = sampler.sample_points([image], iarandom.RNG(1))[0]

                assert len(points) == 1
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_segmentation.py" startline="1196" endline="1212" pcid="2782">

    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                sampler = iaa.RelativeRegularGridPointsSampler(0.01, 0.01)

                points = sampler.sample_points([image], iarandom.RNG(1))[0]

                assert len(points) == 1
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="3809" endline="3849" pcid="3689">

    def test_pad_empty_polygons(self):
        cbaoi = ia.PolygonsOnImage([], shape=(12, 14, 3))
        self._test_crop_empty_cba("augment_polygons", cbaoi)

    def test_pad_empty_line_strings(self):
        cbaoi = ia.LineStringsOnImage([], shape=(12, 14, 3))
        self._test_crop_empty_cba("augment_line_strings", cbaoi)

    def test_pad_empty_bounding_boxes(self):
        cbaoi = ia.BoundingBoxesOnImage([], shape=(12, 14, 3))
        self._test_crop_empty_cba("augment_bounding_boxes", cbaoi)

    def test_zero_sized_axes_no_keep_size(self):
        # we also use height/width 2 here, because a height/width of 1 is
        # actually not changed due to prevent_zero_size
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1),
            (0, 2),
            (2, 0),
            (0, 2, 0),
            (2, 0, 0),
            (0, 2, 1),
            (2, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.Crop(px=1, keep_size=False)

                with warnings.catch_warnings(record=True) as caught_warnings:
                    image_aug = aug(image=image)

                # we don't check the number of warnings here as it varies by
</source>
</class>

<class classid="43" nclones="3" nlines="13" similarity="71">
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="69" endline="81" pcid="1279">
    def test_function_works_inplace(self):
        image = np.arange(4*5*3).astype(np.uint8).reshape((4, 5, 3))
        image = np.copy(image)  # reshape sets flag OWNDATA=False
        image_orig = np.copy(image)
        from_cspace = iaa.CSPACE_RGB
        to_cspace = iaa.CSPACE_BGR
        image_out = iaa.change_colorspace_(
            image,
            to_colorspace=to_cspace, from_colorspace=from_cspace)
        assert image_out is image
        assert np.array_equal(image_out, image)
        assert not np.array_equal(image_out, image_orig)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="100" endline="116" pcid="1281">
    def test_image_is_noncontiguous(self):
        image = np.arange(4*5*3).astype(np.uint8).reshape((4, 5, 3))
        image = np.copy(image)  # reshape sets flag OWNDATA=False
        image_copy = np.copy(np.ascontiguousarray(np.fliplr(image)))
        image_noncontiguous = np.fliplr(image)
        assert image_noncontiguous.flags["C_CONTIGUOUS"] is False

        from_cspace = iaa.CSPACE_RGB
        to_cspace = iaa.CSPACE_BGR
        image_out = iaa.change_colorspace_(
            image_noncontiguous,
            to_colorspace=to_cspace, from_colorspace=from_cspace)

        expected = self._generate_expected_image(image_copy, from_cspace,
                                                 to_cspace)
        assert np.array_equal(image_out, expected)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="82" endline="99" pcid="1280">
    def test_image_is_view(self):
        image = np.arange(4*5*4).astype(np.uint8).reshape((4, 5, 4))
        image = np.copy(image)  # reshape sets flag OWNDATA=False
        image_copy = np.copy(image)
        image_view = image[..., 0:3]
        assert image_view.flags["OWNDATA"] is False

        from_cspace = iaa.CSPACE_RGB
        to_cspace = iaa.CSPACE_BGR
        image_out = iaa.change_colorspace_(
            image_view,
            to_colorspace=to_cspace, from_colorspace=from_cspace)

        expected = self._generate_expected_image(
            np.ascontiguousarray(image_copy[..., 0:3]),
            from_cspace, to_cspace)
        assert np.array_equal(image_out, expected)

</source>
</class>

<class classid="44" nclones="3" nlines="12" similarity="91">
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="117" endline="129" pcid="1282">
    def test_cannot_transform_from_grayscale_to_another_cspace(self):
        image = np.arange(4*5*3).astype(np.uint8).reshape((4, 5, 3))
        image = np.copy(image)  # reshape sets flag OWNDATA=False
        from_cspace = iaa.CSPACE_GRAY
        to_cspace = iaa.CSPACE_RGB
        with self.assertRaises(AssertionError) as cm:
            _ = iaa.change_colorspace_(
                np.copy(image),
                from_colorspace=from_cspace, to_colorspace=to_cspace)
        assert (
            "Cannot convert from grayscale to another colorspace"
            in str(cm.exception))

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="130" endline="142" pcid="1283">
    def test_image_without_channels_fails(self):
        image = np.arange(4*5).astype(np.uint8).reshape((4, 5))
        image = np.copy(image)  # reshape sets flag OWNDATA=False
        from_cspace = iaa.CSPACE_RGB
        to_cspace = iaa.CSPACE_BGR
        with self.assertRaises(AssertionError) as cm:
            _ = iaa.change_colorspace_(
                np.copy(image),
                from_colorspace=from_cspace, to_colorspace=to_cspace)
        assert (
            "Expected image shape to be three-dimensional"
            in str(cm.exception))

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="143" endline="155" pcid="1284">
    def test_image_with_four_channels_fails(self):
        image = np.arange(4*5*4).astype(np.uint8).reshape((4, 5, 4))
        image = np.copy(image)  # reshape sets flag OWNDATA=False
        from_cspace = iaa.CSPACE_RGB
        to_cspace = iaa.CSPACE_BGR
        with self.assertRaises(AssertionError) as cm:
            _ = iaa.change_colorspace_(
                np.copy(image),
                from_colorspace=from_cspace, to_colorspace=to_cspace)
        assert (
            "Expected number of channels to be three"
            in str(cm.exception))

</source>
</class>

<class classid="45" nclones="3" nlines="10" similarity="90">
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="705" endline="717" pcid="1333">
    def test_add_to_example_image(self):
        aug = iaa.MultiplyAndAddToBrightness(mul=1.0, add=10,
                                             to_colorspace=iaa.CSPACE_HSV,
                                             random_order=False)
        image = np.arange(6*6*3).astype(np.uint8).reshape((6, 6, 3))

        image_aug = aug(image=image)

        expected = cv2.cvtColor(image, cv2.COLOR_RGB2HSV).astype(np.float32)
        expected[:, :, 2] += 10
        expected = cv2.cvtColor(expected.astype(np.uint8), cv2.COLOR_HSV2RGB)
        assert np.array_equal(image_aug, expected)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="731" endline="744" pcid="1335">
    def test_multiply_and_add_example_image(self):
        aug = iaa.MultiplyAndAddToBrightness(mul=1.2, add=10,
                                             to_colorspace=iaa.CSPACE_HSV,
                                             random_order=False)
        image = np.arange(6*6*3).astype(np.uint8).reshape((6, 6, 3))

        image_aug = aug(image=image)

        expected = cv2.cvtColor(image, cv2.COLOR_RGB2HSV).astype(np.float32)
        expected[:, :, 2] *= 1.2
        expected[:, :, 2] += 10
        expected = cv2.cvtColor(expected.astype(np.uint8), cv2.COLOR_HSV2RGB)
        assert np.array_equal(image_aug, expected)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="718" endline="730" pcid="1334">
    def test_multiply_example_image(self):
        aug = iaa.MultiplyAndAddToBrightness(mul=1.2, add=0,
                                             to_colorspace=iaa.CSPACE_HSV,
                                             random_order=False)
        image = np.arange(6*6*3).astype(np.uint8).reshape((6, 6, 3))

        image_aug = aug(image=image)

        expected = cv2.cvtColor(image, cv2.COLOR_RGB2HSV).astype(np.float32)
        expected[:, :, 2] *= 1.2
        expected = cv2.cvtColor(expected.astype(np.uint8), cv2.COLOR_HSV2RGB)
        assert np.array_equal(image_aug, expected)

</source>
</class>

<class classid="46" nclones="6" nlines="28" similarity="71">
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="823" endline="858" pcid="1344">
    def test_augment_images__hue(self):
        def augment_images(images, random_state, parents, hooks):
            assert images[0].dtype.name == "int16"
            images = np.copy(images)
            images[..., 0] += 10
            return images

        aug = iaa.WithHueAndSaturation(iaa.Lambda(func_images=augment_images))

        # example image
        image = np.arange(0, 255).reshape((1, 255, 1)).astype(np.uint8)
        image = np.tile(image, (1, 1, 3))
        image[..., 0] += 0
        image[..., 1] += 1
        image[..., 2] += 2

        # compute expected output
        image_hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)
        image_hsv = image_hsv.astype(np.int16)
        image_hsv[..., 0] = (
            (image_hsv[..., 0].astype(np.float32)/180)*255).astype(np.int16)
        image_hsv[..., 0] += 10
        image_hsv[..., 0] = np.mod(image_hsv[..., 0], 255)
        image_hsv[..., 0] = (
            (image_hsv[..., 0].astype(np.float32)/255)*180).astype(np.int16)
        image_hsv = image_hsv.astype(np.uint8)
        image_expected = cv2.cvtColor(image_hsv, cv2.COLOR_HSV2RGB)
        assert not np.array_equal(image_expected, image)

        # augment and verify
        images_aug = aug.augment_images(np.stack([image, image], axis=0))
        assert ia.is_np_array(images_aug)
        for image_aug in images_aug:
            assert image_aug.shape == (1, 255, 3)
            assert np.array_equal(image_aug, image_expected)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="1067" endline="1104" pcid="1366">
    def test_augment_images__mul(self):
        aug = iaa.MultiplyHueAndSaturation(1.5)

        # example image
        image = np.arange(0, 255).reshape((1, 255, 1)).astype(np.uint8)
        image = np.tile(image, (1, 1, 3))
        image[..., 0] += 0
        image[..., 1] += 5
        image[..., 2] += 10

        # compute expected output
        image_hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)
        image_hsv = image_hsv.astype(np.int16)  # simulate WithHueAndSaturation
        image_hsv[..., 0] = (
            (image_hsv[..., 0].astype(np.float32)/180)*255).astype(np.int16)
        image_hsv = image_hsv.astype(np.float32)  # simulate Multiply

        image_hsv[..., 0] *= 1.5
        image_hsv[..., 1] *= 1.5
        image_hsv = np.round(image_hsv).astype(np.int16)

        image_hsv[..., 0] = np.mod(image_hsv[..., 0], 255)
        image_hsv[..., 0] = (
            (image_hsv[..., 0].astype(np.float32)/255)*180).astype(np.int16)
        image_hsv[..., 1] = np.clip(image_hsv[..., 1], 0, 255)

        image_hsv = image_hsv.astype(np.uint8)
        image_expected = cv2.cvtColor(image_hsv, cv2.COLOR_HSV2RGB)
        assert not np.array_equal(image_expected, image)

        # augment and verify
        images_aug = aug.augment_images(np.stack([image, image], axis=0))
        assert ia.is_np_array(images_aug)
        for image_aug in images_aug:
            assert image_aug.shape == (1, 255, 3)
            diff = np.abs(image_aug.astype(np.int16) - image_expected)
            assert np.all(diff <= 1)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="1150" endline="1194" pcid="1368">
    def test_augment_images__mul_saturation(self):
        # this is almost identical to test_augment_images__mul
        # only
        #     aug = ...
        # and
        #     image_hsv[...] *= 1.2
        # have been changed

        aug = iaa.MultiplyHueAndSaturation(mul_saturation=1.5)  # changed

        # example image
        image = np.arange(0, 255).reshape((1, 255, 1)).astype(np.uint8)
        image = np.tile(image, (1, 1, 3))
        image[..., 0] += 0
        image[..., 1] += 5
        image[..., 2] += 10

        # compute expected output
        image_hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)
        image_hsv = image_hsv.astype(np.int16)  # simulate WithHueAndSaturation
        image_hsv[..., 0] = (
            (image_hsv[..., 0].astype(np.float32)/180)*255).astype(np.int16)
        image_hsv = image_hsv.astype(np.float32)  # simulate Multiply

        image_hsv[..., 0] *= 1.0  # changed over __mul
        image_hsv[..., 1] *= 1.5
        image_hsv = np.round(image_hsv).astype(np.int16)

        image_hsv[..., 0] = np.mod(image_hsv[..., 0], 255)
        image_hsv[..., 0] = (
            (image_hsv[..., 0].astype(np.float32)/255)*180).astype(np.int16)
        image_hsv[..., 1] = np.clip(image_hsv[..., 1], 0, 255)

        image_hsv = image_hsv.astype(np.uint8)
        image_expected = cv2.cvtColor(image_hsv, cv2.COLOR_HSV2RGB)
        assert not np.array_equal(image_expected, image)

        # augment and verify
        images_aug = aug.augment_images(np.stack([image, image], axis=0))
        assert ia.is_np_array(images_aug)
        for image_aug in images_aug:
            assert image_aug.shape == (1, 255, 3)
            diff = np.abs(image_aug.astype(np.int16) - image_expected)
            assert np.all(diff <= 1)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="1105" endline="1149" pcid="1367">
    def test_augment_images__mul_hue(self):
        # this is almost identical to test_augment_images__mul
        # only
        #     aug = ...
        # and
        #     image_hsv[...] *= 1.2
        # have been changed

        aug = iaa.MultiplyHueAndSaturation(mul_hue=1.5)  # changed over __mul

        # example image
        image = np.arange(0, 255).reshape((1, 255, 1)).astype(np.uint8)
        image = np.tile(image, (1, 1, 3))
        image[..., 0] += 0
        image[..., 1] += 5
        image[..., 2] += 10

        # compute expected output
        image_hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)
        image_hsv = image_hsv.astype(np.int16)  # simulate WithHueAndSaturation
        image_hsv[..., 0] = (
            (image_hsv[..., 0].astype(np.float32)/180)*255).astype(np.int16)
        image_hsv = image_hsv.astype(np.float32)  # simulate Multiply

        image_hsv[..., 0] *= 1.5
        image_hsv[..., 1] *= 1.0  # changed over __mul
        image_hsv = np.round(image_hsv).astype(np.int16)

        image_hsv[..., 0] = np.mod(image_hsv[..., 0], 255)
        image_hsv[..., 0] = (
            (image_hsv[..., 0].astype(np.float32)/255)*180).astype(np.int16)
        image_hsv[..., 1] = np.clip(image_hsv[..., 1], 0, 255)

        image_hsv = image_hsv.astype(np.uint8)
        image_expected = cv2.cvtColor(image_hsv, cv2.COLOR_HSV2RGB)
        assert not np.array_equal(image_expected, image)

        # augment and verify
        images_aug = aug.augment_images(np.stack([image, image], axis=0))
        assert ia.is_np_array(images_aug)
        for image_aug in images_aug:
            assert image_aug.shape == (1, 255, 3)
            diff = np.abs(image_aug.astype(np.int16) - image_expected)
            assert np.all(diff <= 1)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="859" endline="894" pcid="1346">
    def test_augment_images__saturation(self):
        def augment_images(images, random_state, parents, hooks):
            assert images[0].dtype.name == "int16"
            images = np.copy(images)
            images[..., 1] += 10
            return images

        aug = iaa.WithHueAndSaturation(iaa.Lambda(func_images=augment_images))

        # example image
        image = np.arange(0, 255).reshape((1, 255, 1)).astype(np.uint8)
        image = np.tile(image, (1, 1, 3))
        image[..., 0] += 0
        image[..., 1] += 1
        image[..., 2] += 2

        # compute expected output
        image_hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)
        image_hsv = image_hsv.astype(np.int16)
        image_hsv[..., 0] = (
            (image_hsv[..., 0].astype(np.float32)/180)*255).astype(np.int16)
        image_hsv[..., 1] += 10
        image_hsv[..., 1] = np.clip(image_hsv[..., 1], 0, 255)
        image_hsv[..., 0] = (
            (image_hsv[..., 0].astype(np.float32)/255)*180).astype(np.int16)
        image_hsv = image_hsv.astype(np.uint8)
        image_expected = cv2.cvtColor(image_hsv, cv2.COLOR_HSV2RGB)
        assert not np.array_equal(image_expected, image)

        # augment and verify
        images_aug = aug.augment_images(np.stack([image, image], axis=0))
        assert ia.is_np_array(images_aug)
        for image_aug in images_aug:
            assert image_aug.shape == (1, 255, 3)
            assert np.array_equal(image_aug, image_expected)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="1195" endline="1240" pcid="1369">
    def test_augment_images__mul_hue_and_mul_saturation(self):
        # this is almost identical to test_augment_images__mul
        # only
        #     aug = ...
        # and
        #     image_hsv[...] *= 1.2
        # have been changed

        aug = iaa.MultiplyHueAndSaturation(mul_hue=1.5,
                                           mul_saturation=1.6)  # changed

        # example image
        image = np.arange(0, 255).reshape((1, 255, 1)).astype(np.uint8)
        image = np.tile(image, (1, 1, 3))
        image[..., 0] += 0
        image[..., 1] += 5
        image[..., 2] += 10

        # compute expected output
        image_hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)
        image_hsv = image_hsv.astype(np.int16)  # simulate WithHueAndSaturation
        image_hsv[..., 0] = (
            (image_hsv[..., 0].astype(np.float32)/180)*255).astype(np.int16)
        image_hsv = image_hsv.astype(np.float32)  # simulate Multiply

        image_hsv[..., 0] *= 1.5
        image_hsv[..., 1] *= 1.6  # changed over __mul
        image_hsv = np.round(image_hsv).astype(np.int16)

        image_hsv[..., 0] = np.mod(image_hsv[..., 0], 255)
        image_hsv[..., 0] = (
            (image_hsv[..., 0].astype(np.float32)/255)*180).astype(np.int16)
        image_hsv[..., 1] = np.clip(image_hsv[..., 1], 0, 255)

        image_hsv = image_hsv.astype(np.uint8)
        image_expected = cv2.cvtColor(image_hsv, cv2.COLOR_HSV2RGB)
        assert not np.array_equal(image_expected, image)

        # augment and verify
        images_aug = aug.augment_images(np.stack([image, image], axis=0))
        assert ia.is_np_array(images_aug)
        for image_aug in images_aug:
            assert image_aug.shape == (1, 255, 3)
            diff = np.abs(image_aug.astype(np.int16) - image_expected)
            assert np.all(diff <= 1)

</source>
</class>

<class classid="47" nclones="4" nlines="12" similarity="91">
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="1018" endline="1030" pcid="1363">
    def test_returns_correct_objects__mul_hue(self):
        aug = iaa.MultiplyHueAndSaturation(mul_hue=(0.9, 1.1))
        assert isinstance(aug, iaa.WithHueAndSaturation)
        assert isinstance(aug.children, iaa.Sequential)
        assert len(aug.children) == 1
        assert isinstance(aug.children[0], iaa.WithChannels)
        assert aug.children[0].channels == [0]
        assert len(aug.children[0].children) == 1
        assert isinstance(aug.children[0].children[0], iaa.Multiply)
        assert isinstance(aug.children[0].children[0].mul, iap.Uniform)
        assert np.isclose(aug.children[0].children[0].mul.a.value, 0.9)
        assert np.isclose(aug.children[0].children[0].mul.b.value, 1.1)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="1031" endline="1043" pcid="1364">
    def test_returns_correct_objects__mul_saturation(self):
        aug = iaa.MultiplyHueAndSaturation(mul_saturation=(0.9, 1.1))
        assert isinstance(aug, iaa.WithHueAndSaturation)
        assert isinstance(aug.children, iaa.Sequential)
        assert len(aug.children) == 1
        assert isinstance(aug.children[0], iaa.WithChannels)
        assert aug.children[0].channels == [1]
        assert len(aug.children[0].children) == 1
        assert isinstance(aug.children[0].children[0], iaa.Multiply)
        assert isinstance(aug.children[0].children[0].mul, iap.Uniform)
        assert np.isclose(aug.children[0].children[0].mul.a.value, 0.9)
        assert np.isclose(aug.children[0].children[0].mul.b.value, 1.1)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="1299" endline="1314" pcid="1374">
    def test_returns_correct_class(self):
        # this test is practically identical to
        # TestMultiplyToHueAndSaturation
        #     .test_returns_correct_objects__mul_saturation
        aug = iaa.MultiplySaturation((0.9, 1.1))
        assert isinstance(aug, iaa.WithHueAndSaturation)
        assert isinstance(aug.children, iaa.Sequential)
        assert len(aug.children) == 1
        assert isinstance(aug.children[0], iaa.WithChannels)
        assert aug.children[0].channels == [1]
        assert len(aug.children[0].children) == 1
        assert isinstance(aug.children[0].children[0], iaa.Multiply)
        assert isinstance(aug.children[0].children[0].mul, iap.Uniform)
        assert np.isclose(aug.children[0].children[0].mul.a.value, 0.9)
        assert np.isclose(aug.children[0].children[0].mul.b.value, 1.1)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="1278" endline="1292" pcid="1372">
    def test_returns_correct_class(self):
        # this test is practically identical to
        # TestMultiplyToHueAndSaturation.test_returns_correct_objects__mul_hue
        aug = iaa.MultiplyHue((0.9, 1.1))
        assert isinstance(aug, iaa.WithHueAndSaturation)
        assert isinstance(aug.children, iaa.Sequential)
        assert len(aug.children) == 1
        assert isinstance(aug.children[0], iaa.WithChannels)
        assert aug.children[0].channels == [0]
        assert len(aug.children[0].children) == 1
        assert isinstance(aug.children[0].children[0], iaa.Multiply)
        assert isinstance(aug.children[0].children[0].mul, iap.Uniform)
        assert np.isclose(aug.children[0].children[0].mul.a.value, 0.9)
        assert np.isclose(aug.children[0].children[0].mul.b.value, 1.1)

</source>
</class>

<class classid="48" nclones="2" nlines="11" similarity="81">
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="1544" endline="1557" pcid="1392">
    def test_augment_images__different_hue_and_saturation__no_per_channel(self):
        base_img = self.create_base_image()

        class _DummyParam(iap.StochasticParameter):
            def _draw_samples(self, size, random_state):
                arr = np.float32([10, 20])
                return np.tile(arr[np.newaxis, :], (size[0], 1))

        aug = iaa.AddToHueAndSaturation(value=_DummyParam(), per_channel=False)
        img_expected = self._add_hue_saturation(base_img, value=10)
        img_observed = aug.augment_image(base_img)

        assert np.array_equal(img_observed, img_expected)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="1558" endline="1572" pcid="1394">
    def test_augment_images__different_hue_and_saturation__per_channel(self):
        base_img = self.create_base_image()

        class _DummyParam(iap.StochasticParameter):
            def _draw_samples(self, size, random_state):
                arr = np.float32([10, 20])
                return np.tile(arr[np.newaxis, :], (size[0], 1))

        aug = iaa.AddToHueAndSaturation(value=_DummyParam(), per_channel=True)
        img_expected = self._add_hue_saturation(
            base_img, value_hue=10, value_saturation=20)
        img_observed = aug.augment_image(base_img)

        assert np.array_equal(img_observed, img_expected)

</source>
</class>

<class classid="49" nclones="2" nlines="13" similarity="100">
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="1644" endline="1662" pcid="1401">

    def test_augment_images__value_hue__multi_image_sampling(self):
        base_img = self.create_base_image()

        class _DummyParam(iap.StochasticParameter):
            def _draw_samples(self, size, random_state):
                return np.float32([10, 20, 30])

        aug = iaa.AddToHueAndSaturation(value_hue=_DummyParam())

        img_expected1 = self._add_hue_saturation(base_img, value_hue=10)
        img_expected2 = self._add_hue_saturation(base_img, value_hue=20)
        img_expected3 = self._add_hue_saturation(base_img, value_hue=30)

        img_observed1, img_observed2, img_observed3 = \
            aug.augment_images([base_img] * 3)

        assert np.array_equal(img_observed1, img_expected1)
        assert np.array_equal(img_observed2, img_expected2)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="1678" endline="1696" pcid="1404">
                assert np.array_equal(img_observed, img_expected)

    def test_augment_images__value_saturation__multi_image_sampling(self):
        base_img = self.create_base_image()

        class _DummyParam(iap.StochasticParameter):
            def _draw_samples(self, size, random_state):
                return np.float32([10, 20, 30])

        aug = iaa.AddToHueAndSaturation(value_saturation=_DummyParam())

        img_expected1 = self._add_hue_saturation(base_img, value_saturation=10)
        img_expected2 = self._add_hue_saturation(base_img, value_saturation=20)
        img_expected3 = self._add_hue_saturation(base_img, value_saturation=30)

        img_observed1, img_observed2, img_observed3 = \
            aug.augment_images([base_img] * 3)

        assert np.array_equal(img_observed1, img_expected1)
</source>
</class>

<class classid="50" nclones="3" nlines="16" similarity="87">
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="1948" endline="1965" pcid="1438">
        assert isinstance(aug.to_colorspace, list)
        assert aug.to_colorspace == [iaa.CSPACE_RGB,
                                     iaa.CSPACE_Lab]
        assert aug.max_size == 128
        assert aug.interpolation == "linear"

    def test___init___custom_parameters(self):
        aug = self.augmenter(
            n_colors=(5, 8),
            from_colorspace=iaa.CSPACE_BGR,
            to_colorspace=[iaa.CSPACE_HSV, iaa.CSPACE_Lab],
            max_size=None,
            interpolation="cubic"
        )
        assert isinstance(aug.n_colors, iap.DiscreteUniform)
        assert aug.n_colors.a.value == 5
        assert aug.n_colors.b.value == 8
        assert aug.from_colorspace == iaa.CSPACE_BGR
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="2525" endline="2542" pcid="1485">
        assert aug.counts.b.value == 8
        assert aug.from_colorspace == iaa.CSPACE_RGB
        assert aug.to_colorspace is None
        assert aug.max_size is None
        assert aug.interpolation == "linear"

    def test___init___custom_parameters(self):
        aug = self.augmenter(
            nb_bits=(5, 8),
            from_colorspace=iaa.CSPACE_BGR,
            to_colorspace=[iaa.CSPACE_HSV, iaa.CSPACE_Lab],
            max_size=128,
            interpolation="cubic"
        )
        assert isinstance(aug.counts, iap.DiscreteUniform)
        assert aug.counts.a.value == 5
        assert aug.counts.b.value == 8
        assert aug.from_colorspace == iaa.CSPACE_BGR
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="2382" endline="2399" pcid="1474">
        assert aug.n_colors.b.value == 16
        assert aug.from_colorspace == iaa.CSPACE_RGB
        assert aug.to_colorspace is None
        assert aug.max_size is None
        assert aug.interpolation == "linear"

    def test___init___custom_parameters(self):
        aug = self.augmenter(
            n_colors=(5, 8),
            from_colorspace=iaa.CSPACE_BGR,
            to_colorspace=[iaa.CSPACE_HSV, iaa.CSPACE_Lab],
            max_size=128,
            interpolation="cubic"
        )
        assert isinstance(aug.n_colors, iap.DiscreteUniform)
        assert aug.n_colors.a.value == 5
        assert aug.n_colors.b.value == 8
        assert aug.from_colorspace == iaa.CSPACE_BGR
</source>
</class>

<class classid="51" nclones="2" nlines="11" similarity="81">
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="1995" endline="2009" pcid="1441">
        # call i, args, argument 1
        n_colors = [mock_quantize_func.call_args_list[i][0][1]
                    for i in sm.xrange(n_images)]
        assert all([2 <= n_colors_i <= 1000 for n_colors_i in n_colors])
        assert len(set(n_colors)) > 1

    def test_to_colorspace(self):
        image = np.arange(3*3*3, dtype=np.uint8).reshape((3, 3, 3))
        aug = self.augmenter(to_colorspace="HSV")
        mock_quantize_func = mock.MagicMock(
            return_value=np.zeros((4, 4, 3), dtype=np.uint8))

        fname = self.quantization_func_name
        with mock.patch(fname, mock_quantize_func):
            _ = aug.augment_image(image)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="2010" endline="2023" pcid="1442">

        # call 0, kwargs, argument 'to_colorspace'
        expected = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)
        assert np.array_equal(mock_quantize_func.call_args_list[0][0][0],
                              expected)

    def test_to_colorspace_is_none(self):
        image = np.arange(3*3*3, dtype=np.uint8).reshape((3, 3, 3))
        aug = self.augmenter(to_colorspace=None)
        mock_quantize_func = mock.MagicMock(
            return_value=np.zeros((4, 4, 3), dtype=np.uint8))

        fname = self.quantization_func_name
        with mock.patch(fname, mock_quantize_func):
</source>
</class>

<class classid="52" nclones="2" nlines="18" similarity="88">
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="2024" endline="2046" pcid="1443">
            _ = aug.augment_image(image)

        # call 0, kwargs, argument 'to_colorspace'
        assert np.array_equal(mock_quantize_func.call_args_list[0][0][0],
                              image)

    def test_from_colorspace(self):
        def _noop(img):
            return img

        aug = self.augmenter(from_colorspace="BGR")
        mock_change_colorspace = mock.MagicMock()
        mock_change_colorspace.return_value = mock_change_colorspace
        mock_change_colorspace.augment_image.side_effect = _noop
        mock_change_colorspace._draw_samples.return_value = (None, ["foo"])

        fname = "imgaug.augmenters.color.ChangeColorspace"
        with mock.patch(fname, mock_change_colorspace):
            _ = aug.augment_image(np.zeros((4, 4, 3), dtype=np.uint8))

        # call 0, kwargs, argument 'from_colorspace'
        assert (
            mock_change_colorspace.call_args_list[0][1]["from_colorspace"]
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="2469" endline="2495" pcid="1478">
            max_size=None)

        observed = aug(image=image)

        assert np.array_equal(observed, expected)

    def test_from_colorspace(self):
        def _noop(img):
            return img

        # Actual to_colorspace doesn't matter here as it is overwritten
        # via return_value. Important is just to set it to a non-None value
        # so that a colorspace conversion actually happens.
        aug = self.augmenter(from_colorspace="BGR",
                             to_colorspace="Lab")
        mock_change_colorspace = mock.MagicMock()
        mock_change_colorspace.return_value = mock_change_colorspace
        mock_change_colorspace.augment_image.side_effect = _noop
        mock_change_colorspace._draw_samples.return_value = (None, ["foo"])

        fname = "imgaug.augmenters.color.ChangeColorspace"
        with mock.patch(fname, mock_change_colorspace):
            _ = aug.augment_image(np.zeros((4, 4, 3), dtype=np.uint8))

        # call 0, kwargs, argument 'from_colorspace'
        assert (
            mock_change_colorspace.call_args_list[0][1]["from_colorspace"]
</source>
</class>

<class classid="53" nclones="2" nlines="21" similarity="86">
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="2059" endline="2086" pcid="1446">
        with mock.patch(fname, mock_imresize):
            image_aug = aug.augment_image(image)
            assert image_aug.shape == image.shape

        assert mock_imresize.call_count == 0

    def test_max_size_is_int_and_resize_necessary(self):
        image = np.zeros((200, 100, 3), dtype=np.uint8)
        aug = self.augmenter(max_size=100)

        class _ImresizeSideEffect(object):
            def __init__(self):
                self.nth_call = 0

            def __call__(self, *_args, **_kwargs):
                if self.nth_call == 0:
                    self.nth_call += 1
                    return np.zeros((100, 50, 3), dtype=np.uint8)
                else:
                    return np.zeros((200, 100, 3), dtype=np.uint8)

        mock_imresize = mock.Mock()
        mock_imresize.side_effect = _ImresizeSideEffect()

        fname = "imgaug.imresize_single_image"
        with mock.patch(fname, mock_imresize):
            _ = aug.augment_image(image)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="2099" endline="2133" pcid="1450">
        with mock.patch(fname, mock_imresize):
            image_aug = aug.augment_image(image)
            assert image_aug.shape == image.shape

        assert mock_imresize.call_count == 0

    def test_interpolation(self):
        image = np.zeros((200, 100, 3), dtype=np.uint8)
        aug = self.augmenter(max_size=100, interpolation="cubic")

        class _ImresizeSideEffect(object):
            def __init__(self):
                self.nth_call = 0

            def __call__(self, *_args, **_kwargs):
                if self.nth_call == 0:
                    self.nth_call += 1
                    return np.zeros((100, 50, 3), dtype=np.uint8)
                else:
                    return np.zeros((200, 100, 3), dtype=np.uint8)

        mock_imresize = mock.Mock()
        mock_imresize.side_effect = _ImresizeSideEffect()

        fname = "imgaug.imresize_single_image"
        with mock.patch(fname, mock_imresize):
            _ = aug.augment_image(image)

        assert mock_imresize.call_count == 2
        # downscaling
        # call 0, args, argument 1 (sizes)
        # call 0, kwargs, argument "interpolation"
        assert mock_imresize.call_args_list[0][0][1] == (100, 50)
        assert mock_imresize.call_args_list[0][1]["interpolation"] == "cubic"

</source>
</class>

<class classid="54" nclones="8" nlines="16" similarity="84">
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="2134" endline="2153" pcid="1453">
        # upscaling
        # call 1, args, argument 1 (sizes)
        # call 1, kwargs, argument "interpolation"
        assert mock_imresize.call_args_list[1][0][1] == image.shape[0:2]
        assert mock_imresize.call_args_list[1][1]["interpolation"] == "cubic"

    def test_images_with_1_channel_integrationtest(self):
        image = np.uint8([
            [0, 0, 255, 255],
            [0, 1, 255, 255],
        ])
        expected = np.uint8([
            [0, 0, 255, 255],
            [0, 0, 255, 255],
        ])

        aug = self.augmenter(
            n_colors=2,
            from_colorspace="RGB",
            to_colorspace="RGB",
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="2400" endline="2419" pcid="1475">
        assert isinstance(aug.to_colorspace, list)
        assert aug.to_colorspace == [iaa.CSPACE_HSV,
                                     iaa.CSPACE_Lab]
        assert aug.max_size == 128
        assert aug.interpolation == "cubic"

    def test_images_with_1_channel_integrationtest(self):
        image = np.uint8([
            [0, 0, 255, 255],
            [0, 1, 255, 255],
        ])
        expected = np.uint8([
            [64, 64, 192, 192],
            [64, 64, 192, 192],
        ])

        aug = self.augmenter(
            n_colors=2,
            from_colorspace="RGB",
            to_colorspace="RGB",
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="2177" endline="2202" pcid="1455">
            max_size=None)

        observed = aug(image=image)

        assert np.array_equal(observed, expected)

    def test_images_with_4_channels_integrationtest(self):
        image = np.uint8([
            [0, 0, 255, 255],
            [0, 1, 255, 255],
        ])
        expected = np.uint8([
            [0, 0, 255, 255],
            [0, 0, 255, 255],
        ])

        image = np.tile(image[..., np.newaxis], (1, 1, 4))
        expected = np.tile(expected[..., np.newaxis], (1, 1, 3))

        # alpha channel is expected to not be altered by quantization
        expected = np.concatenate([expected, image[:, :, 3:4]], axis=-1)

        aug = self.augmenter(
            n_colors=2,
            from_colorspace="RGB",
            to_colorspace="RGB",
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="2563" endline="2585" pcid="1487">
            max_size=None)

        observed = aug(image=image)

        assert np.array_equal(observed, expected)

    def test_images_with_3_channels_integrationtest(self):
        image = np.uint8([
            [0, 0, 255, 255],
            [0, 1, 255, 255],
        ])
        expected = np.uint8([
            [0, 0, 128, 128],
            [0, 0, 128, 128],
        ])

        image = np.tile(image[..., np.newaxis], (1, 1, 3))
        expected = np.tile(expected[..., np.newaxis], (1, 1, 3))

        aug = self.augmenter(
            nb_bits=1,
            from_colorspace="RGB",
            to_colorspace="RGB",
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="2420" endline="2442" pcid="1476">
            max_size=None)

        observed = aug(image=image)

        assert np.array_equal(observed, expected)

    def test_images_with_3_channels_integrationtest(self):
        image = np.uint8([
            [0, 0, 255, 255],
            [0, 1, 255, 255],
        ])
        expected = np.uint8([
            [64, 64, 192, 192],
            [64, 64, 192, 192],
        ])

        image = np.tile(image[..., np.newaxis], (1, 1, 3))
        expected = np.tile(expected[..., np.newaxis], (1, 1, 3))

        aug = self.augmenter(
            n_colors=2,
            from_colorspace="RGB",
            to_colorspace="RGB",
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="2154" endline="2176" pcid="1454">
            max_size=None)

        observed = aug(image=image)

        assert np.array_equal(observed, expected)

    def test_images_with_3_channels_integrationtest(self):
        image = np.uint8([
            [0, 0, 255, 255],
            [0, 1, 255, 255],
        ])
        expected = np.uint8([
            [0, 0, 255, 255],
            [0, 0, 255, 255],
        ])

        image = np.tile(image[..., np.newaxis], (1, 1, 3))
        expected = np.tile(expected[..., np.newaxis], (1, 1, 3))

        aug = self.augmenter(
            n_colors=2,
            from_colorspace="RGB",
            to_colorspace="RGB",
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="2543" endline="2562" pcid="1486">
        assert isinstance(aug.to_colorspace, list)
        assert aug.to_colorspace == [iaa.CSPACE_HSV,
                                     iaa.CSPACE_Lab]
        assert aug.max_size == 128
        assert aug.interpolation == "cubic"

    def test_images_with_1_channel_integrationtest(self):
        image = np.uint8([
            [0, 0, 255, 255],
            [0, 1, 255, 255],
        ])
        expected = np.uint8([
            [0, 0, 128, 128],
            [0, 0, 128, 128],
        ])

        aug = self.augmenter(
            nb_bits=1,
            from_colorspace="RGB",
            to_colorspace="RGB",
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="2443" endline="2468" pcid="1477">
            max_size=None)

        observed = aug(image=image)

        assert np.array_equal(observed, expected)

    def test_images_with_4_channels_integrationtest(self):
        image = np.uint8([
            [0, 0, 255, 255],
            [0, 1, 255, 255],
        ])
        expected = np.uint8([
            [64, 64, 192, 192],
            [64, 64, 192, 192],
        ])

        image = np.tile(image[..., np.newaxis], (1, 1, 4))
        expected = np.tile(expected[..., np.newaxis], (1, 1, 3))

        # alpha channel is expected to not be altered by quantization
        expected = np.concatenate([expected, image[:, :, 3:4]], axis=-1)

        aug = self.augmenter(
            n_colors=2,
            from_colorspace="RGB",
            to_colorspace="RGB",
</source>
</class>

<class classid="55" nclones="2" nlines="14" similarity="92">
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="2255" endline="2272" pcid="1461">

class Test_quantize_kmeans(unittest.TestCase):
    def setUp(self):
        reseed()

    @classmethod
    def _test_images_with_n_channels(cls, nb_channels):
        image = np.uint8([
            [0, 0, 255, 255],
            [0, 1, 255, 255],
        ])
        expected = np.uint8([
            [0, 0, 255, 255],
            [0, 0, 255, 255],
        ])

        if nb_channels is not None:
            image = np.tile(image[..., np.newaxis], (1, 1, nb_channels))
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="2640" endline="2657" pcid="1494">

class Test_quantize_uniform_(unittest.TestCase):
    def setUp(self):
        reseed()

    @classmethod
    def _test_images_with_n_channels_2_colors(cls, nb_channels):
        image = np.uint8([
            [0, 0, 255, 255],
            [0, 1, 255, 255],
        ])
        expected = np.uint8([
            [64, 64, 192, 192],
            [64, 64, 192, 192],
        ])

        if nb_channels is not None:
            image = np.tile(image[..., np.newaxis], (1, 1, nb_channels))
</source>
</class>

<class classid="56" nclones="2" nlines="12" similarity="91">
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="2293" endline="2306" pcid="1466">
        expected = np.copy(image)

        observed = iaa.quantize_kmeans(image, 100)

        assert np.array_equal(observed, expected)

    def test_failure_if_n_colors_less_than_2(self):
        image = np.uint8([
            [0, 0, 255, 255],
            [0, 1, 255, 255],
        ])

        got_exception = False
        try:
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_color.py" startline="2737" endline="2750" pcid="1503">
        observed = iaa.quantize_uniform_(np.copy(image),
                                         4,
                                         to_bin_centers=False)

        assert np.array_equal(observed, expected)

    def test_failure_if_n_colors_less_than_2(self):
        image = np.uint8([
            [0, 0, 255, 255],
            [0, 1, 255, 255],
        ])

        got_exception = False
        try:
</source>
</class>

<class classid="57" nclones="2" nlines="14" similarity="85">
<source file="systems/imgaug-0.4.0/test/augmenters/test_weather.py" startline="55" endline="69" pcid="1514">
    def test_basic_functionality(self):
        # basic functionality test
        aug = iaa.FastSnowyLandscape(
            lightness_threshold=100,
            lightness_multiplier=2.0)
        image = np.arange(0, 6*6*3).reshape((6, 6, 3)).astype(np.uint8)
        image_hls = cv2.cvtColor(image, cv2.COLOR_RGB2HLS)
        mask = (image_hls[..., 1] < 100)
        expected = np.copy(image_hls).astype(np.float32)
        expected[..., 1][mask] *= 2.0
        expected = np.clip(np.round(expected), 0, 255).astype(np.uint8)
        expected = cv2.cvtColor(expected, cv2.COLOR_HLS2RGB)
        observed = aug.augment_image(image)
        assert np.array_equal(observed, expected)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_weather.py" startline="126" endline="141" pcid="1517">
    def test_from_colorspace(self):
        # test BGR colorspace
        aug = iaa.FastSnowyLandscape(
            lightness_threshold=100,
            lightness_multiplier=2.0,
            from_colorspace="BGR")
        image = np.arange(0, 6*6*3).reshape((6, 6, 3)).astype(np.uint8)
        image_hls = cv2.cvtColor(image, cv2.COLOR_BGR2HLS)
        mask = (image_hls[..., 1] < 100)
        expected = np.copy(image_hls).astype(np.float32)
        expected[..., 1][mask] *= 2.0
        expected = np.clip(np.round(expected), 0, 255).astype(np.uint8)
        expected = cv2.cvtColor(expected, cv2.COLOR_HLS2BGR)
        observed = aug.augment_image(image)
        assert np.array_equal(observed, expected)

</source>
</class>

<class classid="58" nclones="2" nlines="21" similarity="90">
<source file="systems/imgaug-0.4.0/test/augmenters/test_weather.py" startline="70" endline="97" pcid="1515">
    def test_vary_lightness_threshold(self):
        # test when varying lightness_threshold between images
        image = np.arange(0, 6*6*3).reshape((6, 6, 3)).astype(np.uint8)
        image_hls = cv2.cvtColor(image, cv2.COLOR_RGB2HLS)

        aug = iaa.FastSnowyLandscape(
            lightness_threshold=_TwoValueParam(75, 125),
            lightness_multiplier=2.0)

        mask = (image_hls[..., 1] < 75)
        expected1 = np.copy(image_hls).astype(np.float64)
        expected1[..., 1][mask] *= 2.0
        expected1 = np.clip(np.round(expected1), 0, 255).astype(np.uint8)
        expected1 = cv2.cvtColor(expected1, cv2.COLOR_HLS2RGB)

        mask = (image_hls[..., 1] < 125)
        expected2 = np.copy(image_hls).astype(np.float64)
        expected2[..., 1][mask] *= 2.0
        expected2 = np.clip(np.round(expected2), 0, 255).astype(np.uint8)
        expected2 = cv2.cvtColor(expected2, cv2.COLOR_HLS2RGB)

        observed = aug.augment_images([image] * 4)

        assert np.array_equal(observed[0], expected1)
        assert np.array_equal(observed[1], expected2)
        assert np.array_equal(observed[2], expected1)
        assert np.array_equal(observed[3], expected2)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_weather.py" startline="98" endline="125" pcid="1516">
    def test_vary_lightness_multiplier(self):
        # test when varying lightness_multiplier between images
        image = np.arange(0, 6*6*3).reshape((6, 6, 3)).astype(np.uint8)
        image_hls = cv2.cvtColor(image, cv2.COLOR_RGB2HLS)

        aug = iaa.FastSnowyLandscape(
            lightness_threshold=100,
            lightness_multiplier=_TwoValueParam(1.5, 2.0))

        mask = (image_hls[..., 1] < 100)
        expected1 = np.copy(image_hls).astype(np.float64)
        expected1[..., 1][mask] *= 1.5
        expected1 = np.clip(np.round(expected1), 0, 255).astype(np.uint8)
        expected1 = cv2.cvtColor(expected1, cv2.COLOR_HLS2RGB)

        mask = (image_hls[..., 1] < 100)
        expected2 = np.copy(image_hls).astype(np.float64)
        expected2[..., 1][mask] *= 2.0
        expected2 = np.clip(np.round(expected2), 0, 255).astype(np.uint8)
        expected2 = cv2.cvtColor(expected2, cv2.COLOR_HLS2RGB)

        observed = aug.augment_images([image] * 4)

        assert np.array_equal(observed[0], expected1)
        assert np.array_equal(observed[1], expected2)
        assert np.array_equal(observed[2], expected1)
        assert np.array_equal(observed[3], expected2)

</source>
</class>

<class classid="59" nclones="3" nlines="14" similarity="92">
<source file="systems/imgaug-0.4.0/test/augmenters/test_weather.py" startline="175" endline="191" pcid="1521">
    def _test_very_roughly(cls, nb_channels):
        if nb_channels is None:
            img = np.zeros((100, 100), dtype=np.uint8)
        else:
            img = np.zeros((100, 100, nb_channels), dtype=np.uint8)
        imgs_aug = iaa.Clouds().augment_images([img] * 5)
        assert 20 < np.average(imgs_aug) < 250
        assert np.max(imgs_aug) > 150

        for img_aug in imgs_aug:
            img_aug_f32 = img_aug.astype(np.float32)
            grad_x = img_aug_f32[:, 1:] - img_aug_f32[:, :-1]
            grad_y = img_aug_f32[1:, :] - img_aug_f32[:-1, :]

            assert np.sum(np.abs(grad_x)) > 5 * img.shape[1]
            assert np.sum(np.abs(grad_y)) > 5 * img.shape[0]

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_weather.py" startline="254" endline="270" pcid="1529">
    def _test_very_roughly(cls, nb_channels):
        if nb_channels is None:
            img = np.zeros((100, 100), dtype=np.uint8)
        else:
            img = np.zeros((100, 100, nb_channels), dtype=np.uint8)
        imgs_aug = iaa.Clouds().augment_images([img] * 5)
        assert 50 < np.average(imgs_aug) < 255
        assert np.max(imgs_aug) > 100

        for img_aug in imgs_aug:
            img_aug_f32 = img_aug.astype(np.float32)
            grad_x = img_aug_f32[:, 1:] - img_aug_f32[:, :-1]
            grad_y = img_aug_f32[1:, :] - img_aug_f32[:-1, :]

            assert np.sum(np.abs(grad_x)) > 1 * img.shape[1]
            assert np.sum(np.abs(grad_y)) > 1 * img.shape[0]

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_weather.py" startline="469" endline="486" pcid="1547">
    def _test_very_roughly(cls, nb_channels):
        if nb_channels is None:
            img = np.zeros((100, 100), dtype=np.uint8)
        else:
            img = np.zeros((100, 100, nb_channels), dtype=np.uint8)

        imgs_aug = iaa.Rain()(images=[img] * 5)
        assert 5 < np.average(imgs_aug) < 200
        assert np.max(imgs_aug) > 70

        for img_aug in imgs_aug:
            img_aug_f32 = img_aug.astype(np.float32)
            grad_x = img_aug_f32[:, 1:] - img_aug_f32[:, :-1]
            grad_y = img_aug_f32[1:, :] - img_aug_f32[:-1, :]

            assert np.sum(np.abs(grad_x)) > 10 * img.shape[1]
            assert np.sum(np.abs(grad_y)) > 10 * img.shape[0]

</source>
</class>

<class classid="60" nclones="2" nlines="10" similarity="70">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="80" endline="91" pcid="1557">
    def test___init___translate_percent_is_stochastic_parameter(self):
        aug = iaa.Affine(translate_percent=iap.Uniform(0.7, 0.9))

        assert isinstance(aug.translate, tuple)
        assert isinstance(aug.translate[0], iap.Uniform)
        assert isinstance(aug.translate[0].a, iap.Deterministic)
        assert isinstance(aug.translate[0].b, iap.Deterministic)
        assert 0.7 - 1e-8 < aug.translate[0].a.value < 0.7 + 1e-8
        assert 0.9 - 1e-8 < aug.translate[0].b.value < 0.9 + 1e-8
        assert aug.translate[1] is None
        assert aug.translate[2] == "percent"

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="92" endline="103" pcid="1558">
    def test___init___translate_px_is_stochastic_parameter(self):
        aug = iaa.Affine(translate_px=iap.DiscreteUniform(1, 10))

        assert isinstance(aug.translate, tuple)
        assert isinstance(aug.translate[0], iap.DiscreteUniform)
        assert isinstance(aug.translate[0].a, iap.Deterministic)
        assert isinstance(aug.translate[0].b, iap.Deterministic)
        assert aug.translate[0].a.value == 1
        assert aug.translate[0].b.value == 10
        assert aug.translate[1] is None
        assert aug.translate[2] == "px"

</source>
</class>

<class classid="61" nclones="4" nlines="10" similarity="70">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="548" endline="560" pcid="1624">
    def test_image_scale_zoom_in_only_x_axis__deterministic(self):
        aug = iaa.Affine(scale={"x": 1.75, "y": 1.0},
                         translate_px=0, rotate=0, shear=0)
        aug_det = aug.to_deterministic()

        observed = aug_det.augment_images(self.images)

        assert observed[0][1, 1] > 250
        assert (observed[0][[1, 1], [0, 2]] > 20).all()
        assert (observed[0][[1, 1], [0, 2]] < 150).all()
        assert (observed[0][0, :] < 5).all()
        assert (observed[0][2, :] < 5).all()

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="573" endline="585" pcid="1626">
    def test_image_scale_zoom_in_only_x_axis__deterministic_and_list(self):
        aug = iaa.Affine(scale={"x": 1.75, "y": 1.0},
                         translate_px=0, rotate=0, shear=0)
        aug_det = aug.to_deterministic()

        observed = aug_det.augment_images([self.base_img])

        assert observed[0][1, 1] > 250
        assert (observed[0][[1, 1], [0, 2]] > 20).all()
        assert (observed[0][[1, 1], [0, 2]] < 150).all()
        assert (observed[0][0, :] < 5).all()
        assert (observed[0][2, :] < 5).all()

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="641" endline="653" pcid="1636">
    def test_image_scale_zoom_in_only_y_axis__deterministic(self):
        aug = iaa.Affine(scale={"x": 1.0, "y": 1.75},
                         translate_px=0, rotate=0, shear=0)
        aug_det = aug.to_deterministic()

        observed = aug_det.augment_images(self.images)

        assert observed[0][1, 1] > 250
        assert (observed[0][[0, 2], [1, 1]] > 20).all()
        assert (observed[0][[0, 2], [1, 1]] < 150).all()
        assert (observed[0][:, 0] < 5).all()
        assert (observed[0][:, 2] < 5).all()

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="666" endline="678" pcid="1638">
    def test_image_scale_zoom_in_only_y_axis__deterministic_and_list(self):
        aug = iaa.Affine(scale={"x": 1.0, "y": 1.75},
                         translate_px=0, rotate=0, shear=0)
        aug_det = aug.to_deterministic()

        observed = aug_det.augment_images([self.base_img])

        assert observed[0][1, 1] > 250
        assert (observed[0][[0, 2], [1, 1]] > 20).all()
        assert (observed[0][[0, 2], [1, 1]] < 150).all()
        assert (observed[0][:, 0] < 5).all()
        assert (observed[0][:, 2] < 5).all()

</source>
</class>

<class classid="62" nclones="2" nlines="23" similarity="91">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="851" endline="875" pcid="1665">
    def test_image_x_and_y_axis_are_tuples(self):
        aug = iaa.Affine(scale={"x": (0.5, 1.5), "y": (0.5, 1.5)},
                         translate_px=0, rotate=0, shear=0)

        image = np.array([[0, 0, 0, 0, 0],
                          [0, 1, 1, 1, 0],
                          [0, 1, 2, 1, 0],
                          [0, 1, 1, 1, 0],
                          [0, 0, 0, 0, 0]], dtype=np.uint8) * 100
        image = image[:, :, np.newaxis]
        images = np.array([image])

        last_aug = None
        nb_changed_aug = 0
        nb_iterations = 1000
        for i in sm.xrange(nb_iterations):
            observed_aug = aug.augment_images(images)
            if i == 0:
                last_aug = observed_aug
            else:
                if not np.array_equal(observed_aug, last_aug):
                    nb_changed_aug += 1
                last_aug = observed_aug
        assert nb_changed_aug >= int(nb_iterations * 0.8)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="876" endline="902" pcid="1666">
    def test_image_x_and_y_axis_are_tuples__deterministic(self):
        aug = iaa.Affine(scale={"x": (0.5, 1.5), "y": (0.5, 1.5)},
                         translate_px=0, rotate=0, shear=0)
        aug_det = aug.to_deterministic()

        image = np.array([[0, 0, 0, 0, 0],
                          [0, 1, 1, 1, 0],
                          [0, 1, 2, 1, 0],
                          [0, 1, 1, 1, 0],
                          [0, 0, 0, 0, 0]], dtype=np.uint8) * 100
        image = image[:, :, np.newaxis]
        images = np.array([image])

        last_aug_det = None
        nb_changed_aug_det = 0
        nb_iterations = 10
        for i in sm.xrange(nb_iterations):
            observed_aug_det = aug_det.augment_images(images)
            if i == 0:
                last_aug_det = observed_aug_det
            else:
                if not np.array_equal(observed_aug_det, last_aug_det):
                    nb_changed_aug_det += 1
                last_aug_det = observed_aug_det
        assert nb_changed_aug_det == 0

    # ------------
</source>
</class>

<class classid="63" nclones="6" nlines="19" similarity="70">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="1465" endline="1488" pcid="1744">
    def test_image_translate_by_axiswise_uniform_distributions(self):
        # 0-1px to left/right and 0-1px to top/bottom
        aug = iaa.Affine(scale=1.0, translate_px={"x": (-1, 1), "y": (-1, 1)},
                         rotate=0, shear=0)
        last_aug = None
        nb_changed_aug = 0
        nb_iterations = 1000
        centers_aug = self.image.astype(np.int32) * 0
        for i in sm.xrange(nb_iterations):
            observed_aug = aug.augment_images(self.images)
            if i == 0:
                last_aug = observed_aug
            else:
                if not np.array_equal(observed_aug, last_aug):
                    nb_changed_aug += 1
                last_aug = observed_aug

            assert len(observed_aug[0].nonzero()[0]) == 1
            centers_aug += (observed_aug[0] > 0)

        assert nb_changed_aug >= int(nb_iterations * 0.7)
        assert (centers_aug > int(nb_iterations * (1/9 * 0.6))).all()
        assert (centers_aug < int(nb_iterations * (1/9 * 1.4))).all()

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="1489" endline="1512" pcid="1745">
    def test_image_translate_by_axiswise_uniform_distributions__det(self):
        # 0-1px to left/right and 0-1px to top/bottom
        aug = iaa.Affine(scale=1.0, translate_px={"x": (-1, 1), "y": (-1, 1)},
                         rotate=0, shear=0)
        aug_det = aug.to_deterministic()
        last_aug_det = None
        nb_changed_aug_det = 0
        nb_iterations = 10
        centers_aug_det = self.image.astype(np.int32) * 0
        for i in sm.xrange(nb_iterations):
            observed_aug_det = aug_det.augment_images(self.images)
            if i == 0:
                last_aug_det = observed_aug_det
            else:
                if not np.array_equal(observed_aug_det, last_aug_det):
                    nb_changed_aug_det += 1
                last_aug_det = observed_aug_det

            assert len(observed_aug_det[0].nonzero()[0]) == 1
            centers_aug_det += (observed_aug_det[0] > 0)

        assert nb_changed_aug_det == 0

    # ---------------------
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="1810" endline="1832" pcid="1783">
    def test_image_rotate_is_tuple_0_to_364_deg__deterministic(self):
        aug = iaa.Affine(scale=1.0, translate_px=0, rotate=(0, 364), shear=0)
        aug_det = aug.to_deterministic()
        last_aug_det = None
        nb_changed_aug_det = 0
        nb_iterations = 10
        pixels_sums_aug_det = self.image.astype(np.int32) * 0
        for i in sm.xrange(nb_iterations):
            observed_aug_det = aug_det.augment_images(self.images)
            if i == 0:
                last_aug_det = observed_aug_det
            else:
                if not np.array_equal(observed_aug_det, last_aug_det):
                    nb_changed_aug_det += 1
                last_aug_det = observed_aug_det

            pixels_sums_aug_det += (observed_aug_det[0] > 100)

        assert nb_changed_aug_det == 0
        # center pixel, should always be white when rotating line around center
        assert pixels_sums_aug_det[1, 1] > (nb_iterations * 0.98)
        assert pixels_sums_aug_det[1, 1] < (nb_iterations * 1.02)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="1966" endline="1986" pcid="1794">
    def test_image_cval_is_tuple__deterministic(self):
        # random cvals
        aug = iaa.Affine(scale=1.0, translate_px=100, rotate=0, shear=0,
                         cval=(0, 255))
        aug_det = aug.to_deterministic()
        last_aug_det = None
        nb_changed_aug_det = 0
        nb_iterations = 10
        for i in sm.xrange(nb_iterations):
            observed_aug_det = aug_det.augment_images(self.images)

            if i == 0:
                last_aug_det = observed_aug_det
            else:
                if not np.array_equal(observed_aug_det, last_aug_det):
                    nb_changed_aug_det += 1
                last_aug_det = observed_aug_det

        assert nb_changed_aug_det == 0


</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="1775" endline="1809" pcid="1782">
    def test_image_rotate_is_tuple_0_to_364_deg(self):
        # random rotation 0-364 degrees
        aug = iaa.Affine(scale=1.0, translate_px=0, rotate=(0, 364), shear=0)
        last_aug = None
        nb_changed_aug = 0
        nb_iterations = 1000
        pixels_sums_aug = self.image.astype(np.int32) * 0
        for i in sm.xrange(nb_iterations):
            observed_aug = aug.augment_images(self.images)
            if i == 0:
                last_aug = observed_aug
            else:
                if not np.array_equal(observed_aug, last_aug):
                    nb_changed_aug += 1
                last_aug = observed_aug

            pixels_sums_aug += (observed_aug[0] > 100)

        assert nb_changed_aug >= int(nb_iterations * 0.9)
        # center pixel, should always be white when rotating line around center
        assert pixels_sums_aug[1, 1] > (nb_iterations * 0.98)
        assert pixels_sums_aug[1, 1] < (nb_iterations * 1.02)

        # outer pixels, should sometimes be white
        # the values here had to be set quite tolerant, the middle pixels at
        # top/left/bottom/right get more activation than expected
        outer_pixels = ([0, 0, 0, 1, 1, 2, 2, 2],
                        [0, 1, 2, 0, 2, 0, 1, 2])
        assert (
            pixels_sums_aug[outer_pixels] > int(nb_iterations * (2/8 * 0.4))
        ).all()
        assert (
            pixels_sums_aug[outer_pixels] < int(nb_iterations * (2/8 * 2.0))
        ).all()

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="1947" endline="1965" pcid="1793">
    def test_image_cval_is_tuple(self):
        # random cvals
        aug = iaa.Affine(scale=1.0, translate_px=100, rotate=0, shear=0,
                         cval=(0, 255))
        last_aug = None
        nb_changed_aug = 0
        nb_iterations = 1000
        for i in sm.xrange(nb_iterations):
            observed_aug = aug.augment_images(self.images)

            if i == 0:
                last_aug = observed_aug
            else:
                if not np.array_equal(observed_aug, last_aug):
                    nb_changed_aug += 1
                last_aug = observed_aug

        assert nb_changed_aug >= int(nb_iterations * 0.9)

</source>
</class>

<class classid="64" nclones="5" nlines="16" similarity="70">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="2046" endline="2062" pcid="1802">
    def test_image_rot45(self):
        for backend in ["auto", "cv2", "skimage"]:
            with self.subTest(backend=backend):
                aug = iaa.Affine(rotate=45, fit_output=True,
                                 backend=backend)
                img = np.zeros((10, 10), dtype=np.uint8)
                img[0:2, 0:2] = 255
                img[-2:, 0:2] = 255
                img[0:2, -2:] = 255
                img[-2:, -2:] = 255

                img_aug = aug.augment_image(img)

                _labels, nb_labels = skimage.morphology.label(
                    img_aug > 240, return_num=True, connectivity=2)
                assert nb_labels == 4

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="2167" endline="2191" pcid="1807">
    def test_segmaps_rot45(self):
        for backend in ["auto", "cv2", "skimage"]:
            with self.subTest(backend=backend):
                aug = iaa.Affine(rotate=45, fit_output=True,
                                 backend=backend)
                img = np.zeros((80, 80), dtype=np.uint8)
                img[0:5, 0:5] = 255
                img[-5:, 0:5] = 255
                img[0:5, -5:] = 255
                img[-5:, -5:] = 255
                segmap = SegmentationMapsOnImage(
                    (img > 100).astype(np.int32),
                    shape=(80, 80)
                )

                segmap_aug = aug.augment_segmentation_maps([segmap])[0]

                # these asserts are deactivated because the image size can
                # change under fit_output=True
                # assert segmap_aug.shape == (80, 80)
                # assert segmap_aug.arr_0to1.shape == (40, 40, 1)
                _labels, nb_labels = skimage.morphology.label(
                    segmap_aug.arr > 0, return_num=True, connectivity=2)
                assert nb_labels == 4

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="2063" endline="2081" pcid="1803">
    def test_heatmaps_rot45(self):
        for backend in ["auto", "cv2", "skimage"]:
            with self.subTest(backend=backend):
                aug = iaa.Affine(rotate=45, fit_output=True,
                                 backend=backend)
                img = np.zeros((10, 10), dtype=np.uint8)
                img[0:2, 0:2] = 255
                img[-2:, 0:2] = 255
                img[0:2, -2:] = 255
                img[-2:, -2:] = 255
                hm = ia.HeatmapsOnImage(img.astype(np.float32)/255,
                                        shape=(10, 10))

                hm_aug = aug.augment_heatmaps([hm])[0]

                _labels, nb_labels = skimage.morphology.label(
                    hm_aug.arr_0to1 > 240/255, return_num=True, connectivity=2)
                assert nb_labels == 4

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="2082" endline="2108" pcid="1804">
    def test_heatmaps_rot45__heatmaps_smaller_than_image(self):
        for backend in ["auto", "cv2", "skimage"]:
            with self.subTest(backend=backend):
                aug = iaa.Affine(rotate=45, fit_output=True,
                                 backend=backend)
                img = np.zeros((80, 80), dtype=np.uint8)
                img[0:5, 0:5] = 255
                img[-5:, 0:5] = 255
                img[0:5, -5:] = 255
                img[-5:, -5:] = 255
                hm = HeatmapsOnImage(
                    ia.imresize_single_image(
                        img, (40, 40), interpolation="cubic"
                    ).astype(np.float32)/255,
                    shape=(80, 80)
                )

                hm_aug = aug.augment_heatmaps([hm])[0]

                # these asserts are deactivated because the image size can
                # change under fit_output=True
                # assert hm_aug.shape == (80, 80)
                # assert hm_aug.arr_0to1.shape == (40, 40, 1)
                _labels, nb_labels = skimage.morphology.label(
                    hm_aug.arr_0to1 > 200/255, return_num=True, connectivity=2)
                assert nb_labels == 4

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="2192" endline="2220" pcid="1808">
    def test_segmaps_rot45__segmaps_smaller_than_img(self):
        for backend in ["auto", "cv2", "skimage"]:
            with self.subTest(backend=backend):
                aug = iaa.Affine(rotate=45, fit_output=True,
                                 backend=backend)
                img = np.zeros((80, 80), dtype=np.uint8)
                img[0:5, 0:5] = 255
                img[-5:, 0:5] = 255
                img[0:5, -5:] = 255
                img[-5:, -5:] = 255
                segmap = SegmentationMapsOnImage(
                    (
                        ia.imresize_single_image(
                            img, (40, 40), interpolation="cubic"
                        ) > 100
                     ).astype(np.int32),
                    shape=(80, 80)
                )

                segmap_aug = aug.augment_segmentation_maps([segmap])[0]

                # these asserts are deactivated because the image size can
                # change under fit_output=True
                # assert segmap_aug.shape == (80, 80)
                # assert segmap_aug.arr_0to1.shape == (40, 40, 1)
                _labels, nb_labels = skimage.morphology.label(
                    segmap_aug.arr > 0, return_num=True, connectivity=2)
                assert nb_labels == 4

</source>
</class>

<class classid="65" nclones="4" nlines="24" similarity="73">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="2109" endline="2136" pcid="1805">
    def test_image_heatmap_alignment_random_rots(self):
        nb_iterations = 50
        for backend in ["auto", "cv2", "skimage"]:
            with self.subTest(backend=backend):
                for _ in sm.xrange(nb_iterations):
                    aug = iaa.Affine(rotate=(0, 364), fit_output=True,
                                     backend=backend)
                    img = np.zeros((80, 80), dtype=np.uint8)
                    img[0:5, 0:5] = 255
                    img[-5:, 0:5] = 255
                    img[0:5, -5:] = 255
                    img[-5:, -5:] = 255
                    hm = HeatmapsOnImage(
                        img.astype(np.float32)/255,
                        shape=(80, 80)
                    )

                    img_aug = aug.augment_image(img)
                    hm_aug = aug.augment_heatmaps([hm])[0]

                    img_aug_mask = img_aug > 255*0.1
                    hm_aug_mask = ia.imresize_single_image(
                        hm_aug.arr_0to1, img_aug.shape[0:2],
                        interpolation="cubic"
                    ) > 0.1
                    same = np.sum(img_aug_mask == hm_aug_mask[:, :, 0])
                    assert (same / img_aug_mask.size) >= 0.95

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="2250" endline="2282" pcid="1810">
    def test_image_segmap_alignment_random_rots__sms_smaller_than_img(self):
        nb_iterations = 50
        for backend in ["auto", "cv2", "skimage"]:
            with self.subTest(backend=backend):
                for _ in sm.xrange(nb_iterations):
                    aug = iaa.Affine(rotate=(0, 364), fit_output=True,
                                     backend=backend)
                    img = np.zeros((80, 80), dtype=np.uint8)
                    img[0:5, 0:5] = 255
                    img[-5:, 0:5] = 255
                    img[0:5, -5:] = 255
                    img[-5:, -5:] = 255
                    segmap = SegmentationMapsOnImage(
                        (
                            ia.imresize_single_image(
                                img, (40, 40), interpolation="cubic"
                            ) > 100
                         ).astype(np.int32),
                        shape=(80, 80)
                    )

                    img_aug = aug.augment_image(img)
                    segmap_aug = aug.augment_segmentation_maps([segmap])[0]

                    img_aug_mask = img_aug > 100
                    segmap_aug_mask = ia.imresize_single_image(
                        segmap_aug.arr,
                        img_aug.shape[0:2],
                        interpolation="nearest"
                    ) > 0
                    same = np.sum(img_aug_mask == segmap_aug_mask[:, :, 0])
                    assert (same / img_aug_mask.size) >= 0.95

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="2221" endline="2249" pcid="1809">
    def test_image_segmap_alignment_random_rots(self):
        nb_iterations = 50
        for backend in ["auto", "cv2", "skimage"]:
            with self.subTest(backend=backend):
                for _ in sm.xrange(nb_iterations):
                    aug = iaa.Affine(rotate=(0, 364), fit_output=True,
                                     backend=backend)
                    img = np.zeros((80, 80), dtype=np.uint8)
                    img[0:5, 0:5] = 255
                    img[-5:, 0:5] = 255
                    img[0:5, -5:] = 255
                    img[-5:, -5:] = 255
                    segmap = SegmentationMapsOnImage(
                        (img > 100).astype(np.int32),
                        shape=(80, 80)
                    )

                    img_aug = aug.augment_image(img)
                    segmap_aug = aug.augment_segmentation_maps([segmap])[0]

                    img_aug_mask = img_aug > 100
                    segmap_aug_mask = ia.imresize_single_image(
                        segmap_aug.arr,
                        img_aug.shape[0:2],
                        interpolation="nearest"
                    ) > 0
                    same = np.sum(img_aug_mask == segmap_aug_mask[:, :, 0])
                    assert (same / img_aug_mask.size) >= 0.95

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="2137" endline="2166" pcid="1806">
    def test_image_heatmap_alignment_random_rots__hms_smaller_than_img(self):
        nb_iterations = 50
        for backend in ["auto", "cv2", "skimage"]:
            with self.subTest(backend=backend):
                for _ in sm.xrange(nb_iterations):
                    aug = iaa.Affine(rotate=(0, 364), fit_output=True,
                                     backend=backend)
                    img = np.zeros((80, 80), dtype=np.uint8)
                    img[0:5, 0:5] = 255
                    img[-5:, 0:5] = 255
                    img[0:5, -5:] = 255
                    img[-5:, -5:] = 255
                    hm = HeatmapsOnImage(
                        ia.imresize_single_image(
                            img, (40, 40), interpolation="cubic"
                        ).astype(np.float32)/255,
                        shape=(80, 80)
                    )

                    img_aug = aug.augment_image(img)
                    hm_aug = aug.augment_heatmaps([hm])[0]

                    img_aug_mask = img_aug > 255*0.1
                    hm_aug_mask = ia.imresize_single_image(
                        hm_aug.arr_0to1, img_aug.shape[0:2],
                        interpolation="cubic"
                    ) > 0.1
                    same = np.sum(img_aug_mask == hm_aug_mask[:, :, 0])
                    assert (same / img_aug_mask.size) >= 0.95

</source>
</class>

<class classid="66" nclones="2" nlines="12" similarity="91">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="2283" endline="2295" pcid="1811">
    def test_keypoints_rot90_without_fit_output(self):
        for backend in ["auto", "cv2", "skimage"]:
            with self.subTest(backend=backend):
                aug = iaa.Affine(rotate=90, backend=backend)
                kps = ia.KeypointsOnImage([ia.Keypoint(10, 10)],
                                          shape=(100, 200, 3))
                kps_aug = aug.augment_keypoints(kps)
                assert kps_aug.shape == (100, 200, 3)
                assert not np.allclose(
                    [kps_aug.keypoints[0].x, kps_aug.keypoints[0].y],
                    [kps.keypoints[0].x, kps.keypoints[0].y],
                    atol=1e-2, rtol=0)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="2296" endline="2310" pcid="1812">
    def test_keypoints_rot90(self):
        for backend in ["auto", "cv2", "skimage"]:
            with self.subTest(backend=backend):
                aug = iaa.Affine(rotate=90, fit_output=True, backend=backend)
                kps = ia.KeypointsOnImage([ia.Keypoint(10, 10)],
                                          shape=(100, 200, 3))

                kps_aug = aug.augment_keypoints(kps)

                assert kps_aug.shape == (200, 100, 3)
                assert not np.allclose(
                    [kps_aug.keypoints[0].x, kps_aug.keypoints[0].y],
                    [kps.keypoints[0].x, kps.keypoints[0].y],
                    atol=1e-2, rtol=0)

</source>
</class>

<class classid="67" nclones="2" nlines="26" similarity="85">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="2424" endline="2457" pcid="1826">
    def test_image_segmap_alignment_with_translate_px(self):
        image = np.zeros((80, 100, 3), dtype=np.uint8)
        image[40-10:40+10, 50-10:50+10, :] = 255
        hm = np.zeros((40, 50, 1), dtype=np.float32)
        hm[20-5:20+5, 25-5:25+5, 0] = 1.0
        hm = ia.HeatmapsOnImage(hm, shape=image.shape)

        # note that if x is an odd value (e.g. 1), the projection is a bit
        # less accurate as x=1 projected to a half-sized segmap is x=0.5,
        # leading to interpolation effects
        xvals = [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, [0, 10, 20]]

        for xvals_i in xvals:
            with self.subTest(x=xvals_i):
                aug = iaa.Affine(translate_px={"x": xvals_i})
                iterations = 2 if ia.is_single_number(xvals_i) else 20

                for _ in np.arange(iterations):
                    image_aug, hm_aug = aug(image=image, heatmaps=hm)

                    hm_aug_arr_rs = ia.imresize_single_image(
                        hm_aug.get_arr(), (80, 100), interpolation="nearest")
                    overlap_true = np.sum(
                        np.logical_and(
                            (image_aug[..., 0] > 220),
                            (hm_aug_arr_rs[..., 0] > 0.9)
                        )
                    )
                    p_same_on_zero_cells = np.average(
                        (image_aug[..., 0] > 220)
                        == (hm_aug_arr_rs[..., 0] > 0.9))
                    assert overlap_true > 19*19
                    assert p_same_on_zero_cells > 0.98

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="2458" endline="2494" pcid="1827">
    def test_image_segmap_alignment_with_translate_percent(self):
        image = np.zeros((80, 100, 3), dtype=np.uint8)
        image[40-10:40+10, 50-10:50+10, :] = 255
        hm = np.zeros((40, 50, 1), dtype=np.float32)
        hm[20-5:20+5, 25-5:25+5, 0] = 1.0
        hm = ia.HeatmapsOnImage(hm, shape=image.shape)

        # note that if x is an odd value (e.g. 1), the projection is a bit
        # less accurate as x=1 projected to a half-sized segmap is x=0.5,
        # leading to interpolation effects
        width = image.shape[1]
        xvals = [0/width, 2/width, 4/width, 6/width, 8/width, 10/width,
                 12/width, 14/width, 16/width, 18/width, 20/width,
                 [0/width, 10/width, 20/width]]

        for xvals_i in xvals:
            with self.subTest(x=xvals_i):
                aug = iaa.Affine(translate_percent={"x": xvals_i})
                iterations = 2 if ia.is_single_number(xvals_i) else 20

                for _ in np.arange(iterations):
                    image_aug, hm_aug = aug(image=image, heatmaps=hm)

                    hm_aug_arr_rs = ia.imresize_single_image(
                        hm_aug.get_arr(), (80, 100), interpolation="nearest")
                    overlap_true = np.sum(
                        np.logical_and(
                            (image_aug[..., 0] > 220),
                            (hm_aug_arr_rs[..., 0] > 0.9)
                        )
                    )
                    p_same_on_zero_cells = np.average(
                        (image_aug[..., 0] > 220)
                        == (hm_aug_arr_rs[..., 0] > 0.9))
                    assert overlap_true > 19*19
                    assert p_same_on_zero_cells > 0.98

</source>
</class>

<class classid="68" nclones="3" nlines="23" similarity="73">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="2655" endline="2682" pcid="1842">
    def test_translate_skimage_order_0_uint_int(self):
        dtypes = ["uint8", "uint16", "uint32", "int8", "int16", "int32"]
        for dtype in dtypes:
            aug = iaa.Affine(translate_px={"x": 1}, order=0, mode="constant",
                             backend="skimage")

            min_value, center_value, max_value = \
                iadt.get_value_range_of_dtype(dtype)

            if np.dtype(dtype).kind == "i":
                values = [1, 5, 10, 100, int(0.1 * max_value),
                          int(0.2 * max_value), int(0.5 * max_value),
                          max_value - 100, max_value]
                values = values + [(-1) * value for value in values]
            else:
                values = [1, 5, 10, 100, int(center_value),
                          int(0.1 * max_value), int(0.2 * max_value),
                          int(0.5 * max_value), max_value - 100, max_value]

            for value in values:
                image = np.zeros((3, 3), dtype=dtype)
                image[1, 1] = value

                image_aug = aug.augment_image(image)

                assert image_aug.dtype.name == dtype
                assert np.all(image_aug[~self.translate_mask] == 0)
                assert np.all(image_aug[self.translate_mask] == value)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="2833" endline="2861" pcid="1852">
        assert image_aug.dtype.name == image.dtype.name
        assert np.all(image_aug[~self.translate_mask] == 0)
        assert np.all(image_aug[self.translate_mask] == 1)

    def test_translate_cv2_order_0_uint_int(self):
        aug = iaa.Affine(translate_px={"x": 1}, order=0, mode="constant",
                         backend="cv2")

        dtypes = ["uint8", "uint16", "int8", "int16", "int32"]
        for dtype in dtypes:
            min_value, center_value, max_value = \
                iadt.get_value_range_of_dtype(dtype)

            if np.dtype(dtype).kind == "i":
                values = [1, 5, 10, 100, int(0.1 * max_value),
                          int(0.2 * max_value), int(0.5 * max_value),
                          max_value - 100, max_value]
                values = values + [(-1) * value for value in values]
            else:
                values = [1, 5, 10, 100, int(center_value),
                          int(0.1 * max_value), int(0.2 * max_value),
                          int(0.5 * max_value), max_value - 100, max_value]

            for value in values:
                with self.subTest(dtype=dtype, value=value):
                    image = np.zeros((3, 3), dtype=dtype)
                    image[1, 1] = value

                    image_aug = aug.augment_image(image)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="5347" endline="5375" pcid="1977">
        image[self.other_dtypes_mask] = True

        image_aug = aug.augment_image(image)

        assert image_aug.dtype.name == image.dtype.name
        assert not np.all(image_aug == 1)
        assert np.any(image_aug[~self.other_dtypes_mask] == 1)

    def test_other_dtypes_uint_int(self):
        aug = iaa.PiecewiseAffine(scale=0.2, nb_rows=8, nb_cols=4, order=0,
                                  mode="constant")

        dtypes = ["uint8", "uint16", "uint32", "int8", "int16", "int32"]
        for dtype in dtypes:
            min_value, center_value, max_value = \
                iadt.get_value_range_of_dtype(dtype)

            if np.dtype(dtype).kind == "i":
                values = [1, 5, 10, 100, int(0.1 * max_value),
                          int(0.2 * max_value), int(0.5 * max_value),
                          max_value-100, max_value]
                values = values + [(-1)*value for value in values]
            else:
                values = [1, 5, 10, 100, int(center_value),
                          int(0.1 * max_value), int(0.2 * max_value),
                          int(0.5 * max_value), max_value-100, max_value]

            for value in values:
                with self.subTest(dtype=dtype, value=value):
</source>
</class>

<class classid="69" nclones="7" nlines="24" similarity="72">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="2683" endline="2712" pcid="1843">

    def test_translate_skimage_order_0_float(self):
        # float
        dtypes = ["float16", "float32", "float64"]
        for dtype in dtypes:
            aug = iaa.Affine(translate_px={"x": 1}, order=0, mode="constant",
                             backend="skimage")

            min_value, center_value, max_value = \
                iadt.get_value_range_of_dtype(dtype)

            def _isclose(a, b):
                atol = 1e-4 if dtype == "float16" else 1e-8
                return np.isclose(a, b, atol=atol, rtol=0)

            isize = np.dtype(dtype).itemsize
            values = [0.01, 1.0, 10.0, 100.0, 500 ** (isize - 1),
                      1000 ** (isize - 1)]
            values = values + [(-1) * value for value in values]
            values = values + [min_value, max_value]
            for value in values:
                with self.subTest(dtype=dtype, value=value):
                    image = np.zeros((3, 3), dtype=dtype)
                    image[1, 1] = value

                    image_aug = aug.augment_image(image)

                    assert image_aug.dtype.name == dtype
                    assert np.all(_isclose(image_aug[~self.translate_mask], 0))
                    assert np.all(_isclose(image_aug[self.translate_mask],
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="4609" endline="4639" pcid="3743">
                    1, 5, 10, 100, int(center_value), int(0.1 * max_value),
                    int(0.2 * max_value), int(0.5 * max_value),
                    max_value - 100, max_value]

            for value in values:
                with self.subTest(dtype=dtype, value=value):
                    image = np.zeros((3, 3), dtype=dtype)
                    image[1, 1] = value

                    image_aug = aug.augment_image(image)

                    assert image_aug.dtype.name == dtype
                    assert image_aug.shape == (4, 3)
                    assert np.all(image_aug[~mask] == 0)
                    assert np.all(image_aug[mask] == value)

    def test_other_dtypes_float(self):
        aug = iaa.PadToFixedSize(height=4, width=3, position="center-top")
        dtypes = ["float16", "float32", "float64", "float128"]

        mask = np.zeros((4, 3), dtype=bool)
        mask[2, 1] = True

        for dtype in dtypes:
            min_value, center_value, max_value = \
                iadt.get_value_range_of_dtype(dtype)

            def _isclose(a, b):
                atol = 1e-4 if dtype == "float16" else 1e-8
                return np.isclose(a, b, atol=atol, rtol=0)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="2862" endline="2890" pcid="1853">

                    assert image_aug.dtype.name == dtype
                    assert np.all(image_aug[~self.translate_mask] == 0)
                    assert np.all(image_aug[self.translate_mask] == value)

    def test_translate_cv2_order_0_float(self):
        aug = iaa.Affine(translate_px={"x": 1}, order=0, mode="constant",
                         backend="cv2")

        dtypes = ["float16", "float32", "float64"]
        for dtype in dtypes:
            min_value, center_value, max_value = \
                iadt.get_value_range_of_dtype(dtype)

            def _isclose(a, b):
                atol = 1e-4 if dtype == "float16" else 1e-8
                return np.isclose(a, b, atol=atol, rtol=0)

            isize = np.dtype(dtype).itemsize
            values = [0.01, 1.0, 10.0, 100.0, 500 ** (isize - 1),
                      1000 ** (isize - 1)]
            values = values + [(-1) * value for value in values]
            values = values + [min_value, max_value]
            for value in values:
                with self.subTest(dtype=dtype, value=value):
                    image = np.zeros((3, 3), dtype=dtype)
                    image[1, 1] = value

                    image_aug = aug.augment_image(image)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="5246" endline="5277" pcid="3795">
            else:
                values = [
                    1, 5, 10, 100, int(center_value), int(0.1 * max_value),
                    int(0.2 * max_value), int(0.5 * max_value),
                    max_value - 100, max_value]

            for value in values:
                with self.subTest(dtype=dtype, value=value):
                    image = np.zeros((3, 3), dtype=dtype)
                    image[1, 1] = value

                    image_aug = aug.augment_image(image)

                    assert image_aug.dtype.name == dtype
                    assert image_aug.shape == (2, 3)
                    assert np.all(image_aug[~mask] == 0)
                    assert np.all(image_aug[mask] == value)

    def test_other_dtypes_float(self):
        aug = iaa.CropToFixedSize(height=2, width=3, position="center-top")
        mask = np.zeros((2, 3), dtype=bool)
        mask[0, 1] = True

        dtypes = ["float16", "float32", "float64", "float128"]

        for dtype in dtypes:
            min_value, center_value, max_value = \
                iadt.get_value_range_of_dtype(dtype)

            def _isclose(a, b):
                atol = 1e-4 if dtype == "float16" else 1e-8
                return np.isclose(a, b, atol=atol, rtol=0)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="5376" endline="5407" pcid="1978">
                    image = np.zeros((21, 21), dtype=dtype)
                    image[:, 7:13] = value

                    image_aug = aug.augment_image(image)

                    assert image_aug.dtype.name == dtype
                    assert not np.all(image_aug == value)
                    assert np.any(image_aug[~self.other_dtypes_mask] == value)

    def test_other_dtypes_float(self):
        aug = iaa.PiecewiseAffine(scale=0.2, nb_rows=8, nb_cols=4, order=0,
                                  mode="constant")

        dtypes = ["float16", "float32", "float64"]
        for dtype in dtypes:
            min_value, center_value, max_value = \
                iadt.get_value_range_of_dtype(dtype)

            def _isclose(a, b):
                atol = 1e-4 if dtype == "float16" else 1e-8
                return np.isclose(a, b, atol=atol, rtol=0)

            isize = np.dtype(dtype).itemsize
            values = [0.01, 1.0, 10.0, 100.0, 500 ** (isize - 1),
                      1000 ** (isize - 1)]
            values = values + [(-1) * value for value in values]
            values = values + [min_value, max_value]
            for value in values:
                with self.subTest(dtype=dtype, value=value):
                    image = np.zeros((21, 21), dtype=dtype)
                    image[:, 7:13] = value

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="3933" endline="3962" pcid="3693">
                    values = [
                        1, 5, 10, 100, int(center_value), int(0.1 * max_value),
                        int(0.2 * max_value), int(0.5 * max_value),
                        max_value - 100, max_value]

                for value in values:
                    image = np.zeros((3, 3), dtype=dtype)
                    image[1, 1] = value
                    image_aug = aug.augment_image(image)
                    assert image_aug.dtype.name == dtype
                    assert image_aug.shape == (2, 3)
                    assert np.all(image_aug[~mask] == 0)
                    assert np.all(image_aug[mask] == value)

    def test_other_dtypes_float(self):
        aug = iaa.Crop(px=(1, 0, 0, 0), keep_size=False)
        mask = np.zeros((2, 3), dtype=bool)
        mask[0, 1] = True

        dtypes = ["float16", "float32", "float64", "float128"]

        for dtype in dtypes:
            with self.subTest(dtype=dtype):
                min_value, center_value, max_value = \
                    iadt.get_value_range_of_dtype(dtype)

                def _isclose(a, b):
                    atol = 1e-4 if dtype == np.float16 else 1e-8
                    return np.isclose(a, b, atol=atol, rtol=0)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="2825" endline="2855" pcid="3630">
                    image = np.zeros((3, 3), dtype=dtype)
                    image[1, 1] = value
                    image_aug = aug.augment_image(image)
                    assert image_aug.dtype.name == dtype
                    assert image_aug.shape == (4, 3)
                    assert np.all(image_aug[~mask] == 0)
                    assert np.all(image_aug[mask] == value)

    def test_pad_other_dtypes_float_by_int_without_keep_size(self):
        aug = iaa.Pad(px=(1, 0, 0, 0), keep_size=False)

        mask = np.zeros((4, 3), dtype=bool)
        mask[2, 1] = True

        dtypes = ["float16", "float32", "float64", "float128"]

        for dtype in dtypes:
            with self.subTest(dtype=dtype):
                min_value, center_value, max_value = \
                    iadt.get_value_range_of_dtype(dtype)

                def _isclose(a, b):
                    atol = 1e-4 if dtype == np.float16 else 1e-8
                    return np.isclose(a, b, atol=atol, rtol=0)

                isize = np.dtype(dtype).itemsize
                values = [0.01, 1.0, 10.0, 100.0, 500 ** (isize - 1),
                          1000 ** (isize - 1)]
                values = values + [(-1) * value for value in values]
                values = values + [min_value, max_value]
                for value in values:
</source>
</class>

<class classid="70" nclones="2" nlines="12" similarity="75">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="2713" endline="2730" pcid="1845">
                                           np.float128(value)))

    def test_rotate_skimage_order_not_0_bool(self):
        # skimage, order!=0 and rotate=180
        for order in [1, 3, 4, 5]:
            aug = iaa.Affine(rotate=180, order=order, mode="constant",
                             backend="skimage")
            aug_flip = iaa.Sequential([iaa.Flipud(1.0), iaa.Fliplr(1.0)])

            image = np.zeros((17, 17), dtype=bool)
            image[2:15, 5:13] = True

            image_aug = aug.augment_image(image)
            image_exp = aug_flip.augment_image(image)

            assert image_aug.dtype.name == image.dtype.name
            assert (
                np.sum(image_aug == image_exp)/image.size
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="2891" endline="2906" pcid="1855">

                    assert image_aug.dtype.name == dtype
                    assert np.all(_isclose(image_aug[~self.translate_mask], 0))
                    assert np.all(_isclose(image_aug[self.translate_mask],
                                           np.float128(value)))

    def test_rotate_cv2_order_1_and_3_bool(self):
        # cv2, order=1 and rotate=180
        for order in [1, 3]:
            aug = iaa.Affine(rotate=180, order=order, mode="constant",
                             backend="cv2")
            aug_flip = iaa.Sequential([iaa.Flipud(1.0), iaa.Fliplr(1.0)])

            image = np.zeros((17, 17), dtype=bool)
            image[2:15, 5:13] = True

</source>
</class>

<class classid="71" nclones="2" nlines="11" similarity="100">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="3049" endline="3065" pcid="1864">
        aug = iaa.ScaleX(1.5)
        assert isinstance(aug, iaa.Affine)
        assert np.isclose(aug.scale[0].value, 1.5)
        assert aug.order.value == 1
        assert aug.cval.value == 0
        assert aug.mode.value == "constant"
        assert aug.fit_output is False

    def test_integrationtest(self):
        image = np.zeros((10, 10), dtype=np.uint8)
        image[5, 5] = 255
        aug = iaa.ScaleX(4.0, order=0)

        image_aug = aug(image=image)

        xx = np.nonzero(np.max(image_aug, axis=0) > 200)[0]
        yy = np.nonzero(np.max(image_aug, axis=1) > 200)[0]
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="3079" endline="3095" pcid="1867">
        aug = iaa.ScaleY(1.5)
        assert isinstance(aug, iaa.Affine)
        assert np.isclose(aug.scale[1].value, 1.5)
        assert aug.order.value == 1
        assert aug.cval.value == 0
        assert aug.mode.value == "constant"
        assert aug.fit_output is False

    def test_integrationtest(self):
        image = np.zeros((10, 10), dtype=np.uint8)
        image[5, 5] = 255
        aug = iaa.ScaleY(4.0, order=0)

        image_aug = aug(image=image)

        xx = np.nonzero(np.max(image_aug, axis=0) > 200)[0]
        yy = np.nonzero(np.max(image_aug, axis=1) > 200)[0]
</source>
</class>

<class classid="72" nclones="2" nlines="30" similarity="93">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="3233" endline="3267" pcid="1885">
        aug = iaa.ShearX(40)
        assert isinstance(aug, iaa.Affine)
        assert aug.shear[0].value == 40
        assert aug.order.value == 1
        assert aug.cval.value == 0
        assert aug.mode.value == "constant"
        assert aug.fit_output is False

    def test_integrationtest(self):
        def _find_coords(arr):
            xx = np.nonzero(np.max(arr, axis=0) > 200)[0]
            yy = np.nonzero(np.max(arr, axis=1) > 200)[0]
            x1 = xx[0]
            x2 = xx[-1]
            y1 = yy[0]
            y2 = yy[-1]
            return x1+(x2-x1)/2, y1+(y2-y1)/2

        image = np.zeros((50, 50, 4), dtype=np.uint8)
        image[10:10+1, 20:20+1, 0] = 255
        image[10:10+1, 30:30+1, 1] = 255
        image[40:40+1, 30:30+1, 2] = 255
        image[40:40+1, 20:20+1, 3] = 255
        aug = iaa.ShearX(30, order=0)

        image_aug = aug(image=image)

        x1, y1 = _find_coords(image_aug[..., 0])
        x2, y2 = _find_coords(image_aug[..., 1])
        x3, y3 = _find_coords(image_aug[..., 2])
        x4, y4 = _find_coords(image_aug[..., 3])
        assert x1 > 20
        assert y1 > 10
        assert y2 > 10
        assert np.isclose(y1, y2)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="3281" endline="3315" pcid="1889">
        aug = iaa.ShearY(40)
        assert isinstance(aug, iaa.Affine)
        assert aug.shear[1].value == 40
        assert aug.order.value == 1
        assert aug.cval.value == 0
        assert aug.mode.value == "constant"
        assert aug.fit_output is False

    def test_integrationtest(self):
        def _find_coords(arr):
            xx = np.nonzero(np.max(arr, axis=0) > 200)[0]
            yy = np.nonzero(np.max(arr, axis=1) > 200)[0]
            x1 = xx[0]
            x2 = xx[-1]
            y1 = yy[0]
            y2 = yy[-1]
            return x1+(x2-x1)/2, y1+(y2-y1)/2

        image = np.zeros((50, 50, 4), dtype=np.uint8)
        image[20:20+1, 10:10+1, 0] = 255
        image[20:20+1, 40:40+1, 1] = 255
        image[30:30+1, 40:40+1, 2] = 255
        image[30:30+1, 10:10+1, 3] = 255
        aug = iaa.ShearY(30, order=0)

        image_aug = aug(image=image)

        x1, y1 = _find_coords(image_aug[..., 0])
        x2, y2 = _find_coords(image_aug[..., 1])
        x3, y3 = _find_coords(image_aug[..., 2])
        x4, y4 = _find_coords(image_aug[..., 3])
        assert y1 < 20
        assert x1 > 10
        assert x4 > 10
        assert np.isclose(x1, x4)
</source>
</class>

<class classid="73" nclones="2" nlines="12" similarity="83">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="4504" endline="4520" pcid="1924">
        except Exception as exc:
            assert "Expected " in str(exc)
            got_exception = True
        assert got_exception

    # -----
    # scale
    # -----
    def test_scale_is_small_image(self):
        # basic test
        aug = iaa.PiecewiseAffine(scale=0.01, nb_rows=12, nb_cols=4)

        observed = aug.augment_image(self.image)

        assert (
            100.0
            < np.average(observed[self.mask])
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="4521" endline="4537" pcid="1925">
            < np.average(self.image[self.mask])
        )
        assert (
            100.0-75.0
            > np.average(observed[~self.mask])
            > np.average(self.image[~self.mask])
        )

    def test_scale_is_small_image_absolute_scale(self):
        aug = iaa.PiecewiseAffine(scale=1, nb_rows=12, nb_cols=4,
                                  absolute_scale=True)

        observed = aug.augment_image(self.image)

        assert (
            100.0
            < np.average(observed[self.mask])
</source>
</class>

<class classid="74" nclones="2" nlines="12" similarity="100">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="4629" endline="4642" pcid="1934">
    @classmethod
    def _test_scale_is_zero_cbaoi(cls, cbaoi, augf_name):
        aug = iaa.PiecewiseAffine(scale=0, nb_rows=10, nb_cols=10)

        observed = getattr(aug, augf_name)(cbaoi)

        assert_cbaois_equal(observed, cbaoi)

    def test_scale_is_zero_polygons(self):
        exterior = [(10, 10),
                    (70, 10), (70, 20), (70, 30), (70, 40),
                    (70, 50), (70, 60), (70, 70), (70, 80),
                    (70, 90),
                    (10, 90),
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="4643" endline="4656" pcid="1935">
                    (10, 80), (10, 70), (10, 60), (10, 50),
                    (10, 40), (10, 30), (10, 20), (10, 10)]
        poly = ia.Polygon(exterior)
        psoi = ia.PolygonsOnImage([poly, poly.shift(x=1, y=1)],
                                  shape=(100, 80))

        self._test_scale_is_zero_cbaoi(psoi, "augment_polygons")

    def test_scale_is_zero_line_strings(self):
        coords = [(10, 10),
                  (70, 10), (70, 20), (70, 30), (70, 40),
                  (70, 50), (70, 60), (70, 70), (70, 80),
                  (70, 90),
                  (10, 90),
</source>
</class>

<class classid="75" nclones="3" nlines="14" similarity="71">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="4691" endline="4709" pcid="1939">
        observed1 = aug1.augment_image(self.image)
        observed2 = aug2.augment_image(self.image)

        assert (
            np.average(observed1[~self.mask])
            < np.average(observed2[~self.mask])
        )

    def test_scale_stronger_values_should_increase_changes_heatmaps(self):
        # stronger scale should lead to stronger changes, heatmaps
        aug1 = iaa.PiecewiseAffine(scale=0.01, nb_rows=12, nb_cols=4)
        aug2 = iaa.PiecewiseAffine(scale=0.10, nb_rows=12, nb_cols=4)
        
        observed1 = aug1.augment_heatmaps([self.heatmaps])[0]
        observed2 = aug2.augment_heatmaps([self.heatmaps])[0]
        
        observed1_arr = observed1.get_arr()
        observed2_arr = observed2.get_arr()
        assert observed1.shape == self.heatmaps.shape
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="4710" endline="4729" pcid="1940">
        assert observed2.shape == self.heatmaps.shape
        _assert_same_min_max(observed1, self.heatmaps)
        _assert_same_min_max(observed2, self.heatmaps)
        assert (
            np.average(observed1_arr[~self.mask])
            < np.average(observed2_arr[~self.mask])
        )

    def test_scale_stronger_values_should_increase_changes_heatmaps_abs(self):
        aug1 = iaa.PiecewiseAffine(scale=1, nb_rows=12, nb_cols=4,
                                   absolute_scale=True)
        aug2 = iaa.PiecewiseAffine(scale=10, nb_rows=12, nb_cols=4,
                                   absolute_scale=True)

        observed1 = aug1.augment_heatmaps([self.heatmaps])[0]
        observed2 = aug2.augment_heatmaps([self.heatmaps])[0]

        observed1_arr = observed1.get_arr()
        observed2_arr = observed2.get_arr()
        assert observed1.shape == self.heatmaps.shape
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="4730" endline="4746" pcid="1941">
        assert observed2.shape == self.heatmaps.shape
        _assert_same_min_max(observed1, self.heatmaps)
        _assert_same_min_max(observed2, self.heatmaps)
        assert (
            np.average(observed1_arr[~self.mask])
            < np.average(observed2_arr[~self.mask])
        )

    def test_scale_stronger_values_should_increase_changes_segmaps(self):
        # stronger scale should lead to stronger changes, segmaps
        aug1 = iaa.PiecewiseAffine(scale=0.01, nb_rows=12, nb_cols=4)
        aug2 = iaa.PiecewiseAffine(scale=0.10, nb_rows=12, nb_cols=4)

        observed1 = aug1.augment_segmentation_maps([self.segmaps])[0]
        observed2 = aug2.augment_segmentation_maps([self.segmaps])[0]

        observed1_arr = observed1.get_arr()
</source>
</class>

<class classid="76" nclones="2" nlines="11" similarity="72">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="4747" endline="4761" pcid="1942">
        observed2_arr = observed2.get_arr()
        assert observed1.shape == self.segmaps.shape
        assert observed2.shape == self.segmaps.shape
        assert (
            np.average(observed1_arr[~self.mask] == 0)
            > np.average(observed2_arr[~self.mask] == 0)
        )

    def test_scale_alignment_between_images_and_heatmaps(self):
        # strong scale, measure alignment between images and heatmaps
        aug = iaa.PiecewiseAffine(scale=0.10, nb_rows=12, nb_cols=4)
        aug_det = aug.to_deterministic()

        img_aug = aug_det.augment_image(self.image)
        hm_aug = aug_det.augment_heatmaps([self.heatmaps])[0]
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="4762" endline="4775" pcid="1943">

        img_aug_mask = img_aug > 255*0.1
        hm_aug_mask = hm_aug.arr_0to1 > 0.1
        same = np.sum(img_aug_mask == hm_aug_mask[:, :, 0])
        assert hm_aug.shape == (60, 80, 3)
        _assert_same_min_max(hm_aug, self.heatmaps)
        assert (same / img_aug_mask.size) >= 0.98

    def test_scale_alignment_between_images_and_segmaps(self):
        # strong scale, measure alignment between images and segmaps
        aug = iaa.PiecewiseAffine(scale=0.10, nb_rows=12, nb_cols=4)
        aug_det = aug.to_deterministic()

        img_aug = aug_det.augment_image(self.image)
</source>
</class>

<class classid="77" nclones="2" nlines="18" similarity="88">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="4776" endline="4802" pcid="1944">
        segmap_aug = aug_det.augment_segmentation_maps([self.segmaps])[0]

        img_aug_mask = (img_aug > 255*0.1)
        segmap_aug_mask = (segmap_aug.arr == 1)
        same = np.sum(img_aug_mask == segmap_aug_mask[:, :, 0])
        assert segmap_aug.shape == (60, 80, 3)
        assert (same / img_aug_mask.size) >= 0.9

    def test_scale_alignment_between_images_and_smaller_heatmaps(self):
        # strong scale, measure alignment between images and heatmaps
        # heatmaps here smaller than image
        aug = iaa.PiecewiseAffine(scale=0.10, nb_rows=12, nb_cols=4)
        aug_det = aug.to_deterministic()

        heatmaps_small = ia.HeatmapsOnImage(
            (
                ia.imresize_single_image(
                    self.image, (30, 40+10), interpolation="cubic"
                ) / 255.0
            ).astype(np.float32),
            shape=(60, 80, 3)
        )

        img_aug = aug_det.augment_image(self.image)
        hm_aug = aug_det.augment_heatmaps([heatmaps_small])[0]

        img_aug_mask = img_aug > 255*0.1
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="4803" endline="4829" pcid="1945">
        hm_aug_mask = ia.imresize_single_image(
            hm_aug.arr_0to1, (60, 80), interpolation="cubic"
        ) > 0.1
        same = np.sum(img_aug_mask == hm_aug_mask[:, :, 0])
        assert hm_aug.shape == (60, 80, 3)
        assert hm_aug.arr_0to1.shape == (30, 40+10, 1)
        assert (same / img_aug_mask.size) >= 0.9  # seems to be 0.948 actually

    def test_scale_alignment_between_images_and_smaller_heatmaps_abs(self):
        # image is 60x80, so a scale of 8 is about 0.1*max(60,80)
        aug = iaa.PiecewiseAffine(scale=8, nb_rows=12, nb_cols=4,
                                  absolute_scale=True)
        aug_det = aug.to_deterministic()

        heatmaps_small = ia.HeatmapsOnImage(
            (
                ia.imresize_single_image(
                    self.image, (30, 40+10), interpolation="cubic"
                ) / 255.0
            ).astype(np.float32),
            shape=(60, 80, 3)
        )

        img_aug = aug_det.augment_image(self.image)
        hm_aug = aug_det.augment_heatmaps([heatmaps_small])[0]

        img_aug_mask = img_aug > 255*0.1
</source>
</class>

<class classid="78" nclones="2" nlines="25" similarity="92">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="5527" endline="5558" pcid="1994">
        ])
        if observed.shape != expected.shape:
            observed = ia.imresize_single_image(
                observed, expected.shape[0:2], interpolation="cubic")
        # differences seem to mainly appear around the border of the inner
        # rectangle, possibly due to interpolation
        assert np.average(
            np.abs(observed.astype(np.int32) - expected.astype(np.int32))
        ) < 30.0

    def test_image_heatmaps_alignment_without_keep_size(self):
        aug = iaa.PerspectiveTransform(scale=0.2, keep_size=False)
        aug.jitter = iap.Deterministic(0.2)
        hm = HeatmapsOnImage(
            self.image.astype(np.float32)/255.0,
            shape=(30, 30)
        )

        observed = aug.augment_image(self.image)
        hm_aug = aug.augment_heatmaps([hm])[0]

        y1 = int(30*0.2)
        y2 = int(30*0.8)
        x1 = int(30*0.2)
        x2 = int(30*0.8)

        expected = (y2 - y1, x2 - x1)
        assert all([
            abs(s1-s2) <= 1
            for s1, s2
            in zip(hm_aug.shape, expected)
        ])
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="5559" endline="5590" pcid="1995">
        assert all([
            abs(s1-s2) <= 1
            for s1, s2
            in zip(hm_aug.arr_0to1.shape, expected + (1,))
        ])
        img_aug_mask = observed > 255*0.1
        hm_aug_mask = hm_aug.arr_0to1 > 0.1
        same = np.sum(img_aug_mask == hm_aug_mask[:, :, 0])
        assert (same / img_aug_mask.size) >= 0.99

    def test_image_segmaps_alignment_without_keep_size(self):
        aug = iaa.PerspectiveTransform(scale=0.2, keep_size=False)
        aug.jitter = iap.Deterministic(0.2)
        segmaps = SegmentationMapsOnImage(
            (self.image > 100).astype(np.int32),
            shape=(30, 30)
        )

        observed = aug.augment_image(self.image)
        segmaps_aug = aug.augment_segmentation_maps([segmaps])[0]

        y1 = int(30*0.2)
        y2 = int(30*0.8)
        x1 = int(30*0.2)
        x2 = int(30*0.8)

        expected = (y2 - y1, x2 - x1)
        assert all([
            abs(s1-s2) <= 1
            for s1, s2
            in zip(segmaps_aug.shape, expected)
        ])
</source>
</class>

<class classid="79" nclones="2" nlines="15" similarity="80">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="5713" endline="5733" pcid="2000">
            expected,
            self.image.shape[0:2],
            interpolation="cubic")
        assert observed.shape == self.image.shape
        # differences seem to mainly appear around the border of the inner
        # rectangle, possibly due to interpolation
        assert np.average(
            np.abs(observed.astype(np.int32) - expected.astype(np.int32))
        ) < 30.0

    def test_heatmaps_with_keep_size(self):
        # with keep_size, heatmaps
        aug = iaa.PerspectiveTransform(scale=0.2, keep_size=True)
        aug.jitter = iap.Deterministic(0.2)

        observed = aug.augment_heatmaps([self.heatmaps])[0]

        heatmaps_arr = self.heatmaps.get_arr()
        expected = heatmaps_arr[int(30*0.2):int(30*0.8),
                                int(30*0.2):int(30*0.8)]
        expected = ia.imresize_single_image(
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="5734" endline="5751" pcid="2001">
            (expected*255).astype(np.uint8),
            self.image.shape[0:2],
            interpolation="cubic")
        expected = (expected / 255.0).astype(np.float32)
        assert observed.shape == self.heatmaps.shape
        _assert_same_min_max(observed, self.heatmaps)
        # differences seem to mainly appear around the border of the inner
        # rectangle, possibly due to interpolation
        assert np.average(np.abs(observed.get_arr() - expected)) < 30.0

    def test_segmaps_with_keep_size(self):
        # with keep_size, segmaps
        aug = iaa.PerspectiveTransform(scale=0.2, keep_size=True)
        aug.jitter = iap.Deterministic(0.2)

        observed = aug.augment_segmentation_maps([self.segmaps])[0]

        segmaps_arr = self.segmaps.get_arr()
</source>
</class>

<class classid="80" nclones="3" nlines="13" similarity="73">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="5781" endline="5801" pcid="2003">
                # inner rectangle, possibly due to interpolation
                assert np.average(
                    np.abs(
                        observed_i.astype(np.int32) - expected.astype(np.int32)
                    )
                ) < 30.0

    # --------
    # keypoints
    # --------
    def test_keypoints_without_keep_size(self):
        # keypoint augmentation without keep_size
        # TODO deviations of around 0.4-0.7 in this and the next test (between
        #      expected and observed coordinates) -- why?
        kps = [ia.Keypoint(x=10, y=10), ia.Keypoint(x=14, y=11)]
        kpsoi = ia.KeypointsOnImage(kps, shape=self.image.shape)
        aug = iaa.PerspectiveTransform(scale=0.2, keep_size=False)
        aug.jitter = iap.Deterministic(0.2)

        observed = aug.augment_keypoints([kpsoi])

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="6049" endline="6069" pcid="2020">
        self._test_image_cba_alignment(ia.LineString, ia.LineStringsOnImage,
                                       "augment_line_strings")

    def test_empty_line_strings(self):
        lsoi = ia.LineStringsOnImage([], shape=(20, 10, 3))
        self._test_empty_cba(lsoi, "augment_line_strings")

    # --------
    # bounding boxes
    # --------
    def test_bounding_boxes_without_keep_size(self):
        # BB augmentation without keep_size
        # TODO deviations of around 0.4-0.7 in this and the next test (between
        #      expected and observed coordinates) -- why?
        bbs = [ia.BoundingBox(x1=0, y1=10, x2=20, y2=20)]
        bbsoi = ia.BoundingBoxesOnImage(bbs, shape=self.image.shape)
        aug = iaa.PerspectiveTransform(scale=0.2, keep_size=False)
        aug.jitter = iap.Deterministic(0.2)

        observed = aug.augment_bounding_boxes([bbsoi])

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="5802" endline="5822" pcid="2004">
        kps_expected = [
            ia.Keypoint(x=10-0.2*30, y=10-0.2*30),
            ia.Keypoint(x=14-0.2*30, y=11-0.2*30)
        ]
        gen = zip(observed[0].keypoints, kps_expected)
        # TODO deviations of around 0.5 here from expected values, why?
        for kp_observed, kp_expected in gen:
            assert kp_observed.coords_almost_equals(
                kp_expected, max_distance=1.5)

    def test_keypoints_with_keep_size(self):
        # keypoint augmentation with keep_size
        kps = [ia.Keypoint(x=10, y=10), ia.Keypoint(x=14, y=11)]
        kpsoi = ia.KeypointsOnImage(kps, shape=self.image.shape)
        aug = iaa.PerspectiveTransform(scale=0.2, keep_size=True)
        aug.jitter = iap.Deterministic(0.2)

        observed = aug.augment_keypoints([kpsoi])

        kps_expected = [
            ia.Keypoint(x=((10-0.2*30)/(30*0.6))*30,
</source>
</class>

<class classid="81" nclones="2" nlines="20" similarity="76">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="5866" endline="5890" pcid="2007">
        aug = iaa.PerspectiveTransform(scale=0.2, keep_size=True)

        observed = aug.augment_keypoints(kpsoi)

        assert_cbaois_equal(observed, kpsoi)

    # --------
    # abstract test methods for polygons and line strings
    # --------
    @classmethod
    def _test_cbaois_without_keep_size(cls, cba_class, cbaoi_class, augf_name):
        points = np.float32([
            [10, 10],
            [25, 10],
            [25, 25],
            [10, 25]
        ])
        cbaoi = cbaoi_class([cba_class(points)], shape=(30, 30, 3))
        aug = iaa.PerspectiveTransform(scale=0.2, keep_size=False)
        aug.jitter = iap.Deterministic(0.2)

        observed = getattr(aug, augf_name)(cbaoi)

        assert observed.shape == (30 - 12, 30 - 12, 3)
        assert len(observed.items) == 1
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="5892" endline="5921" pcid="2008">
            assert observed.items[0].is_valid

        points_expected = np.copy(points)
        points_expected[:, 0] -= 0.2 * 30
        points_expected[:, 1] -= 0.2 * 30
        # TODO deviations of around 0.5 here from expected values, why?
        assert observed.items[0].coords_almost_equals(
            points_expected, max_distance=1.5)

    @classmethod
    def _test_cbaois_with_keep_size(cls, cba_class, cbaoi_class, augf_name):
        # polygon augmentation with keep_size
        points = np.float32([
            [10, 10],
            [25, 10],
            [25, 25],
            [10, 25]
        ])
        cbaoi = cbaoi_class([cba_class(points)], shape=(30, 30, 3))
        aug = iaa.PerspectiveTransform(scale=0.2, keep_size=True)
        aug.jitter = iap.Deterministic(0.2)

        observed = getattr(aug, augf_name)(cbaoi)

        assert observed.shape == (30, 30, 3)
        assert len(observed.items) == 1
        if hasattr(observed.items[0], "is_valid"):
            assert observed.items[0].is_valid

        points_expected = np.copy(points)
</source>
</class>

<class classid="82" nclones="2" nlines="34" similarity="77">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="6093" endline="6131" pcid="2022">
                x2=((20-0.2*30)/(30*0.6))*30,
                y2=((20-0.2*30)/(30*0.6))*30
            )
        ]
        gen = zip(observed[0].bounding_boxes, bbs_expected)
        # TODO deviations of around 0.5 here from expected values, why?
        for bb_observed, bb_expected in gen:
            assert bb_observed.coords_almost_equals(
                bb_expected, max_distance=1.5)

    def test_image_bounding_box_alignment(self):
        img = np.zeros((100, 100), dtype=np.uint8)
        img[35:35+1, 35:65+1] = 255
        img[65:65+1, 35:65+1] = 255
        img[35:65+1, 35:35+1] = 255
        img[35:65+1, 65:65+1] = 255
        bbs = [
            ia.BoundingBox(y1=35.5, x1=35.5, y2=65.5, x2=65.5),
        ]
        bbsoi = ia.BoundingBoxesOnImage(bbs, shape=img.shape)
        aug = iaa.PerspectiveTransform(scale=(0.05, 0.2), keep_size=True)

        for _ in sm.xrange(10):
            imgs_aug, bbsois_aug = aug(
                images=[img, img, img, img],
                bounding_boxes=[bbsoi, bbsoi, bbsoi, bbsoi])

            nb_skipped = 0
            for img_aug, bbsoi_aug in zip(imgs_aug, bbsois_aug):
                assert bbsoi_aug.shape == img_aug.shape
                for bb_aug in bbsoi_aug.bounding_boxes:
                    if bb_aug.is_fully_within_image(img_aug):
                        # top, bottom, left, right
                        x1 = bb_aug.x1_int
                        x2 = bb_aug.x2_int
                        y1 = bb_aug.y1_int
                        y2 = bb_aug.y2_int
                        top_row = img_aug[y1-1:y1+1, x1-1:x2+1]
                        btm_row = img_aug[y2-1:y2+1, x1-1:x2+1]
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="7433" endline="7471" pcid="2113">

            observed = aug.augment_bounding_boxes([bbsoi])[0]

            d = bbsoi.to_xyxy_array() - observed.to_xyxy_array()
            d = d.reshape((2*2, 2))
            d[:, 0] = d[:, 0] ** 2
            d[:, 1] = d[:, 1] ** 2
            d = np.sum(d, axis=1)
            d = np.average(d, axis=0)
            assert d < 0.5

    def test_image_bounding_box_alignment(self):
        # test alignment between between images and bounding boxes
        image = np.zeros((100, 100), dtype=np.uint8)
        image[35:35+1, 35:65+1] = 255
        image[65:65+1, 35:65+1] = 255
        image[35:65+1, 35:35+1] = 255
        image[35:65+1, 65:65+1] = 255
        bbs = [
            ia.BoundingBox(x1=35.5, y1=35.5, x2=65.5, y2=65.5)
        ]
        bbsoi = ia.BoundingBoxesOnImage(bbs, shape=image.shape)
        aug = iaa.ElasticTransformation(alpha=70, sigma=5)

        images_aug, bbsois_aug = aug(images=[image, image],
                                     bounding_boxes=[bbsoi, bbsoi])

        count_bad = 0
        for image_aug, bbsoi_aug in zip(images_aug, bbsois_aug):
            assert bbsoi_aug.shape == (100, 100)
            assert len(bbsoi_aug.bounding_boxes) == 1
            for bb_aug in bbsoi_aug.bounding_boxes:
                if bb_aug.is_fully_within_image(image_aug):
                    # top, bottom, left, right
                    x1 = bb_aug.x1_int
                    x2 = bb_aug.x2_int
                    y1 = bb_aug.y1_int
                    y2 = bb_aug.y2_int
                    top_row = image_aug[y1-2:y1+2, x1-2:x2+2]
</source>
</class>

<class classid="83" nclones="2" nlines="25" similarity="76">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="6373" endline="6400" pcid="2034">
        assert 0 <= y0 <= 3
        assert 0 <= x0 <= 3
        assert 0 <= y1 <= 3
        assert image_aug.shape[1]-3 <= x1 <= image_aug.shape[1]
        assert image_aug.shape[1]-3 <= y2 <= image_aug.shape[1]
        assert image_aug.shape[1]-3 <= x2 <= image_aug.shape[1]

        # no corner pixels now in the center
        assert np.max(image_aug[8:h-8, 8:w-8, :]) == 0

    def test_fit_output_with_random_jitter(self):
        aug = iaa.PerspectiveTransform(scale=0.1, fit_output=True,
                                       keep_size=False)

        image = np.zeros((50, 50, 4), dtype=np.uint8)
        image[0:5, 0:5, 0] = 255
        image[0:5, 50-5:, 1] = 255
        image[50-5:, 50-5:, 2] = 255
        image[50-5:, 0:5, 3] = 255

        for _ in sm.xrange(10):
            image_aug = aug(image=image)

            h, w = image_aug.shape[0:2]
            arr_nochan = np.max(image_aug, axis=2)
            y_idx = np.where(np.max(arr_nochan, axis=1))[0]
            x_idx = np.where(np.max(arr_nochan, axis=0))[0]
            y_min = np.min(y_idx)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="6401" endline="6432" pcid="2035">
            y_max = np.max(y_idx)
            x_min = np.min(x_idx)
            x_max = np.max(x_idx)

            tol = 0
            assert 0 <= y_min <= 5+tol
            assert 0 <= x_min <= 5+tol
            assert h-5-tol <= y_max <= h-1
            assert w-5-tol <= x_max <= w-1

    def test_fit_output_with_random_jitter__segmentation_maps(self):
        aug = iaa.PerspectiveTransform(scale=0.1, fit_output=True,
                                       keep_size=False)

        arr = np.zeros((50, 50, 4), dtype=np.uint8)
        arr[0:5, 0:5, 0] = 1
        arr[0:5, 50-5:, 1] = 1
        arr[50-5:, 50-5:, 2] = 1
        arr[50-5:, 0:5, 3] = 1
        segmap = ia.SegmentationMapsOnImage(arr, shape=(50, 50, 3))

        image = np.zeros((49, 49, 3), dtype=np.uint8)
        image = iaa.pad(image, top=1, right=1, bottom=1, left=1, cval=128)

        for _ in sm.xrange(10):
            image_aug, segmap_aug = aug(image=image, segmentation_maps=segmap)

            h, w = segmap_aug.arr.shape[0:2]
            arr_nochan = np.max(segmap_aug.arr, axis=2)
            y_idx = np.where(np.max(arr_nochan, axis=1))[0]
            x_idx = np.where(np.max(arr_nochan, axis=0))[0]
            y_min = np.min(y_idx)
</source>
</class>

<class classid="84" nclones="2" nlines="12" similarity="91">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="6873" endline="6887" pcid="2076">
        aug = iaa.ElasticTransformation(alpha=5, sigma=0.5)
        for nb_channels in [1, 2, 4, 5, 7, 10, 11]:
            img_c = np.tile(self.image[..., np.newaxis], (1, 1, nb_channels))
            assert img_c.shape == (250, 250, nb_channels)

            observed = aug.augment_image(img_c)

            assert observed.shape == (250, 250, nb_channels)
            for c in sm.xrange(1, nb_channels):
                assert np.array_equal(observed[..., c], observed[..., 0])

    def test_heatmaps(self):
        # test basic funtionality, heatmaps
        aug = iaa.ElasticTransformation(alpha=0.5, sigma=0.25)
        observed = aug.augment_heatmaps([self.heatmaps])[0]
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="6888" endline="6904" pcid="2077">

        mask = self.mask
        assert observed.shape == self.heatmaps.shape
        _assert_same_min_max(observed, self.heatmaps)
        assert (
            np.sum(observed.get_arr()[mask])
            < np.sum(self.heatmaps.get_arr()[mask]))
        assert (
            np.sum(observed.get_arr()[~mask])
            > np.sum(self.heatmaps.get_arr()[~mask]))

    def test_segmaps(self):
        # test basic funtionality, segmaps
        # alpha=1.5 instead of 0.5 as above here, because otherwise nothing
        # is moved
        aug = iaa.ElasticTransformation(alpha=1.5, sigma=0.25)

</source>
</class>

<class classid="85" nclones="2" nlines="15" similarity="87">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="6921" endline="6940" pcid="2079">
        observed1 = aug1.augment_image(self.image)
        observed2 = aug2.augment_image(self.image)

        mask = self.mask
        # assume that the inner area has become more black-ish when using high
        # alphas (more white pixels were moved out of the inner area)
        assert np.sum(observed1[mask]) > np.sum(observed2[mask])
        # assume that the outer area has become more white-ish when using high
        # alphas (more black pixels were moved into the inner area)
        assert np.sum(observed1[~mask]) < np.sum(observed2[~mask])

    def test_heatmaps_weak_vs_strong_alpha(self):
        # test effects of increased alpha strength, heatmaps
        aug1 = iaa.ElasticTransformation(alpha=0.1, sigma=0.25)
        aug2 = iaa.ElasticTransformation(alpha=5.0, sigma=0.25)

        observed1 = aug1.augment_heatmaps([self.heatmaps])[0]
        observed2 = aug2.augment_heatmaps([self.heatmaps])[0]

        mask = self.mask
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="6941" endline="6958" pcid="2080">
        assert observed1.shape == self.heatmaps.shape
        assert observed2.shape == self.heatmaps.shape
        _assert_same_min_max(observed1, self.heatmaps)
        _assert_same_min_max(observed2, self.heatmaps)
        assert (
            np.sum(observed1.get_arr()[mask])
            > np.sum(observed2.get_arr()[mask]))
        assert (
            np.sum(observed1.get_arr()[~mask])
            < np.sum(observed2.get_arr()[~mask]))

    def test_segmaps_weak_vs_strong_alpha(self):
        # test effects of increased alpha strength, segmaps
        aug1 = iaa.ElasticTransformation(alpha=0.1, sigma=0.25)
        aug2 = iaa.ElasticTransformation(alpha=5.0, sigma=0.25)

        observed1 = aug1.augment_segmentation_maps([self.segmaps])[0]
        observed2 = aug2.augment_segmentation_maps([self.segmaps])[0]
</source>
</class>

<class classid="86" nclones="3" nlines="18" similarity="100">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="7099" endline="7120" pcid="2090">
        aug = iaa.ElasticTransformation(alpha=3.0, sigma=3.0, mode="constant",
                                        cval=255)

        observed = aug.augment_segmentation_maps([segmaps])[0]

        assert observed.shape == segmaps.shape
        assert np.sum(observed.get_arr() > 0) == 0

    # -----------
    # keypoints
    # -----------
    def test_keypoints_no_movement_if_alpha_below_threshold(self):
        # for small alpha, should not move if below threshold
        with _elastic_trans_temp_thresholds(alpha=1.0, sigma=0.0):
            kps = [
                ia.Keypoint(x=1, y=1), ia.Keypoint(x=15, y=25),
                ia.Keypoint(x=5, y=5), ia.Keypoint(x=7, y=4),
                ia.Keypoint(x=48, y=5), ia.Keypoint(x=21, y=37),
                ia.Keypoint(x=32, y=39), ia.Keypoint(x=6, y=8),
                ia.Keypoint(x=12, y=21), ia.Keypoint(x=3, y=45),
                ia.Keypoint(x=45, y=3), ia.Keypoint(x=7, y=48)]
            kpsoi = ia.KeypointsOnImage(kps, shape=(50, 50))
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="7143" endline="7165" pcid="2092">
            aug = iaa.ElasticTransformation(alpha=1.0, sigma=0.001)

            observed = aug.augment_keypoints([kpsoi])[0]

            d = kpsoi.to_xy_array() - observed.to_xy_array()
            d[:, 0] = d[:, 0] ** 2
            d[:, 1] = d[:, 1] ** 2
            d = np.sum(d, axis=1)
            d = np.average(d, axis=0)
            assert d < 1e-8

    def test_keypoints_small_movement_for_weak_alpha_if_threshold_zero(self):
        # for small alpha (at sigma 1.0), should barely move
        # if thresholds set to zero
        with _elastic_trans_temp_thresholds(alpha=0.0, sigma=0.0):
            kps = [
                ia.Keypoint(x=1, y=1), ia.Keypoint(x=15, y=25),
                ia.Keypoint(x=5, y=5), ia.Keypoint(x=7, y=4),
                ia.Keypoint(x=48, y=5), ia.Keypoint(x=21, y=37),
                ia.Keypoint(x=32, y=39), ia.Keypoint(x=6, y=8),
                ia.Keypoint(x=12, y=21), ia.Keypoint(x=3, y=45),
                ia.Keypoint(x=45, y=3), ia.Keypoint(x=7, y=48)]
            kpsoi = ia.KeypointsOnImage(kps, shape=(50, 50))
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="7121" endline="7142" pcid="2091">
            aug = iaa.ElasticTransformation(alpha=0.001, sigma=1.0)
    
            observed = aug.augment_keypoints([kpsoi])[0]
    
            d = kpsoi.to_xy_array() - observed.to_xy_array()
            d[:, 0] = d[:, 0] ** 2
            d[:, 1] = d[:, 1] ** 2
            d = np.sum(d, axis=1)
            d = np.average(d, axis=0)
            assert d < 1e-8

    def test_keypoints_no_movement_if_sigma_below_threshold(self):
        # for small sigma, should not move if below threshold
        with _elastic_trans_temp_thresholds(alpha=0.0, sigma=1.0):
            kps = [
                ia.Keypoint(x=1, y=1), ia.Keypoint(x=15, y=25),
                ia.Keypoint(x=5, y=5), ia.Keypoint(x=7, y=4),
                ia.Keypoint(x=48, y=5), ia.Keypoint(x=21, y=37),
                ia.Keypoint(x=32, y=39), ia.Keypoint(x=6, y=8),
                ia.Keypoint(x=12, y=21), ia.Keypoint(x=3, y=45),
                ia.Keypoint(x=45, y=3), ia.Keypoint(x=7, y=48)]
            kpsoi = ia.KeypointsOnImage(kps, shape=(50, 50))
</source>
</class>

<class classid="87" nclones="3" nlines="12" similarity="84">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="7210" endline="7225" pcid="2095">
        kpsoi = ia.KeypointsOnImage([], shape=(10, 10, 3))

        kpsoi_aug = aug.augment_keypoints(kpsoi)

        assert len(kpsoi_aug.keypoints) == 0
        assert kpsoi_aug.shape == (10, 10, 3)

    # -----------
    # abstract methods for polygons and line strings
    # -----------
    @classmethod
    def _test_cbaois_no_movement_if_alpha_below_threshold(
            cls, cba_class, cbaoi_class, augf_name):
        # for small alpha, should not move if below threshold
        with _elastic_trans_temp_thresholds(alpha=1.0, sigma=0.0):
            cba = cba_class([(10, 15), (40, 15), (40, 35), (10, 35)])
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="7227" endline="7242" pcid="2096">
            aug = iaa.ElasticTransformation(alpha=0.001, sigma=1.0)

            observed = getattr(aug, augf_name)(cbaoi)

            assert observed.shape == (50, 50)
            assert len(observed.items) == 1
            assert observed.items[0].coords_almost_equals(cba)
            if hasattr(observed.items[0], "is_valid"):
                assert observed.items[0].is_valid

    @classmethod
    def _test_cbaois_no_movement_if_sigma_below_threshold(
            cls, cba_class, cbaoi_class, augf_name):
        # for small sigma, should not move if below threshold
        with _elastic_trans_temp_thresholds(alpha=0.0, sigma=1.0):
            cba = cba_class([(10, 15), (40, 15), (40, 35), (10, 35)])
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="7244" endline="7261" pcid="2097">
            aug = iaa.ElasticTransformation(alpha=1.0, sigma=0.001)

            observed = getattr(aug, augf_name)(cbaoi)

            assert observed.shape == (50, 50)
            assert len(observed.items) == 1
            assert observed.items[0].coords_almost_equals(cba)
            if hasattr(observed.items[0], "is_valid"):
                assert observed.items[0].is_valid

    @classmethod
    def _test_cbaois_small_movement_for_weak_alpha_if_threshold_zero(
            cls, cba_class, cbaoi_class, augf_name):
        # for small alpha (at sigma 1.0), should barely move
        # if thresholds set to zero
        with _elastic_trans_temp_thresholds(alpha=0.0, sigma=0.0):
            cba = cba_class([(10, 15), (40, 15), (40, 35), (10, 35)])
            cbaoi = cbaoi_class([cba], shape=(50, 50))
</source>
</class>

<class classid="88" nclones="3" nlines="15" similarity="87">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="7371" endline="7390" pcid="2110">
    def test_image_line_string_alignment(self):
        self._test_image_cbaoi_alignment(
            ia.LineString, ia.LineStringsOnImage, "augment_line_strings")

    def test_empty_line_strings(self):
        cbaoi = ia.LineStringsOnImage([], shape=(10, 10, 3))
        self._test_empty_cbaois(cbaoi, "augment_line_strings")

    # -----------
    # bounding boxes
    # -----------
    def test_bounding_boxes_no_movement_if_alpha_below_threshold(self):
        # for small alpha, should not move if below threshold
        with _elastic_trans_temp_thresholds(alpha=1.0, sigma=0.0):
            bbs = [
                ia.BoundingBox(x1=10, y1=12, x2=20, y2=22),
                ia.BoundingBox(x1=20, y1=32, x2=40, y2=42)
            ]
            bbsoi = ia.BoundingBoxesOnImage(bbs, shape=(50, 50))
            aug = iaa.ElasticTransformation(alpha=0.001, sigma=1.0)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="7391" endline="7410" pcid="2111">

            observed = aug.augment_bounding_boxes([bbsoi])[0]

            d = bbsoi.to_xyxy_array() - observed.to_xyxy_array()
            d = d.reshape((2*2, 2))
            d[:, 0] = d[:, 0] ** 2
            d[:, 1] = d[:, 1] ** 2
            d = np.sum(d, axis=1)
            d = np.average(d, axis=0)
            assert d < 1e-8

    def test_bounding_boxes_no_movement_if_sigma_below_threshold(self):
        # for small sigma, should not move if below threshold
        with _elastic_trans_temp_thresholds(alpha=0.0, sigma=1.0):
            bbs = [
                ia.BoundingBox(x1=10, y1=12, x2=20, y2=22),
                ia.BoundingBox(x1=20, y1=32, x2=40, y2=42)
            ]
            bbsoi = ia.BoundingBoxesOnImage(bbs, shape=(50, 50))
            aug = iaa.ElasticTransformation(alpha=1.0, sigma=0.001)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="7411" endline="7432" pcid="2112">

            observed = aug.augment_bounding_boxes([bbsoi])[0]

            d = bbsoi.to_xyxy_array() - observed.to_xyxy_array()
            d = d.reshape((2*2, 2))
            d[:, 0] = d[:, 0] ** 2
            d[:, 1] = d[:, 1] ** 2
            d = np.sum(d, axis=1)
            d = np.average(d, axis=0)
            assert d < 1e-8

    def test_bounding_boxes_small_movement_for_weak_alpha_if_threshold_zero(
            self):
        # for small alpha (at sigma 1.0), should barely move
        # if thresholds set to zero
        with _elastic_trans_temp_thresholds(alpha=0.0, sigma=0.0):
            bbs = [
                ia.BoundingBox(x1=10, y1=12, x2=20, y2=22),
                ia.BoundingBox(x1=20, y1=32, x2=40, y2=42)
            ]
            bbsoi = ia.BoundingBoxesOnImage(bbs, shape=(50, 50))
            aug = iaa.ElasticTransformation(alpha=0.001, sigma=1.0)
</source>
</class>

<class classid="89" nclones="3" nlines="20" similarity="71">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="7504" endline="7531" pcid="2116">

        img_aug = aug_det.augment_image(img)
        hm_aug = aug_det.augment_heatmaps([hm])[0]

        img_aug_mask = img_aug > 255*0.1
        hm_aug_mask = hm_aug.arr_0to1 > 0.1
        same = np.sum(img_aug_mask == hm_aug_mask[:, :, 0])
        assert hm_aug.shape == (80, 80)
        assert hm_aug.arr_0to1.shape == (80, 80, 1)
        assert (same / img_aug_mask.size) >= 0.99

    def test_image_heatmaps_alignment_if_heatmaps_smaller_than_image(self):
        # test alignment between images and heatmaps
        # here with heatmaps that are smaller than the image
        img = np.zeros((80, 80), dtype=np.uint8)
        img[:, 30:50] = 255
        img[30:50, :] = 255
        img_small = ia.imresize_single_image(
            img, (40, 40), interpolation="nearest")
        hm = HeatmapsOnImage(
            img_small.astype(np.float32)/255.0,
            shape=(80, 80))
        aug = iaa.ElasticTransformation(
            alpha=60.0, sigma=4.0, mode="constant", cval=0)
        aug_det = aug.to_deterministic()

        img_aug = aug_det.augment_image(img)
        hm_aug = aug_det.augment_heatmaps([hm])[0]
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="7556" endline="7581" pcid="2118">

        img_aug = aug_det.augment_image(img)
        segmaps_aug = aug_det.augment_segmentation_maps([segmaps])[0]

        img_aug_mask = img_aug > 255*0.1
        segmaps_aug_mask = segmaps_aug.arr > 0
        same = np.sum(img_aug_mask == segmaps_aug_mask[:, :, 0])
        assert segmaps_aug.shape == (80, 80)
        assert segmaps_aug.arr.shape == (80, 80, 1)
        assert (same / img_aug_mask.size) >= 0.99

    def test_image_segmaps_alignment_if_heatmaps_smaller_than_image(self):
        # test alignment between images and segmaps
        # here with segmaps that are smaller than the image
        img = np.zeros((80, 80), dtype=np.uint8)
        img[:, 30:50] = 255
        img[30:50, :] = 255
        img_small = ia.imresize_single_image(
            img, (40, 40), interpolation="nearest")
        segmaps = SegmentationMapsOnImage(
            (img_small > 0).astype(np.int32), shape=(80, 80))
        aug = iaa.ElasticTransformation(
            alpha=60.0, sigma=4.0, mode="constant", cval=0, order=0)
        aug_det = aug.to_deterministic()

        img_aug = aug_det.augment_image(img)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="7534" endline="7555" pcid="2117">
        hm_aug_mask = ia.imresize_single_image(
            hm_aug.arr_0to1, (80, 80), interpolation="nearest"
        ) > 0.1
        same = np.sum(img_aug_mask == hm_aug_mask[:, :, 0])
        assert hm_aug.shape == (80, 80)
        assert hm_aug.arr_0to1.shape == (40, 40, 1)
        assert (same / img_aug_mask.size) >= 0.94

    # -----------
    # segmaps alignment
    # -----------
    def test_image_segmaps_alignment(self):
        # test alignment between images and segmaps
        img = np.zeros((80, 80), dtype=np.uint8)
        img[:, 30:50] = 255
        img[30:50, :] = 255
        segmaps = SegmentationMapsOnImage(
            (img > 0).astype(np.int32),
            shape=(80, 80))
        aug = iaa.ElasticTransformation(
            alpha=60.0, sigma=4.0, mode="constant", cval=0, order=0)
        aug_det = aug.to_deterministic()
</source>
</class>

<class classid="90" nclones="2" nlines="11" similarity="75">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="7650" endline="7663" pcid="2122">
        assert isinstance(params[3], iap.Deterministic)
        assert isinstance(params[4], iap.Deterministic)
        assert 0.25 - 1e-8 < params[0].value < 0.25 + 1e-8
        assert 1.0 - 1e-8 < params[1].value < 1.0 + 1e-8
        assert params[2].value == 2
        assert params[3].value == 10
        assert params[4].value == "constant"

    # -----------
    # other dtypes
    # -----------
    def test_other_dtypes_bool(self):
        aug = iaa.ElasticTransformation(sigma=0.5, alpha=5, order=0)
        mask = np.zeros((21, 21), dtype=bool)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="7708" endline="7724" pcid="2126">
            for value in values:
                with self.subTest(dtype=dtype, value=value):
                    image = np.zeros((21, 21), dtype=dtype)
                    image[7:13, 7:13] = value

                    image_aug = aug.augment_image(image)

                    assert image_aug.dtype.name == dtype
                    assert not np.all(_isclose(image_aug, np.float128(value)))
                    assert np.any(_isclose(image_aug[~mask],
                                           np.float128(value)))

    def test_other_dtypes_bool_all_orders(self):
        mask = np.zeros((50, 50), dtype=bool)
        mask[10:40, 20:30] = True
        mask[20:30, 10:40] = True

</source>
</class>

<class classid="91" nclones="4" nlines="10" similarity="100">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="7930" endline="7941" pcid="2147">
        return ia.KeypointsOnImage(kps, shape=(8, 4, 3))

    @property
    def psoi_k1(self):
        # without keep size
        kp_offset = self.kp_offset
        expected_k1_polys = [(4-1+kp_offset, 1),
                             (4-1+kp_offset, 3),
                             (4-3+kp_offset, 3),
                             (4-3+kp_offset, 1)]
        return ia.PolygonsOnImage([ia.Polygon(expected_k1_polys)],
                                  shape=(8, 4, 3))
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="7980" endline="7991" pcid="2151">
    @property
    def lsoi_k2(self):
        # without keep size
        kp_offset = self.kp_offset
        expected_k1_ls = self.psoi_k1.items[0].coords
        expected_k2_ls = [
            (8-expected_k1_ls[0][1]+kp_offset, expected_k1_ls[0][0]),
            (8-expected_k1_ls[1][1]+kp_offset, expected_k1_ls[1][0]),
            (8-expected_k1_ls[2][1]+kp_offset, expected_k1_ls[2][0]),
            (8-expected_k1_ls[3][1]+kp_offset, expected_k1_ls[3][0])]
        return ia.LineStringsOnImage([ia.LineString(expected_k2_ls)],
                                     shape=(4, 8, 3))
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="7967" endline="7978" pcid="2150">
                                  shape=(8, 4, 3))

    @property
    def lsoi_k1(self):
        # without keep size
        kp_offset = self.kp_offset
        expected_k1_ls = [(4-1+kp_offset, 1),
                          (4-1+kp_offset, 3),
                          (4-3+kp_offset, 3),
                          (4-3+kp_offset, 1)]
        return ia.LineStringsOnImage([ia.LineString(expected_k1_ls)],
                                     shape=(8, 4, 3))
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="7943" endline="7954" pcid="2148">
    @property
    def psoi_k2(self):
        # without keep size
        kp_offset = self.kp_offset
        expected_k1_polys = self.psoi_k1.polygons[0].exterior
        expected_k2_polys = [
            (8-expected_k1_polys[0][1]+kp_offset, expected_k1_polys[0][0]),
            (8-expected_k1_polys[1][1]+kp_offset, expected_k1_polys[1][0]),
            (8-expected_k1_polys[2][1]+kp_offset, expected_k1_polys[2][0]),
            (8-expected_k1_polys[3][1]+kp_offset, expected_k1_polys[3][0])]
        return ia.PolygonsOnImage([ia.Polygon(expected_k2_polys)],
                                  shape=(4, 8, 3))
</source>
</class>

<class classid="92" nclones="2" nlines="13" similarity="100">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="8008" endline="8023" pcid="2153">
        # without keep size
        kp_offset = self.kp_offset
        expected_k1_coords = [
            (4-1+kp_offset, 1),
            (4-3+kp_offset, 3)]
        return ia.BoundingBoxesOnImage([
            ia.BoundingBox(
                x1=min(expected_k1_coords[0][0], expected_k1_coords[1][0]),
                y1=min(expected_k1_coords[0][1], expected_k1_coords[1][1]),
                x2=max(expected_k1_coords[1][0], expected_k1_coords[0][0]),
                y2=max(expected_k1_coords[1][1], expected_k1_coords[0][1])
            )], shape=(8, 4, 3))

    @property
    def bbsoi_k2(self):
        # without keep size
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="8025" endline="8040" pcid="2154">
        coords = self.bbsoi_k1.bounding_boxes[0].coords
        expected_k2_coords = [
            (8-coords[0][1]+kp_offset, coords[0][0]),
            (8-coords[1][1]+kp_offset, coords[1][0])]
        return ia.BoundingBoxesOnImage([
            ia.BoundingBox(
                x1=min(expected_k2_coords[0][0], expected_k2_coords[1][0]),
                y1=min(expected_k2_coords[0][1], expected_k2_coords[1][1]),
                x2=max(expected_k2_coords[1][0], expected_k2_coords[0][0]),
                y2=max(expected_k2_coords[1][1], expected_k2_coords[0][1])
            )],
            shape=(4, 8, 3))

    @property
    def bbsoi_k3(self):
        # without keep size
</source>
</class>

<class classid="93" nclones="3" nlines="13" similarity="92">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="8152" endline="8168" pcid="2166">
    def test_heatmaps_k_is_1_and_5(self):
        for k in [1, 5]:
            with self.subTest(k=k):
                aug = iaa.Rot90(k, keep_size=False)

                hms_aug = aug.augment_heatmaps([self.heatmaps])[0]

                assert (hms_aug.arr_0to1.dtype.name
                        == self.heatmaps.arr_0to1.dtype.name)
                assert np.allclose(
                    hms_aug.arr_0to1,
                    np.rot90(self.heatmaps.arr_0to1, 1, axes=(1, 0)))
                assert hms_aug.shape == (4, 4, 3)

    def test_heatmaps_smaller_than_image_k_is_1_and_5(self):
        for k in [1, 5]:
            with self.subTest(k=k):
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="8186" endline="8201" pcid="2168">
                aug = iaa.Rot90(k, keep_size=False)

                segmaps_aug = aug.augment_segmentation_maps(
                    [self.segmaps]
                )[0]

                assert (
                    segmaps_aug.arr.dtype.name
                    == self.segmaps.arr.dtype.name)
                assert np.allclose(
                    segmaps_aug.arr,
                    np.rot90(self.segmaps.arr, 1, axes=(1, 0)))
                assert segmaps_aug.shape == (4, 4, 3)

    def test_segmaps_smaller_than_image_k_is_1_and_5(self):
        for k in [1, 5]:
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="8169" endline="8185" pcid="2167">
                aug = iaa.Rot90(k, keep_size=False)

                hms_smaller_aug = aug.augment_heatmaps(
                    [self.heatmaps_smaller]
                )[0]

                assert (
                    hms_smaller_aug.arr_0to1.dtype.name
                    == self.heatmaps_smaller.arr_0to1.dtype.name)
                assert np.allclose(
                    hms_smaller_aug.arr_0to1,
                    np.rot90(self.heatmaps_smaller.arr_0to1, 1, axes=(1, 0)))
                assert hms_smaller_aug.shape == (8, 4, 3)

    def test_segmaps_k_is_1_and_5(self):
        for k in [1, 5]:
            with self.subTest(k=k):
</source>
</class>

<class classid="94" nclones="6" nlines="11" similarity="75">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="8259" endline="8271" pcid="2175">
        assert np.array_equal(img_aug, np.rot90(img, 2, axes=(1, 0)))

    def test_heatmaps_k_is_2(self):
        aug = iaa.Rot90(2, keep_size=False)
        hms = self.heatmaps

        hms_aug = aug.augment_heatmaps([hms])[0]

        assert hms_aug.arr_0to1.dtype.name == hms.arr_0to1.dtype.name
        assert np.allclose(
            hms_aug.arr_0to1,
            np.rot90(hms.arr_0to1, 2, axes=(1, 0)))
        assert hms_aug.shape == (4, 4, 3)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="8284" endline="8296" pcid="2177">
        assert hms_smaller_aug.shape == (4, 8, 3)

    def test_segmaps_k_is_2(self):
        aug = iaa.Rot90(2, keep_size=False)
        segmaps = self.segmaps

        segmaps_aug = aug.augment_segmentation_maps([segmaps])[0]

        assert segmaps_aug.arr.dtype.name == segmaps.arr.dtype.name
        assert np.allclose(
            segmaps_aug.arr,
            np.rot90(segmaps.arr, 2, axes=(1, 0)))
        assert segmaps_aug.shape == (4, 4, 3)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="8351" endline="8365" pcid="2184">
        hms = self.heatmaps
        for k in [3, -1]:
            with self.subTest(k=k):
                aug = iaa.Rot90(k, keep_size=False)

                hms_aug = aug.augment_heatmaps([hms])[0]

                assert (hms_aug.arr_0to1.dtype.name
                        == hms.arr_0to1.dtype.name)
                assert np.allclose(
                    hms_aug.arr_0to1,
                    np.rot90(hms.arr_0to1, 3, axes=(1, 0)))
                assert hms_aug.shape == (4, 4, 3)

    def test_heatmaps_smaller_than_image_k_is_3_and_minus1(self):
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="8366" endline="8380" pcid="2185">
        hms_smaller = self.heatmaps_smaller
        for k in [3, -1]:
            with self.subTest(k=k):
                aug = iaa.Rot90(k, keep_size=False)

                hms_smaller_aug = aug.augment_heatmaps([hms_smaller])[0]

                assert (hms_smaller_aug.arr_0to1.dtype.name
                        == hms_smaller.arr_0to1.dtype.name)
                assert np.allclose(
                    hms_smaller_aug.arr_0to1,
                    np.rot90(hms_smaller.arr_0to1, 3, axes=(1, 0)))
                assert hms_smaller_aug.shape == (8, 4, 3)

    def test_segmaps_k_is_3_and_minus1(self):
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="8336" endline="8350" pcid="2183">

        assert_cbaois_equal(bbsoi_aug, self.bbsoi_k2)

    def test_images_k_is_3_and_minus1(self):
        img = self.image
        for k in [3, -1]:
            with self.subTest(k=k):
                aug = iaa.Rot90(k, keep_size=False)

                img_aug = aug.augment_image(img)

                assert img_aug.dtype.name == "uint8"
                assert np.array_equal(img_aug, np.rot90(img, 3, axes=(1, 0)))

    def test_heatmaps_k_is_3_and_minus1(self):
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="8381" endline="8396" pcid="2186">
        segmaps = self.segmaps
        for k in [3, -1]:
            with self.subTest(k=k):
                aug = iaa.Rot90(k, keep_size=False)

                segmaps_aug = aug.augment_segmentation_maps([segmaps])[0]

                assert (segmaps_aug.arr.dtype.name
                        == segmaps.arr.dtype.name)
                assert np.allclose(
                    segmaps_aug.arr,
                    np.rot90(segmaps.arr, 3, axes=(1, 0)))
                assert segmaps_aug.shape == (4, 4, 3)

    def test_segmaps_smaller_than_image_k_is_3_and_minus1(self):
        segmaps_smaller = self.segmaps_smaller
</source>
</class>

<class classid="95" nclones="2" nlines="12" similarity="91">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="8528" endline="8542" pcid="2198">

    def test_keypoints_k_is_1_keep_size_is_true(self):
        aug = iaa.Rot90(1, keep_size=True)
        kp_offset = self.kp_offset
        kpsoi = self.kpsoi

        kpsoi_aug = aug.augment_keypoints([kpsoi])[0]

        expected = [(4-2+kp_offset, 1), (4-3+kp_offset, 2)]
        expected = [(8*x/4, 4*y/8) for x, y in expected]
        assert kpsoi_aug.shape == (4, 8, 3)
        for kp_aug, kp in zip(kpsoi_aug.keypoints, expected):
            assert np.allclose([kp_aug.x, kp_aug.y], [kp[0], kp[1]])

    def test_polygons_k_is_1_keep_size_is_true(self):
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="8543" endline="8556" pcid="2199">
        aug = iaa.Rot90(1, keep_size=True)
        psoi = self.psoi
        kp_offset = self.kp_offset

        psoi_aug = aug.augment_polygons(psoi)

        expected = [(4-1+kp_offset, 1), (4-1+kp_offset, 3),
                    (4-3+kp_offset, 3), (4-3+kp_offset, 1)]
        expected = [(8*x/4, 4*y/8) for x, y in expected]
        assert psoi_aug.shape == (4, 8, 3)
        assert len(psoi_aug.polygons) == 1
        assert psoi_aug.polygons[0].is_valid
        assert psoi_aug.polygons[0].exterior_almost_equals(expected)

</source>
</class>

<class classid="96" nclones="2" nlines="14" similarity="100">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="8588" endline="8605" pcid="2202">
        assert len(bbsoi_aug.bounding_boxes) == 1
        assert bbsoi_aug.bounding_boxes[0].coords_almost_equals(expected)

    def test_images_k_is_list(self):
        aug = iaa.Rot90(_TwoValueParam(1, 2), keep_size=False)
        img = self.image

        imgs_aug = aug.augment_images([img] * 4)

        assert np.array_equal(imgs_aug[0], np.rot90(img, 1, axes=(1, 0)))
        assert np.array_equal(imgs_aug[1], np.rot90(img, 2, axes=(1, 0)))
        assert np.array_equal(imgs_aug[2], np.rot90(img, 1, axes=(1, 0)))
        assert np.array_equal(imgs_aug[3], np.rot90(img, 2, axes=(1, 0)))

    def test_heatmaps_smaller_than_image_k_is_list(self):
        def _rot_hm(hm, k):
            return np.rot90(hm.arr_0to1, k, axes=(1, 0))

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="8606" endline="8623" pcid="2204">
        aug = iaa.Rot90(_TwoValueParam(1, 2), keep_size=False)
        hms_smaller = self.heatmaps_smaller

        hms_aug = aug.augment_heatmaps([hms_smaller] * 4)

        assert hms_aug[0].shape == (8, 4, 3)
        assert hms_aug[1].shape == (4, 8, 3)
        assert hms_aug[2].shape == (8, 4, 3)
        assert hms_aug[3].shape == (4, 8, 3)
        assert np.allclose(hms_aug[0].arr_0to1, _rot_hm(hms_smaller, 1))
        assert np.allclose(hms_aug[1].arr_0to1, _rot_hm(hms_smaller, 2))
        assert np.allclose(hms_aug[2].arr_0to1, _rot_hm(hms_smaller, 1))
        assert np.allclose(hms_aug[3].arr_0to1, _rot_hm(hms_smaller, 2))

    def test_segmaps_smaller_than_image_k_is_list(self):
        def _rot_sm(segmap, k):
            return np.rot90(segmap.arr, k, axes=(1, 0))

</source>
</class>

<class classid="97" nclones="3" nlines="13" similarity="78">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="8872" endline="8887" pcid="2227">
class TestWithPolarWarping(unittest.TestCase):
    def setUp(self):
        reseed()

    def test___init___single_augmenter_as_child(self):
        aug = iaa.WithPolarWarping(iaa.Noop())
        assert isinstance(aug.children, iaa.Sequential)
        assert isinstance(aug.children[0], iaa.Noop)

    def test___init___list_of_augmenters_as_child(self):
        aug = iaa.WithPolarWarping([iaa.Noop(), iaa.Noop()])
        assert isinstance(aug.children, iaa.Sequential)
        assert isinstance(aug.children[0], iaa.Noop)
        assert isinstance(aug.children[1], iaa.Noop)

    def test_images_no_change(self):
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="9252" endline="9270" pcid="2246">
        image = np.fliplr(image)
        assert image.flags["C_CONTIGUOUS"] is False
        aug = iaa.WithPolarWarping(iaa.Noop())

        image_aug = aug(image=image)

        avg_dist = np.average(
            np.abs(
                image_aug.astype(np.int32)[2:-2, 2:-2]
                - image_cp.astype(np.int32)[2:-2, 2:-2]
            )
        )
        assert image_aug.shape == (10, 20, 3)
        assert avg_dist < 7.0

    def test_image_is_view(self):
        image = np.mod(np.arange(10*20*3), 255).astype(np.uint8)
        image = image.reshape((10, 20, 3))
        image_cp = np.copy(image)[2:, 2:, :]
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="9233" endline="9251" pcid="2245">
               ia.Keypoint(y=40+10+1.5, x=50+10+1.5)]
        kpsoi = ia.KeypointsOnImage(kps, shape=image.shape)
        aug = iaa.WithPolarWarping(iaa.Affine(translate_px={"x": 10}))

        image_aug, kpsoi_aug = aug(image=image, keypoints=kpsoi)

        kp1 = kpsoi_aug.items[0]
        kp2 = kpsoi_aug.items[1]
        kp1_intensity = image_aug[int(kp1.y), int(kp1.x), 0]
        kp2_intensity = image_aug[int(kp2.y), int(kp2.x), 0]
        assert image_aug.shape == (80, 100, 3)
        assert kpsoi_aug.shape == (80, 100, 3)
        assert kp1_intensity > 200
        assert kp2_intensity > 200

    def test_image_is_noncontiguous(self):
        image = np.mod(np.arange(10*20*3), 255).astype(np.uint8)
        image = image.reshape((10, 20, 3))
        image_cp = np.fliplr(np.copy(image))
</source>
</class>

<class classid="98" nclones="3" nlines="12" similarity="75">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="8933" endline="8948" pcid="2231">
        assert sm_aug.shape == (10, 20, 3)
        assert p_same > 0.95

    def test_keypoints_no_change(self):
        kps = [ia.Keypoint(x=1, y=2), ia.Keypoint(x=5, y=5),
               ia.Keypoint(x=5, y=9)]
        kpsoi = ia.KeypointsOnImage(kps, shape=(10, 20, 3))
        aug = iaa.WithPolarWarping(iaa.Noop())

        kpsoi_aug = aug(keypoints=kpsoi)

        assert kpsoi_aug.shape == (10, 20, 3)
        assert np.allclose(kpsoi_aug.to_xy_array(), kpsoi.to_xy_array(),
                           atol=0.01)

    def test_bounding_boxes_no_change(self):
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="8949" endline="8964" pcid="2232">
        bbs = [
            ia.BoundingBox(x1=1, y1=2, x2=3, y2=4, label="foo"),
            ia.BoundingBox(x1=3, y1=5, x2=7, y2=10),
        ]
        bbsoi = ia.BoundingBoxesOnImage(bbs, shape=(10, 20, 3))
        aug = iaa.WithPolarWarping(iaa.Noop())

        bbsoi_aug = aug(bounding_boxes=bbsoi)

        assert bbsoi_aug.items[0].label == "foo"
        assert bbsoi_aug.items[1].label is None
        assert bbsoi_aug.shape == (10, 20, 3)
        assert np.allclose(bbsoi_aug.to_xy_array(), bbsoi.to_xy_array(),
                           atol=0.01)

    def test_polygons_no_change(self):
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="8965" endline="8978" pcid="2233">
        ps = [
            ia.Polygon([(0, 2), (4, 2), (4, 4)], label="foo"),
            ia.Polygon([(0, 0), (5, 0), (5, 5), (0, 5)])
        ]
        psoi = ia.PolygonsOnImage(ps, shape=(10, 20, 3))
        aug = iaa.WithPolarWarping(iaa.Noop())

        psoi_aug = aug(polygons=psoi)

        assert psoi_aug.items[0].label == "foo"
        assert psoi_aug.items[1].label is None
        assert psoi_aug.shape == (10, 20, 3)
        assert np.allclose(psoi_aug.to_xy_array(), psoi.to_xy_array(),
                           atol=0.01)
</source>
</class>

<class classid="99" nclones="3" nlines="18" similarity="73">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="9009" endline="9030" pcid="2235">
        bbsoi_aug = aug.augment_bounding_boxes(bbsoi)
        psoi_aug = aug.augment_polygons(psoi)

        assert bbsoi_aug.items[0].label == "foo"
        assert bbsoi_aug.items[1].label is None
        assert bbsoi_aug.shape == (10, 20, 3)
        assert np.allclose(bbsoi_aug.to_xy_array(), bbsoi.to_xy_array(),
                           atol=0.01)

        assert psoi_aug.items[0].label == "foo"
        assert psoi_aug.items[1].label is None
        assert psoi_aug.shape == (10, 20, 3)
        assert np.allclose(psoi_aug.to_xy_array(), psoi.to_xy_array(),
                           atol=0.01)

    def test_images_translation_x(self):
        image = np.zeros((50, 70, 3), dtype=np.uint8)
        image[20-1:20+1, 30-1:30+1, 0] = 255
        image[30-1:30+1, 40-1:40+1, 1] = 255
        aug = iaa.WithPolarWarping(iaa.Affine(translate_px={"x": 15}))

        image_aug = aug(image=image)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="9056" endline="9080" pcid="2237">
        x1 = np.argmax(np.max(hm_aug_arr[..., 0], axis=0))
        y1 = np.argmax(np.max(hm_aug_arr[..., 0], axis=1))
        x2 = np.argmax(np.max(hm_aug_arr[..., 1], axis=0))
        y2 = np.argmax(np.max(hm_aug_arr[..., 1], axis=1))

        # translation on x axis in polar representation should move all points
        # a bit away from the center
        min_diff = 4
        assert hm_aug_arr.shape == (50, 70, 2)
        assert hm_aug.shape == (50, 70, 3)
        assert x1 < 30 - min_diff
        assert y1 < 20 - min_diff
        assert x2 > 40 + min_diff
        assert y2 > 30 + min_diff

    def test_segmentation_maps_translation_x(self):
        sm = np.zeros((50, 70, 2), dtype=np.int32)
        sm[20-1:20+1, 30-1:30+1, 0] = 1
        sm[30-1:30+1, 40-1:40+1, 1] = 2
        sm = ia.SegmentationMapsOnImage(sm, shape=(50, 70, 3))
        aug = iaa.WithPolarWarping(iaa.Affine(translate_px={"x": 15}))

        sm_aug = aug(segmentation_maps=sm)

        sm_aug_arr = sm_aug.get_arr()
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="9031" endline="9055" pcid="2236">

        x1 = np.argmax(np.max(image_aug[..., 0], axis=0))
        y1 = np.argmax(np.max(image_aug[..., 0], axis=1))
        x2 = np.argmax(np.max(image_aug[..., 1], axis=0))
        y2 = np.argmax(np.max(image_aug[..., 1], axis=1))

        # translation on x axis in polar representation should move all points
        # a bit away from the center
        min_diff = 4
        assert image_aug.shape == (50, 70, 3)
        assert x1 < 30 - min_diff
        assert y1 < 20 - min_diff
        assert x2 > 40 + min_diff
        assert y2 > 30 + min_diff

    def test_heatmaps_translation_x(self):
        hm = np.zeros((50, 70, 2), dtype=np.float32)
        hm[20-1:20+1, 30-1:30+1, 0] = 1.0
        hm[30-1:30+1, 40-1:40+1, 1] = 1.0
        hm = ia.HeatmapsOnImage(hm, shape=(50, 70, 3))
        aug = iaa.WithPolarWarping(iaa.Affine(translate_px={"x": 15}))

        hm_aug = aug(heatmaps=hm)

        hm_aug_arr = hm_aug.get_arr()
</source>
</class>

<class classid="100" nclones="2" nlines="16" similarity="87">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="9081" endline="9101" pcid="2238">
        x1 = np.argmax(np.max(sm_aug_arr[..., 0], axis=0))
        y1 = np.argmax(np.max(sm_aug_arr[..., 0], axis=1))
        x2 = np.argmax(np.max(sm_aug_arr[..., 1], axis=0))
        y2 = np.argmax(np.max(sm_aug_arr[..., 1], axis=1))

        # translation on x axis in polar representation should move all points
        # a bit away from the center
        min_diff = 4
        assert sm_aug_arr.shape == (50, 70, 2)
        assert sm_aug.shape == (50, 70, 3)
        assert x1 < 30 - min_diff
        assert y1 < 20 - min_diff
        assert x2 > 40 + min_diff
        assert y2 > 30 + min_diff

    def test_keypoints_translation_x(self):
        cbas = [ia.Keypoint(y=20, x=30), ia.Keypoint(y=30, x=40)]
        cbaoi = ia.KeypointsOnImage(cbas, shape=(50, 70, 3))
        aug = iaa.WithPolarWarping(iaa.Affine(translate_px={"x": 15}))

        cbaoi_aug = aug(keypoints=cbaoi)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="9102" endline="9123" pcid="2239">

        x1 = cbaoi_aug.items[0].x
        y1 = cbaoi_aug.items[0].y
        x2 = cbaoi_aug.items[1].x
        y2 = cbaoi_aug.items[1].y

        # translation on x axis in polar representation should move all points
        # a bit away from the center
        min_diff = 4
        assert cbaoi_aug.shape == (50, 70, 3)
        assert x1 < 30 - min_diff
        assert y1 < 20 - min_diff
        assert x2 > 40 + min_diff
        assert y2 > 30 + min_diff

    def test_bounding_boxes_translation_x(self):
        cbas = [ia.BoundingBox(y1=20, x1=30, y2=20+2, x2=30+2),
                ia.BoundingBox(y1=30, x1=40, y2=30+2, x2=40+2)]
        cbaoi = ia.BoundingBoxesOnImage(cbas, shape=(50, 70, 3))
        aug = iaa.WithPolarWarping(iaa.Affine(translate_px={"x": 15}))

        cbaoi_aug = aug(bounding_boxes=cbaoi)
</source>
</class>

<class classid="101" nclones="2" nlines="16" similarity="100">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="9124" endline="9145" pcid="2240">

        x1 = cbaoi_aug.items[0].x1
        y1 = cbaoi_aug.items[0].y1
        x2 = cbaoi_aug.items[1].x2
        y2 = cbaoi_aug.items[1].y2

        # translation on x axis in polar representation should move all points
        # a bit away from the center
        min_diff = 4
        assert cbaoi_aug.shape == (50, 70, 3)
        assert x1 < 30 - min_diff
        assert y1 < 20 - min_diff
        assert x2 > 40 + min_diff
        assert y2 > 30 + min_diff

    def test_polygons_translation_x(self):
        cbas = [ia.Polygon([(30, 20), (30+2, 20), (30+2, 20+2)]),
                ia.Polygon([(40, 30), (40+2, 30), (40+2, 30+2)])]
        cbaoi = ia.PolygonsOnImage(cbas, shape=(50, 70, 3))
        aug = iaa.WithPolarWarping(iaa.Affine(translate_px={"x": 15}))

        cbaoi_aug = aug(polygons=cbaoi)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="9146" endline="9167" pcid="2241">

        x1 = cbaoi_aug.items[0].coords[0][0]
        y1 = cbaoi_aug.items[0].coords[0][1]
        x2 = cbaoi_aug.items[1].coords[2][0]
        y2 = cbaoi_aug.items[1].coords[2][1]

        # translation on x axis in polar representation should move all points
        # a bit away from the center
        min_diff = 4
        assert cbaoi_aug.shape == (50, 70, 3)
        assert x1 < 30 - min_diff
        assert y1 < 20 - min_diff
        assert x2 > 40 + min_diff
        assert y2 > 30 + min_diff

    def test_line_strings_translation_x(self):
        cbas = [ia.LineString([(30, 20), (30+2, 20), (30+2, 20+2)]),
                ia.LineString([(40, 30), (40+2, 30), (40+2, 30+2)])]
        cbaoi = ia.LineStringsOnImage(cbas, shape=(50, 70, 3))
        aug = iaa.WithPolarWarping(iaa.Affine(translate_px={"x": 15}))

        cbaoi_aug = aug(line_strings=cbaoi)
</source>
</class>

<class classid="102" nclones="2" nlines="18" similarity="88">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="9168" endline="9189" pcid="2242">

        x1 = cbaoi_aug.items[0].coords[0][0]
        y1 = cbaoi_aug.items[0].coords[0][1]
        x2 = cbaoi_aug.items[1].coords[2][0]
        y2 = cbaoi_aug.items[1].coords[2][1]

        # translation on x axis in polar representation should move all points
        # a bit away from the center
        min_diff = 4
        assert cbaoi_aug.shape == (50, 70, 3)
        assert x1 < 30 - min_diff
        assert y1 < 20 - min_diff
        assert x2 > 40 + min_diff
        assert y2 > 30 + min_diff

    def test_image_heatmap_alignment(self):
        image = np.zeros((80, 100, 3), dtype=np.uint8)
        image[40-10:40+10, 50-10:50+10, :] = 255
        hm = np.zeros((40, 50, 1), dtype=np.float32)
        hm[20-5:20+5, 25-5:25+5, :] = 1.0
        hm = ia.HeatmapsOnImage(hm, shape=image.shape)
        aug = iaa.WithPolarWarping(iaa.Affine(translate_px={"x": 10}))
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="9190" endline="9211" pcid="2243">

        image_aug, hm_aug = aug(image=image, heatmaps=hm)

        hm_aug_arr = hm_aug.get_arr()
        hm_aug_arr_rs = ia.imresize_single_image(hm_aug_arr, (80, 100),
                                                 interpolation="nearest")
        overlap = np.average(
            (image_aug[..., 0] > 200)
            == (hm_aug_arr_rs[..., 0] > 0.9)
        )
        assert image_aug.shape == (80, 100, 3)
        assert hm_aug.shape == (80, 100, 3)
        assert hm_aug_arr.shape == (40, 50, 1)
        assert overlap > 0.96

    def test_image_segmentation_map_alignment(self):
        image = np.zeros((80, 100, 3), dtype=np.uint8)
        image[40-10:40+10, 50-10:50+10, :] = 255
        sm = np.zeros((40, 50, 1), dtype=np.int32)
        sm[20-5:20+5, 25-5:25+5, :] = 1
        sm = ia.SegmentationMapsOnImage(sm, shape=image.shape)
        aug = iaa.WithPolarWarping(iaa.Affine(translate_px={"x": 10}))
</source>
</class>

<class classid="103" nclones="2" nlines="17" similarity="88">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="9670" endline="9691" pcid="2271">
        observed = iaa.apply_jigsaw_to_coords(arr, destinations, (100, 100))

        assert np.allclose(observed, arr)


class Test_generate_jigsaw_destinations(unittest.TestCase):
    def test_max_steps_0(self):
        rng = iarandom.RNG(0)
        max_steps = 0
        rows = 10
        cols = 20

        observed = iaa.generate_jigsaw_destinations(rows, cols, max_steps, rng,
                                                    connectivity=8)

        assert np.array_equal(
            observed,
            np.arange(rows*cols).reshape((rows, cols)))

    def test_max_steps_1(self):
        rng = iarandom.RNG(0)
        max_steps = 1
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="9692" endline="9714" pcid="2272">
        rows = 10
        cols = 20

        observed = iaa.generate_jigsaw_destinations(rows, cols, max_steps, rng,
                                                    connectivity=8)

        yy = (observed // cols).reshape((rows, cols))
        xx = np.mod(observed, cols).reshape((rows, cols))
        yy_expected = np.tile(np.arange(rows).reshape((rows, 1)), (1, cols))
        xx_expected = np.tile(np.arange(cols).reshape((1, cols)), (rows, 1))

        yy_diff = yy_expected - yy
        xx_diff = xx_expected - xx
        dist = np.sqrt(yy_diff ** 2 + xx_diff ** 2)

        assert np.min(dist) <= 0.01
        assert np.any(dist >= np.sqrt(2) - 1e-4)
        assert np.max(dist) <= np.sqrt(2) + 1e-4

    def test_max_steps_1_connectivity_4(self):
        rng = iarandom.RNG(0)
        max_steps = 1
        rows = 10
</source>
</class>

<class classid="104" nclones="2" nlines="27" similarity="85">
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="9835" endline="9870" pcid="2283">

        old_func = aug._draw_samples

        def _mocked_draw_samples(batch, random_state):
            samples = old_func(batch, random_state)
            return geometriclib._JigsawSamples(
                nb_rows=samples.nb_rows,
                nb_cols=samples.nb_cols,
                max_steps=samples.max_steps,
                destinations=[destinations])

        aug._draw_samples = _mocked_draw_samples

        image_aug = aug(image=image)

        expected = iaa.pad(image, bottom=1, right=1, cval=0)
        expected = iaa.apply_jigsaw(expected, destinations)
        assert np.array_equal(image_aug, expected)

    def test_heatmaps_with_shifts(self):
        # these rows/cols/max_steps parameters are mostly ignored due to the
        # mocked _draw_samples method below
        aug = iaa.Jigsaw(nb_rows=2, nb_cols=2, max_steps=1)
        arr = np.linspace(0, 1.0, 18*18*1).astype(np.float32)
        arr = arr.reshape((18, 18, 1))
        heatmap = ia.HeatmapsOnImage(arr, shape=(19, 19, 3))
        destinations = np.array([
            [3, 1],
            [2, 0]
        ], dtype=np.int32)

        old_func = aug._draw_samples

        def _mocked_draw_samples(batch, random_state):
            samples = old_func(batch, random_state)
            return geometriclib._JigsawSamples(
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_geometric.py" startline="9871" endline="9906" pcid="2285">
                nb_rows=samples.nb_rows,
                nb_cols=samples.nb_cols,
                max_steps=samples.max_steps,
                destinations=[destinations])

        aug._draw_samples = _mocked_draw_samples

        heatmap_aug = aug(heatmaps=heatmap)

        expected = ia.imresize_single_image(arr, (19, 19),
                                            interpolation="cubic")
        expected = np.clip(expected, 0, 1.0)
        expected = iaa.pad(expected, bottom=1, right=1, cval=0.0)
        expected = iaa.apply_jigsaw(expected, destinations)
        expected = ia.imresize_single_image(expected, (18, 18),
                                            interpolation="cubic")
        expected = np.clip(expected, 0, 1.0)
        assert np.allclose(heatmap_aug.arr_0to1, expected)

    def test_segmaps_with_shifts(self):
        # these rows/cols/max_steps parameters are mostly ignored due to the
        # mocked _draw_samples method below
        aug = iaa.Jigsaw(nb_rows=2, nb_cols=2, max_steps=1)
        arr = np.zeros((18, 18, 1), dtype=np.int32)
        arr[0:10, :] = 1
        arr[10:18, 10:18] = 2
        arr = arr.reshape((18, 18, 1))
        segmap = ia.SegmentationMapsOnImage(arr, shape=(19, 19, 3))
        destinations = np.array([
            [3, 1],
            [2, 0]
        ], dtype=np.int32)

        old_func = aug._draw_samples

        def _mocked_draw_samples(batch, random_state):
</source>
</class>

<class classid="105" nclones="2" nlines="20" similarity="85">
<source file="systems/imgaug-0.4.0/test/augmenters/test_blur.py" startline="351" endline="389" pcid="2311">
                            * np.float128(value))
                        assert np.max(diff) < max_diff

    def test_other_dtypes_bool_at_sigma_06(self):
        # --
        # blur of bool input at sigma=0.6
        # --
        # here we use a special mask and sigma as otherwise the only values
        # ending up with >0.5 would be the ones that
        # were before the blur already at >0.5
        # prototype kernel, generated via:
        #  mask = np.zeros((5, 5), dtype=np.float64)
        #  mask[1, 0] = 255
        #  mask[2, 0] = 255
        #  mask[2, 2] = 255
        #  mask[2, 4] = 255
        #  mask[3, 0] = 255
        #  mask = ndimage.gaussian_filter(mask, 1.0, mode="mirror")
        mask_bool = np.float64([
           [ 57,  14,   2,   1,   1],
           [142,  42,  29,  14,  28],
           [169,  69, 114,  56, 114],
           [142,  42,  29,  14,  28],
           [ 57,  14,   2,   1,   1]
        ]) / 255.0

        image = np.zeros((5, 5), dtype=bool)
        image[1, 0] = True
        image[2, 0] = True
        image[2, 2] = True
        image[2, 4] = True
        image[3, 0] = True

        for backend in ["scipy", "cv2"]:
            image_aug = iaa.blur_gaussian_(
                np.copy(image), sigma=0.6, backend=backend)
            expected = mask_bool > 0.5
            assert image_aug.shape == mask_bool.shape
            assert image_aug.dtype.type == np.bool_
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blur.py" startline="614" endline="650" pcid="2327">
            image[1, 1] = center_value
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.allclose(image_aug, image)

    def test_other_dtypes_bool_at_sigma_060(self):
        # --
        # blur of bool input at sigma=0.6
        # --
        # here we use a special mask and sigma as otherwise the only values
        # ending up with >0.5 would be the ones that
        # were before the blur already at >0.5
        # prototype kernel, generated via:
        #  mask = np.zeros((5, 5), dtype=np.float64)
        #  mask[1, 0] = 255
        #  mask[2, 0] = 255
        #  mask[2, 2] = 255
        #  mask[2, 4] = 255
        #  mask[3, 0] = 255
        #  mask = ndimage.gaussian_filter(mask, 1.0, mode="mirror")
        aug = iaa.GaussianBlur(sigma=0.6)

        mask_bool = np.float64([
           [ 57,  14,   2,   1,   1],
           [142,  42,  29,  14,  28],
           [169,  69, 114,  56, 114],
           [142,  42,  29,  14,  28],
           [ 57,  14,   2,   1,   1]
        ]) / 255.0

        image = np.zeros((5, 5), dtype=bool)
        image[1, 0] = True
        image[2, 0] = True
        image[2, 2] = True
        image[2, 4] = True
        image[3, 0] = True
        image_aug = aug.augment_image(image)
</source>
</class>

<class classid="106" nclones="3" nlines="12" similarity="91">
<source file="systems/imgaug-0.4.0/test/augmenters/test_blur.py" startline="531" endline="546" pcid="2322">
        assert (observed[0][outer_pixels[0], outer_pixels[1]] > 0).all()
        assert (observed[0][outer_pixels[0], outer_pixels[1]] < 50).all()

    def test_keypoints_dont_change(self):
        kps = [ia.Keypoint(x=0, y=0), ia.Keypoint(x=1, y=1),
               ia.Keypoint(x=2, y=2)]
        kpsoi = [ia.KeypointsOnImage(kps, shape=(3, 3, 1))]

        aug = iaa.GaussianBlur(sigma=0.5)
        aug_det = aug.to_deterministic()

        observed = aug.augment_keypoints(kpsoi)
        expected = kpsoi
        assert keypoints_equal(observed, expected)

        observed = aug_det.augment_keypoints(kpsoi)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blur.py" startline="1019" endline="1033" pcid="2344">
                image = np.zeros(shape, dtype=np.uint8)

                image_aug = iaa.AverageBlur(k=3)(image=image)

                assert image_aug.shape == image.shape

    def test_keypoints_dont_change(self):
        kps = [ia.Keypoint(x=0, y=0), ia.Keypoint(x=1, y=1),
               ia.Keypoint(x=2, y=2)]
        kpsoi = [ia.KeypointsOnImage(kps, shape=(11, 11, 1))]

        aug = iaa.AverageBlur(k=3)
        aug_det = aug.to_deterministic()
        observed = aug.augment_keypoints(kpsoi)
        expected = kpsoi
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blur.py" startline="1328" endline="1342" pcid="2359">
        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)

                image_aug = iaa.MedianBlur(k=3)(image=image)

                assert image_aug.shape == image.shape

    def test_keypoints_not_changed(self):
        kps = [ia.Keypoint(x=0, y=0), ia.Keypoint(x=1, y=1),
               ia.Keypoint(x=2, y=2)]
        kpsoi = [ia.KeypointsOnImage(kps, shape=(11, 11, 1))]

        aug = iaa.MedianBlur(k=3)
        aug_det = aug.to_deterministic()
</source>
</class>

<class classid="107" nclones="8" nlines="26" similarity="78">
<source file="systems/imgaug-0.4.0/test/augmenters/test_blur.py" startline="547" endline="578" pcid="2323">
        expected = kpsoi
        assert keypoints_equal(observed, expected)

    def test_sigma_is_tuple(self):
        # varying blur sigmas
        base_img = np.array([[0, 0, 0],
                         [0, 255, 0],
                         [0, 0, 0]], dtype=np.uint8)
        base_img = base_img[:, :, np.newaxis]
        images = np.array([base_img])

        aug = iaa.GaussianBlur(sigma=(0, 1))
        aug_det = aug.to_deterministic()

        last_aug = None
        last_aug_det = None
        nb_changed_aug = 0
        nb_changed_aug_det = 0
        nb_iterations = 1000
        for i in sm.xrange(nb_iterations):
            observed_aug = aug.augment_images(images)
            observed_aug_det = aug_det.augment_images(images)
            if i == 0:
                last_aug = observed_aug
                last_aug_det = observed_aug_det
            else:
                if not np.array_equal(observed_aug, last_aug):
                    nb_changed_aug += 1
                if not np.array_equal(observed_aug_det, last_aug_det):
                    nb_changed_aug_det += 1
                last_aug = observed_aug
                last_aug_det = observed_aug_det
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="1811" endline="1838" pcid="2891">
        assert 75 < seen[0] < 125
        assert 75 < seen[1] < 125

    def test_tuple_as_scale(self):
        # varying stds
        base_img = np.ones((16, 16, 1), dtype=np.uint8) * 128

        aug = iaa.AdditiveGaussianNoise(loc=0, scale=(0.01 * 255, 0.2 * 255))
        aug_det = aug.to_deterministic()
        images = np.ones((1, 1, 1, 1), dtype=np.uint8) * 128
        last_aug = None
        last_aug_det = None
        nb_changed_aug = 0
        nb_changed_aug_det = 0
        nb_iterations = 1000
        for i in sm.xrange(nb_iterations):
            observed_aug = aug.augment_images(images)
            observed_aug_det = aug_det.augment_images(images)
            if i == 0:
                last_aug = observed_aug
                last_aug_det = observed_aug_det
            else:
                if not np.array_equal(observed_aug, last_aug):
                    nb_changed_aug += 1
                if not np.array_equal(observed_aug_det, last_aug_det):
                    nb_changed_aug_det += 1
                last_aug = observed_aug
                last_aug_det = observed_aug_det
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="3694" endline="3722" pcid="3002">

        aug = iaa.MultiplyElementwise(mul=1.2)
        aug_det = iaa.Multiply(mul=1.2).to_deterministic()
        observed = aug.augment_keypoints(keypoints)
        expected = keypoints
        assert keypoints_equal(observed, expected)

        observed = aug_det.augment_keypoints(keypoints)
        expected = keypoints
        assert keypoints_equal(observed, expected)

    def test_tuple_as_mul(self):
        # varying multiply factors
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        images = np.array([base_img])

        aug = iaa.MultiplyElementwise(mul=(0, 2.0))
        aug_det = aug.to_deterministic()

        last_aug = None
        last_aug_det = None
        nb_changed_aug = 0
        nb_changed_aug_det = 0
        nb_iterations = 1000
        for i in sm.xrange(nb_iterations):
            observed_aug = aug.augment_images(images)
            observed_aug_det = aug_det.augment_images(images)
            if i == 0:
                last_aug = observed_aug
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="1350" endline="1378" pcid="2872">
        expected = keypoints
        assert keypoints_equal(observed, expected)

    def test_tuple_as_value(self):
        # varying values
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        images = np.array([base_img])

        aug = iaa.AddElementwise(value=(0, 10))
        aug_det = aug.to_deterministic()

        last_aug = None
        last_aug_det = None
        nb_changed_aug = 0
        nb_changed_aug_det = 0
        nb_iterations = 1000
        for i in sm.xrange(nb_iterations):
            observed_aug = aug.augment_images(images)
            observed_aug_det = aug_det.augment_images(images)
            if i == 0:
                last_aug = observed_aug
                last_aug_det = observed_aug_det
            else:
                if not np.array_equal(observed_aug, last_aug):
                    nb_changed_aug += 1
                if not np.array_equal(observed_aug_det, last_aug_det):
                    nb_changed_aug_det += 1
                last_aug = observed_aug
                last_aug_det = observed_aug_det
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="3220" endline="3248" pcid="2985">

        aug = iaa.Multiply(mul=1.2)
        aug_det = iaa.Multiply(mul=1.2).to_deterministic()
        observed = aug.augment_keypoints(keypoints)
        expected = keypoints
        assert keypoints_equal(observed, expected)

        observed = aug_det.augment_keypoints(keypoints)
        expected = keypoints
        assert keypoints_equal(observed, expected)

    def test_tuple_as_mul(self):
        # varying multiply factors
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        images = np.array([base_img])

        aug = iaa.Multiply(mul=(0, 2.0))
        aug_det = aug.to_deterministic()

        last_aug = None
        last_aug_det = None
        nb_changed_aug = 0
        nb_changed_aug_det = 0
        nb_iterations = 1000
        for i in sm.xrange(nb_iterations):
            observed_aug = aug.augment_images(images)
            observed_aug_det = aug_det.augment_images(images)
            if i == 0:
                last_aug = observed_aug
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="2280" endline="2305" pcid="2914">

        observed = aug.augment_keypoints(keypoints)
        assert keypoints_equal(observed, keypoints)

        observed = aug_det.augment_keypoints(keypoints)
        assert keypoints_equal(observed, keypoints)

    def test_tuple_as_p(self):
        # varying p
        aug = iaa.Dropout(p=(0.0, 1.0))
        aug_det = aug.to_deterministic()
        images = np.ones((1, 8, 8, 1), dtype=np.uint8) * 255
        last_aug = None
        last_aug_det = None
        nb_changed_aug = 0
        nb_changed_aug_det = 0
        nb_iterations = 1000
        for i in sm.xrange(nb_iterations):
            observed_aug = aug.augment_images(images)
            observed_aug_det = aug_det.augment_images(images)
            if i == 0:
                last_aug = observed_aug
                last_aug_det = observed_aug_det
            else:
                if not np.array_equal(observed_aug, last_aug):
                    nb_changed_aug += 1
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="1762" endline="1789" pcid="2889">
        values = np.array(values)
        assert 54 < np.average(values) < 74 # loc=0.25 should be around 255*0.25=64 average

    def test_tuple_as_loc(self):
        # varying locs
        base_img = np.ones((16, 16, 1), dtype=np.uint8) * 128

        aug = iaa.AdditiveGaussianNoise(loc=(0, 0.5 * 255), scale=0.0001 * 255)
        aug_det = aug.to_deterministic()
        images = np.ones((1, 1, 1, 1), dtype=np.uint8) * 128
        last_aug = None
        last_aug_det = None
        nb_changed_aug = 0
        nb_changed_aug_det = 0
        nb_iterations = 1000
        for i in sm.xrange(nb_iterations):
            observed_aug = aug.augment_images(images)
            observed_aug_det = aug_det.augment_images(images)
            if i == 0:
                last_aug = observed_aug
                last_aug_det = observed_aug_det
            else:
                if not np.array_equal(observed_aug, last_aug):
                    nb_changed_aug += 1
                if not np.array_equal(observed_aug_det, last_aug_det):
                    nb_changed_aug_det += 1
                last_aug = observed_aug
                last_aug_det = observed_aug_det
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="881" endline="909" pcid="2853">
        expected = keypoints
        assert keypoints_equal(observed, expected)

    def test_tuple_as_value(self):
        # varying values
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        images = np.array([base_img])

        aug = iaa.Add(value=(0, 10))
        aug_det = aug.to_deterministic()

        last_aug = None
        last_aug_det = None
        nb_changed_aug = 0
        nb_changed_aug_det = 0
        nb_iterations = 1000
        for i in sm.xrange(nb_iterations):
            observed_aug = aug.augment_images(images)
            observed_aug_det = aug_det.augment_images(images)
            if i == 0:
                last_aug = observed_aug
                last_aug_det = observed_aug_det
            else:
                if not np.array_equal(observed_aug, last_aug):
                    nb_changed_aug += 1
                if not np.array_equal(observed_aug_det, last_aug_det):
                    nb_changed_aug_det += 1
                last_aug = observed_aug
                last_aug_det = observed_aug_det
</source>
</class>

<class classid="108" nclones="2" nlines="32" similarity="93">
<source file="systems/imgaug-0.4.0/test/augmenters/test_blur.py" startline="651" endline="699" pcid="2328">
        expected = mask_bool > 0.5
        assert image_aug.shape == mask_bool.shape
        assert image_aug.dtype.type == np.bool_
        assert np.all(image_aug == expected)

    def test_other_dtypes_at_sigma_1(self):
        # --
        # blur of various dtypes at sigma=1.0
        # and using an example value of 100 for int/uint/float and True for
        # bool
        # --
        # prototype kernel, generated via:
        #  mask = np.zeros((5, 5), dtype=np.float64)
        #  mask[2, 2] = 100
        #  mask = ndimage.gaussian_filter(mask, 1.0, mode="mirror")
        aug = iaa.GaussianBlur(sigma=1.0)

        mask = np.float64([
            [1, 2, 3, 2, 1],
            [2, 5, 9, 5, 2],
            [4, 9, 15, 9, 4],
            [2, 5, 9, 5, 2],
            [1, 2, 3, 2, 1]
        ])

        # uint, int
        uint_dts = [np.uint8, np.uint16, np.uint32]
        int_dts = [np.int8, np.int16, np.int32]
        for dtype in uint_dts + int_dts:
            image = np.zeros((5, 5), dtype=dtype)
            image[2, 2] = 100
            image_aug = aug.augment_image(image)
            expected = mask.astype(dtype)
            diff = np.abs(image_aug.astype(np.int64)
                          - expected.astype(np.int64))
            assert image_aug.shape == mask.shape
            assert image_aug.dtype.type == dtype
            assert np.max(diff) <= 4
            assert np.average(diff) <= 2

        # float
        float_dts = [np.float16, np.float32, np.float64]
        for dtype in float_dts:
            image = np.zeros((5, 5), dtype=dtype)
            image[2, 2] = 100.0
            image_aug = aug.augment_image(image)
            expected = mask.astype(dtype)
            diff = np.abs(image_aug.astype(np.float128)
                          - expected.astype(np.float128))
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blur.py" startline="700" endline="746" pcid="2329">
            assert image_aug.shape == mask.shape
            assert image_aug.dtype.type == dtype
            assert np.max(diff) < 4
            assert np.average(diff) < 2.0

    def test_other_dtypes_at_sigma_040(self):
        # --
        # blur of various dtypes at sigma=0.4
        # and using an example value of 100 for int/uint/float and True for
        # bool
        # --
        aug = iaa.GaussianBlur(sigma=0.4)

        # prototype kernel, generated via:
        #  mask = np.zeros((5, 5), dtype=np.uint8)
        #  mask[2, 2] = 100
        #  kernel = ndimage.gaussian_filter(mask, 0.4, mode="mirror")
        mask = np.float64([
            [0,  0,  0,  0,  0],
            [0,  0,  3,  0,  0],
            [0,  3, 83,  3,  0],
            [0,  0,  3,  0,  0],
            [0,  0,  0,  0,  0]
        ])

        # uint, int
        uint_dts = [np.uint8, np.uint16, np.uint32]
        int_dts = [np.int8, np.int16, np.int32]
        for dtype in uint_dts + int_dts:
            image = np.zeros((5, 5), dtype=dtype)
            image[2, 2] = 100
            image_aug = aug.augment_image(image)
            expected = mask.astype(dtype)
            diff = np.abs(image_aug.astype(np.int64)
                          - expected.astype(np.int64))
            assert image_aug.shape == mask.shape
            assert image_aug.dtype.type == dtype
            assert np.max(diff) <= 4

        # float
        float_dts = [np.float16, np.float32, np.float64]
        for dtype in float_dts:
            image = np.zeros((5, 5), dtype=dtype)
            image[2, 2] = 100.0
            image_aug = aug.augment_image(image)
            expected = mask.astype(dtype)
            diff = np.abs(image_aug.astype(np.float128)
</source>
</class>

<class classid="109" nclones="3" nlines="10" similarity="72">
<source file="systems/imgaug-0.4.0/test/augmenters/test_blur.py" startline="807" endline="818" pcid="2331">
            assert image_aug.dtype.type == dtype
            # accepts difference of 2.0, 4.0, 8.0, 16.0 (at 1, 2, 4, 8 bytes,
            # i.e. 8, 16, 32, 64 bit)
            max_diff = np.dtype(dtype).itemsize * 0.01 * np.float128(value)
            assert np.max(diff) < max_diff

    def test_failure_on_invalid_dtypes(self):
        # assert failure on invalid dtypes
        aug = iaa.GaussianBlur(sigma=1.0)
        for dt in [np.float128]:
            got_exception = False
            try:
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_convolutional.py" startline="386" endline="398" pcid="2419">

    def test_failure_on_invalid_dtypes(self):
        # don't use assertRaisesRegex, because it doesnt exist in 2.7
        identity_matrix = np.int64([[1]])
        aug = iaa.Convolve(matrix=identity_matrix)
        for dt in [np.uint32, np.uint64, np.int32, np.int64]:
            got_exception = False
            try:
                _ = aug.augment_image(np.zeros((1, 1), dtype=dt))
            except Exception as exc:
                assert "forbidden dtype" in str(exc)
                got_exception = True
            assert got_exception
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blur.py" startline="1188" endline="1199" pcid="2348">
            expected = (mask * value).astype(dtype)
            diff = np.abs(image_aug.astype(np.float128)
                          - expected.astype(np.float128))
            assert image_aug.dtype.type == dtype
            # accepts difference of 2.0, 4.0, 8.0, 16.0 (at 1, 2, 4, 8 bytes,
            # i.e. 8, 16, 32, 64 bit)
            assert np.max(diff) < 2**(1 + np.dtype(dtype).itemsize)

    def test_failure_on_invalid_dtypes(self):
        # assert failure on invalid dtypes
        aug = iaa.AverageBlur(k=3)
        for dt in [np.uint32, np.uint64, np.int32, np.int64]:
</source>
</class>

<class classid="110" nclones="3" nlines="16" similarity="77">
<source file="systems/imgaug-0.4.0/test/augmenters/test_blur.py" startline="906" endline="922" pcid="2338">
    def test_kernel_size_5(self):
        # k=5
        aug = iaa.AverageBlur(k=5)
        observed = aug.augment_image(self.base_img)
        assert np.array_equal(observed, self.blur5x5)

    def test_kernel_size_is_tuple(self):
        # k as (3, 4)
        aug = iaa.AverageBlur(k=(3, 4))
        nb_iterations = 100
        nb_seen = [0, 0]
        for i in sm.xrange(nb_iterations):
            observed = aug.augment_image(self.base_img)
            if np.array_equal(observed, self.blur3x3):
                nb_seen[0] += 1
            elif np.array_equal(observed, self.blur4x4):
                nb_seen[1] += 1
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blur.py" startline="923" endline="942" pcid="2339">
            else:
                raise Exception("Unexpected result in AverageBlur@1")
        p_seen = [v/nb_iterations for v in nb_seen]
        assert 0.4 <= p_seen[0] <= 0.6
        assert 0.4 <= p_seen[1] <= 0.6

    def test_kernel_size_is_tuple_with_wider_range(self):
        # k as (3, 5)
        aug = iaa.AverageBlur(k=(3, 5))
        nb_iterations = 200
        nb_seen = [0, 0, 0]
        for i in sm.xrange(nb_iterations):
            observed = aug.augment_image(self.base_img)
            if np.array_equal(observed, self.blur3x3):
                nb_seen[0] += 1
            elif np.array_equal(observed, self.blur4x4):
                nb_seen[1] += 1
            elif np.array_equal(observed, self.blur5x5):
                nb_seen[2] += 1
            else:
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blur.py" startline="943" endline="959" pcid="2340">
                raise Exception("Unexpected result in AverageBlur@2")
        p_seen = [v/nb_iterations for v in nb_seen]
        assert 0.23 <= p_seen[0] <= 0.43
        assert 0.23 <= p_seen[1] <= 0.43
        assert 0.23 <= p_seen[2] <= 0.43

    def test_kernel_size_is_stochastic_parameter(self):
        # k as stochastic parameter
        aug = iaa.AverageBlur(k=iap.Choice([3, 5]))
        nb_iterations = 100
        nb_seen = [0, 0]
        for i in sm.xrange(nb_iterations):
            observed = aug.augment_image(self.base_img)
            if np.array_equal(observed, self.blur3x3):
                nb_seen[0] += 1
            elif np.array_equal(observed, self.blur5x5):
                nb_seen[1] += 1
</source>
</class>

<class classid="111" nclones="2" nlines="14" similarity="78">
<source file="systems/imgaug-0.4.0/test/augmenters/test_blur.py" startline="1262" endline="1277" pcid="2355">
        assert np.array_equal(observed, self.blur3x3)

    def test_k_is_5(self):
        # k=5
        aug = iaa.MedianBlur(k=5)
        observed = aug.augment_image(self.base_img)
        assert np.array_equal(observed, self.blur5x5)

    def test_k_is_tuple(self):
        # k as (3, 5)
        aug = iaa.MedianBlur(k=(3, 5))
        seen = [False, False]
        for i in sm.xrange(100):
            observed = aug.augment_image(self.base_img)
            if np.array_equal(observed, self.blur3x3):
                seen[0] = True
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blur.py" startline="1278" endline="1293" pcid="2356">
            elif np.array_equal(observed, self.blur5x5):
                seen[1] = True
            else:
                raise Exception("Unexpected result in MedianBlur@1")
            if all(seen):
                break
        assert np.all(seen)

    def test_k_is_stochastic_parameter(self):
        # k as stochastic parameter
        aug = iaa.MedianBlur(k=iap.Choice([3, 5]))
        seen = [False, False]
        for i in sm.xrange(100):
            observed = aug.augment_image(self.base_img)
            if np.array_equal(observed, self.blur3x3):
                seen[0] += True
</source>
</class>

<class classid="112" nclones="5" nlines="16" similarity="75">
<source file="systems/imgaug-0.4.0/test/augmenters/test_blur.py" startline="1377" endline="1396" pcid="2365">
        aug = iaa.BilateralBlur((1, 11), seed=1)
        runtest_pickleable_uint8_img(aug, iterations=10)


class TestMotionBlur(unittest.TestCase):
    def setUp(self):
        reseed()

    def test_simple_parameters(self):
        # simple scenario
        aug = iaa.MotionBlur(k=3, angle=0, direction=0.0)
        matrix_func = aug.matrix
        matrices = [
            matrix_func(
                np.zeros((128, 128, 3), dtype=np.uint8),
                3,
                iarandom.RNG(i)
            ) for i in range(10)
        ]
        expected = np.float32([
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blur.py" startline="1547" endline="1566" pcid="2373">

    # TODO extend this to test sampled kernel sizes
    def test_k_is_tuple(self):
        # no error in case of (a, b), checks for #215
        aug = iaa.MotionBlur(k=(3, 7))
        for _ in range(10):
            _ = aug.augment_image(np.zeros((11, 11, 3), dtype=np.uint8))

    def test_direction_is_1(self):
        # direction 1.0
        aug = iaa.MotionBlur(k=3, angle=0, direction=1.0)
        matrix_func = aug.matrix
        matrices = [
            matrix_func(
                np.zeros((128, 128, 3), dtype=np.uint8),
                3,
                iarandom.RNG(i)
            ) for i in range(10)
        ]
        expected = np.float32([
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blur.py" startline="1397" endline="1416" pcid="2366">
            [0, 1.0/3, 0],
            [0, 1.0/3, 0],
            [0, 1.0/3, 0]
        ])
        for matrices_image in matrices:
            for matrix_channel in matrices_image:
                assert np.allclose(matrix_channel, expected)

    def test_simple_parameters_angle_is_90(self):
        # 90deg angle
        aug = iaa.MotionBlur(k=3, angle=90, direction=0.0)
        matrix_func = aug.matrix
        matrices = [
            matrix_func(
                np.zeros((128, 128, 3), dtype=np.uint8),
                3,
                iarandom.RNG(i)
            ) for i in range(10)
        ]
        expected = np.float32([
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blur.py" startline="1417" endline="1436" pcid="2367">
            [0, 0, 0],
            [1.0/3, 1.0/3, 1.0/3],
            [0, 0, 0]
        ])
        for matrices_image in matrices:
            for matrix_channel in matrices_image:
                assert np.allclose(matrix_channel, expected)

    def test_simple_parameters_angle_is_45(self):
        # 45deg angle
        aug = iaa.MotionBlur(k=3, angle=45, direction=0.0, order=0)
        matrix_func = aug.matrix
        matrices = [
            matrix_func(
                np.zeros((128, 128, 3), dtype=np.uint8),
                3,
                iarandom.RNG(i)
            ) for i in range(10)
        ]
        expected = np.float32([
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blur.py" startline="1567" endline="1586" pcid="2374">
            [0, 1.0/1.5, 0],
            [0, 0.5/1.5, 0],
            [0, 0.0/1.5, 0]
        ])
        for matrices_image in matrices:
            for matrix_channel in matrices_image:
                assert np.allclose(matrix_channel, expected, rtol=0, atol=1e-2)

    def test_direction_is_minus_1(self):
        # direction -1.0
        aug = iaa.MotionBlur(k=3, angle=0, direction=-1.0)
        matrix_func = aug.matrix
        matrices = [
            matrix_func(
                np.zeros((128, 128, 3), dtype=np.uint8),
                3,
                iarandom.RNG(i)
            ) for i in range(10)
        ]
        expected = np.float32([
</source>
</class>

<class classid="113" nclones="2" nlines="13" similarity="84">
<source file="systems/imgaug-0.4.0/test/augmenters/test_convolutional.py" startline="136" endline="151" pcid="2403">
    def test_matrix_is_3x3_with_multiple_nonzero_values(self):
        m = np.float32([
            [0, -1, 0],
            [0, 10, 0],
            [0, 0, 0]
        ])
        expected = np.uint8([
            [10*1+(-1)*4, 10*2+(-1)*5, 10*3+(-1)*6],
            [10*4+(-1)*1, 10*5+(-1)*2, 10*6+(-1)*3],
            [10*7+(-1)*4, 10*8+(-1)*5, 10*9+(-1)*6]
        ])

        aug = iaa.Convolve(matrix=m)
        observed = aug.augment_image(self.img)
        assert np.array_equal(observed, expected)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_convolutional.py" startline="152" endline="169" pcid="2404">
    def test_matrix_is_lambda_3x3_with_multiple_nonzero_values(self):
        def _matrix_generator(_img, _nb_channels, _random_state):
            return np.float32([
                [0, -1, 0],
                [0, 10, 0],
                [0, 0, 0]
            ])

        expected = np.uint8([
            [10*1+(-1)*4, 10*2+(-1)*5, 10*3+(-1)*6],
            [10*4+(-1)*1, 10*5+(-1)*2, 10*6+(-1)*3],
            [10*7+(-1)*4, 10*8+(-1)*5, 10*9+(-1)*6]
        ])

        aug = iaa.Convolve(matrix=_matrix_generator)
        observed = aug.augment_image(self.img)
        assert np.array_equal(observed, expected)

</source>
</class>

<class classid="114" nclones="3" nlines="10" similarity="70">
<source file="systems/imgaug-0.4.0/test/augmenters/test_convolutional.py" startline="498" endline="509" pcid="2433">

    def test_alpha_is_stochastic_parameter(self):
        aug = iaa.Sharpen(alpha=iap.Choice([0.5, 1.0]), lightness=1)
        observed = aug.augment_image(self.base_img)
        expected1 = self._compute_sharpened_base_img(
            0.5*1, 0.5 * self.m_noop + 0.5 * self.m)
        expected2 = self._compute_sharpened_base_img(
            1.0*1, 0.0 * self.m_noop + 1.0 * self.m)
        assert (
            np.allclose(observed, expected1)
            or np.allclose(observed, expected2)
        )
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_convolutional.py" startline="773" endline="784" pcid="2453">

    def test_alpha_1_strength_stochastic_parameter(self):
        aug = iaa.Emboss(alpha=1.0, strength=iap.Choice([1.0, 2.5]))
        observed = aug.augment_image(self.base_img)
        expected1 = self._compute_embossed_base_img(
            self.base_img, alpha=1.0, strength=1.0)
        expected2 = self._compute_embossed_base_img(
            self.base_img, alpha=1.0, strength=2.5)
        assert (
            self._allclose(observed, expected1)
            or self._allclose(observed, expected2)
        )
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_convolutional.py" startline="730" endline="741" pcid="2448">

    def test_alpha_stochastic_parameter_strength_1(self):
        aug = iaa.Emboss(alpha=iap.Choice([0.5, 1.0]), strength=1)
        observed = aug.augment_image(self.base_img)
        expected1 = self._compute_embossed_base_img(
            self.base_img, alpha=0.5, strength=1)
        expected2 = self._compute_embossed_base_img(
            self.base_img, alpha=1.0, strength=1)
        assert (
            self._allclose(observed, expected1)
            or self._allclose(observed, expected2)
        )
</source>
</class>

<class classid="115" nclones="2" nlines="10" similarity="100">
<source file="systems/imgaug-0.4.0/test/augmenters/test_overlay.py" startline="40" endline="54" pcid="2457">
    def test_warns_that_it_is_deprecated(self):
        children_fg = iaa.Identity()
        factor = 1

        with warnings.catch_warnings(record=True) as caught_warnings:
            warnings.simplefilter("always")
            _ = overlay.Alpha(factor, children_fg)

        assert len(caught_warnings) == 2
        assert (
            "imgaug.augmenters.blend.BlendAlpha"
            in str(caught_warnings[0].message)
        )


</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_overlay.py" startline="56" endline="70" pcid="2458">
    def test_warns_that_it_is_deprecated(self):
        children_fg = iaa.Identity()
        factor = 1

        with warnings.catch_warnings(record=True) as caught_warnings:
            warnings.simplefilter("always")
            _ = overlay.AlphaElementwise(factor, children_fg)

        assert len(caught_warnings) == 2
        assert (
            "imgaug.augmenters.blend.BlendAlphaElementwise"
            in str(caught_warnings[0].message)
        )


</source>
</class>

<class classid="116" nclones="2" nlines="11" similarity="72">
<source file="systems/imgaug-0.4.0/test/augmenters/test_flip.py" startline="189" endline="199" pcid="2494">
    def test_heatmaps_p_is_0(self):
        aug = self.create_aug(0)
        heatmaps = self.heatmaps
        observed = aug.augment_heatmaps(heatmaps)
        assert observed.shape == heatmaps.shape
        assert np.isclose(observed.min_value, heatmaps.min_value,
                          rtol=0, atol=1e-6)
        assert np.isclose(observed.max_value, heatmaps.max_value,
                          rtol=0, atol=1e-6)
        assert np.array_equal(observed.get_arr(), heatmaps.get_arr())

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_flip.py" startline="264" endline="275" pcid="2507">
    def test_heatmaps_p_is_1(self):
        aug = self.create_aug(1.0)
        heatmaps = self.heatmaps
        observed = aug.augment_heatmaps(heatmaps)
        assert observed.shape == heatmaps.shape
        assert np.isclose(observed.min_value, heatmaps.min_value,
                          rtol=0, atol=1e-6)
        assert np.isclose(observed.max_value, heatmaps.max_value,
                          rtol=0, atol=1e-6)
        assert np.array_equal(observed.get_arr(),
                              self.heatmaps_flipped.get_arr())

</source>
</class>

<class classid="117" nclones="2" nlines="12" similarity="75">
<source file="systems/imgaug-0.4.0/test/augmenters/test_flip.py" startline="368" endline="381" pcid="2521">
    def test_list_of_images_p_is_050(self):
        images_multi = [self.image, self.image]
        aug = self.create_aug(0.5)
        nb_iterations = 1000
        nb_flipped_by_pos = [0] * len(images_multi)
        for _ in sm.xrange(nb_iterations):
            observed = aug.augment_images(images_multi)
            for i in sm.xrange(len(images_multi)):
                if np.array_equal(observed[i], self.image_flipped):
                    nb_flipped_by_pos[i] += 1

        assert np.allclose(nb_flipped_by_pos,
                           500, rtol=0, atol=100)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_flip.py" startline="382" endline="395" pcid="2522">
    def test_list_of_images_p_is_050__deterministic(self):
        images_multi = [self.image, self.image]
        aug = self.create_aug(0.5).to_deterministic()
        nb_iterations = 10
        nb_flipped_by_pos_det = [0] * len(images_multi)
        for _ in sm.xrange(nb_iterations):
            observed = aug.augment_images(images_multi)
            for i in sm.xrange(len(images_multi)):
                if np.array_equal(observed[i], self.image_flipped):
                    nb_flipped_by_pos_det[i] += 1

        for val in nb_flipped_by_pos_det:
            assert val in [0, nb_iterations]

</source>
</class>

<class classid="118" nclones="2" nlines="21" similarity="100">
<source file="systems/imgaug-0.4.0/test/augmenters/test_flip.py" startline="774" endline="799" pcid="2579">
    @classmethod
    def _test__fliplr_subfunc_n_channels(cls, func, nb_channels):
        arr = np.uint8([
            [0, 1, 2, 3],
            [4, 5, 6, 7],
            [10, 11, 12, 13]
        ])
        if nb_channels is not None:
            arr = np.tile(arr[..., np.newaxis], (1, 1, nb_channels))
            for c in sm.xrange(nb_channels):
                arr[..., c] += c

        arr_flipped = func(arr)

        expected = np.uint8([
            [3, 2, 1, 0],
            [7, 6, 5, 4],
            [13, 12, 11, 10]
        ])
        if nb_channels is not None:
            expected = np.tile(expected[..., np.newaxis], (1, 1, nb_channels))
            for c in sm.xrange(nb_channels):
                expected[..., c] += c
        assert arr_flipped.dtype.name == "uint8"
        assert arr_flipped.shape == arr.shape
        assert np.array_equal(arr_flipped, expected)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_flip.py" startline="959" endline="984" pcid="2597">
    @classmethod
    def _test__flipud_subfunc_n_channels(cls, func, nb_channels):
        arr = np.uint8([
            [0, 1, 2, 3],
            [4, 5, 6, 7],
            [10, 11, 12, 13]
        ])
        if nb_channels is not None:
            arr = np.tile(arr[..., np.newaxis], (1, 1, nb_channels))
            for c in sm.xrange(nb_channels):
                arr[..., c] += c

        arr_flipped = func(arr)

        expected = np.uint8([
            [10, 11, 12, 13],
            [4, 5, 6, 7],
            [0, 1, 2, 3]
        ])
        if nb_channels is not None:
            expected = np.tile(expected[..., np.newaxis], (1, 1, nb_channels))
            for c in sm.xrange(nb_channels):
                expected[..., c] += c
        assert arr_flipped.dtype.name == "uint8"
        assert arr_flipped.shape == arr.shape
        assert np.array_equal(arr_flipped, expected)
</source>
</class>

<class classid="119" nclones="2" nlines="17" similarity="100">
<source file="systems/imgaug-0.4.0/test/augmenters/test_flip.py" startline="818" endline="837" pcid="2583">

    def test_513_channels_arr_cv2(self):
        arr = np.zeros((1, 2, 513), dtype=np.uint8)
        arr[:, 0, :] = 0
        arr[:, 1, :] = 255
        arr[0, 0, 0] = 1
        arr[0, 1, 0] = 254
        arr[0, 0, 512] = 2
        arr[0, 1, 512] = 253

        arr_flipped = fliplib._fliplr_cv2(arr)

        assert arr_flipped.dtype.name == "uint8"
        assert arr_flipped.shape == (1, 2, 513)
        assert arr_flipped[0, 1, 0] == 1
        assert arr_flipped[0, 0, 0] == 254
        assert arr_flipped[0, 1, 512] == 2
        assert arr_flipped[0, 0, 512] == 253
        assert np.all(arr_flipped[0, 0, 1:-2] == 255)
        assert np.all(arr_flipped[0, 1, 1:-2] == 0)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_flip.py" startline="856" endline="875" pcid="2587">

    def test_513_channels_arr_sliced(self):
        arr = np.zeros((1, 2, 513), dtype=np.uint8)
        arr[:, 0, :] = 0
        arr[:, 1, :] = 255
        arr[0, 0, 0] = 1
        arr[0, 1, 0] = 254
        arr[0, 0, 512] = 2
        arr[0, 1, 512] = 253

        arr_flipped = fliplib._fliplr_sliced(arr)

        assert arr_flipped.dtype.name == "uint8"
        assert arr_flipped.shape == (1, 2, 513)
        assert arr_flipped[0, 1, 0] == 1
        assert arr_flipped[0, 0, 0] == 254
        assert arr_flipped[0, 1, 512] == 2
        assert arr_flipped[0, 0, 512] == 253
        assert np.all(arr_flipped[0, 0, 1:-2] == 255)
        assert np.all(arr_flipped[0, 1, 1:-2] == 0)
</source>
</class>

<class classid="120" nclones="4" nlines="14" similarity="78">
<source file="systems/imgaug-0.4.0/test/augmenters/test_flip.py" startline="884" endline="900" pcid="2589">

    def test_uint_int_faithful(self):
        dts = ["uint8", "uint16", "uint32", "uint64",
               "int8", "int16", "int32", "int64"]
        for dt in dts:
            with self.subTest(dtype=dt):
                dt = np.dtype(dt)
                minv, center, maxv = iadt.get_value_range_of_dtype(dt)
                center = int(center)
                arr = np.array([[minv, center, maxv]], dtype=dt)

                arr_flipped = fliplib.fliplr(arr)

                expected = np.array([[maxv, center, minv]], dtype=dt)
                assert arr_flipped.dtype.name == dt.name
                assert arr_flipped.shape == (1, 3)
                assert np.array_equal(arr_flipped, expected)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_flip.py" startline="901" endline="917" pcid="2590">

    def test_float_faithful_to_min_max(self):
        dts = ["float16", "float32", "float64", "float128"]
        for dt in dts:
            with self.subTest(dtype=dt):
                dt = np.dtype(dt)
                minv, center, maxv = iadt.get_value_range_of_dtype(dt)
                center = int(center)
                atol = 1e-4 if dt.name == "float16" else 1e-8
                arr = np.array([[minv, center, maxv]], dtype=dt)

                arr_flipped = fliplib.fliplr(arr)

                expected = np.array([[maxv, center, minv]], dtype=dt)
                assert arr_flipped.dtype.name == dt.name
                assert arr_flipped.shape == (1, 3)
                assert np.allclose(arr_flipped, expected, rtol=0, atol=atol)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_flip.py" startline="1011" endline="1027" pcid="2602">

    def test_uint_int_faithful(self):
        dts = ["uint8", "uint16", "uint32", "uint64",
               "int8", "int16", "int32", "int64"]
        for dt in dts:
            with self.subTest(dtype=dt):
                dt = np.dtype(dt)
                minv, center, maxv = iadt.get_value_range_of_dtype(dt)
                center = int(center)
                arr = np.array([[minv], [center], [maxv]], dtype=dt)

                arr_flipped = fliplib.flipud(arr)

                expected = np.array([[maxv], [center], [minv]], dtype=dt)
                assert arr_flipped.dtype.name == dt.name
                assert arr_flipped.shape == (3, 1)
                assert np.array_equal(arr_flipped, expected)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_flip.py" startline="1028" endline="1044" pcid="2603">

    def test_float_faithful_to_min_max(self):
        dts = ["float16", "float32", "float64", "float128"]
        for dt in dts:
            with self.subTest(dtype=dt):
                dt = np.dtype(dt)
                minv, center, maxv = iadt.get_value_range_of_dtype(dt)
                center = int(center)
                atol = 1e-4 if dt.name == "float16" else 1e-8
                arr = np.array([[minv], [center], [maxv]], dtype=dt)

                arr_flipped = fliplib.flipud(arr)

                expected = np.array([[maxv], [center], [minv]], dtype=dt)
                assert arr_flipped.dtype.name == dt.name
                assert arr_flipped.shape == (3, 1)
                assert np.allclose(arr_flipped, expected, rtol=0, atol=atol)
</source>
</class>

<class classid="121" nclones="2" nlines="20" similarity="90">
<source file="systems/imgaug-0.4.0/test/augmenters/test_flip.py" startline="918" endline="941" pcid="2591">

    def test_float_faithful_to_large_values(self):
        dts = ["float16", "float32", "float64", "float128"]
        values = [
            [0.01, 0.1, 1.0, 10.0**1, 10.0**2],  # float16
            [0.01, 0.1, 1.0, 10.0**1, 10.0**2, 10.0**4, 10.0**6],  # float32
            [0.01, 0.1, 1.0, 10.0**1, 10.0**2, 10.0**6, 10.0**10],  # float64
            [0.01, 0.1, 1.0, 10.0**1, 10.0**2, 10.0**7, 10.0**11],  # float128
        ]
        for dt, values_i in zip(dts, values):
            for value in values_i:
                with self.subTest(dtype=dt, value=value):
                    dt = np.dtype(dt)
                    minv, center, maxv = -value, 0.0, value
                    atol = 1e-4 if dt.name == "float16" else 1e-8
                    arr = np.array([[minv, center, maxv]], dtype=dt)

                    arr_flipped = fliplib.fliplr(arr)

                    expected = np.array([[maxv, center, minv]], dtype=dt)
                    assert arr_flipped.dtype.name == dt.name
                    assert arr_flipped.shape == (1, 3)
                    assert np.allclose(arr_flipped, expected, rtol=0, atol=atol)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_flip.py" startline="1045" endline="1066" pcid="2604">

    def test_float_faithful_to_large_values(self):
        dts = ["float16", "float32", "float64", "float128"]
        values = [
            [0.01, 0.1, 1.0, 10.0**1, 10.0**2],  # float16
            [0.01, 0.1, 1.0, 10.0**1, 10.0**2, 10.0**4, 10.0**6],  # float32
            [0.01, 0.1, 1.0, 10.0**1, 10.0**2, 10.0**6, 10.0**10],  # float64
            [0.01, 0.1, 1.0, 10.0**1, 10.0**2, 10.0**7, 10.0**11],  # float128
        ]
        for dt, values_i in zip(dts, values):
            for value in values_i:
                with self.subTest(dtype=dt, value=value):
                    dt = np.dtype(dt)
                    minv, center, maxv = -value, 0.0, value
                    atol = 1e-4 if dt.name == "float16" else 1e-8
                    arr = np.array([[minv], [center], [maxv]], dtype=dt)

                    arr_flipped = fliplib.flipud(arr)

                    expected = np.array([[maxv], [center], [minv]], dtype=dt)
                    assert arr_flipped.dtype.name == dt.name
                    assert arr_flipped.shape == (3, 1)
</source>
</class>

<class classid="122" nclones="6" nlines="10" similarity="75">
<source file="systems/imgaug-0.4.0/test/augmenters/test_pooling.py" startline="152" endline="165" pcid="2622">
    def _test_augment_heatmaps__kernel_size_is_noop(self, kernel_size):
        from imgaug.augmentables.heatmaps import HeatmapsOnImage
        arr = np.float32([
            [0.5, 0.6, 0.7],
            [0.4, 0.5, 0.6]
        ])
        heatmaps = HeatmapsOnImage(arr, shape=(6, 6, 3))
        aug = self.augmenter(kernel_size)

        heatmaps_aug = aug.augment_heatmaps(heatmaps)

        assert heatmaps_aug.shape == (6, 6, 3)
        assert np.allclose(heatmaps_aug.arr_0to1, arr[..., np.newaxis])

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_pooling.py" startline="275" endline="288" pcid="2638">
    def test_augment_heatmaps__kernel_size_is_two__keep_size(self):
        from imgaug.augmentables.heatmaps import HeatmapsOnImage
        arr = np.float32([
            [0.5, 0.6, 0.7],
            [0.4, 0.5, 0.6]
        ])
        heatmaps = HeatmapsOnImage(arr, shape=(6, 6, 3))
        aug = self.augmenter(2, keep_size=True)

        heatmaps_aug = aug.augment_heatmaps(heatmaps)

        assert heatmaps_aug.shape == (6, 6, 3)
        assert np.allclose(heatmaps_aug.arr_0to1, arr[..., np.newaxis])

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_pooling.py" startline="172" endline="185" pcid="2625">
    def _test_augment_segmaps__kernel_size_is_noop(self, kernel_size):
        from imgaug.augmentables.segmaps import SegmentationMapsOnImage
        arr = np.int32([
            [0, 1, 2],
            [1, 2, 3]
        ])
        segmaps = SegmentationMapsOnImage(arr, shape=(6, 6, 3))
        aug = self.augmenter(kernel_size)

        segmaps_aug = aug.augment_segmentation_maps(segmaps)

        assert segmaps_aug.shape == (6, 6, 3)
        assert np.allclose(segmaps_aug.arr, arr[..., np.newaxis])

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_pooling.py" startline="289" endline="304" pcid="2639">
    def test_augment_heatmaps__kernel_size_is_two__no_keep_size(self):
        from imgaug.augmentables.heatmaps import HeatmapsOnImage
        arr = np.float32([
            [0.5, 0.6, 0.7],
            [0.4, 0.5, 0.6]
        ])
        heatmaps = HeatmapsOnImage(arr, shape=(6, 6, 3))
        aug = self.augmenter(2, keep_size=False)

        heatmaps_aug = aug.augment_heatmaps(heatmaps)

        expected = heatmaps.resize((1, 2))
        assert heatmaps_aug.shape == (3, 3, 3)
        assert heatmaps_aug.arr_0to1.shape == (1, 2, 1)
        assert np.allclose(heatmaps_aug.arr_0to1, expected.arr_0to1)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_pooling.py" startline="305" endline="318" pcid="2640">
    def test_augment_segmaps__kernel_size_is_two__keep_size(self):
        from imgaug.augmentables.segmaps import SegmentationMapsOnImage
        arr = np.int32([
            [0, 1, 2],
            [1, 2, 3]
        ])
        segmaps = SegmentationMapsOnImage(arr, shape=(6, 6, 3))
        aug = self.augmenter(2, keep_size=True)

        segmaps_aug = aug.augment_segmentation_maps(segmaps)

        assert segmaps_aug.shape == (6, 6, 3)
        assert np.allclose(segmaps_aug.arr, arr[..., np.newaxis])

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_pooling.py" startline="319" endline="334" pcid="2641">
    def test_augment_segmaps__kernel_size_is_two__no_keep_size(self):
        from imgaug.augmentables.segmaps import SegmentationMapsOnImage
        arr = np.int32([
            [0, 1, 2],
            [1, 2, 3]
        ])
        segmaps = SegmentationMapsOnImage(arr, shape=(6, 6, 3))
        aug = self.augmenter(2, keep_size=False)

        segmaps_aug = aug.augment_segmentation_maps(segmaps)

        expected = segmaps.resize((1, 2))
        assert segmaps_aug.shape == (3, 3, 3)
        assert segmaps_aug.arr.shape == (1, 2, 1)
        assert np.allclose(segmaps_aug.arr, expected.arr)

</source>
</class>

<class classid="123" nclones="2" nlines="15" similarity="100">
<source file="systems/imgaug-0.4.0/test/augmenters/test_pooling.py" startline="360" endline="378" pcid="2645">
    def _test_augment_polygons__kernel_size_differs(self, shape, shape_exp):
        from imgaug.augmentables.polys import Polygon, PolygonsOnImage
        polys = [Polygon([(1.5, 5.5), (5.5, 1.5), (5.5, 5.5)])]
        psoi = PolygonsOnImage(polys, shape=shape)
        aug = self.augmenter(
            (iap.Deterministic(3), iap.Deterministic(2)),
            keep_size=False)

        psoi_aug = aug.augment_polygons(psoi)

        expected = PolygonsOnImage(
            [Polygon([
                ((1.5/shape[1])*shape_exp[1], (5.5/shape[0])*shape_exp[0]),
                ((5.5/shape[1])*shape_exp[1], (1.5/shape[0])*shape_exp[0]),
                ((5.5/shape[1])*shape_exp[1], (5.5/shape[0])*shape_exp[0])
            ])],
            shape=shape_exp)
        assert_cbaois_equal(psoi_aug, expected)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_pooling.py" startline="385" endline="403" pcid="2648">
    def _test_augment_line_strings__kernel_size_differs(self, shape, shape_exp):
        from imgaug.augmentables.lines import LineString, LineStringsOnImage
        ls = [LineString([(1.5, 5.5), (5.5, 1.5), (5.5, 5.5)])]
        lsoi = LineStringsOnImage(ls, shape=shape)
        aug = self.augmenter(
            (iap.Deterministic(3), iap.Deterministic(2)),
            keep_size=False)

        lsoi_aug = aug.augment_line_strings(lsoi)

        expected = LineStringsOnImage(
            [LineString([
                ((1.5/shape[1])*shape_exp[1], (5.5/shape[0])*shape_exp[0]),
                ((5.5/shape[1])*shape_exp[1], (1.5/shape[0])*shape_exp[0]),
                ((5.5/shape[1])*shape_exp[1], (5.5/shape[0])*shape_exp[0])
            ])],
            shape=shape_exp)
        assert_cbaois_equal(lsoi_aug, expected)

</source>
</class>

<class classid="124" nclones="4" nlines="10" similarity="70">
<source file="systems/imgaug-0.4.0/test/augmenters/test_pooling.py" startline="485" endline="496" pcid="2656">
    def test_keypoint_alignment(self):
        from imgaug.augmentables.kps import Keypoint, KeypointsOnImage
        kps = [Keypoint(x=10, y=10), Keypoint(x=30, y=30)]
        kpsoi = KeypointsOnImage(kps, shape=(40, 40, 1))
        kpsoi_empty = KeypointsOnImage([], shape=(40, 40, 1))

        self._test_cbaoi_alignment(
            kpsoi, kpsoi_empty,
            [[(5, 5)], [(15, 15)]],
            [[(10, 10)], [(30, 30)]],
            "augment_keypoints")

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_pooling.py" startline="497" endline="508" pcid="2657">
    def test_polygon_alignment(self):
        from imgaug.augmentables.polys import Polygon, PolygonsOnImage
        polys = [Polygon([(10, 10), (30, 10), (30, 30)])]
        psoi = PolygonsOnImage(polys, shape=(40, 40, 1))
        psoi_empty = PolygonsOnImage([], shape=(40, 40, 1))

        self._test_cbaoi_alignment(
            psoi, psoi_empty,
            [[(10/2, 10/2), (30/2, 10/2), (30/2, 30/2)]],
            [[(10, 10), (30, 10), (30, 30)]],
            "augment_polygons")

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_pooling.py" startline="521" endline="532" pcid="2659">
    def test_bounding_boxes_alignment(self):
        from imgaug.augmentables.bbs import BoundingBox, BoundingBoxesOnImage
        bbs = [BoundingBox(x1=10, y1=10, x2=30, y2=30)]
        bbsoi = BoundingBoxesOnImage(bbs, shape=(40, 40, 1))
        bbsoi_empty = BoundingBoxesOnImage([], shape=(40, 40, 1))

        self._test_cbaoi_alignment(
            bbsoi, bbsoi_empty,
            [[(10/2, 10/2), (30/2, 30/2)]],
            [[(10, 10), (30, 30)]],
            "augment_bounding_boxes")

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_pooling.py" startline="509" endline="520" pcid="2658">
    def test_line_strings_alignment(self):
        from imgaug.augmentables.lines import LineString, LineStringsOnImage
        lss = [LineString([(10, 10), (30, 10), (30, 30)])]
        lsoi = LineStringsOnImage(lss, shape=(40, 40, 1))
        lsoi_empty = LineStringsOnImage([], shape=(40, 40, 1))

        self._test_cbaoi_alignment(
            lsoi, lsoi_empty,
            [[(10/2, 10/2), (30/2, 10/2), (30/2, 30/2)]],
            [[(10, 10), (30, 10), (30, 30)]],
            "augment_line_strings")

</source>
</class>

<class classid="125" nclones="7" nlines="14" similarity="78">
<source file="systems/imgaug-0.4.0/test/augmenters/test_pooling.py" startline="660" endline="679" pcid="2676">
    def test_augment_images__kernel_size_is_two__custom_array(self):
        aug = iaa.AveragePooling(2, keep_size=False)

        image = np.uint8([
            [50-2, 50-1, 120-4, 120+4],
            [50+1, 50+2, 120+1, 120-1]
        ])
        image = np.tile(image[:, :, np.newaxis], (1, 1, 3))

        expected = np.uint8([
            [50, 120]
        ])
        expected = np.tile(expected[:, :, np.newaxis], (1, 1, 3))

        image_aug = aug.augment_image(image)
        diff = np.abs(image_aug.astype(np.int32) - expected)
        assert image_aug.dtype.name == "uint8"
        assert image_aug.shape == (1, 2, 3)
        assert np.all(diff <= 1)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_pooling.py" startline="802" endline="820" pcid="2683">
    def test_augment_images(self):
        aug = iaa.MaxPooling(2, keep_size=False)

        image = np.uint8([
            [50-2, 50-1, 120-4, 120+4],
            [50+1, 50+2, 120+1, 120-1]
        ])
        image = np.tile(image[:, :, np.newaxis], (1, 1, 3))

        expected = np.uint8([
            [50+2, 120+4]
        ])
        expected = np.tile(expected[:, :, np.newaxis], (1, 1, 3))

        image_aug = aug.augment_image(image)
        diff = np.abs(image_aug.astype(np.int32) - expected)
        assert image_aug.shape == (1, 2, 3)
        assert np.all(diff <= 1)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_pooling.py" startline="894" endline="913" pcid="2689">
    def test_augment_images(self):
        aug = iaa.MedianPooling(3, keep_size=False)

        image = np.uint8([
            [50-9, 50-8, 50-7, 120-5, 120-5, 120-5],
            [50-5, 50+0, 50+3, 120-3, 120+0, 120+1],
            [50+8, 50+9, 50+9, 120+2, 120+3, 120+4]
        ])
        image = np.tile(image[:, :, np.newaxis], (1, 1, 3))

        expected = np.uint8([
            [50, 120]
        ])
        expected = np.tile(expected[:, :, np.newaxis], (1, 1, 3))

        image_aug = aug.augment_image(image)
        diff = np.abs(image_aug.astype(np.int32) - expected)
        assert image_aug.shape == (1, 2, 3)
        assert np.all(diff <= 1)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_pooling.py" startline="848" endline="866" pcid="2686">
    def test_augment_images(self):
        aug = iaa.MinPooling(2, keep_size=False)

        image = np.uint8([
            [50-2, 50-1, 120-4, 120+4],
            [50+1, 50+2, 120+1, 120-1]
        ])
        image = np.tile(image[:, :, np.newaxis], (1, 1, 3))

        expected = np.uint8([
            [50-2, 120-4]
        ])
        expected = np.tile(expected[:, :, np.newaxis], (1, 1, 3))

        image_aug = aug.augment_image(image)
        diff = np.abs(image_aug.astype(np.int32) - expected)
        assert image_aug.shape == (1, 2, 3)
        assert np.all(diff <= 1)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_pooling.py" startline="680" endline="699" pcid="2677">
    def test_augment_images__kernel_size_is_two__four_channels(self):
        aug = iaa.AveragePooling(2, keep_size=False)

        image = np.uint8([
            [50-2, 50-1, 120-4, 120+4],
            [50+1, 50+2, 120+1, 120-1]
        ])
        image = np.tile(image[:, :, np.newaxis], (1, 1, 4))

        expected = np.uint8([
            [50, 120]
        ])
        expected = np.tile(expected[:, :, np.newaxis], (1, 1, 4))

        image_aug = aug.augment_image(image)
        diff = np.abs(image_aug.astype(np.int32) - expected)
        assert image_aug.dtype.name == "uint8"
        assert image_aug.shape == (1, 2, 4)
        assert np.all(diff <= 1)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_pooling.py" startline="771" endline="792" pcid="2681">
    def test_augment_images__kernel_size_is_two__single_channel(self):
        aug = iaa.AveragePooling(2, keep_size=False)

        image = np.uint8([
            [50-2, 50-1, 120-4, 120+4],
            [50+1, 50+2, 120+1, 120-1]
        ])
        image = image[:, :, np.newaxis]

        expected = np.uint8([
            [50, 120]
        ])
        expected = expected[:, :, np.newaxis]

        image_aug = aug.augment_image(image)

        diff = np.abs(image_aug.astype(np.int32) - expected)
        assert image_aug.dtype.name == "uint8"
        assert image_aug.shape == (1, 2, 1)
        assert np.all(diff <= 1)


</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_pooling.py" startline="749" endline="770" pcid="2680">
    def test_augment_images__kernel_size_is_two__keep_size(self):
        aug = iaa.AveragePooling(2, keep_size=True)

        image = np.uint8([
            [50-2, 50-1, 120-4, 120+4],
            [50+1, 50+2, 120+1, 120-1]
        ])
        image = np.tile(image[:, :, np.newaxis], (1, 1, 3))

        expected = np.uint8([
            [50, 50, 120, 120],
            [50, 50, 120, 120]
        ])
        expected = np.tile(expected[:, :, np.newaxis], (1, 1, 3))

        image_aug = aug.augment_image(image)

        diff = np.abs(image_aug.astype(np.int32) - expected)
        assert image_aug.dtype.name == "uint8"
        assert image_aug.shape == (2, 4, 3)
        assert np.all(diff <= 1)

</source>
</class>

<class classid="126" nclones="2" nlines="19" similarity="73">
<source file="systems/imgaug-0.4.0/test/augmenters/test_pooling.py" startline="700" endline="722" pcid="2678">
    def test_augment_images__kernel_size_differs(self):
        aug = iaa.AveragePooling(
            (iap.Deterministic(3), iap.Deterministic(2)),
            keep_size=False)

        image = np.uint8([
            [50-2, 50-1, 120-4, 120+4],
            [50+1, 50+2, 120+2, 120-1],
            [50-5, 50+5, 120-2, 120+1],
        ])
        image = np.tile(image[:, :, np.newaxis], (1, 1, 3))

        expected = np.uint8([
            [50, 120]
        ])
        expected = np.tile(expected[:, :, np.newaxis], (1, 1, 3))

        image_aug = aug.augment_image(image)
        diff = np.abs(image_aug.astype(np.int32) - expected)
        assert image_aug.dtype.name == "uint8"
        assert image_aug.shape == (1, 2, 3)
        assert np.all(diff <= 1)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_pooling.py" startline="723" endline="748" pcid="2679">
    def test_augment_images__kernel_size_differs__requires_padding(self):
        aug = iaa.AveragePooling(
            (iap.Deterministic(3), iap.Deterministic(1)),
            keep_size=False)

        image = np.uint8([
            [50-2, 50-1, 120-4, 120+4],
            [50+1, 50+2, 120+2, 120-1]
        ])
        image = np.tile(image[:, :, np.newaxis], (1, 1, 3))

        expected = np.uint8([
            [(50-2 + 50+1 + 50-2)/3,
             (50-1 + 50+2 + 50-1)/3,
             (120-4 + 120+2 + 120-4)/3,
             (120+4 + 120-1 + 120+4)/3]
        ])
        expected = np.tile(expected[:, :, np.newaxis], (1, 1, 3))

        image_aug = aug.augment_image(image)

        diff = np.abs(image_aug.astype(np.int32) - expected)
        assert image_aug.dtype.name == "uint8"
        assert image_aug.shape == (1, 4, 3)
        assert np.all(diff <= 1)

</source>
</class>

<class classid="127" nclones="3" nlines="13" similarity="84">
<source file="systems/imgaug-0.4.0/test/augmenters/test_pooling.py" startline="821" endline="838" pcid="2684">
    def test_augment_images__different_channels(self):
        aug = iaa.MaxPooling((iap.Deterministic(1), iap.Deterministic(4)),
                             keep_size=False)

        c1 = np.arange(start=1, stop=8+1).reshape((1, 8, 1))
        c2 = (100 + np.arange(start=1, stop=8+1)).reshape((1, 8, 1))
        image = np.dstack([c1, c2]).astype(np.uint8)

        c1_expected = np.uint8([4, 8]).reshape((1, 2, 1))
        c2_expected = np.uint8([100+4, 100+8]).reshape((1, 2, 1))
        image_expected = np.dstack([c1_expected, c2_expected])

        image_aug = aug.augment_image(image)
        diff = np.abs(image_aug.astype(np.int32) - image_expected)
        assert image_aug.shape == (1, 2, 2)
        assert np.all(diff <= 1)


</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_pooling.py" startline="867" endline="884" pcid="2687">
    def test_augment_images__different_channels(self):
        aug = iaa.MinPooling((iap.Deterministic(1), iap.Deterministic(4)),
                             keep_size=False)

        c1 = np.arange(start=1, stop=8+1).reshape((1, 8, 1))
        c2 = (100 + np.arange(start=1, stop=8+1)).reshape((1, 8, 1))
        image = np.dstack([c1, c2]).astype(np.uint8)

        c1_expected = np.uint8([1, 5]).reshape((1, 2, 1))
        c2_expected = np.uint8([100+1, 100+4]).reshape((1, 2, 1))
        image_expected = np.dstack([c1_expected, c2_expected])

        image_aug = aug.augment_image(image)
        diff = np.abs(image_aug.astype(np.int32) - image_expected)
        assert image_aug.shape == (1, 2, 2)
        assert np.all(diff <= 1)


</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_pooling.py" startline="914" endline="929" pcid="2690">
    def test_augment_images__different_channels(self):
        aug = iaa.MinPooling((iap.Deterministic(1), iap.Deterministic(3)),
                             keep_size=False)

        c1 = np.arange(start=1, stop=9+1).reshape((1, 9, 1))
        c2 = (100 + np.arange(start=1, stop=9+1)).reshape((1, 9, 1))
        image = np.dstack([c1, c2]).astype(np.uint8)

        c1_expected = np.uint8([2, 5, 8]).reshape((1, 3, 1))
        c2_expected = np.uint8([100+2, 100+5, 100+8]).reshape((1, 3, 1))
        image_expected = np.dstack([c1_expected, c2_expected])

        image_aug = aug.augment_image(image)
        diff = np.abs(image_aug.astype(np.int32) - image_expected)
        assert image_aug.shape == (1, 3, 2)
        assert np.all(diff <= 1)
</source>
</class>

<class classid="128" nclones="2" nlines="17" similarity="72">
<source file="systems/imgaug-0.4.0/test/augmenters/test_segmentation.py" startline="353" endline="373" pcid="2719">

    def test_replace_mask_is_mixed_integrationtest(self):
        image = np.uint8([
            [0, 1, 200, 201],
            [2, 3, 202, 203]
        ])
        cell_coordinates = np.float32([
            [1.0, 1.0],
            [3.0, 1.0]
        ])
        replace_mask = np.array([False, True], dtype=bool)

        image_seg = iaa.segment_voronoi(image, cell_coordinates, replace_mask)

        pixels2 = image[0:2, 2:4]
        avg_color2 = np.sum(pixels2).astype(np.float32) / pixels2.size
        image_expected = np.uint8([
            [0, 1, avg_color2, avg_color2],
            [2, 3, avg_color2, avg_color2],
        ])
        assert np.array_equal(image_seg, image_expected)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_segmentation.py" startline="374" endline="396" pcid="2720">

    def test_replace_mask_is_none_integrationtest(self):
        image = np.uint8([
            [0, 1, 200, 201],
            [2, 3, 202, 203]
        ])
        cell_coordinates = np.float32([
            [1.0, 1.0],
            [3.0, 1.0]
        ])
        replace_mask = None

        image_seg = iaa.segment_voronoi(image, cell_coordinates, replace_mask)

        pixels1 = image[0:2, 0:2]
        pixels2 = image[0:2, 2:4]
        avg_color1 = np.sum(pixels1).astype(np.float32) / pixels1.size
        avg_color2 = np.sum(pixels2).astype(np.float32) / pixels2.size
        image_expected = np.uint8([
            [avg_color1, avg_color1, avg_color2, avg_color2],
            [avg_color1, avg_color1, avg_color2, avg_color2],
        ])
        assert np.array_equal(image_seg, image_expected)
</source>
</class>

<class classid="129" nclones="4" nlines="10" similarity="81">
<source file="systems/imgaug-0.4.0/test/augmenters/test_segmentation.py" startline="497" endline="510" pcid="2728">

    def test_max_size_is_none(self):
        image = np.zeros((10, 20, 3), dtype=np.uint8)
        sampler = iaa.RegularGridPointsSampler(1, 1)
        aug = iaa.Voronoi(sampler, max_size=None)

        mock_imresize = mock.MagicMock()
        mock_imresize.return_value = image

        fname = "imgaug.imresize_single_image"
        with mock.patch(fname, mock_imresize):
            _image_aug = aug(image=image)

        assert mock_imresize.call_count == 0
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_segmentation.py" startline="511" endline="524" pcid="2729">

    def test_max_size_is_int_image_not_too_large(self):
        image = np.zeros((10, 20, 3), dtype=np.uint8)
        sampler = iaa.RegularGridPointsSampler(1, 1)
        aug = iaa.Voronoi(sampler, max_size=100)

        mock_imresize = mock.MagicMock()
        mock_imresize.return_value = image

        fname = "imgaug.imresize_single_image"
        with mock.patch(fname, mock_imresize):
            _image_aug = aug(image=image)

        assert mock_imresize.call_count == 0
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_segmentation.py" startline="540" endline="554" pcid="2731">

    def test_interpolation(self):
        image = np.zeros((10, 20, 3), dtype=np.uint8)
        sampler = iaa.RegularGridPointsSampler(1, 1)
        aug = iaa.Voronoi(sampler, max_size=10, interpolation="cubic")

        mock_imresize = mock.MagicMock()
        mock_imresize.return_value = image

        fname = "imgaug.imresize_single_image"
        with mock.patch(fname, mock_imresize):
            _image_aug = aug(image=image)

        assert mock_imresize.call_count == 1
        assert mock_imresize.call_args_list[0][1]["interpolation"] == "cubic"
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_segmentation.py" startline="525" endline="539" pcid="2730">

    def test_max_size_is_int_image_too_large(self):
        image = np.zeros((10, 20, 3), dtype=np.uint8)
        sampler = iaa.RegularGridPointsSampler(1, 1)
        aug = iaa.Voronoi(sampler, max_size=10)

        mock_imresize = mock.MagicMock()
        mock_imresize.return_value = image

        fname = "imgaug.imresize_single_image"
        with mock.patch(fname, mock_imresize):
            _image_aug = aug(image=image)

        assert mock_imresize.call_count == 1
        assert mock_imresize.call_args_list[0][0][1] == (5, 10)
</source>
</class>

<class classid="130" nclones="3" nlines="11" similarity="83">
<source file="systems/imgaug-0.4.0/test/augmenters/test_segmentation.py" startline="616" endline="630" pcid="2741">

    def test_p_replace_is_zero(self):
        image = np.zeros((50, 50), dtype=np.uint8)
        sampler = iaa.RegularGridPointsSampler(50, 50)
        aug = iaa.Voronoi(sampler, p_replace=0.0)

        mock_segment_voronoi = mock.MagicMock()
        mock_segment_voronoi.return_value = image[..., np.newaxis]

        fname = "imgaug.augmenters.segmentation.segment_voronoi"
        with mock.patch(fname, mock_segment_voronoi):
            _image_aug = aug(image=image)

        replace_mask = mock_segment_voronoi.call_args_list[0][0][2]
        assert not np.any(replace_mask)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_segmentation.py" startline="646" endline="661" pcid="2743">

    def test_p_replace_is_50_percent(self):
        image = np.zeros((200, 200), dtype=np.uint8)
        sampler = iaa.RegularGridPointsSampler(200, 200)
        aug = iaa.Voronoi(sampler, p_replace=0.5)

        mock_segment_voronoi = mock.MagicMock()
        mock_segment_voronoi.return_value = image[..., np.newaxis]

        fname = "imgaug.augmenters.segmentation.segment_voronoi"
        with mock.patch(fname, mock_segment_voronoi):
            _image_aug = aug(image=image)

        replace_mask = mock_segment_voronoi.call_args_list[0][0][2]
        replace_fraction = np.average(replace_mask.astype(np.float32))
        assert 0.4 <= replace_fraction <= 0.6
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_segmentation.py" startline="631" endline="645" pcid="2742">

    def test_p_replace_is_one(self):
        image = np.zeros((50, 50), dtype=np.uint8)
        sampler = iaa.RegularGridPointsSampler(50, 50)
        aug = iaa.Voronoi(sampler, p_replace=1.0)

        mock_segment_voronoi = mock.MagicMock()
        mock_segment_voronoi.return_value = image[..., np.newaxis]

        fname = "imgaug.augmenters.segmentation.segment_voronoi"
        with mock.patch(fname, mock_segment_voronoi):
            _image_aug = aug(image=image)

        replace_mask = mock_segment_voronoi.call_args_list[0][0][2]
        assert np.all(replace_mask)
</source>
</class>

<class classid="131" nclones="3" nlines="27" similarity="72">
<source file="systems/imgaug-0.4.0/test/augmenters/test_segmentation.py" startline="773" endline="798" pcid="2751">
class TestUniformVoronoi(unittest.TestCase):
    def test___init___(self):
        rs = iarandom.RNG(10)

        mock_voronoi = mock.MagicMock()
        mock_voronoi.return_value = mock_voronoi
        fname = "imgaug.augmenters.segmentation.Voronoi.__init__"
        with mock.patch(fname, mock_voronoi):
            _ = iaa.UniformVoronoi(
                100,
                p_replace=0.5,
                max_size=5,
                interpolation="cubic",
                seed=rs,
                name="foo"
            )

        assert mock_voronoi.call_count == 1
        assert isinstance(mock_voronoi.call_args_list[0][1]["points_sampler"],
                          iaa.UniformPointsSampler)
        assert np.isclose(mock_voronoi.call_args_list[0][1]["p_replace"],
                          0.5)
        assert mock_voronoi.call_args_list[0][1]["max_size"] == 5
        assert mock_voronoi.call_args_list[0][1]["interpolation"] == "cubic"
        assert mock_voronoi.call_args_list[0][1]["name"] == "foo"
        assert mock_voronoi.call_args_list[0][1]["seed"] is rs
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_segmentation.py" startline="822" endline="854" pcid="2754">
class TestRegularGridVoronoi(unittest.TestCase):
    def test___init___(self):
        rs = iarandom.RNG(10)

        mock_voronoi = mock.MagicMock()
        mock_voronoi.return_value = mock_voronoi
        fname = "imgaug.augmenters.segmentation.Voronoi.__init__"
        with mock.patch(fname, mock_voronoi):
            _ = iaa.RegularGridVoronoi(
                10,
                20,
                p_drop_points=0.6,
                p_replace=0.5,
                max_size=5,
                interpolation="cubic",
                seed=rs,
                name="foo"
            )

        assert mock_voronoi.call_count == 1
        ps = mock_voronoi.call_args_list[0][1]["points_sampler"]
        assert isinstance(ps, iaa.DropoutPointsSampler)
        assert isinstance(ps.other_points_sampler,
                          iaa.RegularGridPointsSampler)
        assert np.isclose(ps.p_drop.p.value, 1-0.6)
        assert ps.other_points_sampler.n_rows.value == 10
        assert ps.other_points_sampler.n_cols.value == 20
        assert np.isclose(mock_voronoi.call_args_list[0][1]["p_replace"],
                          0.5)
        assert mock_voronoi.call_args_list[0][1]["max_size"] == 5
        assert mock_voronoi.call_args_list[0][1]["interpolation"] == "cubic"
        assert mock_voronoi.call_args_list[0][1]["name"] == "foo"
        assert mock_voronoi.call_args_list[0][1]["seed"] is rs
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_segmentation.py" startline="884" endline="916" pcid="2757">
class TestRelativeRegularGridVoronoi(unittest.TestCase):
    def test___init___(self):
        rs = iarandom.RNG(10)

        mock_voronoi = mock.MagicMock()
        mock_voronoi.return_value = mock_voronoi
        fname = "imgaug.augmenters.segmentation.Voronoi.__init__"
        with mock.patch(fname, mock_voronoi):
            _ = iaa.RelativeRegularGridVoronoi(
                0.1,
                0.2,
                p_drop_points=0.6,
                p_replace=0.5,
                max_size=5,
                interpolation="cubic",
                seed=rs,
                name="foo"
            )

        assert mock_voronoi.call_count == 1
        ps = mock_voronoi.call_args_list[0][1]["points_sampler"]
        assert isinstance(ps, iaa.DropoutPointsSampler)
        assert isinstance(ps.other_points_sampler,
                          iaa.RelativeRegularGridPointsSampler)
        assert np.isclose(ps.p_drop.p.value, 1-0.6)
        assert np.isclose(ps.other_points_sampler.n_rows_frac.value, 0.1)
        assert np.isclose(ps.other_points_sampler.n_cols_frac.value, 0.2)
        assert np.isclose(mock_voronoi.call_args_list[0][1]["p_replace"],
                          0.5)
        assert mock_voronoi.call_args_list[0][1]["max_size"] == 5
        assert mock_voronoi.call_args_list[0][1]["interpolation"] == "cubic"
        assert mock_voronoi.call_args_list[0][1]["name"] == "foo"
        assert mock_voronoi.call_args_list[0][1]["seed"] is rs
</source>
</class>

<class classid="132" nclones="2" nlines="18" similarity="70">
<source file="systems/imgaug-0.4.0/test/augmenters/test_segmentation.py" startline="799" endline="815" pcid="2752">

    def test___init___integrationtest(self):
        rs = iarandom.RNG(10)
        aug = iaa.UniformVoronoi(
            100,
            p_replace=0.5,
            max_size=5,
            interpolation="cubic",
            seed=rs,
            name=None
        )
        assert aug.points_sampler.n_points.value == 100
        assert np.isclose(aug.p_replace.p.value, 0.5)
        assert aug.max_size == 5
        assert aug.interpolation == "cubic"
        assert aug.name == "UnnamedUniformVoronoi"
        assert aug.random_state.equals(rs)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_segmentation.py" startline="855" endline="876" pcid="2755">

    def test___init___integrationtest(self):
        rs = iarandom.RNG(10)
        aug = iaa.RegularGridVoronoi(
            10,
            (10, 30),
            p_replace=0.5,
            max_size=5,
            interpolation="cubic",
            seed=rs,
            name=None
        )
        assert aug.points_sampler.other_points_sampler.n_rows.value == 10
        assert isinstance(aug.points_sampler.other_points_sampler.n_cols,
                          iap.DiscreteUniform)
        assert aug.points_sampler.other_points_sampler.n_cols.a.value == 10
        assert aug.points_sampler.other_points_sampler.n_cols.b.value == 30
        assert np.isclose(aug.p_replace.p.value, 0.5)
        assert aug.max_size == 5
        assert aug.interpolation == "cubic"
        assert aug.name == "UnnamedRegularGridVoronoi"
        assert aug.random_state.equals(rs)
</source>
</class>

<class classid="133" nclones="3" nlines="10" similarity="81">
<source file="systems/imgaug-0.4.0/test/augmenters/test_segmentation.py" startline="965" endline="976" pcid="2763">

    def test_sample_points(self):
        image = np.zeros((10, 10, 3), dtype=np.uint8)
        sampler = iaa.RegularGridPointsSampler(2, 2)
        points = sampler.sample_points([image], iarandom.RNG(1))[0]
        assert len(points) == 4
        assert np.allclose(points, [
            [2.5, 2.5],
            [7.5, 2.5],
            [2.5, 7.5],
            [7.5, 7.5]
        ])
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_segmentation.py" startline="1114" endline="1125" pcid="2776">

    def test_sample_points(self):
        image = np.zeros((10, 10, 3), dtype=np.uint8)
        sampler = iaa.RelativeRegularGridPointsSampler(0.2, 0.2)
        points = sampler.sample_points([image], iarandom.RNG(1))[0]
        assert len(points) == 4
        assert np.allclose(points, [
            [2.5, 2.5],
            [7.5, 2.5],
            [2.5, 7.5],
            [7.5, 7.5]
        ])
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_segmentation.py" startline="1541" endline="1555" pcid="2810">

    def test_max_is_above_point_count(self):
        image = np.zeros((10, 10, 3), dtype=np.uint8)
        other = iaa.RegularGridPointsSampler(2, 2)
        sampler = iaa.SubsamplingPointsSampler(other, 100)

        observed = sampler.sample_points([image], 1)[0]

        assert len(observed) == 4
        assert np.allclose(observed, [
            [2.5, 2.5],
            [7.5, 2.5],
            [2.5, 7.5],
            [7.5, 7.5]
        ])
</source>
</class>

<class classid="134" nclones="2" nlines="12" similarity="83">
<source file="systems/imgaug-0.4.0/test/augmenters/test_segmentation.py" startline="977" endline="992" pcid="2764">

    def test_sample_points_stochastic(self):
        image = np.zeros((10, 10, 3), dtype=np.uint8)
        sampler = iaa.RegularGridPointsSampler(1, iap.Choice([1, 2]))
        points = sampler.sample_points([image], iarandom.RNG(1))[0]

        matches_single_point = np.allclose(points, [
            [5.0, 5.0]
        ])
        matches_two_points = np.allclose(points, [
            [2.5, 5.0],
            [7.5, 5.0]
        ])

        assert len(points) in [1, 2]
        assert matches_single_point or matches_two_points
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_segmentation.py" startline="1126" endline="1142" pcid="2777">

    def test_sample_points_stochastic(self):
        image = np.zeros((10, 10, 3), dtype=np.uint8)
        sampler = iaa.RelativeRegularGridPointsSampler(0.1,
                                                       iap.Choice([0.1, 0.2]))
        points = sampler.sample_points([image], iarandom.RNG(1))[0]

        matches_single_point = np.allclose(points, [
            [5.0, 5.0]
        ])
        matches_two_points = np.allclose(points, [
            [2.5, 5.0],
            [7.5, 5.0]
        ])

        assert len(points) in [1, 2]
        assert matches_single_point or matches_two_points
</source>
</class>

<class classid="135" nclones="2" nlines="14" similarity="92">
<source file="systems/imgaug-0.4.0/test/augmenters/test_segmentation.py" startline="1299" endline="1315" pcid="2792">

    def test_random_state_propagates(self):
        image = np.zeros((1, 1, 3), dtype=np.uint8)
        points = np.linspace(0.0+0.9, 1000.0-0.9, num=1)
        points = np.stack([points, points], axis=-1)
        other = _FixedPointsSampler(points)
        sampler = iaa.DropoutPointsSampler(other, 0.5)

        _ = sampler.sample_points([image], 1)[0]
        rs_s1_1 = other.last_random_state
        _ = sampler.sample_points([image], 1)[0]
        rs_s1_2 = other.last_random_state
        _ = sampler.sample_points([image], 2)[0]
        rs_s2_1 = other.last_random_state

        assert rs_s1_1.equals(rs_s1_2)
        assert not rs_s1_1.equals(rs_s2_1)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_segmentation.py" startline="1578" endline="1594" pcid="2813">

    def test_random_state_propagates(self):
        image = np.zeros((1, 1, 3), dtype=np.uint8)
        points = np.linspace(0.0+0.9, 1000.0-0.9, num=1)
        points = np.stack([points, points], axis=-1)
        other = _FixedPointsSampler(points)
        sampler = iaa.SubsamplingPointsSampler(other, 100)

        _ = sampler.sample_points([image], 1)[0]
        rs_s1_1 = other.last_random_state
        _ = sampler.sample_points([image], 1)[0]
        rs_s1_2 = other.last_random_state
        _ = sampler.sample_points([image], 2)[0]
        rs_s2_1 = other.last_random_state

        assert rs_s1_1.equals(rs_s1_2)
        assert not rs_s1_1.equals(rs_s2_1)
</source>
</class>

<class classid="136" nclones="4" nlines="15" similarity="75">
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="128" endline="145" pcid="2820">
    def test_zero_height(self):
        image = np.mod(np.arange(100*100*3), 255).astype(np.uint8).reshape(
            (100, 100, 3))
        image = 1 + image
        image_cp = np.copy(image)

        image_aug = iaa.cutout_(image,
                                x1=10,
                                y1=20,
                                x2=30,
                                y2=20,
                                fill_mode="constant",
                                cval=0,
                                fill_per_channel=False,
                                seed=None)

        assert np.array_equal(image_aug, image_cp)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="146" endline="163" pcid="2821">
    def test_zero_height_width(self):
        image = np.mod(np.arange(100*100*3), 255).astype(np.uint8).reshape(
            (100, 100, 3))
        image = 1 + image
        image_cp = np.copy(image)

        image_aug = iaa.cutout_(image,
                                x1=10,
                                y1=20,
                                x2=10,
                                y2=40,
                                fill_mode="constant",
                                cval=0,
                                fill_per_channel=False,
                                seed=None)

        assert np.array_equal(image_aug, image_cp)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="164" endline="181" pcid="2822">
    def test_position_outside_of_image_rect_fully_outside(self):
        image = np.mod(np.arange(100*100*3), 255).astype(np.uint8).reshape(
            (100, 100, 3))
        image = 1 + image
        image_cp = np.copy(image)

        image_aug = iaa.cutout_(image,
                                x1=-50,
                                y1=150,
                                x2=-1,
                                y2=200,
                                fill_mode="constant",
                                cval=0,
                                fill_per_channel=False,
                                seed=None)

        assert np.array_equal(image_aug, image_cp)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="182" endline="200" pcid="2823">
    def test_position_outside_of_image_rect_partially_inside(self):
        image = np.mod(np.arange(100*100*3), 255).astype(np.uint8).reshape(
            (100, 100, 3))
        image = 1 + image

        image_aug = iaa.cutout_(image,
                                x1=-25,
                                y1=-25,
                                x2=25,
                                y2=25,
                                fill_mode="constant",
                                cval=0,
                                fill_per_channel=False,
                                seed=None)

        assert np.all(image_aug[0:25, 0:25] == 0)
        assert np.all(image_aug[0:25, 25:] > 0)
        assert np.all(image_aug[25:, :] > 0)

</source>
</class>

<class classid="137" nclones="5" nlines="11" similarity="75">
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="478" endline="490" pcid="2833">
class Test_fill_rectangle_constant_(unittest.TestCase):
    def test_simple_image(self):
        image = np.mod(np.arange(100*100*3), 256).astype(np.uint8).reshape(
            (100, 100, 3))
        image_cp = np.copy(image)

        image_aug = arithmetic_lib._fill_rectangle_constant_(
            image,
            x1=10, y1=20, x2=60, y2=70,
            cval=17, per_channel=False, random_state=None)

        assert np.array_equal(image_aug[:20, :], image_cp[:20, :])
        assert np.all(image_aug[20:70, 10:60] == 17)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="491" endline="503" pcid="2834">

    def test_iterable_cval_but_per_channel_is_false(self):
        image = np.mod(np.arange(100*100*3), 256).astype(np.uint8).reshape(
            (100, 100, 3))
        image_cp = np.copy(image)

        image_aug = arithmetic_lib._fill_rectangle_constant_(
            image,
            x1=10, y1=20, x2=60, y2=70,
            cval=[17, 21, 25], per_channel=False, random_state=None)

        assert np.array_equal(image_aug[:20, :], image_cp[:20, :])
        assert np.all(image_aug[20:70, 10:60] == 17)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="536" endline="550" pcid="2837">

    def test_single_cval_with_per_channel_is_true(self):
        image = np.mod(np.arange(100*100*3), 256).astype(np.uint8).reshape(
            (100, 100, 3))
        image_cp = np.copy(image)

        image_aug = arithmetic_lib._fill_rectangle_constant_(
            image,
            x1=10, y1=20, x2=60, y2=70,
            cval=17, per_channel=True, random_state=None)

        assert np.array_equal(image_aug[:20, :], image_cp[:20, :])
        assert np.all(image_aug[20:70, 10:60, 0] == 17)
        assert np.all(image_aug[20:70, 10:60, 1] == 17)
        assert np.all(image_aug[20:70, 10:60, 2] == 17)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="504" endline="518" pcid="2835">

    def test_iterable_cval_with_per_channel_is_true(self):
        image = np.mod(np.arange(100*100*3), 256).astype(np.uint8).reshape(
            (100, 100, 3))
        image_cp = np.copy(image)

        image_aug = arithmetic_lib._fill_rectangle_constant_(
            image,
            x1=10, y1=20, x2=60, y2=70,
            cval=[17, 21, 25], per_channel=True, random_state=None)

        assert np.array_equal(image_aug[:20, :], image_cp[:20, :])
        assert np.all(image_aug[20:70, 10:60, 0] == 17)
        assert np.all(image_aug[20:70, 10:60, 1] == 21)
        assert np.all(image_aug[20:70, 10:60, 2] == 25)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="519" endline="535" pcid="2836">

    def test_iterable_cval_with_per_channel_is_true_channel_mismatch(self):
        image = np.mod(np.arange(100*100*5), 256).astype(np.uint8).reshape(
            (100, 100, 5))
        image_cp = np.copy(image)

        image_aug = arithmetic_lib._fill_rectangle_constant_(
            image,
            x1=10, y1=20, x2=60, y2=70,
            cval=[17, 21], per_channel=True, random_state=None)

        assert np.array_equal(image_aug[:20, :], image_cp[:20, :])
        assert np.all(image_aug[20:70, 10:60, 0] == 17)
        assert np.all(image_aug[20:70, 10:60, 1] == 21)
        assert np.all(image_aug[20:70, 10:60, 2] == 17)
        assert np.all(image_aug[20:70, 10:60, 3] == 21)
        assert np.all(image_aug[20:70, 10:60, 4] == 17)
</source>
</class>

<class classid="138" nclones="2" nlines="13" similarity="84">
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="551" endline="566" pcid="2838">

    def test_no_channels_single_cval(self):
        for per_channel in [False, True]:
            with self.subTest(per_channel=per_channel):
                image = np.mod(
                    np.arange(100*100), 256
                ).astype(np.uint8).reshape((100, 100))
                image_cp = np.copy(image)

                image_aug = arithmetic_lib._fill_rectangle_constant_(
                    image,
                    x1=10, y1=20, x2=60, y2=70,
                    cval=17, per_channel=per_channel, random_state=None)

                assert np.array_equal(image_aug[:20, :], image_cp[:20, :])
                assert np.all(image_aug[20:70, 10:60] == 17)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="567" endline="583" pcid="2839">

    def test_no_channels_iterable_cval(self):
        for per_channel in [False, True]:
            with self.subTest(per_channel=per_channel):
                image = np.mod(
                    np.arange(100*100), 256
                ).astype(np.uint8).reshape((100, 100))
                image_cp = np.copy(image)

                image_aug = arithmetic_lib._fill_rectangle_constant_(
                    image,
                    x1=10, y1=20, x2=60, y2=70,
                    cval=[17, 21, 25], per_channel=per_channel,
                    random_state=None)

                assert np.array_equal(image_aug[:20, :], image_cp[:20, :])
                assert np.all(image_aug[20:70, 10:60] == 17)
</source>
</class>

<class classid="139" nclones="7" nlines="13" similarity="84">
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="715" endline="730" pcid="2845">
    def setUp(self):
        reseed()

    def test___init___bad_datatypes(self):
        # test exceptions for wrong parameter types
        got_exception = False
        try:
            _ = iaa.Add(value="test")
        except Exception:
            got_exception = True
        assert got_exception

        got_exception = False
        try:
            _ = iaa.Add(value=1, per_channel="test")
        except Exception:
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="4247" endline="4262" pcid="3023">

            sums = np.sum(observed, axis=2)
            values = np.unique(sums)
            all_values_found = all([(value in values) for value in [0, 1, 2, 3]])
            if all_values_found:
                seen[0] += 1
            else:
                seen[1] += 1
        assert 150 < seen[0] < 250
        assert 150 < seen[1] < 250

    def test___init___bad_datatypes(self):
        # test exceptions for wrong parameter types
        got_exception = False
        try:
            _aug = iaa.ReplaceElementwise(mask="test", replacement=1)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="1861" endline="1876" pcid="2893">
        assert 75 < seen[0] < 125
        assert 75 < seen[1] < 125

    def test___init___bad_datatypes(self):
        # test exceptions for wrong parameter types
        got_exception = False
        try:
            _ = iaa.AdditiveGaussianNoise(loc="test")
        except Exception:
            got_exception = True
        assert got_exception

        got_exception = False
        try:
            _ = iaa.AdditiveGaussianNoise(scale="test")
        except Exception:
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="5391" endline="5406" pcid="3104">
        expected = np.array([255-0, 255-10, 255-50, 150, 200, 255],
                            dtype=np.uint8).reshape((2, 3, 1))
        assert observed.dtype.name == "uint8"
        assert np.array_equal(observed, expected)

    def test_keypoints_dont_change(self):
        # keypoints shouldnt be changed
        zeros = np.zeros((4, 4, 3), dtype=np.uint8)

        keypoints = [ia.KeypointsOnImage([ia.Keypoint(x=0, y=0), ia.Keypoint(x=1, y=1),
                                          ia.Keypoint(x=2, y=2)], shape=zeros.shape)]

        aug = iaa.Invert(p=1.0)
        aug_det = iaa.Invert(p=1.0).to_deterministic()
        observed = aug.augment_keypoints(keypoints)
        expected = keypoints
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="3774" endline="3789" pcid="3006">

            sums = np.sum(observed, axis=2)
            values = np.unique(sums)
            all_values_found = all([(value in values) for value in [0, 1, 2, 3]])
            if all_values_found:
                seen[0] += 1
            else:
                seen[1] += 1
        assert 150 < seen[0] < 250
        assert 150 < seen[1] < 250

    def test___init___bad_datatypes(self):
        # test exceptions for wrong parameter types
        got_exception = False
        try:
            _aug = iaa.MultiplyElementwise(mul="test")
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="1200" endline="1215" pcid="2865">
    def setUp(self):
        reseed()

    def test___init___bad_datatypes(self):
        # test exceptions for wrong parameter types
        got_exception = False
        try:
            _aug = iaa.AddElementwise(value="test")
        except Exception:
            got_exception = True
        assert got_exception

        got_exception = False
        try:
            _aug = iaa.AddElementwise(value=1, per_channel="test")
        except Exception:
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="3275" endline="3290" pcid="2988">
            assert observed.shape == (1, 1, 20)

            uq = np.unique(observed)
            per_channel = (len(uq) == 2)
            if per_channel:
                seen[0] += 1
            else:
                seen[1] += 1
        assert 150 < seen[0] < 250
        assert 150 < seen[1] < 250

    def test___init___bad_datatypes(self):
        # test exceptions for wrong parameter types
        got_exception = False
        try:
            _ = iaa.Multiply(mul="test")
</source>
</class>

<class classid="140" nclones="13" nlines="19" similarity="73">
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="731" endline="756" pcid="2846">
            got_exception = True
        assert got_exception

    def test_add_zero(self):
        # no add, shouldnt change anything
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        images = np.array([base_img])
        images_list = [base_img]

        aug = iaa.Add(value=0)
        aug_det = aug.to_deterministic()

        observed = aug.augment_images(images)
        expected = images
        assert np.array_equal(observed, expected)
        assert observed.shape == (1, 3, 3, 1)

        observed = aug.augment_images(images_list)
        expected = images_list
        assert array_equal_lists(observed, expected)

        observed = aug_det.augment_images(images)
        expected = images
        assert np.array_equal(observed, expected)

        observed = aug_det.augment_images(images_list)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="3626" endline="3651" pcid="2999">
        expected = images_list
        assert array_equal_lists(observed, expected)

        observed = aug_det.augment_images(images)
        expected = images
        assert np.array_equal(observed, expected)

        observed = aug_det.augment_images(images_list)
        expected = images_list
        assert array_equal_lists(observed, expected)

    def test_mul_is_above_one(self):
        # multiply >1.0
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        images = np.array([base_img])
        images_list = [base_img]

        aug = iaa.MultiplyElementwise(mul=1.2)
        aug_det = aug.to_deterministic()

        observed = aug.augment_images(images)
        expected = np.ones((1, 3, 3, 1), dtype=np.uint8) * 120
        assert np.array_equal(observed, expected)
        assert observed.shape == (1, 3, 3, 1)

        observed = aug.augment_images(images_list)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="3152" endline="3177" pcid="2982">
        expected = images_list
        assert array_equal_lists(observed, expected)

        observed = aug_det.augment_images(images)
        expected = images
        assert np.array_equal(observed, expected)

        observed = aug_det.augment_images(images_list)
        expected = images_list
        assert array_equal_lists(observed, expected)

    def test_mul_is_above_one(self):
        # multiply >1.0
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        images = np.array([base_img])
        images_list = [base_img]

        aug = iaa.Multiply(mul=1.2)
        aug_det = aug.to_deterministic()

        observed = aug.augment_images(images)
        expected = np.ones((1, 3, 3, 1), dtype=np.uint8) * 120
        assert np.array_equal(observed, expected)
        assert observed.shape == (1, 3, 3, 1)

        observed = aug.augment_images(images_list)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="3600" endline="3625" pcid="2998">
            """

    def test_pickleable(self):
        aug = iaa.Multiply((0.5, 1.5), per_channel=True, seed=1)
        runtest_pickleable_uint8_img(aug, iterations=20)


class TestMultiplyElementwise(unittest.TestCase):
    def setUp(self):
        reseed()

    def test_mul_is_one(self):
        # no multiply, shouldnt change anything
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        images = np.array([base_img])
        images_list = [base_img]

        aug = iaa.MultiplyElementwise(mul=1.0)
        aug_det = aug.to_deterministic()

        observed = aug.augment_images(images)
        expected = images
        assert np.array_equal(observed, expected)
        assert observed.shape == (1, 3, 3, 1)

        observed = aug.augment_images(images_list)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="3652" endline="3677" pcid="3000">
        expected = [np.ones((3, 3, 1), dtype=np.uint8) * 120]
        assert array_equal_lists(observed, expected)

        observed = aug_det.augment_images(images)
        expected = np.ones((1, 3, 3, 1), dtype=np.uint8) * 120
        assert np.array_equal(observed, expected)

        observed = aug_det.augment_images(images_list)
        expected = [np.ones((3, 3, 1), dtype=np.uint8) * 120]
        assert array_equal_lists(observed, expected)

    def test_mul_is_below_one(self):
        # multiply <1.0
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        images = np.array([base_img])
        images_list = [base_img]

        aug = iaa.MultiplyElementwise(mul=0.8)
        aug_det = aug.to_deterministic()

        observed = aug.augment_images(images)
        expected = np.ones((1, 3, 3, 1), dtype=np.uint8) * 80
        assert np.array_equal(observed, expected)
        assert observed.shape == (1, 3, 3, 1)

        observed = aug.augment_images(images_list)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="4108" endline="4133" pcid="3016">

    def test_pickleable(self):
        aug = iaa.MultiplyElementwise((0.5, 1.5), per_channel=True,
                                      seed=1)
        runtest_pickleable_uint8_img(aug, iterations=3)


class TestReplaceElementwise(unittest.TestCase):
    def setUp(self):
        reseed()

    def test_mask_is_always_zero(self):
        # no replace, shouldnt change anything
        base_img = np.ones((3, 3, 1), dtype=np.uint8) + 99
        images = np.array([base_img])
        images_list = [base_img]

        aug = iaa.ReplaceElementwise(mask=0, replacement=0)
        aug_det = aug.to_deterministic()

        observed = aug.augment_images(images)
        expected = images
        assert np.array_equal(observed, expected)
        assert observed.shape == (1, 3, 3, 1)

        observed = aug.augment_images(images_list)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="1216" endline="1241" pcid="2866">
            got_exception = True
        assert got_exception

    def test_add_zero(self):
        # no add, shouldnt change anything
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        images = np.array([base_img])
        images_list = [base_img]

        aug = iaa.AddElementwise(value=0)
        aug_det = aug.to_deterministic()

        observed = aug.augment_images(images)
        expected = images
        assert np.array_equal(observed, expected)
        assert observed.shape == (1, 3, 3, 1)

        observed = aug.augment_images(images_list)
        expected = images_list
        assert array_equal_lists(observed, expected)

        observed = aug_det.augment_images(images)
        expected = images
        assert np.array_equal(observed, expected)

        observed = aug_det.augment_images(images_list)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="3126" endline="3151" pcid="2981">
                                == 5*3)

    def test_pickleable(self):
        aug = iaa.TotalDropout(p=0.5, seed=1)
        runtest_pickleable_uint8_img(aug, iterations=30, shape=(4, 4, 2))


class TestMultiply(unittest.TestCase):
    def setUp(self):
        reseed()

    def test_mul_is_one(self):
        # no multiply, shouldnt change anything
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        images = np.array([base_img])
        images_list = [base_img]

        aug = iaa.Multiply(mul=1.0)
        aug_det = aug.to_deterministic()

        observed = aug.augment_images(images)
        expected = images
        assert np.array_equal(observed, expected)
        assert observed.shape == (1, 3, 3, 1)

        observed = aug.augment_images(images_list)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="3178" endline="3203" pcid="2983">
        expected = [np.ones((3, 3, 1), dtype=np.uint8) * 120]
        assert array_equal_lists(observed, expected)

        observed = aug_det.augment_images(images)
        expected = np.ones((1, 3, 3, 1), dtype=np.uint8) * 120
        assert np.array_equal(observed, expected)

        observed = aug_det.augment_images(images_list)
        expected = [np.ones((3, 3, 1), dtype=np.uint8) * 120]
        assert array_equal_lists(observed, expected)

    def test_mul_is_below_one(self):
        # multiply <1.0
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        images = np.array([base_img])
        images_list = [base_img]

        aug = iaa.Multiply(mul=0.8)
        aug_det = aug.to_deterministic()

        observed = aug.augment_images(images)
        expected = np.ones((1, 3, 3, 1), dtype=np.uint8) * 80
        assert np.array_equal(observed, expected)
        assert observed.shape == (1, 3, 3, 1)

        observed = aug.augment_images(images_list)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="1242" endline="1267" pcid="2867">
        expected = images_list
        assert array_equal_lists(observed, expected)

    def test_add_one(self):
        # add > 0
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        images = np.array([base_img])
        images_list = [base_img]

        aug = iaa.AddElementwise(value=1)
        aug_det = aug.to_deterministic()

        observed = aug.augment_images(images)
        expected = images + 1
        assert np.array_equal(observed, expected)
        assert observed.shape == (1, 3, 3, 1)

        observed = aug.augment_images(images_list)
        expected = [images_list[0] + 1]
        assert array_equal_lists(observed, expected)

        observed = aug_det.augment_images(images)
        expected = images + 1
        assert np.array_equal(observed, expected)

        observed = aug_det.augment_images(images_list)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="757" endline="782" pcid="2847">
        expected = images_list
        assert array_equal_lists(observed, expected)

    def test_add_one(self):
        # add > 0
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        images = np.array([base_img])
        images_list = [base_img]

        aug = iaa.Add(value=1)
        aug_det = aug.to_deterministic()

        observed = aug.augment_images(images)
        expected = images + 1
        assert np.array_equal(observed, expected)
        assert observed.shape == (1, 3, 3, 1)

        observed = aug.augment_images(images_list)
        expected = [images_list[0] + 1]
        assert array_equal_lists(observed, expected)

        observed = aug_det.augment_images(images)
        expected = images + 1
        assert np.array_equal(observed, expected)

        observed = aug_det.augment_images(images_list)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="2218" endline="2242" pcid="2912">
    def setUp(self):
        reseed()

    def test_p_is_zero(self):
        # no dropout, shouldnt change anything
        base_img = np.ones((512, 512, 1), dtype=np.uint8) * 255
        images = np.array([base_img])
        images_list = [base_img]

        aug = iaa.Dropout(p=0)
        observed = aug.augment_images(images)
        expected = images
        assert np.array_equal(observed, expected)

        observed = aug.augment_images(images_list)
        expected = images_list
        assert array_equal_lists(observed, expected)

        # 100% dropout, should drop everything
        aug = iaa.Dropout(p=1.0)
        observed = aug.augment_images(images)
        expected = np.zeros((1, 512, 512, 1), dtype=np.uint8)
        assert np.array_equal(observed, expected)

        observed = aug.augment_images(images_list)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="4134" endline="4159" pcid="3017">
        expected = images_list
        assert array_equal_lists(observed, expected)

        observed = aug_det.augment_images(images)
        expected = images
        assert np.array_equal(observed, expected)

        observed = aug_det.augment_images(images_list)
        expected = images_list
        assert array_equal_lists(observed, expected)

    def test_mask_is_always_one(self):
        # replace at 100 percent prob., should change everything
        base_img = np.ones((3, 3, 1), dtype=np.uint8) + 99
        images = np.array([base_img])
        images_list = [base_img]

        aug = iaa.ReplaceElementwise(mask=1, replacement=0)
        aug_det = aug.to_deterministic()

        observed = aug.augment_images(images)
        expected = np.zeros((1, 3, 3, 1), dtype=np.uint8)
        assert np.array_equal(observed, expected)
        assert observed.shape == (1, 3, 3, 1)

        observed = aug.augment_images(images_list)
</source>
</class>

<class classid="141" nclones="2" nlines="18" similarity="100">
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="783" endline="807" pcid="2848">
        expected = [images_list[0] + 1]
        assert array_equal_lists(observed, expected)

    def test_minus_one(self):
        # add < 0
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        images = np.array([base_img])
        images_list = [base_img]

        aug = iaa.Add(value=-1)
        aug_det = aug.to_deterministic()

        observed = aug.augment_images(images)
        expected = images - 1
        assert np.array_equal(observed, expected)

        observed = aug.augment_images(images_list)
        expected = [images_list[0] - 1]
        assert array_equal_lists(observed, expected)

        observed = aug_det.augment_images(images)
        expected = images - 1
        assert np.array_equal(observed, expected)

        observed = aug_det.augment_images(images_list)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="1268" endline="1292" pcid="2868">
        expected = [images_list[0] + 1]
        assert array_equal_lists(observed, expected)

    def test_add_minus_one(self):
        # add < 0
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        images = np.array([base_img])
        images_list = [base_img]

        aug = iaa.AddElementwise(value=-1)
        aug_det = aug.to_deterministic()

        observed = aug.augment_images(images)
        expected = images - 1
        assert np.array_equal(observed, expected)

        observed = aug.augment_images(images_list)
        expected = [images_list[0] - 1]
        assert array_equal_lists(observed, expected)

        observed = aug_det.augment_images(images)
        expected = images - 1
        assert np.array_equal(observed, expected)

        observed = aug_det.augment_images(images_list)
</source>
</class>

<class classid="142" nclones="2" nlines="12" similarity="91">
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="808" endline="823" pcid="2849">
        expected = [images_list[0] - 1]
        assert array_equal_lists(observed, expected)

    def test_uint8_every_possible_value(self):
        # uint8, every possible addition for base value 127
        for value_type in [float, int]:
            for per_channel in [False, True]:
                for value in np.arange(-255, 255+1):
                    aug = iaa.Add(value=value_type(value), per_channel=per_channel)
                    expected = np.clip(127 + value_type(value), 0, 255)

                    img = np.full((1, 1), 127, dtype=np.uint8)
                    img_aug = aug.augment_image(img)
                    assert img_aug.item(0) == expected

                    img = np.full((1, 1, 3), 127, dtype=np.uint8)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="1293" endline="1308" pcid="2869">
        expected = [images_list[0] - 1]
        assert array_equal_lists(observed, expected)

    def test_uint8_every_possible_value(self):
        # uint8, every possible addition for base value 127
        for value_type in [int]:
            for per_channel in [False, True]:
                for value in np.arange(-255, 255+1):
                    aug = iaa.AddElementwise(value=value_type(value), per_channel=per_channel)
                    expected = np.clip(127 + value_type(value), 0, 255)

                    img = np.full((1, 1), 127, dtype=np.uint8)
                    img_aug = aug.augment_image(img)
                    assert img_aug.item(0) == expected

                    img = np.full((1, 1, 3), 127, dtype=np.uint8)
</source>
</class>

<class classid="143" nclones="6" nlines="12" similarity="75">
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="865" endline="880" pcid="2852">
        observed = aug.augment_images(images)
        assert 100 - 3 <= np.average(observed) <= 100 + 3

    def test_keypoints_dont_change(self):
        # keypoints shouldnt be changed
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        keypoints = [ia.KeypointsOnImage([ia.Keypoint(x=0, y=0), ia.Keypoint(x=1, y=1),
                                          ia.Keypoint(x=2, y=2)], shape=base_img.shape)]

        aug = iaa.Add(value=1)
        aug_det = iaa.Add(value=1).to_deterministic()
        observed = aug.augment_keypoints(keypoints)
        expected = keypoints
        assert keypoints_equal(observed, expected)

        observed = aug_det.augment_keypoints(keypoints)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="3678" endline="3693" pcid="3001">
        expected = [np.ones((3, 3, 1), dtype=np.uint8) * 80]
        assert array_equal_lists(observed, expected)

        observed = aug_det.augment_images(images)
        expected = np.ones((1, 3, 3, 1), dtype=np.uint8) * 80
        assert np.array_equal(observed, expected)

        observed = aug_det.augment_images(images_list)
        expected = [np.ones((3, 3, 1), dtype=np.uint8) * 80]
        assert array_equal_lists(observed, expected)

    def test_keypoints_dont_change(self):
        # keypoints shouldnt be changed
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        keypoints = [ia.KeypointsOnImage([ia.Keypoint(x=0, y=0), ia.Keypoint(x=1, y=1),
                                          ia.Keypoint(x=2, y=2)], shape=base_img.shape)]
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="3204" endline="3219" pcid="2984">
        expected = [np.ones((3, 3, 1), dtype=np.uint8) * 80]
        assert array_equal_lists(observed, expected)

        observed = aug_det.augment_images(images)
        expected = np.ones((1, 3, 3, 1), dtype=np.uint8) * 80
        assert np.array_equal(observed, expected)

        observed = aug_det.augment_images(images_list)
        expected = [np.ones((3, 3, 1), dtype=np.uint8) * 80]
        assert array_equal_lists(observed, expected)

    def test_keypoints_dont_change(self):
        # keypoints shouldnt be changed
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        keypoints = [ia.KeypointsOnImage([ia.Keypoint(x=0, y=0), ia.Keypoint(x=1, y=1),
                                          ia.Keypoint(x=2, y=2)], shape=base_img.shape)]
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="5374" endline="5390" pcid="3103">
        arr = arr.reshape((2, 3, 1))
        aug = iaa.Invert(p=1.0, threshold=128, invert_above_threshold=True)

        observed = aug.augment_image(arr)

        expected = np.array([0, 10, 50, 255-150, 255-200, 255-255],
                            dtype=np.uint8).reshape((2, 3, 1))
        assert observed.dtype.name == "uint8"
        assert np.array_equal(observed, expected)

    def test_threshold_inv_below(self):
        arr = np.array([0, 10, 50, 150, 200, 255], dtype=np.uint8)
        arr = arr.reshape((2, 3, 1))
        aug = iaa.Invert(p=1.0, threshold=128, invert_above_threshold=False)

        observed = aug.augment_image(arr)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="4193" endline="4208" pcid="3020">
            p = np.mean(observed)
            if 0.1 < p < 0.3:
                seen[0] += 1
            elif 0.6 < p < 0.8:
                seen[1] += 1
            else:
                seen[2] += 1
        assert seen[2] <= 10
        assert 150 < seen[0] < 250
        assert 150 < seen[1] < 250

    def test_keypoints_dont_change(self):
        # keypoints shouldnt be changed
        base_img = np.ones((3, 3, 1), dtype=np.uint8) + 99
        keypoints = [ia.KeypointsOnImage([ia.Keypoint(x=0, y=0), ia.Keypoint(x=1, y=1),
                                          ia.Keypoint(x=2, y=2)], shape=base_img.shape)]
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="1334" endline="1349" pcid="2871">
        assert np.min(observed) >= 100 - 3
        assert np.max(observed) <= 100 + 3

    def test_keypoints_dont_change(self):
        # keypoints shouldnt be changed
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        keypoints = [ia.KeypointsOnImage([ia.Keypoint(x=0, y=0), ia.Keypoint(x=1, y=1),
                                          ia.Keypoint(x=2, y=2)], shape=base_img.shape)]

        aug = iaa.AddElementwise(value=1)
        aug_det = iaa.AddElementwise(value=1).to_deterministic()
        observed = aug.augment_keypoints(keypoints)
        expected = keypoints
        assert keypoints_equal(observed, expected)

        observed = aug_det.augment_keypoints(keypoints)
</source>
</class>

<class classid="144" nclones="5" nlines="14" similarity="80">
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="920" endline="936" pcid="2855">
        assert 1 in uq
        assert len(uq) == 2

    def test_per_channel_with_probability(self):
        # test channelwise with probability
        aug = iaa.Add(value=iap.Choice([0, 1]), per_channel=0.5)
        seen = [0, 0]
        for _ in sm.xrange(400):
            observed = aug.augment_image(np.zeros((1, 1, 20), dtype=np.uint8))
            assert observed.shape == (1, 1, 20)

            uq = np.unique(observed)
            per_channel = (len(uq) == 2)
            if per_channel:
                seen[0] += 1
            else:
                seen[1] += 1
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="4229" endline="4246" pcid="3022">
        p100 = nb_diff_100 / (1000 * 1000)
        p200 = nb_diff_200 / (1000 * 1000)
        assert 0.45 <= p100 <= 0.55
        assert 0.45 <= p200 <= 0.55
        # test channelwise
        aug = iaa.MultiplyElementwise(mul=iap.Choice([0, 1]), per_channel=True)
        observed = aug.augment_image(np.ones((100, 100, 3), dtype=np.uint8))
        sums = np.sum(observed, axis=2)
        values = np.unique(sums)
        assert all([(value in values) for value in [0, 1, 2, 3]])

    def test_per_channel_with_probability(self):
        # test channelwise with probability
        aug = iaa.ReplaceElementwise(mask=iap.Choice([0, 1]), replacement=1, per_channel=0.5)
        seen = [0, 0]
        for _ in sm.xrange(400):
            observed = aug.augment_image(np.zeros((20, 20, 3), dtype=np.uint8))
            assert observed.shape == (20, 20, 3)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="3258" endline="3274" pcid="2987">
        assert nb_changed_aug_det == 0

    def test_per_channel(self):
        aug = iaa.Multiply(mul=iap.Choice([0, 2]), per_channel=True)
        observed = aug.augment_image(np.ones((1, 1, 100), dtype=np.uint8))
        uq = np.unique(observed)
        assert observed.shape == (1, 1, 100)
        assert 0 in uq
        assert 2 in uq
        assert len(uq) == 2

    def test_per_channel_with_probability(self):
        # test channelwise with probability
        aug = iaa.Multiply(mul=iap.Choice([0, 2]), per_channel=0.5)
        seen = [0, 0]
        for _ in sm.xrange(400):
            observed = aug.augment_image(np.ones((1, 1, 20), dtype=np.uint8))
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="3756" endline="3773" pcid="3005">
        assert nb_different > 0.95 * (nb_different + nb_same)

    def test_per_channel(self):
        # test channelwise
        aug = iaa.MultiplyElementwise(mul=iap.Choice([0, 1]), per_channel=True)
        observed = aug.augment_image(np.ones((100, 100, 3), dtype=np.uint8))
        sums = np.sum(observed, axis=2)
        values = np.unique(sums)
        assert all([(value in values) for value in [0, 1, 2, 3]])
        assert observed.shape == (100, 100, 3)

    def test_per_channel_with_probability(self):
        # test channelwise with probability
        aug = iaa.MultiplyElementwise(mul=iap.Choice([0, 1]), per_channel=0.5)
        seen = [0, 0]
        for _ in sm.xrange(400):
            observed = aug.augment_image(np.ones((20, 20, 3), dtype=np.uint8))
            assert observed.shape == (20, 20, 3)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="1411" endline="1426" pcid="2875">
        values = np.unique(sums)
        assert all([(value in values) for value in [0, 1, 2, 3]])

    def test_per_channel_with_probability(self):
        # test channelwise with probability
        aug = iaa.AddElementwise(value=iap.Choice([0, 1]), per_channel=0.5)
        seen = [0, 0]
        for _ in sm.xrange(400):
            observed = aug.augment_image(np.zeros((20, 20, 3), dtype=np.uint8))
            sums = np.sum(observed, axis=2)
            values = np.unique(sums)
            all_values_found = all([(value in values) for value in [0, 1, 2, 3]])
            if all_values_found:
                seen[0] += 1
            else:
                seen[1] += 1
</source>
</class>

<class classid="145" nclones="2" nlines="21" similarity="100">
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="995" endline="1019" pcid="2860">
        hm_aug = aug.augment_heatmaps([hm])[0]
        assert np.allclose(hm.arr_0to1, hm_aug.arr_0to1)

    def test_other_dtypes_bool(self):
        image = np.zeros((3, 3), dtype=bool)
        aug = iaa.Add(value=1)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == np.bool_
        assert np.all(image_aug == 1)

        image = np.full((3, 3), True, dtype=bool)
        aug = iaa.Add(value=1)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == np.bool_
        assert np.all(image_aug == 1)

        image = np.full((3, 3), True, dtype=bool)
        aug = iaa.Add(value=-1)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == np.bool_
        assert np.all(image_aug == 0)

        image = np.full((3, 3), True, dtype=bool)
        aug = iaa.Add(value=-2)
        image_aug = aug.augment_image(image)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="1484" endline="1509" pcid="2880">
        hm_aug = aug.augment_heatmaps([hm])[0]
        assert np.allclose(hm.arr_0to1, hm_aug.arr_0to1)

    def test_other_dtypes_bool(self):
        # bool
        image = np.zeros((3, 3), dtype=bool)
        aug = iaa.AddElementwise(value=1)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == np.bool_
        assert np.all(image_aug == 1)

        image = np.full((3, 3), True, dtype=bool)
        aug = iaa.AddElementwise(value=1)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == np.bool_
        assert np.all(image_aug == 1)

        image = np.full((3, 3), True, dtype=bool)
        aug = iaa.AddElementwise(value=-1)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == np.bool_
        assert np.all(image_aug == 0)

        image = np.full((3, 3), True, dtype=bool)
        aug = iaa.AddElementwise(value=-2)
        image_aug = aug.augment_image(image)
</source>
</class>

<class classid="146" nclones="2" nlines="69" similarity="94">
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="1020" endline="1100" pcid="2861">
        assert image_aug.dtype.type == np.bool_
        assert np.all(image_aug == 0)

    def test_other_dtypes_uint_int(self):
        for dtype in [np.uint8, np.uint16, np.int8, np.int16]:
            min_value, center_value, max_value = iadt.get_value_range_of_dtype(dtype)

            image = np.full((3, 3), min_value, dtype=dtype)
            aug = iaa.Add(1)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == min_value + 1)

            image = np.full((3, 3), min_value + 10, dtype=dtype)
            aug = iaa.Add(11)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == min_value + 21)

            image = np.full((3, 3), max_value - 2, dtype=dtype)
            aug = iaa.Add(1)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == max_value - 1)

            image = np.full((3, 3), max_value - 1, dtype=dtype)
            aug = iaa.Add(1)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == max_value)

            image = np.full((3, 3), max_value - 1, dtype=dtype)
            aug = iaa.Add(2)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == max_value)

            image = np.full((3, 3), min_value + 10, dtype=dtype)
            aug = iaa.Add(-9)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == min_value + 1)

            image = np.full((3, 3), min_value + 10, dtype=dtype)
            aug = iaa.Add(-10)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == min_value)

            image = np.full((3, 3), min_value + 10, dtype=dtype)
            aug = iaa.Add(-11)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == min_value)

            for _ in sm.xrange(10):
                image = np.full((1, 1, 3), 20, dtype=dtype)
                aug = iaa.Add(iap.Uniform(-10, 10))
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(10 <= image_aug, image_aug <= 30))
                assert len(np.unique(image_aug)) == 1

                image = np.full((1, 1, 100), 20, dtype=dtype)
                aug = iaa.Add(iap.Uniform(-10, 10), per_channel=True)
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(10 <= image_aug, image_aug <= 30))
                assert len(np.unique(image_aug)) > 1

                image = np.full((1, 1, 3), 20, dtype=dtype)
                aug = iaa.Add(iap.DiscreteUniform(-10, 10))
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(10 <= image_aug, image_aug <= 30))
                assert len(np.unique(image_aug)) == 1

                image = np.full((1, 1, 100), 20, dtype=dtype)
                aug = iaa.Add(iap.DiscreteUniform(-10, 10), per_channel=True)
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="1510" endline="1593" pcid="2881">
        assert image_aug.dtype.type == np.bool_
        assert np.all(image_aug == 0)

    def test_other_dtypes_uint_int(self):
        # uint, int
        for dtype in [np.uint8, np.uint16, np.int8, np.int16]:
            min_value, center_value, max_value = iadt.get_value_range_of_dtype(dtype)

            image = np.full((3, 3), min_value, dtype=dtype)
            aug = iaa.AddElementwise(1)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == min_value + 1)

            image = np.full((3, 3), min_value + 10, dtype=dtype)
            aug = iaa.AddElementwise(11)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == min_value + 21)

            image = np.full((3, 3), max_value - 2, dtype=dtype)
            aug = iaa.AddElementwise(1)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == max_value - 1)

            image = np.full((3, 3), max_value - 1, dtype=dtype)
            aug = iaa.AddElementwise(1)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == max_value)

            image = np.full((3, 3), max_value - 1, dtype=dtype)
            aug = iaa.AddElementwise(2)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == max_value)

            image = np.full((3, 3), min_value + 10, dtype=dtype)
            aug = iaa.AddElementwise(-9)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == min_value + 1)

            image = np.full((3, 3), min_value + 10, dtype=dtype)
            aug = iaa.AddElementwise(-10)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == min_value)

            image = np.full((3, 3), min_value + 10, dtype=dtype)
            aug = iaa.AddElementwise(-11)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == min_value)

            for _ in sm.xrange(10):
                image = np.full((5, 5, 3), 20, dtype=dtype)
                aug = iaa.AddElementwise(iap.Uniform(-10, 10))
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(10 <= image_aug, image_aug <= 30))
                assert len(np.unique(image_aug)) > 1
                assert np.all(image_aug[..., 0] == image_aug[..., 1])

                image = np.full((1, 1, 100), 20, dtype=dtype)
                aug = iaa.AddElementwise(iap.Uniform(-10, 10), per_channel=True)
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(10 <= image_aug, image_aug <= 30))
                assert len(np.unique(image_aug)) > 1

                image = np.full((5, 5, 3), 20, dtype=dtype)
                aug = iaa.AddElementwise(iap.DiscreteUniform(-10, 10))
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(10 <= image_aug, image_aug <= 30))
                assert len(np.unique(image_aug)) > 1
                assert np.all(image_aug[..., 0] == image_aug[..., 1])

                image = np.full((1, 1, 100), 20, dtype=dtype)
                aug = iaa.AddElementwise(iap.DiscreteUniform(-10, 10), per_channel=True)
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
</source>
</class>

<class classid="147" nclones="2" nlines="75" similarity="97">
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="1101" endline="1190" pcid="2862">
                assert np.all(np.logical_and(10 <= image_aug, image_aug <= 30))
                assert len(np.unique(image_aug)) > 1

    def test_other_dtypes_float(self):
        # float
        for dtype in [np.float16, np.float32]:
            min_value, center_value, max_value = iadt.get_value_range_of_dtype(dtype)

            if dtype == np.float16:
                atol = 1e-3 * max_value
            else:
                atol = 1e-9 * max_value
            _allclose = functools.partial(np.allclose, atol=atol, rtol=0)

            image = np.full((3, 3), min_value, dtype=dtype)
            aug = iaa.Add(1)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, min_value + 1)

            image = np.full((3, 3), min_value + 10, dtype=dtype)
            aug = iaa.Add(11)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, min_value + 21)

            image = np.full((3, 3), max_value - 2, dtype=dtype)
            aug = iaa.Add(1)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, max_value - 1)

            image = np.full((3, 3), max_value - 1, dtype=dtype)
            aug = iaa.Add(1)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, max_value)

            image = np.full((3, 3), max_value - 1, dtype=dtype)
            aug = iaa.Add(2)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, max_value)

            image = np.full((3, 3), min_value + 10, dtype=dtype)
            aug = iaa.Add(-9)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, min_value + 1)

            image = np.full((3, 3), min_value + 10, dtype=dtype)
            aug = iaa.Add(-10)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, min_value)

            image = np.full((3, 3), min_value + 10, dtype=dtype)
            aug = iaa.Add(-11)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, min_value)

            for _ in sm.xrange(10):
                image = np.full((50, 1, 3), 0, dtype=dtype)
                aug = iaa.Add(iap.Uniform(-10, 10))
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(-10 - 1e-2 < image_aug, image_aug < 10 + 1e-2))
                assert np.allclose(image_aug[1:, :, 0], image_aug[:-1, :, 0])
                assert np.allclose(image_aug[..., 0], image_aug[..., 1])

                image = np.full((1, 1, 100), 0, dtype=dtype)
                aug = iaa.Add(iap.Uniform(-10, 10), per_channel=True)
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(-10 - 1e-2 < image_aug, image_aug < 10 + 1e-2))
                assert not np.allclose(image_aug[:, :, 1:], image_aug[:, :, :-1])

                image = np.full((50, 1, 3), 0, dtype=dtype)
                aug = iaa.Add(iap.DiscreteUniform(-10, 10))
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(-10 - 1e-2 < image_aug, image_aug < 10 + 1e-2))
                assert np.allclose(image_aug[1:, :, 0], image_aug[:-1, :, 0])
                assert np.allclose(image_aug[..., 0], image_aug[..., 1])

                image = np.full((1, 1, 100), 0, dtype=dtype)
                aug = iaa.Add(iap.DiscreteUniform(-10, 10), per_channel=True)
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="1594" endline="1683" pcid="2882">
                assert np.all(np.logical_and(10 <= image_aug, image_aug <= 30))
                assert len(np.unique(image_aug)) > 1

    def test_other_dtypes_float(self):
        # float
        for dtype in [np.float16, np.float32]:
            min_value, center_value, max_value = iadt.get_value_range_of_dtype(dtype)

            if dtype == np.float16:
                atol = 1e-3 * max_value
            else:
                atol = 1e-9 * max_value
            _allclose = functools.partial(np.allclose, atol=atol, rtol=0)

            image = np.full((3, 3), min_value, dtype=dtype)
            aug = iaa.AddElementwise(1)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, min_value + 1)

            image = np.full((3, 3), min_value + 10, dtype=dtype)
            aug = iaa.AddElementwise(11)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, min_value + 21)

            image = np.full((3, 3), max_value - 2, dtype=dtype)
            aug = iaa.AddElementwise(1)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, max_value - 1)

            image = np.full((3, 3), max_value - 1, dtype=dtype)
            aug = iaa.AddElementwise(1)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, max_value)

            image = np.full((3, 3), max_value - 1, dtype=dtype)
            aug = iaa.AddElementwise(2)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, max_value)

            image = np.full((3, 3), min_value + 10, dtype=dtype)
            aug = iaa.AddElementwise(-9)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, min_value + 1)

            image = np.full((3, 3), min_value + 10, dtype=dtype)
            aug = iaa.AddElementwise(-10)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, min_value)

            image = np.full((3, 3), min_value + 10, dtype=dtype)
            aug = iaa.AddElementwise(-11)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, min_value)

            for _ in sm.xrange(10):
                image = np.full((50, 1, 3), 0, dtype=dtype)
                aug = iaa.AddElementwise(iap.Uniform(-10, 10))
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(-10 - 1e-2 < image_aug, image_aug < 10 + 1e-2))
                assert not np.allclose(image_aug[1:, :, 0], image_aug[:-1, :, 0])
                assert np.allclose(image_aug[..., 0], image_aug[..., 1])

                image = np.full((1, 1, 100), 0, dtype=dtype)
                aug = iaa.AddElementwise(iap.Uniform(-10, 10), per_channel=True)
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(-10 - 1e-2 < image_aug, image_aug < 10 + 1e-2))
                assert not np.allclose(image_aug[:, :, 1:], image_aug[:, :, :-1])

                image = np.full((50, 1, 3), 0, dtype=dtype)
                aug = iaa.AddElementwise(iap.DiscreteUniform(-10, 10))
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(-10 - 1e-2 < image_aug, image_aug < 10 + 1e-2))
                assert not np.allclose(image_aug[1:, :, 0], image_aug[:-1, :, 0])
                assert np.allclose(image_aug[..., 0], image_aug[..., 1])

                image = np.full((1, 1, 100), 0, dtype=dtype)
                aug = iaa.AddElementwise(iap.DiscreteUniform(-10, 10), per_channel=True)
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
</source>
</class>

<class classid="148" nclones="2" nlines="20" similarity="95">
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="1379" endline="1402" pcid="2873">
        assert nb_changed_aug >= int(nb_iterations * 0.7)
        assert nb_changed_aug_det == 0

    def test_samples_change_by_spatial_location(self):
        # values should change between pixels
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        images = np.array([base_img])

        aug = iaa.AddElementwise(value=(-50, 50))

        nb_same = 0
        nb_different = 0
        nb_iterations = 1000
        for i in sm.xrange(nb_iterations):
            observed_aug = aug.augment_images(images)
            observed_aug_flat = observed_aug.flatten()
            last = None
            for j in sm.xrange(observed_aug_flat.size):
                if last is not None:
                    v = observed_aug_flat[j]
                    if v - 0.0001 <= last <= v + 0.0001:
                        nb_same += 1
                    else:
                        nb_different += 1
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="3723" endline="3746" pcid="3003">
                last_aug_det = observed_aug_det
            else:
                if not np.array_equal(observed_aug, last_aug):
                    nb_changed_aug += 1
                if not np.array_equal(observed_aug_det, last_aug_det):
                    nb_changed_aug_det += 1
                last_aug = observed_aug
                last_aug_det = observed_aug_det
        assert nb_changed_aug >= int(nb_iterations * 0.95)
        assert nb_changed_aug_det == 0

    def test_samples_change_by_spatial_location(self):
        # values should change between pixels
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        images = np.array([base_img])

        aug = iaa.MultiplyElementwise(mul=(0.5, 1.5))

        nb_same = 0
        nb_different = 0
        nb_iterations = 1000
        for i in sm.xrange(nb_iterations):
            observed_aug = aug.augment_images(images)
            observed_aug_flat = observed_aug.flatten()
</source>
</class>

<class classid="149" nclones="2" nlines="25" similarity="100">
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="1933" endline="1965" pcid="2900">
        assert aug.fill_mode is param

    @mock.patch("imgaug.augmenters.arithmetic.cutout_")
    def test_mocked__squared_false(self, mock_apply):
        aug = iaa.Cutout(nb_iterations=2,
                         position=(0.5, 0.6),
                         size=iap.DeterministicList([0.1, 0.2]),
                         squared=False,
                         fill_mode="gaussian",
                         cval=1,
                         fill_per_channel=True)
        image = np.zeros((10, 30, 3), dtype=np.uint8)

        # dont return image itself, otherwise the loop below will fail
        # at its second iteration as the method is expected to handle
        # internally a copy of the image and not the image itself
        mock_apply.return_value = np.copy(image)

        _ = aug(image=image)

        assert mock_apply.call_count == 2

        for call_idx in np.arange(2):
            args = mock_apply.call_args_list[call_idx][0]
            kwargs = mock_apply.call_args_list[call_idx][1]
            assert args[0] is not image
            assert np.array_equal(args[0], image)
            assert np.isclose(kwargs["x1"], 0.5*30 - 0.5 * (0.2*30))
            assert np.isclose(kwargs["y1"], 0.6*10 - 0.5 * (0.1*10))
            assert np.isclose(kwargs["x2"], 0.5*30 + 0.5 * (0.2*30))
            assert np.isclose(kwargs["y2"], 0.6*10 + 0.5 * (0.1*10))
            assert kwargs["fill_mode"] == "gaussian"
            assert np.array_equal(kwargs["cval"], [1, 1, 1])
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="1967" endline="1999" pcid="2901">
            assert isinstance(kwargs["seed"], iarandom.RNG)

    @mock.patch("imgaug.augmenters.arithmetic.cutout_")
    def test_mocked__squared_true(self, mock_apply):
        aug = iaa.Cutout(nb_iterations=2,
                         position=(0.5, 0.6),
                         size=iap.DeterministicList([0.1, 0.2]),
                         squared=True,
                         fill_mode="gaussian",
                         cval=1,
                         fill_per_channel=True)
        image = np.zeros((10, 30, 3), dtype=np.uint8)

        # dont return image itself, otherwise the loop below will fail
        # at its second iteration as the method is expected to handle
        # internally a copy of the image and not the image itself
        mock_apply.return_value = np.copy(image)

        _ = aug(image=image)

        assert mock_apply.call_count == 2

        for call_idx in np.arange(2):
            args = mock_apply.call_args_list[call_idx][0]
            kwargs = mock_apply.call_args_list[call_idx][1]
            assert args[0] is not image
            assert np.array_equal(args[0], image)
            assert np.isclose(kwargs["x1"], 0.5*30 - 0.5 * (0.1*10))
            assert np.isclose(kwargs["y1"], 0.6*10 - 0.5 * (0.1*10))
            assert np.isclose(kwargs["x2"], 0.5*30 + 0.5 * (0.1*10))
            assert np.isclose(kwargs["y2"], 0.6*10 + 0.5 * (0.1*10))
            assert kwargs["fill_mode"] == "gaussian"
            assert np.array_equal(kwargs["cval"], [1, 1, 1])
</source>
</class>

<class classid="150" nclones="3" nlines="16" similarity="75">
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="2327" endline="2344" pcid="2916">
            elif 1.0-0.01 <= p_observed <= 1.0:
                nb_seen[2] += 1
            else:
                nb_seen[3] += 1
        assert np.allclose(nb_seen[0:3], nb_iterations*0.33, rtol=0, atol=75)
        assert nb_seen[3] < 30

    def test_stochastic_parameter_as_p(self):
        # varying p by stochastic parameter
        aug = iaa.Dropout(p=iap.Binomial(1-iap.Choice([0.0, 0.5])))
        images = np.ones((1, 20, 20, 1), dtype=np.uint8) * 255
        seen = [0, 0, 0]
        for i in sm.xrange(400):
            observed = aug.augment_images(images)
            p = np.mean(observed == 0)
            if 0.4 < p < 0.6:
                seen[0] += 1
            elif p < 0.1:
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="4174" endline="4192" pcid="3019">
        img = np.ones((100, 100, 1), dtype=np.uint8)

        nb_iterations = 100
        nb_diff_all = 0
        for i in sm.xrange(nb_iterations):
            observed = aug.augment_image(img)
            nb_diff = np.sum(img != observed)
            nb_diff_all += nb_diff
        p = nb_diff_all / (nb_iterations * 100 * 100)
        assert 0.45 <= p <= 0.55

    def test_mask_is_list(self):
        # mask is list
        aug = iaa.ReplaceElementwise(mask=[0.2, 0.7], replacement=1)
        img = np.zeros((20, 20, 1), dtype=np.uint8)

        seen = [0, 0, 0]
        for i in sm.xrange(400):
            observed = aug.augment_image(img)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="2416" endline="2433" pcid="2926">
            observed = aug.augment_image(base_img)
            avgs = np.average(observed, axis=(0, 1))
            if len(set(avgs)) >= 2:
                found = True
                break
        assert found

    def test_stochastic_parameter_as_p(self):
        # varying p by stochastic parameter
        aug = iaa.CoarseDropout(p=iap.Binomial(1-iap.Choice([0.0, 0.5])), size_px=50)
        images = np.ones((1, 100, 100, 1), dtype=np.uint8) * 255
        seen = [0, 0, 0]
        for i in sm.xrange(400):
            observed = aug.augment_images(images)
            p = np.mean(observed == 0)
            if 0.4 < p < 0.6:
                seen[0] += 1
            elif p < 0.1:
</source>
</class>

<class classid="151" nclones="5" nlines="17" similarity="78">
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="2529" endline="2550" pcid="2939">
        ])
        segmaps = ia.SegmentationMapsOnImage(arr, shape=(2, 2, 3))

        segmaps_aug = aug(segmentation_maps=segmaps)

        assert np.allclose(segmaps_aug.arr, 0.0)

    def test_p_is_1_cbaois(self):
        cbaois = [
            ia.KeypointsOnImage([ia.Keypoint(x=0, y=1)], shape=(2, 2, 3)),
            ia.BoundingBoxesOnImage([ia.BoundingBox(x1=0, y1=1, x2=2, y2=3)],
                                    shape=(2, 2, 3)),
            ia.PolygonsOnImage([ia.Polygon([(0, 0), (1, 0), (1, 1)])],
                               shape=(2, 2, 3)),
            ia.LineStringsOnImage([ia.LineString([(0, 0), (1, 0)])],
                                  shape=(2, 2, 3))
        ]

        cbaoi_names = ["keypoints", "bounding_boxes", "polygons",
                       "line_strings"]

        aug = iaa.Dropout2d(p=1.0, nb_keep_channels=0)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="2634" endline="2658" pcid="2946">
        ])
        segmaps = ia.SegmentationMapsOnImage(arr, shape=(2, 2, 3))

        segmaps_aug = aug(segmentation_maps=segmaps)

        assert np.allclose(segmaps_aug.arr, segmaps.arr)

    def test_p_is_0_cbaois(self):
        cbaois = [
            ia.KeypointsOnImage([ia.Keypoint(x=0, y=1)], shape=(2, 2, 3)),
            ia.BoundingBoxesOnImage([ia.BoundingBox(x1=0, y1=1, x2=2, y2=3)],
                                    shape=(2, 2, 3)),
            ia.PolygonsOnImage([ia.Polygon([(0, 0), (1, 0), (1, 1)])],
                               shape=(2, 2, 3)),
            ia.LineStringsOnImage([ia.LineString([(0, 0), (1, 0)])],
                                  shape=(2, 2, 3))
        ]

        cbaoi_names = ["keypoints", "bounding_boxes", "polygons",
                       "line_strings"]

        aug = iaa.Dropout2d(p=0.0, nb_keep_channels=0)
        for name, cbaoi in zip(cbaoi_names, cbaois):
            with self.subTest(datatype=name):
                cbaoi_aug = aug(**{name: cbaoi})
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="2961" endline="2985" pcid="2970">
            [0, 1],
            [0, 1]
        ])
        segmaps = ia.SegmentationMapsOnImage(arr, shape=(2, 2, 3))

        segmaps_aug = aug(segmentation_maps=segmaps)

        assert np.allclose(segmaps_aug.arr, segmaps.arr)

    def test_p_is_0_cbaois(self):
        cbaois = [
            ia.KeypointsOnImage([ia.Keypoint(x=0, y=1)], shape=(2, 2, 3)),
            ia.BoundingBoxesOnImage([ia.BoundingBox(x1=0, y1=1, x2=2, y2=3)],
                                    shape=(2, 2, 3)),
            ia.PolygonsOnImage([ia.Polygon([(0, 0), (1, 0), (1, 1)])],
                               shape=(2, 2, 3)),
            ia.LineStringsOnImage([ia.LineString([(0, 0), (1, 0)])],
                                  shape=(2, 2, 3))
        ]

        cbaoi_names = ["keypoints", "bounding_boxes", "polygons",
                       "line_strings"]

        aug = iaa.TotalDropout(p=0.0)
        for name, cbaoi in zip(cbaoi_names, cbaois):
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="2575" endline="2599" pcid="2942">
        ])
        segmaps = ia.SegmentationMapsOnImage(arr, shape=(2, 2, 3))

        segmaps_aug = aug(segmentation_maps=segmaps)

        assert np.allclose(segmaps_aug.arr, segmaps.arr)

    def test_p_is_1_cbaois__keep_one_channel(self):
        cbaois = [
            ia.KeypointsOnImage([ia.Keypoint(x=0, y=1)], shape=(2, 2, 3)),
            ia.BoundingBoxesOnImage([ia.BoundingBox(x1=0, y1=1, x2=2, y2=3)],
                                    shape=(2, 2, 3)),
            ia.PolygonsOnImage([ia.Polygon([(0, 0), (1, 0), (1, 1)])],
                               shape=(2, 2, 3)),
            ia.LineStringsOnImage([ia.LineString([(0, 0), (1, 0)])],
                                  shape=(2, 2, 3))
        ]

        cbaoi_names = ["keypoints", "bounding_boxes", "polygons",
                       "line_strings"]

        aug = iaa.Dropout2d(p=1.0, nb_keep_channels=1)
        for name, cbaoi in zip(cbaoi_names, cbaois):
            with self.subTest(datatype=name):
                cbaoi_aug = aug(**{name: cbaoi})
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="2881" endline="2902" pcid="2964">
            [0, 1],
            [0, 1]
        ])
        segmaps = ia.SegmentationMapsOnImage(arr, shape=(2, 2, 3))

        segmaps_aug = aug(segmentation_maps=segmaps)

        assert np.allclose(segmaps_aug.arr, 0.0)

    def test_p_is_1_cbaois(self):
        cbaois = [
            ia.KeypointsOnImage([ia.Keypoint(x=0, y=1)], shape=(2, 2, 3)),
            ia.BoundingBoxesOnImage([ia.BoundingBox(x1=0, y1=1, x2=2, y2=3)],
                                    shape=(2, 2, 3)),
            ia.PolygonsOnImage([ia.Polygon([(0, 0), (1, 0), (1, 1)])],
                               shape=(2, 2, 3)),
            ia.LineStringsOnImage([ia.LineString([(0, 0), (1, 0)])],
                                  shape=(2, 2, 3))
        ]

        cbaoi_names = ["keypoints", "bounding_boxes", "polygons",
                       "line_strings"]
</source>
</class>

<class classid="152" nclones="2" nlines="26" similarity="100">
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="3348" endline="3379" pcid="2993">
        assert isinstance(params[1], iap.Deterministic)
        assert params[0].value == 1
        assert params[1].value == 0

    def test_heatmaps_dont_change(self):
        # test heatmaps (not affected by augmenter)
        aug = iaa.Multiply(mul=2)
        hm = ia.quokka_heatmap()
        hm_aug = aug.augment_heatmaps([hm])[0]
        assert np.allclose(hm.arr_0to1, hm_aug.arr_0to1)

    def test_other_dtypes_bool(self):
        # bool
        image = np.zeros((3, 3), dtype=bool)
        aug = iaa.Multiply(1.0)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == np.bool_
        assert np.all(image_aug == 0)

        image = np.full((3, 3), True, dtype=bool)
        aug = iaa.Multiply(1.0)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == np.bool_
        assert np.all(image_aug == 1)

        image = np.full((3, 3), True, dtype=bool)
        aug = iaa.Multiply(2.0)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == np.bool_
        assert np.all(image_aug == 1)

        image = np.full((3, 3), True, dtype=bool)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="3847" endline="3878" pcid="3011">
        assert isinstance(params[1], iap.Deterministic)
        assert params[0].value == 1
        assert params[1].value == 0

    def test_heatmaps_dont_change(self):
        # test heatmaps (not affected by augmenter)
        aug = iaa.MultiplyElementwise(mul=2)
        hm = ia.quokka_heatmap()
        hm_aug = aug.augment_heatmaps([hm])[0]
        assert np.allclose(hm.arr_0to1, hm_aug.arr_0to1)

    def test_other_dtypes_bool(self):
        # bool
        image = np.zeros((3, 3), dtype=bool)
        aug = iaa.MultiplyElementwise(1.0)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == np.bool_
        assert np.all(image_aug == 0)

        image = np.full((3, 3), True, dtype=bool)
        aug = iaa.MultiplyElementwise(1.0)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == np.bool_
        assert np.all(image_aug == 1)

        image = np.full((3, 3), True, dtype=bool)
        aug = iaa.MultiplyElementwise(2.0)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == np.bool_
        assert np.all(image_aug == 1)

        image = np.full((3, 3), True, dtype=bool)
</source>
</class>

<class classid="153" nclones="2" nlines="91" similarity="74">
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="3380" endline="3500" pcid="2994">
        aug = iaa.Multiply(0.0)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == np.bool_
        assert np.all(image_aug == 0)

        image = np.full((3, 3), True, dtype=bool)
        aug = iaa.Multiply(-1.0)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == np.bool_
        assert np.all(image_aug == 0)

    def test_other_dtypes_uint_int(self):
        # uint, int
        for dtype in [np.uint8, np.uint16, np.int8, np.int16]:
            dtype = np.dtype(dtype)
            min_value, center_value, max_value = iadt.get_value_range_of_dtype(dtype)

            image = np.full((3, 3), 10, dtype=dtype)
            aug = iaa.Multiply(1)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == 10)

            image = np.full((3, 3), 10, dtype=dtype)
            aug = iaa.Multiply(10)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == 100)

            image = np.full((3, 3), 10, dtype=dtype)
            aug = iaa.Multiply(0.5)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == 5)

            image = np.full((3, 3), 0, dtype=dtype)
            aug = iaa.Multiply(0)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == 0)

            if np.dtype(dtype).kind == "u":
                image = np.full((3, 3), 10, dtype=dtype)
                aug = iaa.Multiply(-1)
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(image_aug == 0)
            else:
                image = np.full((3, 3), 10, dtype=dtype)
                aug = iaa.Multiply(-1)
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(image_aug == -10)

            image = np.full((3, 3), int(center_value), dtype=dtype)
            aug = iaa.Multiply(1)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == int(center_value))

            image = np.full((3, 3), int(center_value), dtype=dtype)
            aug = iaa.Multiply(1.2)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == int(1.2 * int(center_value)))

            if np.dtype(dtype).kind == "u":
                image = np.full((3, 3), int(center_value), dtype=dtype)
                aug = iaa.Multiply(100)
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(image_aug == max_value)

            image = np.full((3, 3), max_value, dtype=dtype)
            aug = iaa.Multiply(1)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == max_value)

            # non-uint8 currently don't increase the itemsize
            if dtype.name == "uint8":
                image = np.full((3, 3), max_value, dtype=dtype)
                aug = iaa.Multiply(10)
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(image_aug == max_value)

            image = np.full((3, 3), max_value, dtype=dtype)
            aug = iaa.Multiply(0)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == 0)

            # non-uint8 currently don't increase the itemsize
            if dtype.name == "uint8":
                image = np.full((3, 3), max_value, dtype=dtype)
                aug = iaa.Multiply(-2)
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(image_aug == min_value)

            # non-uint8 currently don't increase the itemsize
            if dtype.name == "uint8":
                for _ in sm.xrange(10):
                    image = np.full((1, 1, 3), 10, dtype=dtype)
                    aug = iaa.Multiply(iap.Uniform(0.5, 1.5))
                    image_aug = aug.augment_image(image)
                    assert image_aug.dtype.type == dtype
                    assert np.all(np.logical_and(5 <= image_aug, image_aug <= 15))
                    assert len(np.unique(image_aug)) == 1

                    image = np.full((1, 1, 100), 10, dtype=dtype)
                    aug = iaa.Multiply(iap.Uniform(0.5, 1.5), per_channel=True)
                    image_aug = aug.augment_image(image)
                    assert image_aug.dtype.type == dtype
                    assert np.all(np.logical_and(5 <= image_aug, image_aug <= 15))
                    assert len(np.unique(image_aug)) > 1

                    image = np.full((1, 1, 3), 10, dtype=dtype)
                    aug = iaa.Multiply(iap.DiscreteUniform(1, 3))
                    image_aug = aug.augment_image(image)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="3879" endline="4005" pcid="3012">
        aug = iaa.MultiplyElementwise(0.0)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == np.bool_
        assert np.all(image_aug == 0)

        image = np.full((3, 3), True, dtype=bool)
        aug = iaa.MultiplyElementwise(-1.0)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == np.bool_
        assert np.all(image_aug == 0)

    def test_other_dtypes_uint_int(self):
        # uint, int
        for dtype in [np.uint8, np.uint16, np.int8, np.int16]:
            dtype = np.dtype(dtype)
            min_value, center_value, max_value = iadt.get_value_range_of_dtype(dtype)

            image = np.full((3, 3), 10, dtype=dtype)
            aug = iaa.MultiplyElementwise(1)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == 10)

            # deactivated, because itemsize increase was deactivated
            # image = np.full((3, 3), 10, dtype=dtype)
            # aug = iaa.MultiplyElementwise(10)
            # image_aug = aug.augment_image(image)
            # assert image_aug.dtype.type == dtype
            # assert np.all(image_aug == 100)

            image = np.full((3, 3), 10, dtype=dtype)
            aug = iaa.MultiplyElementwise(0.5)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == 5)

            image = np.full((3, 3), 0, dtype=dtype)
            aug = iaa.MultiplyElementwise(0)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == 0)

            # partially deactivated, because itemsize increase was deactivated
            if dtype.name == "uint8":
                if dtype.kind == "u":
                    image = np.full((3, 3), 10, dtype=dtype)
                    aug = iaa.MultiplyElementwise(-1)
                    image_aug = aug.augment_image(image)
                    assert image_aug.dtype.type == dtype
                    assert np.all(image_aug == 0)
                else:
                    image = np.full((3, 3), 10, dtype=dtype)
                    aug = iaa.MultiplyElementwise(-1)
                    image_aug = aug.augment_image(image)
                    assert image_aug.dtype.type == dtype
                    assert np.all(image_aug == -10)

            image = np.full((3, 3), int(center_value), dtype=dtype)
            aug = iaa.MultiplyElementwise(1)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == int(center_value))

            # deactivated, because itemsize increase was deactivated
            # image = np.full((3, 3), int(center_value), dtype=dtype)
            # aug = iaa.MultiplyElementwise(1.2)
            # image_aug = aug.augment_image(image)
            # assert image_aug.dtype.type == dtype
            # assert np.all(image_aug == int(1.2 * int(center_value)))

            # deactivated, because itemsize increase was deactivated
            if dtype.name == "uint8":
                if dtype.kind == "u":
                    image = np.full((3, 3), int(center_value), dtype=dtype)
                    aug = iaa.MultiplyElementwise(100)
                    image_aug = aug.augment_image(image)
                    assert image_aug.dtype.type == dtype
                    assert np.all(image_aug == max_value)

            image = np.full((3, 3), max_value, dtype=dtype)
            aug = iaa.MultiplyElementwise(1)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == max_value)

            # deactivated, because itemsize increase was deactivated
            # image = np.full((3, 3), max_value, dtype=dtype)
            # aug = iaa.MultiplyElementwise(10)
            # image_aug = aug.augment_image(image)
            # assert image_aug.dtype.type == dtype
            # assert np.all(image_aug == max_value)

            image = np.full((3, 3), max_value, dtype=dtype)
            aug = iaa.MultiplyElementwise(0)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == 0)

            # deactivated, because itemsize increase was deactivated
            # image = np.full((3, 3), max_value, dtype=dtype)
            # aug = iaa.MultiplyElementwise(-2)
            # image_aug = aug.augment_image(image)
            # assert image_aug.dtype.type == dtype
            # assert np.all(image_aug == min_value)

            # partially deactivated, because itemsize increase was deactivated
            if dtype.name == "uint8":
                for _ in sm.xrange(10):
                    image = np.full((5, 5, 3), 10, dtype=dtype)
                    aug = iaa.MultiplyElementwise(iap.Uniform(0.5, 1.5))
                    image_aug = aug.augment_image(image)
                    assert image_aug.dtype.type == dtype
                    assert np.all(np.logical_and(5 <= image_aug, image_aug <= 15))
                    assert len(np.unique(image_aug)) > 1
                    assert np.all(image_aug[..., 0] == image_aug[..., 1])

                    image = np.full((1, 1, 100), 10, dtype=dtype)
                    aug = iaa.MultiplyElementwise(iap.Uniform(0.5, 1.5), per_channel=True)
                    image_aug = aug.augment_image(image)
                    assert image_aug.dtype.type == dtype
                    assert np.all(np.logical_and(5 <= image_aug, image_aug <= 15))
                    assert len(np.unique(image_aug)) > 1

                    image = np.full((5, 5, 3), 10, dtype=dtype)
                    aug = iaa.MultiplyElementwise(iap.DiscreteUniform(1, 3))
                    image_aug = aug.augment_image(image)
                    assert image_aug.dtype.type == dtype
</source>
</class>

<class classid="154" nclones="2" nlines="32" similarity="85">
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="3501" endline="3590" pcid="2995">
                    assert image_aug.dtype.type == dtype
                    assert np.all(np.logical_and(10 <= image_aug, image_aug <= 30))
                    assert len(np.unique(image_aug)) == 1

                    image = np.full((1, 1, 100), 10, dtype=dtype)
                    aug = iaa.Multiply(iap.DiscreteUniform(1, 3), per_channel=True)
                    image_aug = aug.augment_image(image)
                    assert image_aug.dtype.type == dtype
                    assert np.all(np.logical_and(10 <= image_aug, image_aug <= 30))
                    assert len(np.unique(image_aug)) > 1

    def test_other_dtypes_float(self):
        # float
        for dtype in [np.float16, np.float32]:
            min_value, center_value, max_value = iadt.get_value_range_of_dtype(dtype)

            if dtype == np.float16:
                atol = 1e-3 * max_value
            else:
                atol = 1e-9 * max_value
            _allclose = functools.partial(np.allclose, atol=atol, rtol=0)

            image = np.full((3, 3), 10.0, dtype=dtype)
            aug = iaa.Multiply(1.0)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, 10.0)

            image = np.full((3, 3), 10.0, dtype=dtype)
            aug = iaa.Multiply(2.0)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, 20.0)

            # deactivated, because itemsize increase was deactivated
            # image = np.full((3, 3), max_value, dtype=dtype)
            # aug = iaa.Multiply(-10)
            # image_aug = aug.augment_image(image)
            # assert image_aug.dtype.type == dtype
            # assert _allclose(image_aug, min_value)

            image = np.full((3, 3), max_value, dtype=dtype)
            aug = iaa.Multiply(0.0)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, 0.0)

            image = np.full((3, 3), max_value, dtype=dtype)
            aug = iaa.Multiply(0.5)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, 0.5*max_value)

            # deactivated, because itemsize increase was deactivated
            # image = np.full((3, 3), min_value, dtype=dtype)
            # aug = iaa.Multiply(-2.0)
            # image_aug = aug.augment_image(image)
            # assert image_aug.dtype.type == dtype
            # assert _allclose(image_aug, max_value)

            image = np.full((3, 3), min_value, dtype=dtype)
            aug = iaa.Multiply(0.0)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, 0.0)

            # using tolerances of -100 - 1e-2 and 100 + 1e-2 is not enough for float16, had to be increased to -/+ 1e-1
            # deactivated, because itemsize increase was deactivated
            """
            for _ in sm.xrange(10):
                image = np.full((1, 1, 3), 10.0, dtype=dtype)
                aug = iaa.Multiply(iap.Uniform(-10, 10))
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(-100 - 1e-1 < image_aug, image_aug < 100 + 1e-1))
                assert np.allclose(image_aug[1:, :, 0], image_aug[:-1, :, 0])
                assert np.allclose(image_aug[..., 0], image_aug[..., 1])

                image = np.full((1, 1, 100), 10.0, dtype=dtype)
                aug = iaa.Multiply(iap.Uniform(-10, 10), per_channel=True)
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(-100 - 1e-1 < image_aug, image_aug < 100 + 1e-1))
                assert not np.allclose(image_aug[:, :, 1:], image_aug[:, :, :-1])

                image = np.full((1, 1, 3), 10.0, dtype=dtype)
                aug = iaa.Multiply(iap.DiscreteUniform(-10, 10))
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(-100 - 1e-1 < image_aug, image_aug < 100 + 1e-1))
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="4006" endline="4097" pcid="3013">
                    assert np.all(np.logical_and(10 <= image_aug, image_aug <= 30))
                    assert len(np.unique(image_aug)) > 1
                    assert np.all(image_aug[..., 0] == image_aug[..., 1])

                    image = np.full((1, 1, 100), 10, dtype=dtype)
                    aug = iaa.MultiplyElementwise(iap.DiscreteUniform(1, 3), per_channel=True)
                    image_aug = aug.augment_image(image)
                    assert image_aug.dtype.type == dtype
                    assert np.all(np.logical_and(10 <= image_aug, image_aug <= 30))
                    assert len(np.unique(image_aug)) > 1

    def test_other_dtypes_float(self):
        # float
        for dtype in [np.float16, np.float32]:
            dtype = np.dtype(dtype)
            min_value, center_value, max_value = iadt.get_value_range_of_dtype(dtype)

            if dtype == np.float16:
                atol = 1e-3 * max_value
            else:
                atol = 1e-9 * max_value
            _allclose = functools.partial(np.allclose, atol=atol, rtol=0)

            image = np.full((3, 3), 10.0, dtype=dtype)
            aug = iaa.MultiplyElementwise(1.0)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, 10.0)

            # deactivated, because itemsize increase was deactivated
            # image = np.full((3, 3), 10.0, dtype=dtype)
            # aug = iaa.MultiplyElementwise(2.0)
            # image_aug = aug.augment_image(image)
            # assert image_aug.dtype.type == dtype
            # assert _allclose(image_aug, 20.0)

            # deactivated, because itemsize increase was deactivated
            # image = np.full((3, 3), max_value, dtype=dtype)
            # aug = iaa.MultiplyElementwise(-10)
            # image_aug = aug.augment_image(image)
            # assert image_aug.dtype.type == dtype
            # assert _allclose(image_aug, min_value)

            image = np.full((3, 3), max_value, dtype=dtype)
            aug = iaa.MultiplyElementwise(0.0)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, 0.0)

            image = np.full((3, 3), max_value, dtype=dtype)
            aug = iaa.MultiplyElementwise(0.5)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, 0.5*max_value)

            # deactivated, because itemsize increase was deactivated
            # image = np.full((3, 3), min_value, dtype=dtype)
            # aug = iaa.MultiplyElementwise(-2.0)
            # image_aug = aug.augment_image(image)
            # assert image_aug.dtype.type == dtype
            # assert _allclose(image_aug, max_value)

            image = np.full((3, 3), min_value, dtype=dtype)
            aug = iaa.MultiplyElementwise(0.0)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, 0.0)

            # using tolerances of -100 - 1e-2 and 100 + 1e-2 is not enough for float16, had to be increased to -/+ 1e-1
            # deactivated, because itemsize increase was deactivated
            """
            for _ in sm.xrange(10):
                image = np.full((50, 1, 3), 10.0, dtype=dtype)
                aug = iaa.MultiplyElementwise(iap.Uniform(-10, 10))
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(-100 - 1e-1 < image_aug, image_aug < 100 + 1e-1))
                assert not np.allclose(image_aug[1:, :, 0], image_aug[:-1, :, 0])
                assert np.allclose(image_aug[..., 0], image_aug[..., 1])

                image = np.full((1, 1, 100), 10.0, dtype=dtype)
                aug = iaa.MultiplyElementwise(iap.Uniform(-10, 10), per_channel=True)
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(-100 - 1e-1 < image_aug, image_aug < 100 + 1e-1))
                assert not np.allclose(image_aug[:, :, 1:], image_aug[:, :, :-1])

                image = np.full((50, 1, 3), 10.0, dtype=dtype)
                aug = iaa.MultiplyElementwise(iap.DiscreteUniform(-10, 10))
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(-100 - 1e-1 < image_aug, image_aug < 100 + 1e-1))
</source>
</class>

<class classid="155" nclones="3" nlines="15" similarity="100">
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="4518" endline="4533" pcid="3038">
class TestCoarseSaltAndPepper(unittest.TestCase):
    def setUp(self):
        reseed()

    def test_p_is_fifty_percent(self):
        base_img = np.zeros((100, 100, 1), dtype=np.uint8) + 128
        aug = iaa.CoarseSaltAndPepper(p=0.5, size_px=100)
        observed = aug.augment_image(base_img)
        p = np.mean(observed != 128)
        assert 0.4 < p < 0.6

    def test_size_px(self):
        aug1 = iaa.CoarseSaltAndPepper(p=0.5, size_px=100)
        aug2 = iaa.CoarseSaltAndPepper(p=0.5, size_px=10)
        base_img = np.zeros((100, 100, 1), dtype=np.uint8) + 128
        ps1 = []
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="4636" endline="4651" pcid="3051">
class TestCoarseSalt(unittest.TestCase):
    def setUp(self):
        reseed()

    def test_p_is_fifty_percent(self):
        base_img = np.zeros((100, 100, 1), dtype=np.uint8) + 128
        aug = iaa.CoarseSalt(p=0.5, size_px=100)
        observed = aug.augment_image(base_img)
        p = np.mean(observed != 128)
        assert 0.4 < p < 0.6

    def test_size_px(self):
        aug1 = iaa.CoarseSalt(p=0.5, size_px=100)
        aug2 = iaa.CoarseSalt(p=0.5, size_px=10)
        base_img = np.zeros((100, 100, 1), dtype=np.uint8) + 128
        ps1 = []
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="4753" endline="4768" pcid="3064">
class TestCoarsePepper(unittest.TestCase):
    def setUp(self):
        reseed()

    def test_p_is_fifty_percent(self):
        base_img = np.zeros((100, 100, 1), dtype=np.uint8) + 128
        aug = iaa.CoarsePepper(p=0.5, size_px=100)
        observed = aug.augment_image(base_img)
        p = np.mean(observed != 128)
        assert 0.4 < p < 0.6

    def test_size_px(self):
        aug1 = iaa.CoarsePepper(p=0.5, size_px=100)
        aug2 = iaa.CoarsePepper(p=0.5, size_px=10)
        base_img = np.zeros((100, 100, 1), dtype=np.uint8) + 128
        ps1 = []
</source>
</class>

<class classid="156" nclones="3" nlines="18" similarity="100">
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="4534" endline="4552" pcid="3039">
        ps2 = []
        for _ in sm.xrange(100):
            observed1 = aug1.augment_image(base_img)
            observed2 = aug2.augment_image(base_img)
            p1 = np.mean(observed1 != 128)
            p2 = np.mean(observed2 != 128)
            ps1.append(p1)
            ps2.append(p2)
        assert 0.4 < np.mean(ps2) < 0.6
        assert np.std(ps1)*1.5 < np.std(ps2)

    def test_p_is_list(self):
        aug = iaa.CoarseSaltAndPepper(p=[0.2, 0.5], size_px=100)
        base_img = np.zeros((100, 100, 1), dtype=np.uint8) + 128
        seen = [0, 0, 0]
        for _ in sm.xrange(200):
            observed = aug.augment_image(base_img)
            p = np.mean(observed != 128)
            diff_020 = abs(0.2 - p)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="4652" endline="4670" pcid="3052">
        ps2 = []
        for _ in sm.xrange(100):
            observed1 = aug1.augment_image(base_img)
            observed2 = aug2.augment_image(base_img)
            p1 = np.mean(observed1 != 128)
            p2 = np.mean(observed2 != 128)
            ps1.append(p1)
            ps2.append(p2)
        assert 0.4 < np.mean(ps2) < 0.6
        assert np.std(ps1)*1.5 < np.std(ps2)

    def test_p_is_list(self):
        aug = iaa.CoarseSalt(p=[0.2, 0.5], size_px=100)
        base_img = np.zeros((100, 100, 1), dtype=np.uint8) + 128
        seen = [0, 0, 0]
        for _ in sm.xrange(200):
            observed = aug.augment_image(base_img)
            p = np.mean(observed != 128)
            diff_020 = abs(0.2 - p)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="4769" endline="4787" pcid="3065">
        ps2 = []
        for _ in sm.xrange(100):
            observed1 = aug1.augment_image(base_img)
            observed2 = aug2.augment_image(base_img)
            p1 = np.mean(observed1 != 128)
            p2 = np.mean(observed2 != 128)
            ps1.append(p1)
            ps2.append(p2)
        assert 0.4 < np.mean(ps2) < 0.6
        assert np.std(ps1)*1.5 < np.std(ps2)

    def test_p_is_list(self):
        aug = iaa.CoarsePepper(p=[0.2, 0.5], size_px=100)
        base_img = np.zeros((100, 100, 1), dtype=np.uint8) + 128
        seen = [0, 0, 0]
        for _ in sm.xrange(200):
            observed = aug.augment_image(base_img)
            p = np.mean(observed != 128)
            diff_020 = abs(0.2 - p)
</source>
</class>

<class classid="157" nclones="3" nlines="14" similarity="100">
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="4553" endline="4568" pcid="3040">
            diff_050 = abs(0.5 - p)
            if diff_020 < 0.025:
                seen[0] += 1
            elif diff_050 < 0.025:
                seen[1] += 1
            else:
                seen[2] += 1
        assert seen[2] < 10
        assert 75 < seen[0] < 125
        assert 75 < seen[1] < 125

    def test_p_is_tuple(self):
        aug = iaa.CoarseSaltAndPepper(p=(0.0, 1.0), size_px=50)
        base_img = np.zeros((50, 50, 1), dtype=np.uint8) + 128
        ps = []
        for _ in sm.xrange(200):
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="4788" endline="4803" pcid="3066">
            diff_050 = abs(0.5 - p)
            if diff_020 < 0.025:
                seen[0] += 1
            elif diff_050 < 0.025:
                seen[1] += 1
            else:
                seen[2] += 1
        assert seen[2] < 10
        assert 75 < seen[0] < 125
        assert 75 < seen[1] < 125

    def test_p_is_tuple(self):
        aug = iaa.CoarsePepper(p=(0.0, 1.0), size_px=50)
        base_img = np.zeros((50, 50, 1), dtype=np.uint8) + 128
        ps = []
        for _ in sm.xrange(200):
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="4671" endline="4686" pcid="3053">
            diff_050 = abs(0.5 - p)
            if diff_020 < 0.025:
                seen[0] += 1
            elif diff_050 < 0.025:
                seen[1] += 1
            else:
                seen[2] += 1
        assert seen[2] < 10
        assert 75 < seen[0] < 125
        assert 75 < seen[1] < 125

    def test_p_is_tuple(self):
        aug = iaa.CoarseSalt(p=(0.0, 1.0), size_px=50)
        base_img = np.zeros((50, 50, 1), dtype=np.uint8) + 128
        ps = []
        for _ in sm.xrange(200):
</source>
</class>

<class classid="158" nclones="9" nlines="19" similarity="70">
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="4898" endline="4919" pcid="3076">
        assert np.array_equal(observed, expected)

    def test_arr_is_view_uint8(self):
        zeros = np.zeros((4, 4, 3), dtype=np.uint8)
        max_vr_view = np.copy(zeros + 255)[:, :, [0, 2]]

        observed = iaa.invert_(max_vr_view)
        expected = zeros[:, :, [0, 2]]
        assert observed.dtype.name == "uint8"
        assert np.array_equal(observed, expected)

    def test_uint(self):
        dtypes = ["uint8", "uint16", "uint32", "uint64"]
        for dt in dtypes:
            with self.subTest(dtype=dt):
                min_value, center_value, max_value = \
                    iadt.get_value_range_of_dtype(dt)
                center_value = int(center_value)

                values = np.array([0, 20, 45, 60, center_value, max_value],
                                  dtype=dt)
                expected = np.array([
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="5020" endline="5044" pcid="3081">
                                  dtype=dt)
                expected = np.array([
                    0,
                    20,
                    45,
                    60,
                    center_value,
                    max_value
                ], dtype=dt)

                observed = iaa.invert_(np.copy(values),
                                       threshold=threshold,
                                       invert_above_threshold=True)

                assert np.array_equal(observed, expected)

    def test_uint_with_threshold_50_inv_below(self):
        threshold = 50
        dtypes = ["uint8", "uint16", "uint32", "uint64"]
        for dt in dtypes:
            with self.subTest(dtype=dt):
                min_value, center_value, max_value = \
                    iadt.get_value_range_of_dtype(dt)
                center_value = int(center_value)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="4945" endline="4969" pcid="3078">
                    20,
                    45,
                    max_value - 60,
                    max_value - center_value,
                    min_value
                ], dtype=dt)

                observed = iaa.invert_(np.copy(values),
                                       threshold=threshold,
                                       invert_above_threshold=True)

                assert np.array_equal(observed, expected)

    def test_uint_with_threshold_0_inv_above(self):
        threshold = 0
        dtypes = ["uint8", "uint16", "uint32", "uint64"]
        for dt in dtypes:
            with self.subTest(dtype=dt):
                min_value, center_value, max_value = \
                    iadt.get_value_range_of_dtype(dt)
                center_value = int(center_value)

                values = np.array([0, 20, 45, 60, center_value, max_value],
                                  dtype=dt)
                expected = np.array([
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="5098" endline="5122" pcid="3084">
                center_value = int(center_value)

                values = np.array([-45, -20, center_value, 20, 45, max_value],
                                  dtype=dt)
                expected = np.array([
                    -45,
                    -20,
                    center_value,
                    20,
                    45,
                    min_value
                ], dtype=dt)

                observed = iaa.invert_(np.copy(values),
                                       threshold=threshold,
                                       invert_above_threshold=True)

                assert np.array_equal(observed, expected)

    def test_int_with_threshold_50_inv_below(self):
        threshold = 50
        dtypes = ["int8", "int16", "int32", "int64"]
        for dt in dtypes:
            with self.subTest(dtype=dt):
                min_value, center_value, max_value = \
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="5073" endline="5097" pcid="3083">
                                  dtype=dt)
                expected = np.array([
                    0,  # not clipped to 10 as only >thresh affected
                    20,
                    45,
                    100 - 50,
                    100 - 90,
                    100 - 90
                ], dtype=dt)

                observed = iaa.invert_(np.copy(values),
                                       min_value=10,
                                       max_value=100,
                                       threshold=threshold,
                                       invert_above_threshold=True)

                assert np.array_equal(observed, expected)

    def test_int_with_threshold_50_inv_above(self):
        threshold = 50
        dtypes = ["int8", "int16", "int32", "int64"]
        for dt in dtypes:
            with self.subTest(dtype=dt):
                min_value, center_value, max_value = \
                    iadt.get_value_range_of_dtype(dt)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="4920" endline="4944" pcid="3077">
                    max_value - 0,
                    max_value - 20,
                    max_value - 45,
                    max_value - 60,
                    max_value - center_value,
                    min_value
                ], dtype=dt)

                observed = iaa.invert_(np.copy(values))

                assert np.array_equal(observed, expected)

    def test_uint_with_threshold_50_inv_above(self):
        threshold = 50
        dtypes = ["uint8", "uint16", "uint32", "uint64"]
        for dt in dtypes:
            with self.subTest(dtype=dt):
                min_value, center_value, max_value = \
                    iadt.get_value_range_of_dtype(dt)
                center_value = int(center_value)

                values = np.array([0, 20, 45, 60, center_value, max_value],
                                  dtype=dt)
                expected = np.array([
                    0,
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="4995" endline="5019" pcid="3080">
                expected = np.array([
                    0,
                    20,
                    45,
                    60,
                    center_value,
                    min_value
                ], dtype=dt)

                observed = iaa.invert_(np.copy(values),
                                       threshold=threshold,
                                       invert_above_threshold=True)

                assert np.array_equal(observed, expected)

    def test_uint8_with_threshold_256_inv_above(self):
        threshold = 256
        dtypes = ["uint8"]
        for dt in dtypes:
            with self.subTest(dtype=dt):
                min_value, center_value, max_value = \
                    iadt.get_value_range_of_dtype(dt)
                center_value = int(center_value)

                values = np.array([0, 20, 45, 60, center_value, max_value],
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="4970" endline="4994" pcid="3079">
                    max_value - 0,
                    max_value - 20,
                    max_value - 45,
                    max_value - 60,
                    max_value - center_value,
                    min_value
                ], dtype=dt)

                observed = iaa.invert_(np.copy(values),
                                       threshold=threshold,
                                       invert_above_threshold=True)

                assert np.array_equal(observed, expected)

    def test_uint8_with_threshold_255_inv_above(self):
        threshold = 255
        dtypes = ["uint8"]
        for dt in dtypes:
            with self.subTest(dtype=dt):
                min_value, center_value, max_value = \
                    iadt.get_value_range_of_dtype(dt)
                center_value = int(center_value)

                values = np.array([0, 20, 45, 60, center_value, max_value],
                                  dtype=dt)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="5045" endline="5072" pcid="3082">
                values = np.array([0, 20, 45, 60, center_value, max_value],
                                  dtype=dt)
                expected = np.array([
                    max_value - 0,
                    max_value - 20,
                    max_value - 45,
                    60,
                    center_value,
                    max_value
                ], dtype=dt)

                observed = iaa.invert_(np.copy(values),
                                       threshold=threshold,
                                       invert_above_threshold=False)

                assert np.array_equal(observed, expected)

    def test_uint_with_threshold_50_inv_above_with_min_max(self):
        threshold = 50
        # uint64 does not support custom min/max, hence removed it here
        dtypes = ["uint8", "uint16", "uint32"]
        for dt in dtypes:
            with self.subTest(dtype=dt):
                min_value, center_value, max_value = \
                    iadt.get_value_range_of_dtype(dt)
                center_value = int(center_value)

                values = np.array([0, 20, 45, 60, center_value, max_value],
</source>
</class>

<class classid="159" nclones="2" nlines="21" similarity="76">
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="5123" endline="5148" pcid="3085">
                    iadt.get_value_range_of_dtype(dt)
                center_value = int(center_value)

                values = np.array([-45, -20, center_value, 20, 45, max_value],
                                  dtype=dt)
                expected = np.array([
                    (-1) * (-45) - 1,
                    (-1) * (-20) - 1,
                    (-1) * center_value - 1,
                    (-1) * 20 - 1,
                    (-1) * 45 - 1,
                    max_value
                ], dtype=dt)

                observed = iaa.invert_(np.copy(values),
                                       threshold=threshold,
                                       invert_above_threshold=False)

                assert np.array_equal(observed, expected)

    def test_float_with_threshold_50_inv_above(self):
        threshold = 50
        dtypes = ["float16", "float32", "float64", "float128"]
        for dt in dtypes:
            with self.subTest(dtype=dt):
                min_value, center_value, max_value = \
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="5149" endline="5175" pcid="3086">
                    iadt.get_value_range_of_dtype(dt)
                center_value = center_value

                values = np.array([-45.5, -20.5, center_value, 20.5, 45.5,
                                   max_value],
                                  dtype=dt)
                expected = np.array([
                    -45.5,
                    -20.5,
                    center_value,
                    20.5,
                    45.5,
                    min_value
                ], dtype=dt)

                observed = iaa.invert_(np.copy(values),
                                       threshold=threshold,
                                       invert_above_threshold=True)

                assert np.allclose(observed, expected, rtol=0, atol=1e-4)

    def test_float_with_threshold_50_inv_below(self):
        threshold = 50
        dtypes = ["float16", "float32", "float64", "float128"]
        for dt in dtypes:
            with self.subTest(dtype=dt):
                min_value, center_value, max_value = \
</source>
</class>

<class classid="160" nclones="2" nlines="10" similarity="90">
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="5178" endline="5190" pcid="3087">

                values = np.array([-45.5, -20.5, center_value, 20.5, 45.5,
                                   max_value],
                                  dtype=dt)
                expected = np.array([
                    (-1) * (-45.5),
                    (-1) * (-20.5),
                    (-1) * center_value,
                    (-1) * 20.5,
                    (-1) * 45.5,
                    max_value
                ], dtype=dt)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="5192" endline="5204" pcid="3088">
                                       threshold=threshold,
                                       invert_above_threshold=False)

                assert np.allclose(observed, expected, rtol=0, atol=1e-4)


class Test_solarize(unittest.TestCase):
    @mock.patch("imgaug.augmenters.arithmetic.solarize_")
    def test_mocked_defaults(self, mock_sol):
        arr = np.zeros((1,), dtype=np.uint8)
        mock_sol.return_value = "foo"

        observed = iaa.solarize(arr)
</source>
</class>

<class classid="161" nclones="2" nlines="11" similarity="90">
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="5273" endline="5285" pcid="3096">

        observed = iaa.Invert(p=1.0).augment_image(zeros + 255)
        expected = zeros
        assert observed.dtype.name == "uint8"
        assert np.array_equal(observed, expected)

    def test_p_is_zero(self):
        zeros = np.zeros((4, 4, 3), dtype=np.uint8)

        observed = iaa.Invert(p=0.0).augment_image(zeros + 255)
        expected = zeros + 255
        assert observed.dtype.name == "uint8"
        assert np.array_equal(observed, expected)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="5286" endline="5300" pcid="3097">

    def test_max_value_set(self):
        zeros = np.zeros((4, 4, 3), dtype=np.uint8)

        observed = iaa.Invert(p=1.0, max_value=200).augment_image(zeros + 200)
        expected = zeros
        assert observed.dtype.name == "uint8"
        assert np.array_equal(observed, expected)

    def test_min_value_and_max_value_set(self):
        zeros = np.zeros((4, 4, 3), dtype=np.uint8)

        observed = iaa.Invert(p=1.0, max_value=200, min_value=100).augment_image(zeros + 200)
        expected = zeros + 100
        assert observed.dtype.name == "uint8"
</source>
</class>

<class classid="162" nclones="4" nlines="34" similarity="73">
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="5466" endline="5502" pcid="3109">
                assert np.all(image_aug == 255)
                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == image.shape

    def test_get_parameters(self):
        # test get_parameters()
        aug = iaa.Invert(p=0.5, per_channel=False, min_value=10, max_value=20)
        params = aug.get_parameters()
        assert params[0] is aug.p
        assert params[1] is aug.per_channel
        assert params[2] == 10
        assert params[3] == 20
        assert params[4] is aug.threshold
        assert params[5] is aug.invert_above_threshold

    def test_heatmaps_dont_change(self):
        # test heatmaps (not affected by augmenter)
        aug = iaa.Invert(p=1.0)
        hm = ia.quokka_heatmap()
        hm_aug = aug.augment_heatmaps([hm])[0]
        assert np.allclose(hm.arr_0to1, hm_aug.arr_0to1)

    def test_other_dtypes_p_is_zero(self):
        # with p=0.0
        aug = iaa.Invert(p=0.0)
        dtypes = [bool,
                  np.uint8, np.uint16, np.uint32, np.uint64,
                  np.int8, np.int16, np.int32, np.int64,
                  np.float16, np.float32, np.float64, np.float128]
        for dtype in dtypes:
            min_value, center_value, max_value = iadt.get_value_range_of_dtype(dtype)
            kind = np.dtype(dtype).kind
            image_min = np.full((3, 3), min_value, dtype=dtype)
            if dtype is not bool:
                image_center = np.full((3, 3), center_value if kind == "f" else int(center_value), dtype=dtype)
            image_max = np.full((3, 3), max_value, dtype=dtype)
            image_min_aug = aug.augment_image(image_min)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="5539" endline="5576" pcid="3111">
            image_center_aug = None
            if dtype is not bool:
                image_center_aug = aug.augment_image(image_center)
            image_max_aug = aug.augment_image(image_max)

            assert image_min_aug.dtype == np.dtype(dtype)
            if image_center_aug is not None:
                assert image_center_aug.dtype == np.dtype(dtype)
            assert image_max_aug.dtype == np.dtype(dtype)

            if dtype is bool:
                assert np.all(image_min_aug == image_max)
                assert np.all(image_max_aug == image_min)
            elif np.dtype(dtype).kind in ["i", "u"]:
                assert np.array_equal(image_min_aug, image_max)
                assert np.allclose(image_center_aug, image_center, atol=1.0+1e-4, rtol=0)
                assert np.array_equal(image_max_aug, image_min)
            else:
                assert np.allclose(image_min_aug, image_max)
                assert np.allclose(image_center_aug, image_center)
                assert np.allclose(image_max_aug, image_min)

    def test_other_dtypes_p_is_one_with_min_value(self):
        # with p=1.0 and min_value
        aug = iaa.Invert(p=1.0, min_value=1)
        dtypes = [np.uint8, np.uint16, np.uint32,
                  np.int8, np.int16, np.int32,
                  np.float16, np.float32]
        for dtype in dtypes:
            _min_value, _center_value, max_value = iadt.get_value_range_of_dtype(dtype)
            min_value = 1
            kind = np.dtype(dtype).kind
            center_value = min_value + 0.5 * (max_value - min_value)
            image_min = np.full((3, 3), min_value, dtype=dtype)
            if dtype is not bool:
                image_center = np.full((3, 3), center_value if kind == "f" else int(center_value), dtype=dtype)
            image_max = np.full((3, 3), max_value, dtype=dtype)
            image_min_aug = aug.augment_image(image_min)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="5503" endline="5538" pcid="3110">
            image_center_aug = None
            if dtype is not bool:
                image_center_aug = aug.augment_image(image_center)
            image_max_aug = aug.augment_image(image_max)

            assert image_min_aug.dtype == np.dtype(dtype)
            if image_center_aug is not None:
                assert image_center_aug.dtype == np.dtype(dtype)
            assert image_max_aug.dtype == np.dtype(dtype)

            if dtype is bool:
                assert np.all(image_min_aug == image_min)
                assert np.all(image_max_aug == image_max)
            elif np.dtype(dtype).kind in ["i", "u"]:
                assert np.array_equal(image_min_aug, image_min)
                assert np.array_equal(image_center_aug, image_center)
                assert np.array_equal(image_max_aug, image_max)
            else:
                assert np.allclose(image_min_aug, image_min)
                assert np.allclose(image_center_aug, image_center)
                assert np.allclose(image_max_aug, image_max)

    def test_other_dtypes_p_is_one(self):
        # with p=1.0
        aug = iaa.Invert(p=1.0)
        dtypes = [np.uint8, np.uint16, np.uint32, np.uint64,
                  np.int8, np.int16, np.int32, np.int64,
                  np.float16, np.float32, np.float64, np.float128]
        for dtype in dtypes:
            min_value, center_value, max_value = iadt.get_value_range_of_dtype(dtype)
            kind = np.dtype(dtype).kind
            image_min = np.full((3, 3), min_value, dtype=dtype)
            if dtype is not bool:
                image_center = np.full((3, 3), center_value if kind == "f" else int(center_value), dtype=dtype)
            image_max = np.full((3, 3), max_value, dtype=dtype)
            image_min_aug = aug.augment_image(image_min)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_arithmetic.py" startline="5577" endline="5618" pcid="3112">
            image_center_aug = None
            if dtype is not bool:
                image_center_aug = aug.augment_image(image_center)
            image_max_aug = aug.augment_image(image_max)

            assert image_min_aug.dtype == np.dtype(dtype)
            if image_center_aug is not None:
                assert image_center_aug.dtype == np.dtype(dtype)
            assert image_max_aug.dtype == np.dtype(dtype)

            if dtype is bool:
                assert np.all(image_min_aug == 1)
                assert np.all(image_max_aug == 1)
            elif np.dtype(dtype).kind in ["i", "u"]:
                assert np.array_equal(image_min_aug, image_max)
                assert np.allclose(image_center_aug, image_center, atol=1.0+1e-4, rtol=0)
                assert np.array_equal(image_max_aug, image_min)
            else:
                assert np.allclose(image_min_aug, image_max)
                assert np.allclose(image_center_aug, image_center)
                assert np.allclose(image_max_aug, image_min)

    def test_other_dtypes_p_is_one_with_max_value(self):
        # with p=1.0 and max_value
        aug = iaa.Invert(p=1.0, max_value=16)
        dtypes = [np.uint8, np.uint16, np.uint32,
                  np.int8, np.int16, np.int32,
                  np.float16, np.float32]
        for dtype in dtypes:
            min_value, _center_value, _max_value = iadt.get_value_range_of_dtype(dtype)
            max_value = 16
            kind = np.dtype(dtype).kind
            center_value = min_value + 0.5 * (max_value - min_value)
            image_min = np.full((3, 3), min_value, dtype=dtype)
            if dtype is not bool:
                image_center = np.full((3, 3), center_value if kind == "f" else int(center_value), dtype=dtype)
            image_max = np.full((3, 3), max_value, dtype=dtype)
            image_min_aug = aug.augment_image(image_min)
            image_center_aug = None
            if dtype is not bool:
                image_center_aug = aug.augment_image(image_center)
            image_max_aug = aug.augment_image(image_max)
</source>
</class>

<class classid="163" nclones="4" nlines="13" similarity="84">
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="420" endline="439" pcid="3152">
class TestAlpha(unittest.TestCase):
    def test_deprecation_warning(self):
        aug1 = iaa.Sequential([])
        aug2 = iaa.Sequential([])

        with warnings.catch_warnings(record=True) as caught_warnings:
            warnings.simplefilter("always")

            aug = iaa.Alpha(0.75, first=aug1, second=aug2)

            assert (
                "is deprecated"
                in str(caught_warnings[-1].message)
            )

        assert isinstance(aug, iaa.BlendAlpha)
        assert np.isclose(aug.factor.value, 0.75)
        assert aug.foreground is aug1
        assert aug.background is aug2

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="3519" endline="3535" pcid="3444">
class TestFrequencyNoiseAlpha(unittest.TestCase):
    def test_deprecation_warning(self):
        aug1 = iaa.Sequential([])
        aug2 = iaa.Sequential([])

        with warnings.catch_warnings(record=True) as caught_warnings:
            warnings.simplefilter("always")

            aug = iaa.FrequencyNoiseAlpha(first=aug1, second=aug2)

            assert (
                "is deprecated"
                in str(caught_warnings[-1].message)
            )

        assert isinstance(aug, iaa.BlendAlphaFrequencyNoise)
        assert aug.foreground is aug1
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="1091" endline="1110" pcid="3238">
class TestAlphaElementwise(unittest.TestCase):
    def test_deprecation_warning(self):
        aug1 = iaa.Sequential([])
        aug2 = iaa.Sequential([])

        with warnings.catch_warnings(record=True) as caught_warnings:
            warnings.simplefilter("always")

            aug = iaa.AlphaElementwise(factor=0.5, first=aug1, second=aug2)

            assert (
                "is deprecated"
                in str(caught_warnings[-1].message)
            )

        assert isinstance(aug, iaa.BlendAlphaElementwise)
        assert np.isclose(aug.factor.value, 0.5)
        assert aug.foreground is aug1
        assert aug.background is aug2

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="3499" endline="3517" pcid="3443">
class TestSimplexNoiseAlpha(unittest.TestCase):
    def test_deprecation_warning(self):
        aug1 = iaa.Sequential([])
        aug2 = iaa.Sequential([])

        with warnings.catch_warnings(record=True) as caught_warnings:
            warnings.simplefilter("always")

            aug = iaa.SimplexNoiseAlpha(first=aug1, second=aug2)

            assert (
                "is deprecated"
                in str(caught_warnings[-1].message)
            )

        assert isinstance(aug, iaa.BlendAlphaSimplexNoise)
        assert aug.foreground is aug1
        assert aug.background is aug2

</source>
</class>

<class classid="164" nclones="4" nlines="13" similarity="85">
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="517" endline="531" pcid="3166">

    def test_heatmaps_factor_is_1_with_affines_and_per_channel(self):
        for per_channel in [False, True]:
            with self.subTest(per_channel=per_channel):
                aug = iaa.BlendAlpha(
                    1,
                    iaa.Affine(translate_px={"x": 1}),
                    iaa.Affine(translate_px={"x": -1}),
                    per_channel=per_channel)
                observed = aug.augment_heatmaps([self.heatmaps])[0]
                assert observed.shape == self.heatmaps.shape
                assert 0 - 1e-6 < self.heatmaps.min_value < 0 + 1e-6
                assert 1 - 1e-6 < self.heatmaps.max_value < 1 + 1e-6
                assert np.allclose(observed.get_arr(),
                                   self.heatmaps_r1.get_arr())
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="532" endline="544" pcid="3167">

    def test_segmaps_factor_is_1_with_affines_and_per_channel(self):
        for per_channel in [False, True]:
            with self.subTest(per_channel=per_channel):
                aug = iaa.BlendAlpha(
                    1,
                    iaa.Affine(translate_px={"x": 1}),
                    iaa.Affine(translate_px={"x": -1}),
                    per_channel=per_channel)
                observed = aug.augment_segmentation_maps([self.segmaps])[0]
                assert observed.shape == self.segmaps.shape
                assert np.array_equal(observed.get_arr(),
                                      self.segmaps_r1.get_arr())
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="566" endline="578" pcid="3170">

    def test_segmaps_factor_is_0_with_affines_and_per_channel(self):
        for per_channel in [False, True]:
            with self.subTest(per_channel=per_channel):
                aug = iaa.BlendAlpha(
                    0,
                    iaa.Affine(translate_px={"x": 1}),
                    iaa.Affine(translate_px={"x": -1}),
                    per_channel=per_channel)
                observed = aug.augment_segmentation_maps([self.segmaps])[0]
                assert observed.shape == self.segmaps.shape
                assert np.array_equal(observed.get_arr(),
                                      self.segmaps_l1.get_arr())
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="551" endline="565" pcid="3169">

    def test_heatmaps_factor_is_0_with_affines_and_per_channel(self):
        for per_channel in [False, True]:
            with self.subTest(per_channel=per_channel):
                aug = iaa.BlendAlpha(
                    0,
                    iaa.Affine(translate_px={"x": 1}),
                    iaa.Affine(translate_px={"x": -1}),
                    per_channel=per_channel)
                observed = aug.augment_heatmaps([self.heatmaps])[0]
                assert observed.shape == self.heatmaps.shape
                assert 0 - 1e-6 < self.heatmaps.min_value < 0 + 1e-6
                assert 1 - 1e-6 < self.heatmaps.max_value < 1 + 1e-6
                assert np.allclose(observed.get_arr(),
                                   self.heatmaps_l1.get_arr())
</source>
</class>

<class classid="165" nclones="2" nlines="12" similarity="83">
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="638" endline="650" pcid="3176">

    def test_images_with_per_channel_in_both_alpha_and_child(self):
        image = np.zeros((1, 1, 1000), dtype=np.uint8)
        aug = iaa.BlendAlpha(
            1.0,
            iaa.Add((0, 100), per_channel=True),
            None,
            per_channel=True)
        observed = aug.augment_image(image)
        uq = np.unique(observed)
        assert len(uq) > 1
        assert np.max(observed) > 80
        assert np.min(observed) < 20
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="651" endline="663" pcid="3177">

    def test_images_with_per_channel_in_alpha_and_tuple_as_factor(self):
        image = np.zeros((1, 1, 1000), dtype=np.uint8)
        aug = iaa.BlendAlpha(
            (0.0, 1.0),
            iaa.Add(100),
            None,
            per_channel=True)
        observed = aug.augment_image(image)
        uq = np.unique(observed)
        assert len(uq) > 1
        assert np.max(observed) > 80
        assert np.min(observed) < 20
</source>
</class>

<class classid="166" nclones="2" nlines="14" similarity="100">
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="955" endline="972" pcid="3226">
    @classmethod
    def _test_cba_hooks_limit_propagation(cls, augf_name, cbaoi):
        aug = iaa.BlendAlpha(
            0.0,
            iaa.Affine(translate_px={"x": 1}),
            iaa.Affine(translate_px={"y": 1}),
            name="AlphaTest")

        def propagator(cbaoi_to_aug, augmenter, parents, default):
            if "Alpha" in augmenter.name:
                return False
            else:
                return default

        # no hooks for polygons yet, so we use HooksKeypoints
        hooks = ia.HooksKeypoints(propagator=propagator)
        observed = getattr(aug, augf_name)([cbaoi], hooks=hooks)[0]
        assert observed.items[0].coords_almost_equals(cbaoi.items[0])
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="1672" endline="1689" pcid="3314">
    @classmethod
    def _test_cba_hooks_limit_propagation(cls, augf_name, cbaoi):
        aug = iaa.BlendAlphaElementwise(
            0.0,
            iaa.Affine(translate_px={"x": 1}),
            iaa.Affine(translate_px={"y": 1}),
            name="AlphaTest")

        def propagator(cbaoi_to_aug, augmenter, parents, default):
            if "Alpha" in augmenter.name:
                return False
            else:
                return default

        # no hooks for polygons yet, so we use HooksKeypoints
        hooks = ia.HooksKeypoints(propagator=propagator)
        observed = getattr(aug, augf_name)([cbaoi], hooks=hooks)[0]
        assert observed.items[0].coords_almost_equals(cbaoi.items[0])
</source>
</class>

<class classid="167" nclones="4" nlines="10" similarity="72">
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="1190" endline="1200" pcid="3252">

    def test_heatmaps_factor_is_1_with_affines(self):
        aug = iaa.BlendAlphaElementwise(
            1,
            iaa.Affine(translate_px={"x": 1}),
            iaa.Affine(translate_px={"x": -1}))
        observed = aug.augment_heatmaps([self.heatmaps])[0]
        assert observed.shape == (3, 3, 3)
        assert 0 - 1e-6 < observed.min_value < 0 + 1e-6
        assert 1 - 1e-6 < observed.max_value < 1 + 1e-6
        assert np.allclose(observed.get_arr(), self.heatmaps_r1.get_arr())
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="1216" endline="1226" pcid="3255">

    def test_heatmaps_factor_is_0_with_affines(self):
        aug = iaa.BlendAlphaElementwise(
            0,
            iaa.Affine(translate_px={"x": 1}),
            iaa.Affine(translate_px={"x": -1}))
        observed = aug.augment_heatmaps([self.heatmaps])[0]
        assert observed.shape == (3, 3, 3)
        assert 0 - 1e-6 < observed.min_value < 0 + 1e-6
        assert 1 - 1e-6 < observed.max_value < 1 + 1e-6
        assert np.allclose(observed.get_arr(), self.heatmaps_l1.get_arr())
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="1336" endline="1347" pcid="3267">

    def test_heatmaps_and_per_channel_factor_is_ones(self):
        aug = iaa.BlendAlphaElementwise(
            _DummyMaskParameter(inverted=True),
            iaa.Affine(translate_px={"x": 1}),
            iaa.Affine(translate_px={"x": -1}),
            per_channel=True)
        observed = aug.augment_heatmaps([self.heatmaps])[0]
        assert observed.shape == (3, 3, 3)
        assert 0 - 1e-6 < observed.min_value < 0 + 1e-6
        assert 1 - 1e-6 < observed.max_value < 1 + 1e-6
        assert np.allclose(observed.get_arr(), self.heatmaps_l1.get_arr())
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="1324" endline="1335" pcid="3266">

    def test_heatmaps_and_per_channel_factor_is_zeros(self):
        aug = iaa.BlendAlphaElementwise(
            _DummyMaskParameter(inverted=False),
            iaa.Affine(translate_px={"x": 1}),
            iaa.Affine(translate_px={"x": -1}),
            per_channel=True)
        observed = aug.augment_heatmaps([self.heatmaps])[0]
        assert observed.shape == (3, 3, 3)
        assert 0 - 1e-6 < observed.min_value < 0 + 1e-6
        assert 1 - 1e-6 < observed.max_value < 1 + 1e-6
        assert np.allclose(observed.get_arr(), self.heatmaps_r1.get_arr())
</source>
</class>

<class classid="168" nclones="2" nlines="14" similarity="85">
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="2048" endline="2063" pcid="3345">

    def test___init__(self):
        child1 = iaa.Sequential([])
        child2 = iaa.Sequential([])
        aug = iaa.BlendAlphaSegMapClassIds(
            2,
            nb_sample_classes=1,
            foreground=child1,
            background=child2
        )
        assert aug.foreground is child1
        assert aug.background is child2
        assert isinstance(aug.mask_generator,
                          iaa.SegMapClassIdsMaskGen)
        assert aug.mask_generator.class_ids.value == 2
        assert aug.mask_generator.nb_sample_classes.value == 1
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="2136" endline="2151" pcid="3350">

    def test___init__(self):
        child1 = iaa.Sequential([])
        child2 = iaa.Sequential([])
        aug = iaa.BlendAlphaBoundingBoxes(
            "person",
            nb_sample_labels=1,
            foreground=child1,
            background=child2
        )
        assert aug.foreground is child1
        assert aug.background is child2
        assert isinstance(aug.mask_generator,
                          iaa.BoundingBoxesMaskGen)
        assert aug.mask_generator.labels.value == "person"
        assert aug.mask_generator.nb_sample_labels.value == 1
</source>
</class>

<class classid="169" nclones="2" nlines="21" similarity="77">
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="2106" endline="2131" pcid="3348">

    def test_pickleable(self):
        shape = (15, 15, 3)
        iterations = 3
        augmenter = iaa.BlendAlphaSegMapClassIds(
            [1, 2],
            foreground=iaa.Add((1, 10), seed=1),
            background=iaa.Add((11, 20), seed=2),
            nb_sample_classes=1,
            seed=3)
        image = np.mod(np.arange(int(np.prod(shape))), 256).astype(np.uint8)
        image = image.reshape(shape)
        segmap_arr = np.zeros((15, 15, 1), dtype=np.int32)
        segmap_arr[0:2, 0:2] = 1
        segmap_arr[4:6, 5:8] = 2

        augmenter_pkl = pickle.loads(pickle.dumps(augmenter, protocol=-1))

        for _ in np.arange(iterations):
            image_aug, sm_aug = augmenter(
                image=image, segmentation_maps=[segmap_arr])
            image_aug_pkl, sm_aug_pkl = augmenter_pkl(
                image=image, segmentation_maps=[segmap_arr])
            assert np.array_equal(image_aug, image_aug_pkl)
            assert np.array_equal(sm_aug, sm_aug_pkl)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="2196" endline="2219" pcid="3353">

    def test_pickleable(self):
        shape = (15, 15, 3)
        iterations = 3
        augmenter = iaa.BlendAlphaBoundingBoxes(
            ["bb1", "bb2", "bb3"],
            foreground=iaa.Add((1, 10), seed=1),
            background=iaa.Add((11, 20), seed=2),
            nb_sample_labels=1,
            seed=3)
        image = np.mod(np.arange(int(np.prod(shape))), 256).astype(np.uint8)
        image = image.reshape(shape)
        bbs = [ia.BoundingBox(x1=1, y1=1, x2=5, y2=5, label="bb1"),
               ia.BoundingBox(x1=-3, y1=4, x2=20, y2=8, label="bb2")]

        augmenter_pkl = pickle.loads(pickle.dumps(augmenter, protocol=-1))

        for _ in np.arange(iterations):
            image_aug, bbs_aug = augmenter(
                image=image, bounding_boxes=[bbs])
            image_aug_pkl, bbs_aug_pkl = augmenter_pkl(
                image=image, bounding_boxes=[bbs])
            assert np.array_equal(image_aug, image_aug_pkl)

</source>
</class>

<class classid="170" nclones="2" nlines="15" similarity="100">
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="2390" endline="2408" pcid="3364">

    def test_draw_masks_marks_alpha_is_0(self):
        image = np.uint8([
            [255, 0, 0],
            [0, 255, 0],
            [0, 0, 255],
            [255, 255, 0],
            [255, 0, 255],
            [0, 255, 255],
            [255, 128, 128],
            [128, 255, 128],
            [128, 128, 255]
        ]).reshape((1, 9, 3))
        batch = _BatchInAugmentation(images=[image])
        gen = iaa.SomeColorsMaskGen(alpha=0.0)

        mask = gen.draw_masks(batch)[0]

        assert np.allclose(mask, 0.0)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="2409" endline="2427" pcid="3365">

    def test_draw_masks_alpha_is_1(self):
        image = np.uint8([
            [255, 0, 0],
            [0, 255, 0],
            [0, 0, 255],
            [255, 255, 0],
            [255, 0, 255],
            [0, 255, 255],
            [255, 128, 128],
            [128, 255, 128],
            [128, 128, 255]
        ]).reshape((1, 9, 3))
        batch = _BatchInAugmentation(images=[image])
        gen = iaa.SomeColorsMaskGen(alpha=1.0)

        mask = gen.draw_masks(batch)[0]

        assert np.allclose(mask, 1.0)
</source>
</class>

<class classid="171" nclones="2" nlines="10" similarity="100">
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="2608" endline="2618" pcid="3382">

    def test___init__(self):
        gen = iaa.HorizontalLinearGradientMaskGen(min_value=0.1,
                                                  max_value=1.0,
                                                  start_at=0.1,
                                                  end_at=0.9)
        assert gen.axis == 1
        assert np.isclose(gen.min_value.value, 0.1)
        assert np.isclose(gen.max_value.value, 1.0)
        assert np.isclose(gen.start_at.value, 0.1)
        assert np.isclose(gen.end_at.value, 0.9)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="2736" endline="2746" pcid="3392">

    def test___init__(self):
        gen = iaa.VerticalLinearGradientMaskGen(min_value=0.1,
                                                max_value=1.0,
                                                start_at=0.1,
                                                end_at=0.9)
        assert gen.axis == 0
        assert np.isclose(gen.min_value.value, 0.1)
        assert np.isclose(gen.max_value.value, 1.0)
        assert np.isclose(gen.start_at.value, 0.1)
        assert np.isclose(gen.end_at.value, 0.9)
</source>
</class>

<class classid="172" nclones="2" nlines="24" similarity="77">
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="2619" endline="2643" pcid="3383">

    def test_draw_masks(self):
        image1 = np.zeros((5, 100, 3), dtype=np.uint8)
        image2 = np.zeros((7, 200, 3), dtype=np.uint8)
        batch = _BatchInAugmentation(images=[image1, image2])

        gen = iaa.HorizontalLinearGradientMaskGen(min_value=0.1,
                                                  max_value=0.75,
                                                  start_at=0.1,
                                                  end_at=0.9)

        masks = gen.draw_masks(batch, random_state=1)

        assert masks[0].shape == image1.shape[0:2]
        assert masks[1].shape == image2.shape[0:2]
        assert masks[0].dtype.name == "float32"
        assert masks[1].dtype.name == "float32"
        assert np.allclose(masks[0][:, 0:10], 0.1)
        assert np.allclose(masks[1][:, 0:20], 0.1)
        assert np.allclose(masks[0][:, 90:], 0.75)
        assert np.allclose(masks[1][:, 180:], 0.75)
        assert np.allclose(masks[0][:, 10+40], 0.1 + 0.5 * (0.75 - 0.1),
                           rtol=0, atol=0.05)
        assert np.allclose(masks[1][:, 20+80], 0.1 + 0.5 * (0.75 - 0.1),
                           rtol=0, atol=0.025)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="2747" endline="2780" pcid="3393">

    def test_draw_masks(self):
        # we transpose the axes in this test, because that way the test is
        # essentially identical to the one for HorizontalLinearGradientMaskGen
        image1 = np.zeros((5, 100, 3), dtype=np.uint8)
        image2 = np.zeros((7, 200, 3), dtype=np.uint8)
        image1 = image1.transpose((1, 0, 2))
        image2 = image2.transpose((1, 0, 2))
        batch = _BatchInAugmentation(images=[image1, image2])

        gen = iaa.VerticalLinearGradientMaskGen(min_value=0.1,
                                                max_value=0.75,
                                                start_at=0.1,
                                                end_at=0.9)

        masks = gen.draw_masks(batch, random_state=1)

        image1 = image1.transpose((1, 0, 2))
        image2 = image2.transpose((1, 0, 2))
        masks[0] = masks[0].transpose((1, 0))
        masks[1] = masks[1].transpose((1, 0))
        assert masks[0].shape == image1.shape[0:2]
        assert masks[1].shape == image2.shape[0:2]
        assert masks[0].dtype.name == "float32"
        assert masks[1].dtype.name == "float32"
        assert np.allclose(masks[0][:, 0:10], 0.1)
        assert np.allclose(masks[1][:, 0:20], 0.1)
        assert np.allclose(masks[0][:, 90:], 0.75)
        assert np.allclose(masks[1][:, 180:], 0.75)
        assert np.allclose(masks[0][:, 10+40], 0.1 + 0.5 * (0.75 - 0.1),
                           rtol=0, atol=0.05)
        assert np.allclose(masks[1][:, 20+80], 0.1 + 0.5 * (0.75 - 0.1),
                           rtol=0, atol=0.025)

</source>
</class>

<class classid="173" nclones="2" nlines="13" similarity="85">
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="2866" endline="2878" pcid="3399">

    def test_generate_mask_rows_n_cols_1(self):
        mask = iaa.RegularGridMaskGen.generate_mask(
            (8, 5),
            nb_rows=4, nb_cols=1,
            alphas=np.float32([[1],
                               [0],
                               [1],
                               [0]]))
        expected = np.full((8, 5), 1.0, dtype=np.float32)
        expected[2:4, :] = 0.0
        expected[6:8, :] = 0.0
        assert np.allclose(mask, expected)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="2939" endline="2953" pcid="3403">

    def test_generate_mask_with_more_rows_than_pixels(self):
        mask = iaa.RegularGridMaskGen.generate_mask(
            (4, 5),
            nb_rows=6, nb_cols=1,
            alphas=np.float32([[1],
                               [0],
                               [1],
                               [0],
                               [1],
                               [0]]))
        expected = np.full((4, 5), 1.0, dtype=np.float32)
        expected[1:2, :] = 0.0
        expected[3:4, :] = 0.0
        assert np.allclose(mask, expected)
</source>
</class>

<class classid="174" nclones="2" nlines="25" similarity="74">
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="2895" endline="2928" pcid="3401">

    def test_generate_mask_with_leftover_pixels(self):
        mask = iaa.RegularGridMaskGen.generate_mask(
            (15, 15),
            nb_rows=4, nb_cols=4,
            alphas=np.float32([[1, 0, 1, 0],
                               [0, 1, 0, 1],
                               [1, 0, 1, 0],
                               [0, 1, 0, 1]]))
        expected = np.full((12, 12), 0.0, dtype=np.float32)

        expected[0:3, 0:3] = 1.0
        expected[0:3, 3:6] = 0.0
        expected[0:3, 6:9] = 1.0
        expected[0:3, 9:12] = 0.0

        expected[3:6, 0:3] = 0.0
        expected[3:6, 3:6] = 1.0
        expected[3:6, 6:9] = 0.0
        expected[3:6, 9:12] = 1.0

        expected[6:9, 0:3] = 1.0
        expected[6:9, 3:6] = 0.0
        expected[6:9, 6:9] = 1.0
        expected[6:9, 9:12] = 0.0

        expected[9:12, 0:3] = 0.0
        expected[9:12, 3:6] = 1.0
        expected[9:12, 6:9] = 0.0
        expected[9:12, 9:12] = 1.0

        expected = np.pad(expected, ((1, 2), (1, 2)), mode="reflect")

        assert np.allclose(mask, expected)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="3063" endline="3091" pcid="3413">

    def test_generate_mask_with_leftover_pixels(self):
        mask = iaa.CheckerboardMaskGen.generate_mask((15, 15),
                                                     nb_rows=4, nb_cols=4)
        expected = np.full((12, 12), 0.0, dtype=np.float32)

        expected[0:3, 0:3] = 1.0
        expected[0:3, 3:6] = 0.0
        expected[0:3, 6:9] = 1.0
        expected[0:3, 9:12] = 0.0

        expected[3:6, 0:3] = 0.0
        expected[3:6, 3:6] = 1.0
        expected[3:6, 6:9] = 0.0
        expected[3:6, 9:12] = 1.0

        expected[6:9, 0:3] = 1.0
        expected[6:9, 3:6] = 0.0
        expected[6:9, 6:9] = 1.0
        expected[6:9, 9:12] = 0.0

        expected[9:12, 0:3] = 0.0
        expected[9:12, 3:6] = 1.0
        expected[9:12, 6:9] = 0.0
        expected[9:12, 9:12] = 1.0

        expected = np.pad(expected, ((1, 2), (1, 2)), mode="reflect")

        assert np.allclose(mask, expected)
</source>
</class>

<class classid="175" nclones="2" nlines="14" similarity="100">
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="2988" endline="3004" pcid="3406">

    def test_batch_contains_no_images(self):
        hms = ia.HeatmapsOnImage(np.zeros((5, 5), dtype=np.float32),
                                 shape=(6, 8, 3))
        batch = _BatchInAugmentation(heatmaps=[hms])
        gen = iaa.CheckerboardMaskGen(nb_rows=3, nb_cols=2)
        mask = gen.draw_masks(batch, random_state=1)[0]

        expected = np.full((6, 8), 1.0, dtype=np.float32)
        expected[0:2, 0:4] = 1.0
        expected[0:2, 4:8] = 0.0
        expected[2:4, 0:4] = 0.0
        expected[2:4, 4:8] = 1.0
        expected[4:6, 0:4] = 1.0
        expected[4:6, 4:8] = 0.0
        assert np.allclose(mask, expected)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="3132" endline="3148" pcid="3417">

    def test_batch_contains_no_images(self):
        hms = ia.HeatmapsOnImage(np.zeros((5, 5), dtype=np.float32),
                                 shape=(6, 8, 3))
        batch = _BatchInAugmentation(heatmaps=[hms])
        gen = iaa.CheckerboardMaskGen(nb_rows=3, nb_cols=2)
        mask = gen.draw_masks(batch, random_state=1)[0]

        expected = np.full((6, 8), 1.0, dtype=np.float32)
        expected[0:2, 0:4] = 1.0
        expected[0:2, 4:8] = 0.0
        expected[2:4, 0:4] = 0.0
        expected[2:4, 4:8] = 1.0
        expected[4:6, 0:4] = 1.0
        expected[4:6, 4:8] = 0.0
        assert np.allclose(mask, expected)

</source>
</class>

<class classid="176" nclones="4" nlines="14" similarity="73">
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="3328" endline="3346" pcid="3433">

    def test_draw_masks__labels_is_none(self):
        bbs = [ia.BoundingBox(x1=1, y1=1, x2=5, y2=5, label="bb1"),
               ia.BoundingBox(x1=-3, y1=4, x2=20, y2=8, label="bb2"),
               ia.BoundingBox(x1=2, y1=2, x2=10, y2=10, label="bb3")]
        bbsoi = ia.BoundingBoxesOnImage(bbs, shape=(10, 14, 3))

        batch = _BatchInAugmentation(bounding_boxes=[bbsoi])
        gen = iaa.BoundingBoxesMaskGen()

        mask = gen.draw_masks(batch, random_state=1)[0]

        expected = np.zeros((10, 14), dtype=np.float32)
        expected[1:5, 1:5] = 1.0  # bb1
        expected[4:8, 0:14] = 1.0  # bb2 clipped to image shape
        expected[2:10, 2:10] = 1.0  # bb3
        assert mask.shape == (10, 14)
        assert mask.dtype.name == "float32"
        assert np.allclose(mask, expected)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="3385" endline="3399" pcid="3436">

    def test_generate_mask(self):
        bbs = [ia.BoundingBox(x1=1, y1=1, x2=5, y2=5, label="bb1"),
               ia.BoundingBox(x1=-3, y1=4, x2=20, y2=8, label="bb2"),
               ia.BoundingBox(x1=2, y1=2, x2=10, y2=10, label="bb3")]
        bbsoi = ia.BoundingBoxesOnImage(bbs, shape=(10, 14, 3))

        mask = iaa.BoundingBoxesMaskGen.generate_mask(bbsoi, ["bb1", "bb2"])

        expected = np.zeros((10, 14), dtype=np.float32)
        expected[1:5, 1:5] = 1.0  # bb1
        expected[4:8, 0:14] = 1.0  # bb2 clipped to image shape
        assert mask.shape == (10, 14)
        assert mask.dtype.name == "float32"
        assert np.allclose(mask, expected)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="3347" endline="3364" pcid="3434">

    def test_draw_masks__fixed_labels(self):
        bbs = [ia.BoundingBox(x1=1, y1=1, x2=5, y2=5, label="bb1"),
               ia.BoundingBox(x1=-3, y1=4, x2=20, y2=8, label="bb2"),
               ia.BoundingBox(x1=2, y1=2, x2=10, y2=10, label="bb3")]
        bbsoi = ia.BoundingBoxesOnImage(bbs, shape=(10, 14, 3))

        batch = _BatchInAugmentation(bounding_boxes=[bbsoi])
        gen = iaa.BoundingBoxesMaskGen(["bb1", "bb2"])

        mask = gen.draw_masks(batch, random_state=1)[0]

        expected = np.zeros((10, 14), dtype=np.float32)
        expected[1:5, 1:5] = 1.0  # bb1
        expected[4:8, 0:14] = 1.0  # bb2 clipped to image shape
        assert mask.shape == (10, 14)
        assert mask.dtype.name == "float32"
        assert np.allclose(mask, expected)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_blend.py" startline="3365" endline="3384" pcid="3435">

    def test_draw_masks__stochastic_labels(self):
        bbs = [ia.BoundingBox(x1=1, y1=1, x2=5, y2=5, label="bb1"),
               ia.BoundingBox(x1=-3, y1=4, x2=20, y2=8, label="bb2"),
               ia.BoundingBox(x1=2, y1=2, x2=10, y2=10, label="bb3")]
        bbsoi = ia.BoundingBoxesOnImage(bbs, shape=(10, 14, 3))

        batch = _BatchInAugmentation(bounding_boxes=[bbsoi])
        gen = iaa.BoundingBoxesMaskGen(
            iap.DeterministicList(["bb1", "bb2"]),
            nb_sample_labels=3)

        mask = gen.draw_masks(batch, random_state=1)[0]

        expected = np.zeros((10, 14), dtype=np.float32)
        expected[1:5, 1:5] = 1.0  # bb1
        expected[4:8, 0:14] = 1.0  # bb2 clipped to image shape
        assert mask.shape == (10, 14)
        assert mask.dtype.name == "float32"
        assert np.allclose(mask, expected)
</source>
</class>

<class classid="177" nclones="2" nlines="15" similarity="100">
<source file="systems/imgaug-0.4.0/test/augmenters/test_debug.py" startline="78" endline="95" pcid="3450">
    def test_two_images_and_heatmaps(self):
        rng = iarandom.RNG(0)
        images = rng.integers(0, 256, size=(2, 256, 256, 3), dtype=np.uint8)
        heatmap = np.zeros((256, 256, 1), dtype=np.float32)
        heatmap[128-25:128+25, 128-25:128+25] = 1.0
        heatmap1 = ia.HeatmapsOnImage(np.copy(heatmap), shape=images[0].shape)
        heatmap2 = ia.HeatmapsOnImage(1.0 - heatmap, shape=images[1].shape)
        image1_w_overlay = heatmap1.draw_on_image(images[0])[0]
        image2_w_overlay = heatmap2.draw_on_image(images[1])[0]

        debug_image = iaa.draw_debug_image(images,
                                           heatmaps=[heatmap1, heatmap2])

        assert self._image_contains(images[0, ...], debug_image)
        assert self._image_contains(images[1, ...], debug_image)
        assert self._image_contains(image1_w_overlay, debug_image)
        assert self._image_contains(image2_w_overlay, debug_image)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_debug.py" startline="119" endline="136" pcid="3452">
    def test_two_images_and_heatmaps__map_size_differs_from_image(self):
        rng = iarandom.RNG(0)
        images = rng.integers(0, 256, size=(2, 256, 256, 3), dtype=np.uint8)
        heatmap = np.zeros((128, 128, 1), dtype=np.float32)
        heatmap[64-25:64+25, 64-25:64+25] = 1.0
        heatmap1 = ia.HeatmapsOnImage(np.copy(heatmap), shape=images[0].shape)
        heatmap2 = ia.HeatmapsOnImage(1.0 - heatmap, shape=images[1].shape)
        image1_w_overlay = heatmap1.draw_on_image(images[0])[0]
        image2_w_overlay = heatmap2.draw_on_image(images[1])[0]

        debug_image = iaa.draw_debug_image(images,
                                           heatmaps=[heatmap1, heatmap2])

        assert self._image_contains(images[0, ...], debug_image)
        assert self._image_contains(images[1, ...], debug_image)
        assert self._image_contains(image1_w_overlay, debug_image)
        assert self._image_contains(image2_w_overlay, debug_image)

</source>
</class>

<class classid="178" nclones="4" nlines="17" similarity="72">
<source file="systems/imgaug-0.4.0/test/augmenters/test_debug.py" startline="157" endline="175" pcid="3454">
        assert self._image_contains(image2_w_overlay_c2, debug_image)

    def test_two_images_and_keypoints(self):
        rng = iarandom.RNG(0)
        images = rng.integers(0, 256, size=(2, 256, 256, 3), dtype=np.uint8)
        kps = []
        for x in np.linspace(0, 256, 10):
            for y in np.linspace(0, 256, 10):
                kps.append(ia.Keypoint(x=x, y=y))
        kpsoi1 = ia.KeypointsOnImage(kps, shape=images[0].shape)
        kpsoi2 = kpsoi1.shift(x=20)
        image1_w_overlay = kpsoi1.draw_on_image(images[0])
        image2_w_overlay = kpsoi2.draw_on_image(images[1])

        debug_image = iaa.draw_debug_image(images, keypoints=[kpsoi1, kpsoi2])

        assert self._image_contains(images[0, ...], debug_image)
        assert self._image_contains(images[1, ...], debug_image)
        assert self._image_contains(image1_w_overlay, debug_image)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_debug.py" startline="176" endline="195" pcid="3455">
        assert self._image_contains(image2_w_overlay, debug_image)

    def test_two_images_and_bounding_boxes(self):
        rng = iarandom.RNG(0)
        images = rng.integers(0, 256, size=(2, 256, 256, 3), dtype=np.uint8)
        bbs = []
        for x in np.linspace(0, 256, 5):
            for y in np.linspace(0, 256, 5):
                bbs.append(ia.BoundingBox(x1=x, y1=y, x2=x+20, y2=y+20))
        bbsoi1 = ia.BoundingBoxesOnImage(bbs, shape=images[0].shape)
        bbsoi2 = bbsoi1.shift(x=20)
        image1_w_overlay = bbsoi1.draw_on_image(images[0])
        image2_w_overlay = bbsoi2.draw_on_image(images[1])

        debug_image = iaa.draw_debug_image(images,
                                           bounding_boxes=[bbsoi1, bbsoi2])

        assert self._image_contains(images[0, ...], debug_image)
        assert self._image_contains(images[1, ...], debug_image)
        assert self._image_contains(image1_w_overlay, debug_image)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_debug.py" startline="217" endline="237" pcid="3457">
        assert self._image_contains(image2_w_overlay, debug_image)

    def test_two_images_and_line_strings(self):
        rng = iarandom.RNG(0)
        images = rng.integers(0, 256, size=(2, 32, 32, 3), dtype=np.uint8)
        ls = []
        for x in np.linspace(0, 256, 4):
            for y in np.linspace(0, 256, 4):
                ls.append(ia.LineString([(x, y), (x+20, y), (x+20, y+20),
                                         (x, y+20)]))
        lsoi1 = ia.LineStringsOnImage(ls, shape=images[0].shape)
        lsoi2 = lsoi1.deepcopy()
        image1_w_overlay = lsoi1.draw_on_image(images[0])
        image2_w_overlay = lsoi2.draw_on_image(images[1])

        debug_image = iaa.draw_debug_image(images,
                                           line_strings=[lsoi1, lsoi2])

        assert self._image_contains(images[0, ...], debug_image)
        assert self._image_contains(images[1, ...], debug_image)
        assert self._image_contains(image1_w_overlay, debug_image)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_debug.py" startline="196" endline="216" pcid="3456">
        assert self._image_contains(image2_w_overlay, debug_image)

    def test_two_images_and_polygons(self):
        rng = iarandom.RNG(0)
        images = rng.integers(0, 256, size=(2, 32, 32, 3), dtype=np.uint8)
        polys = []
        for x in np.linspace(0, 256, 4):
            for y in np.linspace(0, 256, 4):
                polys.append(ia.Polygon([(x, y), (x+20, y), (x+20, y+20),
                                         (x, y+20)]))
        psoi1 = ia.PolygonsOnImage(polys, shape=images[0].shape)
        psoi2 = psoi1.shift(x=20)
        image1_w_overlay = psoi1.draw_on_image(images[0])
        image2_w_overlay = psoi2.draw_on_image(images[1])

        debug_image = iaa.draw_debug_image(images,
                                           polygons=[psoi1, psoi2])

        assert self._image_contains(images[0, ...], debug_image)
        assert self._image_contains(images[1, ...], debug_image)
        assert self._image_contains(image1_w_overlay, debug_image)
</source>
</class>

<class classid="179" nclones="2" nlines="23" similarity="100">
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="633" endline="660" pcid="3488">
        assert paddings == (0, 1, 0, 0)

    def test_width_is_one(self):
        arr = np.zeros((1, 1, 3), dtype=np.uint8)
        paddings = iaa.compute_paddings_to_reach_multiples_of(arr, 2, 1)
        assert paddings == (0, 0, 1, 0)

    def test_various_widths(self):
        nb_channels_lst = [None, 1, 3, 4]
        amounts = [2, 3, 4, 5, 6, 7, 8, 9]
        expecteds = [
            (0, 1, 0, 0),
            (0, 1, 0, 0),
            (0, 2, 0, 1),
            (0, 0, 0, 0),
            (0, 1, 0, 0),
            (0, 1, 0, 1),
            (0, 2, 0, 1),
            (0, 2, 0, 2)
        ]

        for amount, expected in zip(amounts, expecteds):
            for nb_channels in nb_channels_lst:
                with self.subTest(width_multiple=amount,
                                  nb_channels=nb_channels):
                    if nb_channels is None:
                        arr = np.zeros((3, 5), dtype=np.uint8)
                    else:
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="661" endline="688" pcid="3489">
                        arr = np.zeros((3, 5, nb_channels), dtype=np.uint8)

                    paddings = iaa.compute_paddings_to_reach_multiples_of(
                        arr, None, amount)

                    assert paddings == expected

    def test_various_heights(self):
        nb_channels_lst = [None, 1, 3, 4]
        amounts = [2, 3, 4, 5, 6, 7, 8, 9]
        expecteds = [
            (0, 0, 1, 0),
            (0, 0, 1, 0),
            (1, 0, 2, 0),
            (0, 0, 0, 0),
            (0, 0, 1, 0),
            (1, 0, 1, 0),
            (1, 0, 2, 0),
            (2, 0, 2, 0)
        ]
        for amount, expected in zip(amounts, expecteds):
            for nb_channels in nb_channels_lst:
                with self.subTest(height_multiple=amount,
                                  nb_channels=nb_channels):
                    if nb_channels is None:
                        arr = np.zeros((5, 3), dtype=np.uint8)
                    else:
                        arr = np.zeros((5, 3, nb_channels), dtype=np.uint8)
</source>
</class>

<class classid="180" nclones="2" nlines="11" similarity="72">
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="692" endline="705" pcid="3490">

                    assert paddings == expected


class Test_pad_to_multiples_of(unittest.TestCase):
    @mock.patch("imgaug.augmenters.size.compute_paddings_to_reach_multiples_of")
    @mock.patch("imgaug.augmenters.size.pad")
    def test_mocked(self, mock_pad, mock_compute_pads):
        mock_compute_pads.return_value = (1, 2, 3, 4)
        mock_pad.return_value = "padded_array"

        arr = np.ones((3, 5, 1), dtype=np.uint8)

        arr_padded = iaa.pad_to_multiples_of(
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="708" endline="722" pcid="3491">
        mock_compute_pads.assert_called_once_with(arr, 10, 20)
        mock_pad.assert_called_once_with(arr, top=1, right=2, bottom=3,
                                         left=4, mode="foo", cval=100)
        assert arr_padded == "padded_array"

    @mock.patch("imgaug.augmenters.size.compute_paddings_to_reach_multiples_of")
    @mock.patch("imgaug.augmenters.size.pad")
    def test_mocked_return_pad_amounts(self, mock_pad, mock_compute_pads):
        mock_compute_pads.return_value = (1, 2, 3, 4)
        mock_pad.return_value = "padded_array"

        arr = np.ones((3, 5, 1), dtype=np.uint8)

        arr_padded, paddings = iaa.pad_to_multiples_of(
            arr, 10, 20, mode="foo", cval=100, return_pad_amounts=True)
</source>
</class>

<class classid="181" nclones="4" nlines="21" similarity="90">
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="1032" endline="1053" pcid="3523">
    def test_empty_bounding_boxes(self):
        aug = iaa.Resize({"height": 8, "width": 12})
        bbsoi = ia.BoundingBoxesOnImage([], shape=(4, 8, 3))
        bbsoi_aug = aug.augment_bounding_boxes(bbsoi)
        assert len(bbsoi_aug.bounding_boxes) == 0
        assert bbsoi_aug.shape == (8, 12, 3)

    def test_size_is_list_of_ints(self):
        aug = iaa.Resize([12, 14])
        seen2d = [False, False]
        seen3d = [False, False]
        for _ in sm.xrange(100):
            observed2d = aug.augment_image(self.image2d)
            observed3d = aug.augment_image(self.image3d)
            assert observed2d.shape in [(12, 12), (14, 14)]
            assert observed3d.shape in [(12, 12, 3), (14, 14, 3)]
            if observed2d.shape == (12, 12):
                seen2d[0] = True
            else:
                seen2d[1] = True
            if observed3d.shape == (12, 12, 3):
                seen3d[0] = True
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="1199" endline="1220" pcid="3538">
            else:
                seen3d[1] = True
            if np.all(seen2d) and np.all(seen3d):
                break
        assert np.all(seen2d)
        assert np.all(seen3d)

    def test_change_height_by_fixed_int_width_by_list_of_ints(self):
        aug = iaa.Resize({"height": 12, "width": [12, 14]})
        seen2d = [False, False]
        seen3d = [False, False]
        for _ in sm.xrange(100):
            observed2d = aug.augment_image(self.image2d)
            observed3d = aug.augment_image(self.image3d)
            assert observed2d.shape in [(12, 12), (12, 14)]
            assert observed3d.shape in [(12, 12, 3), (12, 14, 3)]
            if observed2d.shape == (12, 12):
                seen2d[0] = True
            else:
                seen2d[1] = True
            if observed3d.shape == (12, 12, 3):
                seen3d[0] = True
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="1221" endline="1242" pcid="3539">
            else:
                seen3d[1] = True
            if np.all(seen2d) and np.all(seen3d):
                break
        assert np.all(seen2d)
        assert np.all(seen3d)

    def test_change_height_by_fixed_int_width_by_stochastic_parameter(self):
        aug = iaa.Resize({"height": 12, "width": iap.Choice([12, 14])})
        seen2d = [False, False]
        seen3d = [False, False]
        for _ in sm.xrange(100):
            observed2d = aug.augment_image(self.image2d)
            observed3d = aug.augment_image(self.image3d)
            assert observed2d.shape in [(12, 12), (12, 14)]
            assert observed3d.shape in [(12, 12, 3), (12, 14, 3)]
            if observed2d.shape == (12, 12):
                seen2d[0] = True
            else:
                seen2d[1] = True
            if observed3d.shape == (12, 12, 3):
                seen3d[0] = True
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="1177" endline="1198" pcid="3537">
        observed2d = aug.augment_image(self.image2d)
        observed3d = aug.augment_image(self.image3d)
        aspect_ratio2d = self._aspect_ratio(self.image2d)
        aspect_ratio3d = self._aspect_ratio(self.image3d)
        assert observed2d.shape == (int(6 * (1/aspect_ratio2d)), 6)
        assert observed3d.shape == (int(6 * (1/aspect_ratio3d)), 6, 3)

    def test_change_height_by_list_of_ints_width_by_fixed_int(self):
        aug = iaa.Resize({"height": [12, 14], "width": 12})
        seen2d = [False, False]
        seen3d = [False, False]
        for _ in sm.xrange(100):
            observed2d = aug.augment_image(self.image2d)
            observed3d = aug.augment_image(self.image3d)
            assert observed2d.shape in [(12, 12), (14, 12)]
            assert observed3d.shape in [(12, 12, 3), (14, 12, 3)]
            if observed2d.shape == (12, 12):
                seen2d[0] = True
            else:
                seen2d[1] = True
            if observed3d.shape == (12, 12, 3):
                seen3d[0] = True
</source>
</class>

<class classid="182" nclones="2" nlines="25" similarity="92">
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="1054" endline="1079" pcid="3524">
            else:
                seen3d[1] = True
            if all(seen2d) and all(seen3d):
                break
        assert np.all(seen2d)
        assert np.all(seen3d)

    def test_size_is_tuple_of_ints(self):
        aug = iaa.Resize((12, 14))
        seen2d = [False, False, False]
        seen3d = [False, False, False]
        for _ in sm.xrange(100):
            observed2d = aug.augment_image(self.image2d)
            observed3d = aug.augment_image(self.image3d)
            assert observed2d.shape in [(12, 12), (13, 13), (14, 14)]
            assert observed3d.shape in [(12, 12, 3), (13, 13, 3), (14, 14, 3)]
            if observed2d.shape == (12, 12):
                seen2d[0] = True
            elif observed2d.shape == (13, 13):
                seen2d[1] = True
            else:
                seen2d[2] = True
            if observed3d.shape == (12, 12, 3):
                seen3d[0] = True
            elif observed3d.shape == (13, 13, 3):
                seen3d[1] = True
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="1243" endline="1268" pcid="3540">
            else:
                seen3d[1] = True
            if np.all(seen2d) and np.all(seen3d):
                break
        assert np.all(seen2d)
        assert np.all(seen3d)

    def test_change_height_by_tuple_of_ints_width_by_fixed_int(self):
        aug = iaa.Resize({"height": (12, 14), "width": 12})
        seen2d = [False, False, False]
        seen3d = [False, False, False]
        for _ in sm.xrange(100):
            observed2d = aug.augment_image(self.image2d)
            observed3d = aug.augment_image(self.image3d)
            assert observed2d.shape in [(12, 12), (13, 12), (14, 12)]
            assert observed3d.shape in [(12, 12, 3), (13, 12, 3), (14, 12, 3)]
            if observed2d.shape == (12, 12):
                seen2d[0] = True
            elif observed2d.shape == (13, 12):
                seen2d[1] = True
            else:
                seen2d[2] = True
            if observed3d.shape == (12, 12, 3):
                seen3d[0] = True
            elif observed3d.shape == (13, 12, 3):
                seen3d[1] = True
</source>
</class>

<class classid="183" nclones="2" nlines="27" similarity="92">
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="1285" endline="1312" pcid="3542">
                                    self.image2d.shape[1]*2)
        assert observed3d.shape == (self.image3d.shape[0]*2,
                                    self.image3d.shape[1]*2,
                                    3)
        assert intensity_low < np.average(observed2d) < intensity_high
        assert intensity_low < np.average(observed3d) < intensity_high

    def test_size_is_list(self):
        aug = iaa.Resize([2.0, 4.0])
        seen2d = [False, False]
        seen3d = [False, False]
        expected_shapes_2d = [
            (self.image2d.shape[0]*2, self.image2d.shape[1]*2),
            (self.image2d.shape[0]*4, self.image2d.shape[1]*4)]
        expected_shapes_3d = [
            (self.image3d.shape[0]*2, self.image3d.shape[1]*2, 3),
            (self.image3d.shape[0]*4, self.image3d.shape[1]*4, 3)]
        for _ in sm.xrange(100):
            observed2d = aug.augment_image(self.image2d)
            observed3d = aug.augment_image(self.image3d)
            assert observed2d.shape in expected_shapes_2d
            assert observed3d.shape in expected_shapes_3d
            if observed2d.shape == expected_shapes_2d[0]:
                seen2d[0] = True
            else:
                seen2d[1] = True
            if observed3d.shape == expected_shapes_3d[0]:
                seen3d[0] = True
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="1313" endline="1340" pcid="3543">
            else:
                seen3d[1] = True
            if np.all(seen2d) and np.all(seen3d):
                break
        assert np.all(seen2d)
        assert np.all(seen3d)

    def test_size_is_stochastic_parameter(self):
        aug = iaa.Resize(iap.Choice([2.0, 4.0]))
        seen2d = [False, False]
        seen3d = [False, False]
        expected_shapes_2d = [
            (self.image2d.shape[0]*2, self.image2d.shape[1]*2),
            (self.image2d.shape[0]*4, self.image2d.shape[1]*4)]
        expected_shapes_3d = [
            (self.image3d.shape[0]*2, self.image3d.shape[1]*2, 3),
            (self.image3d.shape[0]*4, self.image3d.shape[1]*4, 3)]
        for _ in sm.xrange(100):
            observed2d = aug.augment_image(self.image2d)
            observed3d = aug.augment_image(self.image3d)
            assert observed2d.shape in expected_shapes_2d
            assert observed3d.shape in expected_shapes_3d
            if observed2d.shape == expected_shapes_2d[0]:
                seen2d[0] = True
            else:
                seen2d[1] = True
            if observed3d.shape == expected_shapes_3d[0]:
                seen3d[0] = True
</source>
</class>

<class classid="184" nclones="2" nlines="26" similarity="88">
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="1341" endline="1366" pcid="3544">
            else:
                seen3d[1] = True
            if all(seen2d) and all(seen3d):
                break
        assert np.all(seen2d)
        assert np.all(seen3d)

    def test_decrease_size_by_tuple_of_floats__one_for_both_sides(self):
        image2d = self.image2d[0:4, 0:4]
        image3d = self.image3d[0:4, 0:4, :]
        aug = iaa.Resize((0.76, 1.0))
        not_seen2d = set()
        not_seen3d = set()
        for size in sm.xrange(3, 4+1):
            not_seen2d.add((size, size))
        for size in sm.xrange(3, 4+1):
            not_seen3d.add((size, size, 3))
        possible2d = set(list(not_seen2d))
        possible3d = set(list(not_seen3d))
        for _ in sm.xrange(100):
            observed2d = aug.augment_image(image2d)
            observed3d = aug.augment_image(image3d)
            assert observed2d.shape in possible2d
            assert observed3d.shape in possible3d
            if observed2d.shape in not_seen2d:
                not_seen2d.remove(observed2d.shape)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="1367" endline="1394" pcid="3545">
            if observed3d.shape in not_seen3d:
                not_seen3d.remove(observed3d.shape)
            if not not_seen2d and not not_seen3d:
                break
        assert not not_seen2d
        assert not not_seen3d

    def test_decrease_size_by_tuples_of_floats__one_per_side(self):
        image2d = self.image2d[0:4, 0:4]
        image3d = self.image3d[0:4, 0:4, :]
        aug = iaa.Resize({"height": (0.76, 1.0), "width": (0.76, 1.0)})
        not_seen2d = set()
        not_seen3d = set()
        for hsize in sm.xrange(3, 4+1):
            for wsize in sm.xrange(3, 4+1):
                not_seen2d.add((hsize, wsize))
        for hsize in sm.xrange(3, 4+1):
            for wsize in sm.xrange(3, 4+1):
                not_seen3d.add((hsize, wsize, 3))
        possible2d = set(list(not_seen2d))
        possible3d = set(list(not_seen3d))
        for _ in sm.xrange(100):
            observed2d = aug.augment_image(image2d)
            observed3d = aug.augment_image(image3d)
            assert observed2d.shape in possible2d
            assert observed3d.shape in possible3d
            if observed2d.shape in not_seen2d:
                not_seen2d.remove(observed2d.shape)
</source>
</class>

<class classid="185" nclones="2" nlines="26" similarity="88">
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="1606" endline="1637" pcid="3568">
        self._test_pad_cbaoi_by_1px_each_side_on_its_own(
            self.lsoi, "augment_line_strings")

    def test_pad_bounding_boxes_by_1px_each_side_on_its_own(self):
        self._test_pad_cbaoi_by_1px_each_side_on_its_own(
            self.bbsoi, "augment_bounding_boxes")

    def test_pad_heatmaps_by_1px_each_side_on_its_own(self):
        pads = [
            (1, 0, 0, 0),
            (0, 1, 0, 0),
            (0, 0, 1, 0),
            (0, 0, 0, 1),
        ]
        for pad in pads:
            with self.subTest(px=pad):
                aug = iaa.Pad(px=pad, keep_size=False)

                top, right, bottom, left = pad

                heatmaps_arr = self.heatmap.get_arr()
                heatmaps_arr_padded = np.pad(
                    heatmaps_arr,
                    ((top, bottom), (left, right)),
                    mode="constant",
                    constant_values=0)
                heatmaps = [ia.HeatmapsOnImage(
                    heatmaps_arr, shape=self.image.shape)]
                image_padded_shape = list(self.image.shape)
                image_padded_shape[0] += top + bottom
                image_padded_shape[1] += left + right

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="1638" endline="1668" pcid="3569">
                observed = aug.augment_heatmaps(heatmaps)[0]

                assert observed.shape == tuple(image_padded_shape)
                assert 0 - 1e-6 < observed.min_value < 0 + 1e-6
                assert 1 - 1e-6 < observed.max_value < 1 + 1e-6
                assert np.array_equal(observed.get_arr(), heatmaps_arr_padded)

    def test_pad_segmaps_by_1px_each_side_on_its_own(self):
        pads = [
            (1, 0, 0, 0),
            (0, 1, 0, 0),
            (0, 0, 1, 0),
            (0, 0, 0, 1),
        ]
        for pad in pads:
            with self.subTest(px=pad):
                aug = iaa.Pad(px=pad, keep_size=False)

                top, right, bottom, left = pad

                segmaps_arr = self.segmap.get_arr()
                segmaps_arr_padded = np.pad(
                    segmaps_arr,
                    ((top, bottom), (left, right)),
                    mode="constant",
                    constant_values=0)
                segmaps = [SegmentationMapsOnImage(
                    segmaps_arr, shape=self.image.shape)]
                image_padded_shape = list(self.image.shape)
                image_padded_shape[0] += top + bottom
                image_padded_shape[1] += left + right
</source>
</class>

<class classid="186" nclones="4" nlines="62" similarity="70">
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="1669" endline="1756" pcid="3570">

                observed = aug.augment_segmentation_maps(segmaps)[0]

                assert observed.shape == tuple(image_padded_shape)
                assert np.array_equal(observed.get_arr(), segmaps_arr_padded)

    # TODO split up, add similar tests for polygons/LS/BBs
    def test_pad_each_side_on_its_own_by_tuple_of_ints(self):
        def _to_range_tuple(val):
            return val if isinstance(val, tuple) else (val, val)

        pads = [
            ((0, 2), 0, 0, 0),
            (0, (0, 2), 0, 0),
            (0, 0, (0, 2), 0),
            (0, 0, 0, (0, 2)),
        ]
        for pad in pads:
            with self.subTest(px=pad):
                aug = iaa.Pad(px=pad, keep_size=False)
                aug_det = aug.to_deterministic()

                top, right, bottom, left = pad

                images_padded = []
                keypoints_padded = []
                top_range = _to_range_tuple(top)
                right_range = _to_range_tuple(right)
                bottom_range = _to_range_tuple(bottom)
                left_range = _to_range_tuple(left)

                top_values = sm.xrange(top_range[0], top_range[1]+1)
                right_values = sm.xrange(right_range[0], right_range[1]+1)
                bottom_values = sm.xrange(bottom_range[0], bottom_range[1]+1)
                left_values = sm.xrange(left_range[0], left_range[1]+1)

                for top_val in top_values:
                    for right_val in right_values:
                        for bottom_val in bottom_values:
                            for left_val in left_values:
                                images_padded.append(
                                    np.pad(
                                        self.image,
                                        ((top_val, bottom_val),
                                         (left_val, right_val),
                                         (0, 0)),
                                        mode="constant",
                                        constant_values=0
                                    )
                                )
                                keypoints_padded.append(
                                    self.kpsoi.shift(x=left_val, y=top_val))

                movements = []
                movements_det = []
                for i in sm.xrange(100):
                    observed = aug.augment_images(self.images)

                    matches = [
                        (1 if np.array_equal(observed,
                                             np.array([base_img_padded]))
                         else 0)
                        for base_img_padded
                        in images_padded
                    ]
                    movements.append(np.argmax(np.array(matches)))
                    assert any([val == 1 for val in matches])

                    observed = aug_det.augment_images(self.images)
                    matches = [
                        (1 if np.array_equal(observed,
                                             np.array([base_img_padded]))
                         else 0)
                        for base_img_padded
                        in images_padded
                    ]
                    movements_det.append(np.argmax(np.array(matches)))
                    assert any([val == 1 for val in matches])

                    observed = aug.augment_images([self.image])
                    assert any([
                        array_equal_lists(observed, [base_img_padded])
                        for base_img_padded
                        in images_padded])

                    observed = aug.augment_keypoints(self.kpsoi)
                    assert any([
                        keypoints_equal(observed, kp)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="1757" endline="1831" pcid="3572">
                        for kp
                        in keypoints_padded])

                assert len(set(movements)) == 3
                assert len(set(movements_det)) == 1

    # TODO split up, add similar tests for polygons/LS/BBs
    def test_pad_each_side_on_its_own_by_list_of_ints(self):
        # test pad by list of exact pixel values
        pads = [
            ([0, 2], 0, 0, 0),
            (0, [0, 2], 0, 0),
            (0, 0, [0, 2], 0),
            (0, 0, 0, [0, 2]),
        ]
        for pad in pads:
            top, right, bottom, left = pad
            aug = iaa.Pad(px=pad, keep_size=False)
            aug_det = aug.to_deterministic()

            images_padded = []
            keypoints_padded = []
            top_range = top if isinstance(top, list) else [top]
            right_range = right if isinstance(right, list) else [right]
            bottom_range = bottom if isinstance(bottom, list) else [bottom]
            left_range = left if isinstance(left, list) else [left]

            for top_val in top_range:
                for right_val in right_range:
                    for bottom_val in bottom_range:
                        for left_val in left_range:
                            images_padded.append(
                                np.pad(
                                    self.image,
                                    ((top_val, bottom_val),
                                     (left_val, right_val),
                                     (0, 0)),
                                    mode="constant",
                                    constant_values=0
                                )
                            )
                            keypoints_padded.append(
                                self.kpsoi.shift(x=left_val, y=top_val))

            movements = []
            movements_det = []
            for i in sm.xrange(100):
                observed = aug.augment_images(self.images)
                matches = [
                    (1 if np.array_equal(observed,
                                         np.array([base_img_padded]))
                     else 0)
                    for base_img_padded
                    in images_padded]
                movements.append(np.argmax(np.array(matches)))
                assert any([val == 1 for val in matches])

                observed = aug_det.augment_images(self.images)
                matches = [
                    (1 if np.array_equal(observed,
                                         np.array([base_img_padded]))
                     else 0)
                    for base_img_padded
                    in images_padded]
                movements_det.append(np.argmax(np.array(matches)))
                assert any([val == 1 for val in matches])

                observed = aug.augment_images([self.image])
                assert any([
                    array_equal_lists(observed, [base_img_padded])
                    for base_img_padded
                    in images_padded])

                observed = aug.augment_keypoints(self.kpsoi)
                assert any([
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="2963" endline="3046" pcid="3643">
                segmaps_arr = self.segmaps[0].get_arr()
                height, width = segmaps_arr.shape[0:2]
                segmaps_arr_cropped = segmaps_arr[top:height-bottom,
                                                  left:width-right]
                observed = aug.augment_segmentation_maps(self.segmaps)[0]
                assert observed.shape == base_img_cropped.shape
                assert np.array_equal(observed.get_arr(), segmaps_arr_cropped)

    # TODO split up and add polys/LS/BBs
    def test_crop_by_tuple_of_ints_on_each_side_on_its_own(self):
        def _to_range_tuple(val):
            return val if isinstance(val, tuple) else (val, val)

        crops = [
            ((0, 2), 0, 0, 0),
            (0, (0, 2), 0, 0),
            (0, 0, (0, 2), 0),
            (0, 0, 0, (0, 2)),
        ]
        for crop in crops:
            with self.subTest(px=crop):
                aug = iaa.Crop(px=crop, keep_size=False)
                aug_det = aug.to_deterministic()

                top, right, bottom, left = crop
                height, width = self.image.shape[0:2]

                top_range = _to_range_tuple(top)
                right_range = _to_range_tuple(right)
                bottom_range = _to_range_tuple(bottom)
                left_range = _to_range_tuple(left)

                top_values = sm.xrange(top_range[0], top_range[1]+1)
                right_values = sm.xrange(right_range[0], right_range[1]+1)
                bottom_values = sm.xrange(bottom_range[0], bottom_range[1]+1)
                left_values = sm.xrange(left_range[0], left_range[1]+1)

                images_cropped = []
                keypoints_cropped = []
                for top_val in top_values:
                    for right_val in right_values:
                        for bottom_val in bottom_values:
                            for left_val in left_values:
                                images_cropped.append(
                                    self.image[top_val:height-bottom_val,
                                               left_val:width-right_val,
                                               :]
                                )
                                keypoints_cropped.append(
                                    self.kpsoi.shift(
                                        x=-left_val, y=-top_val)
                                )

                movements = []
                movements_det = []
                for i in sm.xrange(100):
                    observed = aug.augment_images(self.images)

                    matches = [
                        (1
                         if np.array_equal(observed,
                                           np.array([base_img_cropped]))
                         else 0)
                        for base_img_cropped
                        in images_cropped]
                    movements.append(np.argmax(np.array(matches)))
                    assert any([val == 1 for val in matches])

                    observed = aug_det.augment_images(self.images)
                    matches = [
                        (1
                         if np.array_equal(observed,
                                           np.array([base_img_cropped]))
                         else 0)
                        for base_img_cropped
                        in images_cropped]
                    movements_det.append(np.argmax(np.array(matches)))
                    assert any([val == 1 for val in matches])

                    observed = aug.augment_images([self.image])
                    assert any([array_equal_lists(observed, [base_img_cropped])
                                for base_img_cropped
                                in images_cropped])

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="3047" endline="3120" pcid="3645">
                    observed = aug.augment_keypoints(self.kpsoi)
                    assert any([keypoints_equal(observed, kp)
                                for kp
                                in keypoints_cropped])

                assert len(set(movements)) == 3
                assert len(set(movements_det)) == 1

    # TODO split up and add polys/LS/BBs
    def test_crop_by_list_of_ints_on_each_side_on_its_own(self):
        # test crop by list of exact pixel values
        crops = [
            ([0, 2], 0, 0, 0),
            (0, [0, 2], 0, 0),
            (0, 0, [0, 2], 0),
            (0, 0, 0, [0, 2]),
        ]
        for crop in crops:
            with self.subTest(px=crop):
                aug = iaa.Crop(px=crop, keep_size=False)
                aug_det = aug.to_deterministic()

                top, right, bottom, left = crop
                height, width = self.image.shape[0:2]

                top_range = top if isinstance(top, list) else [top]
                right_range = right if isinstance(right, list) else [right]
                bottom_range = bottom if isinstance(bottom, list) else [bottom]
                left_range = left if isinstance(left, list) else [left]

                images_cropped = []
                keypoints_cropped = []
                for top_val in top_range:
                    for right_val in right_range:
                        for bottom_val in bottom_range:
                            for left_val in left_range:
                                images_cropped.append(
                                    self.image[top_val:height-bottom_val,
                                               left_val:width-right_val,
                                               :]
                                )
                                keypoints_cropped.append(
                                    self.kpsoi.shift(
                                        x=-left_val, y=-top_val)
                                )

                movements = []
                movements_det = []
                for i in sm.xrange(100):
                    observed = aug.augment_images(self.images)
                    matches = [
                        (1
                         if np.array_equal(observed,
                                           np.array([base_img_cropped]))
                         else 0)
                        for base_img_cropped
                        in images_cropped]
                    movements.append(np.argmax(np.array(matches)))
                    assert any([val == 1 for val in matches])

                    observed = aug_det.augment_images(self.images)
                    matches = [
                        (1
                         if np.array_equal(observed,
                                           np.array([base_img_cropped]))
                         else 0)
                        for base_img_cropped in images_cropped]
                    movements_det.append(np.argmax(np.array(matches)))
                    assert any([val == 1 for val in matches])

                    observed = aug.augment_images([self.image])
                    assert any([array_equal_lists(observed, [base_img_cropped])
                                for base_img_cropped
                                in images_cropped])
</source>
</class>

<class classid="187" nclones="4" nlines="24" similarity="72">
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="1832" endline="1861" pcid="3573">
                    keypoints_equal(observed, kp)
                    for kp
                    in keypoints_padded])

            assert len(set(movements)) == 2
            assert len(set(movements_det)) == 1

    def test_pad_heatmaps_smaller_than_img_by_tuple_of_ints_without_ks(self):
        # pad smaller heatmaps
        # heatmap is (6, 4), image is (6, 16)
        # image is padded by (2, 4, 2, 4)
        # expected image size: (10, 24)
        # expected heatmap size: (10, 6)
        aug = iaa.Pad(px=(2, 4, 2, 4), keep_size=False)
        heatmaps_arr_small = np.float32([
            [0, 0, 0, 0],
            [0, 1.0, 1.0, 0],
            [0, 1.0, 1.0, 0],
            [0, 1.0, 1.0, 0],
            [0, 1.0, 1.0, 0],
            [0, 0, 0, 0]
        ])
        top, bottom, left, right = 2, 2, 1, 1
        heatmaps_arr_small_padded = np.pad(
            heatmaps_arr_small,
            ((top, bottom), (left, right)),
            mode="constant",
            constant_values=0)
        heatmaps = [ia.HeatmapsOnImage(heatmaps_arr_small, shape=(6, 16))]
        observed = aug.augment_heatmaps(heatmaps)[0]
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="2426" endline="2462" pcid="3607">

        observed = aug.augment_segmentation_maps(segmaps)[0]

        assert observed.shape == (12, 24)
        assert observed.arr.shape == (12, 6, 1)
        assert np.array_equal(observed.arr[..., 0], segmaps_arr_small_padded)

    def test_pad_heatmaps_smaller_than_img_by_floats_with_keep_size(self):
        # pad smaller heatmaps, with keep_size=True
        # heatmap is (6, 4), image is (6, 16)
        # image is padded by (0.5, 0.25, 0.5, 0.25)
        # expected image size: (12, 24) -> (6, 16) after resize
        # expected heatmap size: (12, 6) -> (6, 4) after resize
        aug = iaa.Pad(percent=(0.5, 0.25, 0.5, 0.25), keep_size=True)
        heatmaps_arr_small = np.float32([
            [0, 0, 0, 0],
            [0, 1.0, 1.0, 0],
            [0, 1.0, 1.0, 0],
            [0, 1.0, 1.0, 0],
            [0, 1.0, 1.0, 0],
            [0, 0, 0, 0]
        ])
        top, bottom, left, right = 3, 3, 1, 1
        heatmaps_arr_small_padded = np.pad(
            heatmaps_arr_small,
            ((top, bottom), (left, right)),
            mode="constant",
            constant_values=0)
        heatmaps = [ia.HeatmapsOnImage(heatmaps_arr_small, shape=(6, 16))]

        observed = aug.augment_heatmaps(heatmaps)[0]
        assert observed.shape == (6, 16)
        assert observed.arr_0to1.shape == (6, 4, 1)
        assert 0 - 1e-6 < observed.min_value < 0 + 1e-6
        assert 1 - 1e-6 < observed.max_value < 1 + 1e-6
        assert np.allclose(
            observed.arr_0to1[..., 0],
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="2371" endline="2401" pcid="3605">
        height, width = (4, 4)
        bbs = [ia.BoundingBox(x1=0, y1=0, x2=4, y2=4),
               ia.BoundingBox(x1=1, y1=2, x2=3, y2=4)]
        bbsoi = ia.BoundingBoxesOnImage(bbs, shape=(height, width))
        self._test_pad_cba_each_side_by_100_percent_without_keep_size(
            "augment_bounding_boxes", bbsoi)

    def test_pad_heatmaps_smaller_than_img_by_floats_without_keep_size(self):
        # pad smaller heatmaps
        # heatmap is (6, 4), image is (6, 16)
        # image is padded by (0.5, 0.25, 0.5, 0.25)
        # expected image size: (12, 24)
        # expected heatmap size: (12, 6)
        aug = iaa.Pad(percent=(0.5, 0.25, 0.5, 0.25), keep_size=False)
        heatmaps_arr_small = np.float32([
            [0, 0, 0, 0],
            [0, 1.0, 1.0, 0],
            [0, 1.0, 1.0, 0],
            [0, 1.0, 1.0, 0],
            [0, 1.0, 1.0, 0],
            [0, 0, 0, 0]
        ])
        top, bottom, left, right = 3, 3, 1, 1
        heatmaps_arr_small_padded = np.pad(
            heatmaps_arr_small,
            ((top, bottom), (left, right)),
            mode="constant",
            constant_values=0)
        heatmaps = [ia.HeatmapsOnImage(heatmaps_arr_small, shape=(6, 16))]

        observed = aug.augment_heatmaps(heatmaps)[0]
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="1888" endline="1927" pcid="3575">

        observed = aug.augment_segmentation_maps(segmaps)[0]

        assert observed.shape == (10, 24)
        assert observed.arr.shape == (10, 6, 1)
        assert np.array_equal(observed.arr[..., 0], segmaps_arr_small_padded)

    def test_pad_heatmaps_smaller_than_img_by_tuple_of_ints_with_ks(self):
        # pad smaller heatmaps, with keep_size=True
        # heatmap is (6, 4), image is (6, 16)
        # image is padded by (2, 4, 2, 4)
        # expected image size: (10, 24) -> (6, 16) after resize
        # expected heatmap size: (10, 6) -> (6, 4) after resize
        aug = iaa.Pad(px=(2, 4, 2, 4), keep_size=True)
        heatmaps_arr_small = np.float32([
            [0, 0, 0, 0],
            [0, 1.0, 1.0, 0],
            [0, 1.0, 1.0, 0],
            [0, 1.0, 1.0, 0],
            [0, 1.0, 1.0, 0],
            [0, 0, 0, 0]
        ])
        top, bottom, left, right = 2, 2, 1, 1
        heatmaps_arr_small_padded = np.pad(
            heatmaps_arr_small,
            ((top, bottom), (left, right)),
            mode="constant",
            constant_values=0)
        heatmaps = [ia.HeatmapsOnImage(heatmaps_arr_small, shape=(6, 16))]

        observed = aug.augment_heatmaps(heatmaps)[0]

        assert observed.shape == (6, 16)
        assert observed.arr_0to1.shape == (6, 4, 1)
        assert 0 - 1e-6 < observed.min_value < 0 + 1e-6
        assert 1 - 1e-6 < observed.max_value < 1 + 1e-6
        assert np.allclose(
            observed.arr_0to1[..., 0],
            np.clip(
                ia.imresize_single_image(
</source>
</class>

<class classid="188" nclones="4" nlines="21" similarity="73">
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="1862" endline="1887" pcid="3574">

        assert observed.shape == (10, 24)
        assert observed.arr_0to1.shape == (10, 6, 1)
        assert 0 - 1e-6 < observed.min_value < 0 + 1e-6
        assert 1 - 1e-6 < observed.max_value < 1 + 1e-6
        assert np.allclose(observed.arr_0to1[..., 0], heatmaps_arr_small_padded)

    def test_pad_segmaps_smaller_than_img_by_tuple_of_ints_without_ks(self):
        # pad smaller segmaps
        # same sizes and paddings as above
        aug = iaa.Pad(px=(2, 4, 2, 4), keep_size=False)
        segmaps_arr_small = np.int32([
            [0, 0, 0, 0],
            [0, 1, 1, 0],
            [0, 1, 1, 0],
            [0, 1, 1, 0],
            [0, 1, 1, 0],
            [0, 0, 0, 0]
        ])
        segmaps = [SegmentationMapsOnImage(segmaps_arr_small, shape=(6, 16))]
        top, bottom, left, right = 2, 2, 1, 1
        segmaps_arr_small_padded = np.pad(
            segmaps_arr_small,
            ((top, bottom), (left, right)),
            mode="constant",
            constant_values=0)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="2402" endline="2425" pcid="3606">

        assert observed.shape == (12, 24)
        assert observed.arr_0to1.shape == (12, 6, 1)
        assert 0 - 1e-6 < observed.min_value < 0 + 1e-6
        assert 1 - 1e-6 < observed.max_value < 1 + 1e-6
        assert np.allclose(observed.arr_0to1[..., 0], heatmaps_arr_small_padded)

    def test_pad_segmaps_smaller_than_img_by_floats_without_keep_size(self):
        aug = iaa.Pad(percent=(0.5, 0.25, 0.5, 0.25), keep_size=False)
        segmaps_arr_small = np.int32([
            [0, 0, 0, 0],
            [0, 1, 1, 0],
            [0, 1, 1, 0],
            [0, 1, 1, 0],
            [0, 1, 1, 0],
            [0, 0, 0, 0]
        ])
        top, bottom, left, right = 3, 3, 1, 1
        segmaps_arr_small_padded = np.pad(
            segmaps_arr_small,
            ((top, bottom), (left, right)),
            mode="constant",
            constant_values=0)
        segmaps = [SegmentationMapsOnImage(segmaps_arr_small, shape=(6, 16))]
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="2463" endline="2490" pcid="3608">
            np.clip(
                ia.imresize_single_image(
                    heatmaps_arr_small_padded, (6, 4), interpolation="cubic"),
                0, 1.0
            )
        )

    def test_pad_segmaps_smaller_than_img_by_floats_with_keep_size(self):
        aug = iaa.Pad(percent=(0.5, 0.25, 0.5, 0.25), keep_size=True)
        segmaps_arr_small = np.int32([
            [0, 0, 0, 0],
            [0, 1, 1, 0],
            [0, 1, 1, 0],
            [0, 1, 1, 0],
            [0, 1, 1, 0],
            [0, 0, 0, 0]
        ])
        top, bottom, left, right = 3, 3, 1, 1
        segmaps_arr_small_padded = np.pad(
            segmaps_arr_small,
            ((top, bottom), (left, right)),
            mode="constant",
            constant_values=0)
        segmaps = [SegmentationMapsOnImage(segmaps_arr_small, shape=(6, 16))]

        observed = aug.augment_segmentation_maps(segmaps)[0]

        assert observed.shape == (6, 16)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="1928" endline="1960" pcid="3576">
                    heatmaps_arr_small_padded,
                    (6, 4),
                    interpolation="cubic"),
                0, 1.0
            )
        )

    def test_pad_segmaps_smaller_than_img_by_tuple_of_ints_with_keep_size(self):
        # pad smaller segmaps, with keep_size=True
        # same sizes and paddings as above
        aug = iaa.Pad(px=(2, 4, 2, 4), keep_size=True)
        segmaps_arr_small = np.int32([
            [0, 0, 0, 0],
            [0, 1, 1, 0],
            [0, 1, 1, 0],
            [0, 1, 1, 0],
            [0, 1, 1, 0],
            [0, 0, 0, 0]
        ])
        top, bottom, left, right = 2, 2, 1, 1
        segmaps_arr_small_padded = np.pad(
            segmaps_arr_small,
            ((top, bottom), (left, right)),
            mode="constant",
            constant_values=0)
        segmaps = [SegmentationMapsOnImage(segmaps_arr_small, shape=(6, 16))]

        observed = aug.augment_segmentation_maps(segmaps)[0]

        assert observed.shape == (6, 16)
        assert observed.arr.shape == (6, 4, 1)
        assert np.array_equal(
            observed.arr[..., 0],
</source>
</class>

<class classid="189" nclones="2" nlines="11" similarity="90">
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="1961" endline="1972" pcid="3577">
            ia.imresize_single_image(
                segmaps_arr_small_padded,
                (6, 4),
                interpolation="nearest"
            ),
        )

    def test_pad_keypoints_by_tuple_of_fixed_ints_without_keep_size(self):
        aug = iaa.Pad((2, 0, 4, 4), keep_size=False)
        kps = [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=0)]
        kpsoi = ia.KeypointsOnImage(kps, shape=(4, 4, 3))
        kpsoi_aug = aug.augment_keypoints([kpsoi])[0]
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="2491" endline="2502" pcid="3609">
        assert observed.arr.shape == (6, 4, 1)
        assert np.array_equal(
            observed.arr[..., 0],
            ia.imresize_single_image(
                segmaps_arr_small_padded, (6, 4), interpolation="nearest")
        )

    def test_pad_keypoints_by_floats_without_keep_size(self):
        aug = iaa.Pad(percent=(0.5, 0, 1.0, 1.0), keep_size=False)
        kps = [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=0)]
        kpsoi = ia.KeypointsOnImage(kps, shape=(4, 4, 3))
        kpsoi_aug = aug.augment_keypoints([kpsoi])[0]
</source>
</class>

<class classid="190" nclones="2" nlines="11" similarity="90">
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="1973" endline="1984" pcid="3578">
        assert kpsoi_aug.shape == (10, 8, 3)
        assert len(kpsoi_aug.keypoints) == 2
        assert np.allclose(kpsoi_aug.keypoints[0].x, 4+1)
        assert np.allclose(kpsoi_aug.keypoints[0].y, 2+2)
        assert np.allclose(kpsoi_aug.keypoints[1].x, 4+3)
        assert np.allclose(kpsoi_aug.keypoints[1].y, 2+0)

    def test_pad_keypoints_by_tuple_of_fixed_ints_with_keep_size(self):
        aug = iaa.Pad((2, 0, 4, 4), keep_size=True)
        kps = [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=0)]
        kpsoi = ia.KeypointsOnImage(kps, shape=(4, 4, 3))
        kpsoi_aug = aug.augment_keypoints([kpsoi])[0]
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="2503" endline="2514" pcid="3610">
        assert kpsoi_aug.shape == (10, 8, 3)
        assert len(kpsoi_aug.keypoints) == 2
        assert np.allclose(kpsoi_aug.keypoints[0].x, 4+1)
        assert np.allclose(kpsoi_aug.keypoints[0].y, 2+2)
        assert np.allclose(kpsoi_aug.keypoints[1].x, 4+3)
        assert np.allclose(kpsoi_aug.keypoints[1].y, 2+0)

    def test_pad_keypoints_by_floats_with_keep_size(self):
        aug = iaa.Pad(percent=(0.5, 0, 1.0, 1.0), keep_size=True)
        kps = [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=0)]
        kpsoi = ia.KeypointsOnImage(kps, shape=(4, 4, 3))
        kpsoi_aug = aug.augment_keypoints([kpsoi])[0]
</source>
</class>

<class classid="191" nclones="16" nlines="14" similarity="71">
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="1985" endline="1999" pcid="3579">
        assert kpsoi_aug.shape == (4, 4, 3)
        assert len(kpsoi_aug.keypoints) == 2
        assert np.allclose(kpsoi_aug.keypoints[0].x, ((4+1)/8)*4)
        assert np.allclose(kpsoi_aug.keypoints[0].y, ((2+2)/10)*4)
        assert np.allclose(kpsoi_aug.keypoints[1].x, ((4+3)/8)*4)
        assert np.allclose(kpsoi_aug.keypoints[1].y, ((2+0)/10)*4)

    def test_pad_polygons_by_tuple_of_fixed_ints_without_keep_size(self):
        aug = iaa.Pad((2, 0, 4, 4), keep_size=False)
        polygons = [ia.Polygon([(0, 0), (4, 0), (4, 4), (0, 4)]),
                    ia.Polygon([(1, 1), (5, 1), (5, 5), (1, 5)])]
        psoi = ia.PolygonsOnImage(polygons, shape=(4, 4, 3))
        psoi_aug = aug.augment_polygons([psoi, psoi])
        assert len(psoi_aug) == 2
        for psoi_aug_i in psoi_aug:
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="2515" endline="2532" pcid="3611">
        assert kpsoi_aug.shape == (4, 4, 3)
        assert len(kpsoi_aug.keypoints) == 2
        assert np.allclose(kpsoi_aug.keypoints[0].x, ((4+1)/8)*4)
        assert np.allclose(kpsoi_aug.keypoints[0].y, ((2+2)/10)*4)
        assert np.allclose(kpsoi_aug.keypoints[1].x, ((4+3)/8)*4)
        assert np.allclose(kpsoi_aug.keypoints[1].y, ((2+0)/10)*4)

    def test_pad_polygons_by_floats_without_keep_size(self):
        aug = iaa.Pad(percent=(0.5, 0, 1.0, 1.0), keep_size=False)
        cbaoi = ia.PolygonsOnImage([
            ia.Polygon([(0, 0), (4, 0), (4, 4), (0, 4)]),
            ia.Polygon([(1, 1), (5, 1), (5, 5), (1, 5)])
        ], shape=(4, 4, 3))
        cbaoi_aug = aug.augment_polygons([cbaoi, cbaoi])
        assert len(cbaoi_aug) == 2
        for cbaoi_aug_i in cbaoi_aug:
            assert cbaoi_aug_i.shape == (10, 8, 3)
            assert len(cbaoi_aug_i.items) == 2
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="2558" endline="2575" pcid="3613">
            assert cbaoi_aug_i.items[1].coords_almost_equals(
                [(4*(5/8), 4*(3/10)),
                 (4*(9/8), 4*(3/10)),
                 (4*(9/8), 4*(7/10)),
                 (4*(5/8), 4*(7/10))]
            )

    def test_pad_line_strings_by_floats_without_keep_size(self):
        aug = iaa.Pad(percent=(0.5, 0, 1.0, 1.0), keep_size=False)
        cbaoi = ia.LineStringsOnImage([
            ia.LineString([(0, 0), (4, 0), (4, 4), (0, 4)]),
            ia.LineString([(1, 1), (5, 1), (5, 5), (1, 5)])
        ], shape=(4, 4, 3))
        cbaoi_aug = aug.augment_line_strings([cbaoi, cbaoi])
        assert len(cbaoi_aug) == 2
        for cbaoi_aug_i in cbaoi_aug:
            assert cbaoi_aug_i.shape == (10, 8, 3)
            assert len(cbaoi_aug_i.items) == 2
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="3236" endline="3254" pcid="3652">
        kpsoi = ia.KeypointsOnImage(kps, shape=(14, 14, 3))

        kpsoi_aug = aug.augment_keypoints([kpsoi])[0]

        assert kpsoi_aug.shape == (14, 14, 3)
        assert len(kpsoi_aug.keypoints) == 2
        assert np.allclose(kpsoi_aug.keypoints[0].x, ((3-4)/10)*14)
        assert np.allclose(kpsoi_aug.keypoints[0].y, ((6-1)/9)*14)
        assert np.allclose(kpsoi_aug.keypoints[1].x, ((8-4)/10)*14)
        assert np.allclose(kpsoi_aug.keypoints[1].y, ((5-1)/9)*14)

    def test_crop_polygons_by_fixed_ints_without_keep_size(self):
        aug = iaa.Crop((1, 0, 4, 4), keep_size=False)
        polygons = [ia.Polygon([(0, 0), (4, 0), (4, 4), (0, 4)]),
                    ia.Polygon([(1, 1), (5, 1), (5, 5), (1, 5)])]
        cbaoi = ia.PolygonsOnImage(polygons, shape=(10, 10, 3))

        cbaoi_aug = aug.augment_polygons([cbaoi, cbaoi])

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="3280" endline="3298" pcid="3654">
                 (10*(0/6), 10*(-1/5)),
                 (10*(0/6), 10*(3/5)),
                 (10*(-4/6), 10*(3/5))]
            )
            assert cbaoi_aug_i.items[1].coords_almost_equals(
                [(10*(-3/6), 10*(0/5)),
                 (10*(1/6), 10*(0/5)),
                 (10*(1/6), 10*(4/5)),
                 (10*(-3/6), 10*(4/5))]
            )

    def test_crop_line_strings_by_fixed_ints_without_keep_size(self):
        aug = iaa.Crop((1, 0, 4, 4), keep_size=False)
        lss = [ia.LineString([(0, 0), (4, 0), (4, 4), (0, 4)]),
               ia.LineString([(1, 1), (5, 1), (5, 5), (1, 5)])]
        cbaoi = ia.LineStringsOnImage(lss, shape=(10, 10, 3))

        cbaoi_aug = aug.augment_line_strings([cbaoi, cbaoi])

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="3324" endline="3342" pcid="3656">
                 (10*(0/6), 10*(-1/5)),
                 (10*(0/6), 10*(3/5)),
                 (10*(-4/6), 10*(3/5))]
            )
            assert cbaoi_aug_i.items[1].coords_almost_equals(
                [(10*(-3/6), 10*(0/5)),
                 (10*(1/6), 10*(0/5)),
                 (10*(1/6), 10*(4/5)),
                 (10*(-3/6), 10*(4/5))]
            )

    def test_crop_bounding_boxes_by_fixed_ints_without_keep_size(self):
        aug = iaa.Crop((1, 0, 4, 4), keep_size=False)
        bbs = [ia.BoundingBox(x1=0, y1=0, x2=10, y2=10),
               ia.BoundingBox(x1=1, y1=2, x2=9, y2=10)]
        bbsoi = ia.BoundingBoxesOnImage(bbs, shape=(10, 10, 3))

        bbsoi_aug = aug.augment_bounding_boxes([bbsoi, bbsoi])

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="3600" endline="3618" pcid="3674">
        aug = iaa.Crop(percent=(0.25, 0, 0.5, 0.1), keep_size=True)
        kps = [ia.Keypoint(x=12, y=10), ia.Keypoint(x=8, y=12)]
        kpsoi = ia.KeypointsOnImage(kps, shape=(16, 20, 3))

        kpsoi_aug = aug.augment_keypoints([kpsoi])[0]

        assert kpsoi_aug.shape == (16, 20, 3)
        assert len(kpsoi_aug.keypoints) == 2
        assert np.allclose(kpsoi_aug.keypoints[0].x, ((12-2)/18)*20)
        assert np.allclose(kpsoi_aug.keypoints[0].y, ((10-4)/4)*16)
        assert np.allclose(kpsoi_aug.keypoints[1].x, ((8-2)/18)*20)
        assert np.allclose(kpsoi_aug.keypoints[1].y, ((12-4)/4)*16)

    def test_crop_polygons_by_fixed_floats_without_keep_size(self):
        aug = iaa.Crop(percent=(0.2, 0, 0.5, 0.1), keep_size=False)
        polygons = [ia.Polygon([(0, 0), (4, 0), (4, 4), (0, 4)]),
                    ia.Polygon([(1, 1), (5, 1), (5, 5), (1, 5)])]
        cbaoi = ia.PolygonsOnImage(polygons, shape=(10, 10, 3))

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="3644" endline="3662" pcid="3676">
            assert cbaoi_aug_i.items[0].coords_almost_equals(
                [(10*(-1/9), 10*(-2/3)),
                 (10*(3/9), 10*(-2/3)),
                 (10*(3/9), 10*(2/3)),
                 (10*(-1/9), 10*(2/3))]
            )
            assert cbaoi_aug_i.items[1].coords_almost_equals(
                [(10*(0/9), 10*(-1/3)),
                 (10*(4/9), 10*(-1/3)),
                 (10*(4/9), 10*(3/3)),
                 (10*(0/9), 10*(3/3))]
            )

    def test_crop_line_strings_by_fixed_floats_without_keep_size(self):
        aug = iaa.Crop(percent=(0.2, 0, 0.5, 0.1), keep_size=False)
        lss = [ia.LineString([(0, 0), (4, 0), (4, 4), (0, 4)]),
               ia.LineString([(1, 1), (5, 1), (5, 5), (1, 5)])]
        cbaoi = ia.LineStringsOnImage(lss, shape=(10, 10, 3))

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="2078" endline="2094" pcid="3584">
            assert bbsoi_aug_i.bounding_boxes[0].coords_almost_equals(
                [(4+0, 2+0), (4+4, 2+4)]
            )
            assert bbsoi_aug_i.bounding_boxes[1].coords_almost_equals(
                [(4+1, 2+1), (4+3, 2+4)]
            )

    def test_pad_bounding_boxes_by_tuple_of_fixed_ints_with_keep_size(self):
        aug = iaa.Pad((2, 0, 4, 4), keep_size=True)
        bbs = [ia.BoundingBox(x1=0, y1=0, x2=4, y2=4),
               ia.BoundingBox(x1=1, y1=1, x2=3, y2=4)]
        bbsoi = ia.BoundingBoxesOnImage(bbs, shape=(4, 4, 3))
        bbsoi_aug = aug.augment_bounding_boxes([bbsoi, bbsoi])
        assert len(bbsoi_aug) == 2
        for bbsoi_aug_i in bbsoi_aug:
            assert bbsoi_aug_i.shape == (4, 4, 3)
            assert len(bbsoi_aug_i.bounding_boxes) == 2
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="2023" endline="2037" pcid="3581">
            assert psoi_aug_i.items[1].coords_almost_equals(
                [(4*(5/8), 4*(3/10)),
                 (4*(9/8), 4*(3/10)),
                 (4*(9/8), 4*(7/10)),
                 (4*(5/8), 4*(7/10))]
            )

    def test_pad_line_strings_by_tuple_of_fixed_ints_without_keep_size(self):
        aug = iaa.Pad((2, 0, 4, 4), keep_size=False)
        lss = [ia.LineString([(0, 0), (4, 0), (4, 4), (0, 4)]),
               ia.LineString([(1, 1), (5, 1), (5, 5), (1, 5)])]
        cbaoi = ia.LineStringsOnImage(lss, shape=(4, 4, 3))
        cbaoi_aug = aug.augment_line_strings([cbaoi, cbaoi])
        assert len(cbaoi_aug) == 2
        for cbaoi_aug_i in cbaoi_aug:
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="2061" endline="2077" pcid="3583">
            assert cbaoi_aug_i.items[1].coords_almost_equals(
                [(4*(5/8), 4*(3/10)),
                 (4*(9/8), 4*(3/10)),
                 (4*(9/8), 4*(7/10)),
                 (4*(5/8), 4*(7/10))]
            )

    def test_pad_bounding_boxes_by_tuple_of_fixed_ints_without_keep_size(self):
        aug = iaa.Pad((2, 0, 4, 4), keep_size=False)
        bbs = [ia.BoundingBox(x1=0, y1=0, x2=4, y2=4),
               ia.BoundingBox(x1=1, y1=1, x2=3, y2=4)]
        bbsoi = ia.BoundingBoxesOnImage(bbs, shape=(4, 4, 3))
        bbsoi_aug = aug.augment_bounding_boxes([bbsoi, bbsoi])
        assert len(bbsoi_aug) == 2
        for bbsoi_aug_i in bbsoi_aug:
            assert bbsoi_aug_i.shape == (10, 8, 3)
            assert len(bbsoi_aug_i.bounding_boxes) == 2
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="3343" endline="3363" pcid="3657">
        assert len(bbsoi_aug) == 2
        for bbsoi_aug_i in bbsoi_aug:
            assert bbsoi_aug_i.shape == (5, 6, 3)
            assert len(bbsoi_aug_i.bounding_boxes) == 2
            assert bbsoi_aug_i.bounding_boxes[0].coords_almost_equals(
                [(0-4, 0-1), (10-4, 10-1)]
            )
            assert bbsoi_aug_i.bounding_boxes[1].coords_almost_equals(
                [(1-4, 2-1), (9-4, 10-1)]
            )

    def test_crop_bounding_boxes_by_fixed_ints_with_keep_size(self):
        aug = iaa.Crop((1, 0, 4, 4), keep_size=True)
        bbs = [ia.BoundingBox(x1=0, y1=0, x2=10, y2=10),
               ia.BoundingBox(x1=1, y1=2, x2=9, y2=10)]
        bbsoi = ia.BoundingBoxesOnImage(bbs, shape=(10, 10, 3))

        bbsoi_aug = aug.augment_bounding_boxes([bbsoi, bbsoi])

        assert len(bbsoi_aug) == 2
        for bbsoi_aug_i in bbsoi_aug:
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="3688" endline="3706" pcid="3678">
            assert cbaoi_aug_i.items[0].coords_almost_equals(
                [(10*(-1/9), 10*(-2/3)),
                 (10*(3/9), 10*(-2/3)),
                 (10*(3/9), 10*(2/3)),
                 (10*(-1/9), 10*(2/3))]
            )
            assert cbaoi_aug_i.items[1].coords_almost_equals(
                [(10*(0/9), 10*(-1/3)),
                 (10*(4/9), 10*(-1/3)),
                 (10*(4/9), 10*(3/3)),
                 (10*(0/9), 10*(3/3))]
            )

    def test_crop_bounding_boxes_by_fixed_floats_without_keep_size(self):
        aug = iaa.Crop(percent=(0.2, 0, 0.5, 0.1), keep_size=False)
        bbs = [ia.BoundingBox(x1=0, y1=0, x2=4, y2=4),
               ia.BoundingBox(x1=1, y1=2, x2=3, y2=4)]
        bbsoi = ia.BoundingBoxesOnImage(bbs, shape=(10, 10, 3))

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="2620" endline="2639" pcid="3616">
                 (int(1.0*4+4), int(0.5*4+4))]
            )
            assert bbsoi_aug_i.bounding_boxes[1].coords_almost_equals(
                [(int(1.0*4+1), int(0.5*4+2)),
                 (int(1.0*4+3), int(0.5*4+4))]
            )

    def test_pad_bounding_boxes_by_floats_with_keep_size(self):
        # BBs, with keep_size=True
        aug = iaa.Pad(percent=(0.5, 0, 1.0, 1.0), keep_size=True)
        bbs = [ia.BoundingBox(x1=0, y1=0, x2=4, y2=4),
               ia.BoundingBox(x1=1, y1=2, x2=3, y2=4)]
        bbsoi = ia.BoundingBoxesOnImage(bbs, shape=(4, 4, 3))
        bbsoi_aug = aug.augment_bounding_boxes([bbsoi, bbsoi])
        assert len(bbsoi_aug) == 2
        for bbsoi_aug_i in bbsoi_aug:
            assert bbsoi_aug_i.shape == (4, 4, 3)
            assert len(bbsoi_aug_i.bounding_boxes) == 2
            assert bbsoi_aug_i.bounding_boxes[0].coords_almost_equals(
                [(4*(4/8), 4*(2/10)),
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="3707" endline="3727" pcid="3679">
        bbsoi_aug = aug.augment_bounding_boxes([bbsoi, bbsoi])

        assert len(bbsoi_aug) == 2
        for bbsoi_aug_i in bbsoi_aug:
            assert bbsoi_aug_i.shape == (3, 9, 3)
            assert len(bbsoi_aug_i.bounding_boxes) == 2
            assert bbsoi_aug_i.bounding_boxes[0].coords_almost_equals(
                [(0-1, 0-2), (4-1, 4-2)]
            )
            assert bbsoi_aug_i.bounding_boxes[1].coords_almost_equals(
                [(1-1, 2-2), (3-1, 4-2)]
            )

    def test_crop_bounding_boxes_by_fixed_floats_with_keep_size(self):
        aug = iaa.Crop(percent=(0.2, 0, 0.5, 0.1), keep_size=True)
        bbs = [ia.BoundingBox(x1=0, y1=0, x2=4, y2=4),
               ia.BoundingBox(x1=1, y1=2, x2=3, y2=4)]
        bbsoi = ia.BoundingBoxesOnImage(bbs, shape=(10, 10, 3))

        bbsoi_aug = aug.augment_bounding_boxes([bbsoi, bbsoi])

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="2601" endline="2619" pcid="3615">
            assert cbaoi_aug_i.items[1].coords_almost_equals(
                [(4*(5/8), 4*(3/10)),
                 (4*(9/8), 4*(3/10)),
                 (4*(9/8), 4*(7/10)),
                 (4*(5/8), 4*(7/10))]
            )

    def test_pad_bounding_boxes_by_floats_without_keep_size(self):
        aug = iaa.Pad(percent=(0.5, 0, 1.0, 1.0), keep_size=False)
        bbs = [ia.BoundingBox(x1=0, y1=0, x2=4, y2=4),
               ia.BoundingBox(x1=1, y1=2, x2=3, y2=4)]
        bbsoi = ia.BoundingBoxesOnImage(bbs, shape=(4, 4, 3))
        bbsoi_aug = aug.augment_bounding_boxes([bbsoi, bbsoi])
        assert len(bbsoi_aug) == 2
        for bbsoi_aug_i in bbsoi_aug:
            assert bbsoi_aug_i.shape == (10, 8, 3)
            assert len(bbsoi_aug_i.bounding_boxes) == 2
            assert bbsoi_aug_i.bounding_boxes[0].coords_almost_equals(
                [(int(1.0*4+0), int(0.5*4+0)),
</source>
</class>

<class classid="192" nclones="8" nlines="20" similarity="70">
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="2000" endline="2022" pcid="3580">
            assert psoi_aug_i.shape == (10, 8, 3)
            assert len(psoi_aug_i.items) == 2
            assert psoi_aug_i.items[0].coords_almost_equals(
                [(4, 2), (8, 2), (8, 6), (4, 6)])
            assert psoi_aug_i.items[1].coords_almost_equals(
                [(5, 3), (9, 3), (9, 7), (5, 7)])

    def test_pad_polygons_by_tuple_of_fixed_ints_with_keep_size(self):
        aug = iaa.Pad((2, 0, 4, 4), keep_size=True)
        polygons = [ia.Polygon([(0, 0), (4, 0), (4, 4), (0, 4)]),
                    ia.Polygon([(1, 1), (5, 1), (5, 5), (1, 5)])]
        psoi = ia.PolygonsOnImage(polygons, shape=(4, 4, 3))
        psoi_aug = aug.augment_polygons([psoi, psoi])
        assert len(psoi_aug) == 2
        for psoi_aug_i in psoi_aug:
            assert psoi_aug_i.shape == (4, 4, 3)
            assert len(psoi_aug_i.items) == 2
            assert psoi_aug_i.items[0].coords_almost_equals(
                [(4*(4/8), 4*(2/10)),
                 (4*(8/8), 4*(2/10)),
                 (4*(8/8), 4*(6/10)),
                 (4*(4/8), 4*(6/10))]
            )
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="3663" endline="3687" pcid="3677">
        cbaoi_aug = aug.augment_line_strings([cbaoi, cbaoi])

        assert len(cbaoi_aug) == 2
        for cbaoi_aug_i in cbaoi_aug:
            assert cbaoi_aug_i.shape == (3, 9, 3)
            assert len(cbaoi_aug_i.items) == 2
            assert cbaoi_aug_i.items[0].coords_almost_equals(
                [(0-1, 0-2), (4-1, 0-2), (4-1, 4-2), (0-1, 4-2)]
            )
            assert cbaoi_aug_i.items[1].coords_almost_equals(
                [(1-1, 1-2), (5-1, 1-2), (5-1, 5-2), (1-1, 5-2)]
            )

    def test_crop_line_strings_by_fixed_floats_with_keep_size(self):
        aug = iaa.Crop(percent=(0.2, 0, 0.5, 0.1), keep_size=True)
        lss = [ia.LineString([(0, 0), (4, 0), (4, 4), (0, 4)]),
               ia.LineString([(1, 1), (5, 1), (5, 5), (1, 5)])]
        cbaoi = ia.LineStringsOnImage(lss, shape=(10, 10, 3))

        cbaoi_aug = aug.augment_line_strings([cbaoi, cbaoi])

        assert len(cbaoi_aug) == 2
        for cbaoi_aug_i in cbaoi_aug:
            assert cbaoi_aug_i.shape == (10, 10, 3)
            assert len(cbaoi_aug_i.items) == 2
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="3619" endline="3643" pcid="3675">
        cbaoi_aug = aug.augment_polygons([cbaoi, cbaoi])

        assert len(cbaoi_aug) == 2
        for cbaoi_aug_i in cbaoi_aug:
            assert cbaoi_aug_i.shape == (3, 9, 3)
            assert len(cbaoi_aug_i.items) == 2
            assert cbaoi_aug_i.items[0].coords_almost_equals(
                [(0-1, 0-2), (4-1, 0-2), (4-1, 4-2), (0-1, 4-2)]
            )
            assert cbaoi_aug_i.items[1].coords_almost_equals(
                [(1-1, 1-2), (5-1, 1-2), (5-1, 5-2), (1-1, 5-2)]
            )

    def test_crop_polygons_by_fixed_floats_with_keep_size(self):
        aug = iaa.Crop(percent=(0.2, 0, 0.5, 0.1), keep_size=True)
        polygons = [ia.Polygon([(0, 0), (4, 0), (4, 4), (0, 4)]),
                    ia.Polygon([(1, 1), (5, 1), (5, 5), (1, 5)])]
        cbaoi = ia.PolygonsOnImage(polygons, shape=(10, 10, 3))

        cbaoi_aug = aug.augment_polygons([cbaoi, cbaoi])

        assert len(cbaoi_aug) == 2
        for cbaoi_aug_i in cbaoi_aug:
            assert cbaoi_aug_i.shape == (10, 10, 3)
            assert len(cbaoi_aug_i.items) == 2
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="2038" endline="2060" pcid="3582">
            assert cbaoi_aug_i.shape == (10, 8, 3)
            assert len(cbaoi_aug_i.items) == 2
            assert cbaoi_aug_i.items[0].coords_almost_equals(
                [(4, 2), (8, 2), (8, 6), (4, 6)])
            assert cbaoi_aug_i.items[1].coords_almost_equals(
                [(5, 3), (9, 3), (9, 7), (5, 7)])

    def test_pad_line_strings_by_tuple_of_fixed_ints_with_keep_size(self):
        aug = iaa.Pad((2, 0, 4, 4), keep_size=True)
        lss = [ia.LineString([(0, 0), (4, 0), (4, 4), (0, 4)]),
               ia.LineString([(1, 1), (5, 1), (5, 5), (1, 5)])]
        cbaoi = ia.LineStringsOnImage(lss, shape=(4, 4, 3))
        cbaoi_aug = aug.augment_line_strings([cbaoi, cbaoi])
        assert len(cbaoi_aug) == 2
        for cbaoi_aug_i in cbaoi_aug:
            assert cbaoi_aug_i.shape == (4, 4, 3)
            assert len(cbaoi_aug_i.items) == 2
            assert cbaoi_aug_i.items[0].coords_almost_equals(
                [(4*(4/8), 4*(2/10)),
                 (4*(8/8), 4*(2/10)),
                 (4*(8/8), 4*(6/10)),
                 (4*(4/8), 4*(6/10))]
            )
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="3299" endline="3323" pcid="3655">
        assert len(cbaoi_aug) == 2
        for cbaoi_aug_i in cbaoi_aug:
            assert cbaoi_aug_i.shape == (5, 6, 3)
            assert len(cbaoi_aug_i.items) == 2
            assert cbaoi_aug_i.items[0].coords_almost_equals(
                [(0-4, 0-1), (4-4, 0-1), (4-4, 4-1), (0-4, 4-1)]
            )
            assert cbaoi_aug_i.items[1].coords_almost_equals(
                [(1-4, 1-1), (5-4, 1-1), (5-4, 5-1), (1-4, 5-1)]
            )

    def test_crop_line_strings_by_fixed_ints_with_keep_size(self):
        aug = iaa.Crop((1, 0, 4, 4), keep_size=True)
        lss = [ia.LineString([(0, 0), (4, 0), (4, 4), (0, 4)]),
               ia.LineString([(1, 1), (5, 1), (5, 5), (1, 5)])]
        cbaoi = ia.LineStringsOnImage(lss, shape=(10, 10, 3))

        cbaoi_aug = aug.augment_line_strings([cbaoi, cbaoi])

        assert len(cbaoi_aug) == 2
        for cbaoi_aug_i in cbaoi_aug:
            assert cbaoi_aug_i.shape == (10, 10, 3)
            assert len(cbaoi_aug_i.items) == 2
            assert cbaoi_aug_i.items[0].coords_almost_equals(
                [(10*(-4/6), 10*(-1/5)),
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="2576" endline="2600" pcid="3614">
            assert cbaoi_aug_i.items[0].coords_almost_equals(
                [(4, 2), (8, 2), (8, 6), (4, 6)]
            )
            assert cbaoi_aug_i.items[1].coords_almost_equals(
                [(5, 3), (9, 3), (9, 7), (5, 7)]
            )

    def test_pad_line_strings_by_floats_with_keep_size(self):
        # polygons, with keep_size=True
        aug = iaa.Pad(percent=(0.5, 0, 1.0, 1.0), keep_size=True)
        cbaoi = ia.LineStringsOnImage([
            ia.LineString([(0, 0), (4, 0), (4, 4), (0, 4)]),
            ia.LineString([(1, 1), (5, 1), (5, 5), (1, 5)])
        ], shape=(4, 4, 3))
        cbaoi_aug = aug.augment_line_strings([cbaoi, cbaoi])
        assert len(cbaoi_aug) == 2
        for cbaoi_aug_i in cbaoi_aug:
            assert cbaoi_aug_i.shape == (4, 4, 3)
            assert len(cbaoi_aug_i.items) == 2
            assert cbaoi_aug_i.items[0].coords_almost_equals(
                [(4*(4/8), 4*(2/10)),
                 (4*(8/8), 4*(2/10)),
                 (4*(8/8), 4*(6/10)),
                 (4*(4/8), 4*(6/10))]
            )
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="3255" endline="3279" pcid="3653">
        assert len(cbaoi_aug) == 2
        for cbaoi_aug_i in cbaoi_aug:
            assert cbaoi_aug_i.shape == (5, 6, 3)
            assert len(cbaoi_aug_i.items) == 2
            assert cbaoi_aug_i.items[0].coords_almost_equals(
                [(0-4, 0-1), (4-4, 0-1), (4-4, 4-1), (0-4, 4-1)]
            )
            assert cbaoi_aug_i.items[1].coords_almost_equals(
                [(1-4, 1-1), (5-4, 1-1), (5-4, 5-1), (1-4, 5-1)]
            )

    def test_crop_polygons_by_fixed_ints_with_keep_size(self):
        aug = iaa.Crop((1, 0, 4, 4), keep_size=True)
        polygons = [ia.Polygon([(0, 0), (4, 0), (4, 4), (0, 4)]),
                    ia.Polygon([(1, 1), (5, 1), (5, 5), (1, 5)])]
        cbaoi = ia.PolygonsOnImage(polygons, shape=(10, 10, 3))

        cbaoi_aug = aug.augment_polygons([cbaoi, cbaoi])

        assert len(cbaoi_aug) == 2
        for cbaoi_aug_i in cbaoi_aug:
            assert cbaoi_aug_i.shape == (10, 10, 3)
            assert len(cbaoi_aug_i.items) == 2
            assert cbaoi_aug_i.items[0].coords_almost_equals(
                [(10*(-4/6), 10*(-1/5)),
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="2533" endline="2557" pcid="3612">
            assert cbaoi_aug_i.items[0].coords_almost_equals(
                [(4, 2), (8, 2), (8, 6), (4, 6)]
            )
            assert cbaoi_aug_i.items[1].coords_almost_equals(
                [(5, 3), (9, 3), (9, 7), (5, 7)]
            )

    def test_pad_polygons_by_floats_with_keep_size(self):
        # polygons, with keep_size=True
        aug = iaa.Pad(percent=(0.5, 0, 1.0, 1.0), keep_size=True)
        cbaoi = ia.PolygonsOnImage([
            ia.Polygon([(0, 0), (4, 0), (4, 4), (0, 4)]),
            ia.Polygon([(1, 1), (5, 1), (5, 5), (1, 5)])
        ], shape=(4, 4, 3))
        cbaoi_aug = aug.augment_polygons([cbaoi, cbaoi])
        assert len(cbaoi_aug) == 2
        for cbaoi_aug_i in cbaoi_aug:
            assert cbaoi_aug_i.shape == (4, 4, 3)
            assert len(cbaoi_aug_i.items) == 2
            assert cbaoi_aug_i.items[0].coords_almost_equals(
                [(4*(4/8), 4*(2/10)),
                 (4*(8/8), 4*(2/10)),
                 (4*(8/8), 4*(6/10)),
                 (4*(4/8), 4*(6/10))]
            )
</source>
</class>

<class classid="193" nclones="3" nlines="18" similarity="77">
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="2095" endline="2117" pcid="3585">
            assert bbsoi_aug_i.bounding_boxes[0].coords_almost_equals(
                [(4*((4+0)/8), 4*((2+0)/10)), (4*((4+4)/8), 4*((2+4)/10))]
            )
            assert bbsoi_aug_i.bounding_boxes[1].coords_almost_equals(
                [(4*((4+1)/8), 4*((2+1)/10)), (4*((4+3)/8), 4*((2+4)/10))]
            )

    def test_pad_mode_is_stochastic_parameter(self):
        aug = iaa.Pad(px=(0, 1, 0, 0),
                      pad_mode=iap.Choice(["constant", "maximum", "edge"]),
                      pad_cval=0,
                      keep_size=False)

        image = np.zeros((1, 2), dtype=np.uint8)
        image[0, 0] = 100
        image[0, 1] = 50

        seen = [0, 0, 0]
        for _ in sm.xrange(300):
            observed = aug.augment_image(image)
            if observed[0, 2] == 0:
                seen[0] += 1
            elif observed[0, 2] == 100:
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="2183" endline="2203" pcid="3591">
                seen[0] += 1
            elif observed[0, 1] == 100:
                seen[1] += 1
            else:
                assert False
        assert np.all([100 - 50 < v < 100 + 50 for v in seen])

    def test_pad_cval_is_tuple(self):
        aug = iaa.Pad(px=(0, 1, 0, 0),
                      pad_mode="constant",
                      pad_cval=(50, 52),
                      keep_size=False)
        image = np.zeros((1, 1), dtype=np.uint8)

        seen = [0, 0, 0]
        for _ in sm.xrange(300):
            observed = aug.augment_image(image)

            if observed[0, 1] == 50:
                seen[0] += 1
            elif observed[0, 1] == 51:
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="2166" endline="2182" pcid="3590">
                      pad_cval=100,
                      keep_size=False)
        image = np.zeros((1, 1), dtype=np.uint8)
        observed = aug.augment_image(image)
        assert observed[0, 0] == 0
        assert observed[0, 1] == 100

    def test_pad_cval_is_stochastic_parameter(self):
        aug = iaa.Pad(px=(0, 1, 0, 0),
                      pad_mode="constant",
                      pad_cval=iap.Choice([50, 100]),
                      keep_size=False)
        image = np.zeros((1, 1), dtype=np.uint8)
        seen = [0, 0]
        for _ in sm.xrange(200):
            observed = aug.augment_image(image)
            if observed[0, 1] == 50:
</source>
</class>

<class classid="194" nclones="2" nlines="11" similarity="81">
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="2118" endline="2129" pcid="3586">
                seen[1] += 1
            elif observed[0, 2] == 50:
                seen[2] += 1
            else:
                assert False
        assert np.all([100 - 50 < v < 100 + 50 for v in seen])

    def test_bad_datatype_for_pad_mode_causes_failure(self):
        got_exception = False
        try:
            _aug = iaa.Pad(px=(0, 1, 0, 0),
                           pad_mode=False,
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="2204" endline="2215" pcid="3592">
                seen[1] += 1
            elif observed[0, 1] == 52:
                seen[2] += 1
            else:
                assert False
        assert np.all([100 - 50 < v < 100 + 50 for v in seen])

    def test_invalid_pad_cval_datatype_leads_to_failure(self):
        got_exception = False
        try:
            _aug = iaa.Pad(px=(0, 1, 0, 0),
                           pad_mode="constant",
</source>
</class>

<class classid="195" nclones="2" nlines="16" similarity="81">
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="2671" endline="2687" pcid="3619">
            n_padded = 0
            while np.all(observed[:, -1] == 0):
                n_padded += 1
                observed = observed[:, 0:-1]
            seen[n_padded] += 1
        assert np.all([v > 30 for v in seen])

    def test_pad_by_list_of_floats_at_top_side_without_keep_size(self):
        aug = iaa.Pad(percent=([0.0, 1.0], 0, 0, 0), keep_size=False)
        seen = [0, 0, 0, 0, 0]
        for _ in sm.xrange(500):
            observed = aug.augment_image(
                np.zeros((4, 4), dtype=np.uint8) + 255)
            n_padded = 0
            while np.all(observed[0, :] == 0):
                n_padded += 1
                observed = observed[1:, :]
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="2688" endline="2704" pcid="3620">
            seen[n_padded] += 1
        assert 250 - 50 < seen[0] < 250 + 50
        assert seen[1] == 0
        assert seen[2] == 0
        assert seen[3] == 0
        assert 250 - 50 < seen[4] < 250 + 50

    def test_pad_by_list_of_floats_at_right_side_without_keep_size(self):
        aug = iaa.Pad(percent=(0, [0.0, 1.0], 0, 0), keep_size=False)
        seen = [0, 0, 0, 0, 0]
        for _ in sm.xrange(500):
            observed = aug.augment_image(
                np.zeros((4, 4), dtype=np.uint8) + 255)
            n_padded = 0
            while np.all(observed[:, -1] == 0):
                n_padded += 1
                observed = observed[:, 0:-1]
</source>
</class>

<class classid="196" nclones="4" nlines="11" similarity="90">
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="2777" endline="2790" pcid="3628">
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.Pad(px=1, keep_size=True)

                image_aug = aug(image=image)

                assert image_aug.shape == image.shape

    def test_pad_other_dtypes_bool_by_int_without_keep_size(self):
        aug = iaa.Pad(px=(1, 0, 0, 0), keep_size=False)
        mask = np.zeros((4, 3), dtype=bool)
        mask[2, 1] = True
        image = np.zeros((3, 3), dtype=bool)
        image[1, 1] = True

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="4560" endline="4573" pcid="3741">
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.PadToFixedSize(height=1, width=1)

                image_aug = aug(image=image)

                expected_height = 1
                expected_width = 1
                expected_shape = tuple([expected_height, expected_width]
                                       + list(shape[2:]))
                assert image_aug.shape == expected_shape
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="5198" endline="5211" pcid="3793">
            (0, 2, 1),
            (2, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.CropToFixedSize(height=1, width=1)

                image_aug = aug(image=image)

                expected_height = 0 if shape[0] == 0 else 1
                expected_width = 0 if shape[1] == 0 else 1
                expected_shape = tuple([expected_height, expected_width]
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="3887" endline="3899" pcid="3691">
                with warnings.catch_warnings(record=True) as caught_warnings:
                    image_aug = aug(image=image)

                # we don't check the number of warnings here as it varies by
                # shape
                for warning in caught_warnings:
                    assert (
                        "crop amounts in CropAndPad"
                        in str(warning.message)
                    )

                assert image_aug.shape == image.shape

</source>
</class>

<class classid="197" nclones="4" nlines="28" similarity="75">
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="2791" endline="2824" pcid="3629">
        image_aug = aug.augment_image(image)

        assert image_aug.dtype.name == image.dtype.name
        assert image_aug.shape == (4, 3)
        assert np.all(image_aug[~mask] == 0)
        assert np.all(image_aug[mask] == 1)

    def test_pad_other_dtypes_uint_int_by_int_without_keep_size(self):
        aug = iaa.Pad(px=(1, 0, 0, 0), keep_size=False)

        mask = np.zeros((4, 3), dtype=bool)
        mask[2, 1] = True

        dtypes = ["uint8", "uint16", "uint32", "uint64",
                  "int8", "int16", "int32", "int64"]

        for dtype in dtypes:
            with self.subTest(dtype=dtype):
                min_value, center_value, max_value = \
                    iadt.get_value_range_of_dtype(dtype)

                if np.dtype(dtype).kind == "i":
                    values = [
                        1, 5, 10, 100, int(0.1 * max_value),
                        int(0.2 * max_value), int(0.5 * max_value),
                        max_value - 100, max_value]
                    values = values + [(-1) * value for value in values]
                else:
                    values = [
                        1, 5, 10, 100, int(center_value),
                        int(0.1 * max_value), int(0.2 * max_value),
                        int(0.5 * max_value), max_value - 100, max_value]

                for value in values:
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="3900" endline="3932" pcid="3692">
    def test_other_dtypes_bool(self):
        aug = iaa.Crop(px=(1, 0, 0, 0), keep_size=False)
        mask = np.zeros((2, 3), dtype=bool)
        mask[0, 1] = True

        image = np.zeros((3, 3), dtype=bool)
        image[1, 1] = True
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.name == image.dtype.name
        assert image_aug.shape == (2, 3)
        assert np.all(image_aug[~mask] == 0)
        assert np.all(image_aug[mask] == 1)

    def test_other_dtypes_uint_int(self):
        aug = iaa.Crop(px=(1, 0, 0, 0), keep_size=False)
        mask = np.zeros((2, 3), dtype=bool)
        mask[0, 1] = True

        dtypes = ["uint8", "uint16", "uint32", "uint64",
                  "int8", "int16", "int32", "int64"]

        for dtype in dtypes:
            with self.subTest(dtype=dtype):
                min_value, center_value, max_value = \
                    iadt.get_value_range_of_dtype(dtype)

                if np.dtype(dtype).kind == "i":
                    values = [
                        1, 5, 10, 100, int(0.1 * max_value),
                        int(0.2 * max_value), int(0.5 * max_value),
                        max_value - 100, max_value]
                    values = values + [(-1) * value for value in values]
                else:
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="5212" endline="5245" pcid="3794">
                                       + list(shape[2:]))
                assert image_aug.shape == expected_shape

    def test_other_dtypes_bool(self):
        aug = iaa.CropToFixedSize(height=2, width=3, position="center-top")
        mask = np.zeros((2, 3), dtype=bool)
        mask[0, 1] = True
        image = np.zeros((3, 3), dtype=bool)
        image[1, 1] = True

        image_aug = aug.augment_image(image)

        assert image_aug.dtype.name == image.dtype.name
        assert image_aug.shape == (2, 3)
        assert np.all(image_aug[~mask] == 0)
        assert np.all(image_aug[mask] == 1)

    def test_other_dtypes_uint_int(self):
        aug = iaa.CropToFixedSize(height=2, width=3, position="center-top")
        mask = np.zeros((2, 3), dtype=bool)
        mask[0, 1] = True

        dtypes = ["uint8", "uint16", "uint32", "uint64",
                  "int8", "int16", "int32", "int64"]

        for dtype in dtypes:
            min_value, center_value, max_value = \
                iadt.get_value_range_of_dtype(dtype)

            if np.dtype(dtype).kind == "i":
                values = [
                    1, 5, 10, 100, int(0.1 * max_value), int(0.2 * max_value),
                    int(0.5 * max_value), max_value - 100, max_value]
                values = values + [(-1) * value for value in values]
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="4574" endline="4608" pcid="3742">

    def test_other_dtypes_bool(self):
        aug = iaa.PadToFixedSize(height=4, width=3, position="center-top")
        mask = np.zeros((4, 3), dtype=bool)
        mask[2, 1] = True
        image = np.zeros((3, 3), dtype=bool)
        image[1, 1] = True

        image_aug = aug.augment_image(image)

        assert image_aug.dtype.name == image.dtype.name
        assert image_aug.shape == (4, 3)
        assert np.all(image_aug[~mask] == 0)
        assert np.all(image_aug[mask] == 1)

    def test_other_dtypes_uint_int(self):
        aug = iaa.PadToFixedSize(height=4, width=3, position="center-top")
        dtypes = ["uint8", "uint16", "uint32", "uint64",
                  "int8", "int16", "int32", "int64"]

        mask = np.zeros((4, 3), dtype=bool)
        mask[2, 1] = True

        for dtype in dtypes:
            min_value, center_value, max_value = \
                iadt.get_value_range_of_dtype(dtype)

            if np.dtype(dtype).kind == "i":
                values = [
                    1, 5, 10, 100, int(0.1 * max_value),
                    int(0.2 * max_value), int(0.5 * max_value),
                    max_value - 100, max_value]
                values = values + [(-1) * value for value in values]
            else:
                values = [
</source>
</class>

<class classid="198" nclones="2" nlines="14" similarity="71">
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="3121" endline="3142" pcid="3646">

                    observed = aug.augment_keypoints(self.kpsoi)
                    assert any([keypoints_equal(observed, kp)
                                for kp
                                in keypoints_cropped])

                assert len(set(movements)) == 2
                assert len(set(movements_det)) == 1

    def test_crop_heatmaps_smaller_than_img_by_fixed_ints_without_ks(self):
        # crop smaller heatmaps
        # heatmap is (6, 8), image is (6, 16)
        # image is cropped by (1, 4, 1, 4)
        # expected image size: (4, 8)
        # expected heatmap size: (4, 4)
        aug = iaa.Crop(px=(1, 4, 1, 4), keep_size=False)
        heatmaps_arr_small = np.zeros((6, 8), dtype=np.float32)
        heatmaps_arr_small[1:-1, 1:-1] = 1.0
        heatmaps = HeatmapsOnImage(heatmaps_arr_small, shape=(6, 16))
        top, bottom, left, right = 1, 1, 2, 2
        heatmaps_arr_small_cropped = \
            heatmaps_arr_small[top:-bottom, left:-right]
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="3486" endline="3506" pcid="3668">
        self._test_crop_cba_by_fixed_float_on_each_side_on_its_own(
            "augment_line_strings", lsoi)

    def test_crop_bounding_boxes_by_fixed_float_on_each_side_on_its_own(self):
        height, width = (50, 50)
        bbs = [ia.BoundingBox(x1=0, y1=0, x2=40, y2=40),
               ia.BoundingBox(x1=10, y1=10, x2=30, y2=40)]
        bbsoi = ia.BoundingBoxesOnImage(bbs, shape=(height, width, 3))
        self._test_crop_cba_by_fixed_float_on_each_side_on_its_own(
            "augment_bounding_boxes", bbsoi)

    def test_crop_heatmaps_smaller_than_img_by_fixed_floats_without_ks(self):
        # crop smaller heatmaps
        # heatmap is (8, 12), image is (16, 32)
        # image is cropped by (0.25, 0.25, 0.25, 0.25)
        # expected image size: (8, 16)
        # expected heatmap size: (4, 6)
        aug = iaa.Crop(percent=(0.25, 0.25, 0.25, 0.25), keep_size=False)
        heatmaps_arr_small = np.zeros((8, 12), dtype=np.float32)
        heatmaps_arr_small[2:-2, 4:-4] = 1.0
        heatmaps = ia.HeatmapsOnImage(heatmaps_arr_small, shape=(16, 32))
</source>
</class>

<class classid="199" nclones="2" nlines="11" similarity="90">
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="3143" endline="3156" pcid="3647">

        observed = aug.augment_heatmaps([heatmaps])[0]

        assert observed.shape == (4, 8)
        assert observed.arr_0to1.shape == (4, 4, 1)
        assert 0 - 1e-6 < observed.min_value < 0 + 1e-6
        assert 1 - 1e-6 < observed.max_value < 1 + 1e-6
        assert np.allclose(observed.arr_0to1[..., 0],
                           heatmaps_arr_small_cropped)

    def test_crop_segmaps_smaller_than_img_by_fixed_ints_without_ks(self):
        aug = iaa.Crop(px=(1, 4, 1, 4), keep_size=False)
        segmaps_arr_small = np.zeros((6, 8), dtype=np.int32)
        segmaps_arr_small[1:-1, 1:-1] = 1
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="3507" endline="3520" pcid="3669">
        top, bottom, left, right = 2, 2, 3, 3
        heatmaps_arr_small_cropped = \
            heatmaps_arr_small[top:-bottom, left:-right]

        observed = aug.augment_heatmaps([heatmaps])[0]

        assert observed.shape == (8, 16)
        assert observed.arr_0to1.shape == (4, 6, 1)
        assert 0 - 1e-6 < observed.min_value < 0 + 1e-6
        assert 1 - 1e-6 < observed.max_value < 1 + 1e-6
        assert np.allclose(observed.arr_0to1[..., 0], heatmaps_arr_small_cropped)

    def test_crop_segmaps_smaller_than_img_by_fixed_floats_without_ks(self):
        aug = iaa.Crop(percent=(0.25, 0.25, 0.25, 0.25), keep_size=False)
</source>
</class>

<class classid="200" nclones="4" nlines="19" similarity="71">
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="3157" endline="3187" pcid="3648">
        segmaps = SegmentationMapsOnImage(segmaps_arr_small, shape=(6, 16))
        top, bottom, left, right = 1, 1, 2, 2
        segmaps_arr_small_cropped = segmaps_arr_small[top:-bottom, left:-right]

        observed = aug.augment_segmentation_maps([segmaps])[0]

        assert observed.shape == (4, 8)
        assert observed.arr.shape == (4, 4, 1)
        assert np.array_equal(observed.arr[..., 0], segmaps_arr_small_cropped)

    def test_crop_heatmaps_smaller_than_img_by_fixed_ints_with_ks(self):
        # crop smaller heatmaps, with keep_size=True
        # heatmap is (6, 8), image is (6, 16)
        # image is cropped by (1, 4, 1, 4)
        # expected image size: (4, 8) -> (6, 16) after resize
        # expected heatmap size: (4, 4) -> (6, 4) after resize
        aug = iaa.Crop(px=(1, 4, 1, 4), keep_size=True)
        heatmaps_arr_small = np.zeros((6, 8), dtype=np.float32)
        heatmaps_arr_small[1:-1, 1:-1] = 1.0
        heatmaps = HeatmapsOnImage(heatmaps_arr_small, shape=(6, 16))
        top, bottom, left, right = 1, 1, 2, 2
        heatmaps_arr_small_cropped = \
            heatmaps_arr_small[top:-bottom, left:-right]

        observed = aug.augment_heatmaps([heatmaps])[0]

        assert observed.shape == (6, 16)
        assert observed.arr_0to1.shape == (6, 8, 1)
        assert 0 - 1e-6 < observed.min_value < 0 + 1e-6
        assert 1 - 1e-6 < observed.max_value < 1 + 1e-6
        assert np.allclose(
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="3521" endline="3551" pcid="3670">
        segmaps_arr_small = np.zeros((8, 12), dtype=np.int32)
        segmaps_arr_small[2:-2, 4:-4] = 1
        segmaps = SegmentationMapsOnImage(segmaps_arr_small, shape=(16, 32))
        top, bottom, left, right = 2, 2, 3, 3
        segmaps_arr_small_cropped = segmaps_arr_small[top:-bottom, left:-right]

        observed = aug.augment_segmentation_maps([segmaps])[0]

        assert observed.shape == (8, 16)
        assert observed.arr.shape == (4, 6, 1)
        assert np.array_equal(observed.arr[..., 0], segmaps_arr_small_cropped)

    def test_crop_heatmaps_smaller_than_img_by_fixed_floats_with_ks(self):
        # crop smaller heatmaps, with keep_size=True
        # heatmap is (8, 12), image is (16, 32)
        # image is cropped by (0.25, 0.25, 0.25, 0.25)
        # expected image size: (8, 16) -> (16, 32) after resize
        # expected heatmap size: (4, 6) -> (8, 12) after resize
        aug = iaa.Crop(percent=(0.25, 0.25, 0.25, 0.25), keep_size=True)
        heatmaps_arr_small = np.zeros((8, 12), dtype=np.float32)
        heatmaps_arr_small[2:-2, 4:-4] = 1.0
        heatmaps = ia.HeatmapsOnImage(heatmaps_arr_small, shape=(16, 32))
        top, bottom, left, right = 2, 2, 3, 3
        heatmaps_arr_small_cropped = \
            heatmaps_arr_small[top:-bottom, left:-right]

        observed = aug.augment_heatmaps([heatmaps])[0]

        assert observed.shape == (16, 32)
        assert observed.arr_0to1.shape == (8, 12, 1)
        assert 0 - 1e-6 < observed.min_value < 0 + 1e-6
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="3188" endline="3207" pcid="3649">
            observed.arr_0to1[..., 0],
            np.clip(
                ia.imresize_single_image(
                    heatmaps_arr_small_cropped,
                    (6, 8),
                    interpolation="cubic"),
                0,
                1.0
            )
        )

    def test_crop_segmaps_smaller_than_img_by_fixed_ints_with_ks(self):
        aug = iaa.Crop(px=(1, 4, 1, 4), keep_size=True)
        segmaps_arr_small = np.zeros((6, 8), dtype=np.int32)
        segmaps_arr_small[1:-1, 1:-1] = 1
        segmaps = SegmentationMapsOnImage(segmaps_arr_small, shape=(6, 16))
        top, bottom, left, right = 1, 1, 2, 2
        segmaps_arr_small_cropped = segmaps_arr_small[top:-bottom, left:-right]

        observed = aug.augment_segmentation_maps([segmaps])[0]
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="3552" endline="3571" pcid="3671">
        assert 1 - 1e-6 < observed.max_value < 1 + 1e-6
        assert np.allclose(
            observed.arr_0to1[..., 0],
            np.clip(
                ia.imresize_single_image(
                    heatmaps_arr_small_cropped,
                    (8, 12),
                    interpolation="cubic"),
                0,
                1.0
            )
        )

    def test_crop_segmaps_smaller_than_img_by_fixed_floats_with_ks(self):
        aug = iaa.Crop(percent=(0.25, 0.25, 0.25, 0.25), keep_size=True)
        segmaps_arr_small = np.zeros((8, 12), dtype=np.int32)
        segmaps_arr_small[2:-2, 4:-4] = 1
        segmaps = SegmentationMapsOnImage(segmaps_arr_small, shape=(16, 32))
        top, bottom, left, right = 2, 2, 3, 3
        segmaps_arr_small_cropped = segmaps_arr_small[top:-bottom, left:-right]
</source>
</class>

<class classid="201" nclones="2" nlines="11" similarity="90">
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="3208" endline="3221" pcid="3650">

        assert observed.shape == (6, 16)
        assert observed.arr.shape == (6, 8, 1)
        assert np.array_equal(
            observed.arr[..., 0],
            ia.imresize_single_image(
                segmaps_arr_small_cropped,
                (6, 8),
                interpolation="nearest"),
        )

    def test_crop_keypoints_by_fixed_ints_without_keep_size(self):
        aug = iaa.Crop((1, 0, 4, 4), keep_size=False)
        kps = [ia.Keypoint(x=3, y=6), ia.Keypoint(x=8, y=5)]
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="3572" endline="3585" pcid="3672">

        observed = aug.augment_segmentation_maps([segmaps])[0]

        assert observed.shape == (16, 32)
        assert observed.arr.shape == (8, 12, 1)
        assert np.allclose(
            observed.arr[..., 0],
            ia.imresize_single_image(
                segmaps_arr_small_cropped,
                (8, 12),
                interpolation="nearest")
        )

    def test_crop_keypoints_by_fixed_floats_without_keep_size(self):
</source>
</class>

<class classid="202" nclones="2" nlines="11" similarity="90">
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="3222" endline="3235" pcid="3651">
        kpsoi = ia.KeypointsOnImage(kps, shape=(14, 14, 3))

        kpsoi_aug = aug.augment_keypoints([kpsoi])[0]

        assert kpsoi_aug.shape == (9, 10, 3)
        assert len(kpsoi_aug.keypoints) == 2
        assert np.allclose(kpsoi_aug.keypoints[0].x, 3-4)
        assert np.allclose(kpsoi_aug.keypoints[0].y, 6-1)
        assert np.allclose(kpsoi_aug.keypoints[1].x, 8-4)
        assert np.allclose(kpsoi_aug.keypoints[1].y, 5-1)

    def test_crop_keypoints_by_fixed_ints_with_keep_size(self):
        aug = iaa.Crop((1, 0, 4, 4), keep_size=True)
        kps = [ia.Keypoint(x=3, y=6), ia.Keypoint(x=8, y=5)]
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="3586" endline="3599" pcid="3673">
        aug = iaa.Crop(percent=(0.25, 0, 0.5, 0.1), keep_size=False)
        kps = [ia.Keypoint(x=12, y=10), ia.Keypoint(x=8, y=12)]
        kpsoi = ia.KeypointsOnImage(kps, shape=(16, 20, 3))

        kpsoi_aug = aug.augment_keypoints([kpsoi])[0]

        assert kpsoi_aug.shape == (4, 18, 3)
        assert len(kpsoi_aug.keypoints) == 2
        assert np.allclose(kpsoi_aug.keypoints[0].x, 12-2)
        assert np.allclose(kpsoi_aug.keypoints[0].y, 10-4)
        assert np.allclose(kpsoi_aug.keypoints[1].x, 8-2)
        assert np.allclose(kpsoi_aug.keypoints[1].y, 12-4)

    def test_crop_keypoints_by_fixed_floats_with_keep_size(self):
</source>
</class>

<class classid="203" nclones="2" nlines="13" similarity="92">
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="3753" endline="3766" pcid="3682">
        # range [0.125, 0.375].
        assert np.all([v > 30 for v in seen])

    def test_crop_by_tuple_of_floats_on_right_side_without_ks(self):
        aug = iaa.Crop(percent=(0, (0, 0.1), 0, 0), keep_size=False)
        image = np.zeros((40, 40), dtype=np.uint8) + 255
        seen = [0, 0, 0, 0, 0]
        for _ in sm.xrange(500):
            observed = aug.augment_image(image)
            n_cropped = 40 - observed.shape[1]
            seen[n_cropped] += 1
        assert np.all([v > 30 for v in seen])

    def test_crop_by_list_of_floats_on_top_side_without_ks(self):
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="3767" endline="3780" pcid="3683">
        aug = iaa.Crop(percent=([0.0, 0.1], 0, 0, 0), keep_size=False)
        image = np.zeros((40, 40), dtype=np.uint8) + 255
        seen = [0, 0, 0, 0, 0]
        for _ in sm.xrange(500):
            observed = aug.augment_image(image)
            n_cropped = 40 - observed.shape[0]
            seen[n_cropped] += 1
        assert 250 - 50 < seen[0] < 250 + 50
        assert seen[1] == 0
        assert seen[2] == 0
        assert seen[3] == 0
        assert 250 - 50 < seen[4] < 250 + 50

    def test_crop_by_list_of_floats_on_right_side_without_ks(self):
</source>
</class>

<class classid="204" nclones="3" nlines="13" similarity="92">
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="4095" endline="4110" pcid="3708">
            [150, 200]
        ])

        observed = aug.augment_image(img2x2)

        expected = np.uint8([
            [50, 50, 100, 100],
            [50, 50, 100, 100],
            [150, 150, 200, 200],
            [150, 150, 200, 200]
        ])
        assert observed.dtype.name == "uint8"
        assert observed.shape == (4, 4)
        assert np.array_equal(observed, expected)

    def test_image_pad_at_left_top(self):
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="4111" endline="4127" pcid="3709">
        # explicit non-center position test
        aug = iaa.PadToFixedSize(
            height=3, width=3, pad_mode="constant", pad_cval=128,
            position="left-top")
        img1x1 = np.uint8([[255]])
        observed = aug.augment_image(img1x1)
        expected = np.uint8([
            [128, 128, 128],
            [128, 128, 128],
            [128, 128, 255]
        ])
        assert observed.dtype.name == "uint8"
        assert observed.shape == (3, 3)
        assert np.array_equal(observed, expected)

    def test_image_pad_at_right_bottom(self):
        aug = iaa.PadToFixedSize(
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="4128" endline="4144" pcid="3710">
            height=3, width=3, pad_mode="constant", pad_cval=128,
            position="right-bottom")
        img1x1 = np.uint8([[255]])

        observed = aug.augment_image(img1x1)

        expected = np.uint8([
            [255, 128, 128],
            [128, 128, 128],
            [128, 128, 128]
        ])
        assert observed.dtype.name == "uint8"
        assert observed.shape == (3, 3)
        assert np.array_equal(observed, expected)

    def test_image_pad_at_bottom_center_given_as_tuple_of_floats(self):
        aug = iaa.PadToFixedSize(
</source>
</class>

<class classid="205" nclones="5" nlines="11" similarity="90">
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="4372" endline="4386" pcid="3729">

        expected = ia.LineStringsOnImage([
            ia.LineString([(0, 0), (3, 0), (3, 3)])
        ], shape=(4, 4))
        assert_cbaois_equal(observed, expected)

    def test_line_strings_empty(self):
        aug = iaa.PadToFixedSize(height=5, width=6)
        cbaoi = ia.LineStringsOnImage([], shape=(3, 3))

        observed = aug.augment_line_strings(cbaoi)

        expected = ia.LineStringsOnImage([], shape=(5, 6))
        assert_cbaois_equal(observed, expected)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="4403" endline="4416" pcid="3731">
        aug = iaa.PadToFixedSize(
            height=4, width=4, pad_mode="edge", position="center")
        bbsoi = ia.BoundingBoxesOnImage([
            ia.BoundingBox(x1=0, y1=1, x2=2, y2=3),
        ], shape=(3, 3))

        observed = aug.augment_bounding_boxes(bbsoi)

        # aug adds a columns at the right and row at the bottom,
        # i.e. BB is not affected
        expected = ia.BoundingBoxesOnImage([
            ia.BoundingBox(x1=0, y1=1, x2=2, y2=3),
        ], shape=(4, 4))
        assert_cbaois_equal(observed, expected)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="4432" endline="4445" pcid="3733">
    def test_bounding_boxes_pad_at_left_top(self):
        # bounding boxes test with explicit non-center position
        aug = iaa.PadToFixedSize(
            height=4, width=4, pad_mode="edge", position="left-top")
        bbsoi = ia.BoundingBoxesOnImage([
            ia.BoundingBox(x1=0, y1=1, x2=2, y2=3),
        ], shape=(3, 3))

        observed = aug.augment_bounding_boxes(bbsoi)

        expected = ia.BoundingBoxesOnImage([
            ia.BoundingBox(x1=0+1, y1=1+1, x2=2+1, y2=3+1),
        ], shape=(4, 4))
        assert_cbaois_equal(observed, expected)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="4417" endline="4431" pcid="3732">

    def test_bounding_boxes_pad_at_center__2px(self):
        aug = iaa.PadToFixedSize(
            height=5, width=5, pad_mode="edge", position="center")
        bbsoi = ia.BoundingBoxesOnImage([
            ia.BoundingBox(x1=0, y1=1, x2=2, y2=3),
        ], shape=(3, 3))

        observed = aug.augment_bounding_boxes(bbsoi)

        expected = ia.BoundingBoxesOnImage([
            ia.BoundingBox(x1=0+1, y1=1+1, x2=2+1, y2=3+1),
        ], shape=(5, 5))
        assert_cbaois_equal(observed, expected)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="4387" endline="4402" pcid="3730">
    def test_bounding_boxes__image_already_fullfills_min_shape(self):
        # bounding boxes test with shape not being changed
        aug = iaa.PadToFixedSize(
            height=3, width=3, pad_mode="edge", position="center")
        bbsoi = ia.BoundingBoxesOnImage([
            ia.BoundingBox(x1=0, y1=1, x2=2, y2=3),
        ], shape=(3, 3))

        observed = aug.augment_bounding_boxes(bbsoi)

        expected = ia.BoundingBoxesOnImage([
            ia.BoundingBox(x1=0, y1=1, x2=2, y2=3),
        ], shape=(3, 3))
        assert_cbaois_equal(observed, expected)

    def test_bounding_boxes_pad_at_center(self):
</source>
</class>

<class classid="206" nclones="2" nlines="13" similarity="76">
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="4455" endline="4473" pcid="3735">

        expected = ia.BoundingBoxesOnImage([
            ia.BoundingBox(x1=0, y1=1, x2=2, y2=3),
        ], shape=(4, 4))
        assert_cbaois_equal(observed, expected)

    def test_bounding_boxes_empty(self):
        aug = iaa.PadToFixedSize(height=5, width=6)
        bbsoi = ia.BoundingBoxesOnImage([], shape=(3, 3))

        observed = aug.augment_bounding_boxes(bbsoi)

        expected = ia.BoundingBoxesOnImage([], shape=(5, 6))
        assert_cbaois_equal(observed, expected)

    def test_heatmaps__pad_mode_should_be_ignored(self):
        # basic heatmaps test
        # pad_mode should be ignored for heatmaps
        aug = iaa.PadToFixedSize(
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="4490" endline="4508" pcid="3737">
        # heatmaps with size unequal to image
        # pad_mode should be ignored for heatmaps
        aug = iaa.PadToFixedSize(
            height=32, width=32, pad_mode="edge", position="left-top")
        heatmaps_arr = np.zeros((15, 15, 1), dtype=np.float32) + 1.0
        heatmaps = ia.HeatmapsOnImage(heatmaps_arr, shape=(30, 30, 3))

        observed = aug.augment_heatmaps([heatmaps])[0]

        expected = np.zeros((16, 16, 1), dtype=np.float32) + 1.0
        expected[:, 0, 0] = 0.0
        expected[0, :, 0] = 0.0
        assert observed.shape == (32, 32, 3)
        assert np.allclose(observed.arr_0to1, expected)

    def test_segmaps__pad_mode_should_be_ignored(self):
        # basic segmaps test
        # pad_mode should be ignored for segmaps
        aug = iaa.PadToFixedSize(
</source>
</class>

<class classid="207" nclones="4" nlines="11" similarity="72">
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="4525" endline="4535" pcid="3739">
        # segmaps with size unequal to image
        # pad_mode should be ignored for segmaps
        aug = iaa.PadToFixedSize(
            height=32, width=32, pad_mode="edge", position="left-top")
        segmaps_arr = np.ones((15, 15, 1), dtype=np.int32)
        segmaps = SegmentationMapsOnImage(segmaps_arr, shape=(30, 30, 3))

        observed = aug.augment_segmentation_maps([segmaps])[0]

        expected = np.ones((16, 16, 1), dtype=np.int32)
        expected[:, 0, 0] = 0
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="5620" endline="5633" pcid="3835">
                                   position="center")

        observed = aug(heatmaps=heatmap)

        expected = heatmap.pad(top=25, bottom=25, left=25, right=25)
        assert observed.shape == (200, 200, 3)
        assert np.allclose(observed.arr_0to1, expected.arr_0to1)

    def test_keypoints(self):
        kps = [ia.Keypoint(x=2, y=3)]
        kpsoi = ia.KeypointsOnImage(kps, shape=(8, 4, 3))
        aug = iaa.PadToMultiplesOf(height_multiple=5, width_multiple=2,
                                   position="center")

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="6012" endline="6025" pcid="3874">
                                position="center")

        observed = aug(heatmaps=heatmap)

        expected = heatmap.pad(top=25, bottom=25, left=25, right=25)
        assert observed.shape == (200, 200, 3)
        assert np.allclose(observed.arr_0to1, expected.arr_0to1)

    def test_keypoints(self):
        kps = [ia.Keypoint(x=2, y=3)]
        kpsoi = ia.KeypointsOnImage(kps, shape=(14, 4, 3))
        aug = iaa.PadToPowersOf(height_base=4, width_base=2,
                                position="center")

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="6332" endline="6344" pcid="3908">
        heatmap = ia.HeatmapsOnImage(arr, shape=(100, 100, 3))
        aug = iaa.PadToAspectRatio(2.0, position="center")

        observed = aug(heatmaps=heatmap)

        expected = heatmap.pad(top=0, bottom=0, left=25, right=25)
        assert observed.shape == (100, 200, 3)
        assert np.allclose(observed.arr_0to1, expected.arr_0to1)

    def test_keypoints(self):
        kps = [ia.Keypoint(x=2, y=3)]
        kpsoi = ia.KeypointsOnImage(kps, shape=(10, 5, 3))
        aug = iaa.PadToAspectRatio(1.0, position="center")
</source>
</class>

<class classid="208" nclones="2" nlines="11" similarity="75">
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="4681" endline="4694" pcid="3751">
class TestCropToFixedSize(unittest.TestCase):
    def setUp(self):
        reseed()

    def test_image2d_that_needs_to_be_cropped_on_both_sides(self):
        aug = iaa.CropToFixedSize(height=1, width=1)
        image = np.uint8([
            [128, 129, 130],
            [131, 132, 133],
            [134, 135, 136]
        ])

        observed = aug.augment_image(image)

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="4695" endline="4711" pcid="3752">
        assert observed.dtype.name == "uint8"
        assert observed.shape == (1, 1)

    def test_image3d_that_needs_to_be_cropped_on_both_sides(self):
        aug = iaa.CropToFixedSize(height=1, width=1)
        image = np.uint8([
            [128, 129, 130],
            [131, 132, 133],
            [134, 135, 136]
        ])
        image3d = np.atleast_3d(image)

        observed = aug.augment_image(image3d)

        assert observed.dtype.name == "uint8"
        assert observed.shape == (1, 1, 1)

</source>
</class>

<class classid="209" nclones="2" nlines="10" similarity="80">
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="5939" endline="5952" pcid="3868">

        observed = aug(image=image)

        expected = iaa.pad(image, bottom=1)
        assert np.array_equal(observed, expected)

    def test_on_7x22_image(self):
        image = np.mod(
            np.arange((7*22*3)),
            255
        ).astype(np.uint8).reshape((7, 22, 3))
        aug = iaa.PadToPowersOf(height_base=12, width_base=2,
                                position="center")

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="5953" endline="5966" pcid="3869">
        observed = aug(image=image)

        expected = iaa.pad(image, top=2, bottom=3, left=5, right=5)
        assert np.array_equal(observed, expected)

    def test_on_7x22_image__cval(self):
        image = np.mod(
            np.arange((7*22*3)),
            255
        ).astype(np.uint8).reshape((7, 22, 3))
        aug = iaa.PadToPowersOf(height_base=12, width_base=2,
                                pad_cval=100,
                                position="center")

</source>
</class>

<class classid="210" nclones="2" nlines="29" similarity="96">
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="6345" endline="6379" pcid="3909">

        observed = aug(keypoints=kpsoi)

        assert observed.keypoints[0].x == 2+2
        assert observed.keypoints[0].y == 3

    def test_get_parameters(self):
        aug = iaa.PadToAspectRatio(2.0,
                                   pad_cval=5, pad_mode="edge",
                                   position="center")

        params = aug.get_parameters()

        assert np.isclose(params[0], 2.0)
        assert params[1].value == "edge"
        assert params[2].value == 5
        assert np.isclose(params[3][0].value, 0.5)
        assert np.isclose(params[3][1].value, 0.5)

    def test_zero_sized_axes__wider(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1),
            (0, 2),
            (2, 0),
            (0, 2, 0),
            (2, 0, 0),
            (0, 2, 1),
            (2, 0, 1)
        ]
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="6380" endline="6414" pcid="3910">

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.PadToAspectRatio(2.0)

                image_aug = aug(image=image)

                height, width = shape[0:2]
                if width == 0 and height == 0:
                    h_exp, w_exp = (1, 2)
                elif width == 0:
                    h_exp, w_exp = (height, height * 2)
                else:  # height == 0
                    h_exp, w_exp = (1, 2)

                expected_shape = tuple([h_exp, w_exp] + list(shape[2:]))
                assert image_aug.shape == expected_shape

    def test_zero_sized_axes__higher(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1),
            (0, 2),
            (2, 0),
            (0, 2, 0),
            (2, 0, 0),
            (0, 2, 1),
            (2, 0, 1)
        ]
</source>
</class>

<class classid="211" nclones="3" nlines="11" similarity="81">
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="6735" endline="6750" pcid="3945">
        assert np.isclose(kpoi_aug.keypoints[2].y,
                          ((3-1)/3)*4,
                          rtol=0, atol=1e-4)

    def test_keypoints_interpolation_is_no_resize(self):
        aug = iaa.KeepSizeByResize(
            self.children, interpolation=iaa.KeepSizeByResize.NO_RESIZE)
        kpsoi = self.kpsoi

        kpoi_aug = aug.augment_keypoints([kpsoi])[0]

        assert kpoi_aug.shape == (3, 4, 3)
        assert np.isclose(kpoi_aug.keypoints[0].x, 0, rtol=0, atol=1e-4)
        assert np.isclose(kpoi_aug.keypoints[0].y, 0, rtol=0, atol=1e-4)
        assert np.isclose(kpoi_aug.keypoints[1].x, 1, rtol=0, atol=1e-4)
        assert np.isclose(kpoi_aug.keypoints[1].y, 0, rtol=0, atol=1e-4)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="6801" endline="6815" pcid="3949">
        )

    def test_line_strings_interpolation_is_no_resize(self):
        aug = iaa.KeepSizeByResize(
            self.children, interpolation=iaa.KeepSizeByResize.NO_RESIZE)
        cbaoi = ia.LineStringsOnImage([
            ia.LineString([(0, 0), (3, 0), (3, 3)])
        ], shape=(4, 4, 3))

        cbaoi_aug = aug.augment_line_strings(cbaoi)

        assert cbaoi_aug.shape == (3, 4, 3)
        assert np.allclose(
            cbaoi_aug.items[0].coords,
            [(0, 0-1),
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="6768" endline="6783" pcid="3947">
        )

    def test_polygons_interpolation_is_no_resize(self):
        aug = iaa.KeepSizeByResize(
            self.children, interpolation=iaa.KeepSizeByResize.NO_RESIZE)
        cbaoi = ia.PolygonsOnImage([
            ia.Polygon([(0, 0), (3, 0), (3, 3)])
        ], shape=(4, 4, 3))

        cbaoi_aug = aug.augment_polygons(cbaoi)

        assert cbaoi_aug.shape == (3, 4, 3)
        assert np.allclose(
            cbaoi_aug.items[0].coords,
            [(0, 0-1),
             (3, 0-1),
</source>
</class>

<class classid="212" nclones="3" nlines="12" similarity="83">
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="6751" endline="6767" pcid="3946">
        assert np.isclose(kpoi_aug.keypoints[2].x, 2, rtol=0, atol=1e-4)
        assert np.isclose(kpoi_aug.keypoints[2].y, 2, rtol=0, atol=1e-4)

    def test_polygons_interpolation_is_cubic(self):
        aug = iaa.KeepSizeByResize(self.children, interpolation="cubic")
        cbaoi = ia.PolygonsOnImage([
            ia.Polygon([(0, 0), (3, 0), (3, 3)])
        ], shape=(4, 4, 3))

        cbaoi_aug = aug.augment_polygons(cbaoi)

        assert cbaoi_aug.shape == (4, 4, 3)
        assert np.allclose(
            cbaoi_aug.items[0].coords,
            [(0, ((0-1)/3)*4),
             (3, ((0-1)/3)*4),
             (3, ((3-1)/3)*4)]
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="6784" endline="6800" pcid="3948">
             (3, 3-1)]
        )

    def test_line_strings_interpolation_is_cubic(self):
        aug = iaa.KeepSizeByResize(self.children, interpolation="cubic")
        cbaoi = ia.LineStringsOnImage([
            ia.LineString([(0, 0), (3, 0), (3, 3)])
        ], shape=(4, 4, 3))

        cbaoi_aug = aug.augment_line_strings(cbaoi)

        assert cbaoi_aug.shape == (4, 4, 3)
        assert np.allclose(
            cbaoi_aug.items[0].coords,
            [(0, ((0-1)/3)*4),
             (3, ((0-1)/3)*4),
             (3, ((3-1)/3)*4)]
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="6816" endline="6831" pcid="3950">
             (3, 0-1),
             (3, 3-1)]
        )

    def test_bounding_boxes_interpolation_is_cubic(self):
        aug = iaa.KeepSizeByResize(self.children, interpolation="cubic")
        bbsoi = ia.BoundingBoxesOnImage([
            ia.BoundingBox(x1=0, y1=1, x2=3, y2=4)
        ], shape=(4, 4, 3))

        bbsoi_aug = aug.augment_bounding_boxes(bbsoi)

        assert bbsoi_aug.shape == (4, 4, 3)
        assert np.allclose(
            bbsoi_aug.bounding_boxes[0].coords,
            [(0, ((1-1)/3)*4),
</source>
</class>

<class classid="213" nclones="4" nlines="10" similarity="70">
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="6832" endline="6846" pcid="3951">
             (3, ((4-1)/3)*4)]
        )

    def test_bounding_boxes_interpolation_is_no_resize(self):
        aug = iaa.KeepSizeByResize(
            self.children, interpolation=iaa.KeepSizeByResize.NO_RESIZE)
        bbsoi = ia.BoundingBoxesOnImage([
            ia.BoundingBox(x1=0, y1=1, x2=3, y2=4)
        ], shape=(4, 4, 3))

        bbsoi_aug = aug.augment_bounding_boxes(bbsoi)

        assert bbsoi_aug.shape == (3, 4, 3)
        assert np.allclose(
            bbsoi_aug.bounding_boxes[0].coords,
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="6904" endline="6916" pcid="3956">
        heatmaps_oi = self.heatmaps
        heatmaps_oi_cubic = self.heatmaps_cubic

        heatmaps_oi_aug = aug.augment_heatmaps([heatmaps_oi])[0]

        assert heatmaps_oi_aug.arr_0to1.shape == (4, 4, 1)
        assert np.allclose(
            heatmaps_oi_aug.arr_0to1, heatmaps_oi_cubic.arr_0to1)

    def test_segmaps_general_interpolation_set_to_cubic(self):
        aug = iaa.KeepSizeByResize(self.children, interpolation="cubic")
        segmaps_oi = self.segmaps
        segmaps_oi_nearest = self.segmaps_nearest
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="6879" endline="6893" pcid="3954">
        assert (
            np.allclose(hmoi_aug.arr_0to1, heatmaps_oi_nearest.arr_0to1)
            or np.allclose(hmoi_aug.arr_0to1, heatmaps_oi_cubic.arr_0to1)
        )

    def test_heatmaps_specific_interpolation_set_to_no_resize(self):
        aug = iaa.KeepSizeByResize(
            self.children,
            interpolation="cubic",
            interpolation_heatmaps=iaa.KeepSizeByResize.NO_RESIZE)

        heatmaps_oi = self.heatmaps

        heatmaps_oi_aug = aug.augment_heatmaps([heatmaps_oi])[0]

</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_size.py" startline="6865" endline="6878" pcid="3953">

    def test_heatmaps_specific_interpolation_set_to_list_of_two(self):
        aug = iaa.KeepSizeByResize(
            self.children,
            interpolation="cubic",
            interpolation_heatmaps=["nearest", "cubic"])

        heatmaps_oi = self.heatmaps
        heatmaps_oi_cubic = self.heatmaps_cubic
        heatmaps_oi_nearest = self.heatmaps_nearest

        hmoi_aug = aug.augment_heatmaps([heatmaps_oi])[0]

        assert hmoi_aug.arr_0to1.shape == (4, 4, 1)
</source>
</class>

<class classid="214" nclones="2" nlines="17" similarity="72">
<source file="systems/imgaug-0.4.0/test/augmenters/test_pillike.py" startline="194" endline="211" pcid="4050">

    def test_unusual_channel_numbers(self):
        nb_channels_lst = [1, 2, 4, 5, 512, 513]
        for nb_channels in nb_channels_lst:
            for size in [20, 100]:
                with self.subTest(nb_channels=nb_channels,
                                  size=size):
                    shape = (size, size, nb_channels)
                    image = iarandom.RNG(0).integers(50, 150, size=shape)
                    image = image.astype(np.uint8)

                    image_aug = iaa.pillike.equalize(image)

                    if size > 1:
                        channelwise_sums = np.sum(image_aug, axis=(0, 1))
                        assert np.all(channelwise_sums > 0)
                    assert np.min(image_aug) < 50
                    assert np.max(image_aug) > 150
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_pillike.py" startline="298" endline="318" pcid="4055">

    def test_unusual_channel_numbers(self):
        nb_channels_lst = [1, 2, 4, 5, 512, 513]
        for nb_channels in nb_channels_lst:
            for size in [20]:
                for cutoff in [0, 1, 10]:
                    with self.subTest(nb_channels=nb_channels,
                                      size=size,
                                      cutoff=cutoff):
                        shape = (size, size, nb_channels)
                        image = iarandom.RNG(0).integers(50, 150, size=shape)
                        image = image.astype(np.uint8)

                        image_aug = iaa.pillike.autocontrast(image,
                                                             cutoff=cutoff)

                        if size > 1:
                            channelwise_sums = np.sum(image_aug, axis=(0, 1))
                            assert np.all(channelwise_sums > 0)
                        assert np.min(image_aug) < 50
                        assert np.max(image_aug) > 150
</source>
</class>

<class classid="215" nclones="7" nlines="10" similarity="72">
<source file="systems/imgaug-0.4.0/test/augmenters/test_pillike.py" startline="709" endline="722" pcid="4124">

    def test_scale_x_by_comparison_with_pil(self):
        def _matrix_gen(scale):
            return np.float32([
                [1/scale, 0, 0],
                [0, 1, 0],
                [0, 0, 1]
            ])

        self._test_aff_by_comparison_with_pil(
            "scale_x",
            [0.01, 0.1, 0.9, 1.0, 1.5, 3.0],
            _matrix_gen
        )
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_pillike.py" startline="751" endline="764" pcid="4130">

    def test_translate_y_by_comparison_with_pil(self):
        def _matrix_gen(translate):
            return np.float32([
                [1, 0, 0],
                [0, 1, -translate],
                [0, 0, 1]
            ])

        self._test_aff_by_comparison_with_pil(
            "translate_y_px",
            [-50, -10, -1, 0, 1, 10, 50],
            _matrix_gen
        )
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_pillike.py" startline="780" endline="794" pcid="4134">

    def test_shear_x_by_comparison_with_pil(self):
        def _matrix_gen(shear):
            s = (-1) * np.deg2rad(shear)
            return np.float32([
                [1, np.tanh(s), 0],
                [0, 1, 0],
                [0, 0, 1]
            ])

        self._test_aff_by_comparison_with_pil(
            "shear_x_deg",
            [-50, -10, -1, 0, 1, 10, 50],
            _matrix_gen
        )
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_pillike.py" startline="737" endline="750" pcid="4128">

    def test_translate_x_by_comparison_with_pil(self):
        def _matrix_gen(translate):
            return np.float32([
                [1, 0, -translate],
                [0, 1, 0],
                [0, 0, 1]
            ])

        self._test_aff_by_comparison_with_pil(
            "translate_x_px",
            [-50, -10, -1, 0, 1, 10, 50],
            _matrix_gen
        )
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_pillike.py" startline="723" endline="736" pcid="4126">

    def test_scale_y_by_comparison_with_pil(self):
        def _matrix_gen(scale):
            return np.float32([
                [1, 0, 0],
                [0, 1/scale, 0],
                [0, 0, 1]
            ])

        self._test_aff_by_comparison_with_pil(
            "scale_y",
            [0.01, 0.1, 0.9, 1.0, 1.5, 3.0],
            _matrix_gen
        )
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_pillike.py" startline="795" endline="809" pcid="4136">

    def test_shear_y_by_comparison_with_pil(self):
        def _matrix_gen(shear):
            s = (-1) * np.deg2rad(shear)
            return np.float32([
                [1, 0, 0],
                [np.tanh(s), 1, 0],
                [0, 0, 1]
            ])

        self._test_aff_by_comparison_with_pil(
            "shear_y_deg",
            [-50, -10, -1, 0, 1, 10, 50],
            _matrix_gen
        )
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_pillike.py" startline="765" endline="779" pcid="4132">

    def test_rotate_by_comparison_with_pil(self):
        def _matrix_gen(rotate):
            r = np.deg2rad(rotate)
            return np.float32([
                [np.cos(r), np.sin(r), 0],
                [-np.sin(r), np.cos(r), 0],
                [0, 0, 1]
            ])

        self._test_aff_by_comparison_with_pil(
            "rotate_deg",
            [-50, -10, -1, 0, 1, 10, 50],
            _matrix_gen
        )
</source>
</class>

<class classid="216" nclones="2" nlines="10" similarity="90">
<source file="systems/imgaug-0.4.0/test/augmenters/test_pillike.py" startline="864" endline="877" pcid="4143">

    def test_shear_x(self):
        image = np.zeros((20, 20, 3), dtype=np.uint8)
        image[5, 10] = 255

        image_aug = iaa.pillike.warp_affine(image,
                                            shear_x_deg=20,
                                            center=(0.0, 0.0))

        y, x = np.unravel_index(np.argmax(image_aug[..., 0]),
                                image_aug.shape[0:2])

        assert y == 5
        assert x > 10
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_pillike.py" startline="878" endline="891" pcid="4144">

    def test_shear_y(self):
        image = np.zeros((20, 20, 3), dtype=np.uint8)
        image[10, 15] = 255

        image_aug = iaa.pillike.warp_affine(image,
                                            shear_y_deg=20,
                                            center=(0.0, 0.0))

        y, x = np.unravel_index(np.argmax(image_aug[..., 0]),
                                image_aug.shape[0:2])

        assert y > 10
        assert x == 15
</source>
</class>

<class classid="217" nclones="4" nlines="10" similarity="100">
<source file="systems/imgaug-0.4.0/test/augmenters/test_pillike.py" startline="1110" endline="1122" pcid="4172">
    @mock.patch("imgaug.augmenters.pillike.enhance_color")
    def test_mocked(self, mock_pilcol):
        aug = iaa.pillike.EnhanceColor(0.75)
        image = np.zeros((1, 1, 3), dtype=np.uint8)
        mock_pilcol.return_value = np.full((1, 1, 3), 128, dtype=np.uint8)

        image_aug = aug(image=image)

        assert mock_pilcol.call_count == 1
        assert ia.is_np_array(mock_pilcol.call_args_list[0][0][0])
        assert np.isclose(mock_pilcol.call_args_list[0][0][1], 0.75, rtol=0,
                          atol=1e-4)
        assert np.all(image_aug == 128)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_pillike.py" startline="1161" endline="1173" pcid="4178">
    @mock.patch("imgaug.augmenters.pillike.enhance_contrast")
    def test_mocked(self, mock_pilco):
        aug = iaa.pillike.EnhanceContrast(0.75)
        image = np.zeros((1, 1, 3), dtype=np.uint8)
        mock_pilco.return_value = np.full((1, 1, 3), 128, dtype=np.uint8)

        image_aug = aug(image=image)

        assert mock_pilco.call_count == 1
        assert ia.is_np_array(mock_pilco.call_args_list[0][0][0])
        assert np.isclose(mock_pilco.call_args_list[0][0][1], 0.75, rtol=0,
                          atol=1e-4)
        assert np.all(image_aug == 128)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_pillike.py" startline="1250" endline="1262" pcid="4188">
    @mock.patch("imgaug.augmenters.pillike.enhance_sharpness")
    def test_mocked(self, mock_pilsh):
        aug = iaa.pillike.EnhanceSharpness(0.75)
        image = np.zeros((3, 3, 3), dtype=np.uint8)
        mock_pilsh.return_value = np.full((3, 3, 3), 128, dtype=np.uint8)

        image_aug = aug(image=image)

        assert mock_pilsh.call_count == 1
        assert ia.is_np_array(mock_pilsh.call_args_list[0][0][0])
        assert np.isclose(mock_pilsh.call_args_list[0][0][1], 0.75, rtol=0,
                          atol=1e-4)
        assert np.all(image_aug == 128)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_pillike.py" startline="1208" endline="1220" pcid="4183">
    @mock.patch("imgaug.augmenters.pillike.enhance_brightness")
    def test_mocked(self, mock_pilbr):
        aug = iaa.pillike.EnhanceBrightness(0.75)
        image = np.zeros((1, 1, 3), dtype=np.uint8)
        mock_pilbr.return_value = np.full((1, 1, 3), 128, dtype=np.uint8)

        image_aug = aug(image=image)

        assert mock_pilbr.call_count == 1
        assert ia.is_np_array(mock_pilbr.call_args_list[0][0][0])
        assert np.isclose(mock_pilbr.call_args_list[0][0][1], 0.75, rtol=0,
                          atol=1e-4)
        assert np.all(image_aug == 128)
</source>
</class>

<class classid="218" nclones="2" nlines="26" similarity="71">
<source file="systems/imgaug-0.4.0/test/augmenters/test_pillike.py" startline="1437" endline="1470" pcid="4226">
    @mock.patch("imgaug.augmenters.pillike.warp_affine")
    def test_mocked(self, mock_pilaff):
        aug = iaa.pillike.Affine(
            scale={"x": 1.25, "y": 1.5},
            translate_px={"x": 10, "y": 20},
            rotate=30,
            shear={"x": 40, "y": 50},
            fillcolor=100,
            center=(0.1, 0.2)
        )
        image = np.zeros((3, 3, 3), dtype=np.uint8)
        mock_pilaff.return_value = np.full((3, 3, 3), 128, dtype=np.uint8)

        image_aug = aug(image=image)

        assert mock_pilaff.call_count == 1

        args = mock_pilaff.call_args_list[0][0]
        assert np.all(args[0] == 128)  # due to in-place change

        kwargs = mock_pilaff.call_args_list[0][1]
        assert np.isclose(kwargs["scale_x"], 1.25)
        assert np.isclose(kwargs["scale_y"], 1.5)
        assert np.isclose(kwargs["translate_x_px"], 10)
        assert np.isclose(kwargs["translate_y_px"], 20)
        assert np.isclose(kwargs["rotate_deg"], 30)
        assert np.isclose(kwargs["shear_x_deg"], 40)
        assert np.isclose(kwargs["shear_y_deg"], 50)
        assert np.isclose(kwargs["fillcolor"][0], 100)
        assert np.isclose(kwargs["fillcolor"][1], 100)
        assert np.isclose(kwargs["fillcolor"][2], 100)
        assert np.isclose(kwargs["center"][0], 0.1)
        assert np.isclose(kwargs["center"][1], 0.2)
        assert np.all(image_aug == 128)
</source>
<source file="systems/imgaug-0.4.0/test/augmenters/test_pillike.py" startline="1472" endline="1500" pcid="4227">
    @mock.patch("imgaug.augmenters.pillike.warp_affine")
    def test_mocked_translate_percent(self, mock_pilaff):
        aug = iaa.pillike.Affine(
            translate_percent={"x": 1.2, "y": 1.5}
        )
        image = np.zeros((20, 50, 3), dtype=np.uint8)
        mock_pilaff.return_value = np.full((20, 50, 3), 128, dtype=np.uint8)

        image_aug = aug(image=image)

        assert mock_pilaff.call_count == 1

        args = mock_pilaff.call_args_list[0][0]
        assert np.all(args[0] == 128)  # due to in-place change

        kwargs = mock_pilaff.call_args_list[0][1]
        assert np.isclose(kwargs["scale_x"], 1.0)
        assert np.isclose(kwargs["scale_y"], 1.0)
        assert np.isclose(kwargs["translate_x_px"], 50*1.2)
        assert np.isclose(kwargs["translate_y_px"], 20*1.5)
        assert np.isclose(kwargs["rotate_deg"], 0)
        assert np.isclose(kwargs["shear_x_deg"], 0)
        assert np.isclose(kwargs["shear_y_deg"], 0)
        assert np.isclose(kwargs["fillcolor"][0], 0)
        assert np.isclose(kwargs["fillcolor"][1], 0)
        assert np.isclose(kwargs["fillcolor"][2], 0)
        assert np.isclose(kwargs["center"][0], 0.5)
        assert np.isclose(kwargs["center"][1], 0.5)
        assert np.all(image_aug == 128)
</source>
</class>

<class classid="219" nclones="2" nlines="45" similarity="76">
<source file="systems/imgaug-0.4.0/test/augmentables/test_normalization.py" startline="144" endline="212" pcid="4234">
    def test_invert_normalize_heatmaps(self):
        def _norm_and_invert(heatmaps, images):
            return normalization.invert_normalize_heatmaps(
                normalization.normalize_heatmaps(heatmaps, shapes=images),
                heatmaps
            )

        # ----
        # None
        # ----
        observed = normalization.invert_normalize_heatmaps(None, None)
        assert observed is None

        # ----
        # array
        # ----
        for images in [[np.zeros((1, 1, 3), dtype=np.uint8)],
                       np.zeros((1, 1, 1, 3), dtype=np.uint8)]:
            before = np.zeros((1, 1, 1, 1), dtype=np.float32) + 0.1
            after = _norm_and_invert(before, images=images)
            assert ia.is_np_array(after)
            assert after.shape == (1, 1, 1, 1)
            assert after.dtype.name == "float32"
            assert np.allclose(after, before)

        # ----
        # single HeatmapsOnImage
        # ----
        before = ia.HeatmapsOnImage(
                    np.zeros((1, 1, 1), dtype=np.float32) + 0.1,
                    shape=(1, 1, 3))
        after = _norm_and_invert(before, images=None)
        assert isinstance(after, ia.HeatmapsOnImage)
        assert after.shape == before.shape
        assert np.allclose(after.arr_0to1, before.arr_0to1)

        # ----
        # empty iterable
        # ----
        before = []
        after = _norm_and_invert(before, images=None)
        assert isinstance(after, list)
        assert len(after) == 0

        # ----
        # iterable of arrays
        # ----
        for images in [[np.zeros((1, 1, 3), dtype=np.uint8)],
                       np.zeros((1, 1, 1, 3), dtype=np.uint8)]:
            before = [np.zeros((1, 1, 1), dtype=np.float32) + 0.1]
            after = _norm_and_invert(before, images=images)
            assert isinstance(after, list)
            assert len(after) == 1
            assert after[0].shape == (1, 1, 1)
            assert after[0].dtype.name == "float32"
            assert np.allclose(after[0], before[0])

        # ----
        # iterable of HeatmapsOnImage
        # ----
        before = [ia.HeatmapsOnImage(
                    np.zeros((1, 1, 1), dtype=np.float32) + 0.1,
                    shape=(1, 1, 3))]
        after = _norm_and_invert(before, images=None)
        assert isinstance(after, list)
        assert isinstance(after[0], ia.HeatmapsOnImage)
        assert after[0].shape == before[0].shape
        assert np.allclose(after[0].arr_0to1, before[0].arr_0to1)

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_normalization.py" startline="213" endline="284" pcid="4236">
    def test_invert_normalize_segmentation_maps(self):
        def _norm_and_invert(segmaps, images):
            return normalization.invert_normalize_segmentation_maps(
                normalization.normalize_segmentation_maps(
                    segmaps, shapes=images),
                segmaps
            )

        # ----
        # None
        # ----
        observed = normalization.invert_normalize_segmentation_maps(None, None)
        assert observed is None

        # ----
        # array
        # ----
        for dt in [np.dtype("int32"), np.dtype("uint16"), np.dtype(bool)]:
            for images in [[np.zeros((1, 1, 3), dtype=np.uint8)],
                           np.zeros((1, 1, 3), dtype=np.uint8)]:
                before = np.ones((1, 1, 1, 1), dtype=dt)
                after = _norm_and_invert(before, images=images)
                assert ia.is_np_array(after)
                assert after.shape == (1, 1, 1, 1)
                assert after.dtype.name == dt.name
                assert np.array_equal(after, before)

        # ----
        # single SegmentationMapsOnImage
        # ----
        before = ia.SegmentationMapsOnImage(
                     np.zeros((1, 1, 1), dtype=np.int32) + 1,
                     shape=(1, 1, 3))
        after = _norm_and_invert(before, images=None)
        assert isinstance(after, ia.SegmentationMapsOnImage)
        assert after.shape == before.shape
        assert np.array_equal(after.arr, before.arr)

        # ----
        # empty iterable
        # ----
        before = []
        after = _norm_and_invert(before, images=None)
        assert isinstance(after, list)
        assert len(after) == 0

        # ----
        # iterable of arrays
        # ----
        for dt in [np.dtype("int32"), np.dtype("uint16"), np.dtype(bool)]:
            for images in [[np.zeros((1, 1, 3), dtype=np.uint8)],
                           np.zeros((1, 1, 1, 3), dtype=np.uint8)]:
                before = [np.ones((1, 1, 1), dtype=dt)]
                after = _norm_and_invert(before, images=images)
                assert isinstance(after, list)
                assert len(after) == 1
                assert after[0].shape == (1, 1, 1)
                assert after[0].dtype.name == dt.name
                assert np.array_equal(after[0], before[0])

        # ----
        # iterable of SegmentationMapsOnImage
        # ----
        before = [ia.SegmentationMapsOnImage(
                    np.zeros((1, 1, 1), dtype=np.int32) + 1,
                    shape=(1, 1, 3))]
        after = _norm_and_invert(before, images=None)
        assert isinstance(after, list)
        assert isinstance(after[0], ia.SegmentationMapsOnImage)
        assert after[0].shape == before[0].shape
        assert np.allclose(after[0].arr, before[0].arr)

</source>
</class>

<class classid="220" nclones="2" nlines="241" similarity="72">
<source file="systems/imgaug-0.4.0/test/augmentables/test_normalization.py" startline="1382" endline="1729" pcid="4249">
    def test_normalize_keypoints(self):
        def _assert_single_image_expected(inputs):
            # --> images None
            with self.assertRaises(ValueError):
                _keypoints_norm = normalization.normalize_keypoints(
                    inputs, None)

            # --> too many images
            with self.assertRaises(ValueError):
                _keypoints_norm = normalization.normalize_keypoints(
                    inputs,
                    shapes=np.zeros((2, 1, 1, 3), dtype=np.uint8)
                )

            # --> too many images
            with self.assertRaises(ValueError):
                _keypoints_norm = normalization.normalize_keypoints(
                    inputs,
                    shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                            np.zeros((1, 1, 3), dtype=np.uint8)]
                )

        # ----
        # None
        # ----
        keypoints_norm = normalization.normalize_keypoints(None)
        assert keypoints_norm is None

        # ----
        # array
        # ----
        for dt in [np.dtype("float32"), np.dtype("int16"), np.dtype("uint16")]:
            keypoints_norm = normalization.normalize_keypoints(
                np.zeros((1, 1, 2), dtype=dt) + 1,
                shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
            )
            assert isinstance(keypoints_norm, list)
            assert isinstance(keypoints_norm[0], ia.KeypointsOnImage)
            assert len(keypoints_norm[0].keypoints) == 1
            assert np.allclose(keypoints_norm[0].to_xy_array(), 1)

            keypoints_norm = normalization.normalize_keypoints(
                np.zeros((1, 5, 2), dtype=dt) + 1,
                shapes=np.zeros((1, 1, 1, 3), dtype=np.uint8)
            )
            assert isinstance(keypoints_norm, list)
            assert isinstance(keypoints_norm[0], ia.KeypointsOnImage)
            assert len(keypoints_norm[0].keypoints) == 5
            assert np.allclose(keypoints_norm[0].to_xy_array(), 1)

            # --> keypoints for too many images
            with self.assertRaises(ValueError):
                _keypoints_norm = normalization.normalize_keypoints(
                    np.zeros((2, 1, 2), dtype=dt) + 1,
                    shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
                )

            # --> too few keypoints
            with self.assertRaises(ValueError):
                _keypoints_norm = normalization.normalize_keypoints(
                    np.zeros((1, 1, 2), dtype=dt) + 1,
                    shapes=np.zeros((2, 1, 1, 3), dtype=np.uint8)
                )

            # --> wrong keypoints shape
            with self.assertRaises(ValueError):
                _keypoints_norm = normalization.normalize_keypoints(
                    np.zeros((1, 1, 100), dtype=dt) + 1,
                    shapes=np.zeros((1, 1, 1, 3), dtype=np.uint8)
                )

            _assert_single_image_expected(np.zeros((1, 1, 2), dtype=dt) + 1)

        # ----
        # (x,y)
        # ----
        keypoints_norm = normalization.normalize_keypoints(
            (1, 2),
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert isinstance(keypoints_norm, list)
        assert isinstance(keypoints_norm[0], ia.KeypointsOnImage)
        assert len(keypoints_norm[0].keypoints) == 1
        assert keypoints_norm[0].keypoints[0].x == 1
        assert keypoints_norm[0].keypoints[0].y == 2

        _assert_single_image_expected((1, 2))

        # ----
        # single Keypoint instance
        # ----
        keypoints_norm = normalization.normalize_keypoints(
            ia.Keypoint(x=1, y=2),
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert isinstance(keypoints_norm, list)
        assert isinstance(keypoints_norm[0], ia.KeypointsOnImage)
        assert len(keypoints_norm[0].keypoints) == 1
        assert keypoints_norm[0].keypoints[0].x == 1
        assert keypoints_norm[0].keypoints[0].y == 2

        _assert_single_image_expected(ia.Keypoint(x=1, y=2))

        # ----
        # single KeypointsOnImage instance
        # ----
        keypoints_norm = normalization.normalize_keypoints(
            ia.KeypointsOnImage([ia.Keypoint(x=1, y=2)], shape=(1, 1, 3)),
            shapes=None
        )
        assert isinstance(keypoints_norm, list)
        assert isinstance(keypoints_norm[0], ia.KeypointsOnImage)
        assert len(keypoints_norm[0].keypoints) == 1
        assert keypoints_norm[0].keypoints[0].x == 1
        assert keypoints_norm[0].keypoints[0].y == 2

        # ----
        # empty iterable
        # ----
        keypoints_norm = normalization.normalize_keypoints(
            [], shapes=None
        )
        assert keypoints_norm is None

        # ----
        # iterable of array
        # ----
        for dt in [np.dtype("float32"), np.dtype("int16"), np.dtype("uint16")]:
            keypoints_norm = normalization.normalize_keypoints(
                [np.zeros((1, 2), dtype=dt) + 1],
                shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
            )
            assert isinstance(keypoints_norm, list)
            assert isinstance(keypoints_norm[0], ia.KeypointsOnImage)
            assert len(keypoints_norm[0].keypoints) == 1
            assert np.allclose(keypoints_norm[0].to_xy_array(), 1)

            keypoints_norm = normalization.normalize_keypoints(
                [np.zeros((5, 2), dtype=dt) + 1],
                shapes=np.zeros((1, 1, 1, 3), dtype=np.uint8)
            )
            assert isinstance(keypoints_norm, list)
            assert isinstance(keypoints_norm[0], ia.KeypointsOnImage)
            assert len(keypoints_norm[0].keypoints) == 5
            assert np.allclose(keypoints_norm[0].to_xy_array(), 1)

            # --> keypoints for too many images
            with self.assertRaises(ValueError):
                _keypoints_norm = normalization.normalize_keypoints(
                    [
                        np.zeros((1, 2), dtype=dt) + 1,
                        np.zeros((1, 2), dtype=dt) + 1
                    ],
                    shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
                )

            # --> too few keypoints
            with self.assertRaises(ValueError):
                _keypoints_norm = normalization.normalize_keypoints(
                    [np.zeros((1, 2), dtype=dt) + 1],
                    shapes=np.zeros((2, 1, 1, 3), dtype=np.uint8)
                )

            # --> images None
            with self.assertRaises(ValueError):
                _keypoints_norm = normalization.normalize_keypoints(
                    [np.zeros((1, 2), dtype=dt) + 1],
                    shapes=None
                )

            # --> wrong shape
            with self.assertRaises(ValueError):
                _keypoints_norm = normalization.normalize_keypoints(
                    [np.zeros((1, 100), dtype=dt) + 1],
                    shapes=np.zeros((1, 1, 1, 3), dtype=np.uint8)
                )

        # ----
        # iterable of (x,y)
        # ----
        keypoints_norm = normalization.normalize_keypoints(
            [(1, 2), (3, 4)],
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert isinstance(keypoints_norm, list)
        assert isinstance(keypoints_norm[0], ia.KeypointsOnImage)
        assert len(keypoints_norm[0].keypoints) == 2
        assert keypoints_norm[0].keypoints[0].x == 1
        assert keypoints_norm[0].keypoints[0].y == 2
        assert keypoints_norm[0].keypoints[1].x == 3
        assert keypoints_norm[0].keypoints[1].y == 4

        # may only be used for single images
        with self.assertRaises(ValueError):
            _keypoints_norm = normalization.normalize_keypoints(
                [(1, 2)],
                shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                        np.zeros((1, 1, 3), dtype=np.uint8)]
            )

        # ----
        # iterable of Keypoint
        # ----
        keypoints_norm = normalization.normalize_keypoints(
            [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=4)],
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert isinstance(keypoints_norm, list)
        assert isinstance(keypoints_norm[0], ia.KeypointsOnImage)
        assert len(keypoints_norm[0].keypoints) == 2
        assert keypoints_norm[0].keypoints[0].x == 1
        assert keypoints_norm[0].keypoints[0].y == 2
        assert keypoints_norm[0].keypoints[1].x == 3
        assert keypoints_norm[0].keypoints[1].y == 4

        # may only be used for single images
        with self.assertRaises(ValueError):
            _keypoints_norm = normalization.normalize_keypoints(
                [ia.Keypoint(x=1, y=2)],
                shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                        np.zeros((1, 1, 3), dtype=np.uint8)]
            )

        # ----
        # iterable of KeypointsOnImage
        # ----
        keypoints_norm = normalization.normalize_keypoints(
            [
                ia.KeypointsOnImage([ia.Keypoint(x=1, y=2)], shape=(1, 1, 3)),
                ia.KeypointsOnImage([ia.Keypoint(x=3, y=4)], shape=(1, 1, 3)),
            ],
            shapes=None
        )
        assert isinstance(keypoints_norm, list)

        assert isinstance(keypoints_norm[0], ia.KeypointsOnImage)
        assert len(keypoints_norm[0].keypoints) == 1
        assert keypoints_norm[0].keypoints[0].x == 1
        assert keypoints_norm[0].keypoints[0].y == 2

        assert isinstance(keypoints_norm[1], ia.KeypointsOnImage)
        assert len(keypoints_norm[1].keypoints) == 1
        assert keypoints_norm[1].keypoints[0].x == 3
        assert keypoints_norm[1].keypoints[0].y == 4

        # ----
        # iterable of empty interables
        # ----
        keypoints_norm = normalization.normalize_keypoints(
            [[]],
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert keypoints_norm is None

        # ----
        # iterable of iterable of (x,y)
        # ----
        keypoints_norm = normalization.normalize_keypoints(
            [
                [(1, 2), (3, 4)],
                [(5, 6), (7, 8)]
            ],
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                    np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert isinstance(keypoints_norm, list)
        assert isinstance(keypoints_norm[0], ia.KeypointsOnImage)
        assert len(keypoints_norm[0].keypoints) == 2
        assert keypoints_norm[0].keypoints[0].x == 1
        assert keypoints_norm[0].keypoints[0].y == 2
        assert keypoints_norm[0].keypoints[1].x == 3
        assert keypoints_norm[0].keypoints[1].y == 4

        assert len(keypoints_norm[1].keypoints) == 2
        assert keypoints_norm[1].keypoints[0].x == 5
        assert keypoints_norm[1].keypoints[0].y == 6
        assert keypoints_norm[1].keypoints[1].x == 7
        assert keypoints_norm[1].keypoints[1].y == 8

        # --> images None
        with self.assertRaises(ValueError):
            _keypoints_norm = normalization.normalize_keypoints(
                [
                    [(1, 2), (3, 4)],
                    [(5, 6), (7, 8)]
                ],
                shapes=None
            )

        # --> different number of images
        with self.assertRaises(ValueError):
            _keypoints_norm = normalization.normalize_keypoints(
                [
                    [(1, 2), (3, 4)],
                    [(5, 6), (7, 8)]
                ],
                shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                        np.zeros((1, 1, 3), dtype=np.uint8),
                        np.zeros((1, 1, 3), dtype=np.uint8)]
            )

        # ----
        # iterable of iterable of Keypoint
        # ----
        keypoints_norm = normalization.normalize_keypoints(
            [
                [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=4)],
                [ia.Keypoint(x=5, y=6), ia.Keypoint(x=7, y=8)]
            ],
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                    np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert isinstance(keypoints_norm, list)
        assert isinstance(keypoints_norm[0], ia.KeypointsOnImage)
        assert len(keypoints_norm[0].keypoints) == 2
        assert keypoints_norm[0].keypoints[0].x == 1
        assert keypoints_norm[0].keypoints[0].y == 2
        assert keypoints_norm[0].keypoints[1].x == 3
        assert keypoints_norm[0].keypoints[1].y == 4

        assert len(keypoints_norm[1].keypoints) == 2
        assert keypoints_norm[1].keypoints[0].x == 5
        assert keypoints_norm[1].keypoints[0].y == 6
        assert keypoints_norm[1].keypoints[1].x == 7
        assert keypoints_norm[1].keypoints[1].y == 8

        # --> images None
        with self.assertRaises(ValueError):
            _keypoints_norm = normalization.normalize_keypoints(
                [
                    [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=4)],
                    [ia.Keypoint(x=5, y=6), ia.Keypoint(x=7, y=8)]
                ],
                shapes=None
            )

        # --> different number of images
        with self.assertRaises(ValueError):
            _keypoints_norm = normalization.normalize_keypoints(
                [
                    [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=4)],
                    [ia.Keypoint(x=5, y=6), ia.Keypoint(x=7, y=8)]
                ],
                shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                        np.zeros((1, 1, 3), dtype=np.uint8),
                        np.zeros((1, 1, 3), dtype=np.uint8)]
            )

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_normalization.py" startline="1730" endline="2123" pcid="4251">
    def test_normalize_bounding_boxes(self):
        def _assert_single_image_expected(inputs):
            # --> images None
            with self.assertRaises(ValueError):
                _bbs_norm = normalization.normalize_bounding_boxes(
                    inputs,
                    shapes=None
                )

            # --> too many images
            with self.assertRaises(ValueError):
                _bbs_norm = normalization.normalize_bounding_boxes(
                    inputs,
                    shapes=np.zeros((2, 1, 1, 3), dtype=np.uint8)
                )

            # --> too many images
            with self.assertRaises(ValueError):
                _bbs_norm = normalization.normalize_bounding_boxes(
                    inputs,
                    shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                            np.zeros((1, 1, 3), dtype=np.uint8)]
                )

        # ----
        # None
        # ----
        bbs_norm = normalization.normalize_bounding_boxes(None)
        assert bbs_norm is None

        # ----
        # array
        # ----
        for dt in [np.dtype("float32"), np.dtype("int16"), np.dtype("uint16")]:
            bbs_norm = normalization.normalize_bounding_boxes(
                np.zeros((1, 1, 4), dtype=dt) + 1,
                shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
            )
            assert isinstance(bbs_norm, list)
            assert isinstance(bbs_norm[0], ia.BoundingBoxesOnImage)
            assert len(bbs_norm[0].bounding_boxes) == 1
            assert np.allclose(bbs_norm[0].to_xyxy_array(), 1)

            bbs_norm = normalization.normalize_bounding_boxes(
                np.zeros((1, 5, 4), dtype=dt) + 1,
                shapes=np.zeros((1, 1, 1, 3), dtype=np.uint8)
            )
            assert isinstance(bbs_norm, list)
            assert isinstance(bbs_norm[0], ia.BoundingBoxesOnImage)
            assert len(bbs_norm[0].bounding_boxes) == 5
            assert np.allclose(bbs_norm[0].to_xyxy_array(), 1)

            # --> bounding boxes for too many images
            with self.assertRaises(ValueError):
                _bbs_norm = normalization.normalize_bounding_boxes(
                    np.zeros((2, 1, 4), dtype=dt) + 1,
                    shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
                )

            # --> too few bounding boxes
            with self.assertRaises(ValueError):
                _bbs_norm = normalization.normalize_bounding_boxes(
                    np.zeros((1, 1, 4), dtype=dt) + 1,
                    shapes=np.zeros((2, 1, 1, 3), dtype=np.uint8)
                )

            # --> wrong keypoints shape
            with self.assertRaises(ValueError):
                _bbs_norm = normalization.normalize_bounding_boxes(
                    np.zeros((1, 1, 100), dtype=dt) + 1,
                    shapes=np.zeros((1, 1, 1, 3), dtype=np.uint8)
                )

            _assert_single_image_expected(np.zeros((1, 1, 4), dtype=dt) + 1)

        # ----
        # (x1,y1,x2,y2)
        # ----
        bbs_norm = normalization.normalize_bounding_boxes(
            (1, 2, 3, 4),
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert isinstance(bbs_norm, list)
        assert isinstance(bbs_norm[0], ia.BoundingBoxesOnImage)
        assert len(bbs_norm[0].bounding_boxes) == 1
        assert bbs_norm[0].bounding_boxes[0].x1 == 1
        assert bbs_norm[0].bounding_boxes[0].y1 == 2
        assert bbs_norm[0].bounding_boxes[0].x2 == 3
        assert bbs_norm[0].bounding_boxes[0].y2 == 4

        _assert_single_image_expected((1, 2, 3, 4))

        # ----
        # single BoundingBox instance
        # ----
        bbs_norm = normalization.normalize_bounding_boxes(
            ia.BoundingBox(x1=1, y1=2, x2=3, y2=4),
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert isinstance(bbs_norm, list)
        assert isinstance(bbs_norm[0], ia.BoundingBoxesOnImage)
        assert len(bbs_norm[0].bounding_boxes) == 1
        assert bbs_norm[0].bounding_boxes[0].x1 == 1
        assert bbs_norm[0].bounding_boxes[0].y1 == 2
        assert bbs_norm[0].bounding_boxes[0].x2 == 3
        assert bbs_norm[0].bounding_boxes[0].y2 == 4

        _assert_single_image_expected(ia.BoundingBox(x1=1, y1=2, x2=3, y2=4))

        # ----
        # single BoundingBoxesOnImage instance
        # ----
        bbs_norm = normalization.normalize_bounding_boxes(
            ia.BoundingBoxesOnImage(
                [ia.BoundingBox(x1=1, y1=2, x2=3, y2=4)],
                shape=(1, 1, 3)),
            shapes=None
        )
        assert isinstance(bbs_norm, list)
        assert isinstance(bbs_norm[0], ia.BoundingBoxesOnImage)
        assert len(bbs_norm[0].bounding_boxes) == 1
        assert bbs_norm[0].bounding_boxes[0].x1 == 1
        assert bbs_norm[0].bounding_boxes[0].y1 == 2
        assert bbs_norm[0].bounding_boxes[0].x2 == 3
        assert bbs_norm[0].bounding_boxes[0].y2 == 4

        # ----
        # empty iterable
        # ----
        bbs_norm = normalization.normalize_bounding_boxes([], shapes=None)
        assert bbs_norm is None

        # ----
        # iterable of array
        # ----
        for dt in [np.dtype("float32"), np.dtype("int16"), np.dtype("uint16")]:
            bbs_norm = normalization.normalize_bounding_boxes(
                [np.zeros((1, 4), dtype=dt) + 1],
                shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
            )
            assert isinstance(bbs_norm, list)
            assert isinstance(bbs_norm[0], ia.BoundingBoxesOnImage)
            assert len(bbs_norm[0].bounding_boxes) == 1
            assert np.allclose(bbs_norm[0].to_xyxy_array(), 1)

            bbs_norm = normalization.normalize_bounding_boxes(
                [np.zeros((5, 4), dtype=dt) + 1],
                shapes=np.zeros((1, 1, 1, 3), dtype=np.uint8)
            )
            assert isinstance(bbs_norm, list)
            assert isinstance(bbs_norm[0], ia.BoundingBoxesOnImage)
            assert len(bbs_norm[0].bounding_boxes) == 5
            assert np.allclose(bbs_norm[0].to_xyxy_array(), 1)

            # --> bounding boxes for too many images
            with self.assertRaises(ValueError):
                _bbs_norm = normalization.normalize_bounding_boxes(
                    [
                        np.zeros((1, 4), dtype=dt) + 1,
                        np.zeros((1, 4), dtype=dt) + 1
                    ],
                    shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
                )

            # --> too few bounding boxes
            with self.assertRaises(ValueError):
                _bbs_norm = normalization.normalize_bounding_boxes(
                    [np.zeros((1, 4), dtype=dt) + 1],
                    shapes=np.zeros((2, 1, 1, 3), dtype=np.uint8)
                )

            # --> images None
            with self.assertRaises(ValueError):
                _bbs_norm = normalization.normalize_bounding_boxes(
                    [np.zeros((1, 4), dtype=dt) + 1],
                    shapes=None
                )

            # --> wrong shape
            with self.assertRaises(ValueError):
                _bbs_norm = normalization.normalize_bounding_boxes(
                    [np.zeros((1, 100), dtype=dt) + 1],
                    shapes=np.zeros((1, 1, 1, 3), dtype=np.uint8)
                )

        # ----
        # iterable of (x1,y1,x2,y2)
        # ----
        bbs_norm = normalization.normalize_bounding_boxes(
            [(1, 2, 3, 4), (5, 6, 7, 8)],
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert isinstance(bbs_norm, list)
        assert isinstance(bbs_norm[0], ia.BoundingBoxesOnImage)
        assert len(bbs_norm[0].bounding_boxes) == 2
        assert bbs_norm[0].bounding_boxes[0].x1 == 1
        assert bbs_norm[0].bounding_boxes[0].y1 == 2
        assert bbs_norm[0].bounding_boxes[0].x2 == 3
        assert bbs_norm[0].bounding_boxes[0].y2 == 4
        assert bbs_norm[0].bounding_boxes[1].x1 == 5
        assert bbs_norm[0].bounding_boxes[1].y1 == 6
        assert bbs_norm[0].bounding_boxes[1].x2 == 7
        assert bbs_norm[0].bounding_boxes[1].y2 == 8

        # may only be used for single images
        with self.assertRaises(ValueError):
            _bbs_norm = normalization.normalize_bounding_boxes(
                [(1, 2, 3, 4)],
                shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                        np.zeros((1, 1, 3), dtype=np.uint8)]
            )

        # ----
        # iterable of BoundingBox
        # ----
        bbs_norm = normalization.normalize_bounding_boxes(
            [
                ia.BoundingBox(x1=1, y1=2, x2=3, y2=4),
                ia.BoundingBox(x1=5, y1=6, x2=7, y2=8)
            ],
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert isinstance(bbs_norm, list)
        assert isinstance(bbs_norm[0], ia.BoundingBoxesOnImage)
        assert len(bbs_norm[0].bounding_boxes) == 2
        assert bbs_norm[0].bounding_boxes[0].x1 == 1
        assert bbs_norm[0].bounding_boxes[0].y1 == 2
        assert bbs_norm[0].bounding_boxes[0].x2 == 3
        assert bbs_norm[0].bounding_boxes[0].y2 == 4
        assert bbs_norm[0].bounding_boxes[1].x1 == 5
        assert bbs_norm[0].bounding_boxes[1].y1 == 6
        assert bbs_norm[0].bounding_boxes[1].x2 == 7
        assert bbs_norm[0].bounding_boxes[1].y2 == 8

        # may only be used for single images
        with self.assertRaises(ValueError):
            _bbs_norm = normalization.normalize_bounding_boxes(
                [ia.BoundingBox(x1=1, y1=2, x2=3, y2=4)],
                shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                        np.zeros((1, 1, 3), dtype=np.uint8)]
            )

        # ----
        # iterable of BoundingBoxesOnImage
        # ----
        bbs_norm = normalization.normalize_bounding_boxes(
            [
                ia.BoundingBoxesOnImage(
                    [ia.BoundingBox(x1=1, y1=2, x2=3, y2=4)],
                    shape=(1, 1, 3)),
                ia.BoundingBoxesOnImage(
                    [ia.BoundingBox(x1=5, y1=6, x2=7, y2=8)],
                    shape=(1, 1, 3))
            ],
            shapes=None
        )
        assert isinstance(bbs_norm, list)

        assert isinstance(bbs_norm[0], ia.BoundingBoxesOnImage)
        assert len(bbs_norm[0].bounding_boxes) == 1
        assert bbs_norm[0].bounding_boxes[0].x1 == 1
        assert bbs_norm[0].bounding_boxes[0].y1 == 2
        assert bbs_norm[0].bounding_boxes[0].x2 == 3
        assert bbs_norm[0].bounding_boxes[0].y2 == 4

        assert isinstance(bbs_norm[1], ia.BoundingBoxesOnImage)
        assert len(bbs_norm[1].bounding_boxes) == 1
        assert bbs_norm[1].bounding_boxes[0].x1 == 5
        assert bbs_norm[1].bounding_boxes[0].y1 == 6
        assert bbs_norm[1].bounding_boxes[0].x2 == 7
        assert bbs_norm[1].bounding_boxes[0].y2 == 8

        # ----
        # iterable of empty interables
        # ----
        bbs_norm = normalization.normalize_bounding_boxes(
            [[]],
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert bbs_norm is None

        # ----
        # iterable of iterable of (x1,y1,x2,y2)
        # ----
        bbs_norm = normalization.normalize_bounding_boxes(
            [
                [(1, 2, 3, 4)],
                [(5, 6, 7, 8), (9, 10, 11, 12)]
            ],
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                    np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert isinstance(bbs_norm, list)
        assert isinstance(bbs_norm[0], ia.BoundingBoxesOnImage)
        assert len(bbs_norm[0].bounding_boxes) == 1
        assert bbs_norm[0].bounding_boxes[0].x1 == 1
        assert bbs_norm[0].bounding_boxes[0].y1 == 2
        assert bbs_norm[0].bounding_boxes[0].x2 == 3
        assert bbs_norm[0].bounding_boxes[0].y2 == 4

        assert len(bbs_norm[1].bounding_boxes) == 2
        assert bbs_norm[1].bounding_boxes[0].x1 == 5
        assert bbs_norm[1].bounding_boxes[0].y1 == 6
        assert bbs_norm[1].bounding_boxes[0].x2 == 7
        assert bbs_norm[1].bounding_boxes[0].y2 == 8

        assert bbs_norm[1].bounding_boxes[1].x1 == 9
        assert bbs_norm[1].bounding_boxes[1].y1 == 10
        assert bbs_norm[1].bounding_boxes[1].x2 == 11
        assert bbs_norm[1].bounding_boxes[1].y2 == 12

        # --> images None
        with self.assertRaises(ValueError):
            _bbs_norm = normalization.normalize_bounding_boxes(
                [
                    [(1, 2, 3, 4), (3, 4, 5, 6)],
                    [(5, 6, 7, 8), (7, 8, 9, 10)]
                ],
                shapes=None
            )

        # --> different number of images
        with self.assertRaises(ValueError):
            _bbs_norm = normalization.normalize_bounding_boxes(
                [
                    [(1, 2, 3, 4)],
                    [(5, 6, 7, 8)]
                ],
                [np.zeros((1, 1, 3), dtype=np.uint8),
                 np.zeros((1, 1, 3), dtype=np.uint8),
                 np.zeros((1, 1, 3), dtype=np.uint8)]
            )

        # ----
        # iterable of iterable of Keypoint
        # ----
        bbs_norm = normalization.normalize_bounding_boxes(
            [
                [ia.BoundingBox(x1=1, y1=2, x2=3, y2=4),
                 ia.BoundingBox(x1=5, y1=6, x2=7, y2=8)],
                [ia.BoundingBox(x1=9, y1=10, x2=11, y2=12),
                 ia.BoundingBox(x1=13, y1=14, x2=15, y2=16)]
            ],
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                    np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert isinstance(bbs_norm, list)
        assert isinstance(bbs_norm[0], ia.BoundingBoxesOnImage)
        assert len(bbs_norm[0].bounding_boxes) == 2
        assert bbs_norm[0].bounding_boxes[0].x1 == 1
        assert bbs_norm[0].bounding_boxes[0].y1 == 2
        assert bbs_norm[0].bounding_boxes[0].x2 == 3
        assert bbs_norm[0].bounding_boxes[0].y2 == 4
        assert bbs_norm[0].bounding_boxes[1].x1 == 5
        assert bbs_norm[0].bounding_boxes[1].y1 == 6
        assert bbs_norm[0].bounding_boxes[1].x2 == 7
        assert bbs_norm[0].bounding_boxes[1].y2 == 8

        assert len(bbs_norm[1].bounding_boxes) == 2
        assert bbs_norm[1].bounding_boxes[0].x1 == 9
        assert bbs_norm[1].bounding_boxes[0].y1 == 10
        assert bbs_norm[1].bounding_boxes[0].x2 == 11
        assert bbs_norm[1].bounding_boxes[0].y2 == 12
        assert bbs_norm[1].bounding_boxes[1].x1 == 13
        assert bbs_norm[1].bounding_boxes[1].y1 == 14
        assert bbs_norm[1].bounding_boxes[1].x2 == 15
        assert bbs_norm[1].bounding_boxes[1].y2 == 16

        # --> images None
        with self.assertRaises(ValueError):
            _bbs_norm = normalization.normalize_bounding_boxes(
                [
                    [ia.BoundingBox(x1=1, y1=2, x2=3, y2=4),
                     ia.BoundingBox(x1=5, y1=6, x2=7, y2=8)],
                    [ia.BoundingBox(x1=9, y1=10, x2=11, y2=12),
                     ia.BoundingBox(x1=13, y1=14, x2=15, y2=16)]
                ],
                shapes=None
            )

        # --> different number of images
        with self.assertRaises(ValueError):
            _bbs_norm = normalization.normalize_bounding_boxes(
                [
                    [ia.BoundingBox(x1=1, y1=2, x2=3, y2=4),
                     ia.BoundingBox(x1=5, y1=6, x2=7, y2=8)],
                    [ia.BoundingBox(x1=9, y1=10, x2=11, y2=12),
                     ia.BoundingBox(x1=13, y1=14, x2=15, y2=16)]
                ],
                shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                        np.zeros((1, 1, 3), dtype=np.uint8),
                        np.zeros((1, 1, 3), dtype=np.uint8)]
            )
    
</source>
</class>

<class classid="221" nclones="3" nlines="13" similarity="85">
<source file="systems/imgaug-0.4.0/test/augmentables/test_normalization.py" startline="1383" endline="1406" pcid="4250">
        def _assert_single_image_expected(inputs):
            # --> images None
            with self.assertRaises(ValueError):
                _keypoints_norm = normalization.normalize_keypoints(
                    inputs, None)

            # --> too many images
            with self.assertRaises(ValueError):
                _keypoints_norm = normalization.normalize_keypoints(
                    inputs,
                    shapes=np.zeros((2, 1, 1, 3), dtype=np.uint8)
                )

            # --> too many images
            with self.assertRaises(ValueError):
                _keypoints_norm = normalization.normalize_keypoints(
                    inputs,
                    shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                            np.zeros((1, 1, 3), dtype=np.uint8)]
                )

        # ----
        # None
        # ----
</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_normalization.py" startline="2125" endline="2144" pcid="4254">
        def _assert_single_image_expected(inputs):
            # --> images None
            with self.assertRaises(ValueError):
                _polygons_norm = normalization.normalize_polygons(
                    inputs, shapes=None)

            # --> too many images
            with self.assertRaises(ValueError):
                _polygons_norm = normalization.normalize_polygons(
                    inputs,
                    shapes=np.zeros((2, 1, 1, 3), dtype=np.uint8))

            # --> too many images
            with self.assertRaises(ValueError):
                _polygons_norm = normalization.normalize_polygons(
                    inputs,
                    shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                            np.zeros((1, 1, 3), dtype=np.uint8)]
                )

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_normalization.py" startline="1731" endline="1756" pcid="4252">
        def _assert_single_image_expected(inputs):
            # --> images None
            with self.assertRaises(ValueError):
                _bbs_norm = normalization.normalize_bounding_boxes(
                    inputs,
                    shapes=None
                )

            # --> too many images
            with self.assertRaises(ValueError):
                _bbs_norm = normalization.normalize_bounding_boxes(
                    inputs,
                    shapes=np.zeros((2, 1, 1, 3), dtype=np.uint8)
                )

            # --> too many images
            with self.assertRaises(ValueError):
                _bbs_norm = normalization.normalize_bounding_boxes(
                    inputs,
                    shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                            np.zeros((1, 1, 3), dtype=np.uint8)]
                )

        # ----
        # None
        # ----
</source>
</class>

<class classid="222" nclones="2" nlines="38" similarity="84">
<source file="systems/imgaug-0.4.0/test/augmentables/test_normalization.py" startline="2956" endline="3015" pcid="4258">
    def test_estimate_heatmaps_norm_type(self):
        ntype = normalization.estimate_heatmaps_norm_type(None)
        assert ntype == "None"

        ntype = normalization.estimate_heatmaps_norm_type(
            np.zeros((1, 1, 1, 1), dtype=np.float32))
        assert ntype == "array[float]"

        ntype = normalization.estimate_heatmaps_norm_type(
            ia.HeatmapsOnImage(
                np.zeros((1, 1, 1), dtype=np.float32),
                shape=(1, 1, 1)
            )
        )
        assert ntype == "HeatmapsOnImage"

        ntype = normalization.estimate_heatmaps_norm_type([])
        assert ntype == "iterable[empty]"

        ntype = normalization.estimate_heatmaps_norm_type(
            [np.zeros((1, 1, 1), dtype=np.float32)])
        assert ntype == "iterable-array[float]"

        ntype = normalization.estimate_heatmaps_norm_type([
            ia.HeatmapsOnImage(np.zeros((1, 1, 1), dtype=np.float32),
                               shape=(1, 1, 1))
        ])
        assert ntype == "iterable-HeatmapsOnImage"

        # --
        # error cases
        # --
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_heatmaps_norm_type(1)

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_heatmaps_norm_type("foo")

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_heatmaps_norm_type(
                np.zeros((1, 1, 1), dtype=np.int32))

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_heatmaps_norm_type([1])

        # wrong class
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_heatmaps_norm_type(
                ia.KeypointsOnImage([], shape=(1, 1, 1)))

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_heatmaps_norm_type([[]])

        # list of list of Heatmaps, only list of Heatmaps is max
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_heatmaps_norm_type([
                [ia.HeatmapsOnImage(np.zeros((1, 1, 1), dtype=np.float32),
                                    shape=(1, 1, 1))]
            ])

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_normalization.py" startline="3016" endline="3074" pcid="4259">
    def test_estimate_segmaps_norm_type(self):
        ntype = normalization.estimate_segmaps_norm_type(None)
        assert ntype == "None"

        for name, dt in zip(["int", "uint", "bool"],
                            [np.int32, np.uint16, bool]):
            ntype = normalization.estimate_segmaps_norm_type(
                np.zeros((1, 1, 1, 1), dtype=dt))
            assert ntype == "array[%s]" % (name,)

        ntype = normalization.estimate_segmaps_norm_type(
            ia.SegmentationMapsOnImage(
                np.zeros((1, 1, 1), dtype=np.int32),
                shape=(1, 1, 1)
            )
        )
        assert ntype == "SegmentationMapsOnImage"

        ntype = normalization.estimate_segmaps_norm_type([])
        assert ntype == "iterable[empty]"

        ntype = normalization.estimate_segmaps_norm_type(
            [np.zeros((1, 1, 1), dtype=np.int32)])
        assert ntype == "iterable-array[int]"

        ntype = normalization.estimate_segmaps_norm_type([
            ia.SegmentationMapsOnImage(np.zeros((1, 1, 1), dtype=np.int32),
                                       shape=(1, 1, 1))
        ])
        assert ntype == "iterable-SegmentationMapsOnImage"

        # --
        # error cases
        # --
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_segmaps_norm_type(1)

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_segmaps_norm_type("foo")

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_segmaps_norm_type([1])

        # wrong class
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_segmaps_norm_type(
                ia.KeypointsOnImage([], shape=(1, 1, 1)))

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_segmaps_norm_type([[]])

        # list of list of SegMap, only list of SegMap is max
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_segmaps_norm_type([
                [ia.SegmentationMapsOnImage(
                    np.zeros((1, 1, 1, 1), dtype=np.int32),
                    shape=(1, 1, 1))]
            ])

</source>
</class>

<class classid="223" nclones="2" nlines="55" similarity="71">
<source file="systems/imgaug-0.4.0/test/augmentables/test_normalization.py" startline="3075" endline="3152" pcid="4260">
    def test_estimate_keypoints_norm_type(self):
        ntype = normalization.estimate_keypoints_norm_type(None)
        assert ntype == "None"

        for name, dt in zip(["float", "int", "uint"],
                            [np.float32, np.int32, np.uint16]):
            ntype = normalization.estimate_keypoints_norm_type(
                np.zeros((1, 5, 2), dtype=dt))
            assert ntype == "array[%s]" % (name,)

        ntype = normalization.estimate_keypoints_norm_type((1, 2))
        assert ntype == "tuple[number,size=2]"

        ntype = normalization.estimate_keypoints_norm_type(
            ia.Keypoint(x=1, y=2))
        assert ntype == "Keypoint"

        ntype = normalization.estimate_keypoints_norm_type(
            ia.KeypointsOnImage([ia.Keypoint(x=1, y=2)], shape=(1, 1, 3)))
        assert ntype == "KeypointsOnImage"

        ntype = normalization.estimate_keypoints_norm_type([])
        assert ntype == "iterable[empty]"

        for name, dt in zip(["float", "int", "uint"],
                            [np.float32, np.int32, np.uint16]):
            ntype = normalization.estimate_keypoints_norm_type(
                [np.zeros((5, 2), dtype=dt)])
            assert ntype == "iterable-array[%s]" % (name,)

        ntype = normalization.estimate_keypoints_norm_type([(1, 2)])
        assert ntype == "iterable-tuple[number,size=2]"

        ntype = normalization.estimate_keypoints_norm_type(
            [ia.Keypoint(x=1, y=2)])
        assert ntype == "iterable-Keypoint"

        ntype = normalization.estimate_keypoints_norm_type([
            ia.KeypointsOnImage([ia.Keypoint(x=1, y=2)], shape=(1, 1, 3))])
        assert ntype == "iterable-KeypointsOnImage"

        ntype = normalization.estimate_keypoints_norm_type([[]])
        assert ntype == "iterable-iterable[empty]"

        ntype = normalization.estimate_keypoints_norm_type([[(1, 2)]])
        assert ntype == "iterable-iterable-tuple[number,size=2]"

        ntype = normalization.estimate_keypoints_norm_type(
            [[ia.Keypoint(x=1, y=2)]])
        assert ntype == "iterable-iterable-Keypoint"

        # --
        # error cases
        # --
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_keypoints_norm_type(1)

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_keypoints_norm_type("foo")

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_keypoints_norm_type([1])

        # wrong class
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_keypoints_norm_type(
                ia.HeatmapsOnImage(np.zeros((1, 1, 1), dtype=np.float32),
                                   shape=(1, 1, 1)))

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_keypoints_norm_type([[[]]])

        # list of list of list of keypoints,
        # only list of list of keypoints is max
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_keypoints_norm_type(
                [[[ia.Keypoint(x=1, y=2)]]])

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_normalization.py" startline="3153" endline="3235" pcid="4261">
    def test_estimate_bounding_boxes_norm_type(self):
        ntype = normalization.estimate_bounding_boxes_norm_type(None)
        assert ntype == "None"

        for name, dt in zip(["float", "int", "uint"],
                            [np.float32, np.int32, np.uint16]):
            ntype = normalization.estimate_bounding_boxes_norm_type(
                np.zeros((1, 5, 4), dtype=dt))
            assert ntype == "array[%s]" % (name,)

        ntype = normalization.estimate_bounding_boxes_norm_type((1, 2, 3, 4))
        assert ntype == "tuple[number,size=4]"

        ntype = normalization.estimate_bounding_boxes_norm_type(
            ia.BoundingBox(x1=1, y1=2, x2=3, y2=4))
        assert ntype == "BoundingBox"

        ntype = normalization.estimate_bounding_boxes_norm_type(
            ia.BoundingBoxesOnImage(
                [ia.BoundingBox(x1=1, y1=2, x2=3, y2=4)], shape=(1, 1, 3)))
        assert ntype == "BoundingBoxesOnImage"

        ntype = normalization.estimate_bounding_boxes_norm_type([])
        assert ntype == "iterable[empty]"

        for name, dt in zip(["float", "int", "uint"],
                            [np.float32, np.int32, np.uint16]):
            ntype = normalization.estimate_bounding_boxes_norm_type(
                [np.zeros((5, 4), dtype=dt)])
            assert ntype == "iterable-array[%s]" % (name,)

        ntype = normalization.estimate_bounding_boxes_norm_type([(1, 2, 3, 4)])
        assert ntype == "iterable-tuple[number,size=4]"

        ntype = normalization.estimate_bounding_boxes_norm_type([
            ia.BoundingBox(x1=1, y1=2, x2=3, y2=4)])
        assert ntype == "iterable-BoundingBox"

        ntype = normalization.estimate_bounding_boxes_norm_type([
            ia.BoundingBoxesOnImage([ia.BoundingBox(x1=1, y1=2, x2=3, y2=4)],
                                    shape=(1, 1, 3))])
        assert ntype == "iterable-BoundingBoxesOnImage"

        ntype = normalization.estimate_bounding_boxes_norm_type([[]])
        assert ntype == "iterable-iterable[empty]"

        ntype = normalization.estimate_bounding_boxes_norm_type(
            [[(1, 2, 3, 4)]])
        assert ntype == "iterable-iterable-tuple[number,size=4]"

        ntype = normalization.estimate_bounding_boxes_norm_type(
            [[ia.BoundingBox(x1=1, y1=2, x2=3, y2=4)]])
        assert ntype == "iterable-iterable-BoundingBox"

        # --
        # error cases
        # --
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_bounding_boxes_norm_type(1)

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_bounding_boxes_norm_type("foo")

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_bounding_boxes_norm_type([1])

        # wrong class
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_bounding_boxes_norm_type(
                ia.HeatmapsOnImage(
                    np.zeros((1, 1, 1), dtype=np.float32),
                    shape=(1, 1, 1))
            )

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_bounding_boxes_norm_type([[[]]])

        # list of list of list of bounding boxes,
        # only list of list of bounding boxes is max
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_bounding_boxes_norm_type([[[
                ia.BoundingBox(x1=1, y1=2, x2=3, y2=4)]]])

</source>
</class>

<class classid="224" nclones="2" nlines="74" similarity="97">
<source file="systems/imgaug-0.4.0/test/augmentables/test_normalization.py" startline="3236" endline="3350" pcid="4262">
    def test_estimate_polygons_norm_type(self):
        points = [(0, 0), (10, 0), (10, 10)]

        ntype = normalization.estimate_polygons_norm_type(None)
        assert ntype == "None"

        for name, dt in zip(["float", "int", "uint"],
                            [np.float32, np.int32, np.uint16]):
            ntype = normalization.estimate_polygons_norm_type(
                np.zeros((1, 2, 5, 2), dtype=dt)
            )
            assert ntype == "array[%s]" % (name,)

        ntype = normalization.estimate_polygons_norm_type(
            ia.Polygon(points)
        )
        assert ntype == "Polygon"

        ntype = normalization.estimate_polygons_norm_type(
            ia.PolygonsOnImage(
                [ia.Polygon(points)], shape=(1, 1, 3))
        )
        assert ntype == "PolygonsOnImage"

        ntype = normalization.estimate_polygons_norm_type([])
        assert ntype == "iterable[empty]"

        for name, dt in zip(["float", "int", "uint"],
                            [np.float32, np.int32, np.uint16]):
            ntype = normalization.estimate_polygons_norm_type(
                [np.zeros((5, 4), dtype=dt)]
            )
            assert ntype == "iterable-array[%s]" % (name,)

        ntype = normalization.estimate_polygons_norm_type(points)
        assert ntype == "iterable-tuple[number,size=2]"

        ntype = normalization.estimate_polygons_norm_type(
            [ia.Keypoint(x=x, y=y) for x, y in points]
        )
        assert ntype == "iterable-Keypoint"

        ntype = normalization.estimate_polygons_norm_type([ia.Polygon(points)])
        assert ntype == "iterable-Polygon"

        ntype = normalization.estimate_polygons_norm_type(
            [ia.PolygonsOnImage([ia.Polygon(points)],
                                shape=(1, 1, 3))]
        )
        assert ntype == "iterable-PolygonsOnImage"

        ntype = normalization.estimate_polygons_norm_type([[]])
        assert ntype == "iterable-iterable[empty]"

        for name, dt in zip(["float", "int", "uint"],
                            [np.float32, np.int32, np.uint16]):
            ntype = normalization.estimate_polygons_norm_type(
                [[np.zeros((5, 4), dtype=dt)]]
            )
            assert ntype == "iterable-iterable-array[%s]" % (name,)

        ntype = normalization.estimate_polygons_norm_type([points])
        assert ntype == "iterable-iterable-tuple[number,size=2]"

        ntype = normalization.estimate_polygons_norm_type([[
            ia.Keypoint(x=x, y=y) for x, y in points
        ]])
        assert ntype == "iterable-iterable-Keypoint"

        ntype = normalization.estimate_polygons_norm_type(
            [[ia.Polygon(points)]]
        )
        assert ntype == "iterable-iterable-Polygon"

        ntype = normalization.estimate_polygons_norm_type([[[]]])
        assert ntype == "iterable-iterable-iterable[empty]"

        ntype = normalization.estimate_polygons_norm_type([[points]])
        assert ntype == "iterable-iterable-iterable-tuple[number,size=2]"

        ntype = normalization.estimate_polygons_norm_type(
            [[[ia.Keypoint(x=x, y=y) for x, y in points]]]
        )
        assert ntype == "iterable-iterable-iterable-Keypoint"

        # --
        # error cases
        # --
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_polygons_norm_type(1)

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_polygons_norm_type("foo")

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_polygons_norm_type([1])

        # wrong class
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_polygons_norm_type(
                ia.HeatmapsOnImage(
                    np.zeros((1, 1, 1), dtype=np.float32),
                    shape=(1, 1, 1))
            )

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_polygons_norm_type([[[[]]]])

        # list of list of list of polygons,
        # only list of list of polygons is max
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_polygons_norm_type([[[
                ia.Polygon(points)]]]
            )
    
</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_normalization.py" startline="3351" endline="3465" pcid="4263">
    def test_estimate_line_strings_norm_type(self):
        points = [(0, 0), (10, 0), (10, 10)]

        ntype = normalization.estimate_line_strings_norm_type(None)
        assert ntype == "None"

        for name, dt in zip(["float", "int", "uint"],
                            [np.float32, np.int32, np.uint16]):
            ntype = normalization.estimate_line_strings_norm_type(
                np.zeros((1, 2, 5, 2), dtype=dt)
            )
            assert ntype == "array[%s]" % (name,)

        ntype = normalization.estimate_line_strings_norm_type(
            ia.LineString(points)
        )
        assert ntype == "LineString"

        ntype = normalization.estimate_line_strings_norm_type(
            ia.LineStringsOnImage(
                [ia.LineString(points)], shape=(1, 1, 3))
        )
        assert ntype == "LineStringsOnImage"

        ntype = normalization.estimate_line_strings_norm_type([])
        assert ntype == "iterable[empty]"

        for name, dt in zip(["float", "int", "uint"],
                            [np.float32, np.int32, np.uint16]):
            ntype = normalization.estimate_line_strings_norm_type(
                [np.zeros((5, 4), dtype=dt)]
            )
            assert ntype == "iterable-array[%s]" % (name,)

        ntype = normalization.estimate_line_strings_norm_type(points)
        assert ntype == "iterable-tuple[number,size=2]"

        ntype = normalization.estimate_line_strings_norm_type(
            [ia.Keypoint(x=x, y=y) for x, y in points]
        )
        assert ntype == "iterable-Keypoint"

        ntype = normalization.estimate_line_strings_norm_type(
            [ia.LineString(points)])
        assert ntype == "iterable-LineString"

        ntype = normalization.estimate_line_strings_norm_type(
            [ia.LineStringsOnImage([ia.LineString(points)],
                                   shape=(1, 1, 3))]
        )
        assert ntype == "iterable-LineStringsOnImage"

        ntype = normalization.estimate_line_strings_norm_type([[]])
        assert ntype == "iterable-iterable[empty]"

        for name, dt in zip(["float", "int", "uint"],
                            [np.float32, np.int32, np.uint16]):
            ntype = normalization.estimate_line_strings_norm_type(
                [[np.zeros((5, 4), dtype=dt)]]
            )
            assert ntype == "iterable-iterable-array[%s]" % (name,)

        ntype = normalization.estimate_line_strings_norm_type([points])
        assert ntype == "iterable-iterable-tuple[number,size=2]"

        ntype = normalization.estimate_line_strings_norm_type([[
            ia.Keypoint(x=x, y=y) for x, y in points
        ]])
        assert ntype == "iterable-iterable-Keypoint"

        ntype = normalization.estimate_line_strings_norm_type(
            [[ia.LineString(points)]]
        )
        assert ntype == "iterable-iterable-LineString"

        ntype = normalization.estimate_line_strings_norm_type([[[]]])
        assert ntype == "iterable-iterable-iterable[empty]"

        ntype = normalization.estimate_line_strings_norm_type([[points]])
        assert ntype == "iterable-iterable-iterable-tuple[number,size=2]"

        ntype = normalization.estimate_line_strings_norm_type(
            [[[ia.Keypoint(x=x, y=y) for x, y in points]]]
        )
        assert ntype == "iterable-iterable-iterable-Keypoint"

        # --
        # error cases
        # --
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_line_strings_norm_type(1)

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_line_strings_norm_type("foo")

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_line_strings_norm_type([1])

        # wrong class
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_line_strings_norm_type(
                ia.HeatmapsOnImage(
                    np.zeros((1, 1, 1), dtype=np.float32),
                    shape=(1, 1, 1))
            )

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_line_strings_norm_type([[[[]]]])

        # list of list of list of LineStrings,
        # only list of list of LineStrings is max
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_line_strings_norm_type([[[
                ia.LineString(points)]]]
            )
</source>
</class>

<class classid="225" nclones="10" nlines="12" similarity="71">
<source file="systems/imgaug-0.4.0/test/augmentables/test_utils.py" startline="55" endline="70" pcid="4267">
    def test_2_points_0_steps(self):
        points = [
            (0, 0),
            (1, 2)
        ]

        inter = interpolate_points(points, 0)

        assert np.allclose(
            inter,
            np.float32([
                [0, 0],
                [1, 2]
            ])
        )

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_utils.py" startline="89" endline="105" pcid="4269">
    def test_2_points_1_step_not_closed(self):
        points = [
            (0, 0),
            (1, 2)
        ]

        inter = interpolate_points(points, 1, closed=False)

        assert np.allclose(
            inter,
            np.float32([
                [0, 0],
                [0.5, 1.0],
                [1, 2]
            ])
        )

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_utils.py" startline="229" endline="245" pcid="4278">
    def test_2_points_dist_1_not_closed(self):
        points = [
            (0, 0),
            (0, 2)
        ]

        inter = interpolate_points_by_max_distance(points, 1.0, closed=False)

        assert np.allclose(
            inter,
            np.float32([
                [0, 0],
                [0, 1.0],
                [0, 2]
            ])
        )

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_utils.py" startline="71" endline="88" pcid="4268">
    def test_2_points_1_step(self):
        points = [
            (0, 0),
            (1, 2)
        ]

        inter = interpolate_points(points, 1)

        assert np.allclose(
            inter,
            np.float32([
                [0, 0],
                [0.5, 1.0],
                [1, 2],
                [0.5, 1.0]
            ])
        )

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_utils.py" startline="266" endline="285" pcid="4280">
    def test_3_points_dist_1_not_closed(self):
        points = [
            (0, 0),
            (0, 2),
            (2, 0)
        ]

        inter = interpolate_points_by_max_distance(points, 1.0, closed=False)

        assert np.allclose(
            inter,
            np.float32([
                [0, 0],
                [0, 1.0],
                [0, 2],
                [1.0, 1.0],
                [2, 0]
            ])
        )

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_utils.py" startline="211" endline="228" pcid="4277">
    def test_2_points_dist_1(self):
        points = [
            (0, 0),
            (0, 2)
        ]

        inter = interpolate_points_by_max_distance(points, 1.0)

        assert np.allclose(
            inter,
            np.float32([
                [0, 0],
                [0, 1.0],
                [0, 2],
                [0, 1.0]
            ])
        )

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_utils.py" startline="106" endline="123" pcid="4270">
    def test_3_points_0_steps(self):
        points = [
            (0, 0),
            (1, 2),
            (0.5, 3)
        ]

        inter = interpolate_points(points, 0)

        assert np.allclose(
            inter,
            np.float32([
                [0, 0],
                [1, 2],
                [0.5, 3]
            ])
        )

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_utils.py" startline="124" endline="144" pcid="4271">
    def test_3_points_1_step(self):
        points = [
            (0, 0),
            (1, 2),
            (0.5, 3)
        ]

        inter = interpolate_points(points, 1)

        assert np.allclose(
            inter,
            np.float32([
                [0, 0],
                [0.5, 1.0],
                [1, 2],
                [0.75, 2.5],
                [0.5, 3],
                [0.25, 1.5]
            ])
        )

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_utils.py" startline="145" endline="164" pcid="4272">
    def test_3_points_1_step_not_closed(self):
        points = [
            (0, 0),
            (1, 2),
            (0.5, 3)
        ]

        inter = interpolate_points(points, 1, closed=False)

        assert np.allclose(
            inter,
            np.float32([
                [0, 0],
                [0.5, 1.0],
                [1, 2],
                [0.75, 2.5],
                [0.5, 3]
            ])
        )

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_utils.py" startline="246" endline="265" pcid="4279">
    def test_3_points_dist_1(self):
        points = [
            (0, 0),
            (0, 2),
            (2, 0)
        ]

        inter = interpolate_points_by_max_distance(points, 1.0)
        assert np.allclose(
            inter,
            np.float32([
                [0, 0],
                [0, 1.0],
                [0, 2],
                [1.0, 1.0],
                [2, 0],
                [1.0, 0]
            ])
        )

</source>
</class>

<class classid="226" nclones="2" nlines="13" similarity="100">
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="70" endline="88" pcid="4286">
    def test_exterior_is_float32_array(self):
        poly = ia.Polygon(
            np.float32([
                [0.0, 0.0],
                [1.0, 1.0],
                [0.5, 2.5]
            ])
        )

        assert poly.exterior.dtype.name == "float32"
        assert np.allclose(
            poly.exterior,
            np.float32([
                [0.0, 0.0],
                [1.0, 1.0],
                [0.5, 2.5]
            ])
        )

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="89" endline="107" pcid="4287">
    def test_exterior_is_float64_array(self):
        poly = ia.Polygon(
            np.float64([
                [0.0, 0.0],
                [1.0, 1.0],
                [0.5, 2.5]
            ])
        )

        assert poly.exterior.dtype.name == "float32"
        assert np.allclose(
            poly.exterior,
            np.float32([
                [0.0, 0.0],
                [1.0, 1.0],
                [0.5, 2.5]
            ])
        )

</source>
</class>

<class classid="227" nclones="3" nlines="12" similarity="100">
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="302" endline="318" pcid="4326">
    def test_project_square_to_image_of_identical_shape(self):
        poly = ia.Polygon([(0, 0), (1, 0), (1, 1), (0, 1)])

        poly_proj = self._func(poly, (1, 1), (1, 1))

        assert poly_proj.exterior.dtype.name == "float32"
        assert poly_proj.exterior.shape == (4, 2)
        assert np.allclose(
            poly_proj.exterior,
            np.float32([
                [0, 0],
                [1, 0],
                [1, 1],
                [0, 1]
            ])
        )

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="336" endline="352" pcid="4328">
    def test_project_square_to_image_with_twice_the_height_but_same_width(self):
        poly = ia.Polygon([(0, 0), (1, 0), (1, 1), (0, 1)])

        poly_proj = self._func(poly, (1, 1), (2, 1))

        assert poly_proj.exterior.dtype.name == "float32"
        assert poly_proj.exterior.shape == (4, 2)
        assert np.allclose(
            poly_proj.exterior,
            np.float32([
                [0, 0],
                [1, 0],
                [1, 2],
                [0, 2]
            ])
        )

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="319" endline="335" pcid="4327">
    def test_project_square_to_image_with_twice_the_height_and_width(self):
        poly = ia.Polygon([(0, 0), (1, 0), (1, 1), (0, 1)])

        poly_proj = self._func(poly, (1, 1), (2, 2))

        assert poly_proj.exterior.dtype.name == "float32"
        assert poly_proj.exterior.shape == (4, 2)
        assert np.allclose(
            poly_proj.exterior,
            np.float32([
                [0, 0],
                [2, 0],
                [2, 2],
                [0, 2]
            ])
        )

</source>
</class>

<class classid="228" nclones="3" nlines="10" similarity="80">
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="660" endline="672" pcid="4375">
    def test_polygon_with_zero_points_fails(self):
        poly = ia.Polygon([])
        got_exception = False
        try:
            poly.is_out_of_image((1, 1, 3))
        except Exception as exc:
            assert (
                "Cannot determine whether the polygon is inside the "
                "image" in str(exc))
            got_exception = True
        assert got_exception


</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="1683" endline="1695" pcid="4462">
    def test_one_point_polygon_fails(self):
        # one point polygon
        poly = ia.Polygon([(0, 0)])
        got_exception = False
        try:
            _ = poly.to_shapely_line_string()
        except Exception as exc:
            assert (
                "Conversion to shapely line string requires at least two "
                "points" in str(exc))
            got_exception = True
        assert got_exception

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="1696" endline="1708" pcid="4463">
    def test_zero_point_polygon_fails(self):
        # zero point polygon
        poly = ia.Polygon([])
        got_exception = False
        try:
            _ = poly.to_shapely_line_string()
        except Exception as exc:
            assert (
                "Conversion to shapely line string requires at least two "
                "points" in str(exc))
            got_exception = True
        assert got_exception

</source>
</class>

<class classid="229" nclones="3" nlines="28" similarity="75">
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="1006" endline="1043" pcid="4408">
    def test_square_polygon(self):
        # simple drawing of square
        poly = ia.Polygon([(2, 2), (8, 2), (8, 8), (2, 8)])
        image = self.image
        image_poly = poly.draw_on_image(image,
                                        color=[32, 128, 32],
                                        color_face=[32, 128, 32],
                                        color_lines=[0, 255, 0],
                                        color_points=[0, 255, 0],
                                        alpha=1.0,
                                        alpha_face=1.0,
                                        alpha_lines=1.0,
                                        alpha_points=0.0,
                                        raise_if_out_of_image=False)
        assert image_poly.dtype.type == np.uint8
        assert image_poly.shape == (10, 10, 3)
        # draw did not change original image (copy=True)
        assert np.sum(image) == 3 * np.sum(np.arange(100))

        for c_idx, value in enumerate([0, 255, 0]):
            # left boundary
            assert np.all(image_poly[2:9, 2:3, c_idx]
                          == np.zeros((7, 1), dtype=np.uint8) + value)
            # right boundary
            assert np.all(image_poly[2:9, 8:9, c_idx]
                          == np.zeros((7, 1), dtype=np.uint8) + value)
            # top boundary
            assert np.all(image_poly[2:3, 2:9, c_idx]
                          == np.zeros((1, 7), dtype=np.uint8) + value)
            # bottom boundary
            assert np.all(image_poly[8:9, 2:9, c_idx]
                          == np.zeros((1, 7), dtype=np.uint8) + value)
        expected = np.tile(
            np.uint8([32, 128, 32]).reshape((1, 1, 3)),
            (5, 5, 1)
        )
        assert np.all(image_poly[3:8, 3:8, :] == expected)

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="1044" endline="1079" pcid="4409">
    def test_square_polygon_use_no_color_subargs(self):
        # simple drawing of square, use only "color" arg
        poly = ia.Polygon([(2, 2), (8, 2), (8, 8), (2, 8)])
        image = self.image
        image_poly = poly.draw_on_image(image,
                                        color=[0, 255, 0],
                                        alpha=1.0,
                                        alpha_face=1.0,
                                        alpha_lines=1.0,
                                        alpha_points=0.0,
                                        raise_if_out_of_image=False)
        assert image_poly.dtype.type == np.uint8
        assert image_poly.shape == (10, 10, 3)
        # draw did not change original image (copy=True)
        assert np.sum(image) == 3 * np.sum(np.arange(100))

        for c_idx, value in enumerate([0, 0.5*255, 0]):
            value = int(np.round(value))
            # left boundary
            assert np.all(image_poly[2:9, 2:3, c_idx]
                          == np.zeros((7, 1), dtype=np.uint8) + value)
            # right boundary
            assert np.all(image_poly[2:9, 8:9, c_idx]
                          == np.zeros((7, 1), dtype=np.uint8) + value)
            # top boundary
            assert np.all(image_poly[2:3, 2:9, c_idx]
                          == np.zeros((1, 7), dtype=np.uint8) + value)
            # bottom boundary
            assert np.all(image_poly[8:9, 2:9, c_idx]
                          == np.zeros((1, 7), dtype=np.uint8) + value)
        expected = np.tile(
            np.uint8([0, 255, 0]).reshape((1, 1, 3)),
            (5, 5, 1)
        )
        assert np.all(image_poly[3:8, 3:8, :] == expected)

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="1115" endline="1149" pcid="4411">
    def test_square_polygon_half_outside_of_image(self):
        # drawing of poly that is half out of image
        poly = ia.Polygon([(2, 2+5), (8, 2+5), (8, 8+5), (2, 8+5)])
        image = self.image
        image_poly = poly.draw_on_image(image,
                                        color=[32, 128, 32],
                                        color_face=[32, 128, 32],
                                        color_lines=[0, 255, 0],
                                        color_points=[0, 255, 0],
                                        alpha=1.0,
                                        alpha_face=1.0,
                                        alpha_lines=1.0,
                                        alpha_points=0.0,
                                        raise_if_out_of_image=False)
        assert image_poly.dtype.type == np.uint8
        assert image_poly.shape == (10, 10, 3)
        # draw did not change original image (copy=True)
        assert np.sum(image) == 3 * np.sum(np.arange(100))

        for c_idx, value in enumerate([0, 255, 0]):
            # left boundary
            assert np.all(image_poly[2+5:, 2:3, c_idx]
                          == np.zeros((3, 1), dtype=np.uint8) + value)
            # right boundary
            assert np.all(image_poly[2+5:, 8:9, c_idx]
                          == np.zeros((3, 1), dtype=np.uint8) + value)
            # top boundary
            assert np.all(image_poly[2+5:3+5, 2:9, c_idx]
                          == np.zeros((1, 7), dtype=np.uint8) + value)
        expected = np.tile(
            np.uint8([32, 128, 32]).reshape((1, 1, 3)),
            (2, 5, 1)
        )
        assert np.all(image_poly[3+5:, 3:8, :] == expected)

</source>
</class>

<class classid="230" nclones="3" nlines="19" similarity="70">
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="1150" endline="1172" pcid="4412">
    def test_square_polygon_half_outside_of_image_with_raise_if_ooi(self):
        # drawing of poly that is half out of image, with
        # raise_if_out_of_image=True
        poly = ia.Polygon([(2, 2+5), (8, 2+5), (8, 8+5), (0, 8+5)])
        image = self.image
        got_exception = False
        try:
            _ = poly.draw_on_image(image,
                                   color=[32, 128, 32],
                                   color_face=[32, 128, 32],
                                   color_lines=[0, 255, 0],
                                   color_points=[0, 255, 0],
                                   alpha=1.0,
                                   alpha_face=1.0,
                                   alpha_lines=1.0,
                                   alpha_points=0.0,
                                   raise_if_out_of_image=True)
        except Exception as exc:
            assert "Cannot draw polygon" in str(exc)
            got_exception = True
        # only polygons fully outside of the image plane lead to exceptions
        assert not got_exception

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="1190" endline="1212" pcid="4414">
    def test_polygon_fully_outside_of_image_with_raise_if_ooi(self):
        # drawing of poly that is fully out of image,
        # with raise_if_out_of_image=True
        poly = ia.Polygon([(100, 100), (100+10, 100), (100+10, 100+10),
                           (100, 100+10)])
        image = self.image
        got_exception = False
        try:
            _ = poly.draw_on_image(image,
                                   color=[32, 128, 32],
                                   color_face=[32, 128, 32],
                                   color_lines=[0, 255, 0],
                                   color_points=[0, 255, 0],
                                   alpha=1.0,
                                   alpha_face=1.0,
                                   alpha_lines=1.0,
                                   alpha_points=0.0,
                                   raise_if_out_of_image=True)
        except Exception as exc:
            assert "Cannot draw polygon" in str(exc)
            got_exception = True
        assert got_exception

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="1173" endline="1189" pcid="4413">
    def test_polygon_fully_outside_of_image(self):
        # drawing of poly that is fully out of image
        poly = ia.Polygon([(100, 100), (100+10, 100), (100+10, 100+10),
                           (100, 100+10)])
        image = self.image
        image_poly = poly.draw_on_image(image,
                                        color=[32, 128, 32],
                                        color_face=[32, 128, 32],
                                        color_lines=[0, 255, 0],
                                        color_points=[0, 255, 0],
                                        alpha=1.0,
                                        alpha_face=1.0,
                                        alpha_lines=1.0,
                                        alpha_points=0.0,
                                        raise_if_out_of_image=False)
        assert np.array_equal(image_poly, image)

</source>
</class>

<class classid="231" nclones="2" nlines="20" similarity="80">
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="1213" endline="1236" pcid="4415">
    def test_only_lines_visible(self):
        # face+points invisible via alpha
        poly = ia.Polygon([(2, 2), (8, 2), (8, 8), (2, 8)])
        image = self.image
        image_poly = poly.draw_on_image(image,
                                        color=[32, 128, 32],
                                        color_face=[32, 128, 32],
                                        color_lines=[0, 255, 0],
                                        color_points=[0, 255, 0],
                                        alpha=1.0,
                                        alpha_face=0.0,
                                        alpha_lines=1.0,
                                        alpha_points=0.0,
                                        raise_if_out_of_image=False)
        assert image_poly.dtype.type == np.uint8
        assert image_poly.shape == (10, 10, 3)
        # draw did not change original image (copy=True)
        assert np.sum(image) == 3 * np.sum(np.arange(100))
        for c_idx, value in enumerate([0, 255, 0]):
            # left boundary
            assert np.all(image_poly[2:9, 2:3, c_idx]
                          == np.zeros((7, 1), dtype=np.uint8) + value)
        assert np.all(image_poly[3:8, 3:8, :] == image[3:8, 3:8, :])

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="1237" endline="1259" pcid="4416">
    def test_only_face_visible(self):
        # boundary+points invisible via alpha
        poly = ia.Polygon([(2, 2), (8, 2), (8, 8), (2, 8)])
        image = self.image
        image_poly = poly.draw_on_image(image,
                                        color=[32, 128, 32],
                                        color_face=[32, 128, 32],
                                        color_lines=[0, 255, 0],
                                        color_points=[0, 255, 0],
                                        alpha=1.0,
                                        alpha_face=1.0,
                                        alpha_lines=0.0,
                                        alpha_points=0.0,
                                        raise_if_out_of_image=False)
        assert image_poly.dtype.type == np.uint8
        assert image_poly.shape == (10, 10, 3)
        # draw did not change original image (copy=True)
        assert np.sum(image) == 3 * np.sum(np.arange(100))
        expected = np.tile(
            np.uint8([32, 128, 32]).reshape((1, 1, 3)), (6, 6, 1)
        )
        assert np.all(image_poly[2:8, 2:8, :] == expected)

</source>
</class>

<class classid="232" nclones="2" nlines="24" similarity="76">
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="1260" endline="1287" pcid="4417">
    def test_alpha_is_080(self):
        # alpha=0.8
        poly = ia.Polygon([(2, 2), (8, 2), (8, 8), (2, 8)])
        image = self.image
        image_poly = poly.draw_on_image(image,
                                        color=[32, 128, 32],
                                        color_face=[32, 128, 32],
                                        color_lines=[0, 255, 0],
                                        color_points=[0, 255, 0],
                                        alpha=0.8,
                                        alpha_points=0.0,
                                        raise_if_out_of_image=False)
        assert image_poly.dtype.type == np.uint8
        assert image_poly.shape == (10, 10, 3)
        for c_idx, value in enumerate([0, 255, 0]):
            expected = np.round(
                (1-0.8)*image[2:9, 8:9, c_idx]
                + np.full((7, 1), 0.8*value, dtype=np.float32)
            ).astype(np.uint8)

            # right boundary
            assert np.all(image_poly[2:9, 8:9, c_idx] == expected)
        expected = (0.8 * 0.5) * np.tile(
            np.uint8([32, 128, 32]).reshape((1, 1, 3)), (5, 5, 1)
        ) + (1 - (0.8 * 0.5)) * image[3:8, 3:8, :]
        assert np.all(image_poly[3:8, 3:8, :]
                      == np.round(expected).astype(np.uint8))

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="1288" endline="1350" pcid="4418">
    def test_face_and_lines_at_half_visibility(self):
        # alpha of fill and perimeter 0.5
        poly = ia.Polygon([(2, 2), (8, 2), (8, 8), (2, 8)])
        image = self.image
        image_poly = poly.draw_on_image(image,
                                        color=[32, 128, 32],
                                        color_face=[32, 128, 32],
                                        color_lines=[0, 255, 0],
                                        color_points=[0, 255, 0],
                                        alpha=1.0,
                                        alpha_face=0.5,
                                        alpha_lines=0.5,
                                        alpha_points=0.0,
                                        raise_if_out_of_image=False)
        assert image_poly.dtype.type == np.uint8
        assert image_poly.shape == (10, 10, 3)
        for c_idx, value in enumerate([0, 255, 0]):
            expected = np.round(
                0.5*image[2:9, 8:9, c_idx]
                + np.full((7, 1), 0.5*value, dtype=np.float32)
            ).astype(np.uint8)

            # right boundary
            assert np.all(image_poly[2:9, 8:9, c_idx] == expected)

        expected = 0.5 * np.tile(
            np.uint8([32, 128, 32]).reshape((1, 1, 3)), (5, 5, 1)
        ) + 0.5 * image[3:8, 3:8, :]
        assert np.all(image_poly[3:8, 3:8, :]
                      == np.round(expected).astype(np.uint8))

        # copy=False
        # test deactivated as the function currently does not offer a copy
        # argument
        """
        image_cp = np.copy(image)
        poly = ia.Polygon([(2, 2), (8, 2), (8, 8), (2, 8)])
        image_poly = poly.draw_on_image(image_cp,
                                        color_face=[32, 128, 32],
                                        color_boundary=[0, 255, 0],
                                        alpha_face=1.0,
                                        alpha_boundary=1.0,
                                        raise_if_out_of_image=False)
        assert image_poly.dtype.type == np.uint8
        assert image_poly.shape == (10, 10, 3)
        assert np.all(image_cp == image_poly)
        assert not np.all(image_cp == image)
        for c_idx, value in enumerate([0, 255, 0]):
            # left boundary
            assert np.all(image_poly[2:9, 2:3, c_idx]
                          == np.zeros((6, 1, 3), dtype=np.uint8) + value)
            # left boundary
            assert np.all(image_cp[2:9, 2:3, c_idx]
                          == np.zeros((6, 1, 3), dtype=np.uint8) + value)
        expected = np.tile(
            np.uint8([32, 128, 32]).reshape((1, 1, 3)),
            (5, 5, 1)
        )
        assert np.all(image_poly[3:8, 3:8, :] == expected)
        assert np.all(image_cp[3:8, 3:8, :] == expected)
        """


</source>
</class>

<class classid="233" nclones="2" nlines="10" similarity="90">
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="2271" endline="2283" pcid="4544">
    def test_with_one_polygon(self):
        # standard case with one polygon
        poly_oi = ia.PolygonsOnImage(
            [ia.Polygon([(0, 0), (1, 0), (1, 1), (0, 1)])],
            shape=(10, 10, 3)
        )
        assert len(poly_oi.polygons) == 1
        assert np.allclose(
            poly_oi.polygons[0].exterior,
            [(0, 0), (1, 0), (1, 1), (0, 1)],
            rtol=0, atol=1e-4)
        assert poly_oi.shape == (10, 10, 3)

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="2448" endline="2461" pcid="4559">
    def test_new_shape_is_2x_width_and_10x_height_of_old_shape(self):
        # 2x increase in width, 10x decrease in height
        poly_oi = ia.PolygonsOnImage(
            [ia.Polygon([(0, 0), (50, 0), (50, 100), (0, 100)])],
            shape=(100, 100, 3)
        )
        poly_oi_proj = self._func(poly_oi, (10, 200, 3))
        assert np.allclose(
            poly_oi_proj.polygons[0].exterior,
            [(0, 0), (100, 0), (100, 10), (0, 10)],
            rtol=0, atol=1e-4)
        assert poly_oi_proj.shape == (10, 200, 3)


</source>
</class>

<class classid="234" nclones="3" nlines="20" similarity="90">
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="2284" endline="2306" pcid="4545">
    def test_with_multiple_polygons(self):
        # standard case with multiple polygons
        poly_oi = ia.PolygonsOnImage(
            [ia.Polygon([(0, 0), (1, 0), (1, 1), (0, 1)]),
             ia.Polygon([(0, 0), (1, 0), (1, 1)]),
             ia.Polygon([(0.5, 0), (1, 0.5), (0.5, 1), (0, 0.5)])],
            shape=(10, 10, 3)
        )
        assert len(poly_oi.polygons) == 3
        assert np.allclose(
            poly_oi.polygons[0].exterior,
            [(0, 0), (1, 0), (1, 1), (0, 1)],
            rtol=0, atol=1e-4)
        assert np.allclose(
            poly_oi.polygons[1].exterior,
            [(0, 0), (1, 0), (1, 1)],
            rtol=0, atol=1e-4)
        assert np.allclose(
            poly_oi.polygons[2].exterior,
            [(0.5, 0), (1, 0.5), (0.5, 1), (0, 0.5)],
            rtol=0, atol=1e-4)
        assert poly_oi.shape == (10, 10, 3)

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="2425" endline="2447" pcid="4558">
    def test_new_shape_is_10x_smaller_than_old_shape(self):
        # 10x decrease in size
        poly_oi = ia.PolygonsOnImage(
            [ia.Polygon([(0, 0), (10, 0), (10, 10), (0, 10)]),
             ia.Polygon([(0, 0), (10, 0), (10, 10)]),
             ia.Polygon([(5, 0), (10, 5), (5, 10), (0, 5)])],
            shape=(10, 10, 3)
        )
        poly_oi_proj = self._func(poly_oi, (1, 1, 3))
        assert np.allclose(
            poly_oi_proj.polygons[0].exterior,
            [(0, 0), (1, 0), (1, 1), (0, 1)],
            rtol=0, atol=1e-4)
        assert np.allclose(
            poly_oi_proj.polygons[1].exterior,
            [(0, 0), (1, 0), (1, 1)],
            rtol=0, atol=1e-4)
        assert np.allclose(
            poly_oi_proj.polygons[2].exterior,
            [(0.5, 0), (1, 0.5), (0.5, 1), (0, 0.5)],
            rtol=0, atol=1e-4)
        assert poly_oi_proj.shape == (1, 1, 3)

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="2402" endline="2424" pcid="4557">
    def test_new_shape_is_identical_to_old_shape(self):
        # size unchanged
        poly_oi = ia.PolygonsOnImage(
            [ia.Polygon([(0, 0), (1, 0), (1, 1), (0, 1)]),
             ia.Polygon([(0, 0), (1, 0), (1, 1)]),
             ia.Polygon([(0.5, 0), (1, 0.5), (0.5, 1), (0, 0.5)])],
            shape=(1, 1, 3)
        )
        poly_oi_proj = self._func(poly_oi, (1, 1, 3))
        assert np.allclose(
            poly_oi_proj.polygons[0].exterior,
            [(0, 0), (1, 0), (1, 1), (0, 1)],
            rtol=0, atol=1e-4)
        assert np.allclose(
            poly_oi_proj.polygons[1].exterior,
            [(0, 0), (1, 0), (1, 1)],
            rtol=0, atol=1e-4)
        assert np.allclose(
            poly_oi_proj.polygons[2].exterior,
            [(0.5, 0), (1, 0.5), (0.5, 1), (0, 0.5)],
            rtol=0, atol=1e-4)
        assert poly_oi_proj.shape == (1, 1, 3)

</source>
</class>

<class classid="235" nclones="2" nlines="11" similarity="81">
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="2572" endline="2585" pcid="4569">
    def test_inplaceness(self):
        poly_oi = ia.PolygonsOnImage(
            [ia.Polygon([(1, 1), (11, 1), (11, 9), (1, 9)]),
             ia.Polygon([(100, 100), (200, 100), (200, 200), (100, 200)])],
            shape=(10, 10, 3))

        poly_oi_rm = self._func(poly_oi.deepcopy(), fully=True, partly=False)

        if self._is_inplace:
            assert poly_oi_rm is poly_oi
        else:
            assert poly_oi_rm is not poly_oi


</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="2761" endline="2775" pcid="4589">
    def test_inplaceness(self):
        poly_oi = ia.PolygonsOnImage(
            [ia.Polygon([(1, 1), (8, 1), (8, 9), (1, 9)]),
             ia.Polygon([(1, 1), (15, 1), (15, 9), (1, 9)]),
             ia.Polygon([(100, 100), (200, 100), (200, 200), (100, 200)])],
            shape=(10, 11, 3))

        poly_oi_shifted = self._func(poly_oi, x=1)

        if self._is_inplace:
            assert poly_oi_shifted is poly_oi
        else:
            assert poly_oi_shifted is not poly_oi


</source>
</class>

<class classid="236" nclones="4" nlines="10" similarity="70">
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="2597" endline="2610" pcid="4572">
    def test_three_polygons(self):
        item1 = ia.Polygon([(5, 1), (9, 1), (9, 2), (5, 2)])
        item2 = ia.Polygon([(5, 1), (15, 1), (15, 2), (5, 2)])
        item3 = ia.Polygon([(15, 1), (25, 1), (25, 2), (15, 2)])
        cbaoi = ia.PolygonsOnImage([item1, item2, item3],
                                   shape=(10, 10, 3))

        cbaoi_reduced = cbaoi.remove_out_of_image_fraction_(0.6)

        assert len(cbaoi_reduced.items) == 2
        assert cbaoi_reduced.items == [item1, item2]
        assert cbaoi_reduced is cbaoi


</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="2612" endline="2625" pcid="4573">
    def test_three_polygons(self):
        item1 = ia.Polygon([(5, 1), (9, 1), (9, 2), (5, 2)])
        item2 = ia.Polygon([(5, 1), (15, 1), (15, 2), (5, 2)])
        item3 = ia.Polygon([(15, 1), (25, 1), (25, 2), (15, 2)])
        cbaoi = ia.PolygonsOnImage([item1, item2, item3],
                                   shape=(10, 10, 3))

        cbaoi_reduced = cbaoi.remove_out_of_image_fraction(0.6)

        assert len(cbaoi_reduced.items) == 2
        assert cbaoi_reduced.items == [item1, item2]
        assert cbaoi_reduced is not cbaoi


</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_bbs.py" startline="1862" endline="1874" pcid="4844">
    def test_remove_out_of_image_fraction_(self):
        item1 = ia.BoundingBox(y1=1, x1=5, y2=6, x2=9)
        item2 = ia.BoundingBox(y1=1, x1=5, y2=6, x2=15)
        item3 = ia.BoundingBox(y1=1, x1=15, y2=6, x2=25)
        cbaoi = ia.BoundingBoxesOnImage([item1, item2, item3],
                                        shape=(10, 10, 3))

        cbaoi_reduced = cbaoi.remove_out_of_image_fraction_(0.6)

        assert len(cbaoi_reduced.items) == 2
        assert cbaoi_reduced.items == [item1, item2]
        assert cbaoi_reduced is cbaoi

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_bbs.py" startline="1875" endline="1887" pcid="4845">
    def test_remove_out_of_image_fraction(self):
        item1 = ia.BoundingBox(y1=1, x1=5, y2=6, x2=9)
        item2 = ia.BoundingBox(y1=1, x1=5, y2=6, x2=15)
        item3 = ia.BoundingBox(y1=1, x1=15, y2=6, x2=25)
        cbaoi = ia.BoundingBoxesOnImage([item1, item2, item3],
                                        shape=(10, 10, 3))

        cbaoi_reduced = cbaoi.remove_out_of_image_fraction(0.6)

        assert len(cbaoi_reduced.items) == 2
        assert cbaoi_reduced.items == [item1, item2]
        assert cbaoi_reduced is not cbaoi

</source>
</class>

<class classid="237" nclones="2" nlines="10" similarity="100">
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="2653" endline="2664" pcid="4578">
    def test_with_one_polygon_fully_inside(self):
        # one polygon, fully inside
        poly_oi = ia.PolygonsOnImage(
            [ia.Polygon([(1, 1), (8, 1), (8, 9), (1, 9)])],
            shape=(10, 11, 3))
        poly_oi_clip = self._func(poly_oi)
        assert len(poly_oi_clip.polygons) == 1
        for point_search in [(1, 1), (8, 1), (8, 9), (1, 9)]:
            assert self._any_point_close(poly_oi_clip.polygons[0].exterior,
                                         point_search)
        assert poly_oi_clip.shape == (10, 11, 3)

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="2665" endline="2676" pcid="4579">
    def test_with_one_polygon_partially_ooi(self):
        # one polygon, partially outside
        poly_oi = ia.PolygonsOnImage(
            [ia.Polygon([(1, 1), (15, 1), (15, 9), (1, 9)])],
            shape=(10, 11, 3))
        poly_oi_clip = self._func(poly_oi)
        assert len(poly_oi_clip.polygons) == 1
        for point_search in [(1, 1), (11, 1), (11, 9), (1, 9)]:
            assert self._any_point_close(poly_oi_clip.polygons[0].exterior,
                                         point_search)
        assert poly_oi_clip.shape == (10, 11, 3)

</source>
</class>

<class classid="238" nclones="2" nlines="20" similarity="70">
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="2740" endline="2760" pcid="4588">
    def test_with_three_polygons_along_xy(self):
        # three polygons
        poly_oi = ia.PolygonsOnImage(
            [ia.Polygon([(1, 1), (8, 1), (8, 9), (1, 9)]),
             ia.Polygon([(1, 1), (15, 1), (15, 9), (1, 9)]),
             ia.Polygon([(100, 100), (200, 100), (200, 200), (100, 200)])],
            shape=(10, 11, 3))
        poly_oi_shifted = self._func(poly_oi, x=1, y=2)
        assert len(poly_oi_shifted.polygons) == 3
        assert np.allclose(poly_oi_shifted.polygons[0].exterior,
                           [(1+1, 1+2), (8+1, 1+2), (8+1, 9+2), (1+1, 9+2)],
                           rtol=0, atol=1e-4)
        assert np.allclose(poly_oi_shifted.polygons[1].exterior,
                           [(1+1, 1+2), (15+1, 1+2), (15+1, 9+2), (1+1, 9+2)],
                           rtol=0, atol=1e-4)
        assert np.allclose(poly_oi_shifted.polygons[2].exterior,
                           [(100+1, 100+2), (200+1, 100+2),
                            (200+1, 200+2), (100+1, 200+2)],
                           rtol=0, atol=1e-4)
        assert poly_oi_shifted.shape == (10, 11, 3)

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="2795" endline="2817" pcid="4594">
    def test_with_three_polygons(self):
        # three polygons
        poly_oi = ia.PolygonsOnImage(
            [ia.Polygon([(1, 1), (8, 1), (8, 9), (1, 9)]),
             ia.Polygon([(1, 1), (15, 1), (15, 9), (1, 9)]),
             ia.Polygon([(100, 100), (200, 100), (200, 200), (100, 200)])],
            shape=(10, 11, 3))
        poly_oi_shifted = self._func(poly_oi, top=3, right=0, bottom=1,
                                     left=-3)
        assert len(poly_oi_shifted.polygons) == 3
        assert np.allclose(poly_oi_shifted.polygons[0].exterior,
                           [(1-3, 1+2), (8-3, 1+2), (8-3, 9+2), (1-3, 9+2)],
                           rtol=0, atol=1e-4)
        assert np.allclose(poly_oi_shifted.polygons[1].exterior,
                           [(1-3, 1+2), (15-3, 1+2), (15-3, 9+2), (1-3, 9+2)],
                           rtol=0, atol=1e-4)
        assert np.allclose(poly_oi_shifted.polygons[2].exterior,
                           [(100-3, 100+2), (200-3, 100+2),
                            (200-3, 200+2), (100-3, 200+2)],
                           rtol=0, atol=1e-4)
        assert poly_oi_shifted.shape == (10, 11, 3)


</source>
</class>

<class classid="239" nclones="2" nlines="13" similarity="78">
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="2826" endline="2842" pcid="4597">
    def test_mocked(self):
        poly_oi = ia.PolygonsOnImage(
            [ia.Polygon([(1, 1), (8, 1), (8, 9), (1, 9)]),
             ia.Polygon([(1, 1), (15, 1), (15, 9), (1, 9)])],
            shape=(10, 11, 3))
        mock_sub = mock.Mock()
        mock_sub.return_value = "foo"
        poly_oi.items[0].subdivide_ = mock_sub
        poly_oi.items[1].subdivide_ = mock_sub

        poly_oi_sub = self._func(poly_oi, 2)

        assert mock_sub.call_count == 2
        assert mock_sub.call_args_list[0][0][0] == 2
        assert mock_sub.call_args_list[1][0][0] == 2
        assert poly_oi_sub.items == ["foo", "foo"]

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="2882" endline="2901" pcid="4603">
    def test_mocked(self):
        poly_oi = ia.PolygonsOnImage(
            [ia.Polygon([(1, 1), (8, 1), (8, 9), (1, 9)]),
             ia.Polygon([(1, 1), (15, 1), (15, 9), (1, 9)])],
            shape=(10, 11, 3))
        mock_sub = mock.Mock()
        mock_sub.return_value = "foo"
        poly_oi.items[0].subdivide_ = mock_sub
        poly_oi.items[1].subdivide_ = mock_sub

        poly_oi_sub = self._func(poly_oi, 2)

        # When the PSOI is copied, each polygon is also copied. That leads
        # to new Polygon instances that have no longer the subdivide_
        # method overwritten by the mock. Hence, the mock is never actually
        # called here.
        assert mock_sub.call_count == 0
        assert poly_oi_sub.items != ["foo", "foo"]


</source>
</class>

<class classid="240" nclones="2" nlines="20" similarity="85">
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="2951" endline="2973" pcid="4608">
    def test_array_with_two_coords(self):
        xy = np.array(
            [(100, 100),
             (101, 100),
             (101, 101),
             (110, 110),
             (120, 100),
             (120, 120)], dtype=np.float32)
        psoi = ia.PolygonsOnImage(
            [ia.Polygon([(0, 0), (1, 0), (1, 1)]),
             ia.Polygon([(10, 10), (20, 0), (20, 20)])],
            shape=(2, 2, 3))

        psoi = psoi.fill_from_xy_array_(xy)

        assert len(psoi.polygons) == 2
        assert np.allclose(
            psoi.polygons[0].coords,
            [(100, 100), (101, 100), (101, 101)])
        assert np.allclose(
            psoi.polygons[1].coords,
            [(110, 110), (120, 100), (120, 120)])

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="2974" endline="2996" pcid="4609">
    def test_list_with_two_coords(self):
        xy = [(100, 100),
              (101, 100),
              (101, 101),
              (110, 110),
              (120, 100),
              (120, 120)]
        psoi = ia.PolygonsOnImage(
            [ia.Polygon([(0, 0), (1, 0), (1, 1)]),
             ia.Polygon([(10, 10), (20, 0), (20, 20)])],
            shape=(2, 2, 3))

        psoi = psoi.fill_from_xy_array_(xy)

        assert len(psoi.polygons) == 2
        assert np.allclose(
            psoi.polygons[0].coords,
            [(100, 100), (101, 100), (101, 101)])
        assert np.allclose(
            psoi.polygons[1].coords,
            [(110, 110), (120, 100), (120, 120)])


</source>
</class>

<class classid="241" nclones="2" nlines="21" similarity="73">
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="2998" endline="3019" pcid="4610">
    def test_filled_instance(self):
        psoi = ia.PolygonsOnImage(
            [ia.Polygon([(0, 0), (1, 0), (1, 1)]),
             ia.Polygon([(10, 10), (20, 0), (20, 20)])],
            shape=(1, 2, 3))

        kpsoi = psoi.to_keypoints_on_image()

        assert len(kpsoi.keypoints) == 2*3
        assert kpsoi.keypoints[0].x == 0
        assert kpsoi.keypoints[0].y == 0
        assert kpsoi.keypoints[1].x == 1
        assert kpsoi.keypoints[1].y == 0
        assert kpsoi.keypoints[2].x == 1
        assert kpsoi.keypoints[2].y == 1
        assert kpsoi.keypoints[3].x == 10
        assert kpsoi.keypoints[3].y == 10
        assert kpsoi.keypoints[4].x == 20
        assert kpsoi.keypoints[4].y == 0
        assert kpsoi.keypoints[5].x == 20
        assert kpsoi.keypoints[5].y == 20

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_bbs.py" startline="1950" endline="1977" pcid="4849">
    def test_to_keypoints_on_image(self):
        bbsoi = ia.BoundingBoxesOnImage(
            [ia.BoundingBox(0, 1, 2, 3),
             ia.BoundingBox(10, 20, 30, 40)],
            shape=(1, 2, 3))

        kpsoi = bbsoi.to_keypoints_on_image()

        assert len(kpsoi.keypoints) == 2*4

        assert kpsoi.keypoints[0].x == 0
        assert kpsoi.keypoints[0].y == 1
        assert kpsoi.keypoints[1].x == 2
        assert kpsoi.keypoints[1].y == 1
        assert kpsoi.keypoints[2].x == 2
        assert kpsoi.keypoints[2].y == 3
        assert kpsoi.keypoints[3].x == 0
        assert kpsoi.keypoints[3].y == 3

        assert kpsoi.keypoints[4].x == 10
        assert kpsoi.keypoints[4].y == 20
        assert kpsoi.keypoints[5].x == 30
        assert kpsoi.keypoints[5].y == 20
        assert kpsoi.keypoints[6].x == 30
        assert kpsoi.keypoints[6].y == 40
        assert kpsoi.keypoints[7].x == 10
        assert kpsoi.keypoints[7].y == 40

</source>
</class>

<class classid="242" nclones="2" nlines="27" similarity="73">
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="3063" endline="3089" pcid="4614">
    def test_with_two_polygons(self):
        poly_oi = ia.PolygonsOnImage(
            [ia.Polygon([(1, 1), (8, 1), (8, 9), (1, 9)]),
             ia.Polygon([(2, 2), (16, 2), (16, 10), (2, 10)])],
            shape=(10, 11, 3))
        poly_oi_copy = poly_oi.copy()
        assert len(poly_oi_copy.polygons) == 2
        assert np.allclose(poly_oi_copy.polygons[0].exterior,
                           [(1, 1), (8, 1), (8, 9), (1, 9)],
                           rtol=0, atol=1e-4)
        assert np.allclose(poly_oi_copy.polygons[1].exterior,
                           [(2, 2), (16, 2), (16, 10), (2, 10)],
                           rtol=0, atol=1e-4)

        poly_oi_copy.shape = (20, 30, 3)
        assert poly_oi.shape == (10, 11, 3)
        assert poly_oi_copy.shape == (20, 30, 3)

        # make sure that changing the polygons only affects the copy
        poly_oi_copy.polygons = [ia.Polygon([(0, 0), (1, 0), (1, 1)])]
        assert np.allclose(poly_oi.polygons[0].exterior,
                           [(1, 1), (8, 1), (8, 9), (1, 9)],
                           rtol=0, atol=1e-4)
        assert np.allclose(poly_oi_copy.polygons[0].exterior,
                           [(0, 0), (1, 0), (1, 1)],
                           rtol=0, atol=1e-4)

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="3115" endline="3150" pcid="4617">
    def test_with_two_polygons(self):
        poly_oi = ia.PolygonsOnImage(
            [ia.Polygon([(1, 1), (8, 1), (8, 9), (1, 9)]),
             ia.Polygon([(2, 2), (16, 2), (16, 10), (2, 10)])],
            shape=(10, 11, 3))
        poly_oi_copy = poly_oi.deepcopy()
        assert len(poly_oi_copy.polygons) == 2
        assert np.allclose(poly_oi_copy.polygons[0].exterior,
                           [(1, 1), (8, 1), (8, 9), (1, 9)],
                           rtol=0, atol=1e-4)
        assert np.allclose(poly_oi_copy.polygons[1].exterior,
                           [(2, 2), (16, 2), (16, 10), (2, 10)],
                           rtol=0, atol=1e-4)

        poly_oi_copy.shape = (20, 30, 3)
        assert poly_oi.shape == (10, 11, 3)
        assert poly_oi_copy.shape == (20, 30, 3)

        # make sure that changing the polygons only affects the copy
        poly_oi_copy.polygons[0] = ia.Polygon([(0, 0), (1, 0), (1, 1)])
        assert np.allclose(poly_oi.polygons[0].exterior,
                           [(1, 1), (8, 1), (8, 9), (1, 9)],
                           rtol=0, atol=1e-4)
        assert np.allclose(poly_oi_copy.polygons[0].exterior,
                           [(0, 0), (1, 0), (1, 1)],
                           rtol=0, atol=1e-4)

        # make sure that the arrays were also copied
        poly_oi_copy.polygons[1].exterior[0][0] = 100
        assert np.allclose(poly_oi.polygons[1].exterior,
                           [(2, 2), (16, 2), (16, 10), (2, 10)],
                           rtol=0, atol=1e-4)
        assert np.allclose(poly_oi_copy.polygons[1].exterior,
                           [(100, 2), (16, 2), (16, 10), (2, 10)],
                           rtol=0, atol=1e-4)

</source>
</class>

<class classid="243" nclones="4" nlines="10" similarity="70">
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="3151" endline="3163" pcid="4618">
    def test_polygons_parameter_set(self):
        poly1 = ia.Polygon([(0, 0), (1, 0), (1, 1)])
        poly2 = ia.Polygon([(0+1, 0), (1+1, 0), (1+1, 1)])
        poly3 = ia.Polygon([(0+2, 0), (1+2, 0), (1+2, 1)])
        psoi = ia.PolygonsOnImage([poly1, poly2], shape=(40, 50, 3))

        psoi_copy = psoi.deepcopy(polygons=[poly3])

        assert psoi_copy is not psoi
        assert psoi_copy.shape == (40, 50, 3)
        assert len(psoi_copy.polygons) == 1
        assert psoi_copy.polygons[0].coords_almost_equals(poly3)

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="3164" endline="3177" pcid="4619">
    def test_shape_parameter_set(self):
        poly1 = ia.Polygon([(0, 0), (1, 0), (1, 1)])
        poly2 = ia.Polygon([(0+1, 0), (1+1, 0), (1+1, 1)])
        psoi = ia.PolygonsOnImage([poly1, poly2], shape=(40, 50, 3))

        psoi_copy = psoi.deepcopy(shape=(40+1, 50+1, 3))

        assert psoi_copy is not psoi
        assert psoi_copy.shape == (40+1, 50+1, 3)
        assert len(psoi_copy.polygons) == 2
        assert psoi_copy.polygons[0].coords_almost_equals(poly1)
        assert psoi_copy.polygons[1].coords_almost_equals(poly2)


</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_kps.py" startline="1317" endline="1329" pcid="5015">
    def test_deepcopy_shape_set(self):
        kp1 = ia.Keypoint(x=1, y=2)
        kp2 = ia.Keypoint(x=3, y=4)
        kpsoi = ia.KeypointsOnImage([kp1, kp2], shape=(40, 50, 3))

        kpsoi_copy = kpsoi.deepcopy(shape=(40+1, 50+1, 3))

        assert kpsoi_copy is not kpsoi
        assert kpsoi_copy.shape == (40+1, 50+1, 3)
        assert len(kpsoi_copy.keypoints) == 2
        assert kpsoi_copy.keypoints[0].coords_almost_equals(kp1)
        assert kpsoi_copy.keypoints[1].coords_almost_equals(kp2)

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_bbs.py" startline="2126" endline="2138" pcid="4860">
    def test_deepcopy_shape_set(self):
        bb1 = ia.BoundingBox(y1=10, x1=20, y2=30, x2=40)
        bb2 = ia.BoundingBox(y1=15, x1=25, y2=35, x2=51)
        bbsoi = ia.BoundingBoxesOnImage([bb1, bb2], shape=(40, 50, 3))

        bbsoi_copy = bbsoi.deepcopy(shape=(40+1, 50+1, 3))

        assert bbsoi_copy is not bbsoi
        assert bbsoi_copy.shape == (40+1, 50+1, 3)
        assert len(bbsoi_copy.bounding_boxes) == 2
        assert bbsoi_copy.bounding_boxes[0].coords_almost_equals(bb1)
        assert bbsoi_copy.bounding_boxes[1].coords_almost_equals(bb2)

</source>
</class>

<class classid="244" nclones="3" nlines="14" similarity="80">
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="3296" endline="3311" pcid="4630">
    def test_recover_from_line(self):
        cpr = _ConcavePolygonRecoverer()

        poly = [(0, 0), (1, 0), (2, 0)]
        old_polygon = ia.Polygon(poly)
        poly_concave = cpr.recover_from(poly, old_polygon)
        assert poly_concave.is_valid
        found = [False] * len(poly)
        for i, point in enumerate(poly):
            for point_ext in poly_concave.exterior:
                dist = np.sqrt((point[0] - point_ext[0])**2
                               + (point[1] - point_ext[1])**2)
                if dist < 0.025:
                    found[i] = True
        assert np.all(found)

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="3312" endline="3327" pcid="4631">
    def test_recover_from_polygon_with_duplicate_points(self):
        cpr = _ConcavePolygonRecoverer()

        poly = [(0, 0), (1, 0), (1, 0), (1, 1)]
        old_polygon = ia.Polygon(poly)
        poly_concave = cpr.recover_from(poly, old_polygon)
        assert poly_concave.is_valid
        found = [False] * len(poly)
        for i, point in enumerate(poly):
            for point_ext in poly_concave.exterior:
                dist = np.sqrt((point[0] - point_ext[0])**2
                               + (point[1] - point_ext[1])**2)
                if dist < 0.01:
                    found[i] = True
        assert np.all(found)

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_polys.py" startline="3328" endline="3344" pcid="4632">
    def test_recover_from_invalid_polygon(self):
        cpr = _ConcavePolygonRecoverer()
        poly = [(0, 0), (0.5, 0), (0.5, 1.2), (1, 0), (1, 1), (0, 1)]
        old_polygon = ia.Polygon(poly)
        poly_concave = cpr.recover_from(poly, old_polygon)
        assert poly_concave.is_valid
        found = [False] * len(poly)
        for i, point in enumerate(poly):
            for point_ext in poly_concave.exterior:
                dist = np.sqrt(
                    (point[0] - point_ext[0])**2
                    + (point[1] - point_ext[1])**2
                )
                if dist < 0.025:
                    found[i] = True
        assert np.all(found)

</source>
</class>

<class classid="245" nclones="2" nlines="15" similarity="93">
<source file="systems/imgaug-0.4.0/test/augmentables/test_bbs.py" startline="694" endline="712" pcid="4736">
    def test_draw_label_on_image_mocked(self, mock_drawer):
        mock_drawer.return_value = mock_drawer
        image = np.zeros((10, 10, 3), dtype=np.uint8)
        bb = ia.BoundingBox(y1=1, x1=1, y2=3, x2=3)

        result = bb.draw_label_on_image(image)

        kwargs = mock_drawer.call_args_list[0][1]
        assert kwargs["color"] == (0, 255, 0)
        assert kwargs["color_text"] is None
        assert kwargs["color_bg"] is None
        assert np.isclose(kwargs["alpha"], 1.0)
        assert kwargs["size"] == 1
        assert kwargs["size_text"] == 20
        assert kwargs["height"] == 30
        assert kwargs["raise_if_out_of_image"] is False

        assert mock_drawer.draw_on_image.call_count == 1

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_bbs.py" startline="714" endline="732" pcid="4737">
    def test_draw_label_on_image_mocked_inplace(self, mock_drawer):
        mock_drawer.return_value = mock_drawer
        image = np.zeros((10, 10, 3), dtype=np.uint8)
        bb = ia.BoundingBox(y1=1, x1=1, y2=3, x2=3)

        result = bb.draw_label_on_image(image, copy=False)

        kwargs = mock_drawer.call_args_list[0][1]
        assert kwargs["color"] == (0, 255, 0)
        assert kwargs["color_text"] is None
        assert kwargs["color_bg"] is None
        assert np.isclose(kwargs["alpha"], 1.0)
        assert kwargs["size"] == 1
        assert kwargs["size_text"] == 20
        assert kwargs["height"] == 30
        assert kwargs["raise_if_out_of_image"] is False

        assert mock_drawer.draw_on_image_.call_count == 1

</source>
</class>

<class classid="246" nclones="3" nlines="11" similarity="72">
<source file="systems/imgaug-0.4.0/test/augmentables/test_bbs.py" startline="823" endline="836" pcid="4746">
    def test_draw_box_on_image_bb_outside_of_image(self):
        image = np.zeros((10, 10, 3), dtype=np.uint8)
        bb = ia.BoundingBox(y1=-1, x1=-1, y2=2, x2=2)
        bb_mask = np.zeros(image.shape[0:2], dtype=np.bool)
        bb_mask[2, 0:3] = True
        bb_mask[0:3, 2] = True

        image_bb = bb.draw_box_on_image(
            image, color=[255, 255, 255], alpha=1.0, size=1, copy=True,
            raise_if_out_of_image=False)

        assert np.all(image_bb[bb_mask] == [255, 255, 255])
        assert np.all(image_bb[~bb_mask] == [0, 0, 0])

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_bbs.py" startline="837" endline="850" pcid="4747">
    def test_draw_box_on_image_bb_outside_of_image_and_very_small(self):
        image, bb, bb_mask = self._get_standard_draw_box_on_image_vars()
        bb = ia.BoundingBox(y1=-1, x1=-1, y2=1, x2=1)
        bb_mask = np.zeros(image.shape[0:2], dtype=np.bool)
        bb_mask[0:1+1, 1] = True
        bb_mask[1, 0:1+1] = True

        image_bb = bb.draw_box_on_image(
            image, color=[255, 255, 255], alpha=1.0, size=1, copy=True,
            raise_if_out_of_image=False)

        assert np.all(image_bb[bb_mask] == [255, 255, 255])
        assert np.all(image_bb[~bb_mask] == [0, 0, 0])

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_bbs.py" startline="851" endline="863" pcid="4748">
    def test_draw_box_on_image_size_2(self):
        image, bb, _ = self._get_standard_draw_box_on_image_vars()
        bb_mask = np.zeros(image.shape[0:2], dtype=np.bool)
        bb_mask[0:5, 0:5] = True
        bb_mask[2, 2] = False

        image_bb = bb.draw_box_on_image(
            image, color=[255, 255, 255], alpha=1.0, size=2, copy=True,
            raise_if_out_of_image=False)

        assert np.all(image_bb[bb_mask] == [255, 255, 255])
        assert np.all(image_bb[~bb_mask] == [0, 0, 0])

</source>
</class>

<class classid="247" nclones="3" nlines="10" similarity="70">
<source file="systems/imgaug-0.4.0/test/augmentables/test_bbs.py" startline="918" endline="930" pcid="4755">
    def test_extract_from_image_bb_partially_out_of_image(self):
        image = iarandom.RNG(1234).integers(0, 255, size=(10, 10, 3))

        bb = ia.BoundingBox(y1=8, y2=11, x1=8, x2=11)
        image_sub = bb.extract_from_image(image)

        image_pad = np.pad(
            image,
            ((0, 1), (0, 1), (0, 0)),
            mode="constant",
            constant_values=0)  # pad at bottom and right each 1px (black)
        assert np.array_equal(image_sub, image_pad[8:11, 8:11, :])

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_bbs.py" startline="931" endline="943" pcid="4756">
    def test_extract_from_image_bb_partially_out_of_image_no_channels(self):
        image = iarandom.RNG(1234).integers(0, 255, size=(10, 10))

        bb = ia.BoundingBox(y1=8, y2=11, x1=8, x2=11)
        image_sub = bb.extract_from_image(image)

        image_pad = np.pad(
            image,
            ((0, 1), (0, 1)),
            mode="constant",
            constant_values=0)  # pad at bottom and right each 1px (black)
        assert np.array_equal(image_sub, image_pad[8:11, 8:11])

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_bbs.py" startline="944" endline="956" pcid="4757">
    def test_extract_from_image_bb_partially_out_of_image_top_left(self):
        image = iarandom.RNG(1234).integers(0, 255, size=(10, 10, 3))

        bb = ia.BoundingBox(y1=-1, y2=3, x1=-1, x2=4)
        image_sub = bb.extract_from_image(image)

        image_pad = np.pad(
            image,
            ((1, 0), (1, 0), (0, 0)),
            mode="constant",
            constant_values=0)  # pad at top and left each 1px (black)
        assert np.array_equal(image_sub, image_pad[0:4, 0:5, :])

</source>
</class>

<class classid="248" nclones="4" nlines="15" similarity="70">
<source file="systems/imgaug-0.4.0/test/augmentables/test_bbs.py" startline="1311" endline="1327" pcid="4799">
    def test_on_same_height_width(self):
        bb1 = ia.BoundingBox(y1=10, x1=20, y2=30, x2=40)
        bb2 = ia.BoundingBox(y1=15, x1=25, y2=35, x2=45)
        bbsoi = ia.BoundingBoxesOnImage([bb1, bb2], shape=(40, 50, 3))

        bbsoi_projected = self._func(bbsoi, (40, 50))

        assert bbsoi_projected.bounding_boxes[0].y1 == 10
        assert bbsoi_projected.bounding_boxes[0].x1 == 20
        assert bbsoi_projected.bounding_boxes[0].y2 == 30
        assert bbsoi_projected.bounding_boxes[0].x2 == 40
        assert bbsoi_projected.bounding_boxes[1].y1 == 15
        assert bbsoi_projected.bounding_boxes[1].x1 == 25
        assert bbsoi_projected.bounding_boxes[1].y2 == 35
        assert bbsoi_projected.bounding_boxes[1].x2 == 45
        assert bbsoi_projected.shape == (40, 50)

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_bbs.py" startline="1392" endline="1408" pcid="4807">
    def test_clip_out_of_image(self):
        bb1 = ia.BoundingBox(y1=10, x1=20, y2=30, x2=40)
        bb2 = ia.BoundingBox(y1=15, x1=25, y2=35, x2=51)
        bbsoi = ia.BoundingBoxesOnImage([bb1, bb2], shape=(40, 50, 3))

        bbsoi_clip = self._func(bbsoi)

        assert len(bbsoi_clip.bounding_boxes) == 2
        assert bbsoi_clip.bounding_boxes[0].y1 == 10
        assert bbsoi_clip.bounding_boxes[0].x1 == 20
        assert bbsoi_clip.bounding_boxes[0].y2 == 30
        assert bbsoi_clip.bounding_boxes[0].x2 == 40
        assert bbsoi_clip.bounding_boxes[1].y1 == 15
        assert bbsoi_clip.bounding_boxes[1].x1 == 25
        assert bbsoi_clip.bounding_boxes[1].y2 == 35
        assert np.isclose(bbsoi_clip.bounding_boxes[1].x2, 50)

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_bbs.py" startline="2049" endline="2069" pcid="4855">
    def test_copy(self):
        bb1 = ia.BoundingBox(y1=10, x1=20, y2=30, x2=40)
        bb2 = ia.BoundingBox(y1=15, x1=25, y2=35, x2=51)
        bbsoi = ia.BoundingBoxesOnImage([bb1, bb2], shape=(40, 50, 3))

        bbsoi_copy = bbsoi.copy()

        assert len(bbsoi.bounding_boxes) == 2
        assert bbsoi_copy.bounding_boxes[0].y1 == 10
        assert bbsoi_copy.bounding_boxes[0].x1 == 20
        assert bbsoi_copy.bounding_boxes[0].y2 == 30
        assert bbsoi_copy.bounding_boxes[0].x2 == 40
        assert bbsoi_copy.bounding_boxes[1].y1 == 15
        assert bbsoi_copy.bounding_boxes[1].x1 == 25
        assert bbsoi_copy.bounding_boxes[1].y2 == 35
        assert bbsoi_copy.bounding_boxes[1].x2 == 51

        bbsoi_copy.bounding_boxes[0].y1 = 0
        assert bbsoi.bounding_boxes[0].y1 == 0
        assert bbsoi_copy.bounding_boxes[0].y1 == 0

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_bbs.py" startline="2093" endline="2113" pcid="4858">
    def test_deepcopy(self):
        bb1 = ia.BoundingBox(y1=10, x1=20, y2=30, x2=40)
        bb2 = ia.BoundingBox(y1=15, x1=25, y2=35, x2=51)
        bbsoi = ia.BoundingBoxesOnImage([bb1, bb2], shape=(40, 50, 3))

        bbsoi_copy = bbsoi.deepcopy()

        assert len(bbsoi.bounding_boxes) == 2
        assert bbsoi_copy.bounding_boxes[0].y1 == 10
        assert bbsoi_copy.bounding_boxes[0].x1 == 20
        assert bbsoi_copy.bounding_boxes[0].y2 == 30
        assert bbsoi_copy.bounding_boxes[0].x2 == 40
        assert bbsoi_copy.bounding_boxes[1].y1 == 15
        assert bbsoi_copy.bounding_boxes[1].x1 == 25
        assert bbsoi_copy.bounding_boxes[1].y2 == 35
        assert bbsoi_copy.bounding_boxes[1].x2 == 51

        bbsoi_copy.bounding_boxes[0].y1 = 0
        assert bbsoi.bounding_boxes[0].y1 == 10
        assert bbsoi_copy.bounding_boxes[0].y1 == 0

</source>
</class>

<class classid="249" nclones="2" nlines="14" similarity="92">
<source file="systems/imgaug-0.4.0/test/augmentables/test_bbs.py" startline="1328" endline="1344" pcid="4800">
    def test_on_upscaled_by_2(self):
        bb1 = ia.BoundingBox(y1=10, x1=20, y2=30, x2=40)
        bb2 = ia.BoundingBox(y1=15, x1=25, y2=35, x2=45)
        bbsoi = ia.BoundingBoxesOnImage([bb1, bb2], shape=(40, 50, 3))

        bbsoi_projected = self._func(bbsoi, (40*2, 50*2, 3))

        assert bbsoi_projected.bounding_boxes[0].y1 == 10*2
        assert bbsoi_projected.bounding_boxes[0].x1 == 20*2
        assert bbsoi_projected.bounding_boxes[0].y2 == 30*2
        assert bbsoi_projected.bounding_boxes[0].x2 == 40*2
        assert bbsoi_projected.bounding_boxes[1].y1 == 15*2
        assert bbsoi_projected.bounding_boxes[1].x1 == 25*2
        assert bbsoi_projected.bounding_boxes[1].y2 == 35*2
        assert bbsoi_projected.bounding_boxes[1].x2 == 45*2
        assert bbsoi_projected.shape == (40*2, 50*2, 3)

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_bbs.py" startline="1345" endline="1361" pcid="4801">
    def test_on_upscaled_by_2_with_shape_given_as_array(self):
        bb1 = ia.BoundingBox(y1=10, x1=20, y2=30, x2=40)
        bb2 = ia.BoundingBox(y1=15, x1=25, y2=35, x2=45)
        bbsoi = ia.BoundingBoxesOnImage([bb1, bb2], shape=(40, 50, 3))

        bbsoi_projected = self._func(bbsoi, np.zeros((40*2, 50*2, 3), dtype=np.uint8))

        assert bbsoi_projected.bounding_boxes[0].y1 == 10*2
        assert bbsoi_projected.bounding_boxes[0].x1 == 20*2
        assert bbsoi_projected.bounding_boxes[0].y2 == 30*2
        assert bbsoi_projected.bounding_boxes[0].x2 == 40*2
        assert bbsoi_projected.bounding_boxes[1].y1 == 15*2
        assert bbsoi_projected.bounding_boxes[1].x1 == 25*2
        assert bbsoi_projected.bounding_boxes[1].y2 == 35*2
        assert bbsoi_projected.bounding_boxes[1].x2 == 45*2
        assert bbsoi_projected.shape == (40*2, 50*2, 3)

</source>
</class>

<class classid="250" nclones="2" nlines="15" similarity="86">
<source file="systems/imgaug-0.4.0/test/augmentables/test_bbs.py" startline="1484" endline="1502" pcid="4819">
    def test_from_xyxy_array_float(self):
        xyxy = np.float32([
            [0.0, 0.0, 1.0, 1.0],
            [1.0, 2.0, 3.0, 4.0]
        ])

        bbsoi = ia.BoundingBoxesOnImage.from_xyxy_array(xyxy, shape=(40, 50, 3))

        assert len(bbsoi.bounding_boxes) == 2
        assert np.allclose(bbsoi.bounding_boxes[0].x1, 0.0)
        assert np.allclose(bbsoi.bounding_boxes[0].y1, 0.0)
        assert np.allclose(bbsoi.bounding_boxes[0].x2, 1.0)
        assert np.allclose(bbsoi.bounding_boxes[0].y2, 1.0)
        assert np.allclose(bbsoi.bounding_boxes[1].x1, 1.0)
        assert np.allclose(bbsoi.bounding_boxes[1].y1, 2.0)
        assert np.allclose(bbsoi.bounding_boxes[1].x2, 3.0)
        assert np.allclose(bbsoi.bounding_boxes[1].y2, 4.0)
        assert bbsoi.shape == (40, 50, 3)

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_bbs.py" startline="1528" endline="1546" pcid="4821">
    def test_from_xyxy_array_int32(self):
        xyxy = np.int32([
            [0, 0, 1, 1],
            [1, 2, 3, 4]
        ])

        bbsoi = ia.BoundingBoxesOnImage.from_xyxy_array(xyxy, shape=(40, 50, 3))

        assert len(bbsoi.bounding_boxes) == 2
        assert np.allclose(bbsoi.bounding_boxes[0].x1, 0.0)
        assert np.allclose(bbsoi.bounding_boxes[0].y1, 0.0)
        assert np.allclose(bbsoi.bounding_boxes[0].x2, 1.0)
        assert np.allclose(bbsoi.bounding_boxes[0].y2, 1.0)
        assert np.allclose(bbsoi.bounding_boxes[1].x1, 1.0)
        assert np.allclose(bbsoi.bounding_boxes[1].y1, 2.0)
        assert np.allclose(bbsoi.bounding_boxes[1].x2, 3.0)
        assert np.allclose(bbsoi.bounding_boxes[1].y2, 4.0)
        assert bbsoi.shape == (40, 50, 3)

</source>
</class>

<class classid="251" nclones="2" nlines="14" similarity="85">
<source file="systems/imgaug-0.4.0/test/augmentables/test_bbs.py" startline="1555" endline="1572" pcid="4823">
    def test_from_point_soups__2d_array(self):
        xy = np.float32([
            [7, 3,
             11, 5,
             1, 7,
             12, 19]
        ])

        bbsoi = ia.BoundingBoxesOnImage.from_point_soups(
            xy, shape=(40, 50, 3))

        assert len(bbsoi.bounding_boxes) == 1
        assert bbsoi.bounding_boxes[0].x1 == 1
        assert bbsoi.bounding_boxes[0].y1 == 3
        assert bbsoi.bounding_boxes[0].x2 == 12
        assert bbsoi.bounding_boxes[0].y2 == 19
        assert bbsoi.shape == (40, 50, 3)

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_bbs.py" startline="1593" endline="1610" pcid="4825">
    def test_from_point_soups__2d_list(self):
        xy = [
            [7, 3,
             11, 5,
             1, 7,
             12, 19]
        ]

        bbsoi = ia.BoundingBoxesOnImage.from_point_soups(
            xy, shape=(40, 50, 3))

        assert len(bbsoi.bounding_boxes) == 1
        assert bbsoi.bounding_boxes[0].x1 == 1
        assert bbsoi.bounding_boxes[0].y1 == 3
        assert bbsoi.bounding_boxes[0].x2 == 12
        assert bbsoi.bounding_boxes[0].y2 == 19
        assert bbsoi.shape == (40, 50, 3)

</source>
</class>

<class classid="252" nclones="4" nlines="18" similarity="78">
<source file="systems/imgaug-0.4.0/test/augmentables/test_bbs.py" startline="1703" endline="1723" pcid="4835">
    def test_fill_from_xyxy_array___array_with_two_coords(self):
        xyxy = np.array(
            [(100, 101, 102, 103),
             (200, 201, 202, 203)], dtype=np.float32)
        bbsoi = ia.BoundingBoxesOnImage(
            [ia.BoundingBox(1, 2, 3, 4),
             ia.BoundingBox(10, 20, 30, 40)],
            shape=(2, 2, 3))

        bbsoi = bbsoi.fill_from_xyxy_array_(xyxy)

        assert len(bbsoi.bounding_boxes) == 2
        assert bbsoi.bounding_boxes[0].x1 == 100
        assert bbsoi.bounding_boxes[0].y1 == 101
        assert bbsoi.bounding_boxes[0].x2 == 102
        assert bbsoi.bounding_boxes[0].y2 == 103
        assert bbsoi.bounding_boxes[1].x1 == 200
        assert bbsoi.bounding_boxes[1].y1 == 201
        assert bbsoi.bounding_boxes[1].x2 == 202
        assert bbsoi.bounding_boxes[1].y2 == 203

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_bbs.py" startline="1783" endline="1804" pcid="4840">
    def test_fill_from_xy_array___list_with_two_coords(self):
        xy = [(100, 101),
              (102, 103),
              (200, 201),
              (202, 203)]
        bbsoi = ia.BoundingBoxesOnImage(
            [ia.BoundingBox(1, 2, 3, 4),
             ia.BoundingBox(10, 20, 30, 40)],
            shape=(2, 2, 3))

        bbsoi = bbsoi.fill_from_xy_array_(xy)

        assert len(bbsoi.bounding_boxes) == 2
        assert bbsoi.bounding_boxes[0].x1 == 100
        assert bbsoi.bounding_boxes[0].y1 == 101
        assert bbsoi.bounding_boxes[0].x2 == 102
        assert bbsoi.bounding_boxes[0].y2 == 103
        assert bbsoi.bounding_boxes[1].x1 == 200
        assert bbsoi.bounding_boxes[1].y1 == 201
        assert bbsoi.bounding_boxes[1].x2 == 202
        assert bbsoi.bounding_boxes[1].y2 == 203

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_bbs.py" startline="1760" endline="1782" pcid="4839">
    def test_fill_from_xy_array___array_with_two_coords(self):
        xy = np.array(
            [(100, 101),
             (102, 103),
             (200, 201),
             (202, 203)], dtype=np.float32)
        bbsoi = ia.BoundingBoxesOnImage(
            [ia.BoundingBox(1, 2, 3, 4),
             ia.BoundingBox(10, 20, 30, 40)],
            shape=(2, 2, 3))

        bbsoi = bbsoi.fill_from_xy_array_(xy)

        assert len(bbsoi.bounding_boxes) == 2
        assert bbsoi.bounding_boxes[0].x1 == 100
        assert bbsoi.bounding_boxes[0].y1 == 101
        assert bbsoi.bounding_boxes[0].x2 == 102
        assert bbsoi.bounding_boxes[0].y2 == 103
        assert bbsoi.bounding_boxes[1].x1 == 200
        assert bbsoi.bounding_boxes[1].y1 == 201
        assert bbsoi.bounding_boxes[1].x2 == 202
        assert bbsoi.bounding_boxes[1].y2 == 203

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_bbs.py" startline="1724" endline="1743" pcid="4836">
    def test_fill_from_xyxy_array___list_with_two_coords(self):
        xyxy = [(100, 101, 102, 103),
                (200, 201, 202, 203)]
        bbsoi = ia.BoundingBoxesOnImage(
            [ia.BoundingBox(1, 2, 3, 4),
             ia.BoundingBox(10, 20, 30, 40)],
            shape=(2, 2, 3))

        bbsoi = bbsoi.fill_from_xyxy_array_(xyxy)

        assert len(bbsoi.bounding_boxes) == 2
        assert bbsoi.bounding_boxes[0].x1 == 100
        assert bbsoi.bounding_boxes[0].y1 == 101
        assert bbsoi.bounding_boxes[0].x2 == 102
        assert bbsoi.bounding_boxes[0].y2 == 103
        assert bbsoi.bounding_boxes[1].x1 == 200
        assert bbsoi.bounding_boxes[1].y1 == 201
        assert bbsoi.bounding_boxes[1].x2 == 202
        assert bbsoi.bounding_boxes[1].y2 == 203

</source>
</class>

<class classid="253" nclones="2" nlines="15" similarity="93">
<source file="systems/imgaug-0.4.0/test/augmentables/test_bbs.py" startline="1888" endline="1905" pcid="4846">
    def test_shift_(self):
        bb1 = ia.BoundingBox(y1=10, x1=20, y2=30, x2=40)
        bb2 = ia.BoundingBox(y1=15, x1=25, y2=35, x2=51)
        bbsoi = ia.BoundingBoxesOnImage([bb1, bb2], shape=(40, 50, 3))

        bbsoi_shifted = bbsoi.shift_(y=2)

        assert len(bbsoi_shifted.bounding_boxes) == 2
        assert bbsoi_shifted.bounding_boxes[0].y1 == 10 + 2
        assert bbsoi_shifted.bounding_boxes[0].x1 == 20
        assert bbsoi_shifted.bounding_boxes[0].y2 == 30 + 2
        assert bbsoi_shifted.bounding_boxes[0].x2 == 40
        assert bbsoi_shifted.bounding_boxes[1].y1 == 15 + 2
        assert bbsoi_shifted.bounding_boxes[1].x1 == 25
        assert bbsoi_shifted.bounding_boxes[1].y2 == 35 + 2
        assert bbsoi_shifted.bounding_boxes[1].x2 == 51
        assert bbsoi_shifted is bbsoi

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_bbs.py" startline="1906" endline="1923" pcid="4847">
    def test_shift(self):
        bb1 = ia.BoundingBox(y1=10, x1=20, y2=30, x2=40)
        bb2 = ia.BoundingBox(y1=15, x1=25, y2=35, x2=51)
        bbsoi = ia.BoundingBoxesOnImage([bb1, bb2], shape=(40, 50, 3))

        bbsoi_shifted = bbsoi.shift(y=2)

        assert len(bbsoi_shifted.bounding_boxes) == 2
        assert bbsoi_shifted.bounding_boxes[0].y1 == 10 + 2
        assert bbsoi_shifted.bounding_boxes[0].x1 == 20
        assert bbsoi_shifted.bounding_boxes[0].y2 == 30 + 2
        assert bbsoi_shifted.bounding_boxes[0].x2 == 40
        assert bbsoi_shifted.bounding_boxes[1].y1 == 15 + 2
        assert bbsoi_shifted.bounding_boxes[1].x1 == 25
        assert bbsoi_shifted.bounding_boxes[1].y2 == 35 + 2
        assert bbsoi_shifted.bounding_boxes[1].x2 == 51
        assert bbsoi_shifted is not bbsoi

</source>
</class>

<class classid="254" nclones="2" nlines="12" similarity="83">
<source file="systems/imgaug-0.4.0/test/augmentables/test_bbs.py" startline="2171" endline="2185" pcid="4865">
    def test_string_conversion(self):
        bb1 = ia.BoundingBox(y1=10, x1=20, y2=30, x2=40)
        bb2 = ia.BoundingBox(y1=15, x1=25, y2=35, x2=51)
        bbsoi = ia.BoundingBoxesOnImage([bb1, bb2], shape=(40, 50, 3))

        bb1_expected = "BoundingBox(x1=20.0000, y1=10.0000, " \
                       "x2=40.0000, y2=30.0000, label=None)"
        bb2_expected = "BoundingBox(x1=25.0000, y1=15.0000, " \
                       "x2=51.0000, y2=35.0000, label=None)"
        expected = "BoundingBoxesOnImage([%s, %s], shape=(40, 50, 3))" % (
            bb1_expected, bb2_expected)
        assert (
            bbsoi.__repr__()
            == bbsoi.__str__()
            == expected
</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_bbs.py" startline="2186" endline="2201" pcid="4866">
        )

    def test_string_conversion_labels_are_not_none(self):
        bb1 = ia.BoundingBox(y1=10, x1=20, y2=30, x2=40, label="foo")
        bb2 = ia.BoundingBox(y1=15, x1=25, y2=35, x2=51, label="bar")
        bbsoi = ia.BoundingBoxesOnImage([bb1, bb2], shape=(40, 50, 3))

        bb1_expected = "BoundingBox(x1=20.0000, y1=10.0000, " \
                       "x2=40.0000, y2=30.0000, label=foo)"
        bb2_expected = "BoundingBox(x1=25.0000, y1=15.0000, " \
                       "x2=51.0000, y2=35.0000, label=bar)"
        expected = "BoundingBoxesOnImage([%s, %s], shape=(40, 50, 3))" % (
            bb1_expected, bb2_expected)
        assert (
            bbsoi.__repr__()
            == bbsoi.__str__()
</source>
</class>

<class classid="255" nclones="2" nlines="20" similarity="95">
<source file="systems/imgaug-0.4.0/test/augmentables/test_bbs.py" startline="2303" endline="2329" pcid="4877">
        assert np.isclose(y1, bb.y1 - 1 - height)
        assert np.isclose(x2, bb.x2 + size)
        assert np.isclose(y2, bb.y1 - 1)

    def test__draw_label_arr__label_is_none(self):
        drawer = _LabelOnImageDrawer()
        height = 50
        width = 100
        nb_channels = 3
        color_text = np.uint8([0, 255, 0])
        color_bg = np.uint8([255, 0, 0])
        size_text = 20

        label_arr = drawer._draw_label_arr(None, height, width, nb_channels,
                                           np.uint8,
                                           color_text, color_bg, size_text)

        frac_textcolor = np.average(
            np.min(label_arr == color_text.reshape((1, 1, -1)), axis=-1)
        )
        frac_bgcolor = np.average(
            np.min(label_arr == color_bg.reshape((1, 1, -1)), axis=-1)
        )
        assert label_arr.dtype.name == "uint8"
        assert label_arr.shape == (height, width, nb_channels)
        assert frac_textcolor > 0.02
        assert frac_bgcolor > 0.8
</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_bbs.py" startline="2330" endline="2356" pcid="4878">
        # not all pixels of the text might be drawn with exactly the text
        # color
        assert frac_textcolor + frac_bgcolor > 0.75

    def test__draw_label_arr__label_is_str(self):
        drawer = _LabelOnImageDrawer()
        height = 50
        width = 100
        nb_channels = 3
        color_text = np.uint8([0, 255, 0])
        color_bg = np.uint8([255, 0, 0])
        size_text = 20

        label_arr = drawer._draw_label_arr("Fooo", height, width, nb_channels,
                                           np.uint8,
                                           color_text, color_bg, size_text)

        frac_textcolor = np.average(
            np.min(label_arr == color_text.reshape((1, 1, -1)), axis=-1)
        )
        frac_bgcolor = np.average(
            np.min(label_arr == color_bg.reshape((1, 1, -1)), axis=-1)
        )
        assert label_arr.dtype.name == "uint8"
        assert label_arr.shape == (height, width, nb_channels)
        assert frac_textcolor > 0.02
        assert frac_bgcolor > 0.8
</source>
</class>

<class classid="256" nclones="2" nlines="15" similarity="86">
<source file="systems/imgaug-0.4.0/test/augmentables/test_bbs.py" startline="2357" endline="2374" pcid="4879">
        # not all pixels of the text might be drawn with exactly the text
        # color
        assert frac_textcolor + frac_bgcolor > 0.75

    def test__blend_label_arr__alpha_is_1(self):
        drawer = _LabelOnImageDrawer(alpha=1)
        image = np.full((50, 60, 3), 100, dtype=np.uint8)
        label_arr = np.full((10, 20, 3), 200, dtype=np.uint8)
        x1 = 15
        x2 = 15 + 20
        y1 = 10
        y2 = 10 + 10

        image_blend = drawer._blend_label_arr_with_image_(image, label_arr,
                                                          x1, y1, x2, y2)

        assert np.all(image_blend[:, :15, :] == 100)
        assert np.all(image_blend[:, 15+20:, :] == 100)
</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_bbs.py" startline="2375" endline="2391" pcid="4880">
        assert np.all(image_blend[:10, :, :] == 100)
        assert np.all(image_blend[10+10:, :, :] == 100)
        assert np.all(image_blend[10:10+10, 15:15+20, :] == 200)

    def test__blend_label_arr__alpha_is_075(self):
        drawer = _LabelOnImageDrawer(alpha=0.75)
        image = np.full((50, 60, 3), 100, dtype=np.uint8)
        label_arr = np.full((10, 20, 3), 200, dtype=np.uint8)
        x1 = 15
        x2 = 15 + 20
        y1 = 10
        y2 = 10 + 10

        image_blend = drawer._blend_label_arr_with_image_(image, label_arr,
                                                          x1, y1, x2, y2)

        assert np.all(image_blend[:, :15, :] == 100)
</source>
</class>

<class classid="257" nclones="2" nlines="13" similarity="84">
<source file="systems/imgaug-0.4.0/test/augmentables/test_kps.py" startline="290" endline="305" pcid="4924">
    def test_generate_similar_points_manhattan_1_step_list(self):
        kp = ia.Keypoint(y=4, x=5)
        kps_manhatten = kp.generate_similar_points_manhattan(
            1, 1.0, return_array=False)
        assert len(kps_manhatten) == 5
        expected = [(4, 5), (3, 5), (4, 6), (5, 5), (4, 4)]
        for y, x in expected:
            assert any([
                np.allclose(
                    [y, x],
                    [kp_manhatten.y, kp_manhatten.x]
                )
                for kp_manhatten
                in kps_manhatten
            ])

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_kps.py" startline="306" endline="321" pcid="4925">
    def test_generate_similar_points_manhattan_1_step_array(self):
        kp = ia.Keypoint(y=4, x=5)
        kps_manhatten = kp.generate_similar_points_manhattan(
            1, 1.0, return_array=True)
        assert kps_manhatten.shape == (5, 2)
        expected = [(4, 5), (3, 5), (4, 6), (5, 5), (4, 4)]
        for y, x in expected:
            assert any([
                np.allclose(
                    [y, x],
                    [kp_manhatten_y, kp_manhatten_x]
                )
                for kp_manhatten_x, kp_manhatten_y
                in kps_manhatten
            ])

</source>
</class>

<class classid="258" nclones="9" nlines="13" similarity="75">
<source file="systems/imgaug-0.4.0/test/augmentables/test_kps.py" startline="620" endline="635" pcid="4962">
    def test_draw_on_image(self):
        kps = [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=4)]
        kpi = ia.KeypointsOnImage(keypoints=kps, shape=(5, 5, 3))
        image = np.zeros((5, 5, 3), dtype=np.uint8) + 10

        kps_mask = np.zeros(image.shape[0:2], dtype=np.bool)
        kps_mask[2, 1] = 1
        kps_mask[4, 3] = 1

        image_kps = kpi.draw_on_image(
            image, color=[0, 255, 0], size=1, copy=True,
            raise_if_out_of_image=False)

        assert np.all(image_kps[kps_mask] == [0, 255, 0])
        assert np.all(image_kps[~kps_mask] == [10, 10, 10])

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_kps.py" startline="726" endline="744" pcid="4968">
    def test_draw_on_image_keypoint_is_outside_of_image(self):
        kps = [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=4)]
        kpi = ia.KeypointsOnImage(
            keypoints=kps + [ia.Keypoint(x=100, y=100)],
            shape=(5, 5, 3)
        )
        image = np.zeros((5, 5, 3), dtype=np.uint8) + 10

        kps_mask = np.zeros(image.shape[0:2], dtype=np.bool)
        kps_mask[2, 1] = 1
        kps_mask[4, 3] = 1

        image_kps = kpi.draw_on_image(
            image, color=[0, 255, 0], size=1, copy=True,
            raise_if_out_of_image=False)

        assert np.all(image_kps[kps_mask] == [0, 255, 0])
        assert np.all(image_kps[~kps_mask] == [10, 10, 10])

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_kps.py" startline="706" endline="725" pcid="4967">
    def test_draw_on_image_copy_is_false(self):
        kps = [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=4)]
        kpi = ia.KeypointsOnImage(keypoints=kps, shape=(5, 5, 3))
        image = np.zeros((5, 5, 3), dtype=np.uint8) + 10

        kps_mask = np.zeros(image.shape[0:2], dtype=np.bool)
        kps_mask[2, 1] = 1
        kps_mask[4, 3] = 1

        image2 = np.copy(image)
        image_kps = kpi.draw_on_image(
            image2, color=[0, 255, 0], size=1, copy=False,
            raise_if_out_of_image=False)

        assert np.all(image2 == image_kps)
        assert np.all(image_kps[kps_mask] == [0, 255, 0])
        assert np.all(image_kps[~kps_mask] == [10, 10, 10])
        assert np.all(image2[kps_mask] == [0, 255, 0])
        assert np.all(image2[~kps_mask] == [10, 10, 10])

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_kps.py" startline="690" endline="705" pcid="4966">
    def test_draw_on_image_single_int_as_color(self):
        kps = [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=4)]
        kpi = ia.KeypointsOnImage(keypoints=kps, shape=(5, 5, 3))
        image = np.zeros((5, 5, 3), dtype=np.uint8) + 10

        kps_mask = np.zeros(image.shape[0:2], dtype=np.bool)
        kps_mask[2, 1] = 1
        kps_mask[4, 3] = 1

        image_kps = kpi.draw_on_image(
            image, color=255, size=1, copy=True,
            raise_if_out_of_image=False)

        assert np.all(image_kps[kps_mask] == [255, 255, 255])
        assert np.all(image_kps[~kps_mask] == [10, 10, 10])

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_kps.py" startline="760" endline="777" pcid="4970">
    def test_draw_on_image_one_kp_at_bottom_right_corner(self):
        kps = [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=4)]
        kpi = ia.KeypointsOnImage(
            keypoints=kps + [ia.Keypoint(x=5, y=5)],
            shape=(5, 5, 3))
        image = np.zeros((5, 5, 3), dtype=np.uint8) + 10

        kps_mask = np.zeros(image.shape[0:2], dtype=np.bool)
        kps_mask[2, 1] = 1
        kps_mask[4, 3] = 1

        image_kps = kpi.draw_on_image(
            image, color=[0, 255, 0], size=1, copy=True,
            raise_if_out_of_image=False)

        assert np.all(image_kps[kps_mask] == [0, 255, 0])
        assert np.all(image_kps[~kps_mask] == [10, 10, 10])

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_kps.py" startline="655" endline="673" pcid="4964">
    def test_draw_on_image_size_3(self):
        kps = [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=4)]
        kpi = ia.KeypointsOnImage(keypoints=kps, shape=(5, 5, 3))
        image = np.zeros((5, 5, 3), dtype=np.uint8) + 10

        kps_mask = np.zeros(image.shape[0:2], dtype=np.bool)
        kps_mask[2, 1] = 1
        kps_mask[4, 3] = 1

        image_kps = kpi.draw_on_image(
            image, color=[0, 255, 0], size=3, copy=True,
            raise_if_out_of_image=False)
        kps_mask_size3 = np.copy(kps_mask)
        kps_mask_size3[2-1:2+1+1, 1-1:1+1+1] = 1
        kps_mask_size3[4-1:4+1+1, 3-1:3+1+1] = 1

        assert np.all(image_kps[kps_mask_size3] == [0, 255, 0])
        assert np.all(image_kps[~kps_mask_size3] == [10, 10, 10])

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_kps.py" startline="674" endline="689" pcid="4965">
    def test_draw_on_image_blue_color(self):
        kps = [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=4)]
        kpi = ia.KeypointsOnImage(keypoints=kps, shape=(5, 5, 3))
        image = np.zeros((5, 5, 3), dtype=np.uint8) + 10

        kps_mask = np.zeros(image.shape[0:2], dtype=np.bool)
        kps_mask[2, 1] = 1
        kps_mask[4, 3] = 1

        image_kps = kpi.draw_on_image(
            image, color=[0, 0, 255], size=1, copy=True,
            raise_if_out_of_image=False)

        assert np.all(image_kps[kps_mask] == [0, 0, 255])
        assert np.all(image_kps[~kps_mask] == [10, 10, 10])

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_kps.py" startline="778" endline="795" pcid="4971">
    def test_draw_on_image_one_kp_at_bottom_right_corner_and_raise_true(self):
        kps = [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=4)]
        kpi = ia.KeypointsOnImage(
            keypoints=kps + [ia.Keypoint(x=5, y=5)],
            shape=(5, 5, 3))
        image = np.zeros((5, 5, 3), dtype=np.uint8) + 10

        kps_mask = np.zeros(image.shape[0:2], dtype=np.bool)
        kps_mask[2, 1] = 1
        kps_mask[4, 3] = 1

        with self.assertRaises(Exception) as context:
            _ = kpi.draw_on_image(
                image, color=[0, 255, 0], size=1, copy=True,
                raise_if_out_of_image=True)

        assert "Cannot draw keypoint" in str(context.exception)

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_kps.py" startline="745" endline="759" pcid="4969">
    def test_draw_on_image_keypoint_is_outside_of_image_and_raise_true(self):
        kps = [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=4)]
        kpi = ia.KeypointsOnImage(
            keypoints=kps + [ia.Keypoint(x=100, y=100)],
            shape=(5, 5, 3)
        )
        image = np.zeros((5, 5, 3), dtype=np.uint8) + 10

        with self.assertRaises(Exception) as context:
            _ = kpi.draw_on_image(
                image, color=[0, 255, 0], size=1, copy=True,
                raise_if_out_of_image=True)

        assert "Cannot draw keypoint" in str(context.exception)

</source>
</class>

<class classid="259" nclones="2" nlines="10" similarity="90">
<source file="systems/imgaug-0.4.0/test/augmentables/test_kps.py" startline="877" endline="889" pcid="4985">
    def test_fill_from_xy_array___array_with_two_coords(self):
        xy = np.array([(0, 0), (1, 2)], dtype=np.float32)
        kps = ia.KeypointsOnImage([ia.Keypoint(10, 20), ia.Keypoint(30, 40)],
                                  shape=(2, 2, 3))

        kps = kps.fill_from_xy_array_(xy)

        assert len(kps.keypoints) == 2
        assert kps.keypoints[0].x == 0
        assert kps.keypoints[0].y == 0
        assert kps.keypoints[1].x == 1
        assert kps.keypoints[1].y == 2

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_kps.py" startline="890" endline="902" pcid="4986">
    def test_fill_from_xy_array___list_with_two_coords(self):
        xy = [(0, 0), (1, 2)]
        kps = ia.KeypointsOnImage([ia.Keypoint(10, 20), ia.Keypoint(30, 40)],
                                  shape=(2, 2, 3))

        kps = kps.fill_from_xy_array_(xy)

        assert len(kps.keypoints) == 2
        assert kps.keypoints[0].x == 0
        assert kps.keypoints[0].y == 0
        assert kps.keypoints[1].x == 1
        assert kps.keypoints[1].y == 2

</source>
</class>

<class classid="260" nclones="3" nlines="14" similarity="80">
<source file="systems/imgaug-0.4.0/test/augmentables/test_kps.py" startline="942" endline="959" pcid="4990">
    def test_from_keypoint_image_dict_as_if_not_found_thresh_20(self):
        kps_image = np.zeros((5, 5, 2), dtype=np.uint8)
        kps_image[2, 1, 0] = 255
        kps_image[4, 3, 1] = 10

        kpi2 = ia.KeypointsOnImage.from_keypoint_image(
            kps_image,
            if_not_found_coords={"x": -1, "y": -2},
            threshold=20,
            nb_channels=3)

        assert kpi2.shape == (5, 5, 3)
        assert len(kpi2.keypoints) == 2
        assert kpi2.keypoints[0].y == 2.5
        assert kpi2.keypoints[0].x == 1.5
        assert kpi2.keypoints[1].y == -2
        assert kpi2.keypoints[1].x == -1

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_kps.py" startline="960" endline="977" pcid="4991">
    def test_from_keypoint_image_tuple_as_if_not_found_thresh_20(self):
        kps_image = np.zeros((5, 5, 2), dtype=np.uint8)
        kps_image[2, 1, 0] = 255
        kps_image[4, 3, 1] = 10

        kpi2 = ia.KeypointsOnImage.from_keypoint_image(
            kps_image,
            if_not_found_coords=(-1, -2),
            threshold=20,
            nb_channels=3)

        assert kpi2.shape == (5, 5, 3)
        assert len(kpi2.keypoints) == 2
        assert kpi2.keypoints[0].y == 2.5
        assert kpi2.keypoints[0].x == 1.5
        assert kpi2.keypoints[1].y == -2
        assert kpi2.keypoints[1].x == -1

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_kps.py" startline="978" endline="993" pcid="4992">
    def test_from_keypoint_image_none_as_if_not_found_thresh_20(self):
        kps_image = np.zeros((5, 5, 2), dtype=np.uint8)
        kps_image[2, 1, 0] = 255
        kps_image[4, 3, 1] = 10

        kpi2 = ia.KeypointsOnImage.from_keypoint_image(
            kps_image,
            if_not_found_coords=None,
            threshold=20,
            nb_channels=3)

        assert kpi2.shape == (5, 5, 3)
        assert len(kpi2.keypoints) == 1
        assert kpi2.keypoints[0].y == 2.5
        assert kpi2.keypoints[0].x == 1.5

</source>
</class>

<class classid="261" nclones="4" nlines="10" similarity="70">
<source file="systems/imgaug-0.4.0/test/augmentables/test_kps.py" startline="1139" endline="1151" pcid="5002">
    def test_from_distance_maps_nb_channels_4(self):
        distance_maps = self._get_distance_maps_for_from_dmap_tests()

        kpi = ia.KeypointsOnImage.from_distance_maps(distance_maps,
                                                     nb_channels=4)

        assert len(kpi.keypoints) == 2
        assert kpi.keypoints[0].x == 2
        assert kpi.keypoints[0].y == 2
        assert kpi.keypoints[1].x == 4
        assert kpi.keypoints[1].y == 2
        assert kpi.shape == (4, 5, 4)

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_kps.py" startline="1168" endline="1180" pcid="5004">
    def test_from_distance_maps_if_not_found_is_tuple_thresh_009(self):
        distance_maps = self._get_distance_maps_for_from_dmap_tests()

        kpi = ia.KeypointsOnImage.from_distance_maps(
            distance_maps, if_not_found_coords=(1, 1), threshold=0.09)

        assert len(kpi.keypoints) == 2
        assert kpi.keypoints[0].x == 2
        assert kpi.keypoints[0].y == 2
        assert kpi.keypoints[1].x == 1
        assert kpi.keypoints[1].y == 1
        assert kpi.shape == (4, 5)

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_kps.py" startline="1196" endline="1208" pcid="5006">
    def test_from_distance_maps_if_not_found_is_none_thresh_009(self):
        distance_maps = self._get_distance_maps_for_from_dmap_tests()

        kpi = ia.KeypointsOnImage.from_distance_maps(
            distance_maps,
            if_not_found_coords=None,
            threshold=0.09)

        assert len(kpi.keypoints) == 1
        assert kpi.keypoints[0].x == 2
        assert kpi.keypoints[0].y == 2
        assert kpi.shape == (4, 5)

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_kps.py" startline="1181" endline="1195" pcid="5005">
    def test_from_distance_maps_if_not_found_is_dict_thresh_009(self):
        distance_maps = self._get_distance_maps_for_from_dmap_tests()

        kpi = ia.KeypointsOnImage.from_distance_maps(
            distance_maps,
            if_not_found_coords={"x": 1, "y": 2},
            threshold=0.09)

        assert len(kpi.keypoints) == 2
        assert kpi.keypoints[0].x == 2
        assert kpi.keypoints[0].y == 2
        assert kpi.keypoints[1].x == 1
        assert kpi.keypoints[1].y == 2
        assert kpi.shape == (4, 5)

</source>
</class>

<class classid="262" nclones="2" nlines="13" similarity="100">
<source file="systems/imgaug-0.4.0/test/augmentables/test_kps.py" startline="1246" endline="1263" pcid="5010">
    def test_copy(self):
        kps = [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=4)]
        kpi = ia.KeypointsOnImage(keypoints=kps, shape=(5, 5, 3))

        kpi2 = kpi.copy()

        assert kpi2.keypoints[0].x == 1
        assert kpi2.keypoints[0].y == 2
        assert kpi2.keypoints[1].x == 3
        assert kpi2.keypoints[1].y == 4

        kps[0].x = 100

        assert kpi2.keypoints[0].x == 100
        assert kpi2.keypoints[0].y == 2
        assert kpi2.keypoints[1].x == 3
        assert kpi2.keypoints[1].y == 4

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_kps.py" startline="1287" endline="1304" pcid="5013">
    def test_deepcopy(self):
        kps = [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=4)]
        kpi = ia.KeypointsOnImage(keypoints=kps, shape=(5, 5, 3))

        kpi2 = kpi.deepcopy()

        assert kpi2.keypoints[0].x == 1
        assert kpi2.keypoints[0].y == 2
        assert kpi2.keypoints[1].x == 3
        assert kpi2.keypoints[1].y == 4

        kps[0].x = 100

        assert kpi2.keypoints[0].x == 1
        assert kpi2.keypoints[0].y == 2
        assert kpi2.keypoints[1].x == 3
        assert kpi2.keypoints[1].y == 4

</source>
</class>

<class classid="263" nclones="2" nlines="11" similarity="72">
<source file="systems/imgaug-0.4.0/test/augmentables/test_segmaps.py" startline="76" endline="90" pcid="5023">
    def test_bool_arr_2d(self):
        arr = np.array([
            [0, 0, 1],
            [0, 1, 1],
            [1, 1, 1]
        ], dtype=bool).reshape((3, 3))

        segmap = ia.SegmentationMapsOnImage(arr, shape=(3, 3))

        assert segmap.shape == (3, 3)
        assert segmap.arr.dtype.name == "int32"
        assert segmap.arr.shape == (3, 3, 1)
        assert np.array_equal(segmap.arr,
                              arr.reshape((3, 3, 1)).astype(np.int32))

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_segmaps.py" startline="91" endline="106" pcid="5024">
    def test_bool_arr_3d(self):
        arr = np.array([
            [0, 0, 1],
            [0, 1, 1],
            [1, 1, 1]
        ], dtype=bool).reshape((3, 3, 1))
        arr = np.tile(arr, (1, 1, 5))

        segmap = ia.SegmentationMapsOnImage(arr, shape=(3, 3))

        assert segmap.shape == (3, 3)
        assert segmap.arr.dtype.name == "int32"
        assert segmap.arr.shape == (3, 3, 5)
        assert np.array_equal(segmap.arr, arr.astype(np.int32))

    # is this different from the test_bool_* tests?
</source>
</class>

<class classid="264" nclones="2" nlines="12" similarity="100">
<source file="systems/imgaug-0.4.0/test/augmentables/test_segmaps.py" startline="129" endline="142" pcid="5026">
    def test_uint32_fails(self):
        got_exception = False
        try:
            arr = np.array([
                [0, 0, 1],
                [0, 2, 1],
                [1, 3, 1]
            ], dtype=np.uint32)
            _segmap = ia.SegmentationMapsOnImage(arr, shape=(3, 3, 3))
        except Exception as exc:
            assert "only uint8 and uint16 " in str(exc)
            got_exception = True
        assert got_exception

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_segmaps.py" startline="143" endline="156" pcid="5027">
    def test_uint64_fails(self):
        got_exception = False
        try:
            arr = np.array([
                [0, 0, 1],
                [0, 2, 1],
                [1, 3, 1]
            ], dtype=np.int64)
            _segmap = ia.SegmentationMapsOnImage(arr, shape=(3, 3, 3))
        except Exception as exc:
            assert "only int8, int16 and int32 " in str(exc)
            got_exception = True
        assert got_exception

</source>
</class>

<class classid="265" nclones="2" nlines="18" similarity="73">
<source file="systems/imgaug-0.4.0/test/augmentables/test_segmaps.py" startline="198" endline="221" pcid="5030">
    def test_uint_int(self):
        dtypes = ["int8", "int16", "int32", "uint8", "uint16"]
        ndims = [2, 3]

        for dtype, ndim in itertools.product(dtypes, ndims):
            with self.subTest(dtype=dtype, ndim=ndim):
                dtype = np.dtype(dtype)
                shape = (3, 3) if ndim == 2 else (3, 3, 1)
                arr = np.array([
                    [0, 0, 1],
                    [0, 2, 1],
                    [1, 3, 1]
                ], dtype=dtype).reshape(shape)
                segmap = ia.SegmentationMapsOnImage(arr, shape=(3, 3))

                observed = segmap.get_arr()

                assert segmap.arr.dtype.name == "int32"
                assert segmap.arr.ndim == 3
                assert np.array_equal(observed, arr)
                assert observed.dtype.name == dtype.name
                assert observed.ndim == ndim
                assert np.array_equal(observed, arr)

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_segmaps.py" startline="222" endline="243" pcid="5031">
    def test_bool(self):
        ndims = [2, 3]
        for ndim in ndims:
            with self.subTest(ndim=ndim):
                shape = (3, 3) if ndim == 2 else (3, 3, 1)
                arr = np.array([
                    [0, 0, 1],
                    [0, 1, 1],
                    [1, 1, 1]
                ], dtype=bool).reshape(shape)
                segmap = ia.SegmentationMapsOnImage(arr, shape=(3, 3))

                observed = segmap.get_arr()

                assert segmap.arr.dtype.name == "int32"
                assert segmap.arr.ndim == 3
                assert np.array_equal(observed, arr)
                assert observed.dtype.kind == "b"
                assert observed.ndim == ndim
                assert np.array_equal(observed, arr)


</source>
</class>

<class classid="266" nclones="3" nlines="11" similarity="72">
<source file="systems/imgaug-0.4.0/test/augmentables/test_segmaps.py" startline="258" endline="273" pcid="5034">
    def test_with_two_classes(self):
        # simple example with 2 classes
        col0 = self.col(0)
        col1 = self.col(1)
        expected = np.uint8([
            [col0, col1, col1],
            [col0, col1, col1],
            [col0, col1, col1]
        ])

        observed = self.segmap.draw()

        assert isinstance(observed, list)
        assert len(observed) == 1
        assert np.array_equal(observed[0], expected)

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_segmaps.py" startline="428" endline="442" pcid="5043">
    def test_alpha_only_segmap_is_visible(self):
        # only segmap visible
        observed = self.segmap.draw_on_image(self.image, alpha=1.0,
                                             draw_background=True)
        col0 = self.col(0)
        col1 = self.col(1)
        expected = np.uint8([
            [col0, col1, col1],
            [col0, col1, col1],
            [col0, col1, col1]
        ])
        assert isinstance(observed, list)
        assert len(observed) == 1
        assert np.array_equal(observed[0], expected)

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_segmaps.py" startline="332" endline="347" pcid="5037">
    def test_colors(self):
        # custom choice of colors
        col0 = (10, 10, 10)
        col1 = (50, 51, 52)
        expected = np.uint8([
            [col0, col1, col1],
            [col0, col1, col1],
            [col0, col1, col1]
        ])

        observed = self.segmap.draw(colors=[col0, col1])

        assert isinstance(observed, list)
        assert len(observed) == 1
        assert np.array_equal(observed[0], expected)

</source>
</class>

<class classid="267" nclones="2" nlines="22" similarity="73">
<source file="systems/imgaug-0.4.0/test/augmentables/test_segmaps.py" startline="274" endline="301" pcid="5035">
    def test_use_size_arg_to_resize_to_2x(self):
        # same example, with resizing to 2x the size
        double_size_args = [
            (6, 6),
            (2.0, 2.0),
            6,
            2.0
        ]

        col0 = self.col(0)
        col1 = self.col(1)
        expected = np.uint8([
            [col0, col1, col1],
            [col0, col1, col1],
            [col0, col1, col1]
        ])
        expected = ia.imresize_single_image(expected,
                                            (6, 6),
                                            interpolation="nearest")

        for double_size_arg in double_size_args:
            with self.subTest(size=double_size_arg):
                observed = self.segmap.draw(size=double_size_arg)

                assert isinstance(observed, list)
                assert len(observed) == 1
                assert np.array_equal(observed[0], expected)

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_segmaps.py" startline="302" endline="331" pcid="5036">
    def test_use_size_arg_to_keep_at_same_size(self):
        # same example, keeps size at 3x3 via None and (int)3 or (float)1.0
        size_args = [
            None,
            (None, None),
            (3, None),
            (None, 3),
            (1.0, None),
            (None, 1.0)
        ]

        col0 = self.col(0)
        col1 = self.col(1)
        expected = np.uint8([
            [col0, col1, col1],
            [col0, col1, col1],
            [col0, col1, col1]
        ])
        expected = ia.imresize_single_image(expected,
                                            (3, 3),
                                            interpolation="nearest")

        for size_arg in size_args:
            with self.subTest(size=size_arg):
                observed = self.segmap.draw(size=size_arg)

                assert isinstance(observed, list)
                assert len(observed) == 1
                assert np.array_equal(observed[0], expected)

</source>
</class>

<class classid="268" nclones="2" nlines="17" similarity="70">
<source file="systems/imgaug-0.4.0/test/augmentables/test_segmaps.py" startline="511" endline="532" pcid="5046">
    def test_non_binary_alpha_with_draw_background(self):
        # overlay without background drawn
        im = self.image
        segmap = self.segmap

        a1 = 0.7
        a0 = 1.0 - a1

        observed = segmap.draw_on_image(im, alpha=a1, draw_background=False)

        col1 = np.uint8(self.col(1))
        expected = np.float32([
            [im[0, 0, :], a0*im[0, 1, :] + a1*col1, a0*im[0, 2, :] + a1*col1],
            [im[1, 0, :], a0*im[1, 1, :] + a1*col1, a0*im[1, 2, :] + a1*col1],
            [im[2, 0, :], a0*im[2, 1, :] + a1*col1, a0*im[2, 2, :] + a1*col1]
        ])
        d_max = np.max(np.abs(observed[0].astype(np.float32) - expected))
        assert isinstance(observed, list)
        assert len(observed) == 1
        assert observed[0].shape == expected.shape
        assert d_max <= 1.0 + 1e-4

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_segmaps.py" startline="533" endline="556" pcid="5047">
    def test_non_binary_alpha_with_draw_background_and_bg_class_id(self):
        # overlay without background drawn
        # different background class id
        image = self.image
        segmap = self.segmap

        a1 = 0.7
        a0 = 1.0 - a1

        observed = segmap.draw_on_image(image, alpha=a1, draw_background=False,
                                        background_class_id=1)

        col0 = np.uint8(self.col(0))
        expected = np.float32([
            [a0*image[0, 0, :] + a1*col0, image[0, 1, :], image[0, 2, :]],
            [a0*image[1, 0, :] + a1*col0, image[1, 1, :], image[1, 2, :]],
            [a0*image[2, 0, :] + a1*col0, image[2, 1, :], image[2, 2, :]]
        ])
        d_max = np.max(np.abs(observed[0].astype(np.float32) - expected))
        assert isinstance(observed, list)
        assert len(observed) == 1
        assert observed[0].shape == expected.shape
        assert d_max <= 1.0 + 1e-4

</source>
</class>

<class classid="269" nclones="2" nlines="29" similarity="86">
<source file="systems/imgaug-0.4.0/test/augmentables/test_segmaps.py" startline="586" endline="624" pcid="5049">
    def test_resize_segmentation_map_to_image(self):
        # resizing of segmap to image
        arr = np.int32([
            [0, 1, 1]
        ])
        segmap = ia.SegmentationMapsOnImage(arr, shape=(3, 3))

        image = np.uint8([
            [0, 10, 20],
            [30, 40, 50],
            [60, 70, 80]
        ])
        image = np.tile(image[:, :, np.newaxis], (1, 1, 3))

        a1 = 0.7
        a0 = 1.0 - a1

        observed = segmap.draw_on_image(image, alpha=a1, draw_background=True,
                                        resize="segmentation_map")

        col0 = self.col(0)
        col1 = self.col(1)
        expected = np.uint8([
            [col0, col1, col1],
            [col0, col1, col1],
            [col0, col1, col1]
        ])
        expected = a0 * image + a1 * expected
        d_max = np.max(
            np.abs(
                observed[0].astype(np.float32)
                - expected.astype(np.float32)
            )
        )
        assert isinstance(observed, list)
        assert len(observed) == 1
        assert observed[0].shape == expected.shape
        assert d_max <= 1.0 + 1e-4

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_segmaps.py" startline="625" endline="663" pcid="5050">
    def test_resize_image_to_segmentation_map(self):
        # resizing of image to segmap
        arr = np.int32([
            [0, 1, 1],
            [0, 1, 1],
            [0, 1, 1]
        ])
        segmap = ia.SegmentationMapsOnImage(arr, shape=(1, 3))

        image = np.uint8([[0, 10, 20]])
        image = np.tile(image[:, :, np.newaxis], (1, 1, 3))
        image_rs = ia.imresize_single_image(
            image, arr.shape[0:2], interpolation="cubic")

        a1 = 0.7
        a0 = 1.0 - a1

        observed = segmap.draw_on_image(image, alpha=a1, draw_background=True,
                                        resize="image")

        col0 = self.col(0)
        col1 = self.col(1)
        expected = np.uint8([
            [col0, col1, col1],
            [col0, col1, col1],
            [col0, col1, col1]
        ])
        expected = a0 * image_rs + a1 * expected
        d_max = np.max(
            np.abs(
                observed[0].astype(np.float32)
                - expected.astype(np.float32)
            )
        )
        assert isinstance(observed, list)
        assert len(observed) == 1
        assert observed[0].shape == expected.shape
        assert d_max <= 1.0 + 1e-4

</source>
</class>

<class classid="270" nclones="3" nlines="14" similarity="85">
<source file="systems/imgaug-0.4.0/test/augmentables/test_heatmaps.py" startline="186" endline="201" pcid="5082">
    def test_defaults(self):
        heatmaps = self.heatmaps
        heatmaps_padded = heatmaps.pad(top=1, right=2, bottom=3, left=4)
        assert heatmaps_padded.arr_0to1.shape == (2+(1+3), 2+(4+2), 1)
        assert np.allclose(
            heatmaps_padded.arr_0to1[:, :, 0],
            np.float32([
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0],
                [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0],
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
            ])
        )

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_heatmaps.py" startline="202" endline="218" pcid="5083">
    def test_mode_constant_with_cval_050(self):
        heatmaps = self.heatmaps
        heatmaps_padded = heatmaps.pad(top=1, right=2, bottom=3, left=4,
                                       cval=0.5)
        assert heatmaps_padded.arr_0to1.shape == (2+(1+3), 2+(4+2), 1)
        assert np.allclose(
            heatmaps_padded.arr_0to1[:, :, 0],
            np.float32([
                [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5],
                [0.5, 0.5, 0.5, 0.5, 0.0, 1.0, 0.5, 0.5],
                [0.5, 0.5, 0.5, 0.5, 0.0, 1.0, 0.5, 0.5],
                [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5],
                [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5],
                [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]
            ])
        )

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_heatmaps.py" startline="219" endline="236" pcid="5084">
    def test_mode_edge(self):
        heatmaps = self.heatmaps
        heatmaps_padded = heatmaps.pad(top=1, right=2, bottom=3, left=4,
                                       mode="edge")
        assert heatmaps_padded.arr_0to1.shape == (2+(1+3), 2+(4+2), 1)
        assert np.allclose(
            heatmaps_padded.arr_0to1[:, :, 0],
            np.float32([
                [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0],
                [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0],
                [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0],
                [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0],
                [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0],
                [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0]
            ])
        )


</source>
</class>

<class classid="271" nclones="3" nlines="10" similarity="90">
<source file="systems/imgaug-0.4.0/test/augmentables/test_heatmaps.py" startline="246" endline="258" pcid="5086">
    def test_square_ratio_with_default_mode_and_cval(self):
        heatmaps = self.heatmaps
        heatmaps_padded = heatmaps.pad_to_aspect_ratio(1.0)
        assert heatmaps_padded.arr_0to1.shape == (3, 3, 1)
        assert np.allclose(
            heatmaps_padded.arr_0to1[:, :, 0],
            np.float32([
                [0.0, 0.0, 1.0],
                [0.0, 0.0, 1.0],
                [0.0, 0.0, 0.0]
            ])
        )

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_heatmaps.py" startline="259" endline="271" pcid="5087">
    def test_square_ratio_with_cval_050(self):
        heatmaps = self.heatmaps
        heatmaps_padded = heatmaps.pad_to_aspect_ratio(1.0, cval=0.5)
        assert heatmaps_padded.arr_0to1.shape == (3, 3, 1)
        assert np.allclose(
            heatmaps_padded.arr_0to1[:, :, 0],
            np.float32([
                [0.0, 0.0, 1.0],
                [0.0, 0.0, 1.0],
                [0.5, 0.5, 0.5]
            ])
        )

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_heatmaps.py" startline="272" endline="284" pcid="5088">
    def test_square_ratio_with_edge_mode(self):
        heatmaps = self.heatmaps
        heatmaps_padded = heatmaps.pad_to_aspect_ratio(1.0, mode="edge")
        assert heatmaps_padded.arr_0to1.shape == (3, 3, 1)
        assert np.allclose(
            heatmaps_padded.arr_0to1[:, :, 0],
            np.float32([
                [0.0, 0.0, 1.0],
                [0.0, 0.0, 1.0],
                [0.0, 0.0, 1.0]
            ])
        )

</source>
</class>

<class classid="272" nclones="2" nlines="13" similarity="100">
<source file="systems/imgaug-0.4.0/test/augmentables/test_heatmaps.py" startline="321" endline="337" pcid="5091">
    def test_with_kernel_size_2(self):
        heatmaps_arr = np.float32([
            [0.0, 0.0, 0.5, 1.0],
            [0.0, 0.0, 0.5, 1.0],
            [0.0, 0.0, 0.5, 1.0],
            [0.0, 0.0, 0.5, 1.0]
        ])
        heatmaps = ia.HeatmapsOnImage(heatmaps_arr, shape=(4, 4, 3))

        heatmaps_pooled = heatmaps.avg_pool(2)
        assert heatmaps_pooled.arr_0to1.shape == (2, 2, 1)
        assert np.allclose(
            heatmaps_pooled.arr_0to1[:, :, 0],
            np.float32([[0.0, 0.75],
                        [0.0, 0.75]])
        )

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_heatmaps.py" startline="339" endline="356" pcid="5092">
    def test_with_kernel_size_2(self):
        heatmaps_arr = np.float32([
            [0.0, 0.0, 0.5, 1.0],
            [0.0, 0.0, 0.5, 1.0],
            [0.0, 0.0, 0.5, 1.0],
            [0.0, 0.0, 0.5, 1.0]
        ])
        heatmaps = ia.HeatmapsOnImage(heatmaps_arr, shape=(4, 4, 3))

        heatmaps_pooled = heatmaps.max_pool(2)
        assert heatmaps_pooled.arr_0to1.shape == (2, 2, 1)
        assert np.allclose(
            heatmaps_pooled.arr_0to1[:, :, 0],
            np.float32([[0.0, 1.0],
                        [0.0, 1.0]])
        )


</source>
</class>

<class classid="273" nclones="2" nlines="13" similarity="78">
<source file="systems/imgaug-0.4.0/test/augmentables/test_heatmaps.py" startline="358" endline="376" pcid="5093">
    def test_resize_to_exact_shape(self):
        heatmaps_arr = np.float32([
            [0.0, 1.0]
        ])
        heatmaps = ia.HeatmapsOnImage(heatmaps_arr, shape=(4, 4, 3))

        heatmaps_scaled = heatmaps.resize((4, 4), interpolation="nearest")
        assert heatmaps_scaled.arr_0to1.shape == (4, 4, 1)
        assert heatmaps_scaled.arr_0to1.dtype.name == "float32"
        assert np.allclose(
            heatmaps_scaled.arr_0to1[:, :, 0],
            np.float32([
                [0.0, 0.0, 1.0, 1.0],
                [0.0, 0.0, 1.0, 1.0],
                [0.0, 0.0, 1.0, 1.0],
                [0.0, 0.0, 1.0, 1.0]
            ])
        )

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_heatmaps.py" startline="377" endline="394" pcid="5094">
    def test_resize_to_twice_the_size(self):
        heatmaps_arr = np.float32([
            [0.0, 1.0]
        ])
        heatmaps = ia.HeatmapsOnImage(heatmaps_arr, shape=(4, 4, 3))

        heatmaps_scaled = heatmaps.resize(2.0, interpolation="nearest")
        assert heatmaps_scaled.arr_0to1.shape == (2, 4, 1)
        assert heatmaps_scaled.arr_0to1.dtype.name == "float32"
        assert np.allclose(
            heatmaps_scaled.arr_0to1[:, :, 0],
            np.float32([
                [0.0, 0.0, 1.0, 1.0],
                [0.0, 0.0, 1.0, 1.0]
            ])
        )


</source>
</class>

<class classid="274" nclones="2" nlines="11" similarity="90">
<source file="systems/imgaug-0.4.0/test/augmentables/test_heatmaps.py" startline="396" endline="410" pcid="5095">
    def test_3d_uint8_array(self):
        hm = ia.HeatmapsOnImage.from_uint8(
            np.uint8([
                [0, 128, 255],
                [255, 128, 0]
            ])[..., np.newaxis],
            (20, 30, 3)
        )
        assert hm.shape == (20, 30, 3)
        assert hm.arr_0to1.shape == (2, 3, 1)
        assert np.allclose(hm.arr_0to1[..., 0], np.float32([
            [0, 128/255, 1.0],
            [1.0, 128/255, 0]
        ]))

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_heatmaps.py" startline="411" endline="425" pcid="5096">
    def test_2d_uint8_array(self):
        hm = ia.HeatmapsOnImage.from_uint8(
            np.uint8([
                [0, 128, 255],
                [255, 128, 0]
            ]),
            (20, 30, 3)
        )
        assert hm.shape == (20, 30, 3)
        assert hm.arr_0to1.shape == (2, 3, 1)
        assert np.allclose(hm.arr_0to1[..., 0], np.float32([
            [0, 128/255, 1.0],
            [1.0, 128/255, 0]
        ]))

</source>
</class>

<class classid="275" nclones="3" nlines="10" similarity="70">
<source file="systems/imgaug-0.4.0/test/augmentables/test_heatmaps.py" startline="448" endline="463" pcid="5098">
    def test_increase_max_value(self):
        # (0.0, 1.0) -> (0.0, 2.0)
        arr = np.float32([
            [0.0, 0.5, 1.0],
            [1.0, 0.5, 0.0]
        ])

        observed = ia.HeatmapsOnImage.change_normalization(
            arr, (0.0, 1.0), (0.0, 2.0))

        expected = np.float32([
            [0.0, 1.0, 2.0],
            [2.0, 1.0, 0.0]
        ])
        assert np.allclose(observed, expected)

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_heatmaps.py" startline="480" endline="495" pcid="5100">
    def test_increase_min_and_max_value__non_standard_source(self):
        # (-1.0, 1.0) -> (1.0, 3.0)
        arr = np.float32([
            [-1.0, 0.0, 1.0],
            [1.0, 0.0, -1.0]
        ])

        observed = ia.HeatmapsOnImage.change_normalization(
            arr, (-1.0, 1.0), (1.0, 3.0))

        expected = np.float32([
            [1.0, 2.0, 3.0],
            [3.0, 2.0, 1.0]
        ])
        assert np.allclose(observed, expected)

</source>
<source file="systems/imgaug-0.4.0/test/augmentables/test_heatmaps.py" startline="464" endline="479" pcid="5099">
    def test_decrease_min_and_max_value(self):
        # (0.0, 1.0) -> (-1.0, 0.0)
        arr = np.float32([
            [0.0, 0.5, 1.0],
            [1.0, 0.5, 0.0]
        ])

        observed = ia.HeatmapsOnImage.change_normalization(
            arr, (0.0, 1.0), (-1.0, 0.0))

        expected = np.float32([
            [-1.0, -0.5, 0.0],
            [0.0, -0.5, -1.0]
        ])
        assert np.allclose(observed, expected)

</source>
</class>

<class classid="276" nclones="2" nlines="18" similarity="83">
<source file="systems/imgaug-0.4.0/test/test_dtypes.py" startline="275" endline="297" pcid="5130">
    def test_many_items_list_input_single_dtype(self):
        arrs = [
            np.array([0.0, 0.1, 0.9, 127.0+0.0, -128.0-0.0], dtype=np.float32),
            np.array([0.0, 0.1, 0.9, 127.0+1.0, -128.0-1.0], dtype=np.float32)
        ]
        dtypes = np.int8

        observed = iadt.restore_dtypes_(
            [np.copy(arr) for arr in arrs],
            dtypes,
            clip=False,
            round=False)

        expected = [
            np.array([0, 0, 0, 127, -128], dtype=np.int8),
            np.array([0, 0, 0, -128+1-1, 127-1+1], dtype=np.int8)
        ]
        assert len(observed) == 2
        assert observed[0].dtype.name == "int8"
        assert observed[1].dtype.name == "int8"
        assert np.array_equal(observed[0], expected[0])
        assert np.array_equal(observed[1], expected[1])

</source>
<source file="systems/imgaug-0.4.0/test/test_dtypes.py" startline="298" endline="320" pcid="5131">
    def test_many_items_list_input_many_dtypes(self):
        arrs = [
            np.array([0.0, 0.1, 0.9, 127.0+1.0, -128.0-1.0], dtype=np.float32),
            np.array([0.0, 0.1, 0.9, 127.0+1.0, -128.0-1.0], dtype=np.float32)
        ]
        dtypes = [np.int8, np.int16]

        observed = iadt.restore_dtypes_(
            [np.copy(arr) for arr in arrs],
            dtypes,
            clip=False,
            round=False)

        expected = [
            np.array([0, 0, 0, -128+1-1, 127-1+1], dtype=np.int8),
            np.array([0, 0, 0, 127+1, -128-1], dtype=np.int16)
        ]
        assert len(observed) == 2
        assert observed[0].dtype.name == "int8"
        assert observed[1].dtype.name == "int16"
        assert np.array_equal(observed[0], expected[0])
        assert np.array_equal(observed[1], expected[1])

</source>
</class>

<class classid="277" nclones="2" nlines="13" similarity="92">
<source file="systems/imgaug-0.4.0/test/test_dtypes.py" startline="491" endline="506" pcid="5145">
    def test_with_lists_of_identical_dtypes(self):
        dts = [
            np.int8, np.int16, np.int32, np.int64,
            np.uint8, np.uint16, np.uint32, np.uint64,
            np.float16, np.float32, np.float64,
            np.bool_
        ]

        for dt in dts:
            dt = np.dtype(dt)
            for length in [1, 2, 3]:
                with self.subTest(dtype=dt.name, length=length):
                    inputs = [dt for _ in range(length)]
                    promoted_dt = iadt.get_minimal_dtype(inputs)
                    assert promoted_dt.name == dt.name

</source>
<source file="systems/imgaug-0.4.0/test/test_dtypes.py" startline="507" endline="523" pcid="5146">
    def test_with_lists_of_identical_dtype_arrays(self):
        dts = [
            np.int8, np.int16, np.int32, np.int64,
            np.uint8, np.uint16, np.uint32, np.uint64,
            np.float16, np.float32, np.float64,
            np.bool_
        ]

        for dt in dts:
            dt = np.dtype(dt)
            for length in [1, 2, 3]:
                with self.subTest(dtype=dt.name, length=length):
                    inputs = [np.zeros((1, 1, 3), dtype=dt)
                              for _ in range(length)]
                    promoted_dt = iadt.get_minimal_dtype(inputs)
                    assert promoted_dt.name == dt.name

</source>
</class>

<class classid="278" nclones="2" nlines="14" similarity="71">
<source file="systems/imgaug-0.4.0/test/test_dtypes.py" startline="587" endline="603" pcid="5150">
    def test_calls_subfunctions_dtypes_set(self, mock_cd, mock_gmd):
        mock_gmd.return_value = np.dtype("int16")
        mock_cd.return_value = "foo"
        arrays = [np.zeros((1,), dtype=np.int8)]

        observed = iadt.promote_array_dtypes_(
            arrays,
            dtypes=["float32"])

        assert mock_gmd.call_count == 1
        assert mock_cd.call_count == 1
        # call 0, args, arg 0, dtype 0
        assert mock_gmd.call_args_list[0][0][0][0] == "float32"
        assert mock_gmd.call_args_list[0][1]["increase_itemsize_factor"] == 1
        assert mock_cd.call_args_list[0][0][0] is arrays
        assert observed == "foo"

</source>
<source file="systems/imgaug-0.4.0/test/test_dtypes.py" startline="606" endline="623" pcid="5151">
    def test_calls_subfunctions_increase_itemsize_factor_set(self, mock_cd,
                                                             mock_gmd):
        mock_gmd.return_value = np.dtype("int16")
        mock_cd.return_value = "foo"
        arrays = [np.zeros((1,), dtype=np.int8)]

        observed = iadt.promote_array_dtypes_(
            arrays,
            increase_itemsize_factor=2)

        assert mock_gmd.call_count == 1
        assert mock_cd.call_count == 1
        # call 0, args, arg 0, dtype 0
        assert mock_gmd.call_args_list[0][0][0][0].name == "int8"
        assert mock_gmd.call_args_list[0][1]["increase_itemsize_factor"] == 2
        assert mock_cd.call_args_list[0][0][0] is arrays
        assert observed == "foo"

</source>
</class>

<class classid="279" nclones="10" nlines="11" similarity="72">
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="1109" endline="1124" pcid="5342">
        )

    def test_value_is_list(self):
        param = iap.Choice([0, 1, 2])

        sample = param.draw_sample()
        samples = param.draw_samples((10, 5))

        assert sample.shape == tuple()
        assert samples.shape == (10, 5)
        assert sample in [0, 1, 2]
        assert np.all(
            np.logical_or(
                np.logical_or(samples == 0, samples == 1),
                samples == 2
            )
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="1285" endline="1300" pcid="5356">
        )

    def test_bounds_are_ints(self):
        param = iap.DiscreteUniform(0, 2)

        sample = param.draw_sample()
        samples = param.draw_samples((10, 5))

        assert sample.shape == tuple()
        assert samples.shape == (10, 5)
        assert sample in [0, 1, 2]
        assert np.all(
            np.logical_or(
                np.logical_or(samples == 0, samples == 1),
                samples == 2
            )
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="1315" endline="1330" pcid="5358">
            )

    def test_lower_bound_is_negative(self):
        param = iap.DiscreteUniform(-1, 1)

        sample = param.draw_sample()
        samples = param.draw_samples((10, 5))

        assert sample.shape == tuple()
        assert samples.shape == (10, 5)
        assert sample in [-1, 0, 1]
        assert np.all(
            np.logical_or(
                np.logical_or(samples == -1, samples == 0),
                samples == 1
            )
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="2012" endline="2027" pcid="5414">
        )

    def test_arguments_are_identical(self):
        param = iap.Uniform(1, 1)

        sample = param.draw_sample()
        samples = param.draw_samples((10, 5))

        assert sample.shape == tuple()
        assert samples.shape == (10, 5)
        assert 1.0 - _eps(sample) < sample < 1.0 + _eps(sample)
        assert np.all(
            np.logical_and(
                1.0 - _eps(samples) < samples,
                samples < 1.0 + _eps(samples)
            )
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="1996" endline="2011" pcid="5413">
        )

    def test_arguments_are_integers(self):
        param = iap.Uniform(-1, 1)

        sample = param.draw_sample()
        samples = param.draw_samples((10, 5))

        assert sample.shape == tuple()
        assert samples.shape == (10, 5)
        assert -1.0 - _eps(sample) < sample < 1.0 + _eps(sample)
        assert np.all(
            np.logical_and(
                -1.0 - _eps(samples) < samples,
                samples < 1.0 + _eps(samples)
            )
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="1349" endline="1366" pcid="5360">
        )

    def test_lower_and_upper_bound_have_wrong_order(self):
        param = iap.DiscreteUniform(1, -1)

        sample = param.draw_sample()
        samples = param.draw_samples((10, 5))

        assert sample.shape == tuple()
        assert samples.shape == (10, 5)
        assert sample in [-1, 0, 1]
        assert np.all(
            np.logical_or(
                np.logical_or(
                    samples == -1, samples == 0
                ),
                samples == 1
            )
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="1331" endline="1348" pcid="5359">
        )

    def test_bounds_are_floats(self):
        param = iap.DiscreteUniform(-1.2, 1.2)

        sample = param.draw_sample()
        samples = param.draw_samples((10, 5))

        assert sample.shape == tuple()
        assert samples.shape == (10, 5)
        assert sample in [-1, 0, 1]
        assert np.all(
            np.logical_or(
                np.logical_or(
                    samples == -1, samples == 0
                ),
                samples == 1
            )
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="1980" endline="1995" pcid="5412">
        )

    def test_wrong_argument_order(self):
        param = iap.Uniform(1.0, -1.0)

        sample = param.draw_sample()
        samples = param.draw_samples((10, 5))

        assert sample.shape == tuple()
        assert samples.shape == (10, 5)
        assert -1.0 - _eps(sample) < sample < 1.0 + _eps(sample)
        assert np.all(
            np.logical_and(
                -1.0 - _eps(samples) < samples,
                samples < 1.0 + _eps(samples)
            )
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="2734" endline="2749" pcid="5470">
        assert np.all(samples == -1)

    def test_value_is_within_bounds_and_float(self):
        param = iap.Clip(iap.Deterministic(0.5), -1, 1)

        sample = param.draw_sample()
        samples = param.draw_samples((10, 5))

        assert sample.shape == tuple()
        assert samples.shape == (10, 5)
        assert 0.5 - _eps(sample) < sample < 0.5 + _eps(sample)
        assert np.all(
            np.logical_and(
                0.5 - _eps(sample) <= samples,
                samples <= 0.5 + _eps(sample)
            )
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="1964" endline="1979" pcid="5411">
            )

    def test_negative_value(self):
        param = iap.Uniform(-1.0, 1.0)

        sample = param.draw_sample()
        samples = param.draw_samples((10, 5))

        assert sample.shape == tuple()
        assert samples.shape == (10, 5)
        assert -1.0 - _eps(sample) < sample < 1.0 + _eps(sample)
        assert np.all(
            np.logical_and(
                -1.0 - _eps(samples) < samples,
                samples < 1.0 + _eps(samples)
            )
</source>
</class>

<class classid="280" nclones="2" nlines="11" similarity="90">
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="1125" endline="1138" pcid="5343">
        )

    def test_sampled_values_match_expected_counts(self):
        param = iap.Choice([0, 1, 2])

        samples = param.draw_samples((10000,))
        expected = 10000/3
        expected_tolerance = expected * 0.05
        for v in [0, 1, 2]:
            count = np.sum(samples == v)
            assert (
                expected - expected_tolerance
                < count <
                expected + expected_tolerance
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="1301" endline="1314" pcid="5357">
        )

    def test_samples_match_expected_counts(self):
        param = iap.DiscreteUniform(0, 2)

        samples = param.draw_samples((10000,))
        expected = 10000/3
        expected_tolerance = expected * 0.05
        for v in [0, 1, 2]:
            count = np.sum(samples == v)
            assert (
                expected - expected_tolerance
                < count <
                expected + expected_tolerance
</source>
</class>

<class classid="281" nclones="2" nlines="12" similarity="83">
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="1213" endline="1227" pcid="5348">
        assert all([count in [0, 1] for count in seen])

    def test_non_uniform_probabilities_over_elements(self):
        param = iap.Choice([0, 1], p=[0.25, 0.75])

        samples = param.draw_samples((10000,))
        unique, counts = np.unique(samples, return_counts=True)

        assert len(unique) == 2
        for val, count in zip(unique, counts):
            if val == 0:
                assert 2500 - 500 < count < 2500 + 500
            elif val == 1:
                assert 7500 - 500 < count < 7500 + 500
            else:
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="1228" endline="1242" pcid="5349">
                assert False

    def test_list_contains_stochastic_parameter(self):
        param = iap.Choice([iap.Choice([0, 1]), 2])

        samples = param.draw_samples((10000,))
        unique, counts = np.unique(samples, return_counts=True)

        assert len(unique) == 3
        for val, count in zip(unique, counts):
            if val in [0, 1]:
                assert 2500 - 500 < count < 2500 + 500
            elif val == 2:
                assert 5000 - 500 < count < 5000 + 500
            else:
</source>
</class>

<class classid="282" nclones="2" nlines="21" similarity="95">
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="1451" endline="1473" pcid="5371">
        assert sample.shape == tuple()

    def test_via_comparison_to_np_normal(self):
        param = iap.Normal(0, 1)

        samples = param.draw_samples((100, 1000))
        samples_direct = iarandom.RNG(1234).normal(loc=0, scale=1,
                                                            size=(100, 1000))
        samples = np.clip(samples, -1, 1)
        samples_direct = np.clip(samples_direct, -1, 1)
        nb_bins = 10
        hist, _ = np.histogram(samples, bins=nb_bins, range=(-1.0, 1.0),
                               density=False)
        hist_direct, _ = np.histogram(samples_direct, bins=nb_bins,
                                      range=(-1.0, 1.0), density=False)
        tolerance = 0.05
        for nb_samples, nb_samples_direct in zip(hist, hist_direct):
            density = nb_samples / samples.size
            density_direct = nb_samples_direct / samples_direct.size
            assert (
                density_direct - tolerance
                < density <
                density_direct + tolerance
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="1635" endline="1660" pcid="5387">
        assert sample.shape == tuple()

    def test_via_comparison_to_np_laplace(self):
        param = iap.Laplace(0, 1)

        samples = param.draw_samples((100, 1000))
        samples_direct = iarandom.RNG(1234).laplace(loc=0, scale=1,
                                                             size=(100, 1000))

        assert samples.shape == (100, 1000)

        samples = np.clip(samples, -1, 1)
        samples_direct = np.clip(samples_direct, -1, 1)
        nb_bins = 10
        hist, _ = np.histogram(samples, bins=nb_bins, range=(-1.0, 1.0),
                               density=False)
        hist_direct, _ = np.histogram(samples_direct, bins=nb_bins,
                                      range=(-1.0, 1.0), density=False)
        tolerance = 0.05
        for nb_samples, nb_samples_direct in zip(hist, hist_direct):
            density = nb_samples / samples.size
            density_direct = nb_samples_direct / samples_direct.size
            assert (
                density_direct - tolerance
                < density <
                density_direct + tolerance
</source>
</class>

<class classid="283" nclones="3" nlines="14" similarity="78">
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="1474" endline="1490" pcid="5372">
            )

    def test_loc_is_stochastic_parameter(self):
        param = iap.Normal(iap.Choice([-100, 100]), 1)

        seen = [0, 0]
        for _ in sm.xrange(1000):
            samples = param.draw_samples((100,))
            exp = np.mean(samples)

            if -100 - 10 < exp < -100 + 10:
                seen[0] += 1
            elif 100 - 10 < exp < 100 + 10:
                seen[1] += 1
            else:
                assert False
        assert 500 - 100 < seen[0] < 500 + 100
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="1661" endline="1678" pcid="5388">
            )

    def test_loc_is_stochastic_parameter(self):
        param = iap.Laplace(iap.Choice([-100, 100]), 1)

        seen = [0, 0]
        for _ in sm.xrange(1000):
            samples = param.draw_samples((100,))
            exp = np.mean(samples)

            if -100 - 10 < exp < -100 + 10:
                seen[0] += 1
            elif 100 - 10 < exp < 100 + 10:
                seen[1] += 1
            else:
                assert False

        assert 500 - 100 < seen[0] < 500 + 100
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="1757" endline="1774" pcid="5396">
            )

    def test_df_is_stochastic_parameter(self):
        param = iap.ChiSquare(iap.Choice([1, 10]))

        seen = [0, 0]
        for _ in sm.xrange(1000):
            samples = param.draw_samples((100,))
            exp = np.mean(samples)

            if 1 - 1.0 < exp < 1 + 1.0:
                seen[0] += 1
            elif 10 - 4.0 < exp < 10 + 4.0:
                seen[1] += 1
            else:
                assert False

        assert 500 - 100 < seen[0] < 500 + 100
</source>
</class>

<class classid="284" nclones="2" nlines="22" similarity="100">
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="1730" endline="1756" pcid="5395">
        assert 0 <= sample

    def test_via_comparison_to_np_chisquare(self):
        param = iap.ChiSquare(1)

        samples = param.draw_samples((100, 1000))
        samples_direct = iarandom.RNG(1234).chisquare(df=1,
                                                               size=(100, 1000))

        assert samples.shape == (100, 1000)
        assert np.all(0 <= samples)

        samples = np.clip(samples, 0, 3)
        samples_direct = np.clip(samples_direct, 0, 3)
        nb_bins = 10
        hist, _ = np.histogram(samples, bins=nb_bins, range=(0, 3.0),
                               density=False)
        hist_direct, _ = np.histogram(samples_direct, bins=nb_bins,
                                      range=(0, 3.0), density=False)
        tolerance = 0.05
        for nb_samples, nb_samples_direct in zip(hist, hist_direct):
            density = nb_samples / samples.size
            density_direct = nb_samples_direct / samples_direct.size
            assert (
                density_direct - tolerance
                < density <
                density_direct + tolerance
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="1818" endline="1844" pcid="5402">
        assert 0 <= sample

    def test_via_comparison_to_np_weibull(self):
        param = iap.Weibull(1)

        samples = param.draw_samples((100, 1000))
        samples_direct = iarandom.RNG(1234).weibull(a=1,
                                                             size=(100, 1000))

        assert samples.shape == (100, 1000)
        assert np.all(0 <= samples)

        samples = np.clip(samples, 0, 2)
        samples_direct = np.clip(samples_direct, 0, 2)
        nb_bins = 10
        hist, _ = np.histogram(samples, bins=nb_bins, range=(0, 2.0),
                               density=False)
        hist_direct, _ = np.histogram(samples_direct, bins=nb_bins,
                                      range=(0, 2.0), density=False)
        tolerance = 0.05
        for nb_samples, nb_samples_direct in zip(hist, hist_direct):
            density = nb_samples / samples.size
            density_direct = nb_samples_direct / samples_direct.size
            assert (
                density_direct - tolerance
                < density <
                density_direct + tolerance
</source>
</class>

<class classid="285" nclones="2" nlines="12" similarity="83">
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="2219" endline="2234" pcid="5431">
                    sample1, sample2, rtol=0, atol=_eps(sample1))

    def test_draw_samples_int(self):
        values = [-100, -54, -1, 0, 1, 54, 100]
        shapes = [10, 10, (5, 3), (5, 3), (4, 5, 3), (4, 5, 3)]
        for value, shape in itertools.product(values, shapes):
            with self.subTest(value=value, shape=shape):
                param = iap.Deterministic(value)

                samples = param.draw_samples(shape)
                shape_expected = (
                    shape
                    if isinstance(shape, tuple)
                    else tuple([shape]))

                assert samples.shape == shape_expected
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="2235" endline="2250" pcid="5432">
                assert np.all(samples == value)

    def test_draw_samples_float(self):
        values = [-100.0, -54.3, -1.0, 0.1, 0.0, 0.1, 1.0, 54.4, 100.0]
        shapes = [10, 10, (5, 3), (5, 3), (4, 5, 3), (4, 5, 3)]
        for value, shape in itertools.product(values, shapes):
            with self.subTest(value=value, shape=shape):
                param = iap.Deterministic(value)

                samples = param.draw_samples(shape)
                shape_expected = (
                    shape
                    if isinstance(shape, tuple)
                    else tuple([shape]))

                assert samples.shape == shape_expected
</source>
</class>

<class classid="286" nclones="6" nlines="20" similarity="81">
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="2481" endline="2505" pcid="5454">
        assert 1 in uq

    def test_different_size_px_arguments(self):
        # different sizes in px
        param1 = iap.FromLowerResolution(iap.Binomial(0.5), size_px=2)
        param2 = iap.FromLowerResolution(iap.Binomial(0.5), size_px=16)

        seen_components = [0, 0]
        seen_pixels = [0, 0]
        for _ in sm.xrange(100):
            samples1 = param1.draw_samples((16, 16, 1))
            samples2 = param2.draw_samples((16, 16, 1))
            _, num1 = skimage.morphology.label(samples1, connectivity=1,
                                               background=0, return_num=True)
            _, num2 = skimage.morphology.label(samples2, connectivity=1,
                                               background=0, return_num=True)
            seen_components[0] += num1
            seen_components[1] += num2
            seen_pixels[0] += np.sum(samples1 == 1)
            seen_pixels[1] += np.sum(samples2 == 1)

        assert seen_components[0] < seen_components[1]
        assert (
            seen_pixels[0] / seen_components[0]
            > seen_pixels[1] / seen_components[1]
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="2506" endline="2530" pcid="5455">
        )

    def test_different_size_px_arguments_with_tuple(self):
        # different sizes in px, one given as tuple (a, b)
        param1 = iap.FromLowerResolution(iap.Binomial(0.5), size_px=2)
        param2 = iap.FromLowerResolution(iap.Binomial(0.5), size_px=(2, 16))

        seen_components = [0, 0]
        seen_pixels = [0, 0]
        for _ in sm.xrange(400):
            samples1 = param1.draw_samples((16, 16, 1))
            samples2 = param2.draw_samples((16, 16, 1))
            _, num1 = skimage.morphology.label(samples1, connectivity=1,
                                               background=0, return_num=True)
            _, num2 = skimage.morphology.label(samples2, connectivity=1,
                                               background=0, return_num=True)
            seen_components[0] += num1
            seen_components[1] += num2
            seen_pixels[0] += np.sum(samples1 == 1)
            seen_pixels[1] += np.sum(samples2 == 1)

        assert seen_components[0] < seen_components[1]
        assert (
            seen_pixels[0] / seen_components[0]
            > seen_pixels[1] / seen_components[1]
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="2565" endline="2590" pcid="5458">
        self.assertTrue("Expected " in str(context.exception))

    def test_min_size(self):
        # min_size
        param1 = iap.FromLowerResolution(iap.Binomial(0.5), size_px=2)
        param2 = iap.FromLowerResolution(iap.Binomial(0.5), size_px=1,
                                         min_size=16)

        seen_components = [0, 0]
        seen_pixels = [0, 0]
        for _ in sm.xrange(100):
            samples1 = param1.draw_samples((16, 16, 1))
            samples2 = param2.draw_samples((16, 16, 1))
            _, num1 = skimage.morphology.label(samples1, connectivity=1,
                                               background=0, return_num=True)
            _, num2 = skimage.morphology.label(samples2, connectivity=1,
                                               background=0, return_num=True)
            seen_components[0] += num1
            seen_components[1] += num2
            seen_pixels[0] += np.sum(samples1 == 1)
            seen_pixels[1] += np.sum(samples2 == 1)

        assert seen_components[0] < seen_components[1]
        assert (
            seen_pixels[0] / seen_components[0]
            > seen_pixels[1] / seen_components[1]
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="2616" endline="2642" pcid="5460">
        )

    def test_size_percent_as_stochastic_parameters(self):
        # different sizes in percent, given as StochasticParameter
        param1 = iap.FromLowerResolution(iap.Binomial(0.5),
                                         size_percent=iap.Deterministic(0.01))
        param2 = iap.FromLowerResolution(iap.Binomial(0.5),
                                         size_percent=iap.Choice([0.4, 0.8]))

        seen_components = [0, 0]
        seen_pixels = [0, 0]
        for _ in sm.xrange(100):
            samples1 = param1.draw_samples((16, 16, 1))
            samples2 = param2.draw_samples((16, 16, 1))
            _, num1 = skimage.morphology.label(samples1, connectivity=1,
                                               background=0, return_num=True)
            _, num2 = skimage.morphology.label(samples2, connectivity=1,
                                               background=0, return_num=True)
            seen_components[0] += num1
            seen_components[1] += num2
            seen_pixels[0] += np.sum(samples1 == 1)
            seen_pixels[1] += np.sum(samples2 == 1)

        assert seen_components[0] < seen_components[1]
        assert (
            seen_pixels[0] / seen_components[0]
            > seen_pixels[1] / seen_components[1]
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="2591" endline="2615" pcid="5459">
        )

    def test_size_percent(self):
        # different sizes in percent
        param1 = iap.FromLowerResolution(iap.Binomial(0.5), size_percent=0.01)
        param2 = iap.FromLowerResolution(iap.Binomial(0.5), size_percent=0.8)

        seen_components = [0, 0]
        seen_pixels = [0, 0]
        for _ in sm.xrange(100):
            samples1 = param1.draw_samples((16, 16, 1))
            samples2 = param2.draw_samples((16, 16, 1))
            _, num1 = skimage.morphology.label(samples1, connectivity=1,
                                               background=0, return_num=True)
            _, num2 = skimage.morphology.label(samples2, connectivity=1,
                                               background=0, return_num=True)
            seen_components[0] += num1
            seen_components[1] += num2
            seen_pixels[0] += np.sum(samples1 == 1)
            seen_pixels[1] += np.sum(samples2 == 1)

        assert seen_components[0] < seen_components[1]
        assert (
            seen_pixels[0] / seen_components[0]
            > seen_pixels[1] / seen_components[1]
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="2531" endline="2557" pcid="5456">
        )

    def test_different_size_px_argument_with_stochastic_parameters(self):
        # different sizes in px, given as StochasticParameter
        param1 = iap.FromLowerResolution(iap.Binomial(0.5),
                                         size_px=iap.Deterministic(1))
        param2 = iap.FromLowerResolution(iap.Binomial(0.5),
                                         size_px=iap.Choice([8, 16]))

        seen_components = [0, 0]
        seen_pixels = [0, 0]
        for _ in sm.xrange(100):
            samples1 = param1.draw_samples((16, 16, 1))
            samples2 = param2.draw_samples((16, 16, 1))
            _, num1 = skimage.morphology.label(samples1, connectivity=1,
                                               background=0, return_num=True)
            _, num2 = skimage.morphology.label(samples2, connectivity=1,
                                               background=0, return_num=True)
            seen_components[0] += num1
            seen_components[1] += num2
            seen_pixels[0] += np.sum(samples1 == 1)
            seen_pixels[1] += np.sum(samples2 == 1)

        assert seen_components[0] < seen_components[1]
        assert (
            seen_pixels[0] / seen_components[0]
            > seen_pixels[1] / seen_components[1]
</source>
</class>

<class classid="287" nclones="16" nlines="12" similarity="70">
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="2922" endline="2937" pcid="5487">
        )

    def test_multiply_example_integer_values(self):
        values_int = [-100, -54, -1, 0, 1, 54, 100]

        for v1, v2 in itertools.product(values_int, values_int):
            with self.subTest(left=v1, right=v2):
                p = iap.Multiply(iap.Deterministic(v1), v2)

                samples = p.draw_samples((2, 3))

                assert p.draw_sample() == v1 * v2
                assert samples.dtype.kind == "i"
                assert np.array_equal(
                    samples,
                    np.zeros((2, 3), dtype=np.int64) + v1 * v2
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="3252" endline="3268" pcid="5509">
        )

    def test_add_integers(self):
        values_int = [-100, -54, -1, 0, 1, 54, 100]

        for v1, v2 in itertools.product(values_int, values_int):
            with self.subTest(left=v1, right=v2):
                p = iap.Add(iap.Deterministic(v1), v2)

                sample = p.draw_sample()
                samples = p.draw_samples((2, 3))

                assert sample == v1 + v2
                assert samples.dtype.kind == "i"
                assert np.array_equal(
                    samples,
                    np.zeros((2, 3), dtype=np.int32) + v1 + v2
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="2954" endline="2969" pcid="5489">
                )

    def test_multiply_example_float_values(self):
        values_float = [-100.0, -54.3, -1.0, 0.1, 0.0, 0.1, 1.0, 54.4, 100.0]
        for v1, v2 in itertools.product(values_float, values_float):
            with self.subTest(left=v1, right=v2):
                p = iap.Multiply(iap.Deterministic(v1), v2)

                sample = p.draw_sample()
                samples = p.draw_samples((2, 3))

                assert np.isclose(sample, v1 * v2, atol=1e-3, rtol=0)
                assert samples.dtype.kind == "f"
                assert np.allclose(
                    samples,
                    np.zeros((2, 3), dtype=np.float32) + v1 * v2
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="2938" endline="2953" pcid="5488">
                )

    def test_multiply_example_integer_values_both_deterministic(self):
        values_int = [-100, -54, -1, 0, 1, 54, 100]

        for v1, v2 in itertools.product(values_int, values_int):
            with self.subTest(left=v1, right=v2):
                p = iap.Multiply(iap.Deterministic(v1), iap.Deterministic(v2))

                samples = p.draw_samples((2, 3))

                assert p.draw_sample() == v1 * v2
                assert samples.dtype.name == "int32"
                assert np.array_equal(
                    samples,
                    np.zeros((2, 3), dtype=np.int32) + v1 * v2
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="3391" endline="3407" pcid="5519">
        )

    def test_subtract_integers(self):
        values_int = [-100, -54, -1, 0, 1, 54, 100]

        for v1, v2 in itertools.product(values_int, values_int):
            with self.subTest(left=v1, right=v2):
                p = iap.Subtract(iap.Deterministic(v1), v2)

                sample = p.draw_sample()
                samples = p.draw_samples((2, 3))

                assert sample == v1 - v2
                assert samples.dtype.kind == "i"
                assert np.array_equal(
                    samples,
                    np.zeros((2, 3), dtype=np.int64) + v1 - v2
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="3269" endline="3285" pcid="5510">
                )

    def test_add_integers_both_deterministic(self):
        values_int = [-100, -54, -1, 0, 1, 54, 100]

        for v1, v2 in itertools.product(values_int, values_int):
            with self.subTest(left=v1, right=v2):
                p = iap.Add(iap.Deterministic(v1), iap.Deterministic(v2))

                sample = p.draw_sample()
                samples = p.draw_samples((2, 3))

                assert sample == v1 + v2
                assert samples.dtype.kind == "i"
                assert np.array_equal(
                    samples,
                    np.zeros((2, 3), dtype=np.int32) + v1 + v2
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="3408" endline="3424" pcid="5520">
                )

    def test_subtract_integers_both_deterministic(self):
        values_int = [-100, -54, -1, 0, 1, 54, 100]

        for v1, v2 in itertools.product(values_int, values_int):
            with self.subTest(left=v1, right=v2):
                p = iap.Subtract(iap.Deterministic(v1), iap.Deterministic(v2))

                sample = p.draw_sample()
                samples = p.draw_samples((2, 3))

                assert sample == v1 - v2
                assert samples.dtype.kind == "i"
                assert np.array_equal(
                    samples,
                    np.zeros((2, 3), dtype=np.int64) + v1 - v2
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="3425" endline="3440" pcid="5521">
                )

    def test_subtract_floats(self):
        values_float = [-100.0, -54.3, -1.0, 0.1, 0.0, 0.1, 1.0, 54.4, 100.0]
        for v1, v2 in itertools.product(values_float, values_float):
            with self.subTest(left=v1, right=v2):
                p = iap.Subtract(iap.Deterministic(v1), v2)

                sample = p.draw_sample()
                samples = p.draw_samples((2, 3))

                assert v1 - v2 - _eps(sample) < sample < v1 - v2 + _eps(sample)
                assert samples.dtype.kind == "f"
                assert np.allclose(
                    samples,
                    np.zeros((2, 3), dtype=np.float64) + v1 - v2
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="3286" endline="3301" pcid="5511">
                )

    def test_add_floats(self):
        values_float = [-100.0, -54.3, -1.0, 0.1, 0.0, 0.1, 1.0, 54.4, 100.0]
        for v1, v2 in itertools.product(values_float, values_float):
            with self.subTest(left=v1, right=v2):
                p = iap.Add(iap.Deterministic(v1), v2)

                sample = p.draw_sample()
                samples = p.draw_samples((2, 3))

                assert np.isclose(sample, v1 + v2, atol=1e-3, rtol=0)
                assert samples.dtype.kind == "f"
                assert np.allclose(
                    samples,
                    np.zeros((2, 3), dtype=np.float32) + v1 + v2
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="3302" endline="3317" pcid="5512">
                )

    def test_add_floats_both_deterministic(self):
        values_float = [-100.0, -54.3, -1.0, 0.1, 0.0, 0.1, 1.0, 54.4, 100.0]
        for v1, v2 in itertools.product(values_float, values_float):
            with self.subTest(left=v1, right=v2):
                p = iap.Add(iap.Deterministic(v1), iap.Deterministic(v2))

                sample = p.draw_sample()
                samples = p.draw_samples((2, 3))

                assert np.isclose(sample, v1 + v2, atol=1e-3, rtol=0)
                assert samples.dtype.kind == "f"
                assert np.allclose(
                    samples,
                    np.zeros((2, 3), dtype=np.float32) + v1 + v2
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="3064" endline="3083" pcid="5497">
        )

    def test_divide_integers(self):
        values_int = [-100, -54, -1, 0, 1, 54, 100]

        for v1, v2 in itertools.product(values_int, values_int):
            if v2 == 0:
                v2 = 1

            with self.subTest(left=v1, right=v2):
                p = iap.Divide(iap.Deterministic(v1), v2)

                sample = p.draw_sample()
                samples = p.draw_samples((2, 3))

                assert sample == (v1 / v2)
                assert samples.dtype.kind == "f"
                assert np.array_equal(
                    samples,
                    np.zeros((2, 3), dtype=np.float64) + (v1 / v2)
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="2970" endline="2985" pcid="5490">
                )

    def test_multiply_example_float_values_both_deterministic(self):
        values_float = [-100.0, -54.3, -1.0, 0.1, 0.0, 0.1, 1.0, 54.4, 100.0]
        for v1, v2 in itertools.product(values_float, values_float):
            with self.subTest(left=v1, right=v2):
                p = iap.Multiply(iap.Deterministic(v1), iap.Deterministic(v2))

                sample = p.draw_sample()
                samples = p.draw_samples((2, 3))

                assert np.isclose(sample, v1 * v2, atol=1e-3, rtol=0)
                assert samples.dtype.kind == "f"
                assert np.allclose(
                    samples,
                    np.zeros((2, 3), dtype=np.float32) + v1 * v2
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="3441" endline="3456" pcid="5522">
                )

    def test_subtract_floats_both_deterministic(self):
        values_float = [-100.0, -54.3, -1.0, 0.1, 0.0, 0.1, 1.0, 54.4, 100.0]
        for v1, v2 in itertools.product(values_float, values_float):
            with self.subTest(left=v1, right=v2):
                p = iap.Subtract(iap.Deterministic(v1), iap.Deterministic(v2))

                sample = p.draw_sample()
                samples = p.draw_samples((2, 3))

                assert v1 - v2 - _eps(sample) < sample < v1 - v2 + _eps(sample)
                assert samples.dtype.kind == "f"
                assert np.allclose(
                    samples,
                    np.zeros((2, 3), dtype=np.float64) + v1 - v2
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="3084" endline="3103" pcid="5498">
                )

    def test_divide_integers_both_deterministic(self):
        values_int = [-100, -54, -1, 0, 1, 54, 100]

        for v1, v2 in itertools.product(values_int, values_int):
            if v2 == 0:
                v2 = 1

            with self.subTest(left=v1, right=v2):
                p = iap.Divide(iap.Deterministic(v1), iap.Deterministic(v2))

                sample = p.draw_sample()
                samples = p.draw_samples((2, 3))

                assert sample == (v1 / v2)
                assert samples.dtype.kind == "f"
                assert np.array_equal(
                    samples,
                    np.zeros((2, 3), dtype=np.float64) + (v1 / v2)
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="3104" endline="3127" pcid="5499">
                )

    def test_divide_floats(self):
        values_float = [-100.0, -54.3, -1.0, 0.1, 0.0, 0.1, 1.0, 54.4, 100.0]

        for v1, v2 in itertools.product(values_float, values_float):
            if v2 == 0:
                v2 = 1

            with self.subTest(left=v1, right=v2):
                p = iap.Divide(iap.Deterministic(v1), v2)

                sample = p.draw_sample()
                samples = p.draw_samples((2, 3))

                assert (
                    (v1 / v2) - _eps(sample)
                    <= sample <=
                    (v1 / v2) + _eps(sample)
                )
                assert samples.dtype.kind == "f"
                assert np.allclose(
                    samples,
                    np.zeros((2, 3), dtype=np.float64) + (v1 / v2)
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="3128" endline="3151" pcid="5500">
                )

    def test_divide_floats_both_deterministic(self):
        values_float = [-100.0, -54.3, -1.0, 0.1, 0.0, 0.1, 1.0, 54.4, 100.0]

        for v1, v2 in itertools.product(values_float, values_float):
            if v2 == 0:
                v2 = 1

            with self.subTest(left=v1, right=v2):
                p = iap.Divide(iap.Deterministic(v1), iap.Deterministic(v2))

                sample = p.draw_sample()
                samples = p.draw_samples((2, 3))

                assert (
                    (v1 / v2) - _eps(sample)
                    <= sample <=
                    (v1 / v2) + _eps(sample)
                )
                assert samples.dtype.kind == "f"
                assert np.allclose(
                    samples,
                    np.zeros((2, 3), dtype=np.float64) + (v1 / v2)
</source>
</class>

<class classid="288" nclones="12" nlines="12" similarity="76">
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="2986" endline="3002" pcid="5491">
                )

    def test_multiply_by_stochastic_parameter(self):
        param = iap.Multiply(iap.Deterministic(1.0),
                             (1.0, 2.0),
                             elementwise=False)

        samples = param.draw_samples((10, 20))
        samples_sorted = np.sort(samples.flatten())

        assert samples.shape == (10, 20)
        assert np.all(samples > 1.0 * 1.0 - _eps(samples))
        assert np.all(samples < 1.0 * 2.0 + _eps(samples))
        assert (
            samples_sorted[0] - _eps(samples_sorted[0])
            < samples_sorted[-1] <
            samples_sorted[0] + _eps(samples_sorted[0])
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="3020" endline="3035" pcid="5493">
        )

    def test_multiply_stochastic_parameter_by_fixed_value(self):
        param = iap.Multiply(iap.Uniform(1.0, 2.0),
                             1.0,
                             elementwise=False)
        samples = param.draw_samples((10, 20))
        samples_sorted = np.sort(samples.flatten())

        assert samples.shape == (10, 20)
        assert np.all(samples > 1.0 * 1.0 - _eps(samples))
        assert np.all(samples < 2.0 * 1.0 + _eps(samples))
        assert not (
            samples_sorted[0] - _eps(samples_sorted[0])
            < samples_sorted[-1] <
            samples_sorted[0] + _eps(samples_sorted[0])
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="3611" endline="3627" pcid="5532">
        )

    def test_exponent_is_stochastic_parameter_elementwise(self):
        param = iap.Power(iap.Deterministic(1.5),
                          (1.0, 2.0),
                          elementwise=True)

        samples = param.draw_samples((10, 20))
        samples_sorted = np.sort(samples.flatten())

        assert samples.shape == (10, 20)
        assert np.all(samples > 1.5 ** 1.0 - 2 * _eps(samples))
        assert np.all(samples < 1.5 ** 2.0 + 2 * _eps(samples))
        assert not (
            samples_sorted[0] - _eps(samples_sorted[0])
            < samples_sorted[-1] <
            samples_sorted[0] + _eps(samples_sorted[0])
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="3003" endline="3019" pcid="5492">
        )

    def test_multiply_by_stochastic_parameter_elementwise(self):
        param = iap.Multiply(iap.Deterministic(1.0),
                             (1.0, 2.0),
                             elementwise=True)

        samples = param.draw_samples((10, 20))
        samples_sorted = np.sort(samples.flatten())

        assert samples.shape == (10, 20)
        assert np.all(samples > 1.0 * 1.0 - _eps(samples))
        assert np.all(samples < 1.0 * 2.0 + _eps(samples))
        assert not (
            samples_sorted[0] - _eps(samples_sorted[0])
            < samples_sorted[-1] <
            samples_sorted[0] + _eps(samples_sorted[0])
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="3457" endline="3473" pcid="5523">
                )

    def test_subtract_stochastic_parameter(self):
        param = iap.Subtract(iap.Deterministic(1.0),
                             (1.0, 2.0),
                             elementwise=False)

        samples = param.draw_samples((10, 20))
        samples_sorted = np.sort(samples.flatten())

        assert samples.shape == (10, 20)
        assert np.all(samples > 1.0 - 2.0 - _eps(samples))
        assert np.all(samples < 1.0 - 1.0 + _eps(samples))
        assert (
            samples_sorted[0] - _eps(samples_sorted[0])
            < samples_sorted[-1] <
            samples_sorted[0] + _eps(samples_sorted[0])
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="3474" endline="3490" pcid="5524">
        )

    def test_subtract_stochastic_parameter_elementwise(self):
        param = iap.Subtract(iap.Deterministic(1.0),
                             (1.0, 2.0),
                             elementwise=True)

        samples = param.draw_samples((10, 20))
        samples_sorted = np.sort(samples.flatten())

        assert samples.shape == (10, 20)
        assert np.all(samples > 1.0 - 2.0 - _eps(samples))
        assert np.all(samples < 1.0 - 1.0 + _eps(samples))
        assert not (
            samples_sorted[0] - _eps(samples_sorted[0])
            < samples_sorted[-1] <
            samples_sorted[0] + _eps(samples_sorted[0])
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="3594" endline="3610" pcid="5531">
                )

    def test_exponent_is_stochastic_parameter(self):
        param = iap.Power(iap.Deterministic(1.5),
                          (1.0, 2.0),
                          elementwise=False)

        samples = param.draw_samples((10, 20))
        samples_sorted = np.sort(samples.flatten())

        assert samples.shape == (10, 20)
        assert np.all(samples > 1.5 ** 1.0 - 2 * _eps(samples))
        assert np.all(samples < 1.5 ** 2.0 + 2 * _eps(samples))
        assert (
            samples_sorted[0] - _eps(samples_sorted[0])
            < samples_sorted[-1] <
            samples_sorted[0] + _eps(samples_sorted[0])
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="3036" endline="3051" pcid="5494">
        )

    def test_multiply_stochastic_parameter_by_fixed_value_elementwise(self):
        param = iap.Multiply(iap.Uniform(1.0, 2.0), 1.0, elementwise=True)

        samples = param.draw_samples((10, 20))
        samples_sorted = np.sort(samples.flatten())

        assert samples.shape == (10, 20)
        assert np.all(samples > 1.0 * 1.0 - _eps(samples))
        assert np.all(samples < 2.0 * 1.0 + _eps(samples))
        assert not (
            samples_sorted[0] - _eps(samples_sorted[0])
            < samples_sorted[-1] <
            samples_sorted[0] + _eps(samples_sorted[0])
        )
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="3643" endline="3658" pcid="5534">
        )

    def test_value_is_uniform_elementwise(self):
        param = iap.Power(iap.Uniform(1.0, 2.0), 1.0, elementwise=True)

        samples = param.draw_samples((10, 20))
        samples_sorted = np.sort(samples.flatten())

        assert samples.shape == (10, 20)
        assert np.all(samples > 1.0 ** 1.0 - 2 * _eps(samples))
        assert np.all(samples < 2.0 ** 1.0 + 2 * _eps(samples))
        assert not (
            samples_sorted[0] - _eps(samples_sorted[0])
            < samples_sorted[-1] <
            samples_sorted[0] + _eps(samples_sorted[0])
        )
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="3628" endline="3642" pcid="5533">
        )

    def test_value_is_uniform(self):
        param = iap.Power(iap.Uniform(1.0, 2.0), 1.0, elementwise=False)

        samples = param.draw_samples((10, 20))
        samples_sorted = np.sort(samples.flatten())

        assert samples.shape == (10, 20)
        assert np.all(samples > 1.0 ** 1.0 - 2 * _eps(samples))
        assert np.all(samples < 2.0 ** 1.0 + 2 * _eps(samples))
        assert not (
            samples_sorted[0] - _eps(samples_sorted[0])
            < samples_sorted[-1] <
            samples_sorted[0] + _eps(samples_sorted[0])
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="3491" endline="3505" pcid="5525">
        )

    def test_subtract_from_stochastic_parameter(self):
        param = iap.Subtract(iap.Uniform(1.0, 2.0), 1.0, elementwise=False)

        samples = param.draw_samples((10, 20))
        samples_sorted = np.sort(samples.flatten())

        assert samples.shape == (10, 20)
        assert np.all(samples > 1.0 - 1.0 - _eps(samples))
        assert np.all(samples < 2.0 - 1.0 + _eps(samples))
        assert not (
            samples_sorted[0] - _eps(samples_sorted[0])
            < samples_sorted[-1] <
            samples_sorted[0] + _eps(samples_sorted[0])
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="3506" endline="3521" pcid="5526">
        )

    def test_subtract_from_stochastic_parameter_elementwise(self):
        param = iap.Subtract(iap.Uniform(1.0, 2.0), 1.0, elementwise=True)

        samples = param.draw_samples((10, 20))
        samples_sorted = np.sort(samples.flatten())

        assert samples.shape == (10, 20)
        assert np.all(samples > 1.0 - 1.0 - _eps(samples))
        assert np.all(samples < 2.0 - 1.0 + _eps(samples))
        assert not (
            samples_sorted[0] - _eps(samples_sorted[0])
            < samples_sorted[-1] <
            samples_sorted[0] + _eps(samples_sorted[0])
        )
</source>
</class>

<class classid="289" nclones="4" nlines="13" similarity="76">
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="3152" endline="3168" pcid="5501">
                )

    def test_divide_by_stochastic_parameter(self):
        param = iap.Divide(iap.Deterministic(1.0),
                           (1.0, 2.0),
                           elementwise=False)

        samples = param.draw_samples((10, 20))
        samples_sorted = np.sort(samples.flatten())

        assert samples.shape == (10, 20)
        assert np.all(samples > (1.0 / 2.0) - _eps(samples))
        assert np.all(samples < (1.0 / 1.0) + _eps(samples))
        assert (
            samples_sorted[0] - _eps(samples)
            < samples_sorted[-1] <
            samples_sorted[0] + _eps(samples)
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="3169" endline="3185" pcid="5502">
        )

    def test_divide_by_stochastic_parameter_elementwise(self):
        param = iap.Divide(iap.Deterministic(1.0),
                           (1.0, 2.0),
                           elementwise=True)

        samples = param.draw_samples((10, 20))
        samples_sorted = np.sort(samples.flatten())

        assert samples.shape == (10, 20)
        assert np.all(samples > (1.0 / 2.0) - _eps(samples))
        assert np.all(samples < (1.0 / 1.0) + _eps(samples))
        assert not (
            samples_sorted[0] - _eps(samples)
            < samples_sorted[-1] <
            samples_sorted[0] + _eps(samples)
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="3186" endline="3202" pcid="5503">
        )

    def test_divide_stochastic_parameter_by_float(self):
        param = iap.Divide(iap.Uniform(1.0, 2.0),
                           1.0,
                           elementwise=False)

        samples = param.draw_samples((10, 20))
        samples_sorted = np.sort(samples.flatten())

        assert samples.shape == (10, 20)
        assert np.all(samples > (1.0 / 1.0) - _eps(samples))
        assert np.all(samples < (2.0 / 1.0) + _eps(samples))
        assert not (
            samples_sorted[0] - _eps(samples)
            < samples_sorted[-1] <
            samples_sorted[0] + _eps(samples)
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="3203" endline="3220" pcid="5504">
        )

    def test_divide_stochastic_parameter_by_float_elementwise(self):
        param = iap.Divide(iap.Uniform(1.0, 2.0),
                           1.0,
                           elementwise=True)

        samples = param.draw_samples((10, 20))
        samples_sorted = np.sort(samples.flatten())

        assert samples.shape == (10, 20)
        assert np.all(samples > (1.0 / 1.0) - _eps(samples))
        assert np.all(samples < (2.0 / 1.0) + _eps(samples))
        assert not (
            samples_sorted[0] - _eps(samples_sorted)
            < samples_sorted[-1]
            < samples_sorted[-1]
            < samples_sorted[0] + _eps(samples_sorted)
</source>
</class>

<class classid="290" nclones="4" nlines="11" similarity="81">
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="3318" endline="3332" pcid="5513">
                )

    def test_add_stochastic_parameter(self):
        param = iap.Add(iap.Deterministic(1.0), (1.0, 2.0), elementwise=False)

        samples = param.draw_samples((10, 20))
        samples_sorted = np.sort(samples.flatten())

        assert samples.shape == (10, 20)
        assert np.all(samples >= 1.0 + 1.0 - _eps(samples))
        assert np.all(samples <= 1.0 + 2.0 + _eps(samples))
        assert (
            samples_sorted[0] - _eps(samples_sorted[0])
            < samples_sorted[-1]
            < samples_sorted[0] + _eps(samples_sorted[0])
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="3363" endline="3378" pcid="5516">
        )

    def test_add_to_stochastic_parameter_elementwise(self):
        param = iap.Add(iap.Uniform(1.0, 2.0), 1.0, elementwise=True)

        samples = param.draw_samples((10, 20))
        samples_sorted = np.sort(samples.flatten())

        assert samples.shape == (10, 20)
        assert np.all(samples >= 1.0 + 1.0 - _eps(samples))
        assert np.all(samples <= 2.0 + 1.0 + _eps(samples))
        assert not (
            samples_sorted[0] - _eps(samples_sorted[0])
            < samples_sorted[-1]
            < samples_sorted[0] + _eps(samples_sorted[0])
        )
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="3333" endline="3347" pcid="5514">
        )

    def test_add_stochastic_parameter_elementwise(self):
        param = iap.Add(iap.Deterministic(1.0), (1.0, 2.0), elementwise=True)

        samples = param.draw_samples((10, 20))
        samples_sorted = np.sort(samples.flatten())

        assert samples.shape == (10, 20)
        assert np.all(samples >= 1.0 + 1.0 - _eps(samples))
        assert np.all(samples <= 1.0 + 2.0 + _eps(samples))
        assert not (
            samples_sorted[0] - _eps(samples_sorted[0])
            < samples_sorted[-1]
            < samples_sorted[0] + _eps(samples_sorted[0])
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="3348" endline="3362" pcid="5515">
        )

    def test_add_to_stochastic_parameter(self):
        param = iap.Add(iap.Uniform(1.0, 2.0), 1.0, elementwise=False)

        samples = param.draw_samples((10, 20))
        samples_sorted = np.sort(samples.flatten())

        assert samples.shape == (10, 20)
        assert np.all(samples >= 1.0 + 1.0 - _eps(samples))
        assert np.all(samples <= 2.0 + 1.0 + _eps(samples))
        assert not (
            samples_sorted[0] - _eps(samples_sorted[0])
            < samples_sorted[-1]
            < samples_sorted[0] + _eps(samples_sorted[0])
</source>
</class>

<class classid="291" nclones="2" nlines="22" similarity="95">
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="3534" endline="3563" pcid="5529">
        )

    def test_pairs(self):
        values = [
            -100, -54, -1, 0, 1, 54, 100,
            -100.0, -54.0, -1.0, 0.0, 1.0, 54.0, 100.0
        ]
        exponents = [-2, -1.5, -1, -0.5, 0, 0.5, 1, 1.5, 2]

        for base, exponent in itertools.product(values, exponents):
            if base < 0 and ia.is_single_float(exponent):
                continue
            if base == 0 and exponent < 0:
                continue

            with self.subTest(base=base, exponent=exponent):
                p = iap.Power(iap.Deterministic(base), exponent)

                sample = p.draw_sample()
                samples = p.draw_samples((2, 3))

                assert (
                    base ** exponent - _eps(sample)
                    < sample <
                    base ** exponent + _eps(sample)
                )
                assert samples.dtype.kind == "f"
                assert np.allclose(
                    samples,
                    np.zeros((2, 3), dtype=np.float64) + base ** exponent
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="3564" endline="3593" pcid="5530">
                )

    def test_pairs_both_deterministic(self):
        values = [
            -100, -54, -1, 0, 1, 54, 100,
            -100.0, -54.0, -1.0, 0.0, 1.0, 54.0, 100.0
        ]
        exponents = [-2, -1.5, -1, -0.5, 0, 0.5, 1, 1.5, 2]

        for base, exponent in itertools.product(values, exponents):
            if base < 0 and ia.is_single_float(exponent):
                continue
            if base == 0 and exponent < 0:
                continue

            with self.subTest(base=base, exponent=exponent):
                p = iap.Power(iap.Deterministic(base), iap.Deterministic(exponent))

                sample = p.draw_sample()
                samples = p.draw_samples((2, 3))

                assert (
                    base ** exponent - _eps(sample)
                    < sample <
                    base ** exponent + _eps(sample)
                )
                assert samples.dtype.kind == "f"
                assert np.allclose(
                    samples,
                    np.zeros((2, 3), dtype=np.float64) + base ** exponent
</source>
</class>

<class classid="292" nclones="2" nlines="10" similarity="80">
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="3844" endline="3856" pcid="5553">
        assert np.all(samples == -1)

    def test_many_samples_stochastic_value_to_positive(self):
        param = iap.ForceSign(iap.Choice([-2, 1]), positive=True,
                              mode="invert")

        samples = param.draw_samples(1000)
        n_twos = np.sum(samples == 2)
        n_ones = np.sum(samples == 1)

        assert samples.shape == (1000,)
        assert n_twos + n_ones == 1000
        assert 200 < n_twos < 700
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="3857" endline="3869" pcid="5554">
        assert 200 < n_ones < 700

    def test_many_samples_stochastic_value_to_positive_reroll(self):
        param = iap.ForceSign(iap.Choice([-2, 1]), positive=True,
                              mode="reroll")

        samples = param.draw_samples(1000)
        n_twos = np.sum(samples == 2)
        n_ones = np.sum(samples == 1)

        assert samples.shape == (1000,)
        assert n_twos + n_ones == 1000
        assert n_twos > 0
</source>
</class>

<class classid="293" nclones="2" nlines="11" similarity="72">
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="3882" endline="3896" pcid="5556">
        assert n_twos < 5

    def test_samples_same_values_for_same_seeds(self):
        param = iap.ForceSign(iap.Choice([-2, 1]),
                              positive=True,
                              mode="invert")

        samples1 = param.draw_samples((100, 10),
                                      random_state=iarandom.RNG(1234))
        samples2 = param.draw_samples((100, 10),
                                      random_state=iarandom.RNG(1234))

        assert samples1.shape == (100, 10)
        assert samples2.shape == (100, 10)
        assert np.array_equal(samples1, samples2)
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="4089" endline="4101" pcid="5572">
        assert 0.25 - 0.05 < nb_0 / (2 * 1000) < 0.25 + 0.05

    def test_samples_same_values_for_same_seeds(self):
        param = iap.IterativeNoiseAggregator(
            iap.Choice([0, 50]), iterations=5, aggregation_method="avg")

        samples1 = param.draw_samples((100, 10),
                                      random_state=iarandom.RNG(1234))
        samples2 = param.draw_samples((100, 10),
                                      random_state=iarandom.RNG(1234))

        assert samples1.shape == (100, 10)
        assert samples2.shape == (100, 10)
</source>
</class>

<class classid="294" nclones="4" nlines="10" similarity="70">
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="3949" endline="3961" pcid="5563">
        )

    def test_value_is_deterministic_max_1_iter(self):
        param = iap.IterativeNoiseAggregator(iap.Deterministic(1),
                                             iterations=1,
                                             aggregation_method="max")

        sample = param.draw_sample()
        samples = param.draw_samples((2, 4))

        assert sample.shape == tuple()
        assert samples.shape == (2, 4)
        assert sample == 1
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="3962" endline="3974" pcid="5564">
        assert np.all(samples == 1)

    def test_value_is_stochastic_avg_200_iter(self):
        param = iap.IterativeNoiseAggregator(iap.Choice([0, 50]),
                                             iterations=200,
                                             aggregation_method="avg")

        sample = param.draw_sample()
        samples = param.draw_samples((2, 4))

        assert sample.shape == tuple()
        assert samples.shape == (2, 4)
        assert 25 - 10 < sample < 25 + 10
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="3988" endline="4000" pcid="5566">
        assert np.all(samples == 50)

    def test_value_is_stochastic_min_100_iter(self):
        param = iap.IterativeNoiseAggregator(iap.Choice([0, 50]),
                                             iterations=100,
                                             aggregation_method="min")

        sample = param.draw_sample()
        samples = param.draw_samples((2, 4))

        assert sample.shape == tuple()
        assert samples.shape == (2, 4)
        assert sample == 0
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="3975" endline="3987" pcid="5565">
        assert np.all(np.logical_and(25 - 10 < samples, samples < 25 + 10))

    def test_value_is_stochastic_max_100_iter(self):
        param = iap.IterativeNoiseAggregator(iap.Choice([0, 50]),
                                             iterations=100,
                                             aggregation_method="max")

        sample = param.draw_sample()
        samples = param.draw_samples((2, 4))

        assert sample.shape == tuple()
        assert samples.shape == (2, 4)
        assert sample == 50
</source>
</class>

<class classid="295" nclones="2" nlines="17" similarity="94">
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="4156" endline="4177" pcid="5578">
        )

    def test_activated_is_true(self):
        param = iap.Sigmoid(
            iap.Deterministic(5),
            add=0,
            mul=1,
            threshold=0.5,
            activated=True)

        expected = 1 / (1 + np.exp(-(5 * 1 + 0 - 0.5)))
        sample = param.draw_sample()
        samples = param.draw_samples((5, 10))

        assert sample.shape == tuple()
        assert samples.shape == (5, 10)
        assert expected - _eps(sample) < sample < expected + _eps(sample)
        assert np.all(
            np.logical_and(
                expected - _eps(samples) < samples,
                samples < expected + _eps(samples)
            )
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="4178" endline="4199" pcid="5579">
        )

    def test_activated_is_false(self):
        param = iap.Sigmoid(
            iap.Deterministic(5),
            add=0,
            mul=1,
            threshold=0.5,
            activated=False)

        expected = 5
        sample = param.draw_sample()
        samples = param.draw_samples((5, 10))

        assert sample.shape == tuple()
        assert samples.shape == (5, 10)
        assert expected - _eps(sample) < sample < expected + _eps(sample)
        assert np.all(
            np.logical_and(
                expected - _eps(sample) < samples,
                samples < expected + _eps(sample)
            )
</source>
</class>

<class classid="296" nclones="2" nlines="22" similarity="86">
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="4200" endline="4224" pcid="5580">
        )

    def test_activated_is_probabilistic(self):
        param = iap.Sigmoid(
            iap.Deterministic(5),
            add=0,
            mul=1,
            threshold=0.5,
            activated=0.5)

        expected_first = 5
        expected_second = 1 / (1 + np.exp(-(5 * 1 + 0 - 0.5)))
        seen = [0, 0]
        for _ in sm.xrange(1000):
            sample = param.draw_sample()
            diff_first = abs(sample - expected_first)
            diff_second = abs(sample - expected_second)
            if diff_first < _eps(sample):
                seen[0] += 1
            elif diff_second < _eps(sample):
                seen[1] += 1
            else:
                assert False

        assert 500 - 150 < seen[0] < 500 + 150
</source>
<source file="systems/imgaug-0.4.0/test/test_parameters.py" startline="4225" endline="4249" pcid="5581">
        assert 500 - 150 < seen[1] < 500 + 150

    def test_value_is_stochastic_param(self):
        param = iap.Sigmoid(
            iap.Choice([1, 10]),
            add=0,
            mul=1,
            threshold=0.5,
            activated=True)

        expected_first = 1 / (1 + np.exp(-(1 * 1 + 0 - 0.5)))
        expected_second = 1 / (1 + np.exp(-(10 * 1 + 0 - 0.5)))
        seen = [0, 0]
        for _ in sm.xrange(1000):
            sample = param.draw_sample()
            diff_first = abs(sample - expected_first)
            diff_second = abs(sample - expected_second)
            if diff_first < _eps(sample):
                seen[0] += 1
            elif diff_second < _eps(sample):
                seen[1] += 1
            else:
                assert False

        assert 500 - 150 < seen[0] < 500 + 150
</source>
</class>

</clones>
