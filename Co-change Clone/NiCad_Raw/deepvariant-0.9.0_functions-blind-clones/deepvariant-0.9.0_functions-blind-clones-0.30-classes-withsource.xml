<clones>
<systeminfo processor="nicad6" system="deepvariant-0.9.0" granularity="functions-blind" threshold="30%" minlines="10" maxlines="2500"/>
<cloneinfo npcs="642" npairs="10"/>
<runinfo ncompares="5784" cputime="45112"/>
<classinfo nclasses="8"/>

<class classid="1" nclones="2" nlines="13" similarity="78">
<source file="systems/deepvariant-0.9.0/deepvariant/vcf_stats_vis.py" startline="163" endline="182" pcid="20">
  return qual_histogram


def _build_gq_histogram(data):
  """Create the Genotype quality (GQ) histogram."""
  # gq = genotype quality, found at :GQ: in FORMAT column of VCF
  width = 200
  height = 200
  title = 'Genotype quality'
  gq_data = _integer_counts_to_histogram(data)
  gq_histogram = _placeholder_for_empty_chart(
      'No entries in VCF with GQ', width=width, height=height, title=title)
  if not gq_data.empty:
    # standardize x-axis limits across reports
    domain = [min(0, data[0][0]), max(150, data[-1][0])]
    # s = bin_start, e = bin_end, c = count
    gq_histogram = alt.Chart(gq_data).mark_bar(color=BAR_COLOR_GQ) \
        .encode(
            x=alt.X('s', title='GQ', scale=alt.Scale(domain=domain)),
            x2='e',
</source>
<source file="systems/deepvariant-0.9.0/deepvariant/vcf_stats_vis.py" startline="322" endline="337" pcid="26">
                  title=title) \
      .interactive(bind_y=False)

    indel_log = alt.Chart(indel_size_data).mark_bar().encode(
        x=alt.X('s', title='size'),
        x2='e',
        y=alt.Y(
            'c',
            title='Count',
            axis=alt.Axis(format='s'),
            scale=alt.Scale(type='log', base=10)),
        color=alt.Color('type', sort=ordered_labels,
                        scale=alt.Scale(scheme='set1'))) \
      .properties(width=400, height=100) \
      .interactive(bind_y=False)

</source>
</class>

<class classid="2" nclones="2" nlines="28" similarity="92">
<source file="systems/deepvariant-0.9.0/deepvariant/labeler/variant_labeler.py" startline="208" endline="276" pcid="168">
def _genotype_from_matched_truth(candidate_variant, truth_variant):
  """Gets the diploid genotype for candidate_variant from matched truth_variant.

  This method figures out the genotype for candidate_variant by matching alleles
  in candidate_variant with those used by the genotype assigned to
  truth_variant. For example, if candidate is A/C and truth is A/C with a 0/1
  genotype, then this function would return (0, 1) indicating that there's one
  copy of the A allele and one of C in truth. If the true genotype is 1/1, then
  this routine would return (1, 1).

  The routine allows candidate_variant and truth_variant to differ in both
  the number of alternate alleles, and even in the representation of the same
  alleles due to those differences. For example, candidate could be:

      AGT/A/AGTGT => 2 bp deletion and 2 bp insertion

  and truth could have:

      A/AGT => just the simplified 2 bp insertion

  And this routine will correctly equate the AGT/AGTGT allele in candidate
  with the A/AGT in truth and use the number of copies of AGT in truth to
  compute the number of copies of AGTGT when determining the returned genotype.

  Args:
    candidate_variant: Our candidate third_party.nucleus.protos.Variant variant.
    truth_variant: Our third_party.nucleus.protos.Variant truth variant
      containing true alleles and genotypes.

  Returns:
    A tuple genotypes with the same semantics at the genotype field of the
    VariantCall proto.

  Raises:
    ValueError: If candidate_variant is None, truth_variant is None, or
      truth_variant doesn't have genotypes.
  """
  if candidate_variant is None:
    raise ValueError('candidate_variant cannot be None')
  if truth_variant is None:
    raise ValueError('truth_variant cannot be None')
  if not variantcall_utils.has_genotypes(
      variant_utils.only_call(truth_variant)):
    raise ValueError('truth_variant needs genotypes to be used for labeling',
                     truth_variant)

  def _match_one_allele(true_allele):
    if true_allele == truth_variant.reference_bases:
      return 0
    else:
      simplifed_true_allele = variant_utils.simplify_alleles(
          truth_variant.reference_bases, true_allele)
      for alt_index, alt_allele in enumerate(candidate_variant.alternate_bases):
        simplifed_alt_allele = variant_utils.simplify_alleles(
            candidate_variant.reference_bases, alt_allele)
        if simplifed_true_allele == simplifed_alt_allele:
          return alt_index + 1
      # If nothing matched, we don't have this alt, so the alt allele index for
      # should be 0 (i.e., not any alt).
      return 0

  # If our candidate_variant is a reference call, return a (0, 0) genotype.
  if variant_utils.is_ref(candidate_variant):
    return (0, 0)
  else:
    return tuple(
        sorted(
            _match_one_allele(true_allele) for true_allele in
            variant_utils.genotype_as_alleles(truth_variant)))
</source>
<source file="systems/deepvariant-0.9.0/deepvariant/labeler/positional_labeler.py" startline="162" endline="230" pcid="184">
def _genotype_from_matched_truth(candidate_variant, truth_variant):
  """Gets the diploid genotype for candidate_variant from matched truth_variant.

  This method figures out the genotype for candidate_variant by matching alleles
  in candidate_variant with those used by the genotype assigned to
  truth_variant. For example, if candidate is A/C and truth is A/C with a 0/1
  genotype, then this function would return (0, 1) indicating that there's one
  copy of the A allele and one of C in truth. If the true genotype is 1/1, then
  this routine would return (1, 1).

  The routine allows candidate_variant and truth_variant to differ in both
  the number of alternate alleles, and even in the representation of the same
  alleles due to those differences. For example, candidate could be:

      AGT/A/AGTGT => 2 bp deletion and 2 bp insertion

  and truth could have:

      A/AGT => just the simplified 2 bp insertion

  And this routine will correctly equate the AGT/AGTGT allele in candidate
  with the A/AGT in truth and use the number of copies of AGT in truth to
  compute the number of copies of AGTGT when determining the returned genotype.

  Args:
    candidate_variant: Our candidate third_party.nucleus.protos.Variant variant.
    truth_variant: Our third_party.nucleus.protos.Variant truth variant
      containing true alleles and genotypes.

  Returns:
    A tuple genotypes with the same semantics at the genotype field of the
    VariantCall proto.

  Raises:
    ValueError: If candidate_variant is None, truth_variant is None, or
      truth_variant doesn't have genotypes.
  """
  if candidate_variant is None:
    raise ValueError('candidate_variant cannot be None')
  if truth_variant is None:
    raise ValueError('truth_variant cannot be None')
  if not variantcall_utils.has_genotypes(
      variant_utils.only_call(truth_variant)):
    raise ValueError('truth_variant needs genotypes to be used for labeling',
                     truth_variant)

  def _match_one_allele(true_allele):
    if true_allele == truth_variant.reference_bases:
      return 0
    else:
      simplified_true_allele = variant_utils.simplify_alleles(
          truth_variant.reference_bases, true_allele)
      for alt_index, alt_allele in enumerate(candidate_variant.alternate_bases):
        simplified_alt_allele = variant_utils.simplify_alleles(
            candidate_variant.reference_bases, alt_allele)
        if simplified_true_allele == simplified_alt_allele:
          return alt_index + 1
      # If nothing matched, we don't have this alt, so the alt allele index for
      # should be 0 (i.e., not any alt).
      return 0

  # If our candidate_variant is a reference call, return a (0, 0) genotype.
  if variant_utils.is_ref(candidate_variant):
    return (0, 0)
  else:
    return tuple(
        _match_one_allele(true_allele)
        for true_allele in variant_utils.genotype_as_alleles(
            variant_utils.unphase_all_genotypes(truth_variant)))
</source>
</class>

<class classid="3" nclones="2" nlines="11" similarity="100">
<source file="systems/deepvariant-0.9.0/deepvariant/very_sensitive_caller_test.py" startline="70" endline="84" pcid="206">
  def fake_allele_counter(self, start_pos, counts):
    allele_counter = mock.Mock()
    # pylint: disable=g-complex-comprehension
    allele_counter.summary_counts.return_value = [
        deepvariant_pb2.AlleleCountSummary(
            ref_supporting_read_count=n_ref,
            total_read_count=n_ref + n_alt,
            ref_base=ref,
            reference_name='chr1',
            position=start_pos + i)
        for i, (n_alt, n_ref, ref) in enumerate(counts)
    ]
    # pylint: enable=g-complex-comprehension
    return allele_counter

</source>
<source file="systems/deepvariant-0.9.0/deepvariant/vcf_caller_test.py" startline="74" endline="88" pcid="283">
  def fake_allele_counter(self, start_pos, counts):
    allele_counter = mock.Mock()
    # pylint: disable=g-complex-comprehension
    allele_counter.summary_counts.return_value = [
        deepvariant_pb2.AlleleCountSummary(
            ref_supporting_read_count=n_ref,
            total_read_count=n_ref + n_alt,
            ref_base=ref,
            reference_name='chr1',
            position=start_pos + i)
        for i, (n_alt, n_ref, ref) in enumerate(counts)
    ]
    # pylint: enable=g-complex-comprehension
    return allele_counter

</source>
</class>

<class classid="4" nclones="2" nlines="21" similarity="90">
<source file="systems/deepvariant-0.9.0/deepvariant/very_sensitive_caller_test.py" startline="85" endline="121" pcid="207">
  def test_calls_from_allele_counts(self):
    # Our test AlleleCounts are 5 positions:
    #
    # 10: A ref [no reads]
    # 11: G/C variant
    # 12: G ref [no reads]
    # 13: G ref [no reads]
    # 14: T/C variant
    #
    # The ref sites have no reads for ref or any alt simply because it
    # simplifies comparing them with the expected variant genotype likelihoods.
    # We aren't testing the correctness of the gvcf calculation here (that's
    # elsewhere) but rather focusing here on the separation of variants from
    # gvcf records, and the automatic merging of the gvcf blocks.
    allele_counter = self.fake_allele_counter(10, [
        (0, 0, 'A'),
        (10, 10, 'G'),
        (0, 0, 'G'),
        (0, 0, 'G'),
        (10, 10, 'T'),
    ])
    fake_candidates = [
        deepvariant_pb2.DeepVariantCall(
            variant=test_utils.make_variant(alleles=['G', 'C'], start=11)),
        deepvariant_pb2.DeepVariantCall(
            variant=test_utils.make_variant(alleles=['T', 'C'], start=14)),
    ]

    caller = self.make_test_caller(0.01, 100)
    with mock.patch.object(caller, 'cpp_variant_caller') as mock_cpp:
      mock_cpp.calls_from_allele_counter.return_value = fake_candidates
      candidates, _ = caller.calls_and_gvcfs(allele_counter, False)

    mock_cpp.calls_from_allele_counter.assert_called_once_with(allele_counter)
    self.assertEqual(candidates, fake_candidates)


</source>
<source file="systems/deepvariant-0.9.0/deepvariant/vcf_caller_test.py" startline="89" endline="126" pcid="284">
  def test_calls_from_vcf(self):
    # Our test AlleleCounts are 5 positions:
    #
    # 10: A ref [no reads]
    # 11: G/C variant
    # 12: G ref [no reads]
    # 13: G ref [no reads]
    # 14: T/C variant
    #
    # The ref sites have no reads for ref or any alt simply because it
    # simplifies comparing them with the expected variant genotype likelihoods.
    # We aren't testing the correctness of the gvcf calculation here (that's
    # elsewhere) but rather focusing here on the separation of variants from
    # gvcf records, and the automatic merging of the gvcf blocks.
    allele_counter = self.fake_allele_counter(10, [
        (0, 0, 'A'),
        (10, 10, 'G'),
        (0, 0, 'G'),
        (0, 0, 'G'),
        (10, 10, 'T'),
    ])
    fake_candidates = [
        deepvariant_pb2.DeepVariantCall(
            variant=test_utils.make_variant(alleles=['G', 'C'], start=11)),
        deepvariant_pb2.DeepVariantCall(
            variant=test_utils.make_variant(alleles=['T', 'C'], start=14)),
    ]

    caller = self.make_test_caller(0.01, 100)
    with mock.patch.object(caller, 'cpp_variant_caller') as mock_cpp:
      mock_cpp.calls_from_vcf.return_value = fake_candidates
      candidates, _ = caller.calls_and_gvcfs(allele_counter, False)

    mock_cpp.calls_from_vcf.assert_called_once_with(allele_counter,
                                                    caller.vcf_reader)
    self.assertEqual(candidates, fake_candidates)

  # Golden sets are created with learning/genomics/internal/create_golden.sh.
</source>
</class>

<class classid="5" nclones="2" nlines="14" similarity="73">
<source file="systems/deepvariant-0.9.0/deepvariant/realigner/python/ssw_wrap_test.py" startline="55" endline="71" pcid="242">
  def test_Align(self):
    """Tests the Align method."""
    aligner = ssw.Aligner()
    filter_ = ssw.Filter()
    length = aligner.set_reference_sequence(REF)
    self.assertEqual(len(REF), length)
    alignment = aligner.align(QUERY, filter_)
    self.assertEqual(21, alignment.sw_score)
    self.assertEqual(8, alignment.sw_score_next_best)
    self.assertEqual(8, alignment.ref_begin)
    self.assertEqual(21, alignment.ref_end)
    self.assertEqual(0, alignment.query_begin)
    self.assertEqual(14, alignment.query_end)
    self.assertEqual(4, alignment.ref_end_next_best)
    self.assertEqual(2, alignment.mismatches)
    self.assertEqual('4=1X4=1I5=', alignment.cigar_string)

</source>
<source file="systems/deepvariant-0.9.0/deepvariant/realigner/python/ssw_wrap_test.py" startline="72" endline="86" pcid="243">
  def test_Align2_reversed(self):
    """Tests the Align method, reversing query and ref from above."""
    aligner = ssw.Aligner()
    filter_ = ssw.Filter()
    aligner.set_reference_sequence(QUERY)
    alignment = aligner.align(REF, filter_)
    self.assertEqual(21, alignment.sw_score)
    self.assertEqual(8, alignment.query_begin)
    self.assertEqual(21, alignment.query_end)
    self.assertEqual(0, alignment.ref_begin)
    self.assertEqual(14, alignment.ref_end)
    self.assertEqual(2, alignment.mismatches)
    self.assertEqual('8S4=1X4=1D5=17S', alignment.cigar_string)


</source>
</class>

<class classid="6" nclones="2" nlines="18" similarity="100">
<source file="systems/deepvariant-0.9.0/deepvariant/realigner/python/ssw_misc_test.py" startline="51" endline="71" pcid="245">
  def test_short(self):
    """Test very short strings."""
    ref = 'tttt'
    query = 'ttAtt'
    match = 4
    mismatch = 2
    gap_extend_penalty = 2
    gap_open_penalty = 4

    aligner = ssw.Aligner.construct(
        match_score=match,
        mismatch_penalty=mismatch,
        gap_opening_penalty=gap_open_penalty,
        gap_extending_penalty=gap_extend_penalty)
    filter_ = ssw.Filter()
    length = aligner.set_reference_sequence(ref)
    self.assertEqual(len(ref), length)
    alignment = aligner.align(query, filter_)
    p(alignment)
    self.assertEqual('2=1I2=', alignment.cigar_string)

</source>
<source file="systems/deepvariant-0.9.0/deepvariant/realigner/python/ssw_misc_test.py" startline="72" endline="93" pcid="246">
  def test_longer(self):
    """Test longer strings, so the second-best alignment is considered."""
    ref = 'TTTTGGGGGGGGGGGGG'
    query = 'TTATTGGGGGGGGGGGGG'
    match = 4
    mismatch = 2
    gap_extend_penalty = 2
    gap_open_penalty = 4

    aligner = ssw.Aligner.construct(
        match_score=match,
        mismatch_penalty=mismatch,
        gap_opening_penalty=gap_open_penalty,
        gap_extending_penalty=gap_extend_penalty)
    filter_ = ssw.Filter()
    length = aligner.set_reference_sequence(ref)
    self.assertEqual(len(ref), length)
    alignment = aligner.align(query, filter_)
    p(alignment)
    self.assertEqual('2=1I15=', alignment.cigar_string)


</source>
</class>

<class classid="7" nclones="2" nlines="15" similarity="81">
<source file="systems/deepvariant-0.9.0/third_party/nucleus/io/python/vcf_writer_wrap_test.py" startline="284" endline="311" pcid="593">
  def test_round_trip_vcf(self, test_datum_name):
    # Round-trip variants through writing and reading:
    # 1. Read variants v1 from VcfReader;
    # 2. Write v1 to vcf using our VcfWriter;
    # 3. Read back in using VcfReader -- v2;
    # 4. compare v1 and v2.
    in_file = test_utils.genomics_core_testdata(test_datum_name)
    out_file = test_utils.test_tmpfile('output_' + test_datum_name)

    v1_reader = vcf.VcfReader(in_file)
    v1_records = list(v1_reader.iterate())
    self.assertTrue(v1_records, 'Reader failed to find records')

    header = copy.deepcopy(v1_reader.header)
    writer_options = variants_pb2.VcfWriterOptions()

    with vcf_writer.VcfWriter.to_file(out_file, header,
                                      writer_options) as writer:
      for record in v1_records:
        writer.write(record)

    v2_reader = vcf.VcfReader(out_file)
    v2_records = list(v2_reader.iterate())

    self.assertEqual(v1_records, v2_records,
                     'Round-tripped variants not as expected')


</source>
<source file="systems/deepvariant-0.9.0/third_party/nucleus/io/python/fastq_writer_wrap_test.py" startline="120" endline="144" pcid="619">
  def test_round_trip_fastq(self, test_datum_name):
    # Round-trip FASTQ records through writing and reading:
    # 1. Read records v1 from FastqReader;
    # 2. Write v1 to fastq using our FastqWriter;
    # 3. Read back in using FastqReader -- v2;
    # 4. compare v1 and v2.
    in_file = test_utils.genomics_core_testdata(test_datum_name)
    out_file = test_utils.test_tmpfile('output_' + test_datum_name)

    v1_reader = fastq.FastqReader(in_file)
    v1_records = list(v1_reader.iterate())
    self.assertTrue(v1_records, 'Reader failed to find records')

    writer_options = fastq_pb2.FastqWriterOptions()

    with fastq_writer.FastqWriter.to_file(out_file, writer_options) as writer:
      for record in v1_records:
        writer.write(record)

    v2_reader = fastq.FastqReader(out_file)
    v2_records = list(v2_reader.iterate())
    self.assertEqual(v1_records, v2_records,
                     'Round-tripped FASTQ files not as expected')


</source>
</class>

<class classid="8" nclones="3" nlines="13" similarity="76">
<source file="systems/deepvariant-0.9.0/third_party/nucleus/io/python/gff_writer_wrap_test.py" startline="65" endline="81" pcid="612">
  def test_writing_canned_records(self):
    """Tests writing all the records that are 'canned' in our tfrecord file."""
    # This file is in TFRecord format.
    tfrecord_file = test_utils.genomics_core_testdata(
        'test_features.gff.tfrecord')
    writer_options = gff_pb2.GffWriterOptions()
    gff_records = list(
        tfrecord.read_tfrecords(tfrecord_file, proto=gff_pb2.GffRecord))
    out_fname = test_utils.test_tmpfile('output.gff')
    with gff_writer.GffWriter.to_file(out_fname, self.header,
                                      writer_options) as writer:
      for record in gff_records:
        writer.write(record)

    with open(out_fname) as f:
      self.assertEqual(f.readlines(), self.expected_gff_content)

</source>
<source file="systems/deepvariant-0.9.0/third_party/nucleus/io/python/bed_writer_wrap_test.py" startline="67" endline="85" pcid="621">
  def test_writing_canned_records(self):
    """Tests writing all the records that are 'canned' in our tfrecord file."""
    # This file is in TFRecord format.
    tfrecord_file = test_utils.genomics_core_testdata(
        'test_regions.bed.tfrecord')

    header = bed_pb2.BedHeader(num_fields=12)
    writer_options = bed_pb2.BedWriterOptions()
    bed_records = list(
        tfrecord.read_tfrecords(tfrecord_file, proto=bed_pb2.BedRecord))
    out_fname = test_utils.test_tmpfile('output.bed')
    with bed_writer.BedWriter.to_file(out_fname, header,
                                      writer_options) as writer:
      for record in bed_records:
        writer.write(record)

    with gfile.Open(out_fname, 'r') as f:
      self.assertEqual(f.readlines(), self.expected_bed_content)

</source>
<source file="systems/deepvariant-0.9.0/third_party/nucleus/io/python/fastq_writer_wrap_test.py" startline="80" endline="96" pcid="616">
  def test_writing_canned_records(self):
    """Tests writing all the variants that are 'canned' in our tfrecord file."""
    # This file is in TFRecord format.
    tfrecord_file = test_utils.genomics_core_testdata(
        'test_reads.fastq.tfrecord')

    writer_options = fastq_pb2.FastqWriterOptions()
    fastq_records = list(
        tfrecord.read_tfrecords(tfrecord_file, proto=fastq_pb2.FastqRecord))
    out_fname = test_utils.test_tmpfile('output.fastq')
    with fastq_writer.FastqWriter.to_file(out_fname, writer_options) as writer:
      for record in fastq_records:
        writer.write(record)

    with gfile.Open(out_fname, 'r') as f:
      self.assertEqual(f.readlines(), self.expected_fastq_content)

</source>
</class>

</clones>
