<html>
<head>
    <title>NiCad6 Clone Report</title>
    <style type="text/css">
        body {font-family:sans-serif;}
        table {background-color:white; border:0px; padding:0px; border-spacing:4px; width:auto; margin-left:30px; margin-right:auto;}
        td {background-color:rgba(192,212,238,0.8); border:0px; padding:8px; width:auto; vertical-align:top; border-radius:8px}
        pre {background-color:white; padding:4px;}
        a {color:darkblue;}
    </style>
</head>
<body>
<h2>NiCad6 Clone Report</h2>
<table>
<tr style="font-size:14pt">
<td><b>System:</b> &nbsp; deepvariant-0.10.0</td>
<td><b>Clone pairs:</b> &nbsp; 11</td>
<td><b>Clone classes:</b> &nbsp; 9</td>
</tr>
<tr style="font-size:12pt">
<td style="background-color:white">Clone type: &nbsp; 3-2</td>
<td style="background-color:white">Granularity: &nbsp; functions-blind</td>
<td style="background-color:white">Max diff threshold: &nbsp; 30%</td>
<td style="background-color:white">Clone size: &nbsp; 10 - 2500 lines</td>
<td style="background-color:white">Total functions-blind: &nbsp; 675</td>
</tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 1:</b> &nbsp; 2 fragments, nominal size 13 lines, similarity 78%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag22')" href="javascript:;">
deepvariant-0.10.0/deepvariant/vcf_stats_vis.py: 166-185
</a>
<div class="mid" id="frag22" style="display:none"><pre>
  return qual_histogram


def _build_gq_histogram(data):
  """Create the Genotype quality (GQ) histogram."""
  # gq = genotype quality, found at :GQ: in FORMAT column of VCF
  width = 200
  height = 200
  title = 'Genotype quality'
  gq_data = _integer_counts_to_histogram(data)
  gq_histogram = _placeholder_for_empty_chart(
      'No entries in VCF with GQ', width=width, height=height, title=title)
  if not gq_data.empty:
    # standardize x-axis limits across reports
    domain = [min(0, data[0][0]), max(150, data[-1][0])]
    # s = bin_start, e = bin_end, c = count
    gq_histogram = alt.Chart(gq_data).mark_bar(color=BAR_COLOR_GQ) \
        .encode(
            x=alt.X('s', title='GQ', scale=alt.Scale(domain=domain)),
            x2='e',
</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag28')" href="javascript:;">
deepvariant-0.10.0/deepvariant/vcf_stats_vis.py: 325-340
</a>
<div class="mid" id="frag28" style="display:none"><pre>
                  title=title) \
      .interactive(bind_y=False)

    indel_log = alt.Chart(indel_size_data).mark_bar().encode(
        x=alt.X('s', title='size'),
        x2='e',
        y=alt.Y(
            'c',
            title='Count',
            axis=alt.Axis(format='s'),
            scale=alt.Scale(type='log', base=10)),
        color=alt.Color('type', sort=ordered_labels,
                        scale=alt.Scale(scheme='set1'))) \
      .properties(width=400, height=100) \
      .interactive(bind_y=False)

</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 2:</b> &nbsp; 2 fragments, nominal size 11 lines, similarity 100%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag158')" href="javascript:;">
deepvariant-0.10.0/deepvariant/vcf_candidate_importer_test.py: 74-88
</a>
<div class="mid" id="frag158" style="display:none"><pre>
  def fake_allele_counter(self, start_pos, counts):
    allele_counter = mock.Mock()
    # pylint: disable=g-complex-comprehension
    allele_counter.summary_counts.return_value = [
        deepvariant_pb2.AlleleCountSummary(
            ref_supporting_read_count=n_ref,
            total_read_count=n_ref + n_alt,
            ref_base=ref,
            reference_name='chr1',
            position=start_pos + i)
        for i, (n_alt, n_ref, ref) in enumerate(counts)
    ]
    # pylint: enable=g-complex-comprehension
    return allele_counter

</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag209')" href="javascript:;">
deepvariant-0.10.0/deepvariant/very_sensitive_caller_test.py: 70-84
</a>
<div class="mid" id="frag209" style="display:none"><pre>
  def fake_allele_counter(self, start_pos, counts):
    allele_counter = mock.Mock()
    # pylint: disable=g-complex-comprehension
    allele_counter.summary_counts.return_value = [
        deepvariant_pb2.AlleleCountSummary(
            ref_supporting_read_count=n_ref,
            total_read_count=n_ref + n_alt,
            ref_base=ref,
            reference_name='chr1',
            position=start_pos + i)
        for i, (n_alt, n_ref, ref) in enumerate(counts)
    ]
    # pylint: enable=g-complex-comprehension
    return allele_counter

</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 3:</b> &nbsp; 2 fragments, nominal size 21 lines, similarity 90%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag159')" href="javascript:;">
deepvariant-0.10.0/deepvariant/vcf_candidate_importer_test.py: 89-126
</a>
<div class="mid" id="frag159" style="display:none"><pre>
  def test_calls_from_vcf(self):
    # Our test AlleleCounts are 5 positions:
    #
    # 10: A ref [no reads]
    # 11: G/C variant
    # 12: G ref [no reads]
    # 13: G ref [no reads]
    # 14: T/C variant
    #
    # The ref sites have no reads for ref or any alt simply because it
    # simplifies comparing them with the expected variant genotype likelihoods.
    # We aren't testing the correctness of the gvcf calculation here (that's
    # elsewhere) but rather focusing here on the separation of variants from
    # gvcf records, and the automatic merging of the gvcf blocks.
    allele_counter = self.fake_allele_counter(10, [
        (0, 0, 'A'),
        (10, 10, 'G'),
        (0, 0, 'G'),
        (0, 0, 'G'),
        (10, 10, 'T'),
    ])
    fake_candidates = [
        deepvariant_pb2.DeepVariantCall(
            variant=test_utils.make_variant(alleles=['G', 'C'], start=11)),
        deepvariant_pb2.DeepVariantCall(
            variant=test_utils.make_variant(alleles=['T', 'C'], start=14)),
    ]

    caller = self.make_test_caller(0.01, 100)
    with mock.patch.object(caller, 'cpp_variant_caller') as mock_cpp:
      mock_cpp.calls_from_vcf.return_value = fake_candidates
      candidates, _ = caller.calls_and_gvcfs(allele_counter, False)

    mock_cpp.calls_from_vcf.assert_called_once_with(allele_counter,
                                                    caller.vcf_reader)
    self.assertEqual(candidates, fake_candidates)

  # Golden sets are created with learning/genomics/internal/create_golden.sh.
</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag210')" href="javascript:;">
deepvariant-0.10.0/deepvariant/very_sensitive_caller_test.py: 85-121
</a>
<div class="mid" id="frag210" style="display:none"><pre>
  def test_calls_from_allele_counts(self):
    # Our test AlleleCounts are 5 positions:
    #
    # 10: A ref [no reads]
    # 11: G/C variant
    # 12: G ref [no reads]
    # 13: G ref [no reads]
    # 14: T/C variant
    #
    # The ref sites have no reads for ref or any alt simply because it
    # simplifies comparing them with the expected variant genotype likelihoods.
    # We aren't testing the correctness of the gvcf calculation here (that's
    # elsewhere) but rather focusing here on the separation of variants from
    # gvcf records, and the automatic merging of the gvcf blocks.
    allele_counter = self.fake_allele_counter(10, [
        (0, 0, 'A'),
        (10, 10, 'G'),
        (0, 0, 'G'),
        (0, 0, 'G'),
        (10, 10, 'T'),
    ])
    fake_candidates = [
        deepvariant_pb2.DeepVariantCall(
            variant=test_utils.make_variant(alleles=['G', 'C'], start=11)),
        deepvariant_pb2.DeepVariantCall(
            variant=test_utils.make_variant(alleles=['T', 'C'], start=14)),
    ]

    caller = self.make_test_caller(0.01, 100)
    with mock.patch.object(caller, 'cpp_variant_caller') as mock_cpp:
      mock_cpp.calls_from_allele_counter.return_value = fake_candidates
      candidates, _ = caller.calls_and_gvcfs(allele_counter, False)

    mock_cpp.calls_from_allele_counter.assert_called_once_with(allele_counter)
    self.assertEqual(candidates, fake_candidates)


</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 4:</b> &nbsp; 2 fragments, nominal size 28 lines, similarity 92%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag173')" href="javascript:;">
deepvariant-0.10.0/deepvariant/labeler/variant_labeler.py: 208-276
</a>
<div class="mid" id="frag173" style="display:none"><pre>
def _genotype_from_matched_truth(candidate_variant, truth_variant):
  """Gets the diploid genotype for candidate_variant from matched truth_variant.

  This method figures out the genotype for candidate_variant by matching alleles
  in candidate_variant with those used by the genotype assigned to
  truth_variant. For example, if candidate is A/C and truth is A/C with a 0/1
  genotype, then this function would return (0, 1) indicating that there's one
  copy of the A allele and one of C in truth. If the true genotype is 1/1, then
  this routine would return (1, 1).

  The routine allows candidate_variant and truth_variant to differ in both
  the number of alternate alleles, and even in the representation of the same
  alleles due to those differences. For example, candidate could be:

      AGT/A/AGTGT =&gt; 2 bp deletion and 2 bp insertion

  and truth could have:

      A/AGT =&gt; just the simplified 2 bp insertion

  And this routine will correctly equate the AGT/AGTGT allele in candidate
  with the A/AGT in truth and use the number of copies of AGT in truth to
  compute the number of copies of AGTGT when determining the returned genotype.

  Args:
    candidate_variant: Our candidate third_party.nucleus.protos.Variant variant.
    truth_variant: Our third_party.nucleus.protos.Variant truth variant
      containing true alleles and genotypes.

  Returns:
    A tuple genotypes with the same semantics at the genotype field of the
    VariantCall proto.

  Raises:
    ValueError: If candidate_variant is None, truth_variant is None, or
      truth_variant doesn't have genotypes.
  """
  if candidate_variant is None:
    raise ValueError('candidate_variant cannot be None')
  if truth_variant is None:
    raise ValueError('truth_variant cannot be None')
  if not variantcall_utils.has_genotypes(
      variant_utils.only_call(truth_variant)):
    raise ValueError('truth_variant needs genotypes to be used for labeling',
                     truth_variant)

  def _match_one_allele(true_allele):
    if true_allele == truth_variant.reference_bases:
      return 0
    else:
      simplifed_true_allele = variant_utils.simplify_alleles(
          truth_variant.reference_bases, true_allele)
      for alt_index, alt_allele in enumerate(candidate_variant.alternate_bases):
        simplifed_alt_allele = variant_utils.simplify_alleles(
            candidate_variant.reference_bases, alt_allele)
        if simplifed_true_allele == simplifed_alt_allele:
          return alt_index + 1
      # If nothing matched, we don't have this alt, so the alt allele index for
      # should be 0 (i.e., not any alt).
      return 0

  # If our candidate_variant is a reference call, return a (0, 0) genotype.
  if variant_utils.is_ref(candidate_variant):
    return (0, 0)
  else:
    return tuple(
        sorted(
            _match_one_allele(true_allele) for true_allele in
            variant_utils.genotype_as_alleles(truth_variant)))
</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag189')" href="javascript:;">
deepvariant-0.10.0/deepvariant/labeler/positional_labeler.py: 161-229
</a>
<div class="mid" id="frag189" style="display:none"><pre>
def _genotype_from_matched_truth(candidate_variant, truth_variant):
  """Gets the diploid genotype for candidate_variant from matched truth_variant.

  This method figures out the genotype for candidate_variant by matching alleles
  in candidate_variant with those used by the genotype assigned to
  truth_variant. For example, if candidate is A/C and truth is A/C with a 0/1
  genotype, then this function would return (0, 1) indicating that there's one
  copy of the A allele and one of C in truth. If the true genotype is 1/1, then
  this routine would return (1, 1).

  The routine allows candidate_variant and truth_variant to differ in both
  the number of alternate alleles, and even in the representation of the same
  alleles due to those differences. For example, candidate could be:

      AGT/A/AGTGT =&gt; 2 bp deletion and 2 bp insertion

  and truth could have:

      A/AGT =&gt; just the simplified 2 bp insertion

  And this routine will correctly equate the AGT/AGTGT allele in candidate
  with the A/AGT in truth and use the number of copies of AGT in truth to
  compute the number of copies of AGTGT when determining the returned genotype.

  Args:
    candidate_variant: Our candidate third_party.nucleus.protos.Variant variant.
    truth_variant: Our third_party.nucleus.protos.Variant truth variant
      containing true alleles and genotypes.

  Returns:
    A tuple genotypes with the same semantics at the genotype field of the
    VariantCall proto.

  Raises:
    ValueError: If candidate_variant is None, truth_variant is None, or
      truth_variant doesn't have genotypes.
  """
  if candidate_variant is None:
    raise ValueError('candidate_variant cannot be None')
  if truth_variant is None:
    raise ValueError('truth_variant cannot be None')
  if not variantcall_utils.has_genotypes(
      variant_utils.only_call(truth_variant)):
    raise ValueError('truth_variant needs genotypes to be used for labeling',
                     truth_variant)

  def _match_one_allele(true_allele):
    if true_allele == truth_variant.reference_bases:
      return 0
    else:
      simplified_true_allele = variant_utils.simplify_alleles(
          truth_variant.reference_bases, true_allele)
      for alt_index, alt_allele in enumerate(candidate_variant.alternate_bases):
        simplified_alt_allele = variant_utils.simplify_alleles(
            candidate_variant.reference_bases, alt_allele)
        if simplified_true_allele == simplified_alt_allele:
          return alt_index + 1
      # If nothing matched, we don't have this alt, so the alt allele index for
      # should be 0 (i.e., not any alt).
      return 0

  # If our candidate_variant is a reference call, return a (0, 0) genotype.
  if variant_utils.is_ref(candidate_variant):
    return (0, 0)
  else:
    return tuple(
        _match_one_allele(true_allele)
        for true_allele in variant_utils.genotype_as_alleles(
            variant_utils.unphase_all_genotypes(truth_variant)))
</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 5:</b> &nbsp; 2 fragments, nominal size 14 lines, similarity 73%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag242')" href="javascript:;">
deepvariant-0.10.0/deepvariant/realigner/python/ssw_wrap_test.py: 55-71
</a>
<div class="mid" id="frag242" style="display:none"><pre>
  def test_Align(self):
    """Tests the Align method."""
    aligner = ssw.Aligner()
    filter_ = ssw.Filter()
    length = aligner.set_reference_sequence(REF)
    self.assertLen(REF, length)
    alignment = aligner.align(QUERY, filter_)
    self.assertEqual(21, alignment.sw_score)
    self.assertEqual(8, alignment.sw_score_next_best)
    self.assertEqual(8, alignment.ref_begin)
    self.assertEqual(21, alignment.ref_end)
    self.assertEqual(0, alignment.query_begin)
    self.assertEqual(14, alignment.query_end)
    self.assertEqual(4, alignment.ref_end_next_best)
    self.assertEqual(2, alignment.mismatches)
    self.assertEqual(six.b('4=1X4=1I5='), alignment.cigar_string)

</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag243')" href="javascript:;">
deepvariant-0.10.0/deepvariant/realigner/python/ssw_wrap_test.py: 72-86
</a>
<div class="mid" id="frag243" style="display:none"><pre>
  def test_Align2_reversed(self):
    """Tests the Align method, reversing query and ref from above."""
    aligner = ssw.Aligner()
    filter_ = ssw.Filter()
    aligner.set_reference_sequence(QUERY)
    alignment = aligner.align(REF, filter_)
    self.assertEqual(21, alignment.sw_score)
    self.assertEqual(8, alignment.query_begin)
    self.assertEqual(21, alignment.query_end)
    self.assertEqual(0, alignment.ref_begin)
    self.assertEqual(14, alignment.ref_end)
    self.assertEqual(2, alignment.mismatches)
    self.assertEqual(six.b('8S4=1X4=1D5=17S'), alignment.cigar_string)


</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 6:</b> &nbsp; 2 fragments, nominal size 18 lines, similarity 100%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag245')" href="javascript:;">
deepvariant-0.10.0/deepvariant/realigner/python/ssw_misc_test.py: 51-71
</a>
<div class="mid" id="frag245" style="display:none"><pre>
  def test_short(self):
    """Test very short strings."""
    ref = 'tttt'
    query = 'ttAtt'
    match = 4
    mismatch = 2
    gap_extend_penalty = 2
    gap_open_penalty = 4

    aligner = ssw.Aligner.construct(
        match_score=match,
        mismatch_penalty=mismatch,
        gap_opening_penalty=gap_open_penalty,
        gap_extending_penalty=gap_extend_penalty)
    filter_ = ssw.Filter()
    length = aligner.set_reference_sequence(ref)
    self.assertLen(ref, length)
    alignment = aligner.align(query, filter_)
    p(alignment)
    self.assertEqual(six.b('2=1I2='), alignment.cigar_string)

</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag246')" href="javascript:;">
deepvariant-0.10.0/deepvariant/realigner/python/ssw_misc_test.py: 72-93
</a>
<div class="mid" id="frag246" style="display:none"><pre>
  def test_longer(self):
    """Test longer strings, so the second-best alignment is considered."""
    ref = 'TTTTGGGGGGGGGGGGG'
    query = 'TTATTGGGGGGGGGGGGG'
    match = 4
    mismatch = 2
    gap_extend_penalty = 2
    gap_open_penalty = 4

    aligner = ssw.Aligner.construct(
        match_score=match,
        mismatch_penalty=mismatch,
        gap_opening_penalty=gap_open_penalty,
        gap_extending_penalty=gap_extend_penalty)
    filter_ = ssw.Filter()
    length = aligner.set_reference_sequence(ref)
    self.assertLen(ref, length)
    alignment = aligner.align(query, filter_)
    p(alignment)
    self.assertEqual(six.b('2=1I15='), alignment.cigar_string)


</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 7:</b> &nbsp; 2 fragments, nominal size 12 lines, similarity 91%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag348')" href="javascript:;">
deepvariant-0.10.0/third_party/nucleus/util/vis_test.py: 186-200
</a>
<div class="mid" id="frag348" style="display:none"><pre>
  def test_save_to_png(self, shape, should_succeed):
    arr = _image_array(shape)

    if should_succeed:
      temp_dir = self.create_tempdir().full_path
      output_path = os.path.join(temp_dir, 'test.png')
      # check the file doesn't already exist before function runs
      self.assertEmpty(glob.glob(output_path))
      vis.save_to_png(arr, path=output_path)
      self.assertLen(glob.glob(output_path), 1)
    else:
      self.assertRaisesWithPredicateMatch(
          ValueError, lambda x: str(x).index('dimensions') != -1,
          vis.save_to_png, arr)

</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag349')" href="javascript:;">
deepvariant-0.10.0/third_party/nucleus/util/vis_test.py: 208-222
</a>
<div class="mid" id="frag349" style="display:none"><pre>
  def test_array_to_png_works_with_floats(self, shape, should_succeed):
    arr = np.random.random(shape)

    if should_succeed:
      temp_dir = self.create_tempdir().full_path
      output_path = os.path.join(temp_dir, 'test.png')
      # Check the file doesn't already exist before function runs.
      self.assertEmpty(glob.glob(output_path))
      vis.array_to_png(arr, path=output_path)
      self.assertLen(glob.glob(output_path), 1)
    else:
      self.assertRaisesWithPredicateMatch(
          ValueError, lambda x: str(x).index('dimensions') != -1,
          vis.array_to_png, arr)

</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 8:</b> &nbsp; 2 fragments, nominal size 15 lines, similarity 81%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag626')" href="javascript:;">
deepvariant-0.10.0/third_party/nucleus/io/python/vcf_writer_wrap_test.py: 284-311
</a>
<div class="mid" id="frag626" style="display:none"><pre>
  def test_round_trip_vcf(self, test_datum_name):
    # Round-trip variants through writing and reading:
    # 1. Read variants v1 from VcfReader;
    # 2. Write v1 to vcf using our VcfWriter;
    # 3. Read back in using VcfReader -- v2;
    # 4. compare v1 and v2.
    in_file = test_utils.genomics_core_testdata(test_datum_name)
    out_file = test_utils.test_tmpfile('output_' + test_datum_name)

    v1_reader = vcf.VcfReader(in_file)
    v1_records = list(v1_reader.iterate())
    self.assertTrue(v1_records, 'Reader failed to find records')

    header = copy.deepcopy(v1_reader.header)
    writer_options = variants_pb2.VcfWriterOptions()

    with vcf_writer.VcfWriter.to_file(out_file, header,
                                      writer_options) as writer:
      for record in v1_records:
        writer.write(record)

    v2_reader = vcf.VcfReader(out_file)
    v2_records = list(v2_reader.iterate())

    self.assertEqual(v1_records, v2_records,
                     'Round-tripped variants not as expected')


</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag652')" href="javascript:;">
deepvariant-0.10.0/third_party/nucleus/io/python/fastq_writer_wrap_test.py: 120-144
</a>
<div class="mid" id="frag652" style="display:none"><pre>
  def test_round_trip_fastq(self, test_datum_name):
    # Round-trip FASTQ records through writing and reading:
    # 1. Read records v1 from FastqReader;
    # 2. Write v1 to fastq using our FastqWriter;
    # 3. Read back in using FastqReader -- v2;
    # 4. compare v1 and v2.
    in_file = test_utils.genomics_core_testdata(test_datum_name)
    out_file = test_utils.test_tmpfile('output_' + test_datum_name)

    v1_reader = fastq.FastqReader(in_file)
    v1_records = list(v1_reader.iterate())
    self.assertTrue(v1_records, 'Reader failed to find records')

    writer_options = fastq_pb2.FastqWriterOptions()

    with fastq_writer.FastqWriter.to_file(out_file, writer_options) as writer:
      for record in v1_records:
        writer.write(record)

    v2_reader = fastq.FastqReader(out_file)
    v2_records = list(v2_reader.iterate())
    self.assertEqual(v1_records, v2_records,
                     'Round-tripped FASTQ files not as expected')


</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 9:</b> &nbsp; 3 fragments, nominal size 13 lines, similarity 76%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag645')" href="javascript:;">
deepvariant-0.10.0/third_party/nucleus/io/python/gff_writer_wrap_test.py: 65-81
</a>
<div class="mid" id="frag645" style="display:none"><pre>
  def test_writing_canned_records(self):
    """Tests writing all the records that are 'canned' in our tfrecord file."""
    # This file is in TFRecord format.
    tfrecord_file = test_utils.genomics_core_testdata(
        'test_features.gff.tfrecord')
    writer_options = gff_pb2.GffWriterOptions()
    gff_records = list(
        tfrecord.read_tfrecords(tfrecord_file, proto=gff_pb2.GffRecord))
    out_fname = test_utils.test_tmpfile('output.gff')
    with gff_writer.GffWriter.to_file(out_fname, self.header,
                                      writer_options) as writer:
      for record in gff_records:
        writer.write(record)

    with open(out_fname) as f:
      self.assertEqual(f.readlines(), self.expected_gff_content)

</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag654')" href="javascript:;">
deepvariant-0.10.0/third_party/nucleus/io/python/bed_writer_wrap_test.py: 67-85
</a>
<div class="mid" id="frag654" style="display:none"><pre>
  def test_writing_canned_records(self):
    """Tests writing all the records that are 'canned' in our tfrecord file."""
    # This file is in TFRecord format.
    tfrecord_file = test_utils.genomics_core_testdata(
        'test_regions.bed.tfrecord')

    header = bed_pb2.BedHeader(num_fields=12)
    writer_options = bed_pb2.BedWriterOptions()
    bed_records = list(
        tfrecord.read_tfrecords(tfrecord_file, proto=bed_pb2.BedRecord))
    out_fname = test_utils.test_tmpfile('output.bed')
    with bed_writer.BedWriter.to_file(out_fname, header,
                                      writer_options) as writer:
      for record in bed_records:
        writer.write(record)

    with gfile.Open(out_fname, 'r') as f:
      self.assertEqual(f.readlines(), self.expected_bed_content)

</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag649')" href="javascript:;">
deepvariant-0.10.0/third_party/nucleus/io/python/fastq_writer_wrap_test.py: 80-96
</a>
<div class="mid" id="frag649" style="display:none"><pre>
  def test_writing_canned_records(self):
    """Tests writing all the variants that are 'canned' in our tfrecord file."""
    # This file is in TFRecord format.
    tfrecord_file = test_utils.genomics_core_testdata(
        'test_reads.fastq.tfrecord')

    writer_options = fastq_pb2.FastqWriterOptions()
    fastq_records = list(
        tfrecord.read_tfrecords(tfrecord_file, proto=fastq_pb2.FastqRecord))
    out_fname = test_utils.test_tmpfile('output.fastq')
    with fastq_writer.FastqWriter.to_file(out_fname, writer_options) as writer:
      for record in fastq_records:
        writer.write(record)

    with gfile.Open(out_fname, 'r') as f:
      self.assertEqual(f.readlines(), self.expected_fastq_content)

</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<script language="JavaScript">
function ShowHide(divId) { 
    if(document.getElementById(divId).style.display == 'none') {
        document.getElementById(divId).style.display='block';
    } else { 
        document.getElementById(divId).style.display = 'none';
    } 
}
</script>
</body>
</html>
