<clones>
<systeminfo processor="nicad6" system="imgaug-0.3.0" granularity="functions-blind" threshold="30%" minlines="10" maxlines="2500"/>
<cloneinfo npcs="3650" npairs="1658"/>
<runinfo ncompares="460088" cputime="803444"/>
<classinfo nclasses="235"/>

<class classid="1" nclones="2" nlines="10" similarity="100">
<source file="systems/imgaug-0.3.0/imgaug/augmenters/weather.py" startline="357" endline="367" pcid="21">
    def get_parameters(self):
        return [self.intensity_mean,
                self.alpha_min,
                self.alpha_multiplier,
                self.alpha_size_px_max,
                self.alpha_freq_exponent,
                self.intensity_freq_exponent,
                self.sparsity,
                self.density_multiplier,
                self.intensity_coarse_scale]

</source>
<source file="systems/imgaug-0.3.0/imgaug/augmenters/weather.py" startline="823" endline="833" pcid="31">
        return result

    def get_parameters(self):
        return [self.density,
                self.density_uniformity,
                self.flake_size,
                self.flake_size_uniformity,
                self.angle,
                self.speed,
                self.blur_sigma_fraction,
                self.blur_sigma_limits,
</source>
</class>

<class classid="2" nclones="2" nlines="30" similarity="83">
<source file="systems/imgaug-0.3.0/imgaug/augmenters/blend.py" startline="1070" endline="1110" pcid="78">
    def __init__(self, first=None, second=None, per_channel=False,
                 size_px_max=(2, 16), upscale_method=None,
                 iterations=(1, 3), aggregation_method="max",
                 sigmoid=True, sigmoid_thresh=None,
                 name=None, deterministic=False, random_state=None):
        upscale_method_default = iap.Choice(["nearest", "linear", "cubic"],
                                            p=[0.05, 0.6, 0.35])
        sigmoid_thresh_default = iap.Normal(0.0, 5.0)

        noise = iap.SimplexNoise(
            size_px_max=size_px_max,
            upscale_method=(upscale_method
                            if upscale_method is not None
                            else upscale_method_default)
        )

        if iterations != 1:
            noise = iap.IterativeNoiseAggregator(
                noise,
                iterations=iterations,
                aggregation_method=aggregation_method
            )

        use_sigmoid = (
            sigmoid is True
            or (ia.is_single_number(sigmoid) and sigmoid >= 0.01))
        if use_sigmoid:
            noise = iap.Sigmoid.create_for_noise(
                noise,
                threshold=(sigmoid_thresh
                           if sigmoid_thresh is not None
                           else sigmoid_thresh_default),
                activated=sigmoid
            )

        super(SimplexNoiseAlpha, self).__init__(
            factor=noise, first=first, second=second, per_channel=per_channel,
            name=name, deterministic=deterministic, random_state=random_state
        )


</source>
<source file="systems/imgaug-0.3.0/imgaug/augmenters/blend.py" startline="1305" endline="1345" pcid="79">
    def __init__(self, exponent=(-4, 4), first=None, second=None,
                 per_channel=False, size_px_max=(4, 16), upscale_method=None,
                 iterations=(1, 3), aggregation_method=["avg", "max"],
                 sigmoid=0.5, sigmoid_thresh=None,
                 name=None, deterministic=False, random_state=None):
        # pylint: disable=dangerous-default-value
        upscale_method_default = iap.Choice(["nearest", "linear", "cubic"],
                                            p=[0.05, 0.6, 0.35])
        sigmoid_thresh_default = iap.Normal(0.0, 5.0)

        noise = iap.FrequencyNoise(
            exponent=exponent,
            size_px_max=size_px_max,
            upscale_method=(upscale_method
                            if upscale_method is not None
                            else upscale_method_default)
        )

        if iterations != 1:
            noise = iap.IterativeNoiseAggregator(
                noise,
                iterations=iterations,
                aggregation_method=aggregation_method
            )

        use_sigmoid = (
            sigmoid is True
            or (ia.is_single_number(sigmoid) and sigmoid >= 0.01))
        if use_sigmoid:
            noise = iap.Sigmoid.create_for_noise(
                noise,
                threshold=(sigmoid_thresh
                           if sigmoid_thresh is not None
                           else sigmoid_thresh_default),
                activated=sigmoid
            )

        super(FrequencyNoiseAlpha, self).__init__(
            factor=noise, first=first, second=second, per_channel=per_channel,
            name=name, deterministic=deterministic, random_state=random_state
        )
</source>
</class>

<class classid="3" nclones="2" nlines="13" similarity="84">
<source file="systems/imgaug-0.3.0/imgaug/augmenters/segmentation.py" startline="897" endline="913" pcid="114">
    """

    def __init__(self, n_rows, n_cols, p_drop_points=0.4, p_replace=1.0,
                 max_size=128, interpolation="linear",
                 name=None, deterministic=False, random_state=None):
        super(RegularGridVoronoi, self).__init__(
            points_sampler=DropoutPointsSampler(
                RegularGridPointsSampler(n_rows, n_cols),
                p_drop_points
            ),
            p_replace=p_replace,
            max_size=max_size,
            interpolation=interpolation,
            name=name,
            deterministic=deterministic,
            random_state=random_state
        )
</source>
<source file="systems/imgaug-0.3.0/imgaug/augmenters/segmentation.py" startline="1071" endline="1087" pcid="115">
    """

    def __init__(self, n_rows_frac, n_cols_frac, p_drop_points=0.4,
                 p_replace=1.0, max_size=None, interpolation="linear",
                 name=None, deterministic=False, random_state=None):
        super(RelativeRegularGridVoronoi, self).__init__(
            points_sampler=DropoutPointsSampler(
                RelativeRegularGridPointsSampler(n_rows_frac, n_cols_frac),
                p_drop_points
            ),
            p_replace=p_replace,
            max_size=max_size,
            interpolation=interpolation,
            name=name,
            deterministic=deterministic,
            random_state=random_state
        )
</source>
</class>

<class classid="4" nclones="2" nlines="12" similarity="100">
<source file="systems/imgaug-0.3.0/imgaug/augmenters/convolutional.py" startline="297" endline="312" pcid="169">
    def __init__(self, alpha=0, lightness=1,
                 name=None, deterministic=False, random_state=None):
        alpha_param = iap.handle_continuous_param(
            alpha, "alpha",
            value_range=(0, 1.0), tuple_to_uniform=True, list_to_choice=True)
        lightness_param = iap.handle_continuous_param(
            lightness, "lightness",
            value_range=(0, None), tuple_to_uniform=True, list_to_choice=True)

        matrix_gen = _SharpeningMatrixGenerator(alpha_param, lightness_param)

        super(Sharpen, self).__init__(
            matrix=matrix_gen, name=name, deterministic=deterministic,
            random_state=random_state)


</source>
<source file="systems/imgaug-0.3.0/imgaug/augmenters/convolutional.py" startline="398" endline="413" pcid="172">
    def __init__(self, alpha=0, strength=1,
                 name=None, deterministic=False, random_state=None):
        alpha_param = iap.handle_continuous_param(
            alpha, "alpha",
            value_range=(0, 1.0), tuple_to_uniform=True, list_to_choice=True)
        strength_param = iap.handle_continuous_param(
            strength, "strength",
            value_range=(0, None), tuple_to_uniform=True, list_to_choice=True)

        matrix_gen = _EmbossMatrixGenerator(alpha_param, strength_param)

        super(Emboss, self).__init__(
            matrix=matrix_gen, name=name, deterministic=deterministic,
            random_state=random_state)


</source>
</class>

<class classid="5" nclones="3" nlines="17" similarity="76">
<source file="systems/imgaug-0.3.0/imgaug/augmenters/convolutional.py" startline="318" endline="340" pcid="171">
    def __call__(self, _image, nb_channels, random_state):
        alpha_sample = self.alpha.draw_sample(random_state=random_state)
        assert 0 <= alpha_sample <= 1.0, (
            "Expected 'alpha' to be in the interval [0.0, 1.0], "
            "got %.4f." % (alpha_sample,))
        lightness_sample = self.lightness.draw_sample(random_state=random_state)
        matrix_nochange = np.array([
            [0, 0, 0],
            [0, 1, 0],
            [0, 0, 0]
        ], dtype=np.float32)
        matrix_effect = np.array([
            [-1, -1, -1],
            [-1, 8+lightness_sample, -1],
            [-1, -1, -1]
        ], dtype=np.float32)
        matrix = (
            (1-alpha_sample) * matrix_nochange
            + alpha_sample * matrix_effect
        )
        return [matrix] * nb_channels


</source>
<source file="systems/imgaug-0.3.0/imgaug/augmenters/convolutional.py" startline="502" endline="529" pcid="177">
    def __call__(self, _image, nb_channels, random_state):
        alpha_sample = self.alpha.draw_sample(random_state=random_state)
        assert 0 <= alpha_sample <= 1.0, (
            "Expected 'alpha' to be in the interval [0.0, 1.0], "
            "got %.4f." % (alpha_sample,))
        matrix_nochange = np.array([
            [0, 0, 0],
            [0, 1, 0],
            [0, 0, 0]
        ], dtype=np.float32)
        matrix_effect = np.array([
            [0, 1, 0],
            [1, -4, 1],
            [0, 1, 0]
        ], dtype=np.float32)
        matrix = (
            (1-alpha_sample) * matrix_nochange
            + alpha_sample * matrix_effect
        )
        return [matrix] * nb_channels


# TODO add tests
# TODO merge EdgeDetect and DirectedEdgeDetect?
# TODO deprecate and rename to AngledEdgeDetect
# TODO rename arg "direction" to "angle"
# TODO change direction/angle value range to (0, 360)
# TODO move this to edges.py?
</source>
<source file="systems/imgaug-0.3.0/imgaug/augmenters/convolutional.py" startline="419" endline="443" pcid="174">
    def __call__(self, _image, nb_channels, random_state):
        alpha_sample = self.alpha.draw_sample(random_state=random_state)
        assert 0 <= alpha_sample <= 1.0, (
            "Expected 'alpha' to be in the interval [0.0, 1.0], "
            "got %.4f." % (alpha_sample,))
        strength_sample = self.strength.draw_sample(random_state=random_state)
        matrix_nochange = np.array([
            [0, 0, 0],
            [0, 1, 0],
            [0, 0, 0]
        ], dtype=np.float32)
        matrix_effect = np.array([
            [-1-strength_sample, 0-strength_sample, 0],
            [0-strength_sample, 1, 0+strength_sample],
            [0, 0+strength_sample, 1+strength_sample]
        ], dtype=np.float32)
        matrix = (
            (1-alpha_sample) * matrix_nochange
            + alpha_sample * matrix_effect
        )
        return [matrix] * nb_channels


# TODO add tests
# TODO move this to edges.py?
</source>
</class>

<class classid="6" nclones="3" nlines="18" similarity="70">
<source file="systems/imgaug-0.3.0/imgaug/augmenters/contrast.py" startline="93" endline="172" pcid="189">
def adjust_contrast_gamma(arr, gamma):
    """
    Adjust image contrast by scaling pixel values to ``255*((v/255)**gamma)``.

    dtype support::

        * ``uint8``: yes; fully tested (1) (2) (3)
        * ``uint16``: yes; tested (2) (3)
        * ``uint32``: yes; tested (2) (3)
        * ``uint64``: yes; tested (2) (3) (4)
        * ``int8``: limited; tested (2) (3) (5)
        * ``int16``: limited; tested (2) (3) (5)
        * ``int32``: limited; tested (2) (3) (5)
        * ``int64``: limited; tested (2) (3) (4) (5)
        * ``float16``: limited; tested (5)
        * ``float32``: limited; tested (5)
        * ``float64``: limited; tested (5)
        * ``float128``: no (6)
        * ``bool``: no (7)

        - (1) Handled by ``cv2``. Other dtypes are handled by ``skimage``.
        - (2) Normalization is done as ``I_ij/max``, where ``max`` is the
              maximum value of the dtype, e.g. 255 for ``uint8``. The
              normalization is reversed afterwards, e.g. ``result*255`` for
              ``uint8``.
        - (3) Integer-like values are not rounded after applying the contrast
              adjustment equation (before inverting the normalization to
              ``[0.0, 1.0]`` space), i.e. projection from continuous
              space to discrete happens according to floor function.
        - (4) Note that scikit-image doc says that integers are converted to
              ``float64`` values before applying the contrast normalization
              method. This might lead to inaccuracies for large 64bit integer
              values. Tests showed no indication of that happening though.
        - (5) Must not contain negative values. Values >=0 are fully supported.
        - (6) Leads to error in scikit-image.
        - (7) Does not make sense for contrast adjustments.

    Parameters
    ----------
    arr : numpy.ndarray
        Array for which to adjust the contrast. Dtype ``uint8`` is fastest.

    gamma : number
        Exponent for the contrast adjustment. Higher values darken the image.

    Returns
    -------
    numpy.ndarray
        Array with adjusted contrast.

    """
    if arr.size == 0:
        return np.copy(arr)

    # int8 is also possible according to docs
    # https://docs.opencv.org/3.0-beta/modules/core/doc/operations_on_arrays.html#cv2.LUT , but here it seemed
    # like `d` was 0 for CV_8S, causing that to fail
    if arr.dtype.name == "uint8":
        min_value, _center_value, max_value = \
            iadt.get_value_range_of_dtype(arr.dtype)
        dynamic_range = max_value - min_value

        value_range = np.linspace(0, 1.0, num=dynamic_range+1,
                                  dtype=np.float32)

        # 255 * ((I_ij/255)**gamma)
        # using np.float32(.) here still works when the input is a numpy array
        # of size 1
        table = (min_value
                 + (value_range ** np.float32(gamma))
                 * dynamic_range)
        arr_aug = cv2.LUT(
            arr, np.clip(table, min_value, max_value).astype(arr.dtype))
        if arr.ndim == 3 and arr_aug.ndim == 2:
            return arr_aug[..., np.newaxis]
        return arr_aug
    else:
        return ski_exposure.adjust_gamma(arr, gamma)


</source>
<source file="systems/imgaug-0.3.0/imgaug/augmenters/contrast.py" startline="262" endline="344" pcid="191">
# TODO quite similar to the other adjust_contrast_*() functions, make DRY
# TODO add dtype gating
def adjust_contrast_log(arr, gain):
    """
    Adjust image contrast by scaling pixels to ``255*gain*log_2(1+v/255)``.

    dtype support::

        * ``uint8``: yes; fully tested (1) (2) (3)
        * ``uint16``: yes; tested (2) (3)
        * ``uint32``: no; tested (2) (3) (8)
        * ``uint64``: no; tested (2) (3) (4) (8)
        * ``int8``: limited; tested (2) (3) (5)
        * ``int16``: limited; tested (2) (3) (5)
        * ``int32``: no; tested (2) (3) (5) (8)
        * ``int64``: no; tested (2) (3) (4) (5) (8)
        * ``float16``: limited; tested (5)
        * ``float32``: limited; tested (5)
        * ``float64``: limited; tested (5)
        * ``float128``: no (6)
        * ``bool``: no (7)

        - (1) Handled by ``cv2``. Other dtypes are handled by ``skimage``.
        - (2) Normalization is done as ``I_ij/max``, where ``max`` is the
              maximum value of the dtype, e.g. 255 for ``uint8``. The
              normalization is reversed afterwards, e.g. ``result*255`` for
              ``uint8``.
        - (3) Integer-like values are not rounded after applying the contrast
              adjustment equation (before inverting the normalization
              to ``[0.0, 1.0]`` space), i.e. projection from continuous
              space to discrete happens according to floor function.
        - (4) Note that scikit-image doc says that integers are converted to
              ``float64`` values before applying the contrast normalization
              method. This might lead to inaccuracies for large 64bit integer
              values. Tests showed no indication of that happening though.
        - (5) Must not contain negative values. Values >=0 are fully supported.
        - (6) Leads to error in scikit-image.
        - (7) Does not make sense for contrast adjustments.
        - (8) No longer supported since numpy 1.17. Previously: 'yes' for
              ``uint32``, ``uint64``; 'limited' for ``int32``, ``int64``.

    Parameters
    ----------
    arr : numpy.ndarray
        Array for which to adjust the contrast. Dtype ``uint8`` is fastest.

    gain : number
        Multiplier for the logarithm result. Values around 1.0 lead to a
        contrast-adjusted images. Values above 1.0 quickly lead to partially
        broken images due to exceeding the datatype's value range.

    Returns
    -------
    numpy.ndarray
        Array with adjusted contrast.

    """
    if arr.size == 0:
        return np.copy(arr)

    # int8 is also possible according to docs
    # https://docs.opencv.org/3.0-beta/modules/core/doc/operations_on_arrays.html#cv2.LUT , but here it seemed
    # like `d` was 0 for CV_8S, causing that to fail
    if arr.dtype.name == "uint8":
        min_value, _center_value, max_value = \
            iadt.get_value_range_of_dtype(arr.dtype)
        dynamic_range = max_value - min_value

        value_range = np.linspace(0, 1.0, num=dynamic_range+1,
                                  dtype=np.float32)

        # 255 * 1/(1 + exp(gain*(cutoff - I_ij/255)))
        # using np.float32(.) here still works when the input is a numpy array
        # of size 1
        gain = np.float32(gain)
        table = min_value + dynamic_range * gain * np.log2(1 + value_range)
        arr_aug = cv2.LUT(
            arr, np.clip(table, min_value, max_value).astype(arr.dtype))
        if arr.ndim == 3 and arr_aug.ndim == 2:
            return arr_aug[..., np.newaxis]
        return arr_aug
    else:
        return ski_exposure.adjust_log(arr, gain=gain)
</source>
<source file="systems/imgaug-0.3.0/imgaug/augmenters/contrast.py" startline="173" endline="261" pcid="190">
# TODO quite similar to the other adjust_contrast_*() functions, make DRY
def adjust_contrast_sigmoid(arr, gain, cutoff):
    """
    Adjust image contrast to ``255*1/(1+exp(gain*(cutoff-I_ij/255)))``.

    dtype support::

        * ``uint8``: yes; fully tested (1) (2) (3)
        * ``uint16``: yes; tested (2) (3)
        * ``uint32``: yes; tested (2) (3)
        * ``uint64``: yes; tested (2) (3) (4)
        * ``int8``: limited; tested (2) (3) (5)
        * ``int16``: limited; tested (2) (3) (5)
        * ``int32``: limited; tested (2) (3) (5)
        * ``int64``: limited; tested (2) (3) (4) (5)
        * ``float16``: limited; tested (5)
        * ``float32``: limited; tested (5)
        * ``float64``: limited; tested (5)
        * ``float128``: no (6)
        * ``bool``: no (7)

        - (1) Handled by ``cv2``. Other dtypes are handled by ``skimage``.
        - (2) Normalization is done as ``I_ij/max``, where ``max`` is the
              maximum value of the dtype, e.g. 255 for ``uint8``. The
              normalization is reversed afterwards, e.g. ``result*255``
              for ``uint8``.
        - (3) Integer-like values are not rounded after applying the contrast
              adjustment equation before inverting the normalization
              to ``[0.0, 1.0]`` space), i.e. projection from continuous
              space to discrete happens according to floor function.
        - (4) Note that scikit-image doc says that integers are converted to
              ``float64`` values before applying the contrast normalization
              method. This might lead to inaccuracies for large 64bit integer
              values. Tests showed no indication of that happening though.
        - (5) Must not contain negative values. Values >=0 are fully supported.
        - (6) Leads to error in scikit-image.
        - (7) Does not make sense for contrast adjustments.

    Parameters
    ----------
    arr : numpy.ndarray
        Array for which to adjust the contrast. Dtype ``uint8`` is fastest.

    gain : number
        Multiplier for the sigmoid function's output.
        Higher values lead to quicker changes from dark to light pixels.

    cutoff : number
        Cutoff that shifts the sigmoid function in horizontal direction.
        Higher values mean that the switch from dark to light pixels happens
        later, i.e. the pixels will remain darker.

    Returns
    -------
    numpy.ndarray
        Array with adjusted contrast.

    """
    if arr.size == 0:
        return np.copy(arr)

    # int8 is also possible according to docs
    # https://docs.opencv.org/3.0-beta/modules/core/doc/operations_on_arrays.html#cv2.LUT , but here it seemed
    # like `d` was 0 for CV_8S, causing that to fail
    if arr.dtype.name == "uint8":
        min_value, _center_value, max_value = \
            iadt.get_value_range_of_dtype(arr.dtype)
        dynamic_range = max_value - min_value

        value_range = np.linspace(0, 1.0, num=dynamic_range+1,
                                  dtype=np.float32)

        # 255 * 1/(1 + exp(gain*(cutoff - I_ij/255)))
        # using np.float32(.) here still works when the input is a numpy array
        # of size 1
        gain = np.float32(gain)
        cutoff = np.float32(cutoff)
        table = (min_value
                 + dynamic_range
                 * 1/(1 + np.exp(gain * (cutoff - value_range))))
        arr_aug = cv2.LUT(
            arr, np.clip(table, min_value, max_value).astype(arr.dtype))
        if arr.ndim == 3 and arr_aug.ndim == 2:
            return arr_aug[..., np.newaxis]
        return arr_aug
    else:
        return ski_exposure.adjust_sigmoid(arr, cutoff=cutoff, gain=gain)


</source>
</class>

<class classid="7" nclones="2" nlines="15" similarity="80">
<source file="systems/imgaug-0.3.0/imgaug/augmenters/contrast.py" startline="478" endline="495" pcid="193">
    Same as in the previous example, but ``gamma`` is sampled once per image
    *and* channel.

    """

    def __init__(self, gamma=1, per_channel=False, name=None, deterministic=False,
                 random_state=None):
        params1d = [iap.handle_continuous_param(
            gamma, "gamma", value_range=None, tuple_to_uniform=True,
            list_to_choice=True)]
        func = adjust_contrast_gamma
        super(GammaContrast, self).__init__(
            func, params1d, per_channel,
            dtypes_allowed=["uint8", "uint16", "uint32", "uint64",
                            "int8", "int16", "int32", "int64",
                            "float16", "float32", "float64"],
            dtypes_disallowed=["float96", "float128", "float256", "bool"],
            name=name,
</source>
<source file="systems/imgaug-0.3.0/imgaug/augmenters/contrast.py" startline="647" endline="666" pcid="195">

    Same as in the previous example, but ``gain`` is sampled once per image
    *and* channel.

    """
    def __init__(self, gain=1, per_channel=False,
                 name=None, deterministic=False, random_state=None):
        # TODO add inv parameter?
        params1d = [iap.handle_continuous_param(
            gain, "gain", value_range=(0, None), tuple_to_uniform=True,
            list_to_choice=True)]
        func = adjust_contrast_log

        super(LogContrast, self).__init__(
            func, params1d, per_channel,
            dtypes_allowed=["uint8", "uint16", "uint32", "uint64",
                            "int8", "int16", "int32", "int64",
                            "float16", "float32", "float64"],
            dtypes_disallowed=["float96", "float128", "float256", "bool"],
            name=name,
</source>
</class>

<class classid="8" nclones="2" nlines="18" similarity="100">
<source file="systems/imgaug-0.3.0/imgaug/augmenters/contrast.py" startline="1216" endline="1236" pcid="204">
            name="%s_AllChannelsCLAHE" % (name,))

        self.intensity_channel_based_applier = _IntensityChannelBasedApplier(
            from_colorspace, to_colorspace, name=name)

    def _augment_images(self, images, random_state, parents, hooks):
        iadt.gate_dtypes(
            images,
            allowed=["uint8"],
            disallowed=["bool",
                        "uint16", "uint32", "uint64", "uint128", "uint256",
                        "int8", "int16", "int32", "int64", "int128", "int256",
                        "float16", "float32", "float64", "float96", "float128",
                        "float256"],
            augmenter=self)

        def _augment_all_channels_clahe(images_normalized,
                                        random_state_derived):
            return self.all_channel_clahe._augment_images(
                images_normalized, random_state_derived, parents + [self],
                hooks)
</source>
<source file="systems/imgaug-0.3.0/imgaug/augmenters/contrast.py" startline="1447" endline="1467" pcid="211">
            AllChannelsHistogramEqualization(
                name="%s_AllChannelsHistogramEqualization" % (name,))

        self.intensity_channel_based_applier = _IntensityChannelBasedApplier(
            from_colorspace, to_colorspace, name=name)

    def _augment_images(self, images, random_state, parents, hooks):
        iadt.gate_dtypes(
            images,
            allowed=["uint8"],
            disallowed=["bool",
                        "uint16", "uint32", "uint64", "uint128", "uint256",
                        "int8", "int16", "int32", "int64", "int128", "int256",
                        "float16", "float32", "float64", "float96", "float128",
                        "float256"],
            augmenter=self)

        def _augment_all_channels_histogram_equalization(images_normalized,
                                                         random_state_derived):
            return self.all_channel_histogram_equalization._augment_images(
                images_normalized, random_state_derived, parents + [self],
</source>
</class>

<class classid="9" nclones="3" nlines="22" similarity="76">
<source file="systems/imgaug-0.3.0/imgaug/imgaug.py" startline="955" endline="1000" pcid="254">
def quokka_keypoints(size=None, extract=None):
    """Return example keypoints on the standard example quokke image.

    The keypoints cover the eyes, ears, nose and paws.

    Parameters
    ----------
    size : None or float or tuple of int or tuple of float, optional
        Size of the output image on which the keypoints are placed. If
        ``None``, then the keypoints are not projected to any new size
        (positions on the original image are used). ``float`` s lead to
        relative size changes, ``int`` s to absolute sizes in pixels.

    extract : None or 'square' or tuple of number or imgaug.augmentables.bbs.BoundingBox or imgaug.augmentables.bbs.BoundingBoxesOnImage
        Subarea to extract from the image. See :func:`imgaug.imgaug.quokka`.

    Returns
    -------
    imgaug.augmentables.kps.KeypointsOnImage
        Example keypoints on the quokka image.

    """
    # TODO get rid of this deferred import
    from imgaug.augmentables.kps import Keypoint, KeypointsOnImage

    left, top = 0, 0
    if extract is not None:
        bb_extract = _quokka_normalize_extract(extract)
        left = bb_extract.x1
        top = bb_extract.y1
    with open(QUOKKA_ANNOTATIONS_FP, "r") as f:
        json_dict = json.load(f)
    keypoints = []
    for kp_dict in json_dict["keypoints"]:
        keypoints.append(Keypoint(x=kp_dict["x"] - left, y=kp_dict["y"] - top))
    if extract is not None:
        shape = (bb_extract.height, bb_extract.width, 3)
    else:
        shape = (643, 960, 3)
    kpsoi = KeypointsOnImage(keypoints, shape=shape)
    if size is not None:
        shape_resized = _compute_resized_shape(shape, size)
        kpsoi = kpsoi.on(shape_resized)
    return kpsoi


</source>
<source file="systems/imgaug-0.3.0/imgaug/imgaug.py" startline="1054" endline="1104" pcid="256">
def quokka_polygons(size=None, extract=None):
    """
    Returns example polygons on the standard example quokke image.

    The result contains one polygon, covering the quokka's outline.

    Parameters
    ----------
    size : None or float or tuple of int or tuple of float, optional
        Size of the output image on which the polygons are placed. If ``None``,
        then the polygons are not projected to any new size (positions on the
        original image are used). ``float`` s lead to relative size changes,
        ``int`` s to absolute sizes in pixels.

    extract : None or 'square' or tuple of number or imgaug.augmentables.bbs.BoundingBox or imgaug.augmentables.bbs.BoundingBoxesOnImage
        Subarea to extract from the image. See :func:`imgaug.imgaug.quokka`.

    Returns
    -------
    imgaug.augmentables.polys.PolygonsOnImage
        Example polygons on the quokka image.

    """
    # TODO get rid of this deferred import
    from imgaug.augmentables.polys import Polygon, PolygonsOnImage

    left, top = 0, 0
    if extract is not None:
        bb_extract = _quokka_normalize_extract(extract)
        left = bb_extract.x1
        top = bb_extract.y1
    with open(QUOKKA_ANNOTATIONS_FP, "r") as f:
        json_dict = json.load(f)
    polygons = []
    for poly_json in json_dict["polygons"]:
        polygons.append(
            Polygon([(point["x"] - left, point["y"] - top)
                    for point in poly_json["keypoints"]])
        )
    if extract is not None:
        shape = (bb_extract.height, bb_extract.width, 3)
    else:
        shape = (643, 960, 3)
    psoi = PolygonsOnImage(polygons, shape=shape)
    if size is not None:
        shape_resized = _compute_resized_shape(shape, size)
        psoi = psoi.on(shape_resized)
    return psoi


# TODO change this to some atan2 stuff?
</source>
<source file="systems/imgaug-0.3.0/imgaug/imgaug.py" startline="1001" endline="1053" pcid="255">
def quokka_bounding_boxes(size=None, extract=None):
    """Return example bounding boxes on the standard example quokke image.

    Currently only a single bounding box is returned that covers the quokka.

    Parameters
    ----------
    size : None or float or tuple of int or tuple of float, optional
        Size of the output image on which the BBs are placed. If ``None``, then
        the BBs are not projected to any new size (positions on the original
        image are used). ``float`` s lead to relative size changes, ``int`` s
        to absolute sizes in pixels.

    extract : None or 'square' or tuple of number or imgaug.augmentables.bbs.BoundingBox or imgaug.augmentables.bbs.BoundingBoxesOnImage
        Subarea to extract from the image. See :func:`imgaug.imgaug.quokka`.

    Returns
    -------
    imgaug.augmentables.bbs.BoundingBoxesOnImage
        Example BBs on the quokka image.

    """
    # TODO get rid of this deferred import
    from imgaug.augmentables.bbs import BoundingBox, BoundingBoxesOnImage

    left, top = 0, 0
    if extract is not None:
        bb_extract = _quokka_normalize_extract(extract)
        left = bb_extract.x1
        top = bb_extract.y1
    with open(QUOKKA_ANNOTATIONS_FP, "r") as f:
        json_dict = json.load(f)
    bbs = []
    for bb_dict in json_dict["bounding_boxes"]:
        bbs.append(
            BoundingBox(
                x1=bb_dict["x1"] - left,
                y1=bb_dict["y1"] - top,
                x2=bb_dict["x2"] - left,
                y2=bb_dict["y2"] - top
            )
        )
    if extract is not None:
        shape = (bb_extract.height, bb_extract.width, 3)
    else:
        shape = (643, 960, 3)
    bbsoi = BoundingBoxesOnImage(bbs, shape=shape)
    if size is not None:
        shape_resized = _compute_resized_shape(shape, size)
        bbsoi = bbsoi.on(shape_resized)
    return bbsoi


</source>
</class>

<class classid="10" nclones="2" nlines="15" similarity="73">
<source file="systems/imgaug-0.3.0/imgaug/imgaug.py" startline="1841" endline="1906" pcid="266">

def pad_to_aspect_ratio(arr, aspect_ratio, mode="constant", cval=0,
                        return_pad_amounts=False):
    """Pad an image array on its sides so that it matches a target aspect ratio.

    See :func:`imgaug.imgaug.compute_paddings_for_aspect_ratio` for an
    explanation of how the required padding amounts are distributed per
    image axis.

    dtype support::

        See :func:`imgaug.imgaug.pad`.

    Parameters
    ----------
    arr : (H,W) ndarray or (H,W,C) ndarray
        Image-like array to pad.

    aspect_ratio : float
        Target aspect ratio, given as width/height. E.g. ``2.0`` denotes the
        image having twice as much width as height.

    mode : str, optional
        Padding mode to use. See :func:`imgaug.imgaug.pad` for details.

    cval : number, optional
        Value to use for padding if `mode` is ``constant``.
        See :func:`numpy.pad` for details.

    return_pad_amounts : bool, optional
        If ``False``, then only the padded image will be returned. If
        ``True``, a ``tuple`` with two entries will be returned, where the
        first entry is the padded image and the second entry are the amounts
        by which each image side was padded. These amounts are again a
        ``tuple`` of the form ``(top, right, bottom, left)``, with each value
        being an ``int``.

    Returns
    -------
    (H',W') ndarray or (H',W',C) ndarray
        Padded image as ``(H',W')`` or ``(H',W',C)`` ndarray, fulfilling the
        given `aspect_ratio`.

    tuple of int
        Amounts by which the image was padded on each side, given as a
        ``tuple`` ``(top, right, bottom, left)``.
        This ``tuple`` is only returned if `return_pad_amounts` was set to
        ``True``.

    """
    pad_top, pad_right, pad_bottom, pad_left = \
        compute_paddings_for_aspect_ratio(arr, aspect_ratio)
    arr_padded = pad(
        arr,
        top=pad_top,
        right=pad_right,
        bottom=pad_bottom,
        left=pad_left,
        mode=mode,
        cval=cval
    )

    if return_pad_amounts:
        return arr_padded, (pad_top, pad_right, pad_bottom, pad_left)
    return arr_padded

</source>
<source file="systems/imgaug-0.3.0/imgaug/imgaug.py" startline="1967" endline="2037" pcid="269">


def pad_to_multiples_of(arr, height_multiple, width_multiple, mode="constant",
                        cval=0, return_pad_amounts=False):
    """Pad an image array until its side lengths are multiples of given values.

    See :func:`imgaug.imgaug.compute_paddings_for_aspect_ratio` for an
    explanation of how the required padding amounts are distributed per
    image axis.

    dtype support::

        See :func:`imgaug.imgaug.pad`.

    Parameters
    ----------
    arr : (H,W) ndarray or (H,W,C) ndarray
        Image-like array to pad.

    height_multiple : None or int
        The desired multiple of the height. The computed padding amount will
        reflect a padding that increases the y axis size until it is a multiple
        of this value.

    width_multiple : None or int
        The desired multiple of the width. The computed padding amount will
        reflect a padding that increases the x axis size until it is a multiple
        of this value.

    mode : str, optional
        Padding mode to use. See :func:`imgaug.imgaug.pad` for details.

    cval : number, optional
        Value to use for padding if `mode` is ``constant``.
        See :func:`numpy.pad` for details.

    return_pad_amounts : bool, optional
        If ``False``, then only the padded image will be returned. If
        ``True``, a ``tuple`` with two entries will be returned, where the
        first entry is the padded image and the second entry are the amounts
        by which each image side was padded. These amounts are again a
        ``tuple`` of the form ``(top, right, bottom, left)``, with each value
        being an integer.

    Returns
    -------
    (H',W') ndarray or (H',W',C) ndarray
        Padded image as ``(H',W')`` or ``(H',W',C)`` ndarray.

    tuple of int
        Amounts by which the image was padded on each side, given as a
        ``tuple`` ``(top, right, bottom, left)``.
        This ``tuple`` is only returned if `return_pad_amounts` was set to
        ``True``.

    """
    pad_top, pad_right, pad_bottom, pad_left = \
        compute_paddings_to_reach_multiples_of(
            arr, height_multiple, width_multiple)
    arr_padded = pad(
        arr,
        top=pad_top,
        right=pad_right,
        bottom=pad_bottom,
        left=pad_left,
        mode=mode,
        cval=cval
    )

    if return_pad_amounts:
        return arr_padded, (pad_top, pad_right, pad_bottom, pad_left)
</source>
</class>

<class classid="11" nclones="2" nlines="30" similarity="93">
<source file="systems/imgaug-0.3.0/imgaug/external/poly_point_isect_py2py3.py" startline="875" endline="914" pcid="339">
    def succ_item(self, key, default=_sentinel):
        """Get successor (k,v) pair of key, raises KeyError if key is max key
        or key does not exist. optimized for pypy.
        """
        # removed graingets version, because it was little slower on CPython and much slower on pypy
        # this version runs about 4x faster with pypy than the Cython version
        # Note: Code sharing of succ_item() and ceiling_item() is possible, but has always a speed penalty.
        node = self._root
        succ_node = None
        while node is not None:
            cmp = self._cmp(self._cmp_data, key, node.key)
            if cmp == 0:
                break
            elif cmp < 0:
                if (succ_node is None) or self._cmp(self._cmp_data, node.key, succ_node.key) < 0:
                    succ_node = node
                node = node.left
            else:
                node = node.right

        if node is None:  # stay at dead end
            if default is _sentinel:
                raise KeyError(str(key))
            return default
        # found node of key
        if node.right is not None:
            # find smallest node of right subtree
            node = node.right
            while node.left is not None:
                node = node.left
            if succ_node is None:
                succ_node = node
            elif self._cmp(self._cmp_data, node.key, succ_node.key) < 0:
                succ_node = node
        elif succ_node is None:  # given key is biggest in tree
            if default is _sentinel:
                raise KeyError(str(key))
            return default
        return succ_node.key, succ_node.value

</source>
<source file="systems/imgaug-0.3.0/imgaug/external/poly_point_isect_py2py3.py" startline="915" endline="955" pcid="340">
    def prev_item(self, key, default=_sentinel):
        """Get predecessor (k,v) pair of key, raises KeyError if key is min key
        or key does not exist. optimized for pypy.
        """
        # removed graingets version, because it was little slower on CPython and much slower on pypy
        # this version runs about 4x faster with pypy than the Cython version
        # Note: Code sharing of prev_item() and floor_item() is possible, but has always a speed penalty.
        node = self._root
        prev_node = None

        while node is not None:
            cmp = self._cmp(self._cmp_data, key, node.key)
            if cmp == 0:
                break
            elif cmp < 0:
                node = node.left
            else:
                if (prev_node is None) or self._cmp(self._cmp_data, prev_node.key, node.key) < 0:
                    prev_node = node
                node = node.right

        if node is None:  # stay at dead end (None)
            if default is _sentinel:
                raise KeyError(str(key))
            return default
        # found node of key
        if node.left is not None:
            # find biggest node of left subtree
            node = node.left
            while node.right is not None:
                node = node.right
            if prev_node is None:
                prev_node = node
            elif self._cmp(self._cmp_data, prev_node.key, node.key) < 0:
                prev_node = node
        elif prev_node is None:  # given key is smallest in tree
            if default is _sentinel:
                raise KeyError(str(key))
            return default
        return prev_node.key, prev_node.value

</source>
</class>

<class classid="12" nclones="2" nlines="15" similarity="73">
<source file="systems/imgaug-0.3.0/imgaug/augmentables/normalization.py" startline="69" endline="93" pcid="373">
def _assert_many_arrays_ndim(arrs, ndim, shape_str, to_ntype):
    # For polygons, this can be a list of lists of arrays, hence we must
    # flatten the lists here.
    # itertools.chain.from_iterable() seems to flatten the arrays too, so it
    # cannot be used here.
    iterable_type_str = "iterable"
    if len(arrs) == 0:
        arrs_flat = []
    elif ia.is_np_array(arrs[0]):
        arrs_flat = arrs
    else:
        iterable_type_str = "iterable of iterable"
        arrs_flat = [arr for arrs_sublist in arrs for arr in arrs_sublist]

    if any([arr.ndim != ndim for arr in arrs_flat]):
        raise ValueError(
            "Tried to convert an %s of arrays to a list of "
            "%s. Expected each array to be of shape %s, "
            "i.e. to be %d-dimensional, but got dimensions %s "
            "instead (array shapes: %s)." % (
                iterable_type_str, to_ntype, shape_str, ndim,
                ", ".join([str(arr.ndim) for arr in arrs_flat]),
                ", ".join([str(arr.shape) for arr in arrs_flat])))


</source>
<source file="systems/imgaug-0.3.0/imgaug/augmentables/normalization.py" startline="103" endline="126" pcid="375">
def _assert_many_arrays_last_dim_exactly(arrs, size, to_ntype):
    # For polygons, this can be a list of lists of arrays, hence we must
    # flatten the lists here.
    # itertools.chain.from_iterable() seems to flatten the arrays too, so it
    # cannot be used here.
    iterable_type_str = "iterable"
    if len(arrs) == 0:
        arrs_flat = []
    elif ia.is_np_array(arrs[0]):
        arrs_flat = arrs
    else:
        iterable_type_str = "iterable of iterable"
        arrs_flat = [arr for arrs_sublist in arrs for arr in arrs_sublist]

    if any([arr.shape[-1] != size for arr in arrs_flat]):
        raise ValueError(
            "Tried to convert an %s of array to a list of %s. Expected the "
            "arrays' last dimensions to have size %d, but got %s instead "
            "(array shapes: %s)." % (
                 iterable_type_str, to_ntype, size,
                 ", ".join([str(arr.shape[-1]) for arr in arrs_flat]),
                 ", ".join([str(arr.shape) for arr in arrs_flat])))


</source>
</class>

<class classid="13" nclones="2" nlines="68" similarity="85">
<source file="systems/imgaug-0.3.0/imgaug/augmentables/normalization.py" startline="232" endline="304" pcid="379">
def normalize_keypoints(inputs, shapes=None):
    # TODO get rid of this deferred import
    from imgaug.augmentables.kps import Keypoint, KeypointsOnImage

    shapes = _preprocess_shapes(shapes)
    ntype = estimate_keypoints_norm_type(inputs)
    _assert_exactly_n_shapes_partial = functools.partial(
        _assert_exactly_n_shapes,
        from_ntype=ntype, to_ntype="List[KeypointsOnImage]",
        shapes=shapes)

    if ntype == "None":
        return inputs
    elif ntype in ["array[float]", "array[int]", "array[uint]"]:
        _assert_single_array_ndim(inputs, 3, "(N,K,2)", "KeypointsOnImage")
        _assert_single_array_last_dim_exactly(inputs, 2, "KeypointsOnImage")
        _assert_exactly_n_shapes_partial(n=len(inputs))
        return [
            KeypointsOnImage.from_xy_array(attr_i, shape=shape)
            for attr_i, shape
            in zip(inputs, shapes)
        ]
    elif ntype == "tuple[number,size=2]":
        _assert_exactly_n_shapes_partial(n=1)
        return [KeypointsOnImage([Keypoint(x=inputs[0], y=inputs[1])],
                                 shape=shapes[0])]
    elif ntype == "Keypoint":
        _assert_exactly_n_shapes_partial(n=1)
        return [KeypointsOnImage([inputs], shape=shapes[0])]
    elif ntype == "KeypointsOnImage":
        return [inputs]
    elif ntype == "iterable[empty]":
        return None
    elif ntype in ["iterable-array[float]",
                   "iterable-array[int]",
                   "iterable-array[uint]"]:
        _assert_many_arrays_ndim(inputs, 2, "(K,2)", "KeypointsOnImage")
        _assert_many_arrays_last_dim_exactly(inputs, 2, "KeypointsOnImage")
        _assert_exactly_n_shapes_partial(n=len(inputs))
        return [
            KeypointsOnImage.from_xy_array(attr_i, shape=shape)
            for attr_i, shape
            in zip(inputs, shapes)
        ]
    elif ntype == "iterable-tuple[number,size=2]":
        _assert_exactly_n_shapes_partial(n=1)
        return [KeypointsOnImage([Keypoint(x=x, y=y) for x, y in inputs],
                                 shape=shapes[0])]
    elif ntype == "iterable-Keypoint":
        _assert_exactly_n_shapes_partial(n=1)
        return [KeypointsOnImage(inputs, shape=shapes[0])]
    elif ntype == "iterable-KeypointsOnImage":
        return inputs
    elif ntype == "iterable-iterable[empty]":
        return None
    elif ntype == "iterable-iterable-tuple[number,size=2]":
        _assert_exactly_n_shapes_partial(n=len(inputs))
        return [
            KeypointsOnImage.from_xy_array(
                np.array(attr_i, dtype=np.float32),
                shape=shape)
            for attr_i, shape
            in zip(inputs, shapes)
        ]
    else:
        assert ntype == "iterable-iterable-Keypoint", (
            "Got unknown normalization type '%s'." % (ntype,))
        _assert_exactly_n_shapes_partial(n=len(inputs))
        return [KeypointsOnImage(attr_i, shape=shape)
                for attr_i, shape
                in zip(inputs, shapes)]


</source>
<source file="systems/imgaug-0.3.0/imgaug/augmentables/normalization.py" startline="305" endline="387" pcid="380">
def normalize_bounding_boxes(inputs, shapes=None):
    # TODO get rid of this deferred import
    from imgaug.augmentables.bbs import BoundingBox, BoundingBoxesOnImage

    shapes = _preprocess_shapes(shapes)
    ntype = estimate_bounding_boxes_norm_type(inputs)
    _assert_exactly_n_shapes_partial = functools.partial(
        _assert_exactly_n_shapes,
        from_ntype=ntype, to_ntype="List[BoundingBoxesOnImage]",
        shapes=shapes)

    if ntype == "None":
        return None
    elif ntype in ["array[float]", "array[int]", "array[uint]"]:
        _assert_single_array_ndim(inputs, 3, "(N,B,4)", "BoundingBoxesOnImage")
        _assert_single_array_last_dim_exactly(
            inputs, 4, "BoundingBoxesOnImage")
        _assert_exactly_n_shapes_partial(n=len(inputs))
        return [
            BoundingBoxesOnImage.from_xyxy_array(attr_i, shape=shape)
            for attr_i, shape
            in zip(inputs, shapes)
        ]
    elif ntype == "tuple[number,size=4]":
        _assert_exactly_n_shapes_partial(n=1)
        return [
            BoundingBoxesOnImage(
                [BoundingBox(
                    x1=inputs[0], y1=inputs[1],
                    x2=inputs[2], y2=inputs[3])],
                shape=shapes[0])
        ]
    elif ntype == "BoundingBox":
        _assert_exactly_n_shapes_partial(n=1)
        return [BoundingBoxesOnImage([inputs], shape=shapes[0])]
    elif ntype == "BoundingBoxesOnImage":
        return [inputs]
    elif ntype == "iterable[empty]":
        return None
    elif ntype in ["iterable-array[float]",
                   "iterable-array[int]",
                   "iterable-array[uint]"]:
        _assert_many_arrays_ndim(inputs, 2, "(B,4)", "BoundingBoxesOnImage")
        _assert_many_arrays_last_dim_exactly(inputs, 4, "BoundingBoxesOnImage")
        _assert_exactly_n_shapes_partial(n=len(inputs))
        return [
            BoundingBoxesOnImage.from_xyxy_array(attr_i, shape=shape)
            for attr_i, shape
            in zip(inputs, shapes)
        ]
    elif ntype == "iterable-tuple[number,size=4]":
        _assert_exactly_n_shapes_partial(n=1)
        return [
            BoundingBoxesOnImage(
                [BoundingBox(x1=x1, y1=y1, x2=x2, y2=y2)
                 for x1, y1, x2, y2 in inputs],
                shape=shapes[0])
        ]
    elif ntype == "iterable-BoundingBox":
        _assert_exactly_n_shapes_partial(n=1)
        return [BoundingBoxesOnImage(inputs, shape=shapes[0])]
    elif ntype == "iterable-BoundingBoxesOnImage":
        return inputs
    elif ntype == "iterable-iterable[empty]":
        return None
    elif ntype == "iterable-iterable-tuple[number,size=4]":
        _assert_exactly_n_shapes_partial(n=len(inputs))
        return [
            BoundingBoxesOnImage.from_xyxy_array(
                np.array(attr_i, dtype=np.float32),
                shape=shape)
            for attr_i, shape
            in zip(inputs, shapes)
        ]
    else:
        assert ntype == "iterable-iterable-BoundingBox", (
            "Got unknown normalization type '%s'." % (ntype,))
        _assert_exactly_n_shapes_partial(n=len(inputs))
        return [BoundingBoxesOnImage(attr_i, shape=shape)
                for attr_i, shape
                in zip(inputs, shapes)]


</source>
</class>

<class classid="14" nclones="2" nlines="33" similarity="73">
<source file="systems/imgaug-0.3.0/imgaug/augmentables/normalization.py" startline="575" endline="614" pcid="385">
def invert_normalize_heatmaps(heatmaps, heatmaps_old):
    ntype = estimate_heatmaps_norm_type(heatmaps_old)
    if ntype == "None":
        assert heatmaps is None, (
            "Expected (normalized) 'heatmaps' to be None due (unnormalized) "
            "'heatmaps_old' being None. Got type %s instead." % (
                type(heatmaps),))
        return heatmaps
    elif ntype == "array[float]":
        assert len(heatmaps) == heatmaps_old.shape[0], (
            "Expected as many heatmaps after normalization as before "
            "normalization. Got %d (after) and %d (before)." % (
                len(heatmaps), heatmaps_old.shape[0]))
        input_dtype = heatmaps_old.dtype
        return restore_dtype_and_merge(
            [hm_i.arr_0to1 for hm_i in heatmaps],
            input_dtype)
    elif ntype == "HeatmapsOnImage":
        assert len(heatmaps) == 1, (
            "Expected as many heatmaps after normalization as before "
            "normalization. Got %d (after) and %d (before)." % (
                len(heatmaps), 1))
        return heatmaps[0]
    elif ntype == "iterable[empty]":
        assert heatmaps is None, (
            "Expected heatmaps after normalization to be None, due to the "
            "heatmaps before normalization being an empty iterable. "
            "Got type %s instead." % (type(heatmaps),))
        return []
    elif ntype == "iterable-array[float]":
        nonempty, _, _ = find_first_nonempty(heatmaps_old)
        input_dtype = nonempty.dtype
        return [restore_dtype_and_merge(hm_i.arr_0to1, input_dtype)
                for hm_i in heatmaps]
    else:
        assert ntype == "iterable-HeatmapsOnImage", (
            "Got unknown normalization type '%s'." % (ntype,))
        return heatmaps


</source>
<source file="systems/imgaug-0.3.0/imgaug/augmentables/normalization.py" startline="615" endline="657" pcid="386">
def invert_normalize_segmentation_maps(segmentation_maps,
                                       segmentation_maps_old):
    ntype = estimate_segmaps_norm_type(segmentation_maps_old)
    if ntype == "None":
        assert segmentation_maps is None, (
            "Expected (normalized) 'segmentation_maps' to be None due "
            "(unnormalized) 'segmentation_maps_old' being None. Got type %s "
            "instead." % (type(segmentation_maps),))
        return segmentation_maps
    elif ntype in ["array[int]", "array[uint]", "array[bool]"]:
        assert len(segmentation_maps) == segmentation_maps_old.shape[0], (
            "Expected as many segmentation maps after normalization as before "
            "normalization. Got %d (after) and %d (before)." % (
                len(segmentation_maps), segmentation_maps_old.shape[0]))
        input_dtype = segmentation_maps_old.dtype
        return restore_dtype_and_merge(
            [segmap_i.get_arr() for segmap_i in segmentation_maps],
            input_dtype)
    elif ntype == "SegmentationMapsOnImage":
        assert len(segmentation_maps) == 1, (
            "Expected as many segmentation maps after normalization as before "
            "normalization. Got %d (after) and %d (before)." % (
                len(segmentation_maps), 1))
        return segmentation_maps[0]
    elif ntype == "iterable[empty]":
        assert segmentation_maps is None, (
            "Expected segmentation maps after normalization to be None, due "
            "to the segmentation maps before normalization being an empty "
            "iterable. Got type %s instead." % (type(segmentation_maps),))
        return []
    elif ntype in ["iterable-array[int]",
                   "iterable-array[uint]",
                   "iterable-array[bool]"]:
        nonempty, _, _ = find_first_nonempty(segmentation_maps_old)
        input_dtype = nonempty.dtype
        return [restore_dtype_and_merge(segmap_i.get_arr(), input_dtype)
                for segmap_i in segmentation_maps]
    else:
        assert ntype == "iterable-SegmentationMapsOnImage", (
            "Got unknown normalization type '%s'." % (ntype,))
        return segmentation_maps


</source>
</class>

<class classid="15" nclones="2" nlines="23" similarity="91">
<source file="systems/imgaug-0.3.0/imgaug/augmentables/normalization.py" startline="1081" endline="1105" pcid="395">
def estimate_keypoints_norm_type(keypoints):
    type_str = estimate_normalization_type(keypoints)
    valid_type_strs = [
        "None",
        "array[float]",
        "array[int]",
        "array[uint]",
        "tuple[number,size=2]",
        "Keypoint",
        "KeypointsOnImage",
        "iterable[empty]",
        "iterable-array[float]",
        "iterable-array[int]",
        "iterable-array[uint]",
        "iterable-tuple[number,size=2]",
        "iterable-Keypoint",
        "iterable-KeypointsOnImage",
        "iterable-iterable[empty]",
        "iterable-iterable-tuple[number,size=2]",
        "iterable-iterable-Keypoint"
    ]
    _assert_is_of_norm_type(type_str, valid_type_strs, "keypoints")
    return type_str


</source>
<source file="systems/imgaug-0.3.0/imgaug/augmentables/normalization.py" startline="1106" endline="1131" pcid="396">
def estimate_bounding_boxes_norm_type(bounding_boxes):
    type_str = estimate_normalization_type(bounding_boxes)
    valid_type_strs = [
        "None",
        "array[float]",
        "array[int]",
        "array[uint]",
        "tuple[number,size=4]",
        "BoundingBox",
        "BoundingBoxesOnImage",
        "iterable[empty]",
        "iterable-array[float]",
        "iterable-array[int]",
        "iterable-array[uint]",
        "iterable-tuple[number,size=4]",
        "iterable-BoundingBox",
        "iterable-BoundingBoxesOnImage",
        "iterable-iterable[empty]",
        "iterable-iterable-tuple[number,size=4]",
        "iterable-iterable-BoundingBox"
    ]
    _assert_is_of_norm_type(
        type_str, valid_type_strs, "bounding_boxes")
    return type_str


</source>
</class>

<class classid="16" nclones="2" nlines="18" similarity="100">
<source file="systems/imgaug-0.3.0/imgaug/augmentables/batches.py" startline="102" endline="120" pcid="517">
    def __init__(self, images=None, heatmaps=None, segmentation_maps=None,
                 keypoints=None, bounding_boxes=None, polygons=None,
                 line_strings=None, data=None):
        self.images_unaug = images
        self.images_aug = None
        self.heatmaps_unaug = heatmaps
        self.heatmaps_aug = None
        self.segmentation_maps_unaug = segmentation_maps
        self.segmentation_maps_aug = None
        self.keypoints_unaug = keypoints
        self.keypoints_aug = None
        self.bounding_boxes_unaug = bounding_boxes
        self.bounding_boxes_aug = None
        self.polygons_unaug = polygons
        self.polygons_aug = None
        self.line_strings_unaug = line_strings
        self.line_strings_aug = None
        self.data = data

</source>
<source file="systems/imgaug-0.3.0/imgaug/augmentables/batches.py" startline="259" endline="277" pcid="520">
    def __init__(self, images=None, heatmaps=None, segmentation_maps=None,
                 keypoints=None, bounding_boxes=None, polygons=None,
                 line_strings=None, data=None):
        self.images_unaug = images
        self.images_aug = None
        self.heatmaps_unaug = heatmaps
        self.heatmaps_aug = None
        self.segmentation_maps_unaug = segmentation_maps
        self.segmentation_maps_aug = None
        self.keypoints_unaug = keypoints
        self.keypoints_aug = None
        self.bounding_boxes_unaug = bounding_boxes
        self.bounding_boxes_aug = None
        self.polygons_unaug = polygons
        self.polygons_aug = None
        self.line_strings_unaug = line_strings
        self.line_strings_aug = None
        self.data = data

</source>
</class>

<class classid="17" nclones="2" nlines="12" similarity="76">
<source file="systems/imgaug-0.3.0/imgaug/augmentables/lines.py" startline="664" endline="708" pcid="550">
    def draw_lines_heatmap_array(self, image_shape, alpha=1.0,
                                 size=1, antialiased=True,
                                 raise_if_out_of_image=False):
        """Draw the line segments of this line string as a heatmap array.

        Parameters
        ----------
        image_shape : tuple of int
            The shape of the image onto which to draw the line mask.

        alpha : float, optional
            Opacity of the line string. Higher values denote a more visible
            line string.

        size : int, optional
            Thickness of the line segments.

        antialiased : bool, optional
            Whether to draw the line with anti-aliasing activated.

        raise_if_out_of_image : bool, optional
            Whether to raise an error if the line string is fully
            outside of the image. If set to ``False``, no error will be
            raised and only the parts inside the image will be drawn.

        Returns
        -------
        ndarray
            ``float32`` array of shape `image_shape` (no channel axis) with
            drawn line string. All values are in the interval ``[0.0, 1.0]``.

        """
        assert len(image_shape) == 2 or (
            len(image_shape) == 3 and image_shape[-1] == 1), (
            "Expected (H,W) or (H,W,1) as image_shape, got %s." % (
                image_shape,))

        arr = self.draw_lines_on_image(
            np.zeros(image_shape, dtype=np.uint8),
            color=255, alpha=alpha, size=size,
            antialiased=antialiased,
            raise_if_out_of_image=raise_if_out_of_image
        )
        return arr.astype(np.float32) / 255.0

</source>
<source file="systems/imgaug-0.3.0/imgaug/augmentables/lines.py" startline="709" endline="749" pcid="551">
    def draw_points_heatmap_array(self, image_shape, alpha=1.0,
                                  size=1, raise_if_out_of_image=False):
        """Draw the points of this line string as a heatmap array.

        Parameters
        ----------
        image_shape : tuple of int
            The shape of the image onto which to draw the point mask.

        alpha : float, optional
            Opacity of the line string points. Higher values denote a more
            visible points.

        size : int, optional
            Size of the points in pixels.

        raise_if_out_of_image : bool, optional
            Whether to raise an error if the line string is fully
            outside of the image. If set to ``False``, no error will be
            raised and only the parts inside the image will be drawn.

        Returns
        -------
        ndarray
            ``float32`` array of shape `image_shape` (no channel axis) with
            drawn line string points. All values are in the
            interval ``[0.0, 1.0]``.

        """
        assert len(image_shape) == 2 or (
            len(image_shape) == 3 and image_shape[-1] == 1), (
            "Expected (H,W) or (H,W,1) as image_shape, got %s." % (
                image_shape,))

        arr = self.draw_points_on_image(
            np.zeros(image_shape, dtype=np.uint8),
            color=255, alpha=alpha, size=size,
            raise_if_out_of_image=raise_if_out_of_image
        )
        return arr.astype(np.float32) / 255.0

</source>
</class>

<class classid="18" nclones="3" nlines="11" similarity="72">
<source file="systems/imgaug-0.3.0/imgaug/random.py" startline="606" endline="627" pcid="637">
    def standard_exponential(self, size=None, dtype="float32", method="zig",
                             out=None):
        """Call :func:`numpy.random.Generator.standard_exponential`.

        .. note ::

            Changed `dtype` argument default value from numpy's ``d`` to
            ``float32``.

        """
        if self._is_new_rng_style:
            return self.generator.standard_exponential(
                size=size, dtype=dtype, method=method, out=out)
        result = self.generator.standard_exponential(size=size).astype(dtype)
        if out is not None:
            assert out.dtype.name == result.dtype.name, (
                "Expected out array to have the same dtype as "
                "standard_exponential()'s result array. Got %s (out) and "
                "%s (result) instead." % (out.dtype.name, result.dtype.name))
            out[...] = result
        return result

</source>
<source file="systems/imgaug-0.3.0/imgaug/random.py" startline="628" endline="649" pcid="638">
    def standard_gamma(self, shape, size=None, dtype="float32", out=None):
        """Call :func:`numpy.random.Generator.standard_gamma`.

        .. note ::

            Changed `dtype` argument default value from numpy's ``d`` to
            ``float32``.

        """
        if self._is_new_rng_style:
            return self.generator.standard_gamma(
                shape=shape, size=size, dtype=dtype, out=out)
        result = self.generator.standard_gamma(
            shape=shape, size=size).astype(dtype)
        if out is not None:
            assert out.dtype.name == result.dtype.name, (
                "Expected out array to have the same dtype as "
                "standard_gamma()'s result array. Got %s (out) and "
                "%s (result) instead." % (out.dtype.name, result.dtype.name))
            out[...] = result
        return result

</source>
<source file="systems/imgaug-0.3.0/imgaug/random.py" startline="650" endline="670" pcid="639">
    def standard_normal(self, size=None, dtype="float32", out=None):
        """Call :func:`numpy.random.Generator.standard_normal`.

        .. note ::

            Changed `dtype` argument default value from numpy's ``d`` to
            ``float32``.

        """
        if self._is_new_rng_style:
            return self.generator.standard_normal(
                size=size, dtype=dtype, out=out)
        result = self.generator.standard_normal(size=size).astype(dtype)
        if out is not None:
            assert out.dtype.name == result.dtype.name, (
                "Expected out array to have the same dtype as "
                "standard_normal()'s result array. Got %s (out) and "
                "%s (result) instead." % (out.dtype.name, result.dtype.name))
            out[...] = result
        return result

</source>
</class>

<class classid="19" nclones="3" nlines="13" similarity="71">
<source file="systems/imgaug-0.3.0/imgaug/parameters.py" startline="1722" endline="1739" pcid="782">
    def _draw_samples(self, size, random_state):
        rngs = random_state.duplicate(2)
        samples = self.other_param.draw_samples(size, random_state=rngs[0])

        elementwise = (
            self.elementwise
            and not isinstance(self.val, Deterministic))

        if elementwise:
            val_samples = self.val.draw_samples(size, random_state=rngs[1])
        else:
            val_samples = self.val.draw_sample(random_state=rngs[1])

        if elementwise:
            return np.multiply(samples, val_samples)
        else:
            return samples * val_samples

</source>
<source file="systems/imgaug-0.3.0/imgaug/parameters.py" startline="1970" endline="1985" pcid="794">
    def _draw_samples(self, size, random_state):
        rngs = random_state.duplicate(2)
        samples = self.other_param.draw_samples(size, random_state=rngs[0])

        elementwise = self.elementwise and not isinstance(self.val, Deterministic)

        if elementwise:
            val_samples = self.val.draw_samples(size, random_state=rngs[1])
        else:
            val_samples = self.val.draw_sample(random_state=rngs[1])

        if elementwise:
            return np.subtract(samples, val_samples)
        else:
            return samples - val_samples

</source>
<source file="systems/imgaug-0.3.0/imgaug/parameters.py" startline="1894" endline="1910" pcid="790">
    def _draw_samples(self, size, random_state):
        rngs = random_state.duplicate(2)
        samples = self.other_param.draw_samples(size, random_state=rngs[0])

        elementwise = (
            self.elementwise and not isinstance(self.val, Deterministic))

        if elementwise:
            val_samples = self.val.draw_samples(size, random_state=rngs[1])
        else:
            val_samples = self.val.draw_sample(random_state=rngs[1])

        if elementwise:
            return np.add(samples, val_samples)
        else:
            return samples + val_samples

</source>
</class>

<class classid="20" nclones="2" nlines="23" similarity="91">
<source file="systems/imgaug-0.3.0/imgaug/parameters.py" startline="2736" endline="2762" pcid="825">
    def __init__(self, size_px_max=(2, 16),
                 upscale_method=["linear", "nearest"]):
        # pylint: disable=dangerous-default-value
        super(SimplexNoise, self).__init__()
        self.size_px_max = handle_discrete_param(
            size_px_max, "size_px_max", value_range=(1, 10000))

        if upscale_method == ia.ALL:
            self.upscale_method = Choice(["nearest", "linear", "area",
                                          "cubic"])
        elif ia.is_string(upscale_method):
            self.upscale_method = Deterministic(upscale_method)
        elif isinstance(upscale_method, list):
            assert len(upscale_method) >= 1, (
                "Expected at least one upscale method, "
                "got %d." % (len(upscale_method),))
            assert all([ia.is_string(val) for val in upscale_method]), (
                "Expected all upscale methods to be strings, got types %s." % (
                    ", ".join([str(type(v)) for v in upscale_method])))
            self.upscale_method = Choice(upscale_method)
        elif isinstance(upscale_method, StochasticParameter):
            self.upscale_method = upscale_method
        else:
            raise Exception(
                "Expected upscale_method to be string or list of strings or "
                "StochasticParameter, got %s." % (type(upscale_method),))

</source>
<source file="systems/imgaug-0.3.0/imgaug/parameters.py" startline="2928" endline="2955" pcid="830">
    def __init__(self, exponent=(-4, 4), size_px_max=(4, 32),
                 upscale_method=["linear", "nearest"]):
        # pylint: disable=dangerous-default-value
        super(FrequencyNoise, self).__init__()
        self.exponent = handle_continuous_param(exponent, "exponent")
        self.size_px_max = handle_discrete_param(
            size_px_max, "size_px_max", value_range=(1, 10000))

        if upscale_method == ia.ALL:
            self.upscale_method = Choice(["nearest", "linear", "area",
                                          "cubic"])
        elif ia.is_string(upscale_method):
            self.upscale_method = Deterministic(upscale_method)
        elif isinstance(upscale_method, list):
            assert len(upscale_method) >= 1, (
                "Expected at least one upscale method, "
                "got %d." % (len(upscale_method),))
            assert all([ia.is_string(val) for val in upscale_method]), (
                "Expected all upscale methods to be strings, got types %s." % (
                    ", ".join([str(type(v)) for v in upscale_method])))
            self.upscale_method = Choice(upscale_method)
        elif isinstance(upscale_method, StochasticParameter):
            self.upscale_method = upscale_method
        else:
            raise Exception(
                "Expected upscale_method to be string or list of strings or "
                "StochasticParameter, got %s." % (type(upscale_method),))

</source>
</class>

<class classid="21" nclones="2" nlines="14" similarity="85">
<source file="systems/imgaug-0.3.0/imgaug/multicore.py" startline="220" endline="273" pcid="845">
    def imap_batches(self, batches, chunksize=1, output_buffer_size=None):
        """
        Augment batches from a generator.

        Pattern for output buffer constraint is from
        https://stackoverflow.com/a/47058399.

        Parameters
        ----------
        batches : generator of imgaug.augmentables.batches.Batch
            The batches to augment, provided as a generator. Each call to the
            generator should yield exactly one batch.

        chunksize : None or int, optional
            Rough indicator of how many tasks should be sent to each worker.
            Increasing this number can improve performance.

        output_buffer_size : None or int, optional
            Max number of batches to handle *at the same time* in the *whole*
            pipeline (including already augmented batches that are waiting to
            be requested). If the buffer size is reached, no new batches will
            be loaded from `batches` until a produced (i.e. augmented) batch is
            consumed (i.e. requested from this method).
            The buffer is unlimited if this is set to ``None``. For large
            datasets, this should be set to an integer value to avoid filling
            the whole RAM if loading+augmentation happens faster than training.

            *New in version 0.3.0.*

        Yields
        ------
        imgaug.augmentables.batches.Batch
            Augmented batch.

        """
        self._assert_batches_is_generator(batches)

        # buffer is either None or a Semaphore
        output_buffer_left = _create_output_buffer_left(output_buffer_size)

        # TODO change this to 'yield from' once switched to 3.3+
        gen = self.pool.imap(
            _Pool_starworker,
            self._ibuffer_batch_loading(
                self._handle_batch_ids_gen(batches),
                output_buffer_left
            ),
            chunksize=chunksize)

        for batch in gen:
            yield batch
            if output_buffer_left is not None:
                output_buffer_left.release()

</source>
<source file="systems/imgaug-0.3.0/imgaug/multicore.py" startline="274" endline="327" pcid="846">
    def imap_batches_unordered(self, batches, chunksize=1,
                               output_buffer_size=None):
        """Augment batches from a generator (without preservation of order).

        Pattern for output buffer constraint is from
        https://stackoverflow.com/a/47058399.

        Parameters
        ----------
        batches : generator of imgaug.augmentables.batches.Batch
            The batches to augment, provided as a generator. Each call to the
            generator should yield exactly one batch.

        chunksize : None or int, optional
            Rough indicator of how many tasks should be sent to each worker.
            Increasing this number can improve performance.

        output_buffer_size : None or int, optional
            Max number of batches to handle *at the same time* in the *whole*
            pipeline (including already augmented batches that are waiting to
            be requested). If the buffer size is reached, no new batches will
            be loaded from `batches` until a produced (i.e. augmented) batch is
            consumed (i.e. requested from this method).
            The buffer is unlimited if this is set to ``None``. For large
            datasets, this should be set to an integer value to avoid filling
            the whole RAM if loading+augmentation happens faster than training.

            *New in version 0.3.0.*

        Yields
        ------
        imgaug.augmentables.batches.Batch
            Augmented batch.

        """
        self._assert_batches_is_generator(batches)

        # buffer is either None or a Semaphore
        output_buffer_left = _create_output_buffer_left(output_buffer_size)

        gen = self.pool.imap_unordered(
            _Pool_starworker,
            self._ibuffer_batch_loading(
                self._handle_batch_ids_gen(batches),
                output_buffer_left
            ),
            chunksize=chunksize
        )

        for batch in gen:
            yield batch
            if output_buffer_left is not None:
                output_buffer_left.release()

</source>
</class>

<class classid="22" nclones="3" nlines="12" similarity="100">
<source file="systems/imgaug-0.3.0/checks/check_clouds.py" startline="9" endline="24" pcid="880">
def main():
    for size in [0.1, 0.2, 1.0]:
        image = imageio.imread("https://upload.wikimedia.org/wikipedia/commons/8/89/Kukle%2CCzech_Republic..jpg",
                               format="jpg")
        image = ia.imresize_single_image(image, size, "cubic")
        print(image.shape)
        augs = [
            ("iaa.Clouds()", iaa.Clouds())
        ]

        for descr, aug in augs:
            print(descr)
            images_aug = aug.augment_images([image] * 64)
            ia.imshow(ia.draw_grid(images_aug))


</source>
<source file="systems/imgaug-0.3.0/checks/check_fog.py" startline="9" endline="24" pcid="908">
def main():
    for size in [0.1, 0.2, 1.0]:
        image = imageio.imread("https://upload.wikimedia.org/wikipedia/commons/8/89/Kukle%2CCzech_Republic..jpg",
                               format="jpg")
        image = ia.imresize_single_image(image, size, "cubic")
        print(image.shape)
        augs = [
            ("iaa.Fog()", iaa.Fog())
        ]

        for descr, aug in augs:
            print(descr)
            images_aug = aug.augment_images([image] * 64)
            ia.imshow(ia.draw_grid(images_aug))


</source>
<source file="systems/imgaug-0.3.0/checks/check_snowflakes.py" startline="9" endline="24" pcid="886">
def main():
    for size in [0.1, 0.2, 1.0]:
        image = imageio.imread("https://upload.wikimedia.org/wikipedia/commons/8/89/Kukle%2CCzech_Republic..jpg",
                               format="jpg")
        image = ia.imresize_single_image(image, size, "cubic")
        print(image.shape)
        augs = [
            ("iaa.Snowflakes()", iaa.Snowflakes())
        ]

        for descr, aug in augs:
            print(descr)
            images_aug = aug.augment_images([image] * 64)
            ia.imshow(ia.draw_grid(images_aug))


</source>
</class>

<class classid="23" nclones="2" nlines="76" similarity="100">
<source file="systems/imgaug-0.3.0/checks/check_elastic_transformation.py" startline="127" endline="219" pcid="884">
    def map_coordinates(cls, image, dx, dy, order=1, cval=0, mode="constant"):
        # small debug message to be sure that the right function is executed
        print("map_coordinates() with scipy")

        if order == 0 and image.dtype.name in ["uint64", "int64"]:
            raise Exception(("dtypes uint64 and int64 are only supported in ElasticTransformation for order=0, "
                             + "got order=%d with dtype=%s.") % (order, image.dtype.name))

        input_dtype = image.dtype
        if image.dtype.name == "bool":
            image = image.astype(np.float32)
        elif order == 1 and image.dtype.name in ["int8", "int16", "int32"]:
            image = image.astype(np.float64)
        elif order >= 2 and image.dtype.name == "int8":
            image = image.astype(np.int16)
        elif order >= 2 and image.dtype.name == "int32":
            image = image.astype(np.float64)

        shrt_max = 32767
        backend = "cv2"
        if order == 0:
            bad_dtype_cv2 = (image.dtype.name in ["uint32", "uint64", "int64", "float128", "bool"])
        elif order == 1:
            bad_dtype_cv2 = (image.dtype.name in ["uint32", "uint64", "int8", "int16", "int32", "int64", "float128",
                                                  "bool"])
        else:
            bad_dtype_cv2 = (image.dtype.name in ["uint32", "uint64", "int8", "int32", "int64", "float128", "bool"])

        bad_dx_shape_cv2 = (dx.shape[0] >= shrt_max or dx.shape[1] >= shrt_max)
        bad_dy_shape_cv2 = (dy.shape[0] >= shrt_max or dy.shape[1] >= shrt_max)
        if bad_dtype_cv2 or bad_dx_shape_cv2 or bad_dy_shape_cv2:
            backend = "scipy"

        ia.do_assert(image.ndim == 3)
        result = np.copy(image)
        height, width = image.shape[0:2]
        # True was added here, only difference to usual code
        if True or backend == "scipy":
            h, w = image.shape[0:2]
            y, x = np.meshgrid(np.arange(h).astype(np.float32), np.arange(w).astype(np.float32), indexing='ij')
            x_shifted = x + (-1) * dx
            y_shifted = y + (-1) * dy

            for c in sm.xrange(image.shape[2]):
                remapped_flat = ndimage.interpolation.map_coordinates(
                    image[..., c],
                    (y_shifted.flatten(), x_shifted.flatten()),
                    order=order,
                    cval=cval,
                    mode=mode
                )
                remapped = remapped_flat.reshape((height, width))
                result[..., c] = remapped
        else:
            h, w, nb_channels = image.shape

            y, x = np.meshgrid(np.arange(h).astype(np.float32), np.arange(w).astype(np.float32), indexing='ij')
            x_shifted = x + (-1) * dx
            y_shifted = y + (-1) * dy

            if image.dtype.kind == "f":
                cval = float(cval)
            else:
                cval = int(cval)
            border_mode = cls._MAPPING_MODE_SCIPY_CV2[mode]
            interpolation = cls._MAPPING_ORDER_SCIPY_CV2[order]

            is_nearest_neighbour = (interpolation == cv2.INTER_NEAREST)
            map1, map2 = cv2.convertMaps(x_shifted, y_shifted, cv2.CV_16SC2, nninterpolation=is_nearest_neighbour)
            # remap only supports up to 4 channels
            if nb_channels <= 4:
                result = cv2.remap(image, map1, map2, interpolation=interpolation, borderMode=border_mode, borderValue=cval)
                if image.ndim == 3 and result.ndim == 2:
                    result = result[..., np.newaxis]
            else:
                current_chan_idx = 0
                result = []
                while current_chan_idx < nb_channels:
                    channels = image[..., current_chan_idx:current_chan_idx+4]
                    result_c =  cv2.remap(channels, map1, map2, interpolation=interpolation, borderMode=border_mode,
                                          borderValue=cval)
                    if result_c.ndim == 2:
                        result_c = result_c[..., np.newaxis]
                    result.append(result_c)
                    current_chan_idx += 4
                result = np.concatenate(result, axis=2)

        if result.dtype.name != input_dtype.name:
            result = meta.restore_dtypes_(result, input_dtype)

        return result


</source>
<source file="systems/imgaug-0.3.0/checks/check_elastic_transformation.py" startline="222" endline="314" pcid="885">
    def map_coordinates(cls, image, dx, dy, order=1, cval=0, mode="constant"):
        # small debug message to be sure that the right function is executed
        print("map_coordinates() with cv2")

        if order == 0 and image.dtype.name in ["uint64", "int64"]:
            raise Exception(("dtypes uint64 and int64 are only supported in ElasticTransformation for order=0, "
                             + "got order=%d with dtype=%s.") % (order, image.dtype.name))

        input_dtype = image.dtype
        if image.dtype.name == "bool":
            image = image.astype(np.float32)
        elif order == 1 and image.dtype.name in ["int8", "int16", "int32"]:
            image = image.astype(np.float64)
        elif order >= 2 and image.dtype.name == "int8":
            image = image.astype(np.int16)
        elif order >= 2 and image.dtype.name == "int32":
            image = image.astype(np.float64)

        shrt_max = 32767
        backend = "cv2"
        if order == 0:
            bad_dtype_cv2 = (image.dtype.name in ["uint32", "uint64", "int64", "float128", "bool"])
        elif order == 1:
            bad_dtype_cv2 = (image.dtype.name in ["uint32", "uint64", "int8", "int16", "int32", "int64", "float128",
                                                  "bool"])
        else:
            bad_dtype_cv2 = (image.dtype.name in ["uint32", "uint64", "int8", "int32", "int64", "float128", "bool"])

        bad_dx_shape_cv2 = (dx.shape[0] >= shrt_max or dx.shape[1] >= shrt_max)
        bad_dy_shape_cv2 = (dy.shape[0] >= shrt_max or dy.shape[1] >= shrt_max)
        if bad_dtype_cv2 or bad_dx_shape_cv2 or bad_dy_shape_cv2:
            backend = "scipy"

        ia.do_assert(image.ndim == 3)
        result = np.copy(image)
        height, width = image.shape[0:2]
        # False was added here, only difference to usual code
        if False or backend == "scipy":
            h, w = image.shape[0:2]
            y, x = np.meshgrid(np.arange(h).astype(np.float32), np.arange(w).astype(np.float32), indexing='ij')
            x_shifted = x + (-1) * dx
            y_shifted = y + (-1) * dy

            for c in sm.xrange(image.shape[2]):
                remapped_flat = ndimage.interpolation.map_coordinates(
                    image[..., c],
                    (x_shifted.flatten(), y_shifted.flatten()),
                    order=order,
                    cval=cval,
                    mode=mode
                )
                remapped = remapped_flat.reshape((height, width))
                result[..., c] = remapped
        else:
            h, w, nb_channels = image.shape

            y, x = np.meshgrid(np.arange(h).astype(np.float32), np.arange(w).astype(np.float32), indexing='ij')
            x_shifted = x + (-1) * dx
            y_shifted = y + (-1) * dy

            if image.dtype.kind == "f":
                cval = float(cval)
            else:
                cval = int(cval)
            border_mode = cls._MAPPING_MODE_SCIPY_CV2[mode]
            interpolation = cls._MAPPING_ORDER_SCIPY_CV2[order]

            is_nearest_neighbour = (interpolation == cv2.INTER_NEAREST)
            map1, map2 = cv2.convertMaps(x_shifted, y_shifted, cv2.CV_16SC2, nninterpolation=is_nearest_neighbour)
            # remap only supports up to 4 channels
            if nb_channels <= 4:
                result = cv2.remap(image, map1, map2, interpolation=interpolation, borderMode=border_mode, borderValue=cval)
                if image.ndim == 3 and result.ndim == 2:
                    result = result[..., np.newaxis]
            else:
                current_chan_idx = 0
                result = []
                while current_chan_idx < nb_channels:
                    channels = image[..., current_chan_idx:current_chan_idx+4]
                    result_c =  cv2.remap(channels, map1, map2, interpolation=interpolation, borderMode=border_mode,
                                          borderValue=cval)
                    if result_c.ndim == 2:
                        result_c = result_c[..., np.newaxis]
                    result.append(result_c)
                    current_chan_idx += 4
                result = np.concatenate(result, axis=2)

        if result.dtype.name != input_dtype.name:
            result = meta.restore_dtypes_(result, input_dtype)

        return result


</source>
</class>

<class classid="24" nclones="2" nlines="25" similarity="81">
<source file="systems/imgaug-0.3.0/checks/check_median_blur.py" startline="14" endline="44" pcid="896">
def main():
    image = data.astronaut()
    image = ia.imresize_single_image(image, (64, 64))
    print("image shape:", image.shape)
    print("Press any key or wait %d ms to proceed to the next image." % (TIME_PER_STEP,))

    k = [
        1,
        3,
        5,
        7,
        (3, 3),
        (1, 11)
    ]

    cv2.namedWindow("aug", cv2.WINDOW_NORMAL)
    cv2.resizeWindow("aug", 64*NB_AUGS_PER_IMAGE, 64)

    for ki in k:
        aug = iaa.MedianBlur(k=ki)
        img_aug = [aug.augment_image(image) for _ in range(NB_AUGS_PER_IMAGE)]
        img_aug = np.hstack(img_aug)
        print("dtype", img_aug.dtype, "averages", np.average(img_aug, axis=tuple(range(0, img_aug.ndim-1))))

        title = "k=%s" % (str(ki),)
        img_aug = ia.draw_text(img_aug, x=5, y=5, text=title)

        cv2.imshow("aug", img_aug[..., ::-1]) # here with rgb2bgr
        cv2.waitKey(TIME_PER_STEP)


</source>
<source file="systems/imgaug-0.3.0/checks/check_average_blur.py" startline="14" endline="48" pcid="945">
def main():
    image = data.astronaut()
    image = ia.imresize_single_image(image, (64, 64))
    print("image shape:", image.shape)
    print("Press any key or wait %d ms to proceed to the next image." % (TIME_PER_STEP,))

    k = [
        1,
        2,
        4,
        8,
        16,
        (8, 8),
        (1, 8),
        ((1, 1), (8, 8)),
        ((1, 16), (1, 16)),
        ((1, 16), 1)
    ]

    cv2.namedWindow("aug", cv2.WINDOW_NORMAL)
    cv2.resizeWindow("aug", 64*NB_AUGS_PER_IMAGE, 64)

    for ki in k:
        aug = iaa.AverageBlur(k=ki)
        img_aug = [aug.augment_image(image) for _ in range(NB_AUGS_PER_IMAGE)]
        img_aug = np.hstack(img_aug)
        print("dtype", img_aug.dtype, "averages", np.average(img_aug, axis=tuple(range(0, img_aug.ndim-1))))

        title = "k=%s" % (str(ki),)
        img_aug = ia.draw_text(img_aug, x=5, y=5, text=title)

        cv2.imshow("aug", img_aug[..., ::-1])  # here with rgb2bgr
        cv2.waitKey(TIME_PER_STEP)


</source>
</class>

<class classid="25" nclones="2" nlines="24" similarity="70">
<source file="systems/imgaug-0.3.0/checks/check_multicore_pool.py" startline="321" endline="353" pcid="929">
def load_images(n_batches=10, sleep=0.0, draw_text=True):
    batch_size = 4
    astronaut = data.astronaut()
    astronaut = ia.imresize_single_image(astronaut, (64, 64))
    kps = ia.KeypointsOnImage([ia.Keypoint(x=15, y=25)], shape=astronaut.shape)

    counter = 0
    for i in range(n_batches):
        if draw_text:
            batch_images = []
            batch_kps = []
            for b in range(batch_size):
                astronaut_text = ia.draw_text(astronaut, x=0, y=0, text="%d" % (counter,), color=[0, 255, 0], size=16)
                batch_images.append(astronaut_text)
                batch_kps.append(kps)
                counter += 1
            batch = ia.Batch(
                images=np.array(batch_images, dtype=np.uint8),
                keypoints=batch_kps
            )
        else:
            if i == 0:
                batch_images = np.array([np.copy(astronaut) for _ in range(batch_size)], dtype=np.uint8)

            batch = ia.Batch(
                images=np.copy(batch_images),
                keypoints=[kps.deepcopy() for _ in range(batch_size)]
            )
        yield batch
        if sleep > 0:
            time.sleep(sleep)


</source>
<source file="systems/imgaug-0.3.0/checks/check_background_augmentation.py" startline="261" endline="283" pcid="955">
def load_images(n_batches=10, sleep=0.0):
    batch_size = 4
    astronaut = data.astronaut()
    astronaut = ia.imresize_single_image(astronaut, (64, 64))
    kps = ia.KeypointsOnImage([ia.Keypoint(x=15, y=25)], shape=astronaut.shape)
    counter = 0
    for i in range(n_batches):
        batch_images = []
        batch_kps = []
        for b in range(batch_size):
            astronaut_text = ia.draw_text(astronaut, x=0, y=0, text="%d" % (counter,), color=[0, 255, 0], size=16)
            batch_images.append(astronaut_text)
            batch_kps.append(kps)
            counter += 1
        batch = ia.Batch(
            images=np.array(batch_images, dtype=np.uint8),
            keypoints=batch_kps
        )
        yield batch
        if sleep > 0:
            time.sleep(sleep)


</source>
</class>

<class classid="26" nclones="2" nlines="17" similarity="100">
<source file="systems/imgaug-0.3.0/checks/check_multicore_pool.py" startline="354" endline="374" pcid="930">
def draw_grid(images_aug, keypoints_aug):
    if keypoints_aug is None:
        keypoints_aug = []
        for bidx in range(len(images_aug)):
            keypoints_aug.append([None for image in images_aug[bidx]])

    images_kps_batches = []
    for bidx in range(len(images_aug)):
        images_kps_batch = []
        for image, kps in zip(images_aug[bidx], keypoints_aug[bidx]):
            if kps is None:
                image_kps = image
            else:
                image_kps = kps.draw_on_image(image, size=5, color=[255, 0, 0])
            images_kps_batch.append(image_kps)
        images_kps_batches.extend(images_kps_batch)

    grid = ia.draw_grid(images_kps_batches, cols=len(images_aug[0]))
    return grid


</source>
<source file="systems/imgaug-0.3.0/checks/check_background_augmentation.py" startline="284" endline="304" pcid="956">
def draw_grid(images_aug, keypoints_aug):
    if keypoints_aug is None:
        keypoints_aug = []
        for bidx in range(len(images_aug)):
            keypoints_aug.append([None for image in images_aug[bidx]])

    images_kps_batches = []
    for bidx in range(len(images_aug)):
        images_kps_batch = []
        for image, kps in zip(images_aug[bidx], keypoints_aug[bidx]):
            if kps is None:
                image_kps = image
            else:
                image_kps = kps.draw_on_image(image, size=5, color=[255, 0, 0])
            images_kps_batch.append(image_kps)
        images_kps_batches.extend(images_kps_batch)

    grid = ia.draw_grid(images_kps_batches, cols=len(images_aug[0]))
    return grid


</source>
</class>

<class classid="27" nclones="2" nlines="10" similarity="100">
<source file="systems/imgaug-0.3.0/test/test_imgaug.py" startline="105" endline="116" pcid="960">
def test_is_single_integer():
    assert ia.is_single_integer("A") is False
    assert ia.is_single_integer(None) is False
    assert ia.is_single_integer(1.2) is False
    assert ia.is_single_integer(1.0) is False
    assert ia.is_single_integer(np.ones((1,), dtype=np.float32)[0]) is False
    assert ia.is_single_integer(1) is True
    assert ia.is_single_integer(1234) is True
    assert ia.is_single_integer(np.ones((1,), dtype=np.uint8)[0]) is True
    assert ia.is_single_integer(np.ones((1,), dtype=np.int32)[0]) is True


</source>
<source file="systems/imgaug-0.3.0/test/test_imgaug.py" startline="117" endline="128" pcid="961">
def test_is_single_float():
    assert ia.is_single_float("A") is False
    assert ia.is_single_float(None) is False
    assert ia.is_single_float(1.2) is True
    assert ia.is_single_float(1.0) is True
    assert ia.is_single_float(np.ones((1,), dtype=np.float32)[0]) is True
    assert ia.is_single_float(1) is False
    assert ia.is_single_float(1234) is False
    assert ia.is_single_float(np.ones((1,), dtype=np.uint8)[0]) is False
    assert ia.is_single_float(np.ones((1,), dtype=np.int32)[0]) is False


</source>
</class>

<class classid="28" nclones="2" nlines="10" similarity="70">
<source file="systems/imgaug-0.3.0/test/test_imgaug.py" startline="167" endline="178" pcid="965">
def test_is_string():
    class _Dummy(object):
        pass
    values_true = ["A", "BC", "1", ""]
    values_false = [-100, 1, 0, 1, 100, -1.2, -0.001, 0.0, 0.001, 1.2, 1e-4, True, False, (1.0, 2.0), [1.0, 2.0],
                    _Dummy(), np.zeros((1, 2), dtype=np.uint8)]
    for value in values_true:
        assert ia.is_string(value) is True
    for value in values_false:
        assert ia.is_string(value) is False


</source>
<source file="systems/imgaug-0.3.0/test/test_imgaug.py" startline="179" endline="190" pcid="966">
def test_is_single_bool():
    class _Dummy(object):
        pass
    values_true = [False, True]
    values_false = [-100, 1, 0, 1, 100, -1.2, -0.001, 0.0, 0.001, 1.2, 1e-4, (1.0, 2.0), [1.0, 2.0], _Dummy(),
                    np.zeros((1, 2), dtype=np.uint8), np.zeros((1,), dtype=bool)]
    for value in values_true:
        assert ia.is_single_bool(value) is True
    for value in values_false:
        assert ia.is_single_bool(value) is False


</source>
</class>

<class classid="29" nclones="2" nlines="20" similarity="90">
<source file="systems/imgaug-0.3.0/test/test_imgaug.py" startline="191" endline="214" pcid="967">
def test_is_integer_array():
    class _Dummy(object):
        pass
    values_true = [
        np.zeros((1, 2), dtype=np.uint8),
        np.zeros((100,), dtype=np.uint8),
        np.zeros((1, 2), dtype=np.uint16),
        np.zeros((1, 2), dtype=np.int32),
        np.zeros((1, 2), dtype=np.int64)
    ]
    values_false = [
        "A", "BC", "1", "", -100, 1, 0, 1, 100, -1.2, -0.001, 0.0, 0.001, 1.2, 1e-4, True, False,
        (1.0, 2.0), [1.0, 2.0], _Dummy(),
        np.zeros((1, 2), dtype=np.float16),
        np.zeros((100,), dtype=np.float32),
        np.zeros((1, 2), dtype=np.float64),
        np.zeros((1, 2), dtype=np.bool)
    ]
    for value in values_true:
        assert ia.is_integer_array(value) is True
    for value in values_false:
        assert ia.is_integer_array(value) is False


</source>
<source file="systems/imgaug-0.3.0/test/test_imgaug.py" startline="215" endline="239" pcid="968">
def test_is_float_array():
    class _Dummy(object):
        pass

    values_true = [
        np.zeros((1, 2), dtype=np.float16),
        np.zeros((100,), dtype=np.float32),
        np.zeros((1, 2), dtype=np.float64)
    ]
    values_false = [
        "A", "BC", "1", "", -100, 1, 0, 1, 100, -1.2, -0.001, 0.0, 0.001, 1.2, 1e-4, True, False,
        (1.0, 2.0), [1.0, 2.0], _Dummy(),
        np.zeros((1, 2), dtype=np.uint8),
        np.zeros((100,), dtype=np.uint8),
        np.zeros((1, 2), dtype=np.uint16),
        np.zeros((1, 2), dtype=np.int32),
        np.zeros((1, 2), dtype=np.int64),
        np.zeros((1, 2), dtype=np.bool)
    ]
    for value in values_true:
        assert ia.is_float_array(value) is True
    for value in values_false:
        assert ia.is_float_array(value) is False


</source>
</class>

<class classid="30" nclones="2" nlines="13" similarity="100">
<source file="systems/imgaug-0.3.0/test/test_imgaug.py" startline="573" endline="594" pcid="990">
def test_quokka_heatmap():
    # we are intentionally a bit looser here with atol=0.1, because apparently
    # on some systems there are small differences in what exactly is loaded,
    # see issue #414

    hm = ia.quokka_heatmap()
    assert hm.shape == (643, 960, 3)
    assert hm.arr_0to1.shape == (643, 960, 1)
    assert np.allclose(np.average(hm.arr_0to1), 0.57618505, rtol=0, atol=1e-3)

    hm = ia.quokka_heatmap(extract="square")
    assert hm.shape == (643, 643, 3)
    assert hm.arr_0to1.shape == (643, 643, 1)
    # TODO this value is 0.48026073 in python 2.7, while 0.48026952 in 3.7 -- why?
    assert np.allclose(np.average(hm.arr_0to1), 0.48026952, rtol=0, atol=1e-3)

    hm = ia.quokka_heatmap(size=(642, 959))
    assert hm.shape == (642, 959, 3)
    assert hm.arr_0to1.shape == (642, 959, 1)
    assert np.allclose(np.average(hm.arr_0to1), 0.5762454, rtol=0, atol=1e-3)


</source>
<source file="systems/imgaug-0.3.0/test/test_imgaug.py" startline="595" endline="611" pcid="991">
def test_quokka_segmentation_map():
    segmap = ia.quokka_segmentation_map()
    assert segmap.shape == (643, 960, 3)
    assert segmap.arr.shape == (643, 960, 1)
    assert np.allclose(np.average(segmap.arr), 0.3016427, rtol=0, atol=1e-3)

    segmap = ia.quokka_segmentation_map(extract="square")
    assert segmap.shape == (643, 643, 3)
    assert segmap.arr.shape == (643, 643, 1)
    assert np.allclose(np.average(segmap.arr), 0.450353, rtol=0, atol=1e-3)

    segmap = ia.quokka_segmentation_map(size=(642, 959))
    assert segmap.shape == (642, 959, 3)
    assert segmap.arr.shape == (642, 959, 1)
    assert np.allclose(np.average(segmap.arr), 0.30160266, rtol=0, atol=1e-3)


</source>
</class>

<class classid="31" nclones="2" nlines="26" similarity="80">
<source file="systems/imgaug-0.3.0/test/test_imgaug.py" startline="612" endline="642" pcid="992">
def test_quokka_keypoints():
    kpsoi = ia.quokka_keypoints()
    assert len(kpsoi.keypoints) > 0
    assert np.allclose(kpsoi.keypoints[0].x, 163.0)
    assert np.allclose(kpsoi.keypoints[0].y, 78.0)
    assert kpsoi.shape == (643, 960, 3)

    img = ia.quokka()
    patches = []
    for kp in kpsoi.keypoints:
        bb = ia.BoundingBox(x1=kp.x-1, x2=kp.x+2, y1=kp.y-1, y2=kp.y+2)
        patches.append(bb.extract_from_image(img))

    img_square = ia.quokka(extract="square")
    kpsoi_square = ia.quokka_keypoints(extract="square")
    assert len(kpsoi.keypoints) == len(kpsoi_square.keypoints)
    assert kpsoi_square.shape == (643, 643, 3)

    for kp, patch in zip(kpsoi_square.keypoints, patches):
        bb = ia.BoundingBox(x1=kp.x-1, x2=kp.x+2, y1=kp.y-1, y2=kp.y+2)
        patch_square = bb.extract_from_image(img_square)
        assert np.average(np.abs(patch.astype(np.float32) - patch_square.astype(np.float32))) < 1.0

    kpsoi_resized = ia.quokka_keypoints(size=(642, 959))
    assert kpsoi_resized.shape == (642, 959, 3)
    assert len(kpsoi.keypoints) == len(kpsoi_resized.keypoints)
    for kp, kp_resized in zip(kpsoi.keypoints, kpsoi_resized.keypoints):
        d = np.sqrt((kp.x - kp_resized.x) ** 2 + (kp.y - kp_resized.y) ** 2)
        assert d < 1.0


</source>
<source file="systems/imgaug-0.3.0/test/test_imgaug.py" startline="643" endline="674" pcid="993">
def test_quokka_bounding_boxes():
    bbsoi = ia.quokka_bounding_boxes()
    assert len(bbsoi.bounding_boxes) > 0
    bb0 = bbsoi.bounding_boxes[0]
    assert np.allclose(bb0.x1, 148.0)
    assert np.allclose(bb0.y1, 50.0)
    assert np.allclose(bb0.x2, 550.0)
    assert np.allclose(bb0.y2, 642.0)
    assert bbsoi.shape == (643, 960, 3)

    img = ia.quokka()
    patches = []
    for bb in bbsoi.bounding_boxes:
        patches.append(bb.extract_from_image(img))

    img_square = ia.quokka(extract="square")
    bbsoi_square = ia.quokka_bounding_boxes(extract="square")
    assert len(bbsoi.bounding_boxes) == len(bbsoi_square.bounding_boxes)
    assert bbsoi_square.shape == (643, 643, 3)

    for bb, patch in zip(bbsoi_square.bounding_boxes, patches):
        patch_square = bb.extract_from_image(img_square)
        assert np.average(np.abs(patch.astype(np.float32) - patch_square.astype(np.float32))) < 1.0

    bbsoi_resized = ia.quokka_bounding_boxes(size=(642, 959))
    assert bbsoi_resized.shape == (642, 959, 3)
    assert len(bbsoi.bounding_boxes) == len(bbsoi_resized.bounding_boxes)
    for bb, bb_resized in zip(bbsoi.bounding_boxes, bbsoi_resized.bounding_boxes):
        d = np.sqrt((bb.center_x - bb_resized.center_x) ** 2 + (bb.center_y - bb_resized.center_y) ** 2)
        assert d < 1.0


</source>
</class>

<class classid="32" nclones="2" nlines="23" similarity="100">
<source file="systems/imgaug-0.3.0/test/test_imgaug.py" startline="1599" endline="1626" pcid="1009">
        arr = np.zeros((1, 1, 3), dtype=np.uint8)
        paddings = ia.compute_paddings_to_reach_multiples_of(arr, 1, 2)
        assert paddings == (0, 1, 0, 0)

    def test_width_is_one(self):
        arr = np.zeros((1, 1, 3), dtype=np.uint8)
        paddings = ia.compute_paddings_to_reach_multiples_of(arr, 2, 1)
        assert paddings == (0, 0, 1, 0)

    def test_various_widths(self):
        nb_channels_lst = [None, 1, 3, 4]
        amounts = [2, 3, 4, 5, 6, 7, 8, 9]
        expecteds = [
            (0, 1, 0, 0),
            (0, 1, 0, 0),
            (0, 2, 0, 1),
            (0, 0, 0, 0),
            (0, 1, 0, 0),
            (0, 1, 0, 1),
            (0, 2, 0, 1),
            (0, 2, 0, 2)
        ]

        for amount, expected in zip(amounts, expecteds):
            for nb_channels in nb_channels_lst:
                with self.subTest(width_multiple=amount,
                                  nb_channels=nb_channels):
                    if nb_channels is None:
</source>
<source file="systems/imgaug-0.3.0/test/test_imgaug.py" startline="1627" endline="1654" pcid="1010">
                        arr = np.zeros((3, 5), dtype=np.uint8)
                    else:
                        arr = np.zeros((3, 5, nb_channels), dtype=np.uint8)

                    paddings = ia.compute_paddings_to_reach_multiples_of(
                        arr, None, amount)

                    assert paddings == expected

    def test_various_heights(self):
        nb_channels_lst = [None, 1, 3, 4]
        amounts = [2, 3, 4, 5, 6, 7, 8, 9]
        expecteds = [
            (0, 0, 1, 0),
            (0, 0, 1, 0),
            (1, 0, 2, 0),
            (0, 0, 0, 0),
            (0, 0, 1, 0),
            (1, 0, 1, 0),
            (1, 0, 2, 0),
            (2, 0, 2, 0)
        ]
        for amount, expected in zip(amounts, expecteds):
            for nb_channels in nb_channels_lst:
                with self.subTest(height_multiple=amount,
                                  nb_channels=nb_channels):
                    if nb_channels is None:
                        arr = np.zeros((5, 3), dtype=np.uint8)
</source>
</class>

<class classid="33" nclones="2" nlines="11" similarity="72">
<source file="systems/imgaug-0.3.0/test/test_imgaug.py" startline="1658" endline="1671" pcid="1011">
                    paddings = ia.compute_paddings_to_reach_multiples_of(
                        arr, amount, None)

                    assert paddings == expected


class Test_pad_to_multiples_of(unittest.TestCase):
    @mock.patch("imgaug.imgaug.compute_paddings_to_reach_multiples_of")
    @mock.patch("imgaug.imgaug.pad")
    def test_mocked(self, mock_pad, mock_compute_pads):
        mock_compute_pads.return_value = (1, 2, 3, 4)
        mock_pad.return_value = "padded_array"

        arr = np.ones((3, 5, 1), dtype=np.uint8)
</source>
<source file="systems/imgaug-0.3.0/test/test_imgaug.py" startline="1674" endline="1688" pcid="1012">
            arr, 10, 20, mode="foo", cval=100)

        mock_compute_pads.assert_called_once_with(arr, 10, 20)
        mock_pad.assert_called_once_with(arr, top=1, right=2, bottom=3,
                                         left=4, mode="foo", cval=100)
        assert arr_padded == "padded_array"

    @mock.patch("imgaug.imgaug.compute_paddings_to_reach_multiples_of")
    @mock.patch("imgaug.imgaug.pad")
    def test_mocked_return_pad_amounts(self, mock_pad, mock_compute_pads):
        mock_compute_pads.return_value = (1, 2, 3, 4)
        mock_pad.return_value = "padded_array"

        arr = np.ones((3, 5, 1), dtype=np.uint8)

</source>
</class>

<class classid="34" nclones="4" nlines="13" similarity="100">
<source file="systems/imgaug-0.3.0/test/test_imgaug.py" startline="1988" endline="2004" pcid="1016">
    assert arr_pooled.shape == (2, 2)
    assert arr_pooled.dtype == arr.dtype.type
    assert np.isclose(arr_pooled[0, 0], np.average([0, 1, 4, 5]))
    assert np.isclose(arr_pooled[0, 1], np.average([2, 2, 6, 6]))
    assert np.isclose(arr_pooled[1, 0], np.average([8, 9, 8, 9]))
    assert np.isclose(arr_pooled[1, 1], np.average([10, 10, 10, 10]))


# TODO add test that verifies the default padding mode
def test_avg_pool():
    # very basic test, as avg_pool() just calls pool(), which is tested in test_pool()
    arr = np.uint8([
        [0, 1, 2, 3],
        [4, 5, 6, 7],
        [8, 9, 10, 11],
        [12, 13, 14, 15]
    ])
</source>
<source file="systems/imgaug-0.3.0/test/test_imgaug.py" startline="2006" endline="2023" pcid="1017">
    assert arr_pooled.shape == (2, 2)
    assert arr_pooled.dtype == arr.dtype.type
    assert arr_pooled[0, 0] == int(np.average([0, 1, 4, 5]))
    assert arr_pooled[0, 1] == int(np.average([2, 3, 6, 7]))
    assert arr_pooled[1, 0] == int(np.average([8, 9, 12, 13]))
    assert arr_pooled[1, 1] == int(np.average([10, 11, 14, 15]))


# TODO add test that verifies the default padding mode
def test_max_pool():
    # very basic test, as max_pool() just calls pool(), which is tested in
    # test_pool()
    arr = np.uint8([
        [0, 1, 2, 3],
        [4, 5, 6, 7],
        [8, 9, 10, 11],
        [12, 13, 14, 15]
    ])
</source>
<source file="systems/imgaug-0.3.0/test/test_imgaug.py" startline="2046" endline="2065" pcid="1019">
    assert arr_pooled.shape == (2, 2)
    assert arr_pooled.dtype == arr.dtype.type
    assert arr_pooled[0, 0] == int(np.min([0, 1, 4, 5]))
    assert arr_pooled[0, 1] == int(np.min([2, 3, 6, 7]))
    assert arr_pooled[1, 0] == int(np.min([8, 9, 12, 13]))
    assert arr_pooled[1, 1] == int(np.min([10, 11, 14, 15]))


# TODO add test that verifies the default padding mode
def test_median_pool():
    # very basic test, as median_pool() just calls pool(), which is tested in
    # test_pool()
    arr = np.uint8([
        [0, 1, 2, 3],
        [4, 5, 6, 7],
        [8, 9, 10, 11],
        [12, 13, 14, 15]
    ])

    arr_pooled = ia.median_pool(arr, 2)
</source>
<source file="systems/imgaug-0.3.0/test/test_imgaug.py" startline="2025" endline="2044" pcid="1018">
    assert arr_pooled.shape == (2, 2)
    assert arr_pooled.dtype == arr.dtype.type
    assert arr_pooled[0, 0] == int(np.max([0, 1, 4, 5]))
    assert arr_pooled[0, 1] == int(np.max([2, 3, 6, 7]))
    assert arr_pooled[1, 0] == int(np.max([8, 9, 12, 13]))
    assert arr_pooled[1, 1] == int(np.max([10, 11, 14, 15]))


# TODO add test that verifies the default padding mode
def test_min_pool():
    # very basic test, as min_pool() just calls pool(), which is tested in
    # test_pool()
    arr = np.uint8([
        [0, 1, 2, 3],
        [4, 5, 6, 7],
        [8, 9, 10, 11],
        [12, 13, 14, 15]
    ])

    arr_pooled = ia.min_pool(arr, 2)
</source>
</class>

<class classid="35" nclones="3" nlines="13" similarity="71">
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="70" endline="82" pcid="1027">
    def test_function_works_inplace(self):
        image = np.arange(4*5*3).astype(np.uint8).reshape((4, 5, 3))
        image = np.copy(image)  # reshape sets flag OWNDATA=False
        image_orig = np.copy(image)
        from_cspace = iaa.CSPACE_RGB
        to_cspace = iaa.CSPACE_BGR
        image_out = iaa.change_colorspace_(
            image,
            to_colorspace=to_cspace, from_colorspace=from_cspace)
        assert image_out is image
        assert np.array_equal(image_out, image)
        assert not np.array_equal(image_out, image_orig)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="101" endline="117" pcid="1029">
    def test_image_is_noncontiguous(self):
        image = np.arange(4*5*3).astype(np.uint8).reshape((4, 5, 3))
        image = np.copy(image)  # reshape sets flag OWNDATA=False
        image_copy = np.copy(np.ascontiguousarray(np.fliplr(image)))
        image_noncontiguous = np.fliplr(image)
        assert image_noncontiguous.flags["C_CONTIGUOUS"] is False

        from_cspace = iaa.CSPACE_RGB
        to_cspace = iaa.CSPACE_BGR
        image_out = iaa.change_colorspace_(
            image_noncontiguous,
            to_colorspace=to_cspace, from_colorspace=from_cspace)

        expected = self._generate_expected_image(image_copy, from_cspace,
                                                 to_cspace)
        assert np.array_equal(image_out, expected)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="83" endline="100" pcid="1028">
    def test_image_is_view(self):
        image = np.arange(4*5*4).astype(np.uint8).reshape((4, 5, 4))
        image = np.copy(image)  # reshape sets flag OWNDATA=False
        image_copy = np.copy(image)
        image_view = image[..., 0:3]
        assert image_view.flags["OWNDATA"] is False

        from_cspace = iaa.CSPACE_RGB
        to_cspace = iaa.CSPACE_BGR
        image_out = iaa.change_colorspace_(
            image_view,
            to_colorspace=to_cspace, from_colorspace=from_cspace)

        expected = self._generate_expected_image(
            np.ascontiguousarray(image_copy[..., 0:3]),
            from_cspace, to_cspace)
        assert np.array_equal(image_out, expected)

</source>
</class>

<class classid="36" nclones="3" nlines="12" similarity="91">
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="118" endline="130" pcid="1030">
    def test_cannot_transform_from_grayscale_to_another_cspace(self):
        image = np.arange(4*5*3).astype(np.uint8).reshape((4, 5, 3))
        image = np.copy(image)  # reshape sets flag OWNDATA=False
        from_cspace = iaa.CSPACE_GRAY
        to_cspace = iaa.CSPACE_RGB
        with self.assertRaises(AssertionError) as cm:
            _ = iaa.change_colorspace_(
                np.copy(image),
                from_colorspace=from_cspace, to_colorspace=to_cspace)
        assert (
            "Cannot convert from grayscale to another colorspace"
            in str(cm.exception))

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="131" endline="143" pcid="1031">
    def test_image_without_channels_fails(self):
        image = np.arange(4*5).astype(np.uint8).reshape((4, 5))
        image = np.copy(image)  # reshape sets flag OWNDATA=False
        from_cspace = iaa.CSPACE_RGB
        to_cspace = iaa.CSPACE_BGR
        with self.assertRaises(AssertionError) as cm:
            _ = iaa.change_colorspace_(
                np.copy(image),
                from_colorspace=from_cspace, to_colorspace=to_cspace)
        assert (
            "Expected image shape to be three-dimensional"
            in str(cm.exception))

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="144" endline="156" pcid="1032">
    def test_image_with_four_channels_fails(self):
        image = np.arange(4*5*4).astype(np.uint8).reshape((4, 5, 4))
        image = np.copy(image)  # reshape sets flag OWNDATA=False
        from_cspace = iaa.CSPACE_RGB
        to_cspace = iaa.CSPACE_BGR
        with self.assertRaises(AssertionError) as cm:
            _ = iaa.change_colorspace_(
                np.copy(image),
                from_colorspace=from_cspace, to_colorspace=to_cspace)
        assert (
            "Expected number of channels to be three"
            in str(cm.exception))

</source>
</class>

<class classid="37" nclones="71" nlines="15" similarity="70">
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="183" endline="198" pcid="1034">
    def test_zero_sized_axes(self):
        shapes = [
            (0, 0, 3),
            (0, 1, 3),
            (1, 0, 3)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)

                image_aug = iaa.change_colorspace_(
                    np.copy(image), from_colorspace="RGB", to_colorspace="BGR")

                assert image_aug.shape == image.shape

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blur.py" startline="1206" endline="1220" pcid="1698">
            elif np.array_equal(observed, self.blur5x5):
                seen[1] += True
            else:
                raise Exception("Unexpected result in MedianBlur@2")
            if all(seen):
                break
        assert np.all(seen)

    def test_more_than_four_channels(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blur.py" startline="901" endline="915" pcid="1684">
                if np.array_equal(observed, img_aug):
                    nb_seen[key] += 1
        # dont check sum here, because 0xX and Xx0 are all the same, i.e. much
        # higher sum than nb_iterations
        assert np.all([v > 0 for v in nb_seen.values()])

    def test_more_than_four_channels(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]
        for shape in shapes:
            with self.subTest(shape=shape):
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blur.py" startline="111" endline="125" pcid="1652">
    def test_more_than_four_channels(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]
        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)

                image_aug = iaa.blur_gaussian_(np.copy(image), 1.0)

                assert image_aug.shape == image.shape

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blur.py" startline="1261" endline="1276" pcid="1702">
        assert keypoints_equal(observed, expected)


# TODO extend these tests
class TestBilateralBlur(unittest.TestCase):
    def setUp(self):
        reseed()

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0, 3),
            (0, 1, 3),
            (1, 0, 3)
        ]

        for shape in shapes:
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="3656" endline="3671" pcid="2242">
        hm = ia.quokka_heatmap()
        hm_aug = aug.augment_heatmaps([hm])[0]
        assert np.allclose(hm.arr_0to1, hm_aug.arr_0to1)

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0, 3),
            (0, 1, 3),
            (1, 0, 3)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.JpegCompression(100)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blur.py" startline="126" endline="144" pcid="1653">
    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)

                image_aug = iaa.blur_gaussian_(np.copy(image), 1.0)

                assert image_aug.shape == image.shape

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="3255" endline="3273" pcid="2224">
                assert np.all(image_aug == 255)
                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == image.shape

    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.Invert(1.0)

                image_aug = aug(image=image)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="1610" endline="1628" pcid="2141">
                assert np.all(image_aug == 2)
                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == image.shape

    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.ones(shape, dtype=np.uint8)
                aug = iaa.Multiply(2)

                image_aug = aug(image=image)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_segmentation.py" startline="1172" endline="1188" pcid="2031">

    def test_zero_sized_axes(self):
        shapes = [
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                sampler = iaa.RelativeRegularGridPointsSampler(0.01, 0.01)

                points = sampler.sample_points([image], iarandom.RNG(1))[0]

                assert len(points) == 1
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="279" endline="297" pcid="2078">
    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.Add(1)

                image_aug = aug(image=image)

                assert np.all(image_aug == 1)
                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == image.shape

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_segmentation.py" startline="1189" endline="1205" pcid="2032">

    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                sampler = iaa.RelativeRegularGridPointsSampler(0.01, 0.01)

                points = sampler.sample_points([image], iarandom.RNG(1))[0]

                assert len(points) == 1
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_segmentation.py" startline="1488" endline="1504" pcid="2055">

    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                sampler = iaa.UniformPointsSampler(1)

                points = sampler.sample_points([image], iarandom.RNG(1))[0]

                assert len(points) == 1
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blur.py" startline="916" endline="934" pcid="1685">
                image = np.zeros(shape, dtype=np.uint8)

                image_aug = iaa.AverageBlur(k=3)(image=image)

                assert image_aug.shape == image.shape

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="765" endline="783" pcid="2097">
    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.AddElementwise(1)

                image_aug = aug(image=image)

                assert np.all(image_aug == 1)
                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == image.shape

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_segmentation.py" startline="1468" endline="1487" pcid="2054">

    def test_zero_sized_axes(self):
        shapes = [
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                sampler = iaa.UniformPointsSampler(1)

                points = sampler.sample_points([image], iarandom.RNG(1))[0]

                # TODO this is not the same as for
                #      (Relative)RegularGridPointsSampler, which returns in
                #      this case 0 points
                assert len(points) == 1
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="2573" endline="2591" pcid="2174">
                assert np.all(image_aug == 1)
                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == image.shape

    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.ReplaceElementwise(1.0, 1)

                image_aug = aug(image=image)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_segmentation.py" startline="1051" endline="1067" pcid="2020">

    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                sampler = iaa.RegularGridPointsSampler(1, 1)

                points = sampler.sample_points([image], iarandom.RNG(1))[0]

                assert len(points) == 1
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="2105" endline="2123" pcid="2158">
                assert np.all(image_aug == 2)
                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == image.shape

    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.ones(shape, dtype=np.uint8)
                aug = iaa.MultiplyElementwise(2)

                image_aug = aug(image=image)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_segmentation.py" startline="1034" endline="1050" pcid="2019">

    def test_zero_sized_axes(self):
        shapes = [
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                sampler = iaa.RegularGridPointsSampler(1, 1)

                points = sampler.sample_points([image], iarandom.RNG(1))[0]

                assert len(points) == 1
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blur.py" startline="1221" endline="1239" pcid="1699">
        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)

                image_aug = iaa.MedianBlur(k=3)(image=image)

                assert image_aug.shape == image.shape

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_weather.py" startline="218" endline="240" pcid="1172">
    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.Clouds()

                image_aug = aug(image=image)

                assert np.any(image_aug > 0)
                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape


# only a very rough test here currently, because the augmenter is fairly hard
# to test
# TODO add more tests, improve testability
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="257" endline="278" pcid="2077">
    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.Add(1)

                image_aug = aug(image=image)

                assert np.all(image_aug == 1)
                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == image.shape

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_weather.py" startline="293" endline="315" pcid="1179">
    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.Fog()

                image_aug = aug(image=image)

                assert np.any(image_aug > 0)
                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape


# only a very rough test here currently, because the augmenter is fairly hard
# to test
# TODO add more tests, improve testability
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="4975" endline="4996" pcid="1499">

        img_aug255 = aug255.augment_image(img)
        img_aug0 = aug0.augment_image(img)

        assert (img_aug255 == 255).all()
        assert not (img_aug0 == 255).all()

    # ---------
    # unusual channel numbers
    # ---------
    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.PerspectiveTransform(scale=0.01)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="5903" endline="5924" pcid="1564">
        img_aug_mask = img_aug > 255*0.1
        segmaps_aug_mask = ia.imresize_single_image(
            segmaps_aug.arr, (80, 80), interpolation="nearest") > 0
        same = np.sum(img_aug_mask == segmaps_aug_mask[:, :, 0])
        assert segmaps_aug.shape == (80, 80)
        assert segmaps_aug.arr.shape == (40, 40, 1)
        assert (same / img_aug_mask.size) >= 0.94

    # ---------
    # unusual channel numbers
    # ---------
    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_weather.py" startline="376" endline="392" pcid="1185">
    def test_zero_sized_axes(self):
        shapes = [
            (0, 0, 3),
            (0, 1, 3),
            (1, 0, 3)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.Snowflakes()

                image_aug = aug(image=image)

                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_weather.py" startline="144" endline="165" pcid="1165">
    def test_zero_sized_axes(self):
        shapes = [
            (0, 0, 3),
            (0, 1, 3),
            (1, 0, 3)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.FastSnowyLandscape(100, 1.5,
                                             from_colorspace="RGB")

                image_aug = aug(image=image)

                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape


# only a very rough test here currently, because the augmenter is fairly hard
# to test
# TODO add more tests, improve testability
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="1588" endline="1609" pcid="2140">
        except Exception:
            got_exception = True
        assert got_exception

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.ones(shape, dtype=np.uint8)
                aug = iaa.Multiply(1)

                image_aug = aug(image=image)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="743" endline="764" pcid="2096">
    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.AddElementwise(1)

                image_aug = aug(image=image)

                assert np.all(image_aug == 1)
                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == image.shape

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="2083" endline="2104" pcid="2157">
        except Exception:
            got_exception = True
        assert got_exception

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.ones(shape, dtype=np.uint8)
                aug = iaa.MultiplyElementwise(2)

                image_aug = aug(image=image)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_pooling.py" startline="318" endline="335" pcid="1922">
    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.full(shape, 128, dtype=np.uint8)
                aug = self.augmenter(3)

                image_aug = aug(image=image)

                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="6894" endline="6914" pcid="1640">
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                for _ in sm.xrange(10):
                    image = np.zeros(shape, dtype=np.uint8)
                    aug = iaa.Rot90([1, 3], keep_size=False)

                    image_aug = aug(image=image)

                    shape_expected = tuple([shape[1], shape[0]]
                                           + list(shape[2:]))
                    assert image_aug.shape == shape_expected

    def test_zero_sized_axes_k_1_or_3_keep_size(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_weather.py" startline="197" endline="217" pcid="1171">
    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.Clouds()

                image_aug = aug(image=image)

                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_convolutional.py" startline="208" endline="227" pcid="1739">
    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.Convolve(matrix=np.float32([[1]]))

                image_aug = aug(image=image)

                assert image_aug.shape == image.shape

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="4244" endline="4268" pcid="1460">
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.PiecewiseAffine(scale=0.05, nb_rows=2, nb_cols=2)

                image_aug = aug(image=image)

                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape

    def test_zero_sized_axes_absolute_scale(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.PiecewiseAffine(scale=5, nb_rows=2, nb_cols=2,
                                          absolute_scale=True)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="1806" endline="1825" pcid="1155">
            _ = iaa.quantize_colors_uniform(image, 1)
        except AssertionError as exc:
            assert "[2..256]" in str(exc)
            got_exception = True
        assert got_exception

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_weather.py" startline="272" endline="292" pcid="1178">
    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.Fog()

                image_aug = aug(image=image)

                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="1541" endline="1561" pcid="1133">
        for _ in sm.xrange(20):
            images_quantized.append(iaa.quantize_colors_kmeans(image, 20))

        for image_quantized in images_quantized[1:]:
            assert np.array_equal(image_quantized, images_quantized[0])

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="1767" endline="1786" pcid="2471">
    def test_zero_sized_axes_keep_size(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.Pad(px=1, keep_size=True)

                image_aug = aug(image=image)

                assert image_aug.shape == image.shape

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="2551" endline="2572" pcid="2173">
        except Exception:
            got_exception = True
        assert got_exception

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.ReplaceElementwise(1.0, 1)

                image_aug = aug(image=image)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="3233" endline="3254" pcid="2223">
        except Exception:
            got_exception = True
        assert got_exception

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.Invert(1.0)

                image_aug = aug(image=image)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="4223" endline="4243" pcid="1459">
        observed = aug.augment_polygons(psoi)

        assert observed.shape == (10, 10, 3)
        assert len(observed.polygons) == 0

    # ---------
    # zero-sized axes
    # ---------
    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_segmentation.py" startline="720" endline="739" pcid="2000">

    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

        sampler = iaa.RegularGridPointsSampler(50, 50)

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.full(shape, 128, dtype=np.uint8)
                aug = iaa.Voronoi(sampler, p_replace=1)

                image_aug = aug(image=image)

                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="6829" endline="6848" pcid="1637">
        kpsoi_aug = aug.augment_keypoints(kpsoi)

        assert len(kpsoi_aug.keypoints) == 0
        assert kpsoi_aug.shape == (8, 4, 3)

    def test_empty_polygons(self):
        aug = iaa.Rot90(k=1, keep_size=False)
        psoi = ia.PolygonsOnImage([], shape=(4, 8, 3))

        psoi_aug = aug.augment_polygons(psoi)

        assert len(psoi_aug.polygons) == 0
        assert psoi_aug.shape == (8, 4, 3)

    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="1562" endline="1580" pcid="1134">
                image_aug = iaa.quantize_colors_kmeans(image, 2)

                assert np.all(image_aug == 0)
                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape

    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)

                image_aug = iaa.quantize_colors_kmeans(image, 2)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="1826" endline="1842" pcid="1156">

                image_aug = iaa.quantize_colors_uniform(image, 2)

                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape

    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blend.py" startline="113" endline="131" pcid="2252">
    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image_fg = np.full(shape, 0, dtype=np.uint8)
                image_bg = np.full(shape, 255, dtype=np.uint8)

                image_aug = blend.blend_alpha(image_fg, image_bg, 1.0)

                assert np.all(image_aug == 0)
                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blend.py" startline="906" endline="924" pcid="2306">

    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.full(shape, 0, dtype=np.uint8)
                aug = iaa.Alpha(1.0, iaa.Add(1), iaa.Add(100))

                image_aug = aug(image=image)

                assert np.all(image_aug == 1)
                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blend.py" startline="1512" endline="1529" pcid="2361">

    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.full(shape, 0, dtype=np.uint8)
                aug = iaa.Alpha(1.0, iaa.Add(1), iaa.Add(100))

                image_aug = aug(image=image)

                assert np.all(image_aug == 1)
                assert image_aug.dtype.name == "uint8"
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_segmentation.py" startline="167" endline="184" pcid="1960">
    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.full(shape, 128, dtype=np.uint8)
                aug = iaa.Superpixels(p_replace=1.0, n_segments=10)

                image_aug = aug(image=image)

                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_segmentation.py" startline="146" endline="166" pcid="1959">
    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.full(shape, 128, dtype=np.uint8)
                aug = iaa.Superpixels(p_replace=1.0, n_segments=10)

                image_aug = aug(image=image)

                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_pooling.py" startline="297" endline="317" pcid="1921">
    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.full(shape, 128, dtype=np.uint8)
                aug = self.augmenter(3)

                image_aug = aug(image=image)

                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_segmentation.py" startline="697" endline="719" pcid="1999">

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        sampler = iaa.RegularGridPointsSampler(50, 50)

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.full(shape, 128, dtype=np.uint8)
                aug = iaa.Voronoi(sampler, p_replace=1)

                image_aug = aug(image=image)

                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="4997" endline="5022" pcid="1500">

                image_aug = aug(image=image)

                assert np.all(image_aug == 0)
                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape

    # ---------
    # zero-sized axes
    # ---------
    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            for keep_size in [False, True]:
                with self.subTest(shape=shape, keep_size=keep_size):
                    for _ in sm.xrange(3):
                        image = np.zeros(shape, dtype=np.uint8)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blend.py" startline="1490" endline="1511" pcid="2360">

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.full(shape, 0, dtype=np.uint8)
                aug = iaa.Alpha(1.0, iaa.Add(1), iaa.Add(100))

                image_aug = aug(image=image)

                assert np.all(image_aug == 1)
                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blend.py" startline="884" endline="905" pcid="2305">

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.full(shape, 0, dtype=np.uint8)
                aug = iaa.Alpha(1.0, iaa.Add(1), iaa.Add(100))

                image_aug = aug(image=image)

                assert np.all(image_aug == 1)
                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="5925" endline="5950" pcid="1565">
                aug = iaa.ElasticTransformation(alpha=2.0, sigma=2.0)

                image_aug = aug(image=image)

                assert np.all(image_aug == 0)
                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape

    # ---------
    # zero-sized axes
    # ---------
    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            for keep_size in [False, True]:
                with self.subTest(shape=shape, keep_size=keep_size):
                    for _ in sm.xrange(3):
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blend.py" startline="91" endline="112" pcid="2251">
    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image_fg = np.full(shape, 0, dtype=np.uint8)
                image_bg = np.full(shape, 255, dtype=np.uint8)

                image_aug = blend.blend_alpha(image_fg, image_bg, 1.0)

                assert np.all(image_aug == 0)
                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="6849" endline="6870" pcid="1638">
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.Rot90(k=1)

                image_aug = aug(image=image)

                shape_expected = tuple([shape[1], shape[0]] + list(shape[2:]))
                assert np.all(image_aug == 0)
                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape_expected

    def test_zero_sized_axes_k_0_or_2(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="6871" endline="6893" pcid="1639">
            (1, 0, 1)
        ]

        for shape in shapes:
            for keep_size in [False, True]:
                with self.subTest(shape=shape, keep_size=keep_size):
                    for _ in sm.xrange(10):
                        image = np.zeros(shape, dtype=np.uint8)
                        aug = iaa.Rot90([0, 2], keep_size=keep_size)

                        image_aug = aug(image=image)

                        assert image_aug.shape == shape

    def test_zero_sized_axes_k_1_or_3_no_keep_size(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="1743" endline="1766" pcid="2470">
    def test_zero_sized_axes_no_keep_size(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.Pad(px=1, keep_size=False)

                image_aug = aug(image=image)

                expected_height = shape[0] + 2
                expected_width = shape[1] + 2
                expected_shape = tuple([expected_height, expected_width]
                                       + list(shape[2:]))
                assert image_aug.shape == expected_shape

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="2990" endline="3013" pcid="2539">
        observed = aug.augment_segmentation_maps([segmaps])[0]

        expected = np.ones((16, 16, 1), dtype=np.int32)
        expected[:, 0, 0] = 0
        expected[0, :, 0] = 0
        assert observed.shape == (32, 32, 3)
        assert np.array_equal(observed.arr, expected)

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.PadToFixedSize(height=1, width=1)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="2379" endline="2400" pcid="1387">
                assert np.allclose(image_aug[:, 0:2, :], 128, rtol=0, atol=2)
                assert np.allclose(image_aug[:, 2:3, 0:3], 255, rtol=0, atol=2)
                assert np.allclose(image_aug[:, 2:3, 3:], 255, rtol=0, atol=2)
                assert np.allclose(hm_aug_arr[:, 0:2, :], 0.5, rtol=0,
                                   atol=0.025)
                assert np.allclose(hm_aug_arr[:, 2:3, :], 0.0, rtol=0,
                                   atol=0.025)

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        for fit_output in [False, True]:
            for shape in shapes:
                with self.subTest(shape=shape, fit_output=fit_output):
                    image = np.zeros(shape, dtype=np.uint8)
                    aug = iaa.Affine(rotate=45, fit_output=fit_output)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_flip.py" startline="391" endline="416" pcid="1830">
    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1),
            (0, 2),
            (2, 0),
            (0, 2, 0),
            (2, 0, 0),
            (0, 2, 1),
            (2, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = self.create_aug(1.0)

                image_aug = aug(image=image)

                assert image_aug.shape == image.shape

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_segmentation.py" startline="420" endline="446" pcid="1977">

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1)
        ]

        cell_coordinates = np.float32([
            [1.0, 1.0],
            [3.0, 1.0]
        ])
        replace_mask = np.array([True, True], dtype=bool)

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.full(shape, 128, dtype=np.uint8)

                image_aug = iaa.segment_voronoi(image, cell_coordinates,
                                                replace_mask)

                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="2601" endline="2637" pcid="2513">
                expected_height = 0 if shape[0] == 0 else 1
                expected_width = 0 if shape[1] == 0 else 1
                expected_shape = tuple([expected_height, expected_width]
                                       + list(shape[2:]))
                assert image_aug.shape == expected_shape

    def test_zero_sized_axes_keep_size(self):
        # we also use height/width 2 here, because a height/width of 1 is
        # actually not changed due to prevent_zero_size
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1),
            (0, 2),
            (2, 0),
            (0, 2, 0),
            (2, 0, 0),
            (0, 2, 1),
            (2, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.Crop(px=1, keep_size=True)

                with warnings.catch_warnings(record=True) as caught_warnings:
                    image_aug = aug(image=image)

                # we don't check the number of warnings here as it varies by
                # shape
                for warning in caught_warnings:
                    assert (
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="3376" endline="3405" pcid="2568">
        aug = iaa.CropToFixedSize(height=32, width=32, position="left-top")
        segmaps_arr = np.ones((17, 17, 1), dtype=np.int32)
        segmaps = SegmentationMapsOnImage(segmaps_arr, shape=(34, 34, 3))

        observed = aug.augment_segmentation_maps([segmaps])[0]

        expected = np.ones((16, 16, 1), dtype=np.int32)
        assert observed.shape == (32, 32, 3)
        assert np.array_equal(observed.arr, expected)

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1),
            (0, 2),
            (2, 0),
            (0, 2, 0),
            (2, 0, 0),
            (0, 2, 1),
            (2, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="3797" endline="3823" pcid="2597">
    def test_segmaps_specific_interpolation_set_to_no_resize(self):
        aug = iaa.KeepSizeByResize(
            self.children,
            interpolation="cubic",
            interpolation_segmaps=iaa.KeepSizeByResize.NO_RESIZE)
        segmaps_oi = self.segmaps

        segmaps_oi_aug = aug.augment_segmentation_maps([segmaps_oi])[0]

        assert segmaps_oi_aug.arr.shape == (3, 4, 1)
        assert np.array_equal(segmaps_oi_aug.arr, segmaps_oi.arr[1:, :, :])

    def test_zero_sized_axes(self):
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1),
            (0, 2),
            (2, 0),
            (0, 2, 0),
            (2, 0, 0),
            (0, 2, 1),
            (2, 0, 1)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_segmentation.py" startline="447" endline="471" pcid="1978">

    def test_unusual_channel_numbers(self):
        shapes = [
            (1, 1, 4),
            (1, 1, 5),
            (1, 1, 512),
            (1, 1, 513)
        ]

        cell_coordinates = np.float32([
            [1.0, 1.0],
            [3.0, 1.0]
        ])
        replace_mask = np.array([True, True], dtype=bool)

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.full(shape, 128, dtype=np.uint8)

                image_aug = iaa.segment_voronoi(image, cell_coordinates,
                                                replace_mask)

                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == shape

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="2560" endline="2600" pcid="2512">
        assert 250 - 50 < seen[0] < 250 + 50
        assert seen[1] == 0
        assert seen[2] == 0
        assert seen[3] == 0
        assert 250 - 50 < seen[4] < 250 + 50

    def test_zero_sized_axes_no_keep_size(self):
        # we also use height/width 2 here, because a height/width of 1 is
        # actually not changed due to prevent_zero_size
        shapes = [
            (0, 0),
            (0, 1),
            (1, 0),
            (0, 1, 0),
            (1, 0, 0),
            (0, 1, 1),
            (1, 0, 1),
            (0, 2),
            (2, 0),
            (0, 2, 0),
            (2, 0, 0),
            (0, 2, 1),
            (2, 0, 1)
        ]

        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)
                aug = iaa.Crop(px=1, keep_size=False)

                with warnings.catch_warnings(record=True) as caught_warnings:
                    image_aug = aug(image=image)

                # we don't check the number of warnings here as it varies by
                # shape
                for warning in caught_warnings:
                    assert (
                        "crop amounts in CropAndPad"
                        in str(warning.message)
                    )

</source>
</class>

<class classid="38" nclones="6" nlines="28" similarity="71">
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="256" endline="291" pcid="1040">
    def test_augment_images__hue(self):
        def augment_images(images, random_state, parents, hooks):
            assert images[0].dtype.name == "int16"
            images = np.copy(images)
            images[..., 0] += 10
            return images

        aug = iaa.WithHueAndSaturation(iaa.Lambda(func_images=augment_images))

        # example image
        image = np.arange(0, 255).reshape((1, 255, 1)).astype(np.uint8)
        image = np.tile(image, (1, 1, 3))
        image[..., 0] += 0
        image[..., 1] += 1
        image[..., 2] += 2

        # compute expected output
        image_hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)
        image_hsv = image_hsv.astype(np.int16)
        image_hsv[..., 0] = (
            (image_hsv[..., 0].astype(np.float32)/180)*255).astype(np.int16)
        image_hsv[..., 0] += 10
        image_hsv[..., 0] = np.mod(image_hsv[..., 0], 255)
        image_hsv[..., 0] = (
            (image_hsv[..., 0].astype(np.float32)/255)*180).astype(np.int16)
        image_hsv = image_hsv.astype(np.uint8)
        image_expected = cv2.cvtColor(image_hsv, cv2.COLOR_HSV2RGB)
        assert not np.array_equal(image_expected, image)

        # augment and verify
        images_aug = aug.augment_images(np.stack([image, image], axis=0))
        assert ia.is_np_array(images_aug)
        for image_aug in images_aug:
            assert image_aug.shape == (1, 255, 3)
            assert np.array_equal(image_aug, image_expected)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="480" endline="517" pcid="1057">
    def test_augment_images__mul(self):
        aug = iaa.MultiplyHueAndSaturation(1.5)

        # example image
        image = np.arange(0, 255).reshape((1, 255, 1)).astype(np.uint8)
        image = np.tile(image, (1, 1, 3))
        image[..., 0] += 0
        image[..., 1] += 5
        image[..., 2] += 10

        # compute expected output
        image_hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)
        image_hsv = image_hsv.astype(np.int16)  # simulate WithHueAndSaturation
        image_hsv[..., 0] = (
            (image_hsv[..., 0].astype(np.float32)/180)*255).astype(np.int16)
        image_hsv = image_hsv.astype(np.float32)  # simulate Multiply

        image_hsv[..., 0] *= 1.5
        image_hsv[..., 1] *= 1.5
        image_hsv = np.round(image_hsv).astype(np.int16)

        image_hsv[..., 0] = np.mod(image_hsv[..., 0], 255)
        image_hsv[..., 0] = (
            (image_hsv[..., 0].astype(np.float32)/255)*180).astype(np.int16)
        image_hsv[..., 1] = np.clip(image_hsv[..., 1], 0, 255)

        image_hsv = image_hsv.astype(np.uint8)
        image_expected = cv2.cvtColor(image_hsv, cv2.COLOR_HSV2RGB)
        assert not np.array_equal(image_expected, image)

        # augment and verify
        images_aug = aug.augment_images(np.stack([image, image], axis=0))
        assert ia.is_np_array(images_aug)
        for image_aug in images_aug:
            assert image_aug.shape == (1, 255, 3)
            diff = np.abs(image_aug.astype(np.int16) - image_expected)
            assert np.all(diff <= 1)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="518" endline="562" pcid="1058">
    def test_augment_images__mul_hue(self):
        # this is almost identical to test_augment_images__mul
        # only
        #     aug = ...
        # and
        #     image_hsv[...] *= 1.2
        # have been changed

        aug = iaa.MultiplyHueAndSaturation(mul_hue=1.5)  # changed over __mul

        # example image
        image = np.arange(0, 255).reshape((1, 255, 1)).astype(np.uint8)
        image = np.tile(image, (1, 1, 3))
        image[..., 0] += 0
        image[..., 1] += 5
        image[..., 2] += 10

        # compute expected output
        image_hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)
        image_hsv = image_hsv.astype(np.int16)  # simulate WithHueAndSaturation
        image_hsv[..., 0] = (
            (image_hsv[..., 0].astype(np.float32)/180)*255).astype(np.int16)
        image_hsv = image_hsv.astype(np.float32)  # simulate Multiply

        image_hsv[..., 0] *= 1.5
        image_hsv[..., 1] *= 1.0  # changed over __mul
        image_hsv = np.round(image_hsv).astype(np.int16)

        image_hsv[..., 0] = np.mod(image_hsv[..., 0], 255)
        image_hsv[..., 0] = (
            (image_hsv[..., 0].astype(np.float32)/255)*180).astype(np.int16)
        image_hsv[..., 1] = np.clip(image_hsv[..., 1], 0, 255)

        image_hsv = image_hsv.astype(np.uint8)
        image_expected = cv2.cvtColor(image_hsv, cv2.COLOR_HSV2RGB)
        assert not np.array_equal(image_expected, image)

        # augment and verify
        images_aug = aug.augment_images(np.stack([image, image], axis=0))
        assert ia.is_np_array(images_aug)
        for image_aug in images_aug:
            assert image_aug.shape == (1, 255, 3)
            diff = np.abs(image_aug.astype(np.int16) - image_expected)
            assert np.all(diff <= 1)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="292" endline="327" pcid="1042">
    def test_augment_images__saturation(self):
        def augment_images(images, random_state, parents, hooks):
            assert images[0].dtype.name == "int16"
            images = np.copy(images)
            images[..., 1] += 10
            return images

        aug = iaa.WithHueAndSaturation(iaa.Lambda(func_images=augment_images))

        # example image
        image = np.arange(0, 255).reshape((1, 255, 1)).astype(np.uint8)
        image = np.tile(image, (1, 1, 3))
        image[..., 0] += 0
        image[..., 1] += 1
        image[..., 2] += 2

        # compute expected output
        image_hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)
        image_hsv = image_hsv.astype(np.int16)
        image_hsv[..., 0] = (
            (image_hsv[..., 0].astype(np.float32)/180)*255).astype(np.int16)
        image_hsv[..., 1] += 10
        image_hsv[..., 1] = np.clip(image_hsv[..., 1], 0, 255)
        image_hsv[..., 0] = (
            (image_hsv[..., 0].astype(np.float32)/255)*180).astype(np.int16)
        image_hsv = image_hsv.astype(np.uint8)
        image_expected = cv2.cvtColor(image_hsv, cv2.COLOR_HSV2RGB)
        assert not np.array_equal(image_expected, image)

        # augment and verify
        images_aug = aug.augment_images(np.stack([image, image], axis=0))
        assert ia.is_np_array(images_aug)
        for image_aug in images_aug:
            assert image_aug.shape == (1, 255, 3)
            assert np.array_equal(image_aug, image_expected)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="563" endline="607" pcid="1059">
    def test_augment_images__mul_saturation(self):
        # this is almost identical to test_augment_images__mul
        # only
        #     aug = ...
        # and
        #     image_hsv[...] *= 1.2
        # have been changed

        aug = iaa.MultiplyHueAndSaturation(mul_saturation=1.5)  # changed

        # example image
        image = np.arange(0, 255).reshape((1, 255, 1)).astype(np.uint8)
        image = np.tile(image, (1, 1, 3))
        image[..., 0] += 0
        image[..., 1] += 5
        image[..., 2] += 10

        # compute expected output
        image_hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)
        image_hsv = image_hsv.astype(np.int16)  # simulate WithHueAndSaturation
        image_hsv[..., 0] = (
            (image_hsv[..., 0].astype(np.float32)/180)*255).astype(np.int16)
        image_hsv = image_hsv.astype(np.float32)  # simulate Multiply

        image_hsv[..., 0] *= 1.0  # changed over __mul
        image_hsv[..., 1] *= 1.5
        image_hsv = np.round(image_hsv).astype(np.int16)

        image_hsv[..., 0] = np.mod(image_hsv[..., 0], 255)
        image_hsv[..., 0] = (
            (image_hsv[..., 0].astype(np.float32)/255)*180).astype(np.int16)
        image_hsv[..., 1] = np.clip(image_hsv[..., 1], 0, 255)

        image_hsv = image_hsv.astype(np.uint8)
        image_expected = cv2.cvtColor(image_hsv, cv2.COLOR_HSV2RGB)
        assert not np.array_equal(image_expected, image)

        # augment and verify
        images_aug = aug.augment_images(np.stack([image, image], axis=0))
        assert ia.is_np_array(images_aug)
        for image_aug in images_aug:
            assert image_aug.shape == (1, 255, 3)
            diff = np.abs(image_aug.astype(np.int16) - image_expected)
            assert np.all(diff <= 1)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="608" endline="653" pcid="1060">
    def test_augment_images__mul_hue_and_mul_saturation(self):
        # this is almost identical to test_augment_images__mul
        # only
        #     aug = ...
        # and
        #     image_hsv[...] *= 1.2
        # have been changed

        aug = iaa.MultiplyHueAndSaturation(mul_hue=1.5,
                                           mul_saturation=1.6)  # changed

        # example image
        image = np.arange(0, 255).reshape((1, 255, 1)).astype(np.uint8)
        image = np.tile(image, (1, 1, 3))
        image[..., 0] += 0
        image[..., 1] += 5
        image[..., 2] += 10

        # compute expected output
        image_hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)
        image_hsv = image_hsv.astype(np.int16)  # simulate WithHueAndSaturation
        image_hsv[..., 0] = (
            (image_hsv[..., 0].astype(np.float32)/180)*255).astype(np.int16)
        image_hsv = image_hsv.astype(np.float32)  # simulate Multiply

        image_hsv[..., 0] *= 1.5
        image_hsv[..., 1] *= 1.6  # changed over __mul
        image_hsv = np.round(image_hsv).astype(np.int16)

        image_hsv[..., 0] = np.mod(image_hsv[..., 0], 255)
        image_hsv[..., 0] = (
            (image_hsv[..., 0].astype(np.float32)/255)*180).astype(np.int16)
        image_hsv[..., 1] = np.clip(image_hsv[..., 1], 0, 255)

        image_hsv = image_hsv.astype(np.uint8)
        image_expected = cv2.cvtColor(image_hsv, cv2.COLOR_HSV2RGB)
        assert not np.array_equal(image_expected, image)

        # augment and verify
        images_aug = aug.augment_images(np.stack([image, image], axis=0))
        assert ia.is_np_array(images_aug)
        for image_aug in images_aug:
            assert image_aug.shape == (1, 255, 3)
            diff = np.abs(image_aug.astype(np.int16) - image_expected)
            assert np.all(diff <= 1)

</source>
</class>

<class classid="39" nclones="4" nlines="12" similarity="91">
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="431" endline="443" pcid="1054">
    def test_returns_correct_objects__mul_hue(self):
        aug = iaa.MultiplyHueAndSaturation(mul_hue=(0.9, 1.1))
        assert isinstance(aug, iaa.WithHueAndSaturation)
        assert isinstance(aug.children, iaa.Sequential)
        assert len(aug.children) == 1
        assert isinstance(aug.children[0], iaa.WithChannels)
        assert aug.children[0].channels == [0]
        assert len(aug.children[0].children) == 1
        assert isinstance(aug.children[0].children[0], iaa.Multiply)
        assert isinstance(aug.children[0].children[0].mul, iap.Uniform)
        assert np.isclose(aug.children[0].children[0].mul.a.value, 0.9)
        assert np.isclose(aug.children[0].children[0].mul.b.value, 1.1)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="699" endline="715" pcid="1063">
    def test_returns_correct_class(self):
        # this test is practically identical to
        # TestMultiplyToHueAndSaturation
        #     .test_returns_correct_objects__mul_saturation
        aug = iaa.MultiplySaturation((0.9, 1.1))
        assert isinstance(aug, iaa.WithHueAndSaturation)
        assert isinstance(aug.children, iaa.Sequential)
        assert len(aug.children) == 1
        assert isinstance(aug.children[0], iaa.WithChannels)
        assert aug.children[0].channels == [1]
        assert len(aug.children[0].children) == 1
        assert isinstance(aug.children[0].children[0], iaa.Multiply)
        assert isinstance(aug.children[0].children[0].mul, iap.Uniform)
        assert np.isclose(aug.children[0].children[0].mul.a.value, 0.9)
        assert np.isclose(aug.children[0].children[0].mul.b.value, 1.1)


</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="682" endline="697" pcid="1062">
    def test_returns_correct_class(self):
        # this test is practically identical to
        # TestMultiplyToHueAndSaturation.test_returns_correct_objects__mul_hue
        aug = iaa.MultiplyHue((0.9, 1.1))
        assert isinstance(aug, iaa.WithHueAndSaturation)
        assert isinstance(aug.children, iaa.Sequential)
        assert len(aug.children) == 1
        assert isinstance(aug.children[0], iaa.WithChannels)
        assert aug.children[0].channels == [0]
        assert len(aug.children[0].children) == 1
        assert isinstance(aug.children[0].children[0], iaa.Multiply)
        assert isinstance(aug.children[0].children[0].mul, iap.Uniform)
        assert np.isclose(aug.children[0].children[0].mul.a.value, 0.9)
        assert np.isclose(aug.children[0].children[0].mul.b.value, 1.1)


</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="444" endline="456" pcid="1055">
    def test_returns_correct_objects__mul_saturation(self):
        aug = iaa.MultiplyHueAndSaturation(mul_saturation=(0.9, 1.1))
        assert isinstance(aug, iaa.WithHueAndSaturation)
        assert isinstance(aug.children, iaa.Sequential)
        assert len(aug.children) == 1
        assert isinstance(aug.children[0], iaa.WithChannels)
        assert aug.children[0].channels == [1]
        assert len(aug.children[0].children) == 1
        assert isinstance(aug.children[0].children[0], iaa.Multiply)
        assert isinstance(aug.children[0].children[0].mul, iap.Uniform)
        assert np.isclose(aug.children[0].children[0].mul.a.value, 0.9)
        assert np.isclose(aug.children[0].children[0].mul.b.value, 1.1)

</source>
</class>

<class classid="40" nclones="2" nlines="11" similarity="81">
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="885" endline="898" pcid="1075">
    def test_augment_images__different_hue_and_saturation__no_per_channel(self):
        base_img = self.create_base_image()

        class _DummyParam(iap.StochasticParameter):
            def _draw_samples(self, size, random_state):
                arr = np.float32([10, 20])
                return np.tile(arr[np.newaxis, :], (size[0], 1))

        aug = iaa.AddToHueAndSaturation(value=_DummyParam(), per_channel=False)
        img_expected = self._add_hue_saturation(base_img, value=10)
        img_observed = aug.augment_image(base_img)

        assert np.array_equal(img_observed, img_expected)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="899" endline="913" pcid="1077">
    def test_augment_images__different_hue_and_saturation__per_channel(self):
        base_img = self.create_base_image()

        class _DummyParam(iap.StochasticParameter):
            def _draw_samples(self, size, random_state):
                arr = np.float32([10, 20])
                return np.tile(arr[np.newaxis, :], (size[0], 1))

        aug = iaa.AddToHueAndSaturation(value=_DummyParam(), per_channel=True)
        img_expected = self._add_hue_saturation(
            base_img, value_hue=10, value_saturation=20)
        img_observed = aug.augment_image(base_img)

        assert np.array_equal(img_observed, img_expected)

</source>
</class>

<class classid="41" nclones="2" nlines="13" similarity="100">
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="985" endline="1003" pcid="1084">

    def test_augment_images__value_hue__multi_image_sampling(self):
        base_img = self.create_base_image()

        class _DummyParam(iap.StochasticParameter):
            def _draw_samples(self, size, random_state):
                return np.float32([10, 20, 30])

        aug = iaa.AddToHueAndSaturation(value_hue=_DummyParam())

        img_expected1 = self._add_hue_saturation(base_img, value_hue=10)
        img_expected2 = self._add_hue_saturation(base_img, value_hue=20)
        img_expected3 = self._add_hue_saturation(base_img, value_hue=30)

        img_observed1, img_observed2, img_observed3 = \
            aug.augment_images([base_img] * 3)

        assert np.array_equal(img_observed1, img_expected1)
        assert np.array_equal(img_observed2, img_expected2)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="1019" endline="1037" pcid="1087">
                assert np.array_equal(img_observed, img_expected)

    def test_augment_images__value_saturation__multi_image_sampling(self):
        base_img = self.create_base_image()

        class _DummyParam(iap.StochasticParameter):
            def _draw_samples(self, size, random_state):
                return np.float32([10, 20, 30])

        aug = iaa.AddToHueAndSaturation(value_saturation=_DummyParam())

        img_expected1 = self._add_hue_saturation(base_img, value_saturation=10)
        img_expected2 = self._add_hue_saturation(base_img, value_saturation=20)
        img_expected3 = self._add_hue_saturation(base_img, value_saturation=30)

        img_observed1, img_observed2, img_observed3 = \
            aug.augment_images([base_img] * 3)

        assert np.array_equal(img_observed1, img_expected1)
</source>
</class>

<class classid="42" nclones="2" nlines="16" similarity="87">
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="1196" endline="1213" pcid="1106">
        assert isinstance(aug.to_colorspace, list)
        assert aug.to_colorspace == [iaa.ChangeColorspace.RGB,
                                     iaa.ChangeColorspace.Lab]
        assert aug.max_size == 128
        assert aug.interpolation == "linear"

    def test___init___custom_parameters(self):
        aug = self.augmenter(
            n_colors=(5, 8),
            from_colorspace=iaa.ChangeColorspace.BGR,
            to_colorspace=[iaa.ChangeColorspace.HSV, iaa.ChangeColorspace.Lab],
            max_size=None,
            interpolation="cubic"
        )
        assert isinstance(aug.n_colors, iap.DiscreteUniform)
        assert aug.n_colors.a.value == 5
        assert aug.n_colors.b.value == 8
        assert aug.from_colorspace == iaa.ChangeColorspace.BGR
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="1603" endline="1620" pcid="1139">
        assert aug.n_colors.b.value == 16
        assert aug.from_colorspace == iaa.ChangeColorspace.RGB
        assert aug.to_colorspace is None
        assert aug.max_size is None
        assert aug.interpolation == "linear"

    def test___init___custom_parameters(self):
        aug = self.augmenter(
            n_colors=(5, 8),
            from_colorspace=iaa.ChangeColorspace.BGR,
            to_colorspace=[iaa.ChangeColorspace.HSV, iaa.ChangeColorspace.Lab],
            max_size=128,
            interpolation="cubic"
        )
        assert isinstance(aug.n_colors, iap.DiscreteUniform)
        assert aug.n_colors.a.value == 5
        assert aug.n_colors.b.value == 8
        assert aug.from_colorspace == iaa.ChangeColorspace.BGR
</source>
</class>

<class classid="43" nclones="2" nlines="11" similarity="81">
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="1243" endline="1257" pcid="1109">
        # call i, args, argument 1
        n_colors = [mock_quantize_func.call_args_list[i][0][1]
                    for i in sm.xrange(n_images)]
        assert all([2 <= n_colors_i <= 1000 for n_colors_i in n_colors])
        assert len(set(n_colors)) > 1

    def test_to_colorspace(self):
        image = np.arange(3*3*3, dtype=np.uint8).reshape((3, 3, 3))
        aug = self.augmenter(to_colorspace="HSV")
        mock_quantize_func = mock.MagicMock(
            return_value=np.zeros((4, 4, 3), dtype=np.uint8))

        fname = self.quantization_func_name
        with mock.patch(fname, mock_quantize_func):
            _ = aug.augment_image(image)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="1258" endline="1271" pcid="1110">

        # call 0, kwargs, argument 'to_colorspace'
        expected = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)
        assert np.array_equal(mock_quantize_func.call_args_list[0][0][0],
                              expected)

    def test_to_colorspace_is_none(self):
        image = np.arange(3*3*3, dtype=np.uint8).reshape((3, 3, 3))
        aug = self.augmenter(to_colorspace=None)
        mock_quantize_func = mock.MagicMock(
            return_value=np.zeros((4, 4, 3), dtype=np.uint8))

        fname = self.quantization_func_name
        with mock.patch(fname, mock_quantize_func):
</source>
</class>

<class classid="44" nclones="2" nlines="18" similarity="88">
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="1272" endline="1294" pcid="1111">
            _ = aug.augment_image(image)

        # call 0, kwargs, argument 'to_colorspace'
        assert np.array_equal(mock_quantize_func.call_args_list[0][0][0],
                              image)

    def test_from_colorspace(self):
        def _noop(img):
            return img

        aug = self.augmenter(from_colorspace="BGR")
        mock_change_colorspace = mock.MagicMock()
        mock_change_colorspace.return_value = mock_change_colorspace
        mock_change_colorspace.augment_image.side_effect = _noop
        mock_change_colorspace._draw_samples.return_value = (None, ["foo"])

        fname = "imgaug.augmenters.color.ChangeColorspace"
        with mock.patch(fname, mock_change_colorspace):
            _ = aug.augment_image(np.zeros((4, 4, 3), dtype=np.uint8))

        # call 0, kwargs, argument 'from_colorspace'
        assert (
            mock_change_colorspace.call_args_list[0][1]["from_colorspace"]
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="1690" endline="1717" pcid="1143">
            max_size=None)

        observed = aug(image=image)

        assert np.array_equal(observed, expected)

    def test_from_colorspace(self):
        def _noop(img):
            return img

        # Actual to_colorspace doesn't matter here as it is overwritten
        # via return_value. Important is just to set it to a non-None value
        # so that a colorspace conversion actually happens.
        aug = self.augmenter(from_colorspace="BGR",
                             to_colorspace="Lab")
        mock_change_colorspace = mock.MagicMock()
        mock_change_colorspace.return_value = mock_change_colorspace
        mock_change_colorspace.augment_image.side_effect = _noop
        mock_change_colorspace._draw_samples.return_value = (None, ["foo"])

        fname = "imgaug.augmenters.color.ChangeColorspace"
        with mock.patch(fname, mock_change_colorspace):
            _ = aug.augment_image(np.zeros((4, 4, 3), dtype=np.uint8))

        # call 0, kwargs, argument 'from_colorspace'
        assert (
            mock_change_colorspace.call_args_list[0][1]["from_colorspace"]
            == "BGR")
</source>
</class>

<class classid="45" nclones="2" nlines="21" similarity="86">
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="1307" endline="1334" pcid="1114">
        with mock.patch(fname, mock_imresize):
            image_aug = aug.augment_image(image)
            assert image_aug.shape == image.shape

        assert mock_imresize.call_count == 0

    def test_max_size_is_int_and_resize_necessary(self):
        image = np.zeros((200, 100, 3), dtype=np.uint8)
        aug = self.augmenter(max_size=100)

        class _ImresizeSideEffect(object):
            def __init__(self):
                self.nth_call = 0

            def __call__(self, *_args, **_kwargs):
                if self.nth_call == 0:
                    self.nth_call += 1
                    return np.zeros((100, 50, 3), dtype=np.uint8)
                else:
                    return np.zeros((200, 100, 3), dtype=np.uint8)

        mock_imresize = mock.Mock()
        mock_imresize.side_effect = _ImresizeSideEffect()

        fname = "imgaug.imresize_single_image"
        with mock.patch(fname, mock_imresize):
            _ = aug.augment_image(image)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="1347" endline="1381" pcid="1118">
        with mock.patch(fname, mock_imresize):
            image_aug = aug.augment_image(image)
            assert image_aug.shape == image.shape

        assert mock_imresize.call_count == 0

    def test_interpolation(self):
        image = np.zeros((200, 100, 3), dtype=np.uint8)
        aug = self.augmenter(max_size=100, interpolation="cubic")

        class _ImresizeSideEffect(object):
            def __init__(self):
                self.nth_call = 0

            def __call__(self, *_args, **_kwargs):
                if self.nth_call == 0:
                    self.nth_call += 1
                    return np.zeros((100, 50, 3), dtype=np.uint8)
                else:
                    return np.zeros((200, 100, 3), dtype=np.uint8)

        mock_imresize = mock.Mock()
        mock_imresize.side_effect = _ImresizeSideEffect()

        fname = "imgaug.imresize_single_image"
        with mock.patch(fname, mock_imresize):
            _ = aug.augment_image(image)

        assert mock_imresize.call_count == 2
        # downscaling
        # call 0, args, argument 1 (sizes)
        # call 0, kwargs, argument "interpolation"
        assert mock_imresize.call_args_list[0][0][1] == (100, 50)
        assert mock_imresize.call_args_list[0][1]["interpolation"] == "cubic"

</source>
</class>

<class classid="46" nclones="6" nlines="17" similarity="84">
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="1382" endline="1401" pcid="1121">
        # upscaling
        # call 1, args, argument 1 (sizes)
        # call 1, kwargs, argument "interpolation"
        assert mock_imresize.call_args_list[1][0][1] == image.shape[0:2]
        assert mock_imresize.call_args_list[1][1]["interpolation"] == "cubic"

    def test_images_with_1_channel_integrationtest(self):
        image = np.uint8([
            [0, 0, 255, 255],
            [0, 1, 255, 255],
        ])
        expected = np.uint8([
            [0, 0, 255, 255],
            [0, 0, 255, 255],
        ])

        aug = self.augmenter(
            n_colors=2,
            from_colorspace="RGB",
            to_colorspace="RGB",
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="1664" endline="1689" pcid="1142">
            max_size=None)

        observed = aug(image=image)

        assert np.array_equal(observed, expected)

    def test_images_with_4_channels_integrationtest(self):
        image = np.uint8([
            [0, 0, 255, 255],
            [0, 1, 255, 255],
        ])
        expected = np.uint8([
            [64, 64, 192, 192],
            [64, 64, 192, 192],
        ])

        image = np.tile(image[..., np.newaxis], (1, 1, 4))
        expected = np.tile(expected[..., np.newaxis], (1, 1, 3))

        # alpha channel is expected to not be altered by quantization
        expected = np.concatenate([expected, image[:, :, 3:4]], axis=-1)

        aug = self.augmenter(
            n_colors=2,
            from_colorspace="RGB",
            to_colorspace="RGB",
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="1425" endline="1450" pcid="1123">
            max_size=None)

        observed = aug(image=image)

        assert np.array_equal(observed, expected)

    def test_images_with_4_channels_integrationtest(self):
        image = np.uint8([
            [0, 0, 255, 255],
            [0, 1, 255, 255],
        ])
        expected = np.uint8([
            [0, 0, 255, 255],
            [0, 0, 255, 255],
        ])

        image = np.tile(image[..., np.newaxis], (1, 1, 4))
        expected = np.tile(expected[..., np.newaxis], (1, 1, 3))

        # alpha channel is expected to not be altered by quantization
        expected = np.concatenate([expected, image[:, :, 3:4]], axis=-1)

        aug = self.augmenter(
            n_colors=2,
            from_colorspace="RGB",
            to_colorspace="RGB",
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="1621" endline="1640" pcid="1140">
        assert isinstance(aug.to_colorspace, list)
        assert aug.to_colorspace == [iaa.ChangeColorspace.HSV,
                                     iaa.ChangeColorspace.Lab]
        assert aug.max_size == 128
        assert aug.interpolation == "cubic"

    def test_images_with_1_channel_integrationtest(self):
        image = np.uint8([
            [0, 0, 255, 255],
            [0, 1, 255, 255],
        ])
        expected = np.uint8([
            [64, 64, 192, 192],
            [64, 64, 192, 192],
        ])

        aug = self.augmenter(
            n_colors=2,
            from_colorspace="RGB",
            to_colorspace="RGB",
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="1402" endline="1424" pcid="1122">
            max_size=None)

        observed = aug(image=image)

        assert np.array_equal(observed, expected)

    def test_images_with_3_channels_integrationtest(self):
        image = np.uint8([
            [0, 0, 255, 255],
            [0, 1, 255, 255],
        ])
        expected = np.uint8([
            [0, 0, 255, 255],
            [0, 0, 255, 255],
        ])

        image = np.tile(image[..., np.newaxis], (1, 1, 3))
        expected = np.tile(expected[..., np.newaxis], (1, 1, 3))

        aug = self.augmenter(
            n_colors=2,
            from_colorspace="RGB",
            to_colorspace="RGB",
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="1641" endline="1663" pcid="1141">
            max_size=None)

        observed = aug(image=image)

        assert np.array_equal(observed, expected)

    def test_images_with_3_channels_integrationtest(self):
        image = np.uint8([
            [0, 0, 255, 255],
            [0, 1, 255, 255],
        ])
        expected = np.uint8([
            [64, 64, 192, 192],
            [64, 64, 192, 192],
        ])

        image = np.tile(image[..., np.newaxis], (1, 1, 3))
        expected = np.tile(expected[..., np.newaxis], (1, 1, 3))

        aug = self.augmenter(
            n_colors=2,
            from_colorspace="RGB",
            to_colorspace="RGB",
</source>
</class>

<class classid="47" nclones="2" nlines="14" similarity="100">
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="1476" endline="1493" pcid="1126">

class Test_quantize_colors_kmeans(unittest.TestCase):
    def setUp(self):
        reseed()

    @classmethod
    def _test_images_with_n_channels(cls, nb_channels):
        image = np.uint8([
            [0, 0, 255, 255],
            [0, 1, 255, 255],
        ])
        expected = np.uint8([
            [0, 0, 255, 255],
            [0, 0, 255, 255],
        ])

        if nb_channels is not None:
            image = np.tile(image[..., np.newaxis], (1, 1, nb_channels))
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="1723" endline="1740" pcid="1146">

class Test_quantize_colors_uniform(unittest.TestCase):
    def setUp(self):
        reseed()

    @classmethod
    def _test_images_with_n_channels_2_colors(cls, nb_channels):
        image = np.uint8([
            [0, 0, 255, 255],
            [0, 1, 255, 255],
        ])
        expected = np.uint8([
            [64, 64, 192, 192],
            [64, 64, 192, 192],
        ])

        if nb_channels is not None:
            image = np.tile(image[..., np.newaxis], (1, 1, nb_channels))
</source>
</class>

<class classid="48" nclones="2" nlines="12" similarity="100">
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="1514" endline="1527" pcid="1131">
        expected = np.copy(image)

        observed = iaa.quantize_colors_kmeans(image, 100)

        assert np.array_equal(observed, expected)

    def test_failure_if_n_colors_less_than_2(self):
        image = np.uint8([
            [0, 0, 255, 255],
            [0, 1, 255, 255],
        ])

        got_exception = False
        try:
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_color.py" startline="1792" endline="1805" pcid="1154">
    def test_images_with_1_channel_4_colors(self):
        self._test_images_with_n_channels_4_colors(1)

    def test_images_with_3_channels_4_colors(self):
        self._test_images_with_n_channels_4_colors(3)

    def test_failure_if_n_colors_less_than_2(self):
        image = np.uint8([
            [0, 0, 255, 255],
            [0, 1, 255, 255],
        ])

        got_exception = False
        try:
</source>
</class>

<class classid="49" nclones="2" nlines="14" similarity="85">
<source file="systems/imgaug-0.3.0/test/augmenters/test_weather.py" startline="57" endline="71" pcid="1161">
    def test_basic_functionality(self):
        # basic functionality test
        aug = iaa.FastSnowyLandscape(
            lightness_threshold=100,
            lightness_multiplier=2.0)
        image = np.arange(0, 6*6*3).reshape((6, 6, 3)).astype(np.uint8)
        image_hls = cv2.cvtColor(image, cv2.COLOR_RGB2HLS)
        mask = (image_hls[..., 1] < 100)
        expected = np.copy(image_hls).astype(np.float32)
        expected[..., 1][mask] *= 2.0
        expected = np.clip(np.round(expected), 0, 255).astype(np.uint8)
        expected = cv2.cvtColor(expected, cv2.COLOR_HLS2RGB)
        observed = aug.augment_image(image)
        assert np.array_equal(observed, expected)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_weather.py" startline="128" endline="143" pcid="1164">
    def test_from_colorspace(self):
        # test BGR colorspace
        aug = iaa.FastSnowyLandscape(
            lightness_threshold=100,
            lightness_multiplier=2.0,
            from_colorspace="BGR")
        image = np.arange(0, 6*6*3).reshape((6, 6, 3)).astype(np.uint8)
        image_hls = cv2.cvtColor(image, cv2.COLOR_BGR2HLS)
        mask = (image_hls[..., 1] < 100)
        expected = np.copy(image_hls).astype(np.float32)
        expected[..., 1][mask] *= 2.0
        expected = np.clip(np.round(expected), 0, 255).astype(np.uint8)
        expected = cv2.cvtColor(expected, cv2.COLOR_HLS2BGR)
        observed = aug.augment_image(image)
        assert np.array_equal(observed, expected)

</source>
</class>

<class classid="50" nclones="2" nlines="21" similarity="90">
<source file="systems/imgaug-0.3.0/test/augmenters/test_weather.py" startline="72" endline="99" pcid="1162">
    def test_vary_lightness_threshold(self):
        # test when varying lightness_threshold between images
        image = np.arange(0, 6*6*3).reshape((6, 6, 3)).astype(np.uint8)
        image_hls = cv2.cvtColor(image, cv2.COLOR_RGB2HLS)

        aug = iaa.FastSnowyLandscape(
            lightness_threshold=_TwoValueParam(75, 125),
            lightness_multiplier=2.0)

        mask = (image_hls[..., 1] < 75)
        expected1 = np.copy(image_hls).astype(np.float64)
        expected1[..., 1][mask] *= 2.0
        expected1 = np.clip(np.round(expected1), 0, 255).astype(np.uint8)
        expected1 = cv2.cvtColor(expected1, cv2.COLOR_HLS2RGB)

        mask = (image_hls[..., 1] < 125)
        expected2 = np.copy(image_hls).astype(np.float64)
        expected2[..., 1][mask] *= 2.0
        expected2 = np.clip(np.round(expected2), 0, 255).astype(np.uint8)
        expected2 = cv2.cvtColor(expected2, cv2.COLOR_HLS2RGB)

        observed = aug.augment_images([image] * 4)

        assert np.array_equal(observed[0], expected1)
        assert np.array_equal(observed[1], expected2)
        assert np.array_equal(observed[2], expected1)
        assert np.array_equal(observed[3], expected2)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_weather.py" startline="100" endline="127" pcid="1163">
    def test_vary_lightness_multiplier(self):
        # test when varying lightness_multiplier between images
        image = np.arange(0, 6*6*3).reshape((6, 6, 3)).astype(np.uint8)
        image_hls = cv2.cvtColor(image, cv2.COLOR_RGB2HLS)

        aug = iaa.FastSnowyLandscape(
            lightness_threshold=100,
            lightness_multiplier=_TwoValueParam(1.5, 2.0))

        mask = (image_hls[..., 1] < 100)
        expected1 = np.copy(image_hls).astype(np.float64)
        expected1[..., 1][mask] *= 1.5
        expected1 = np.clip(np.round(expected1), 0, 255).astype(np.uint8)
        expected1 = cv2.cvtColor(expected1, cv2.COLOR_HLS2RGB)

        mask = (image_hls[..., 1] < 100)
        expected2 = np.copy(image_hls).astype(np.float64)
        expected2[..., 1][mask] *= 2.0
        expected2 = np.clip(np.round(expected2), 0, 255).astype(np.uint8)
        expected2 = cv2.cvtColor(expected2, cv2.COLOR_HLS2RGB)

        observed = aug.augment_images([image] * 4)

        assert np.array_equal(observed[0], expected1)
        assert np.array_equal(observed[1], expected2)
        assert np.array_equal(observed[2], expected1)
        assert np.array_equal(observed[3], expected2)

</source>
</class>

<class classid="51" nclones="2" nlines="14" similarity="100">
<source file="systems/imgaug-0.3.0/test/augmenters/test_weather.py" startline="171" endline="187" pcid="1167">
    def _test_very_roughly(cls, nb_channels):
        if nb_channels is None:
            img = np.zeros((100, 100), dtype=np.uint8)
        else:
            img = np.zeros((100, 100, nb_channels), dtype=np.uint8)
        imgs_aug = iaa.Clouds().augment_images([img] * 5)
        assert 20 < np.average(imgs_aug) < 250
        assert np.max(imgs_aug) > 150

        for img_aug in imgs_aug:
            img_aug_f32 = img_aug.astype(np.float32)
            grad_x = img_aug_f32[:, 1:] - img_aug_f32[:, :-1]
            grad_y = img_aug_f32[1:, :] - img_aug_f32[:-1, :]

            assert np.sum(np.abs(grad_x)) > 5 * img.shape[1]
            assert np.sum(np.abs(grad_y)) > 5 * img.shape[0]

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_weather.py" startline="246" endline="262" pcid="1174">
    def _test_very_roughly(cls, nb_channels):
        if nb_channels is None:
            img = np.zeros((100, 100), dtype=np.uint8)
        else:
            img = np.zeros((100, 100, nb_channels), dtype=np.uint8)
        imgs_aug = iaa.Clouds().augment_images([img] * 5)
        assert 50 < np.average(imgs_aug) < 255
        assert np.max(imgs_aug) > 100

        for img_aug in imgs_aug:
            img_aug_f32 = img_aug.astype(np.float32)
            grad_x = img_aug_f32[:, 1:] - img_aug_f32[:, :-1]
            grad_y = img_aug_f32[1:, :] - img_aug_f32[:-1, :]

            assert np.sum(np.abs(grad_x)) > 1 * img.shape[1]
            assert np.sum(np.abs(grad_y)) > 1 * img.shape[0]

</source>
</class>

<class classid="52" nclones="4" nlines="10" similarity="70">
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="407" endline="419" pcid="1233">
    def test_image_scale_zoom_in_only_x_axis__deterministic(self):
        aug = iaa.Affine(scale={"x": 1.75, "y": 1.0},
                         translate_px=0, rotate=0, shear=0)
        aug_det = aug.to_deterministic()

        observed = aug_det.augment_images(self.images)

        assert observed[0][1, 1] > 250
        assert (observed[0][[1, 1], [0, 2]] > 20).all()
        assert (observed[0][[1, 1], [0, 2]] < 150).all()
        assert (observed[0][0, :] < 5).all()
        assert (observed[0][2, :] < 5).all()

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="512" endline="524" pcid="1241">
    def test_image_scale_zoom_in_only_y_axis__deterministic_and_list(self):
        aug = iaa.Affine(scale={"x": 1.0, "y": 1.75},
                         translate_px=0, rotate=0, shear=0)
        aug_det = aug.to_deterministic()

        observed = aug_det.augment_images([self.base_img])

        assert observed[0][1, 1] > 250
        assert (observed[0][[0, 2], [1, 1]] > 20).all()
        assert (observed[0][[0, 2], [1, 1]] < 150).all()
        assert (observed[0][:, 0] < 5).all()
        assert (observed[0][:, 2] < 5).all()

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="432" endline="444" pcid="1235">
    def test_image_scale_zoom_in_only_x_axis__deterministic_and_list(self):
        aug = iaa.Affine(scale={"x": 1.75, "y": 1.0},
                         translate_px=0, rotate=0, shear=0)
        aug_det = aug.to_deterministic()

        observed = aug_det.augment_images([self.base_img])

        assert observed[0][1, 1] > 250
        assert (observed[0][[1, 1], [0, 2]] > 20).all()
        assert (observed[0][[1, 1], [0, 2]] < 150).all()
        assert (observed[0][0, :] < 5).all()
        assert (observed[0][2, :] < 5).all()

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="487" endline="499" pcid="1239">
    def test_image_scale_zoom_in_only_y_axis__deterministic(self):
        aug = iaa.Affine(scale={"x": 1.0, "y": 1.75},
                         translate_px=0, rotate=0, shear=0)
        aug_det = aug.to_deterministic()

        observed = aug_det.augment_images(self.images)

        assert observed[0][1, 1] > 250
        assert (observed[0][[0, 2], [1, 1]] > 20).all()
        assert (observed[0][[0, 2], [1, 1]] < 150).all()
        assert (observed[0][:, 0] < 5).all()
        assert (observed[0][:, 2] < 5).all()

</source>
</class>

<class classid="53" nclones="4" nlines="10" similarity="81">
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="445" endline="457" pcid="1236">
    def test_keypoints_scale_zoom_in_only_x_axis(self):
        aug = iaa.Affine(scale={"x": 1.75, "y": 1.0},
                         translate_px=0, rotate=0, shear=0)

        observed = aug.augment_keypoints(self.kpsoi)

        assert observed[0].keypoints[0].x < 0
        assert observed[0].keypoints[0].y == 0
        assert observed[0].keypoints[1].x == 1
        assert observed[0].keypoints[1].y == 1
        assert observed[0].keypoints[2].x > 2
        assert observed[0].keypoints[2].y == 2

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="538" endline="552" pcid="1243">
    def test_keypoints_scale_zoom_in_only_y_axis__deterministic(self):
        aug = iaa.Affine(scale={"x": 1.0, "y": 1.75},
                         translate_px=0, rotate=0, shear=0)
        aug_det = aug.to_deterministic()

        observed = aug_det.augment_keypoints(self.kpsoi)

        assert observed[0].keypoints[0].x == 0
        assert observed[0].keypoints[0].y < 0
        assert observed[0].keypoints[1].x == 1
        assert observed[0].keypoints[1].y == 1
        assert observed[0].keypoints[2].x == 2
        assert observed[0].keypoints[2].y > 2

    # ---------------------
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="525" endline="537" pcid="1242">
    def test_keypoints_scale_zoom_in_only_y_axis(self):
        aug = iaa.Affine(scale={"x": 1.0, "y": 1.75},
                         translate_px=0, rotate=0, shear=0)

        observed = aug.augment_keypoints(self.kpsoi)

        assert observed[0].keypoints[0].x == 0
        assert observed[0].keypoints[0].y < 0
        assert observed[0].keypoints[1].x == 1
        assert observed[0].keypoints[1].y == 1
        assert observed[0].keypoints[2].x == 2
        assert observed[0].keypoints[2].y > 2

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="458" endline="472" pcid="1237">
    def test_keypoints_scale_zoom_in_only_x_axis__deterministic(self):
        aug = iaa.Affine(scale={"x": 1.75, "y": 1.0},
                         translate_px=0, rotate=0, shear=0)
        aug_det = aug.to_deterministic()

        observed = aug_det.augment_keypoints(self.kpsoi)

        assert observed[0].keypoints[0].x < 0
        assert observed[0].keypoints[0].y == 0
        assert observed[0].keypoints[1].x == 1
        assert observed[0].keypoints[1].y == 1
        assert observed[0].keypoints[2].x > 2
        assert observed[0].keypoints[2].y == 2

    # ---------------------
</source>
</class>

<class classid="54" nclones="2" nlines="23" similarity="91">
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="659" endline="683" pcid="1256">
    def test_image_x_and_y_axis_are_tuples(self):
        aug = iaa.Affine(scale={"x": (0.5, 1.5), "y": (0.5, 1.5)},
                         translate_px=0, rotate=0, shear=0)

        image = np.array([[0, 0, 0, 0, 0],
                          [0, 1, 1, 1, 0],
                          [0, 1, 2, 1, 0],
                          [0, 1, 1, 1, 0],
                          [0, 0, 0, 0, 0]], dtype=np.uint8) * 100
        image = image[:, :, np.newaxis]
        images = np.array([image])

        last_aug = None
        nb_changed_aug = 0
        nb_iterations = 1000
        for i in sm.xrange(nb_iterations):
            observed_aug = aug.augment_images(images)
            if i == 0:
                last_aug = observed_aug
            else:
                if not np.array_equal(observed_aug, last_aug):
                    nb_changed_aug += 1
                last_aug = observed_aug
        assert nb_changed_aug >= int(nb_iterations * 0.8)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="684" endline="710" pcid="1257">
    def test_image_x_and_y_axis_are_tuples__deterministic(self):
        aug = iaa.Affine(scale={"x": (0.5, 1.5), "y": (0.5, 1.5)},
                         translate_px=0, rotate=0, shear=0)
        aug_det = aug.to_deterministic()

        image = np.array([[0, 0, 0, 0, 0],
                          [0, 1, 1, 1, 0],
                          [0, 1, 2, 1, 0],
                          [0, 1, 1, 1, 0],
                          [0, 0, 0, 0, 0]], dtype=np.uint8) * 100
        image = image[:, :, np.newaxis]
        images = np.array([image])

        last_aug_det = None
        nb_changed_aug_det = 0
        nb_iterations = 10
        for i in sm.xrange(nb_iterations):
            observed_aug_det = aug_det.augment_images(images)
            if i == 0:
                last_aug_det = observed_aug_det
            else:
                if not np.array_equal(observed_aug_det, last_aug_det):
                    nb_changed_aug_det += 1
                last_aug_det = observed_aug_det
        assert nb_changed_aug_det == 0

    # ------------
</source>
</class>

<class classid="55" nclones="6" nlines="19" similarity="70">
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="1062" endline="1085" pcid="1298">
    def test_image_translate_by_axiswise_uniform_distributions(self):
        # 0-1px to left/right and 0-1px to top/bottom
        aug = iaa.Affine(scale=1.0, translate_px={"x": (-1, 1), "y": (-1, 1)},
                         rotate=0, shear=0)
        last_aug = None
        nb_changed_aug = 0
        nb_iterations = 1000
        centers_aug = self.image.astype(np.int32) * 0
        for i in sm.xrange(nb_iterations):
            observed_aug = aug.augment_images(self.images)
            if i == 0:
                last_aug = observed_aug
            else:
                if not np.array_equal(observed_aug, last_aug):
                    nb_changed_aug += 1
                last_aug = observed_aug

            assert len(observed_aug[0].nonzero()[0]) == 1
            centers_aug += (observed_aug[0] > 0)

        assert nb_changed_aug >= int(nb_iterations * 0.7)
        assert (centers_aug > int(nb_iterations * (1/9 * 0.6))).all()
        assert (centers_aug < int(nb_iterations * (1/9 * 1.4))).all()

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="1086" endline="1109" pcid="1299">
    def test_image_translate_by_axiswise_uniform_distributions__det(self):
        # 0-1px to left/right and 0-1px to top/bottom
        aug = iaa.Affine(scale=1.0, translate_px={"x": (-1, 1), "y": (-1, 1)},
                         rotate=0, shear=0)
        aug_det = aug.to_deterministic()
        last_aug_det = None
        nb_changed_aug_det = 0
        nb_iterations = 10
        centers_aug_det = self.image.astype(np.int32) * 0
        for i in sm.xrange(nb_iterations):
            observed_aug_det = aug_det.augment_images(self.images)
            if i == 0:
                last_aug_det = observed_aug_det
            else:
                if not np.array_equal(observed_aug_det, last_aug_det):
                    nb_changed_aug_det += 1
                last_aug_det = observed_aug_det

            assert len(observed_aug_det[0].nonzero()[0]) == 1
            centers_aug_det += (observed_aug_det[0] > 0)

        assert nb_changed_aug_det == 0

    # ---------------------
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="1350" endline="1372" pcid="1324">
    def test_image_rotate_is_tuple_0_to_364_deg__deterministic(self):
        aug = iaa.Affine(scale=1.0, translate_px=0, rotate=(0, 364), shear=0)
        aug_det = aug.to_deterministic()
        last_aug_det = None
        nb_changed_aug_det = 0
        nb_iterations = 10
        pixels_sums_aug_det = self.image.astype(np.int32) * 0
        for i in sm.xrange(nb_iterations):
            observed_aug_det = aug_det.augment_images(self.images)
            if i == 0:
                last_aug_det = observed_aug_det
            else:
                if not np.array_equal(observed_aug_det, last_aug_det):
                    nb_changed_aug_det += 1
                last_aug_det = observed_aug_det

            pixels_sums_aug_det += (observed_aug_det[0] > 100)

        assert nb_changed_aug_det == 0
        # center pixel, should always be white when rotating line around center
        assert pixels_sums_aug_det[1, 1] > (nb_iterations * 0.98)
        assert pixels_sums_aug_det[1, 1] < (nb_iterations * 1.02)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="1485" endline="1505" pcid="1334">
    def test_image_cval_is_tuple__deterministic(self):
        # random cvals
        aug = iaa.Affine(scale=1.0, translate_px=100, rotate=0, shear=0,
                         cval=(0, 255))
        aug_det = aug.to_deterministic()
        last_aug_det = None
        nb_changed_aug_det = 0
        nb_iterations = 10
        for i in sm.xrange(nb_iterations):
            observed_aug_det = aug_det.augment_images(self.images)

            if i == 0:
                last_aug_det = observed_aug_det
            else:
                if not np.array_equal(observed_aug_det, last_aug_det):
                    nb_changed_aug_det += 1
                last_aug_det = observed_aug_det

        assert nb_changed_aug_det == 0


</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="1315" endline="1349" pcid="1323">
    def test_image_rotate_is_tuple_0_to_364_deg(self):
        # random rotation 0-364 degrees
        aug = iaa.Affine(scale=1.0, translate_px=0, rotate=(0, 364), shear=0)
        last_aug = None
        nb_changed_aug = 0
        nb_iterations = 1000
        pixels_sums_aug = self.image.astype(np.int32) * 0
        for i in sm.xrange(nb_iterations):
            observed_aug = aug.augment_images(self.images)
            if i == 0:
                last_aug = observed_aug
            else:
                if not np.array_equal(observed_aug, last_aug):
                    nb_changed_aug += 1
                last_aug = observed_aug

            pixels_sums_aug += (observed_aug[0] > 100)

        assert nb_changed_aug >= int(nb_iterations * 0.9)
        # center pixel, should always be white when rotating line around center
        assert pixels_sums_aug[1, 1] > (nb_iterations * 0.98)
        assert pixels_sums_aug[1, 1] < (nb_iterations * 1.02)

        # outer pixels, should sometimes be white
        # the values here had to be set quite tolerant, the middle pixels at
        # top/left/bottom/right get more activation than expected
        outer_pixels = ([0, 0, 0, 1, 1, 2, 2, 2],
                        [0, 1, 2, 0, 2, 0, 1, 2])
        assert (
            pixels_sums_aug[outer_pixels] > int(nb_iterations * (2/8 * 0.4))
        ).all()
        assert (
            pixels_sums_aug[outer_pixels] < int(nb_iterations * (2/8 * 2.0))
        ).all()

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="1466" endline="1484" pcid="1333">
    def test_image_cval_is_tuple(self):
        # random cvals
        aug = iaa.Affine(scale=1.0, translate_px=100, rotate=0, shear=0,
                         cval=(0, 255))
        last_aug = None
        nb_changed_aug = 0
        nb_iterations = 1000
        for i in sm.xrange(nb_iterations):
            observed_aug = aug.augment_images(self.images)

            if i == 0:
                last_aug = observed_aug
            else:
                if not np.array_equal(observed_aug, last_aug):
                    nb_changed_aug += 1
                last_aug = observed_aug

        assert nb_changed_aug >= int(nb_iterations * 0.9)

</source>
</class>

<class classid="56" nclones="5" nlines="16" similarity="70">
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="1565" endline="1581" pcid="1342">
    def test_image_rot45(self):
        for backend in ["auto", "cv2", "skimage"]:
            with self.subTest(backend=backend):
                aug = iaa.Affine(rotate=45, fit_output=True,
                                 backend=backend)
                img = np.zeros((10, 10), dtype=np.uint8)
                img[0:2, 0:2] = 255
                img[-2:, 0:2] = 255
                img[0:2, -2:] = 255
                img[-2:, -2:] = 255

                img_aug = aug.augment_image(img)

                _labels, nb_labels = skimage.morphology.label(
                    img_aug > 240, return_num=True, connectivity=2)
                assert nb_labels == 4

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="1686" endline="1710" pcid="1347">
    def test_segmaps_rot45(self):
        for backend in ["auto", "cv2", "skimage"]:
            with self.subTest(backend=backend):
                aug = iaa.Affine(rotate=45, fit_output=True,
                                 backend=backend)
                img = np.zeros((80, 80), dtype=np.uint8)
                img[0:5, 0:5] = 255
                img[-5:, 0:5] = 255
                img[0:5, -5:] = 255
                img[-5:, -5:] = 255
                segmap = SegmentationMapsOnImage(
                    (img > 100).astype(np.int32),
                    shape=(80, 80)
                )

                segmap_aug = aug.augment_segmentation_maps([segmap])[0]

                # these asserts are deactivated because the image size can
                # change under fit_output=True
                # assert segmap_aug.shape == (80, 80)
                # assert segmap_aug.arr_0to1.shape == (40, 40, 1)
                _labels, nb_labels = skimage.morphology.label(
                    segmap_aug.arr > 0, return_num=True, connectivity=2)
                assert nb_labels == 4

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="1582" endline="1600" pcid="1343">
    def test_heatmaps_rot45(self):
        for backend in ["auto", "cv2", "skimage"]:
            with self.subTest(backend=backend):
                aug = iaa.Affine(rotate=45, fit_output=True,
                                 backend=backend)
                img = np.zeros((10, 10), dtype=np.uint8)
                img[0:2, 0:2] = 255
                img[-2:, 0:2] = 255
                img[0:2, -2:] = 255
                img[-2:, -2:] = 255
                hm = ia.HeatmapsOnImage(img.astype(np.float32)/255,
                                        shape=(10, 10))

                hm_aug = aug.augment_heatmaps([hm])[0]

                _labels, nb_labels = skimage.morphology.label(
                    hm_aug.arr_0to1 > 240/255, return_num=True, connectivity=2)
                assert nb_labels == 4

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="1601" endline="1627" pcid="1344">
    def test_heatmaps_rot45__heatmaps_smaller_than_image(self):
        for backend in ["auto", "cv2", "skimage"]:
            with self.subTest(backend=backend):
                aug = iaa.Affine(rotate=45, fit_output=True,
                                 backend=backend)
                img = np.zeros((80, 80), dtype=np.uint8)
                img[0:5, 0:5] = 255
                img[-5:, 0:5] = 255
                img[0:5, -5:] = 255
                img[-5:, -5:] = 255
                hm = HeatmapsOnImage(
                    ia.imresize_single_image(
                        img, (40, 40), interpolation="cubic"
                    ).astype(np.float32)/255,
                    shape=(80, 80)
                )

                hm_aug = aug.augment_heatmaps([hm])[0]

                # these asserts are deactivated because the image size can
                # change under fit_output=True
                # assert hm_aug.shape == (80, 80)
                # assert hm_aug.arr_0to1.shape == (40, 40, 1)
                _labels, nb_labels = skimage.morphology.label(
                    hm_aug.arr_0to1 > 200/255, return_num=True, connectivity=2)
                assert nb_labels == 4

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="1711" endline="1739" pcid="1348">
    def test_segmaps_rot45__segmaps_smaller_than_img(self):
        for backend in ["auto", "cv2", "skimage"]:
            with self.subTest(backend=backend):
                aug = iaa.Affine(rotate=45, fit_output=True,
                                 backend=backend)
                img = np.zeros((80, 80), dtype=np.uint8)
                img[0:5, 0:5] = 255
                img[-5:, 0:5] = 255
                img[0:5, -5:] = 255
                img[-5:, -5:] = 255
                segmap = SegmentationMapsOnImage(
                    (
                        ia.imresize_single_image(
                            img, (40, 40), interpolation="cubic"
                        ) > 100
                     ).astype(np.int32),
                    shape=(80, 80)
                )

                segmap_aug = aug.augment_segmentation_maps([segmap])[0]

                # these asserts are deactivated because the image size can
                # change under fit_output=True
                # assert segmap_aug.shape == (80, 80)
                # assert segmap_aug.arr_0to1.shape == (40, 40, 1)
                _labels, nb_labels = skimage.morphology.label(
                    segmap_aug.arr > 0, return_num=True, connectivity=2)
                assert nb_labels == 4

</source>
</class>

<class classid="57" nclones="4" nlines="24" similarity="73">
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="1628" endline="1655" pcid="1345">
    def test_image_heatmap_alignment_random_rots(self):
        nb_iterations = 50
        for backend in ["auto", "cv2", "skimage"]:
            with self.subTest(backend=backend):
                for _ in sm.xrange(nb_iterations):
                    aug = iaa.Affine(rotate=(0, 364), fit_output=True,
                                     backend=backend)
                    img = np.zeros((80, 80), dtype=np.uint8)
                    img[0:5, 0:5] = 255
                    img[-5:, 0:5] = 255
                    img[0:5, -5:] = 255
                    img[-5:, -5:] = 255
                    hm = HeatmapsOnImage(
                        img.astype(np.float32)/255,
                        shape=(80, 80)
                    )

                    img_aug = aug.augment_image(img)
                    hm_aug = aug.augment_heatmaps([hm])[0]

                    img_aug_mask = img_aug > 255*0.1
                    hm_aug_mask = ia.imresize_single_image(
                        hm_aug.arr_0to1, img_aug.shape[0:2],
                        interpolation="cubic"
                    ) > 0.1
                    same = np.sum(img_aug_mask == hm_aug_mask[:, :, 0])
                    assert (same / img_aug_mask.size) >= 0.95

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="1769" endline="1801" pcid="1350">
    def test_image_segmap_alignment_random_rots__sms_smaller_than_img(self):
        nb_iterations = 50
        for backend in ["auto", "cv2", "skimage"]:
            with self.subTest(backend=backend):
                for _ in sm.xrange(nb_iterations):
                    aug = iaa.Affine(rotate=(0, 364), fit_output=True,
                                     backend=backend)
                    img = np.zeros((80, 80), dtype=np.uint8)
                    img[0:5, 0:5] = 255
                    img[-5:, 0:5] = 255
                    img[0:5, -5:] = 255
                    img[-5:, -5:] = 255
                    segmap = SegmentationMapsOnImage(
                        (
                            ia.imresize_single_image(
                                img, (40, 40), interpolation="cubic"
                            ) > 100
                         ).astype(np.int32),
                        shape=(80, 80)
                    )

                    img_aug = aug.augment_image(img)
                    segmap_aug = aug.augment_segmentation_maps([segmap])[0]

                    img_aug_mask = img_aug > 100
                    segmap_aug_mask = ia.imresize_single_image(
                        segmap_aug.arr,
                        img_aug.shape[0:2],
                        interpolation="nearest"
                    ) > 0
                    same = np.sum(img_aug_mask == segmap_aug_mask[:, :, 0])
                    assert (same / img_aug_mask.size) >= 0.95

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="1740" endline="1768" pcid="1349">
    def test_image_segmap_alignment_random_rots(self):
        nb_iterations = 50
        for backend in ["auto", "cv2", "skimage"]:
            with self.subTest(backend=backend):
                for _ in sm.xrange(nb_iterations):
                    aug = iaa.Affine(rotate=(0, 364), fit_output=True,
                                     backend=backend)
                    img = np.zeros((80, 80), dtype=np.uint8)
                    img[0:5, 0:5] = 255
                    img[-5:, 0:5] = 255
                    img[0:5, -5:] = 255
                    img[-5:, -5:] = 255
                    segmap = SegmentationMapsOnImage(
                        (img > 100).astype(np.int32),
                        shape=(80, 80)
                    )

                    img_aug = aug.augment_image(img)
                    segmap_aug = aug.augment_segmentation_maps([segmap])[0]

                    img_aug_mask = img_aug > 100
                    segmap_aug_mask = ia.imresize_single_image(
                        segmap_aug.arr,
                        img_aug.shape[0:2],
                        interpolation="nearest"
                    ) > 0
                    same = np.sum(img_aug_mask == segmap_aug_mask[:, :, 0])
                    assert (same / img_aug_mask.size) >= 0.95

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="1656" endline="1685" pcid="1346">
    def test_image_heatmap_alignment_random_rots__hms_smaller_than_img(self):
        nb_iterations = 50
        for backend in ["auto", "cv2", "skimage"]:
            with self.subTest(backend=backend):
                for _ in sm.xrange(nb_iterations):
                    aug = iaa.Affine(rotate=(0, 364), fit_output=True,
                                     backend=backend)
                    img = np.zeros((80, 80), dtype=np.uint8)
                    img[0:5, 0:5] = 255
                    img[-5:, 0:5] = 255
                    img[0:5, -5:] = 255
                    img[-5:, -5:] = 255
                    hm = HeatmapsOnImage(
                        ia.imresize_single_image(
                            img, (40, 40), interpolation="cubic"
                        ).astype(np.float32)/255,
                        shape=(80, 80)
                    )

                    img_aug = aug.augment_image(img)
                    hm_aug = aug.augment_heatmaps([hm])[0]

                    img_aug_mask = img_aug > 255*0.1
                    hm_aug_mask = ia.imresize_single_image(
                        hm_aug.arr_0to1, img_aug.shape[0:2],
                        interpolation="cubic"
                    ) > 0.1
                    same = np.sum(img_aug_mask == hm_aug_mask[:, :, 0])
                    assert (same / img_aug_mask.size) >= 0.95

</source>
</class>

<class classid="58" nclones="2" nlines="12" similarity="91">
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="1802" endline="1814" pcid="1351">
    def test_keypoints_rot90_without_fit_output(self):
        for backend in ["auto", "cv2", "skimage"]:
            with self.subTest(backend=backend):
                aug = iaa.Affine(rotate=90, backend=backend)
                kps = ia.KeypointsOnImage([ia.Keypoint(10, 10)],
                                          shape=(100, 200, 3))
                kps_aug = aug.augment_keypoints(kps)
                assert kps_aug.shape == (100, 200, 3)
                assert not np.allclose(
                    [kps_aug.keypoints[0].x, kps_aug.keypoints[0].y],
                    [kps.keypoints[0].x, kps.keypoints[0].y],
                    atol=1e-2, rtol=0)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="1815" endline="1829" pcid="1352">
    def test_keypoints_rot90(self):
        for backend in ["auto", "cv2", "skimage"]:
            with self.subTest(backend=backend):
                aug = iaa.Affine(rotate=90, fit_output=True, backend=backend)
                kps = ia.KeypointsOnImage([ia.Keypoint(10, 10)],
                                          shape=(100, 200, 3))

                kps_aug = aug.augment_keypoints(kps)

                assert kps_aug.shape == (200, 100, 3)
                assert not np.allclose(
                    [kps_aug.keypoints[0].x, kps_aug.keypoints[0].y],
                    [kps.keypoints[0].x, kps.keypoints[0].y],
                    atol=1e-2, rtol=0)

</source>
</class>

<class classid="59" nclones="2" nlines="14" similarity="71">
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="1841" endline="1858" pcid="1354">
    def test_polygons_rot90_without_fit_output(self):
        for backend in ["auto", "cv2", "skimage"]:
            with self.subTest(backend=backend):
                # verify that shape in PolygonsOnImages changes
                aug = iaa.Affine(rotate=90, backend=backend)
                psoi = ia.PolygonsOnImage([
                    ia.Polygon([(10, 10), (20, 10), (20, 20)])
                ], shape=(100, 200, 3))

                psoi_aug = aug.augment_polygons([psoi, psoi])

                assert len(psoi_aug) == 2
                for psoi_aug_i in psoi_aug:
                    assert psoi_aug_i.shape == (100, 200, 3)
                    assert not psoi_aug_i.polygons[0].exterior_almost_equals(
                        psoi.polygons[0].exterior, max_distance=1e-2)
                    assert psoi_aug_i.polygons[0].is_valid

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="1859" endline="1877" pcid="1355">
    def test_polygons_rot90(self):
        for backend in ["auto", "cv2", "skimage"]:
            with self.subTest(backend=backend):
                aug = iaa.Affine(rotate=90, fit_output=True, backend=backend)
                psoi = ia.PolygonsOnImage([
                    ia.Polygon([(10, 10), (20, 10), (20, 20)])
                ], shape=(100, 200, 3))

                psoi_aug = aug.augment_polygons([psoi, psoi])

                assert len(psoi_aug) == 2
                for psoi_aug_i in psoi_aug:
                    assert psoi_aug_i.shape == (200, 100, 3)
                    assert psoi_aug_i.polygons[0].exterior_almost_equals(
                        ia.Polygon([(100-10-1, 10), (100-10-1, 20),
                                    (100-20-1, 20)])
                    )
                    assert psoi_aug_i.polygons[0].is_valid

</source>
</class>

<class classid="60" nclones="2" nlines="39" similarity="74">
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="1894" endline="1935" pcid="1358">
    def test_image_keypoint_alignment(self):
        aug = iaa.Affine(rotate=[0, 180], order=0)
        img = np.zeros((10, 10), dtype=np.uint8)
        img[0:5, 5] = 255
        img[2, 4:6] = 255
        img_rot = [np.copy(img), np.copy(np.flipud(np.fliplr(img)))]
        kpsoi = ia.KeypointsOnImage([ia.Keypoint(x=5, y=2)], shape=img.shape)
        kpsoi_rot = [(5, 2), (5-1, 10-2-1)]
        img_aug_indices = []
        kpsois_aug_indices = []
        for _ in sm.xrange(40):
            aug_det = aug.to_deterministic()
            imgs_aug = aug_det.augment_images([img, img])
            kpsois_aug = aug_det.augment_keypoints([kpsoi, kpsoi])

            assert kpsois_aug[0].shape == img.shape
            assert kpsois_aug[1].shape == img.shape

            for img_aug in imgs_aug:
                if np.array_equal(img_aug, img_rot[0]):
                    img_aug_indices.append(0)
                elif np.array_equal(img_aug, img_rot[1]):
                    img_aug_indices.append(1)
                else:
                    assert False
            for kpsoi_aug in kpsois_aug:
                similar_to_rot_0 = np.allclose(
                    [kpsoi_aug.keypoints[0].x, kpsoi_aug.keypoints[0].y],
                    kpsoi_rot[0])
                similar_to_rot_180 = np.allclose(
                    [kpsoi_aug.keypoints[0].x, kpsoi_aug.keypoints[0].y],
                    kpsoi_rot[1])
                if similar_to_rot_0:
                    kpsois_aug_indices.append(0)
                elif similar_to_rot_180:
                    kpsois_aug_indices.append(1)
                else:
                    assert False
        assert np.array_equal(img_aug_indices, kpsois_aug_indices)
        assert len(set(img_aug_indices)) == 2
        assert len(set(kpsois_aug_indices)) == 2

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="1936" endline="1978" pcid="1359">
    def test_image_polygon_alignment(self):
        aug = iaa.Affine(rotate=[0, 180], order=0)
        img = np.zeros((10, 10), dtype=np.uint8)
        img[0:5, 5] = 255
        img[2, 4:6] = 255
        img_rot = [np.copy(img), np.copy(np.flipud(np.fliplr(img)))]
        psoi = ia.PolygonsOnImage([ia.Polygon([(1, 1), (9, 1), (5, 5)])],
                                  shape=img.shape)
        psoi_rot = [
            psoi.polygons[0].deepcopy(),
            ia.Polygon([(10-1-1, 10-1-1), (10-9-1, 10-1-1), (10-5-1, 10-5-1)])
        ]
        img_aug_indices = []
        psois_aug_indices = []
        for _ in sm.xrange(40):
            aug_det = aug.to_deterministic()
            imgs_aug = aug_det.augment_images([img, img])
            psois_aug = aug_det.augment_polygons([psoi, psoi])

            assert psois_aug[0].shape == img.shape
            assert psois_aug[1].shape == img.shape
            assert psois_aug[0].polygons[0].is_valid
            assert psois_aug[1].polygons[0].is_valid

            for img_aug in imgs_aug:
                if np.array_equal(img_aug, img_rot[0]):
                    img_aug_indices.append(0)
                elif np.array_equal(img_aug, img_rot[1]):
                    img_aug_indices.append(1)
                else:
                    assert False
            for psoi_aug in psois_aug:
                if psoi_aug.polygons[0].exterior_almost_equals(psoi_rot[0]):
                    psois_aug_indices.append(0)
                elif psoi_aug.polygons[0].exterior_almost_equals(psoi_rot[1]):
                    psois_aug_indices.append(1)
                else:
                    assert False
        assert np.array_equal(img_aug_indices, psois_aug_indices)
        assert len(set(img_aug_indices)) == 2
        assert len(set(psois_aug_indices)) == 2


</source>
</class>

<class classid="61" nclones="3" nlines="23" similarity="73">
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="2028" endline="2055" pcid="1369">
    def test_translate_skimage_order_0_uint_int(self):
        dtypes = ["uint8", "uint16", "uint32", "int8", "int16", "int32"]
        for dtype in dtypes:
            aug = iaa.Affine(translate_px={"x": 1}, order=0, mode="constant",
                             backend="skimage")

            min_value, center_value, max_value = \
                iadt.get_value_range_of_dtype(dtype)

            if np.dtype(dtype).kind == "i":
                values = [1, 5, 10, 100, int(0.1 * max_value),
                          int(0.2 * max_value), int(0.5 * max_value),
                          max_value - 100, max_value]
                values = values + [(-1) * value for value in values]
            else:
                values = [1, 5, 10, 100, int(center_value),
                          int(0.1 * max_value), int(0.2 * max_value),
                          int(0.5 * max_value), max_value - 100, max_value]

            for value in values:
                image = np.zeros((3, 3), dtype=dtype)
                image[1, 1] = value

                image_aug = aug.augment_image(image)

                assert image_aug.dtype.name == dtype
                assert np.all(image_aug[~self.translate_mask] == 0)
                assert np.all(image_aug[self.translate_mask] == value)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="2206" endline="2234" pcid="1379">
        assert image_aug.dtype.name == image.dtype.name
        assert np.all(image_aug[~self.translate_mask] == 0)
        assert np.all(image_aug[self.translate_mask] == 1)

    def test_translate_cv2_order_0_uint_int(self):
        aug = iaa.Affine(translate_px={"x": 1}, order=0, mode="constant",
                         backend="cv2")

        dtypes = ["uint8", "uint16", "int8", "int16", "int32"]
        for dtype in dtypes:
            min_value, center_value, max_value = \
                iadt.get_value_range_of_dtype(dtype)

            if np.dtype(dtype).kind == "i":
                values = [1, 5, 10, 100, int(0.1 * max_value),
                          int(0.2 * max_value), int(0.5 * max_value),
                          max_value - 100, max_value]
                values = values + [(-1) * value for value in values]
            else:
                values = [1, 5, 10, 100, int(center_value),
                          int(0.1 * max_value), int(0.2 * max_value),
                          int(0.5 * max_value), max_value - 100, max_value]

            for value in values:
                with self.subTest(dtype=dtype, value=value):
                    image = np.zeros((3, 3), dtype=dtype)
                    image[1, 1] = value

                    image_aug = aug.augment_image(image)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="4310" endline="4338" pcid="1464">
        image[self.other_dtypes_mask] = True

        image_aug = aug.augment_image(image)

        assert image_aug.dtype.name == image.dtype.name
        assert not np.all(image_aug == 1)
        assert np.any(image_aug[~self.other_dtypes_mask] == 1)

    def test_other_dtypes_uint_int(self):
        aug = iaa.PiecewiseAffine(scale=0.2, nb_rows=8, nb_cols=4, order=0,
                                  mode="constant")

        dtypes = ["uint8", "uint16", "uint32", "int8", "int16", "int32"]
        for dtype in dtypes:
            min_value, center_value, max_value = \
                iadt.get_value_range_of_dtype(dtype)

            if np.dtype(dtype).kind == "i":
                values = [1, 5, 10, 100, int(0.1 * max_value),
                          int(0.2 * max_value), int(0.5 * max_value),
                          max_value-100, max_value]
                values = values + [(-1)*value for value in values]
            else:
                values = [1, 5, 10, 100, int(center_value),
                          int(0.1 * max_value), int(0.2 * max_value),
                          int(0.5 * max_value), max_value-100, max_value]

            for value in values:
                with self.subTest(dtype=dtype, value=value):
</source>
</class>

<class classid="62" nclones="7" nlines="23" similarity="72">
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="2056" endline="2085" pcid="1370">

    def test_translate_skimage_order_0_float(self):
        # float
        dtypes = ["float16", "float32", "float64"]
        for dtype in dtypes:
            aug = iaa.Affine(translate_px={"x": 1}, order=0, mode="constant",
                             backend="skimage")

            min_value, center_value, max_value = \
                iadt.get_value_range_of_dtype(dtype)

            def _isclose(a, b):
                atol = 1e-4 if dtype == "float16" else 1e-8
                return np.isclose(a, b, atol=atol, rtol=0)

            isize = np.dtype(dtype).itemsize
            values = [0.01, 1.0, 10.0, 100.0, 500 ** (isize - 1),
                      1000 ** (isize - 1)]
            values = values + [(-1) * value for value in values]
            values = values + [min_value, max_value]
            for value in values:
                with self.subTest(dtype=dtype, value=value):
                    image = np.zeros((3, 3), dtype=dtype)
                    image[1, 1] = value

                    image_aug = aug.augment_image(image)

                    assert image_aug.dtype.name == dtype
                    assert np.all(_isclose(image_aug[~self.translate_mask], 0))
                    assert np.all(_isclose(image_aug[self.translate_mask],
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="2235" endline="2263" pcid="1380">

                    assert image_aug.dtype.name == dtype
                    assert np.all(image_aug[~self.translate_mask] == 0)
                    assert np.all(image_aug[self.translate_mask] == value)

    def test_translate_cv2_order_0_float(self):
        aug = iaa.Affine(translate_px={"x": 1}, order=0, mode="constant",
                         backend="cv2")

        dtypes = ["float16", "float32", "float64"]
        for dtype in dtypes:
            min_value, center_value, max_value = \
                iadt.get_value_range_of_dtype(dtype)

            def _isclose(a, b):
                atol = 1e-4 if dtype == "float16" else 1e-8
                return np.isclose(a, b, atol=atol, rtol=0)

            isize = np.dtype(dtype).itemsize
            values = [0.01, 1.0, 10.0, 100.0, 500 ** (isize - 1),
                      1000 ** (isize - 1)]
            values = values + [(-1) * value for value in values]
            values = values + [min_value, max_value]
            for value in values:
                with self.subTest(dtype=dtype, value=value):
                    image = np.zeros((3, 3), dtype=dtype)
                    image[1, 1] = value

                    image_aug = aug.augment_image(image)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="4339" endline="4371" pcid="1465">
                    image = np.zeros((21, 21), dtype=dtype)
                    image[:, 7:13] = value

                    image_aug = aug.augment_image(image)

                    assert image_aug.dtype.name == dtype
                    assert not np.all(image_aug == value)
                    assert np.any(image_aug[~self.other_dtypes_mask] == value)

    def test_other_dtypes_float(self):
        aug = iaa.PiecewiseAffine(scale=0.2, nb_rows=8, nb_cols=4, order=0,
                                  mode="constant")

        dtypes = ["float16", "float32", "float64"]
        for dtype in dtypes:
            min_value, center_value, max_value = \
                iadt.get_value_range_of_dtype(dtype)

            def _isclose(a, b):
                atol = 1e-4 if dtype == "float16" else 1e-8
                return np.isclose(a, b, atol=atol, rtol=0)

            isize = np.dtype(dtype).itemsize
            values = [0.01, 1.0, 10.0, 100.0, 500 ** (isize - 1),
                      1000 ** (isize - 1)]
            values = values + [(-1) * value for value in values]
            values = values + [min_value, max_value]
            for value in values:
                with self.subTest(dtype=dtype, value=value):
                    image = np.zeros((21, 21), dtype=dtype)
                    image[:, 7:13] = value

                    image_aug = aug.augment_image(image)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="3063" endline="3094" pcid="2542">
                    image[1, 1] = value

                    image_aug = aug.augment_image(image)

                    assert image_aug.dtype.name == dtype
                    assert image_aug.shape == (4, 3)
                    assert np.all(image_aug[~mask] == 0)
                    assert np.all(image_aug[mask] == value)

    def test_other_dtypes_float(self):
        aug = iaa.PadToFixedSize(height=4, width=3, position="center-top")
        dtypes = ["float16", "float32", "float64", "float128"]

        mask = np.zeros((4, 3), dtype=bool)
        mask[2, 1] = True

        for dtype in dtypes:
            min_value, center_value, max_value = \
                iadt.get_value_range_of_dtype(dtype)

            def _isclose(a, b):
                atol = 1e-4 if dtype == "float16" else 1e-8
                return np.isclose(a, b, atol=atol, rtol=0)

            isize = np.dtype(dtype).itemsize
            values = [0.01, 1.0, 10.0, 100.0, 500 ** (isize - 1),
                      1000 ** (isize - 1)]
            values = values + [(-1) * value for value in values]
            values = values + [min_value, max_value]
            for value in values:
                with self.subTest(dtype=dtype, value=value):
                    image = np.zeros((3, 3), dtype=dtype)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="3454" endline="3486" pcid="2571">
                with self.subTest(dtype=dtype, value=value):
                    image = np.zeros((3, 3), dtype=dtype)
                    image[1, 1] = value

                    image_aug = aug.augment_image(image)

                    assert image_aug.dtype.name == dtype
                    assert image_aug.shape == (2, 3)
                    assert np.all(image_aug[~mask] == 0)
                    assert np.all(image_aug[mask] == value)

    def test_other_dtypes_float(self):
        aug = iaa.CropToFixedSize(height=2, width=3, position="center-top")
        mask = np.zeros((2, 3), dtype=bool)
        mask[0, 1] = True

        dtypes = ["float16", "float32", "float64", "float128"]

        for dtype in dtypes:
            min_value, center_value, max_value = \
                iadt.get_value_range_of_dtype(dtype)

            def _isclose(a, b):
                atol = 1e-4 if dtype == "float16" else 1e-8
                return np.isclose(a, b, atol=atol, rtol=0)

            isize = np.dtype(dtype).itemsize
            values = [0.01, 1.0, 10.0, 100.0, 500 ** (isize - 1),
                      1000 ** (isize - 1)]
            values = values + [(-1) * value for value in values]
            values = values + [min_value, max_value]
            for value in values:
                with self.subTest(dtype=dtype, value=value):
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="2684" endline="2714" pcid="2516">
                    image[1, 1] = value
                    image_aug = aug.augment_image(image)
                    assert image_aug.dtype.name == dtype
                    assert image_aug.shape == (2, 3)
                    assert np.all(image_aug[~mask] == 0)
                    assert np.all(image_aug[mask] == value)

    def test_other_dtypes_float(self):
        aug = iaa.Crop(px=(1, 0, 0, 0), keep_size=False)
        mask = np.zeros((2, 3), dtype=bool)
        mask[0, 1] = True

        dtypes = ["float16", "float32", "float64", "float128"]

        for dtype in dtypes:
            with self.subTest(dtype=dtype):
                min_value, center_value, max_value = \
                    iadt.get_value_range_of_dtype(dtype)

                def _isclose(a, b):
                    atol = 1e-4 if dtype == np.float16 else 1e-8
                    return np.isclose(a, b, atol=atol, rtol=0)

                isize = np.dtype(dtype).itemsize
                values = [0.01, 1.0, 10.0, 100.0, 500 ** (isize - 1),
                          1000 ** (isize - 1)]
                values = values + [(-1) * value for value in values]
                values = values + [min_value, max_value]
                for value in values:
                    image = np.zeros((3, 3), dtype=dtype)
                    image[1, 1] = value
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="1835" endline="1866" pcid="2474">

    def test_pad_other_dtypes_float_by_int_without_keep_size(self):
        aug = iaa.Pad(px=(1, 0, 0, 0), keep_size=False)

        mask = np.zeros((4, 3), dtype=bool)
        mask[2, 1] = True

        dtypes = ["float16", "float32", "float64", "float128"]

        for dtype in dtypes:
            with self.subTest(dtype=dtype):
                min_value, center_value, max_value = \
                    iadt.get_value_range_of_dtype(dtype)

                def _isclose(a, b):
                    atol = 1e-4 if dtype == np.float16 else 1e-8
                    return np.isclose(a, b, atol=atol, rtol=0)

                isize = np.dtype(dtype).itemsize
                values = [0.01, 1.0, 10.0, 100.0, 500 ** (isize - 1),
                          1000 ** (isize - 1)]
                values = values + [(-1) * value for value in values]
                values = values + [min_value, max_value]
                for value in values:
                    image = np.zeros((3, 3), dtype=dtype)
                    image[1, 1] = value
                    image_aug = aug.augment_image(image)
                    assert image_aug.dtype == np.dtype(dtype)
                    assert image_aug.shape == (4, 3)
                    assert np.all(_isclose(image_aug[~mask], 0))
                    assert np.all(_isclose(image_aug[mask],
                                           np.float128(value)))
</source>
</class>

<class classid="63" nclones="2" nlines="12" similarity="75">
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="2086" endline="2103" pcid="1372">
                                           np.float128(value)))

    def test_rotate_skimage_order_not_0_bool(self):
        # skimage, order!=0 and rotate=180
        for order in [1, 3, 4, 5]:
            aug = iaa.Affine(rotate=180, order=order, mode="constant",
                             backend="skimage")
            aug_flip = iaa.Sequential([iaa.Flipud(1.0), iaa.Fliplr(1.0)])

            image = np.zeros((17, 17), dtype=bool)
            image[2:15, 5:13] = True

            image_aug = aug.augment_image(image)
            image_exp = aug_flip.augment_image(image)

            assert image_aug.dtype.name == image.dtype.name
            assert (
                np.sum(image_aug == image_exp)/image.size
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="2264" endline="2279" pcid="1382">

                    assert image_aug.dtype.name == dtype
                    assert np.all(_isclose(image_aug[~self.translate_mask], 0))
                    assert np.all(_isclose(image_aug[self.translate_mask],
                                           np.float128(value)))

    def test_rotate_cv2_order_1_and_3_bool(self):
        # cv2, order=1 and rotate=180
        for order in [1, 3]:
            aug = iaa.Affine(rotate=180, order=order, mode="constant",
                             backend="cv2")
            aug_flip = iaa.Sequential([iaa.Flipud(1.0), iaa.Fliplr(1.0)])

            image = np.zeros((17, 17), dtype=bool)
            image[2:15, 5:13] = True

</source>
</class>

<class classid="64" nclones="2" nlines="12" similarity="83">
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="3567" endline="3583" pcid="1421">
        except Exception as exc:
            assert "Expected " in str(exc)
            got_exception = True
        assert got_exception

    # -----
    # scale
    # -----
    def test_scale_is_small_image(self):
        # basic test
        aug = iaa.PiecewiseAffine(scale=0.01, nb_rows=12, nb_cols=4)

        observed = aug.augment_image(self.image)

        assert (
            100.0
            < np.average(observed[self.mask])
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="3584" endline="3600" pcid="1422">
            < np.average(self.image[self.mask])
        )
        assert (
            100.0-75.0
            > np.average(observed[~self.mask])
            > np.average(self.image[~self.mask])
        )

    def test_scale_is_small_image_absolute_scale(self):
        aug = iaa.PiecewiseAffine(scale=1, nb_rows=12, nb_cols=4,
                                  absolute_scale=True)

        observed = aug.augment_image(self.image)

        assert (
            100.0
            < np.average(observed[self.mask])
</source>
</class>

<class classid="65" nclones="3" nlines="14" similarity="71">
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="3740" endline="3758" pcid="1433">
        observed1 = aug1.augment_image(self.image)
        observed2 = aug2.augment_image(self.image)

        assert (
            np.average(observed1[~self.mask])
            < np.average(observed2[~self.mask])
        )

    def test_scale_stronger_values_should_increase_changes_heatmaps(self):
        # stronger scale should lead to stronger changes, heatmaps
        aug1 = iaa.PiecewiseAffine(scale=0.01, nb_rows=12, nb_cols=4)
        aug2 = iaa.PiecewiseAffine(scale=0.10, nb_rows=12, nb_cols=4)
        
        observed1 = aug1.augment_heatmaps([self.heatmaps])[0]
        observed2 = aug2.augment_heatmaps([self.heatmaps])[0]
        
        observed1_arr = observed1.get_arr()
        observed2_arr = observed2.get_arr()
        assert observed1.shape == self.heatmaps.shape
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="3759" endline="3778" pcid="1434">
        assert observed2.shape == self.heatmaps.shape
        _assert_same_min_max(observed1, self.heatmaps)
        _assert_same_min_max(observed2, self.heatmaps)
        assert (
            np.average(observed1_arr[~self.mask])
            < np.average(observed2_arr[~self.mask])
        )

    def test_scale_stronger_values_should_increase_changes_heatmaps_abs(self):
        aug1 = iaa.PiecewiseAffine(scale=1, nb_rows=12, nb_cols=4,
                                   absolute_scale=True)
        aug2 = iaa.PiecewiseAffine(scale=10, nb_rows=12, nb_cols=4,
                                   absolute_scale=True)

        observed1 = aug1.augment_heatmaps([self.heatmaps])[0]
        observed2 = aug2.augment_heatmaps([self.heatmaps])[0]

        observed1_arr = observed1.get_arr()
        observed2_arr = observed2.get_arr()
        assert observed1.shape == self.heatmaps.shape
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="3779" endline="3795" pcid="1435">
        assert observed2.shape == self.heatmaps.shape
        _assert_same_min_max(observed1, self.heatmaps)
        _assert_same_min_max(observed2, self.heatmaps)
        assert (
            np.average(observed1_arr[~self.mask])
            < np.average(observed2_arr[~self.mask])
        )

    def test_scale_stronger_values_should_increase_changes_segmaps(self):
        # stronger scale should lead to stronger changes, segmaps
        aug1 = iaa.PiecewiseAffine(scale=0.01, nb_rows=12, nb_cols=4)
        aug2 = iaa.PiecewiseAffine(scale=0.10, nb_rows=12, nb_cols=4)

        observed1 = aug1.augment_segmentation_maps([self.segmaps])[0]
        observed2 = aug2.augment_segmentation_maps([self.segmaps])[0]

        observed1_arr = observed1.get_arr()
</source>
</class>

<class classid="66" nclones="2" nlines="11" similarity="72">
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="3796" endline="3810" pcid="1436">
        observed2_arr = observed2.get_arr()
        assert observed1.shape == self.segmaps.shape
        assert observed2.shape == self.segmaps.shape
        assert (
            np.average(observed1_arr[~self.mask] == 0)
            > np.average(observed2_arr[~self.mask] == 0)
        )

    def test_scale_alignment_between_images_and_heatmaps(self):
        # strong scale, measure alignment between images and heatmaps
        aug = iaa.PiecewiseAffine(scale=0.10, nb_rows=12, nb_cols=4)
        aug_det = aug.to_deterministic()

        img_aug = aug_det.augment_image(self.image)
        hm_aug = aug_det.augment_heatmaps([self.heatmaps])[0]
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="3811" endline="3824" pcid="1437">

        img_aug_mask = img_aug > 255*0.1
        hm_aug_mask = hm_aug.arr_0to1 > 0.1
        same = np.sum(img_aug_mask == hm_aug_mask[:, :, 0])
        assert hm_aug.shape == (60, 80, 3)
        _assert_same_min_max(hm_aug, self.heatmaps)
        assert (same / img_aug_mask.size) >= 0.98

    def test_scale_alignment_between_images_and_segmaps(self):
        # strong scale, measure alignment between images and segmaps
        aug = iaa.PiecewiseAffine(scale=0.10, nb_rows=12, nb_cols=4)
        aug_det = aug.to_deterministic()

        img_aug = aug_det.augment_image(self.image)
</source>
</class>

<class classid="67" nclones="2" nlines="18" similarity="88">
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="3825" endline="3851" pcid="1438">
        segmap_aug = aug_det.augment_segmentation_maps([self.segmaps])[0]

        img_aug_mask = (img_aug > 255*0.1)
        segmap_aug_mask = (segmap_aug.arr == 1)
        same = np.sum(img_aug_mask == segmap_aug_mask[:, :, 0])
        assert segmap_aug.shape == (60, 80, 3)
        assert (same / img_aug_mask.size) >= 0.9

    def test_scale_alignment_between_images_and_smaller_heatmaps(self):
        # strong scale, measure alignment between images and heatmaps
        # heatmaps here smaller than image
        aug = iaa.PiecewiseAffine(scale=0.10, nb_rows=12, nb_cols=4)
        aug_det = aug.to_deterministic()

        heatmaps_small = ia.HeatmapsOnImage(
            (
                ia.imresize_single_image(
                    self.image, (30, 40+10), interpolation="cubic"
                ) / 255.0
            ).astype(np.float32),
            shape=(60, 80, 3)
        )

        img_aug = aug_det.augment_image(self.image)
        hm_aug = aug_det.augment_heatmaps([heatmaps_small])[0]

        img_aug_mask = img_aug > 255*0.1
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="3852" endline="3878" pcid="1439">
        hm_aug_mask = ia.imresize_single_image(
            hm_aug.arr_0to1, (60, 80), interpolation="cubic"
        ) > 0.1
        same = np.sum(img_aug_mask == hm_aug_mask[:, :, 0])
        assert hm_aug.shape == (60, 80, 3)
        assert hm_aug.arr_0to1.shape == (30, 40+10, 1)
        assert (same / img_aug_mask.size) >= 0.9  # seems to be 0.948 actually

    def test_scale_alignment_between_images_and_smaller_heatmaps_abs(self):
        # image is 60x80, so a scale of 8 is about 0.1*max(60,80)
        aug = iaa.PiecewiseAffine(scale=8, nb_rows=12, nb_cols=4,
                                  absolute_scale=True)
        aug_det = aug.to_deterministic()

        heatmaps_small = ia.HeatmapsOnImage(
            (
                ia.imresize_single_image(
                    self.image, (30, 40+10), interpolation="cubic"
                ) / 255.0
            ).astype(np.float32),
            shape=(60, 80, 3)
        )

        img_aug = aug_det.augment_image(self.image)
        hm_aug = aug_det.augment_heatmaps([heatmaps_small])[0]

        img_aug_mask = img_aug > 255*0.1
</source>
</class>

<class classid="68" nclones="2" nlines="25" similarity="92">
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="4486" endline="4517" pcid="1480">
        ])
        if observed.shape != expected.shape:
            observed = ia.imresize_single_image(
                observed, expected.shape[0:2], interpolation="cubic")
        # differences seem to mainly appear around the border of the inner
        # rectangle, possibly due to interpolation
        assert np.average(
            np.abs(observed.astype(np.int32) - expected.astype(np.int32))
        ) < 30.0

    def test_image_heatmaps_alignment_without_keep_size(self):
        aug = iaa.PerspectiveTransform(scale=0.2, keep_size=False)
        aug.jitter = iap.Deterministic(0.2)
        hm = HeatmapsOnImage(
            self.image.astype(np.float32)/255.0,
            shape=(30, 30)
        )

        observed = aug.augment_image(self.image)
        hm_aug = aug.augment_heatmaps([hm])[0]

        y1 = int(30*0.2)
        y2 = int(30*0.8)
        x1 = int(30*0.2)
        x2 = int(30*0.8)

        expected = (y2 - y1, x2 - x1)
        assert all([
            abs(s1-s2) <= 1
            for s1, s2
            in zip(hm_aug.shape, expected)
        ])
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="4518" endline="4549" pcid="1481">
        assert all([
            abs(s1-s2) <= 1
            for s1, s2
            in zip(hm_aug.arr_0to1.shape, expected + (1,))
        ])
        img_aug_mask = observed > 255*0.1
        hm_aug_mask = hm_aug.arr_0to1 > 0.1
        same = np.sum(img_aug_mask == hm_aug_mask[:, :, 0])
        assert (same / img_aug_mask.size) >= 0.99

    def test_image_segmaps_alignment_without_keep_size(self):
        aug = iaa.PerspectiveTransform(scale=0.2, keep_size=False)
        aug.jitter = iap.Deterministic(0.2)
        segmaps = SegmentationMapsOnImage(
            (self.image > 100).astype(np.int32),
            shape=(30, 30)
        )

        observed = aug.augment_image(self.image)
        segmaps_aug = aug.augment_segmentation_maps([segmaps])[0]

        y1 = int(30*0.2)
        y2 = int(30*0.8)
        x1 = int(30*0.2)
        x2 = int(30*0.8)

        expected = (y2 - y1, x2 - x1)
        assert all([
            abs(s1-s2) <= 1
            for s1, s2
            in zip(segmaps_aug.shape, expected)
        ])
</source>
</class>

<class classid="69" nclones="2" nlines="35" similarity="91">
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="4550" endline="4593" pcid="1482">
        assert all([
            abs(s1-s2) <= 1
            for s1, s2
            in zip(segmaps_aug.arr.shape, expected + (1,))
        ])
        img_aug_mask = observed > 255*0.5
        segmaps_aug_mask = segmaps_aug.arr > 0
        same = np.sum(img_aug_mask == segmaps_aug_mask[:, :, 0])
        assert (same / img_aug_mask.size) >= 0.99

    def test_heatmaps_smaller_than_image_without_keep_size(self):
        # without keep_size, different heatmap size
        aug = iaa.PerspectiveTransform(scale=0.2, keep_size=False)
        aug.jitter = iap.Deterministic(0.2)

        y1 = int(30*0.2)
        y2 = int(30*0.8)
        x1 = int(30*0.2)
        x2 = int(30*0.8)
        x1_small = int(25*0.2)
        x2_small = int(25*0.8)
        y1_small = int(20*0.2)
        y2_small = int(20*0.8)

        img_small = ia.imresize_single_image(
            self.image,
            (20, 25),
            interpolation="cubic")
        hm = ia.HeatmapsOnImage(
            img_small.astype(np.float32)/255.0,
            shape=(30, 30))

        img_aug = aug.augment_image(self.image)
        hm_aug = aug.augment_heatmaps([hm])[0]

        expected = (y2 - y1, x2 - x1)
        expected_small = (y2_small - y1_small, x2_small - x1_small, 1)
        assert all([
            abs(s1-s2) <= 1
            for s1, s2
            in zip(hm_aug.shape, expected)
        ])
        assert all([
            abs(s1-s2) <= 1
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="4594" endline="4636" pcid="1483">
            for s1, s2
            in zip(hm_aug.arr_0to1.shape, expected_small)
        ])
        img_aug_mask = img_aug > 255*0.1
        hm_aug_mask = ia.imresize_single_image(
            hm_aug.arr_0to1, img_aug.shape[0:2], interpolation="cubic"
        ) > 0.1
        same = np.sum(img_aug_mask == hm_aug_mask[:, :, 0])
        assert (same / img_aug_mask.size) >= 0.96

    def test_segmaps_smaller_than_image_without_keep_size(self):
        # without keep_size, different segmap size
        aug = iaa.PerspectiveTransform(scale=0.2, keep_size=False)
        aug.jitter = iap.Deterministic(0.2)

        y1 = int(30*0.2)
        y2 = int(30*0.8)
        x1 = int(30*0.2)
        x2 = int(30*0.8)
        x1_small = int(25*0.2)
        x2_small = int(25*0.8)
        y1_small = int(20*0.2)
        y2_small = int(20*0.8)

        img_small = ia.imresize_single_image(
            self.image,
            (20, 25),
            interpolation="cubic")
        seg = SegmentationMapsOnImage(
            (img_small > 100).astype(np.int32),
            shape=(30, 30))

        img_aug = aug.augment_image(self.image)
        seg_aug = aug.augment_segmentation_maps([seg])[0]

        expected = (y2 - y1, x2 - x1)
        expected_small = (y2_small - y1_small, x2_small - x1_small, 1)
        assert all([
            abs(s1-s2) <= 1
            for s1, s2
            in zip(seg_aug.shape, expected)
        ])
        assert all([
</source>
</class>

<class classid="70" nclones="2" nlines="15" similarity="80">
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="4657" endline="4677" pcid="1485">
            expected,
            self.image.shape[0:2],
            interpolation="cubic")
        assert observed.shape == self.image.shape
        # differences seem to mainly appear around the border of the inner
        # rectangle, possibly due to interpolation
        assert np.average(
            np.abs(observed.astype(np.int32) - expected.astype(np.int32))
        ) < 30.0

    def test_heatmaps_with_keep_size(self):
        # with keep_size, heatmaps
        aug = iaa.PerspectiveTransform(scale=0.2, keep_size=True)
        aug.jitter = iap.Deterministic(0.2)

        observed = aug.augment_heatmaps([self.heatmaps])[0]

        heatmaps_arr = self.heatmaps.get_arr()
        expected = heatmaps_arr[int(30*0.2):int(30*0.8),
                                int(30*0.2):int(30*0.8)]
        expected = ia.imresize_single_image(
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="4678" endline="4695" pcid="1486">
            (expected*255).astype(np.uint8),
            self.image.shape[0:2],
            interpolation="cubic")
        expected = (expected / 255.0).astype(np.float32)
        assert observed.shape == self.heatmaps.shape
        _assert_same_min_max(observed, self.heatmaps)
        # differences seem to mainly appear around the border of the inner
        # rectangle, possibly due to interpolation
        assert np.average(np.abs(observed.get_arr() - expected)) < 30.0

    def test_segmaps_with_keep_size(self):
        # with keep_size, segmaps
        aug = iaa.PerspectiveTransform(scale=0.2, keep_size=True)
        aug.jitter = iap.Deterministic(0.2)

        observed = aug.augment_segmentation_maps([self.segmaps])[0]

        segmaps_arr = self.segmaps.get_arr()
</source>
</class>

<class classid="71" nclones="2" nlines="14" similarity="73">
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="4725" endline="4745" pcid="1488">
                # inner rectangle, possibly due to interpolation
                assert np.average(
                    np.abs(
                        observed_i.astype(np.int32) - expected.astype(np.int32)
                    )
                ) < 30.0

    # --------
    # keypoints
    # --------
    def test_keypoints_without_keep_size(self):
        # keypoint augmentation without keep_size
        # TODO deviations of around 0.4-0.7 in this and the next test (between
        #      expected and observed coordinates) -- why?
        kps = [ia.Keypoint(x=10, y=10), ia.Keypoint(x=14, y=11)]
        kpsoi = ia.KeypointsOnImage(kps, shape=self.image.shape)
        aug = iaa.PerspectiveTransform(scale=0.2, keep_size=False)
        aug.jitter = iap.Deterministic(0.2)

        observed = aug.augment_keypoints([kpsoi])

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="4746" endline="4766" pcid="1489">
        kps_expected = [
            ia.Keypoint(x=10-0.2*30, y=10-0.2*30),
            ia.Keypoint(x=14-0.2*30, y=11-0.2*30)
        ]
        gen = zip(observed[0].keypoints, kps_expected)
        # TODO deviations of around 0.5 here from expected values, why?
        for kp_observed, kp_expected in gen:
            assert kp_expected.x - 1.5 < kp_observed.x < kp_expected.x + 1.5
            assert kp_expected.y - 1.5 < kp_observed.y < kp_expected.y + 1.5

    def test_keypoints_with_keep_size(self):
        # keypoint augmentation with keep_size
        kps = [ia.Keypoint(x=10, y=10), ia.Keypoint(x=14, y=11)]
        kpsoi = ia.KeypointsOnImage(kps, shape=self.image.shape)
        aug = iaa.PerspectiveTransform(scale=0.2, keep_size=True)
        aug.jitter = iap.Deterministic(0.2)

        observed = aug.augment_keypoints([kpsoi])

        kps_expected = [
            ia.Keypoint(x=((10-0.2*30)/(30*0.6))*30,
</source>
</class>

<class classid="72" nclones="2" nlines="19" similarity="75">
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="4809" endline="4832" pcid="1492">
        aug = iaa.PerspectiveTransform(scale=0.2, keep_size=True)

        observed = aug.augment_keypoints(kpsoi)

        assert observed.shape == (20, 10, 3)
        assert len(observed.keypoints) == 0

    # --------
    # polygons
    # --------
    def test_polygons_without_keep_size(self):
        exterior = np.float32([
            [10, 10],
            [25, 10],
            [25, 25],
            [10, 25]
        ])
        psoi = ia.PolygonsOnImage([ia.Polygon(exterior)], shape=(30, 30, 3))
        aug = iaa.PerspectiveTransform(scale=0.2, keep_size=False)
        aug.jitter = iap.Deterministic(0.2)

        observed = aug.augment_polygons(psoi)

        assert observed.shape == (30 - 12, 30 - 12, 3)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="4833" endline="4861" pcid="1493">
        assert len(observed.polygons) == 1
        assert observed.polygons[0].is_valid

        exterior_expected = np.copy(exterior)
        exterior_expected[:, 0] -= 0.2 * 30
        exterior_expected[:, 1] -= 0.2 * 30
        # TODO deviations of around 0.5 here from expected values, why?
        assert observed.polygons[0].exterior_almost_equals(
            exterior_expected, max_distance=1.5)

    def test_polygons_with_keep_size(self):
        # polygon augmentation with keep_size
        exterior = np.float32([
            [10, 10],
            [25, 10],
            [25, 25],
            [10, 25]
        ])
        psoi = ia.PolygonsOnImage([ia.Polygon(exterior)], shape=(30, 30, 3))
        aug = iaa.PerspectiveTransform(scale=0.2, keep_size=True)
        aug.jitter = iap.Deterministic(0.2)

        observed = aug.augment_polygons(psoi)

        assert observed.shape == (30, 30, 3)
        assert len(observed.polygons) == 1
        assert observed.polygons[0].is_valid

        exterior_expected = np.copy(exterior)
</source>
</class>

<class classid="73" nclones="2" nlines="12" similarity="91">
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="5375" endline="5389" pcid="1537">
        aug = iaa.ElasticTransformation(alpha=5, sigma=0.5)
        for nb_channels in [1, 2, 4, 5, 7, 10, 11]:
            img_c = np.tile(self.image[..., np.newaxis], (1, 1, nb_channels))
            assert img_c.shape == (250, 250, nb_channels)

            observed = aug.augment_image(img_c)

            assert observed.shape == (250, 250, nb_channels)
            for c in sm.xrange(1, nb_channels):
                assert np.array_equal(observed[..., c], observed[..., 0])

    def test_heatmaps(self):
        # test basic funtionality, heatmaps
        aug = iaa.ElasticTransformation(alpha=0.5, sigma=0.25)
        observed = aug.augment_heatmaps([self.heatmaps])[0]
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="5390" endline="5406" pcid="1538">

        mask = self.mask
        assert observed.shape == self.heatmaps.shape
        _assert_same_min_max(observed, self.heatmaps)
        assert (
            np.sum(observed.get_arr()[mask])
            < np.sum(self.heatmaps.get_arr()[mask]))
        assert (
            np.sum(observed.get_arr()[~mask])
            > np.sum(self.heatmaps.get_arr()[~mask]))

    def test_segmaps(self):
        # test basic funtionality, segmaps
        # alpha=1.5 instead of 0.5 as above here, because otherwise nothing
        # is moved
        aug = iaa.ElasticTransformation(alpha=1.5, sigma=0.25)

</source>
</class>

<class classid="74" nclones="2" nlines="15" similarity="87">
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="5423" endline="5442" pcid="1540">
        observed1 = aug1.augment_image(self.image)
        observed2 = aug2.augment_image(self.image)

        mask = self.mask
        # assume that the inner area has become more black-ish when using high
        # alphas (more white pixels were moved out of the inner area)
        assert np.sum(observed1[mask]) > np.sum(observed2[mask])
        # assume that the outer area has become more white-ish when using high
        # alphas (more black pixels were moved into the inner area)
        assert np.sum(observed1[~mask]) < np.sum(observed2[~mask])

    def test_heatmaps_weak_vs_strong_alpha(self):
        # test effects of increased alpha strength, heatmaps
        aug1 = iaa.ElasticTransformation(alpha=0.1, sigma=0.25)
        aug2 = iaa.ElasticTransformation(alpha=5.0, sigma=0.25)

        observed1 = aug1.augment_heatmaps([self.heatmaps])[0]
        observed2 = aug2.augment_heatmaps([self.heatmaps])[0]

        mask = self.mask
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="5443" endline="5460" pcid="1541">
        assert observed1.shape == self.heatmaps.shape
        assert observed2.shape == self.heatmaps.shape
        _assert_same_min_max(observed1, self.heatmaps)
        _assert_same_min_max(observed2, self.heatmaps)
        assert (
            np.sum(observed1.get_arr()[mask])
            > np.sum(observed2.get_arr()[mask]))
        assert (
            np.sum(observed1.get_arr()[~mask])
            < np.sum(observed2.get_arr()[~mask]))

    def test_segmaps_weak_vs_strong_alpha(self):
        # test effects of increased alpha strength, segmaps
        aug1 = iaa.ElasticTransformation(alpha=0.1, sigma=0.25)
        aug2 = iaa.ElasticTransformation(alpha=5.0, sigma=0.25)

        observed1 = aug1.augment_segmentation_maps([self.segmaps])[0]
        observed2 = aug2.augment_segmentation_maps([self.segmaps])[0]
</source>
</class>

<class classid="75" nclones="3" nlines="18" similarity="100">
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="5587" endline="5608" pcid="1550">
        aug = iaa.ElasticTransformation(alpha=3.0, sigma=3.0, mode="constant",
                                        cval=255)

        observed = aug.augment_segmentation_maps([segmaps])[0]

        assert observed.shape == segmaps.shape
        assert np.sum(observed.get_arr() > 0) == 0

    # -----------
    # keypoints
    # -----------
    def test_keypoints_no_movement_if_alpha_below_threshold(self):
        # for small alpha, should not move if below threshold
        with _elastic_trans_temp_thresholds(alpha=1.0, sigma=0.0):
            kps = [
                ia.Keypoint(x=1, y=1), ia.Keypoint(x=15, y=25),
                ia.Keypoint(x=5, y=5), ia.Keypoint(x=7, y=4),
                ia.Keypoint(x=48, y=5), ia.Keypoint(x=21, y=37),
                ia.Keypoint(x=32, y=39), ia.Keypoint(x=6, y=8),
                ia.Keypoint(x=12, y=21), ia.Keypoint(x=3, y=45),
                ia.Keypoint(x=45, y=3), ia.Keypoint(x=7, y=48)]
            kpsoi = ia.KeypointsOnImage(kps, shape=(50, 50))
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="5631" endline="5653" pcid="1552">
            aug = iaa.ElasticTransformation(alpha=1.0, sigma=0.001)

            observed = aug.augment_keypoints([kpsoi])[0]

            d = kpsoi.to_xy_array() - observed.to_xy_array()
            d[:, 0] = d[:, 0] ** 2
            d[:, 1] = d[:, 1] ** 2
            d = np.sum(d, axis=1)
            d = np.average(d, axis=0)
            assert d < 1e-8

    def test_keypoints_small_movement_for_weak_alpha_if_threshold_zero(self):
        # for small alpha (at sigma 1.0), should barely move
        # if thresholds set to zero
        with _elastic_trans_temp_thresholds(alpha=0.0, sigma=0.0):
            kps = [
                ia.Keypoint(x=1, y=1), ia.Keypoint(x=15, y=25),
                ia.Keypoint(x=5, y=5), ia.Keypoint(x=7, y=4),
                ia.Keypoint(x=48, y=5), ia.Keypoint(x=21, y=37),
                ia.Keypoint(x=32, y=39), ia.Keypoint(x=6, y=8),
                ia.Keypoint(x=12, y=21), ia.Keypoint(x=3, y=45),
                ia.Keypoint(x=45, y=3), ia.Keypoint(x=7, y=48)]
            kpsoi = ia.KeypointsOnImage(kps, shape=(50, 50))
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="5609" endline="5630" pcid="1551">
            aug = iaa.ElasticTransformation(alpha=0.001, sigma=1.0)
    
            observed = aug.augment_keypoints([kpsoi])[0]
    
            d = kpsoi.to_xy_array() - observed.to_xy_array()
            d[:, 0] = d[:, 0] ** 2
            d[:, 1] = d[:, 1] ** 2
            d = np.sum(d, axis=1)
            d = np.average(d, axis=0)
            assert d < 1e-8

    def test_keypoints_no_movement_if_sigma_below_threshold(self):
        # for small sigma, should not move if below threshold
        with _elastic_trans_temp_thresholds(alpha=0.0, sigma=1.0):
            kps = [
                ia.Keypoint(x=1, y=1), ia.Keypoint(x=15, y=25),
                ia.Keypoint(x=5, y=5), ia.Keypoint(x=7, y=4),
                ia.Keypoint(x=48, y=5), ia.Keypoint(x=21, y=37),
                ia.Keypoint(x=32, y=39), ia.Keypoint(x=6, y=8),
                ia.Keypoint(x=12, y=21), ia.Keypoint(x=3, y=45),
                ia.Keypoint(x=45, y=3), ia.Keypoint(x=7, y=48)]
            kpsoi = ia.KeypointsOnImage(kps, shape=(50, 50))
</source>
</class>

<class classid="76" nclones="3" nlines="10" similarity="81">
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="5697" endline="5710" pcid="1555">
        aug = iaa.ElasticTransformation(alpha=10, sigma=10)
        kpsoi = ia.KeypointsOnImage([], shape=(10, 10, 3))

        kpsoi_aug = aug.augment_keypoints(kpsoi)

        assert len(kpsoi_aug.keypoints) == 0
        assert kpsoi_aug.shape == (10, 10, 3)

    # -----------
    # polygons
    # -----------
    def test_polygons_no_movement_if_alpha_below_threshold(self):
        # for small alpha, should not move if below threshold
        with _elastic_trans_temp_thresholds(alpha=1.0, sigma=0.0):
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="5711" endline="5724" pcid="1556">
            poly = ia.Polygon([(10, 15), (40, 15), (40, 35), (10, 35)])
            psoi = ia.PolygonsOnImage([poly], shape=(50, 50))
            aug = iaa.ElasticTransformation(alpha=0.001, sigma=1.0)

            observed = aug.augment_polygons(psoi)

            assert observed.shape == (50, 50)
            assert len(observed.polygons) == 1
            assert observed.polygons[0].exterior_almost_equals(poly)
            assert observed.polygons[0].is_valid

    def test_polygons_no_movement_if_sigma_below_threshold(self):
        # for small sigma, should not move if below threshold
        with _elastic_trans_temp_thresholds(alpha=0.0, sigma=1.0):
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="5725" endline="5740" pcid="1557">
            poly = ia.Polygon([(10, 15), (40, 15), (40, 35), (10, 35)])
            psoi = ia.PolygonsOnImage([poly], shape=(50, 50))
            aug = iaa.ElasticTransformation(alpha=1.0, sigma=0.001)

            observed = aug.augment_polygons(psoi)

            assert observed.shape == (50, 50)
            assert len(observed.polygons) == 1
            assert observed.polygons[0].exterior_almost_equals(poly)
            assert observed.polygons[0].is_valid

    def test_polygons_small_movement_for_weak_alpha_if_threshold_zero(self):
        # for small alpha (at sigma 1.0), should barely move
        # if thresholds set to zero
        with _elastic_trans_temp_thresholds(alpha=0.0, sigma=0.0):
            poly = ia.Polygon([(10, 15), (40, 15), (40, 35), (10, 35)])
</source>
</class>

<class classid="77" nclones="3" nlines="20" similarity="71">
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="5823" endline="5850" pcid="1561">

        img_aug = aug_det.augment_image(img)
        hm_aug = aug_det.augment_heatmaps([hm])[0]

        img_aug_mask = img_aug > 255*0.1
        hm_aug_mask = hm_aug.arr_0to1 > 0.1
        same = np.sum(img_aug_mask == hm_aug_mask[:, :, 0])
        assert hm_aug.shape == (80, 80)
        assert hm_aug.arr_0to1.shape == (80, 80, 1)
        assert (same / img_aug_mask.size) >= 0.99

    def test_image_heatmaps_alignment_if_heatmaps_smaller_than_image(self):
        # test alignment between images and heatmaps
        # here with heatmaps that are smaller than the image
        img = np.zeros((80, 80), dtype=np.uint8)
        img[:, 30:50] = 255
        img[30:50, :] = 255
        img_small = ia.imresize_single_image(
            img, (40, 40), interpolation="nearest")
        hm = HeatmapsOnImage(
            img_small.astype(np.float32)/255.0,
            shape=(80, 80))
        aug = iaa.ElasticTransformation(
            alpha=60.0, sigma=4.0, mode="constant", cval=0)
        aug_det = aug.to_deterministic()

        img_aug = aug_det.augment_image(img)
        hm_aug = aug_det.augment_heatmaps([hm])[0]
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="5875" endline="5900" pcid="1563">

        img_aug = aug_det.augment_image(img)
        segmaps_aug = aug_det.augment_segmentation_maps([segmaps])[0]

        img_aug_mask = img_aug > 255*0.1
        segmaps_aug_mask = segmaps_aug.arr > 0
        same = np.sum(img_aug_mask == segmaps_aug_mask[:, :, 0])
        assert segmaps_aug.shape == (80, 80)
        assert segmaps_aug.arr.shape == (80, 80, 1)
        assert (same / img_aug_mask.size) >= 0.99

    def test_image_segmaps_alignment_if_heatmaps_smaller_than_image(self):
        # test alignment between images and segmaps
        # here with segmaps that are smaller than the image
        img = np.zeros((80, 80), dtype=np.uint8)
        img[:, 30:50] = 255
        img[30:50, :] = 255
        img_small = ia.imresize_single_image(
            img, (40, 40), interpolation="nearest")
        segmaps = SegmentationMapsOnImage(
            (img_small > 0).astype(np.int32), shape=(80, 80))
        aug = iaa.ElasticTransformation(
            alpha=60.0, sigma=4.0, mode="constant", cval=0, order=0)
        aug_det = aug.to_deterministic()

        img_aug = aug_det.augment_image(img)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="5853" endline="5874" pcid="1562">
        hm_aug_mask = ia.imresize_single_image(
            hm_aug.arr_0to1, (80, 80), interpolation="nearest"
        ) > 0.1
        same = np.sum(img_aug_mask == hm_aug_mask[:, :, 0])
        assert hm_aug.shape == (80, 80)
        assert hm_aug.arr_0to1.shape == (40, 40, 1)
        assert (same / img_aug_mask.size) >= 0.94

    # -----------
    # segmaps alignment
    # -----------
    def test_image_segmaps_alignment(self):
        # test alignment between images and segmaps
        img = np.zeros((80, 80), dtype=np.uint8)
        img[:, 30:50] = 255
        img[30:50, :] = 255
        segmaps = SegmentationMapsOnImage(
            (img > 0).astype(np.int32),
            shape=(80, 80))
        aug = iaa.ElasticTransformation(
            alpha=60.0, sigma=4.0, mode="constant", cval=0, order=0)
        aug_det = aug.to_deterministic()
</source>
</class>

<class classid="78" nclones="2" nlines="11" similarity="75">
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="5969" endline="5982" pcid="1567">
        assert isinstance(params[3], iap.Deterministic)
        assert isinstance(params[4], iap.Deterministic)
        assert 0.25 - 1e-8 < params[0].value < 0.25 + 1e-8
        assert 1.0 - 1e-8 < params[1].value < 1.0 + 1e-8
        assert params[2].value == 2
        assert params[3].value == 10
        assert params[4].value == "constant"

    # -----------
    # other dtypes
    # -----------
    def test_other_dtypes_bool(self):
        aug = iaa.ElasticTransformation(sigma=0.5, alpha=5, order=0)
        mask = np.zeros((21, 21), dtype=bool)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="6027" endline="6043" pcid="1571">
            for value in values:
                with self.subTest(dtype=dtype, value=value):
                    image = np.zeros((21, 21), dtype=dtype)
                    image[7:13, 7:13] = value

                    image_aug = aug.augment_image(image)

                    assert image_aug.dtype.name == dtype
                    assert not np.all(_isclose(image_aug, np.float128(value)))
                    assert np.any(_isclose(image_aug[~mask],
                                           np.float128(value)))

    def test_other_dtypes_bool_all_orders(self):
        mask = np.zeros((50, 50), dtype=bool)
        mask[10:40, 20:30] = True
        mask[20:30, 10:40] = True

</source>
</class>

<class classid="79" nclones="2" nlines="10" similarity="100">
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="6230" endline="6241" pcid="1589">
        return ia.KeypointsOnImage(kps, shape=(8, 4, 3))

    @property
    def psoi_k1(self):
        # without keep size
        kp_offset = self.kp_offset
        expected_k1_polys = [(4-1+kp_offset, 1),
                             (4-1+kp_offset, 3),
                             (4-3+kp_offset, 3),
                             (4-3+kp_offset, 1)]
        return ia.PolygonsOnImage([ia.Polygon(expected_k1_polys)],
                                  shape=(8, 4, 3))
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="6243" endline="6254" pcid="1590">
    @property
    def psoi_k2(self):
        # without keep size
        kp_offset = self.kp_offset
        expected_k1_polys = self.psoi_k1.polygons[0].exterior
        expected_k2_polys = [
            (8-expected_k1_polys[0][1]+kp_offset, expected_k1_polys[0][0]),
            (8-expected_k1_polys[1][1]+kp_offset, expected_k1_polys[1][0]),
            (8-expected_k1_polys[2][1]+kp_offset, expected_k1_polys[2][0]),
            (8-expected_k1_polys[3][1]+kp_offset, expected_k1_polys[3][0])]
        return ia.PolygonsOnImage([ia.Polygon(expected_k2_polys)],
                                  shape=(8, 4, 3))
</source>
</class>

<class classid="80" nclones="3" nlines="13" similarity="92">
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="6356" endline="6372" pcid="1600">
    def test_heatmaps_k_is_1_and_5(self):
        for k in [1, 5]:
            with self.subTest(k=k):
                aug = iaa.Rot90(k, keep_size=False)

                hms_aug = aug.augment_heatmaps([self.heatmaps])[0]

                assert (hms_aug.arr_0to1.dtype.name
                        == self.heatmaps.arr_0to1.dtype.name)
                assert np.allclose(
                    hms_aug.arr_0to1,
                    np.rot90(self.heatmaps.arr_0to1, 1, axes=(1, 0)))
                assert hms_aug.shape == (4, 4, 3)

    def test_heatmaps_smaller_than_image_k_is_1_and_5(self):
        for k in [1, 5]:
            with self.subTest(k=k):
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="6373" endline="6389" pcid="1601">
                aug = iaa.Rot90(k, keep_size=False)

                hms_smaller_aug = aug.augment_heatmaps(
                    [self.heatmaps_smaller]
                )[0]

                assert (
                    hms_smaller_aug.arr_0to1.dtype.name
                    == self.heatmaps_smaller.arr_0to1.dtype.name)
                assert np.allclose(
                    hms_smaller_aug.arr_0to1,
                    np.rot90(self.heatmaps_smaller.arr_0to1, 1, axes=(1, 0)))
                assert hms_smaller_aug.shape == (8, 4, 3)

    def test_segmaps_k_is_1_and_5(self):
        for k in [1, 5]:
            with self.subTest(k=k):
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="6390" endline="6405" pcid="1602">
                aug = iaa.Rot90(k, keep_size=False)

                segmaps_aug = aug.augment_segmentation_maps(
                    [self.segmaps]
                )[0]

                assert (
                    segmaps_aug.arr.dtype.name
                    == self.segmaps.arr.dtype.name)
                assert np.allclose(
                    segmaps_aug.arr,
                    np.rot90(self.segmaps.arr, 1, axes=(1, 0)))
                assert segmaps_aug.shape == (4, 4, 3)

    def test_segmaps_smaller_than_image_k_is_1_and_5(self):
        for k in [1, 5]:
</source>
</class>

<class classid="81" nclones="2" nlines="11" similarity="90">
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="6418" endline="6431" pcid="1604">
                assert segmaps_smaller_aug.shape == (8, 4, 3)

    def test_keypoints_k_is_1_and_5(self):
        for k in [1, 5]:
            with self.subTest(k=k):
                aug = iaa.Rot90(k, keep_size=False)

                kpsoi_aug = aug.augment_keypoints([self.kpsoi])[0]

                assert kpsoi_aug.shape == (8, 4, 3)
                expected_k1_kps = self.kpsoi_k1.to_xy_array()
                for kp_aug, kp in zip(kpsoi_aug.keypoints, expected_k1_kps):
                    assert np.allclose([kp_aug.x, kp_aug.y], [kp[0], kp[1]])

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="6596" endline="6609" pcid="1618">
                assert segmaps_smaller_aug.shape == (8, 4, 3)

    def test_keypoints_k_is_3_and_minus1(self):
        for k in [3, -1]:
            with self.subTest(k=k):
                aug = iaa.Rot90(k, keep_size=False)

                kpsoi_aug = aug.augment_keypoints([self.kpsoi])[0]

                assert kpsoi_aug.shape == (8, 4, 3)
                expected_k3_kps = self.kpsoi_k3.to_xy_array()
                for kp_aug, kp in zip(kpsoi_aug.keypoints, expected_k3_kps):
                    assert np.allclose([kp_aug.x, kp_aug.y], [kp[0], kp[1]])

</source>
</class>

<class classid="82" nclones="6" nlines="11" similarity="75">
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="6453" endline="6465" pcid="1607">
        assert np.array_equal(img_aug, np.rot90(img, 2, axes=(1, 0)))

    def test_heatmaps_k_is_2(self):
        aug = iaa.Rot90(2, keep_size=False)
        hms = self.heatmaps

        hms_aug = aug.augment_heatmaps([hms])[0]

        assert hms_aug.arr_0to1.dtype.name == hms.arr_0to1.dtype.name
        assert np.allclose(
            hms_aug.arr_0to1,
            np.rot90(hms.arr_0to1, 2, axes=(1, 0)))
        assert hms_aug.shape == (4, 4, 3)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="6553" endline="6567" pcid="1615">
        hms_smaller = self.heatmaps_smaller
        for k in [3, -1]:
            with self.subTest(k=k):
                aug = iaa.Rot90(k, keep_size=False)

                hms_smaller_aug = aug.augment_heatmaps([hms_smaller])[0]

                assert (hms_smaller_aug.arr_0to1.dtype.name
                        == hms_smaller.arr_0to1.dtype.name)
                assert np.allclose(
                    hms_smaller_aug.arr_0to1,
                    np.rot90(hms_smaller.arr_0to1, 3, axes=(1, 0)))
                assert hms_smaller_aug.shape == (8, 4, 3)

    def test_segmaps_k_is_3_and_minus1(self):
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="6478" endline="6490" pcid="1609">
        assert hms_smaller_aug.shape == (4, 8, 3)

    def test_segmaps_k_is_2(self):
        aug = iaa.Rot90(2, keep_size=False)
        segmaps = self.segmaps

        segmaps_aug = aug.augment_segmentation_maps([segmaps])[0]

        assert segmaps_aug.arr.dtype.name == segmaps.arr.dtype.name
        assert np.allclose(
            segmaps_aug.arr,
            np.rot90(segmaps.arr, 2, axes=(1, 0)))
        assert segmaps_aug.shape == (4, 4, 3)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="6538" endline="6552" pcid="1614">
        hms = self.heatmaps
        for k in [3, -1]:
            with self.subTest(k=k):
                aug = iaa.Rot90(k, keep_size=False)

                hms_aug = aug.augment_heatmaps([hms])[0]

                assert (hms_aug.arr_0to1.dtype.name
                        == hms.arr_0to1.dtype.name)
                assert np.allclose(
                    hms_aug.arr_0to1,
                    np.rot90(hms.arr_0to1, 3, axes=(1, 0)))
                assert hms_aug.shape == (4, 4, 3)

    def test_heatmaps_smaller_than_image_k_is_3_and_minus1(self):
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="6523" endline="6537" pcid="1613">
        expected_k2_poly = self.psoi_k2.polygons[0]
        assert psoi_aug.polygons[0].exterior_almost_equals(expected_k2_poly)

    def test_images_k_is_3_and_minus1(self):
        img = self.image
        for k in [3, -1]:
            with self.subTest(k=k):
                aug = iaa.Rot90(k, keep_size=False)

                img_aug = aug.augment_image(img)

                assert img_aug.dtype.name == "uint8"
                assert np.array_equal(img_aug, np.rot90(img, 3, axes=(1, 0)))

    def test_heatmaps_k_is_3_and_minus1(self):
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="6568" endline="6583" pcid="1616">
        segmaps = self.segmaps
        for k in [3, -1]:
            with self.subTest(k=k):
                aug = iaa.Rot90(k, keep_size=False)

                segmaps_aug = aug.augment_segmentation_maps([segmaps])[0]

                assert (segmaps_aug.arr.dtype.name
                        == segmaps.arr.dtype.name)
                assert np.allclose(
                    segmaps_aug.arr,
                    np.rot90(segmaps.arr, 3, axes=(1, 0)))
                assert segmaps_aug.shape == (4, 4, 3)

    def test_segmaps_smaller_than_image_k_is_3_and_minus1(self):
        segmaps_smaller = self.segmaps_smaller
</source>
</class>

<class classid="83" nclones="2" nlines="14" similarity="100">
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="6731" endline="6748" pcid="1628">
        assert psoi_aug.polygons[0].is_valid
        assert psoi_aug.polygons[0].exterior_almost_equals(expected)

    def test_images_k_is_list(self):
        aug = iaa.Rot90(_TwoValueParam(1, 2), keep_size=False)
        img = self.image

        imgs_aug = aug.augment_images([img] * 4)

        assert np.array_equal(imgs_aug[0], np.rot90(img, 1, axes=(1, 0)))
        assert np.array_equal(imgs_aug[1], np.rot90(img, 2, axes=(1, 0)))
        assert np.array_equal(imgs_aug[2], np.rot90(img, 1, axes=(1, 0)))
        assert np.array_equal(imgs_aug[3], np.rot90(img, 2, axes=(1, 0)))

    def test_heatmaps_smaller_than_image_k_is_list(self):
        def _rot_hm(hm, k):
            return np.rot90(hm.arr_0to1, k, axes=(1, 0))

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_geometric.py" startline="6749" endline="6766" pcid="1630">
        aug = iaa.Rot90(_TwoValueParam(1, 2), keep_size=False)
        hms_smaller = self.heatmaps_smaller

        hms_aug = aug.augment_heatmaps([hms_smaller] * 4)

        assert hms_aug[0].shape == (8, 4, 3)
        assert hms_aug[1].shape == (4, 8, 3)
        assert hms_aug[2].shape == (8, 4, 3)
        assert hms_aug[3].shape == (4, 8, 3)
        assert np.allclose(hms_aug[0].arr_0to1, _rot_hm(hms_smaller, 1))
        assert np.allclose(hms_aug[1].arr_0to1, _rot_hm(hms_smaller, 2))
        assert np.allclose(hms_aug[2].arr_0to1, _rot_hm(hms_smaller, 1))
        assert np.allclose(hms_aug[3].arr_0to1, _rot_hm(hms_smaller, 2))

    def test_segmaps_smaller_than_image_k_is_list(self):
        def _rot_sm(segmap, k):
            return np.rot90(segmap.arr, k, axes=(1, 0))

</source>
</class>

<class classid="84" nclones="2" nlines="20" similarity="85">
<source file="systems/imgaug-0.3.0/test/augmenters/test_blur.py" startline="353" endline="391" pcid="1661">
                            * np.float128(value))
                        assert np.max(diff) < max_diff

    def test_other_dtypes_bool_at_sigma_06(self):
        # --
        # blur of bool input at sigma=0.6
        # --
        # here we use a special mask and sigma as otherwise the only values
        # ending up with >0.5 would be the ones that
        # were before the blur already at >0.5
        # prototype kernel, generated via:
        #  mask = np.zeros((5, 5), dtype=np.float64)
        #  mask[1, 0] = 255
        #  mask[2, 0] = 255
        #  mask[2, 2] = 255
        #  mask[2, 4] = 255
        #  mask[3, 0] = 255
        #  mask = ndimage.gaussian_filter(mask, 1.0, mode="mirror")
        mask_bool = np.float64([
           [ 57,  14,   2,   1,   1],
           [142,  42,  29,  14,  28],
           [169,  69, 114,  56, 114],
           [142,  42,  29,  14,  28],
           [ 57,  14,   2,   1,   1]
        ]) / 255.0

        image = np.zeros((5, 5), dtype=bool)
        image[1, 0] = True
        image[2, 0] = True
        image[2, 2] = True
        image[2, 4] = True
        image[3, 0] = True

        for backend in ["scipy", "cv2"]:
            image_aug = iaa.blur_gaussian_(
                np.copy(image), sigma=0.6, backend=backend)
            expected = mask_bool > 0.5
            assert image_aug.shape == mask_bool.shape
            assert image_aug.dtype.type == np.bool_
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blur.py" startline="534" endline="570" pcid="1670">
            image[1, 1] = center_value
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.allclose(image_aug, image)

    def test_other_dtypes_bool_at_sigma_060(self):
        # --
        # blur of bool input at sigma=0.6
        # --
        # here we use a special mask and sigma as otherwise the only values
        # ending up with >0.5 would be the ones that
        # were before the blur already at >0.5
        # prototype kernel, generated via:
        #  mask = np.zeros((5, 5), dtype=np.float64)
        #  mask[1, 0] = 255
        #  mask[2, 0] = 255
        #  mask[2, 2] = 255
        #  mask[2, 4] = 255
        #  mask[3, 0] = 255
        #  mask = ndimage.gaussian_filter(mask, 1.0, mode="mirror")
        aug = iaa.GaussianBlur(sigma=0.6)

        mask_bool = np.float64([
           [ 57,  14,   2,   1,   1],
           [142,  42,  29,  14,  28],
           [169,  69, 114,  56, 114],
           [142,  42,  29,  14,  28],
           [ 57,  14,   2,   1,   1]
        ]) / 255.0

        image = np.zeros((5, 5), dtype=bool)
        image[1, 0] = True
        image[2, 0] = True
        image[2, 2] = True
        image[2, 4] = True
        image[3, 0] = True
        image_aug = aug.augment_image(image)
</source>
</class>

<class classid="85" nclones="3" nlines="12" similarity="91">
<source file="systems/imgaug-0.3.0/test/augmenters/test_blur.py" startline="451" endline="466" pcid="1665">
        assert (observed[0][outer_pixels[0], outer_pixels[1]] > 0).all()
        assert (observed[0][outer_pixels[0], outer_pixels[1]] < 50).all()

    def test_keypoints_dont_change(self):
        kps = [ia.Keypoint(x=0, y=0), ia.Keypoint(x=1, y=1),
               ia.Keypoint(x=2, y=2)]
        kpsoi = [ia.KeypointsOnImage(kps, shape=(3, 3, 1))]

        aug = iaa.GaussianBlur(sigma=0.5)
        aug_det = aug.to_deterministic()

        observed = aug.augment_keypoints(kpsoi)
        expected = kpsoi
        assert keypoints_equal(observed, expected)

        observed = aug_det.augment_keypoints(kpsoi)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blur.py" startline="935" endline="949" pcid="1686">
                image = np.zeros(shape, dtype=np.uint8)

                image_aug = iaa.AverageBlur(k=3)(image=image)

                assert image_aug.shape == image.shape

    def test_keypoints_dont_change(self):
        kps = [ia.Keypoint(x=0, y=0), ia.Keypoint(x=1, y=1),
               ia.Keypoint(x=2, y=2)]
        kpsoi = [ia.KeypointsOnImage(kps, shape=(11, 11, 1))]

        aug = iaa.AverageBlur(k=3)
        aug_det = aug.to_deterministic()
        observed = aug.augment_keypoints(kpsoi)
        expected = kpsoi
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blur.py" startline="1240" endline="1255" pcid="1700">
        for shape in shapes:
            with self.subTest(shape=shape):
                image = np.zeros(shape, dtype=np.uint8)

                image_aug = iaa.MedianBlur(k=3)(image=image)

                assert image_aug.shape == image.shape

    def test_keypoints_not_changed(self):
        kps = [ia.Keypoint(x=0, y=0), ia.Keypoint(x=1, y=1),
               ia.Keypoint(x=2, y=2)]
        kpsoi = [ia.KeypointsOnImage(kps, shape=(11, 11, 1))]

        aug = iaa.MedianBlur(k=3)
        aug_det = aug.to_deterministic()
        observed = aug.augment_keypoints(kpsoi)
</source>
</class>

<class classid="86" nclones="8" nlines="26" similarity="78">
<source file="systems/imgaug-0.3.0/test/augmenters/test_blur.py" startline="467" endline="498" pcid="1666">
        expected = kpsoi
        assert keypoints_equal(observed, expected)

    def test_sigma_is_tuple(self):
        # varying blur sigmas
        base_img = np.array([[0, 0, 0],
                         [0, 255, 0],
                         [0, 0, 0]], dtype=np.uint8)
        base_img = base_img[:, :, np.newaxis]
        images = np.array([base_img])

        aug = iaa.GaussianBlur(sigma=(0, 1))
        aug_det = aug.to_deterministic()

        last_aug = None
        last_aug_det = None
        nb_changed_aug = 0
        nb_changed_aug_det = 0
        nb_iterations = 1000
        for i in sm.xrange(nb_iterations):
            observed_aug = aug.augment_images(images)
            observed_aug_det = aug_det.augment_images(images)
            if i == 0:
                last_aug = observed_aug
                last_aug_det = observed_aug_det
            else:
                if not np.array_equal(observed_aug, last_aug):
                    nb_changed_aug += 1
                if not np.array_equal(observed_aug_det, last_aug_det):
                    nb_changed_aug_det += 1
                last_aug = observed_aug
                last_aug_det = observed_aug_det
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="1265" endline="1290" pcid="2117">

        observed = aug_det.augment_keypoints(keypoints)
        assert keypoints_equal(observed, keypoints)

    def test_tuple_as_p(self):
        # varying p
        aug = iaa.Dropout(p=(0.0, 1.0))
        aug_det = aug.to_deterministic()
        images = np.ones((1, 8, 8, 1), dtype=np.uint8) * 255
        last_aug = None
        last_aug_det = None
        nb_changed_aug = 0
        nb_changed_aug_det = 0
        nb_iterations = 1000
        for i in sm.xrange(nb_iterations):
            observed_aug = aug.augment_images(images)
            observed_aug_det = aug_det.augment_images(images)
            if i == 0:
                last_aug = observed_aug
                last_aug_det = observed_aug_det
            else:
                if not np.array_equal(observed_aug, last_aug):
                    nb_changed_aug += 1
                if not np.array_equal(observed_aug_det, last_aug_det):
                    nb_changed_aug_det += 1
                last_aug = observed_aug
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="1123" endline="1150" pcid="2110">
    def test_tuple_as_scale(self):
        # varying stds
        base_img = np.ones((16, 16, 1), dtype=np.uint8) * 128

        aug = iaa.AdditiveGaussianNoise(loc=0, scale=(0.01 * 255, 0.2 * 255))
        aug_det = aug.to_deterministic()
        images = np.ones((1, 1, 1, 1), dtype=np.uint8) * 128
        last_aug = None
        last_aug_det = None
        nb_changed_aug = 0
        nb_changed_aug_det = 0
        nb_iterations = 1000
        for i in sm.xrange(nb_iterations):
            observed_aug = aug.augment_images(images)
            observed_aug_det = aug_det.augment_images(images)
            if i == 0:
                last_aug = observed_aug
                last_aug_det = observed_aug_det
            else:
                if not np.array_equal(observed_aug, last_aug):
                    nb_changed_aug += 1
                if not np.array_equal(observed_aug_det, last_aug_det):
                    nb_changed_aug_det += 1
                last_aug = observed_aug
                last_aug_det = observed_aug_det
        assert nb_changed_aug >= int(nb_iterations * 0.95)
        assert nb_changed_aug_det == 0

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="666" endline="694" pcid="2092">
    def test_tuple_as_value(self):
        # varying values
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        images = np.array([base_img])

        aug = iaa.AddElementwise(value=(0, 10))
        aug_det = aug.to_deterministic()

        last_aug = None
        last_aug_det = None
        nb_changed_aug = 0
        nb_changed_aug_det = 0
        nb_iterations = 1000
        for i in sm.xrange(nb_iterations):
            observed_aug = aug.augment_images(images)
            observed_aug_det = aug_det.augment_images(images)
            if i == 0:
                last_aug = observed_aug
                last_aug_det = observed_aug_det
            else:
                if not np.array_equal(observed_aug, last_aug):
                    nb_changed_aug += 1
                if not np.array_equal(observed_aug_det, last_aug_det):
                    nb_changed_aug_det += 1
                last_aug = observed_aug
                last_aug_det = observed_aug_det
        assert nb_changed_aug >= int(nb_iterations * 0.7)
        assert nb_changed_aug_det == 0

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="1074" endline="1101" pcid="2108">
    def test_tuple_as_loc(self):
        # varying locs
        base_img = np.ones((16, 16, 1), dtype=np.uint8) * 128

        aug = iaa.AdditiveGaussianNoise(loc=(0, 0.5 * 255), scale=0.0001 * 255)
        aug_det = aug.to_deterministic()
        images = np.ones((1, 1, 1, 1), dtype=np.uint8) * 128
        last_aug = None
        last_aug_det = None
        nb_changed_aug = 0
        nb_changed_aug_det = 0
        nb_iterations = 1000
        for i in sm.xrange(nb_iterations):
            observed_aug = aug.augment_images(images)
            observed_aug_det = aug_det.augment_images(images)
            if i == 0:
                last_aug = observed_aug
                last_aug_det = observed_aug_det
            else:
                if not np.array_equal(observed_aug, last_aug):
                    nb_changed_aug += 1
                if not np.array_equal(observed_aug_det, last_aug_det):
                    nb_changed_aug_det += 1
                last_aug = observed_aug
                last_aug_det = observed_aug_det
        assert nb_changed_aug >= int(nb_iterations * 0.95)
        assert nb_changed_aug_det == 0

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="1987" endline="2015" pcid="2152">
        observed = aug_det.augment_keypoints(keypoints)
        expected = keypoints
        assert keypoints_equal(observed, expected)

    def test_tuple_as_mul(self):
        # varying multiply factors
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        images = np.array([base_img])

        aug = iaa.MultiplyElementwise(mul=(0, 2.0))
        aug_det = aug.to_deterministic()

        last_aug = None
        last_aug_det = None
        nb_changed_aug = 0
        nb_changed_aug_det = 0
        nb_iterations = 1000
        for i in sm.xrange(nb_iterations):
            observed_aug = aug.augment_images(images)
            observed_aug_det = aug_det.augment_images(images)
            if i == 0:
                last_aug = observed_aug
                last_aug_det = observed_aug_det
            else:
                if not np.array_equal(observed_aug, last_aug):
                    nb_changed_aug += 1
                if not np.array_equal(observed_aug_det, last_aug_det):
                    nb_changed_aug_det += 1
                last_aug = observed_aug
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="1517" endline="1545" pcid="2136">
        observed = aug_det.augment_keypoints(keypoints)
        expected = keypoints
        assert keypoints_equal(observed, expected)

    def test_tuple_as_mul(self):
        # varying multiply factors
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        images = np.array([base_img])

        aug = iaa.Multiply(mul=(0, 2.0))
        aug_det = aug.to_deterministic()

        last_aug = None
        last_aug_det = None
        nb_changed_aug = 0
        nb_changed_aug_det = 0
        nb_iterations = 1000
        for i in sm.xrange(nb_iterations):
            observed_aug = aug.augment_images(images)
            observed_aug_det = aug_det.augment_images(images)
            if i == 0:
                last_aug = observed_aug
                last_aug_det = observed_aug_det
            else:
                if not np.array_equal(observed_aug, last_aug):
                    nb_changed_aug += 1
                if not np.array_equal(observed_aug_det, last_aug_det):
                    nb_changed_aug_det += 1
                last_aug = observed_aug
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="201" endline="229" pcid="2074">
    def test_tuple_as_value(self):
        # varying values
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        images = np.array([base_img])

        aug = iaa.Add(value=(0, 10))
        aug_det = aug.to_deterministic()

        last_aug = None
        last_aug_det = None
        nb_changed_aug = 0
        nb_changed_aug_det = 0
        nb_iterations = 1000
        for i in sm.xrange(nb_iterations):
            observed_aug = aug.augment_images(images)
            observed_aug_det = aug_det.augment_images(images)
            if i == 0:
                last_aug = observed_aug
                last_aug_det = observed_aug_det
            else:
                if not np.array_equal(observed_aug, last_aug):
                    nb_changed_aug += 1
                if not np.array_equal(observed_aug_det, last_aug_det):
                    nb_changed_aug_det += 1
                last_aug = observed_aug
                last_aug_det = observed_aug_det
        assert nb_changed_aug >= int(nb_iterations * 0.7)
        assert nb_changed_aug_det == 0

</source>
</class>

<class classid="87" nclones="2" nlines="32" similarity="93">
<source file="systems/imgaug-0.3.0/test/augmenters/test_blur.py" startline="571" endline="619" pcid="1671">
        expected = mask_bool > 0.5
        assert image_aug.shape == mask_bool.shape
        assert image_aug.dtype.type == np.bool_
        assert np.all(image_aug == expected)

    def test_other_dtypes_at_sigma_1(self):
        # --
        # blur of various dtypes at sigma=1.0
        # and using an example value of 100 for int/uint/float and True for
        # bool
        # --
        # prototype kernel, generated via:
        #  mask = np.zeros((5, 5), dtype=np.float64)
        #  mask[2, 2] = 100
        #  mask = ndimage.gaussian_filter(mask, 1.0, mode="mirror")
        aug = iaa.GaussianBlur(sigma=1.0)

        mask = np.float64([
            [1, 2, 3, 2, 1],
            [2, 5, 9, 5, 2],
            [4, 9, 15, 9, 4],
            [2, 5, 9, 5, 2],
            [1, 2, 3, 2, 1]
        ])

        # uint, int
        uint_dts = [np.uint8, np.uint16, np.uint32]
        int_dts = [np.int8, np.int16, np.int32]
        for dtype in uint_dts + int_dts:
            image = np.zeros((5, 5), dtype=dtype)
            image[2, 2] = 100
            image_aug = aug.augment_image(image)
            expected = mask.astype(dtype)
            diff = np.abs(image_aug.astype(np.int64)
                          - expected.astype(np.int64))
            assert image_aug.shape == mask.shape
            assert image_aug.dtype.type == dtype
            assert np.max(diff) <= 4
            assert np.average(diff) <= 2

        # float
        float_dts = [np.float16, np.float32, np.float64]
        for dtype in float_dts:
            image = np.zeros((5, 5), dtype=dtype)
            image[2, 2] = 100.0
            image_aug = aug.augment_image(image)
            expected = mask.astype(dtype)
            diff = np.abs(image_aug.astype(np.float128)
                          - expected.astype(np.float128))
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blur.py" startline="620" endline="666" pcid="1672">
            assert image_aug.shape == mask.shape
            assert image_aug.dtype.type == dtype
            assert np.max(diff) < 4
            assert np.average(diff) < 2.0

    def test_other_dtypes_at_sigma_040(self):
        # --
        # blur of various dtypes at sigma=0.4
        # and using an example value of 100 for int/uint/float and True for
        # bool
        # --
        aug = iaa.GaussianBlur(sigma=0.4)

        # prototype kernel, generated via:
        #  mask = np.zeros((5, 5), dtype=np.uint8)
        #  mask[2, 2] = 100
        #  kernel = ndimage.gaussian_filter(mask, 0.4, mode="mirror")
        mask = np.float64([
            [0,  0,  0,  0,  0],
            [0,  0,  3,  0,  0],
            [0,  3, 83,  3,  0],
            [0,  0,  3,  0,  0],
            [0,  0,  0,  0,  0]
        ])

        # uint, int
        uint_dts = [np.uint8, np.uint16, np.uint32]
        int_dts = [np.int8, np.int16, np.int32]
        for dtype in uint_dts + int_dts:
            image = np.zeros((5, 5), dtype=dtype)
            image[2, 2] = 100
            image_aug = aug.augment_image(image)
            expected = mask.astype(dtype)
            diff = np.abs(image_aug.astype(np.int64)
                          - expected.astype(np.int64))
            assert image_aug.shape == mask.shape
            assert image_aug.dtype.type == dtype
            assert np.max(diff) <= 4

        # float
        float_dts = [np.float16, np.float32, np.float64]
        for dtype in float_dts:
            image = np.zeros((5, 5), dtype=dtype)
            image[2, 2] = 100.0
            image_aug = aug.augment_image(image)
            expected = mask.astype(dtype)
            diff = np.abs(image_aug.astype(np.float128)
</source>
</class>

<class classid="88" nclones="3" nlines="10" similarity="72">
<source file="systems/imgaug-0.3.0/test/augmenters/test_blur.py" startline="727" endline="739" pcid="1674">
            assert image_aug.dtype.type == dtype
            # accepts difference of 2.0, 4.0, 8.0, 16.0 (at 1, 2, 4, 8 bytes,
            # i.e. 8, 16, 32, 64 bit)
            max_diff = np.dtype(dtype).itemsize * 0.01 * np.float128(value)
            assert np.max(diff) < max_diff

    def test_failure_on_invalid_dtypes(self):
        # assert failure on invalid dtypes
        aug = iaa.GaussianBlur(sigma=1.0)
        for dt in [np.float128]:
            got_exception = False
            try:
                _ = aug.augment_image(np.zeros((1, 1), dtype=dt))
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_convolutional.py" startline="388" endline="401" pcid="1749">

    def test_failure_on_invalid_dtypes(self):
        # don't use assertRaisesRegex, because it doesnt exist in 2.7
        identity_matrix = np.int64([[1]])
        aug = iaa.Convolve(matrix=identity_matrix)
        for dt in [np.uint32, np.uint64, np.int32, np.int64]:
            got_exception = False
            try:
                _ = aug.augment_image(np.zeros((1, 1), dtype=dt))
            except Exception as exc:
                assert "forbidden dtype" in str(exc)
                got_exception = True
            assert got_exception

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blur.py" startline="1104" endline="1116" pcid="1690">
            expected = (mask * value).astype(dtype)
            diff = np.abs(image_aug.astype(np.float128)
                          - expected.astype(np.float128))
            assert image_aug.dtype.type == dtype
            # accepts difference of 2.0, 4.0, 8.0, 16.0 (at 1, 2, 4, 8 bytes,
            # i.e. 8, 16, 32, 64 bit)
            assert np.max(diff) < 2**(1 + np.dtype(dtype).itemsize)

    def test_failure_on_invalid_dtypes(self):
        # assert failure on invalid dtypes
        aug = iaa.AverageBlur(k=3)
        for dt in [np.uint32, np.uint64, np.int32, np.int64]:
            got_exception = False
</source>
</class>

<class classid="89" nclones="3" nlines="16" similarity="77">
<source file="systems/imgaug-0.3.0/test/augmenters/test_blur.py" startline="822" endline="838" pcid="1680">
    def test_kernel_size_5(self):
        # k=5
        aug = iaa.AverageBlur(k=5)
        observed = aug.augment_image(self.base_img)
        assert np.array_equal(observed, self.blur5x5)

    def test_kernel_size_is_tuple(self):
        # k as (3, 4)
        aug = iaa.AverageBlur(k=(3, 4))
        nb_iterations = 100
        nb_seen = [0, 0]
        for i in sm.xrange(nb_iterations):
            observed = aug.augment_image(self.base_img)
            if np.array_equal(observed, self.blur3x3):
                nb_seen[0] += 1
            elif np.array_equal(observed, self.blur4x4):
                nb_seen[1] += 1
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blur.py" startline="839" endline="858" pcid="1681">
            else:
                raise Exception("Unexpected result in AverageBlur@1")
        p_seen = [v/nb_iterations for v in nb_seen]
        assert 0.4 <= p_seen[0] <= 0.6
        assert 0.4 <= p_seen[1] <= 0.6

    def test_kernel_size_is_tuple_with_wider_range(self):
        # k as (3, 5)
        aug = iaa.AverageBlur(k=(3, 5))
        nb_iterations = 200
        nb_seen = [0, 0, 0]
        for i in sm.xrange(nb_iterations):
            observed = aug.augment_image(self.base_img)
            if np.array_equal(observed, self.blur3x3):
                nb_seen[0] += 1
            elif np.array_equal(observed, self.blur4x4):
                nb_seen[1] += 1
            elif np.array_equal(observed, self.blur5x5):
                nb_seen[2] += 1
            else:
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blur.py" startline="859" endline="875" pcid="1682">
                raise Exception("Unexpected result in AverageBlur@2")
        p_seen = [v/nb_iterations for v in nb_seen]
        assert 0.23 <= p_seen[0] <= 0.43
        assert 0.23 <= p_seen[1] <= 0.43
        assert 0.23 <= p_seen[2] <= 0.43

    def test_kernel_size_is_stochastic_parameter(self):
        # k as stochastic parameter
        aug = iaa.AverageBlur(k=iap.Choice([3, 5]))
        nb_iterations = 100
        nb_seen = [0, 0]
        for i in sm.xrange(nb_iterations):
            observed = aug.augment_image(self.base_img)
            if np.array_equal(observed, self.blur3x3):
                nb_seen[0] += 1
            elif np.array_equal(observed, self.blur5x5):
                nb_seen[1] += 1
</source>
</class>

<class classid="90" nclones="2" nlines="14" similarity="78">
<source file="systems/imgaug-0.3.0/test/augmenters/test_blur.py" startline="1174" endline="1189" pcid="1696">
        assert np.array_equal(observed, self.blur3x3)

    def test_k_is_5(self):
        # k=5
        aug = iaa.MedianBlur(k=5)
        observed = aug.augment_image(self.base_img)
        assert np.array_equal(observed, self.blur5x5)

    def test_k_is_tuple(self):
        # k as (3, 5)
        aug = iaa.MedianBlur(k=(3, 5))
        seen = [False, False]
        for i in sm.xrange(100):
            observed = aug.augment_image(self.base_img)
            if np.array_equal(observed, self.blur3x3):
                seen[0] = True
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blur.py" startline="1190" endline="1205" pcid="1697">
            elif np.array_equal(observed, self.blur5x5):
                seen[1] = True
            else:
                raise Exception("Unexpected result in MedianBlur@1")
            if all(seen):
                break
        assert np.all(seen)

    def test_k_is_stochastic_parameter(self):
        # k as stochastic parameter
        aug = iaa.MedianBlur(k=iap.Choice([3, 5]))
        seen = [False, False]
        for i in sm.xrange(100):
            observed = aug.augment_image(self.base_img)
            if np.array_equal(observed, self.blur3x3):
                seen[0] += True
</source>
</class>

<class classid="91" nclones="5" nlines="16" similarity="75">
<source file="systems/imgaug-0.3.0/test/augmenters/test_blur.py" startline="1281" endline="1300" pcid="1704">

                assert image_aug.shape == image.shape


class TestMotionBlur(unittest.TestCase):
    def setUp(self):
        reseed()

    def test_simple_parameters(self):
        # simple scenario
        aug = iaa.MotionBlur(k=3, angle=0, direction=0.0)
        matrix_func = aug.matrix
        matrices = [
            matrix_func(
                np.zeros((128, 128, 3), dtype=np.uint8),
                3,
                iarandom.RNG(i)
            ) for i in range(10)
        ]
        expected = np.float32([
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blur.py" startline="1301" endline="1320" pcid="1705">
            [0, 1.0/3, 0],
            [0, 1.0/3, 0],
            [0, 1.0/3, 0]
        ])
        for matrices_image in matrices:
            for matrix_channel in matrices_image:
                assert np.allclose(matrix_channel, expected)

    def test_simple_parameters_angle_is_90(self):
        # 90deg angle
        aug = iaa.MotionBlur(k=3, angle=90, direction=0.0)
        matrix_func = aug.matrix
        matrices = [
            matrix_func(
                np.zeros((128, 128, 3), dtype=np.uint8),
                3,
                iarandom.RNG(i)
            ) for i in range(10)
        ]
        expected = np.float32([
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blur.py" startline="1451" endline="1470" pcid="1712">

    # TODO extend this to test sampled kernel sizes
    def test_k_is_tuple(self):
        # no error in case of (a, b), checks for #215
        aug = iaa.MotionBlur(k=(3, 7))
        for _ in range(10):
            _ = aug.augment_image(np.zeros((11, 11, 3), dtype=np.uint8))

    def test_direction_is_1(self):
        # direction 1.0
        aug = iaa.MotionBlur(k=3, angle=0, direction=1.0)
        matrix_func = aug.matrix
        matrices = [
            matrix_func(
                np.zeros((128, 128, 3), dtype=np.uint8),
                3,
                iarandom.RNG(i)
            ) for i in range(10)
        ]
        expected = np.float32([
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blur.py" startline="1321" endline="1340" pcid="1706">
            [0, 0, 0],
            [1.0/3, 1.0/3, 1.0/3],
            [0, 0, 0]
        ])
        for matrices_image in matrices:
            for matrix_channel in matrices_image:
                assert np.allclose(matrix_channel, expected)

    def test_simple_parameters_angle_is_45(self):
        # 45deg angle
        aug = iaa.MotionBlur(k=3, angle=45, direction=0.0, order=0)
        matrix_func = aug.matrix
        matrices = [
            matrix_func(
                np.zeros((128, 128, 3), dtype=np.uint8),
                3,
                iarandom.RNG(i)
            ) for i in range(10)
        ]
        expected = np.float32([
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blur.py" startline="1471" endline="1490" pcid="1713">
            [0, 1.0/1.5, 0],
            [0, 0.5/1.5, 0],
            [0, 0.0/1.5, 0]
        ])
        for matrices_image in matrices:
            for matrix_channel in matrices_image:
                assert np.allclose(matrix_channel, expected, rtol=0, atol=1e-2)

    def test_direction_is_minus_1(self):
        # direction -1.0
        aug = iaa.MotionBlur(k=3, angle=0, direction=-1.0)
        matrix_func = aug.matrix
        matrices = [
            matrix_func(
                np.zeros((128, 128, 3), dtype=np.uint8),
                3,
                iarandom.RNG(i)
            ) for i in range(10)
        ]
        expected = np.float32([
</source>
</class>

<class classid="92" nclones="2" nlines="13" similarity="84">
<source file="systems/imgaug-0.3.0/test/augmenters/test_convolutional.py" startline="138" endline="153" pcid="1733">
    def test_matrix_is_3x3_with_multiple_nonzero_values(self):
        m = np.float32([
            [0, -1, 0],
            [0, 10, 0],
            [0, 0, 0]
        ])
        expected = np.uint8([
            [10*1+(-1)*4, 10*2+(-1)*5, 10*3+(-1)*6],
            [10*4+(-1)*1, 10*5+(-1)*2, 10*6+(-1)*3],
            [10*7+(-1)*4, 10*8+(-1)*5, 10*9+(-1)*6]
        ])

        aug = iaa.Convolve(matrix=m)
        observed = aug.augment_image(self.img)
        assert np.array_equal(observed, expected)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_convolutional.py" startline="154" endline="171" pcid="1734">
    def test_matrix_is_lambda_3x3_with_multiple_nonzero_values(self):
        def _matrix_generator(_img, _nb_channels, _random_state):
            return np.float32([
                [0, -1, 0],
                [0, 10, 0],
                [0, 0, 0]
            ])

        expected = np.uint8([
            [10*1+(-1)*4, 10*2+(-1)*5, 10*3+(-1)*6],
            [10*4+(-1)*1, 10*5+(-1)*2, 10*6+(-1)*3],
            [10*7+(-1)*4, 10*8+(-1)*5, 10*9+(-1)*6]
        ])

        aug = iaa.Convolve(matrix=_matrix_generator)
        observed = aug.augment_image(self.img)
        assert np.array_equal(observed, expected)

</source>
</class>

<class classid="93" nclones="3" nlines="10" similarity="70">
<source file="systems/imgaug-0.3.0/test/augmenters/test_convolutional.py" startline="486" endline="497" pcid="1760">

    def test_alpha_is_stochastic_parameter(self):
        aug = iaa.Sharpen(alpha=iap.Choice([0.5, 1.0]), lightness=1)
        observed = aug.augment_image(self.base_img)
        expected1 = self._compute_sharpened_base_img(
            0.5*1, 0.5 * self.m_noop + 0.5 * self.m)
        expected2 = self._compute_sharpened_base_img(
            1.0*1, 0.0 * self.m_noop + 1.0 * self.m)
        assert (
            np.allclose(observed, expected1)
            or np.allclose(observed, expected2)
        )
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_convolutional.py" startline="714" endline="725" pcid="1774">

    def test_alpha_stochastic_parameter_strength_1(self):
        aug = iaa.Emboss(alpha=iap.Choice([0.5, 1.0]), strength=1)
        observed = aug.augment_image(self.base_img)
        expected1 = self._compute_embossed_base_img(
            self.base_img, alpha=0.5, strength=1)
        expected2 = self._compute_embossed_base_img(
            self.base_img, alpha=1.0, strength=1)
        assert (
            self._allclose(observed, expected1)
            or self._allclose(observed, expected2)
        )
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_convolutional.py" startline="757" endline="768" pcid="1779">

    def test_alpha_1_strength_stochastic_parameter(self):
        aug = iaa.Emboss(alpha=1.0, strength=iap.Choice([1.0, 2.5]))
        observed = aug.augment_image(self.base_img)
        expected1 = self._compute_embossed_base_img(
            self.base_img, alpha=1.0, strength=1.0)
        expected2 = self._compute_embossed_base_img(
            self.base_img, alpha=1.0, strength=2.5)
        assert (
            self._allclose(observed, expected1)
            or self._allclose(observed, expected2)
        )
</source>
</class>

<class classid="94" nclones="3" nlines="11" similarity="72">
<source file="systems/imgaug-0.3.0/test/augmenters/test_overlay.py" startline="25" endline="40" pcid="1781">
    def test_warns_that_it_is_deprecated(self):
        image_fg = np.zeros((1, 1, 3), dtype=np.uint8)
        image_bg = np.copy(image_fg)
        alpha = 1

        with warnings.catch_warnings(record=True) as caught_warnings:
            warnings.simplefilter("always")
            _ = overlay.blend_alpha(image_fg, image_bg, alpha)

        assert len(caught_warnings) == 1
        assert (
            "imgaug.augmenters.blend.blend_alpha"
            in str(caught_warnings[-1].message)
        )


</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_overlay.py" startline="42" endline="56" pcid="1782">
    def test_warns_that_it_is_deprecated(self):
        children_fg = iaa.Noop()
        factor = 1

        with warnings.catch_warnings(record=True) as caught_warnings:
            warnings.simplefilter("always")
            _ = overlay.Alpha(factor, children_fg)

        assert len(caught_warnings) == 1
        assert (
            "imgaug.augmenters.blend.Alpha"
            in str(caught_warnings[-1].message)
        )


</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_overlay.py" startline="58" endline="72" pcid="1783">
    def test_warns_that_it_is_deprecated(self):
        children_fg = iaa.Noop()
        factor = 1

        with warnings.catch_warnings(record=True) as caught_warnings:
            warnings.simplefilter("always")
            _ = overlay.AlphaElementwise(factor, children_fg)

        assert len(caught_warnings) == 1
        assert (
            "imgaug.augmenters.blend.AlphaElementwise"
            in str(caught_warnings[-1].message)
        )


</source>
</class>

<class classid="95" nclones="4" nlines="10" similarity="90">
<source file="systems/imgaug-0.3.0/test/augmenters/test_flip.py" startline="153" endline="164" pcid="1808">
    def test_polygons_p_is_0(self):
        aug = self.create_aug(0)

        for _ in sm.xrange(3):
            observed = aug.augment_polygons(self.psoi)
            assert len(observed) == 1
            assert len(observed[0].polygons) == 1
            assert observed[0].shape == self.psoi[0].shape
            assert observed[0].polygons[0].exterior_almost_equals(
                self.psoi[0].polygons[0])
            assert observed[0].polygons[0].is_valid

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_flip.py" startline="226" endline="237" pcid="1816">
    def test_polygons_p_is_1(self):
        aug = self.create_aug(1.0)

        for _ in sm.xrange(3):
            observed = aug.augment_polygons(self.psoi)
            assert len(observed) == 1
            assert len(observed[0].polygons) == 1
            assert observed[0].shape == self.psoi[0].shape
            assert observed[0].polygons[0].exterior_almost_equals(
                self.psoi_flipped[0].polygons[0])
            assert observed[0].polygons[0].is_valid

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_flip.py" startline="238" endline="249" pcid="1817">
    def test_polygons_p_is_1__deterministic(self):
        aug = self.create_aug(1.0).to_deterministic()

        for _ in sm.xrange(3):
            observed = aug.augment_polygons(self.psoi)
            assert len(observed) == 1
            assert len(observed[0].polygons) == 1
            assert observed[0].shape == self.psoi[0].shape
            assert observed[0].polygons[0].exterior_almost_equals(
                self.psoi_flipped[0].polygons[0])
            assert observed[0].polygons[0].is_valid

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_flip.py" startline="165" endline="176" pcid="1809">
    def test_polygons_p_is_0__deterministic(self):
        aug = self.create_aug(0).to_deterministic()

        for _ in sm.xrange(3):
            observed = aug.augment_polygons(self.psoi)
            assert len(observed) == 1
            assert len(observed[0].polygons) == 1
            assert observed[0].shape == self.psoi[0].shape
            assert observed[0].polygons[0].exterior_almost_equals(
                self.psoi[0].polygons[0])
            assert observed[0].polygons[0].is_valid

</source>
</class>

<class classid="96" nclones="2" nlines="11" similarity="72">
<source file="systems/imgaug-0.3.0/test/augmenters/test_flip.py" startline="177" endline="187" pcid="1810">
    def test_heatmaps_p_is_0(self):
        aug = self.create_aug(0)
        heatmaps = self.heatmaps
        observed = aug.augment_heatmaps(heatmaps)
        assert observed.shape == heatmaps.shape
        assert np.isclose(observed.min_value, heatmaps.min_value,
                          rtol=0, atol=1e-6)
        assert np.isclose(observed.max_value, heatmaps.max_value,
                          rtol=0, atol=1e-6)
        assert np.array_equal(observed.get_arr(), heatmaps.get_arr())

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_flip.py" startline="250" endline="261" pcid="1818">
    def test_heatmaps_p_is_1(self):
        aug = self.create_aug(1.0)
        heatmaps = self.heatmaps
        observed = aug.augment_heatmaps(heatmaps)
        assert observed.shape == heatmaps.shape
        assert np.isclose(observed.min_value, heatmaps.min_value,
                          rtol=0, atol=1e-6)
        assert np.isclose(observed.max_value, heatmaps.max_value,
                          rtol=0, atol=1e-6)
        assert np.array_equal(observed.get_arr(),
                              self.heatmaps_flipped.get_arr())

</source>
</class>

<class classid="97" nclones="4" nlines="10" similarity="72">
<source file="systems/imgaug-0.3.0/test/augmenters/test_flip.py" startline="269" endline="281" pcid="1820">
    def test_images_p_is_050(self):
        aug = self.create_aug(0.5)

        nb_iterations = 1000
        nb_images_flipped = 0
        for _ in sm.xrange(nb_iterations):
            observed = aug.augment_images(self.images)
            if np.array_equal(observed, self.images_flipped):
                nb_images_flipped += 1

        assert np.isclose(nb_images_flipped/nb_iterations,
                          0.5, rtol=0, atol=0.1)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_flip.py" startline="294" endline="306" pcid="1822">
    def test_keypoints_p_is_050(self):
        aug = self.create_aug(0.5)

        nb_iterations = 1000
        nb_keypoints_flipped = 0
        for _ in sm.xrange(nb_iterations):
            observed = aug.augment_keypoints(self.kpsoi)
            if keypoints_equal(observed, self.kpsoi_flipped):
                nb_keypoints_flipped += 1

        assert np.isclose(nb_keypoints_flipped/nb_iterations,
                          0.5, rtol=0, atol=0.1)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_flip.py" startline="319" endline="332" pcid="1824">
    def test_polygons_p_is_050(self):
        aug = self.create_aug(0.5)

        nb_iterations = 250
        nb_polygons_flipped = 0
        for _ in sm.xrange(nb_iterations):
            observed = aug.augment_polygons(self.psoi)
            if observed[0].polygons[0].exterior_almost_equals(
                    self.psoi_flipped[0].polygons[0]):
                nb_polygons_flipped += 1

        assert np.isclose(nb_polygons_flipped/nb_iterations,
                          0.5, rtol=0, atol=0.2)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_flip.py" startline="333" endline="345" pcid="1825">
    def test_polygons_p_is_050__deterministic(self):
        aug = self.create_aug(0.5).to_deterministic()

        nb_iterations = 10
        nb_polygons_flipped_det = 0
        for _ in sm.xrange(nb_iterations):
            observed = aug.augment_polygons(self.psoi)
            if observed[0].polygons[0].exterior_almost_equals(
                    self.psoi_flipped[0].polygons[0]):
                nb_polygons_flipped_det += 1

        assert nb_polygons_flipped_det in [0, nb_iterations]

</source>
</class>

<class classid="98" nclones="2" nlines="12" similarity="75">
<source file="systems/imgaug-0.3.0/test/augmenters/test_flip.py" startline="346" endline="359" pcid="1826">
    def test_list_of_images_p_is_050(self):
        images_multi = [self.image, self.image]
        aug = self.create_aug(0.5)
        nb_iterations = 1000
        nb_flipped_by_pos = [0] * len(images_multi)
        for _ in sm.xrange(nb_iterations):
            observed = aug.augment_images(images_multi)
            for i in sm.xrange(len(images_multi)):
                if np.array_equal(observed[i], self.image_flipped):
                    nb_flipped_by_pos[i] += 1

        assert np.allclose(nb_flipped_by_pos,
                           500, rtol=0, atol=100)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_flip.py" startline="360" endline="373" pcid="1827">
    def test_list_of_images_p_is_050__deterministic(self):
        images_multi = [self.image, self.image]
        aug = self.create_aug(0.5).to_deterministic()
        nb_iterations = 10
        nb_flipped_by_pos_det = [0] * len(images_multi)
        for _ in sm.xrange(nb_iterations):
            observed = aug.augment_images(images_multi)
            for i in sm.xrange(len(images_multi)):
                if np.array_equal(observed[i], self.image_flipped):
                    nb_flipped_by_pos_det[i] += 1

        for val in nb_flipped_by_pos_det:
            assert val in [0, nb_iterations]

</source>
</class>

<class classid="99" nclones="2" nlines="21" similarity="100">
<source file="systems/imgaug-0.3.0/test/augmenters/test_flip.py" startline="706" endline="731" pcid="1875">
    @classmethod
    def _test__fliplr_subfunc_n_channels(cls, func, nb_channels):
        arr = np.uint8([
            [0, 1, 2, 3],
            [4, 5, 6, 7],
            [10, 11, 12, 13]
        ])
        if nb_channels is not None:
            arr = np.tile(arr[..., np.newaxis], (1, 1, nb_channels))
            for c in sm.xrange(nb_channels):
                arr[..., c] += c

        arr_flipped = func(arr)

        expected = np.uint8([
            [3, 2, 1, 0],
            [7, 6, 5, 4],
            [13, 12, 11, 10]
        ])
        if nb_channels is not None:
            expected = np.tile(expected[..., np.newaxis], (1, 1, nb_channels))
            for c in sm.xrange(nb_channels):
                expected[..., c] += c
        assert arr_flipped.dtype.name == "uint8"
        assert arr_flipped.shape == arr.shape
        assert np.array_equal(arr_flipped, expected)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_flip.py" startline="891" endline="916" pcid="1893">
    @classmethod
    def _test__flipud_subfunc_n_channels(cls, func, nb_channels):
        arr = np.uint8([
            [0, 1, 2, 3],
            [4, 5, 6, 7],
            [10, 11, 12, 13]
        ])
        if nb_channels is not None:
            arr = np.tile(arr[..., np.newaxis], (1, 1, nb_channels))
            for c in sm.xrange(nb_channels):
                arr[..., c] += c

        arr_flipped = func(arr)

        expected = np.uint8([
            [10, 11, 12, 13],
            [4, 5, 6, 7],
            [0, 1, 2, 3]
        ])
        if nb_channels is not None:
            expected = np.tile(expected[..., np.newaxis], (1, 1, nb_channels))
            for c in sm.xrange(nb_channels):
                expected[..., c] += c
        assert arr_flipped.dtype.name == "uint8"
        assert arr_flipped.shape == arr.shape
        assert np.array_equal(arr_flipped, expected)
</source>
</class>

<class classid="100" nclones="2" nlines="17" similarity="100">
<source file="systems/imgaug-0.3.0/test/augmenters/test_flip.py" startline="750" endline="769" pcid="1879">

    def test_513_channels_arr_cv2(self):
        arr = np.zeros((1, 2, 513), dtype=np.uint8)
        arr[:, 0, :] = 0
        arr[:, 1, :] = 255
        arr[0, 0, 0] = 1
        arr[0, 1, 0] = 254
        arr[0, 0, 512] = 2
        arr[0, 1, 512] = 253

        arr_flipped = fliplib._fliplr_cv2(arr)

        assert arr_flipped.dtype.name == "uint8"
        assert arr_flipped.shape == (1, 2, 513)
        assert arr_flipped[0, 1, 0] == 1
        assert arr_flipped[0, 0, 0] == 254
        assert arr_flipped[0, 1, 512] == 2
        assert arr_flipped[0, 0, 512] == 253
        assert np.all(arr_flipped[0, 0, 1:-2] == 255)
        assert np.all(arr_flipped[0, 1, 1:-2] == 0)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_flip.py" startline="788" endline="807" pcid="1883">

    def test_513_channels_arr_sliced(self):
        arr = np.zeros((1, 2, 513), dtype=np.uint8)
        arr[:, 0, :] = 0
        arr[:, 1, :] = 255
        arr[0, 0, 0] = 1
        arr[0, 1, 0] = 254
        arr[0, 0, 512] = 2
        arr[0, 1, 512] = 253

        arr_flipped = fliplib._fliplr_sliced(arr)

        assert arr_flipped.dtype.name == "uint8"
        assert arr_flipped.shape == (1, 2, 513)
        assert arr_flipped[0, 1, 0] == 1
        assert arr_flipped[0, 0, 0] == 254
        assert arr_flipped[0, 1, 512] == 2
        assert arr_flipped[0, 0, 512] == 253
        assert np.all(arr_flipped[0, 0, 1:-2] == 255)
        assert np.all(arr_flipped[0, 1, 1:-2] == 0)
</source>
</class>

<class classid="101" nclones="4" nlines="14" similarity="78">
<source file="systems/imgaug-0.3.0/test/augmenters/test_flip.py" startline="816" endline="832" pcid="1885">

    def test_uint_int_faithful(self):
        dts = ["uint8", "uint16", "uint32", "uint64",
               "int8", "int16", "int32", "int64"]
        for dt in dts:
            with self.subTest(dtype=dt):
                dt = np.dtype(dt)
                minv, center, maxv = iadt.get_value_range_of_dtype(dt)
                center = int(center)
                arr = np.array([[minv, center, maxv]], dtype=dt)

                arr_flipped = fliplib.fliplr(arr)

                expected = np.array([[maxv, center, minv]], dtype=dt)
                assert arr_flipped.dtype.name == dt.name
                assert arr_flipped.shape == (1, 3)
                assert np.array_equal(arr_flipped, expected)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_flip.py" startline="833" endline="849" pcid="1886">

    def test_float_faithful_to_min_max(self):
        dts = ["float16", "float32", "float64", "float128"]
        for dt in dts:
            with self.subTest(dtype=dt):
                dt = np.dtype(dt)
                minv, center, maxv = iadt.get_value_range_of_dtype(dt)
                center = int(center)
                atol = 1e-4 if dt.name == "float16" else 1e-8
                arr = np.array([[minv, center, maxv]], dtype=dt)

                arr_flipped = fliplib.fliplr(arr)

                expected = np.array([[maxv, center, minv]], dtype=dt)
                assert arr_flipped.dtype.name == dt.name
                assert arr_flipped.shape == (1, 3)
                assert np.allclose(arr_flipped, expected, rtol=0, atol=atol)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_flip.py" startline="943" endline="959" pcid="1898">

    def test_uint_int_faithful(self):
        dts = ["uint8", "uint16", "uint32", "uint64",
               "int8", "int16", "int32", "int64"]
        for dt in dts:
            with self.subTest(dtype=dt):
                dt = np.dtype(dt)
                minv, center, maxv = iadt.get_value_range_of_dtype(dt)
                center = int(center)
                arr = np.array([[minv], [center], [maxv]], dtype=dt)

                arr_flipped = fliplib.flipud(arr)

                expected = np.array([[maxv], [center], [minv]], dtype=dt)
                assert arr_flipped.dtype.name == dt.name
                assert arr_flipped.shape == (3, 1)
                assert np.array_equal(arr_flipped, expected)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_flip.py" startline="960" endline="976" pcid="1899">

    def test_float_faithful_to_min_max(self):
        dts = ["float16", "float32", "float64", "float128"]
        for dt in dts:
            with self.subTest(dtype=dt):
                dt = np.dtype(dt)
                minv, center, maxv = iadt.get_value_range_of_dtype(dt)
                center = int(center)
                atol = 1e-4 if dt.name == "float16" else 1e-8
                arr = np.array([[minv], [center], [maxv]], dtype=dt)

                arr_flipped = fliplib.flipud(arr)

                expected = np.array([[maxv], [center], [minv]], dtype=dt)
                assert arr_flipped.dtype.name == dt.name
                assert arr_flipped.shape == (3, 1)
                assert np.allclose(arr_flipped, expected, rtol=0, atol=atol)
</source>
</class>

<class classid="102" nclones="2" nlines="20" similarity="90">
<source file="systems/imgaug-0.3.0/test/augmenters/test_flip.py" startline="850" endline="873" pcid="1887">

    def test_float_faithful_to_large_values(self):
        dts = ["float16", "float32", "float64", "float128"]
        values = [
            [0.01, 0.1, 1.0, 10.0**1, 10.0**2],  # float16
            [0.01, 0.1, 1.0, 10.0**1, 10.0**2, 10.0**4, 10.0**6],  # float32
            [0.01, 0.1, 1.0, 10.0**1, 10.0**2, 10.0**6, 10.0**10],  # float64
            [0.01, 0.1, 1.0, 10.0**1, 10.0**2, 10.0**7, 10.0**11],  # float128
        ]
        for dt, values_i in zip(dts, values):
            for value in values_i:
                with self.subTest(dtype=dt, value=value):
                    dt = np.dtype(dt)
                    minv, center, maxv = -value, 0.0, value
                    atol = 1e-4 if dt.name == "float16" else 1e-8
                    arr = np.array([[minv, center, maxv]], dtype=dt)

                    arr_flipped = fliplib.fliplr(arr)

                    expected = np.array([[maxv, center, minv]], dtype=dt)
                    assert arr_flipped.dtype.name == dt.name
                    assert arr_flipped.shape == (1, 3)
                    assert np.allclose(arr_flipped, expected, rtol=0, atol=atol)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_flip.py" startline="977" endline="998" pcid="1900">

    def test_float_faithful_to_large_values(self):
        dts = ["float16", "float32", "float64", "float128"]
        values = [
            [0.01, 0.1, 1.0, 10.0**1, 10.0**2],  # float16
            [0.01, 0.1, 1.0, 10.0**1, 10.0**2, 10.0**4, 10.0**6],  # float32
            [0.01, 0.1, 1.0, 10.0**1, 10.0**2, 10.0**6, 10.0**10],  # float64
            [0.01, 0.1, 1.0, 10.0**1, 10.0**2, 10.0**7, 10.0**11],  # float128
        ]
        for dt, values_i in zip(dts, values):
            for value in values_i:
                with self.subTest(dtype=dt, value=value):
                    dt = np.dtype(dt)
                    minv, center, maxv = -value, 0.0, value
                    atol = 1e-4 if dt.name == "float16" else 1e-8
                    arr = np.array([[minv], [center], [maxv]], dtype=dt)

                    arr_flipped = fliplib.flipud(arr)

                    expected = np.array([[maxv], [center], [minv]], dtype=dt)
                    assert arr_flipped.dtype.name == dt.name
                    assert arr_flipped.shape == (3, 1)
</source>
</class>

<class classid="103" nclones="3" nlines="10" similarity="80">
<source file="systems/imgaug-0.3.0/test/augmenters/test_pooling.py" startline="94" endline="106" pcid="1905">
    def _test_augment_keypoints__kernel_size_is_noop(self, kernel_size):
        from imgaug.augmentables.kps import Keypoint, KeypointsOnImage
        kps = [Keypoint(x=1.5, y=5.5), Keypoint(x=5.5, y=1.5)]
        kpsoi = KeypointsOnImage(kps, shape=(6, 6, 3))
        aug = self.augmenter(kernel_size)

        kpsoi_aug = aug.augment_keypoints(kpsoi)

        assert kpsoi_aug.shape == (6, 6, 3)
        assert np.allclose(kpsoi_aug.to_xy_array(),
                           [[1.5, 5.5],
                            [5.5, 1.5]])

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_pooling.py" startline="133" endline="145" pcid="1911">
    def test_augment_keypoints__kernel_size_is_two__keep_size(self):
        from imgaug.augmentables.kps import Keypoint, KeypointsOnImage
        kps = [Keypoint(x=1.5, y=5.5), Keypoint(x=5.5, y=1.5)]
        kpsoi = KeypointsOnImage(kps, shape=(6, 6, 3))
        aug = self.augmenter(2, keep_size=True)

        kpsoi_aug = aug.augment_keypoints(kpsoi)

        assert kpsoi_aug.shape == (6, 6, 3)
        assert np.allclose(kpsoi_aug.to_xy_array(),
                           [[1.5, 5.5],
                            [5.5, 1.5]])

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_pooling.py" startline="146" endline="158" pcid="1912">
    def test_augment_keypoints__kernel_size_is_two__no_keep_size(self):
        from imgaug.augmentables.kps import Keypoint, KeypointsOnImage
        kps = [Keypoint(x=1.5, y=5.5), Keypoint(x=5.5, y=1.5)]
        kpsoi = KeypointsOnImage(kps, shape=(6, 6, 3))
        aug = self.augmenter(2, keep_size=False)

        kpsoi_aug = aug.augment_keypoints(kpsoi)

        assert kpsoi_aug.shape == (3, 3, 3)
        assert np.allclose(kpsoi_aug.to_xy_array(),
                           [[1.5/2, 5.5/2],
                            [5.5/2, 1.5/2]])

</source>
</class>

<class classid="104" nclones="3" nlines="10" similarity="80">
<source file="systems/imgaug-0.3.0/test/augmenters/test_pooling.py" startline="113" endline="126" pcid="1908">
    def _test_augment_heatmaps__kernel_size_is_noop(self, kernel_size):
        from imgaug.augmentables.heatmaps import HeatmapsOnImage
        arr = np.float32([
            [0.5, 0.6, 0.7],
            [0.4, 0.5, 0.6]
        ])
        heatmaps = HeatmapsOnImage(arr, shape=(6, 6, 3))
        aug = self.augmenter(kernel_size)

        heatmaps_aug = aug.augment_heatmaps(heatmaps)

        assert heatmaps_aug.shape == (6, 6, 3)
        assert np.allclose(heatmaps_aug.arr_0to1, arr[..., np.newaxis])

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_pooling.py" startline="159" endline="172" pcid="1913">
    def test_augment_heatmaps__kernel_size_is_two__keep_size(self):
        from imgaug.augmentables.heatmaps import HeatmapsOnImage
        arr = np.float32([
            [0.5, 0.6, 0.7],
            [0.4, 0.5, 0.6]
        ])
        heatmaps = HeatmapsOnImage(arr, shape=(6, 6, 3))
        aug = self.augmenter(2, keep_size=True)

        heatmaps_aug = aug.augment_heatmaps(heatmaps)

        assert heatmaps_aug.shape == (6, 6, 3)
        assert np.allclose(heatmaps_aug.arr_0to1, arr[..., np.newaxis])

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_pooling.py" startline="173" endline="189" pcid="1914">
    def test_augment_heatmaps__kernel_size_is_two__no_keep_size(self):
        from imgaug.augmentables.heatmaps import HeatmapsOnImage
        arr = np.float32([
            [0.5, 0.6, 0.7],
            [0.4, 0.5, 0.6]
        ])
        heatmaps = HeatmapsOnImage(arr, shape=(6, 6, 3))
        aug = self.augmenter(2, keep_size=False)

        heatmaps_aug = aug.augment_heatmaps(heatmaps)

        # heatmap aug is only supposed to update the image shape as the library
        # can handle heatmaps of different size than the image, so heatmap
        # array stays the same
        assert heatmaps_aug.shape == (3, 3, 3)
        assert np.allclose(heatmaps_aug.arr_0to1, arr[..., np.newaxis])

</source>
</class>

<class classid="105" nclones="3" nlines="12" similarity="76">
<source file="systems/imgaug-0.3.0/test/augmenters/test_pooling.py" startline="190" endline="204" pcid="1915">
    def test_augment_keypoints__kernel_size_differs(self):
        from imgaug.augmentables.kps import Keypoint, KeypointsOnImage
        kps = [Keypoint(x=1.5, y=5.5), Keypoint(x=5.5, y=1.5)]
        kpsoi = KeypointsOnImage(kps, shape=(6, 6, 3))
        aug = self.augmenter(
            (iap.Deterministic(3), iap.Deterministic(2)),
            keep_size=False)

        kpsoi_aug = aug.augment_keypoints(kpsoi)

        assert kpsoi_aug.shape == (2, 3, 3)
        assert np.allclose(kpsoi_aug.to_xy_array(),
                           [[(1.5/6)*3, (5.5/6)*2],
                            [(5.5/6)*3, (1.5/6)*2]])

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_pooling.py" startline="220" endline="235" pcid="1917">
    def test_augment_polygons__kernel_size_differs(self):
        from imgaug.augmentables.polys import Polygon, PolygonsOnImage
        polys = [Polygon([(1.5, 5.5), (5.5, 1.5), (5.5, 5.5)])]
        psoi = PolygonsOnImage(polys, shape=(6, 6, 3))
        aug = self.augmenter(
            (iap.Deterministic(3), iap.Deterministic(2)),
            keep_size=False)

        psoi_aug = aug.augment_polygons(psoi)

        assert psoi_aug.shape == (2, 3, 3)
        assert np.allclose(psoi_aug.polygons[0].exterior,
                           [[(1.5/6)*3, (5.5/6)*2],
                            [(5.5/6)*3, (1.5/6)*2],
                            [(5.5/6)*3, (5.5/6)*2]])

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_pooling.py" startline="205" endline="219" pcid="1916">
    def test_augment_keypoints__kernel_size_differs__requires_padding(self):
        from imgaug.augmentables.kps import Keypoint, KeypointsOnImage
        kps = [Keypoint(x=1.5, y=5.5), Keypoint(x=5.5, y=1.5)]
        kpsoi = KeypointsOnImage(kps, shape=(5, 6, 3))
        aug = self.augmenter(
            (iap.Deterministic(3), iap.Deterministic(2)),
            keep_size=False)

        kpsoi_aug = aug.augment_keypoints(kpsoi)

        assert kpsoi_aug.shape == (2, 3, 3)
        assert np.allclose(kpsoi_aug.to_xy_array(),
                           [[(1.5/6)*3, (5.5/5)*2],
                            [(5.5/6)*3, (1.5/5)*2]])

</source>
</class>

<class classid="106" nclones="7" nlines="14" similarity="78">
<source file="systems/imgaug-0.3.0/test/augmenters/test_pooling.py" startline="393" endline="412" pcid="1931">
    def test_augment_images__kernel_size_is_two__custom_array(self):
        aug = iaa.AveragePooling(2, keep_size=False)

        image = np.uint8([
            [50-2, 50-1, 120-4, 120+4],
            [50+1, 50+2, 120+1, 120-1]
        ])
        image = np.tile(image[:, :, np.newaxis], (1, 1, 3))

        expected = np.uint8([
            [50, 120]
        ])
        expected = np.tile(expected[:, :, np.newaxis], (1, 1, 3))

        image_aug = aug.augment_image(image)
        diff = np.abs(image_aug.astype(np.int32) - expected)
        assert image_aug.dtype.name == "uint8"
        assert image_aug.shape == (1, 2, 3)
        assert np.all(diff <= 1)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_pooling.py" startline="535" endline="553" pcid="1938">
    def test_augment_images(self):
        aug = iaa.MaxPooling(2, keep_size=False)

        image = np.uint8([
            [50-2, 50-1, 120-4, 120+4],
            [50+1, 50+2, 120+1, 120-1]
        ])
        image = np.tile(image[:, :, np.newaxis], (1, 1, 3))

        expected = np.uint8([
            [50+2, 120+4]
        ])
        expected = np.tile(expected[:, :, np.newaxis], (1, 1, 3))

        image_aug = aug.augment_image(image)
        diff = np.abs(image_aug.astype(np.int32) - expected)
        assert image_aug.shape == (1, 2, 3)
        assert np.all(diff <= 1)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_pooling.py" startline="581" endline="599" pcid="1941">
    def test_augment_images(self):
        aug = iaa.MinPooling(2, keep_size=False)

        image = np.uint8([
            [50-2, 50-1, 120-4, 120+4],
            [50+1, 50+2, 120+1, 120-1]
        ])
        image = np.tile(image[:, :, np.newaxis], (1, 1, 3))

        expected = np.uint8([
            [50-2, 120-4]
        ])
        expected = np.tile(expected[:, :, np.newaxis], (1, 1, 3))

        image_aug = aug.augment_image(image)
        diff = np.abs(image_aug.astype(np.int32) - expected)
        assert image_aug.shape == (1, 2, 3)
        assert np.all(diff <= 1)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_pooling.py" startline="627" endline="646" pcid="1944">
    def test_augment_images(self):
        aug = iaa.MedianPooling(3, keep_size=False)

        image = np.uint8([
            [50-9, 50-8, 50-7, 120-5, 120-5, 120-5],
            [50-5, 50+0, 50+3, 120-3, 120+0, 120+1],
            [50+8, 50+9, 50+9, 120+2, 120+3, 120+4]
        ])
        image = np.tile(image[:, :, np.newaxis], (1, 1, 3))

        expected = np.uint8([
            [50, 120]
        ])
        expected = np.tile(expected[:, :, np.newaxis], (1, 1, 3))

        image_aug = aug.augment_image(image)
        diff = np.abs(image_aug.astype(np.int32) - expected)
        assert image_aug.shape == (1, 2, 3)
        assert np.all(diff <= 1)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_pooling.py" startline="504" endline="525" pcid="1936">
    def test_augment_images__kernel_size_is_two__single_channel(self):
        aug = iaa.AveragePooling(2, keep_size=False)

        image = np.uint8([
            [50-2, 50-1, 120-4, 120+4],
            [50+1, 50+2, 120+1, 120-1]
        ])
        image = image[:, :, np.newaxis]

        expected = np.uint8([
            [50, 120]
        ])
        expected = expected[:, :, np.newaxis]

        image_aug = aug.augment_image(image)

        diff = np.abs(image_aug.astype(np.int32) - expected)
        assert image_aug.dtype.name == "uint8"
        assert image_aug.shape == (1, 2, 1)
        assert np.all(diff <= 1)


</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_pooling.py" startline="413" endline="432" pcid="1932">
    def test_augment_images__kernel_size_is_two__four_channels(self):
        aug = iaa.AveragePooling(2, keep_size=False)

        image = np.uint8([
            [50-2, 50-1, 120-4, 120+4],
            [50+1, 50+2, 120+1, 120-1]
        ])
        image = np.tile(image[:, :, np.newaxis], (1, 1, 4))

        expected = np.uint8([
            [50, 120]
        ])
        expected = np.tile(expected[:, :, np.newaxis], (1, 1, 4))

        image_aug = aug.augment_image(image)
        diff = np.abs(image_aug.astype(np.int32) - expected)
        assert image_aug.dtype.name == "uint8"
        assert image_aug.shape == (1, 2, 4)
        assert np.all(diff <= 1)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_pooling.py" startline="482" endline="503" pcid="1935">
    def test_augment_images__kernel_size_is_two__keep_size(self):
        aug = iaa.AveragePooling(2, keep_size=True)

        image = np.uint8([
            [50-2, 50-1, 120-4, 120+4],
            [50+1, 50+2, 120+1, 120-1]
        ])
        image = np.tile(image[:, :, np.newaxis], (1, 1, 3))

        expected = np.uint8([
            [50, 50, 120, 120],
            [50, 50, 120, 120]
        ])
        expected = np.tile(expected[:, :, np.newaxis], (1, 1, 3))

        image_aug = aug.augment_image(image)

        diff = np.abs(image_aug.astype(np.int32) - expected)
        assert image_aug.dtype.name == "uint8"
        assert image_aug.shape == (2, 4, 3)
        assert np.all(diff <= 1)

</source>
</class>

<class classid="107" nclones="2" nlines="19" similarity="73">
<source file="systems/imgaug-0.3.0/test/augmenters/test_pooling.py" startline="433" endline="455" pcid="1933">
    def test_augment_images__kernel_size_differs(self):
        aug = iaa.AveragePooling(
            (iap.Deterministic(3), iap.Deterministic(2)),
            keep_size=False)

        image = np.uint8([
            [50-2, 50-1, 120-4, 120+4],
            [50+1, 50+2, 120+2, 120-1],
            [50-5, 50+5, 120-2, 120+1],
        ])
        image = np.tile(image[:, :, np.newaxis], (1, 1, 3))

        expected = np.uint8([
            [50, 120]
        ])
        expected = np.tile(expected[:, :, np.newaxis], (1, 1, 3))

        image_aug = aug.augment_image(image)
        diff = np.abs(image_aug.astype(np.int32) - expected)
        assert image_aug.dtype.name == "uint8"
        assert image_aug.shape == (1, 2, 3)
        assert np.all(diff <= 1)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_pooling.py" startline="456" endline="481" pcid="1934">
    def test_augment_images__kernel_size_differs__requires_padding(self):
        aug = iaa.AveragePooling(
            (iap.Deterministic(3), iap.Deterministic(1)),
            keep_size=False)

        image = np.uint8([
            [50-2, 50-1, 120-4, 120+4],
            [50+1, 50+2, 120+2, 120-1]
        ])
        image = np.tile(image[:, :, np.newaxis], (1, 1, 3))

        expected = np.uint8([
            [(50-2 + 50+1 + 50-2)/3,
             (50-1 + 50+2 + 50-1)/3,
             (120-4 + 120+2 + 120-4)/3,
             (120+4 + 120-1 + 120+4)/3]
        ])
        expected = np.tile(expected[:, :, np.newaxis], (1, 1, 3))

        image_aug = aug.augment_image(image)

        diff = np.abs(image_aug.astype(np.int32) - expected)
        assert image_aug.dtype.name == "uint8"
        assert image_aug.shape == (1, 4, 3)
        assert np.all(diff <= 1)

</source>
</class>

<class classid="108" nclones="3" nlines="13" similarity="84">
<source file="systems/imgaug-0.3.0/test/augmenters/test_pooling.py" startline="554" endline="571" pcid="1939">
    def test_augment_images__different_channels(self):
        aug = iaa.MaxPooling((iap.Deterministic(1), iap.Deterministic(4)),
                             keep_size=False)

        c1 = np.arange(start=1, stop=8+1).reshape((1, 8, 1))
        c2 = (100 + np.arange(start=1, stop=8+1)).reshape((1, 8, 1))
        image = np.dstack([c1, c2]).astype(np.uint8)

        c1_expected = np.uint8([4, 8]).reshape((1, 2, 1))
        c2_expected = np.uint8([100+4, 100+8]).reshape((1, 2, 1))
        image_expected = np.dstack([c1_expected, c2_expected])

        image_aug = aug.augment_image(image)
        diff = np.abs(image_aug.astype(np.int32) - image_expected)
        assert image_aug.shape == (1, 2, 2)
        assert np.all(diff <= 1)


</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_pooling.py" startline="647" endline="662" pcid="1945">
    def test_augment_images__different_channels(self):
        aug = iaa.MinPooling((iap.Deterministic(1), iap.Deterministic(3)),
                             keep_size=False)

        c1 = np.arange(start=1, stop=9+1).reshape((1, 9, 1))
        c2 = (100 + np.arange(start=1, stop=9+1)).reshape((1, 9, 1))
        image = np.dstack([c1, c2]).astype(np.uint8)

        c1_expected = np.uint8([2, 5, 8]).reshape((1, 3, 1))
        c2_expected = np.uint8([100+2, 100+5, 100+8]).reshape((1, 3, 1))
        image_expected = np.dstack([c1_expected, c2_expected])

        image_aug = aug.augment_image(image)
        diff = np.abs(image_aug.astype(np.int32) - image_expected)
        assert image_aug.shape == (1, 3, 2)
        assert np.all(diff <= 1)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_pooling.py" startline="600" endline="617" pcid="1942">
    def test_augment_images__different_channels(self):
        aug = iaa.MinPooling((iap.Deterministic(1), iap.Deterministic(4)),
                             keep_size=False)

        c1 = np.arange(start=1, stop=8+1).reshape((1, 8, 1))
        c2 = (100 + np.arange(start=1, stop=8+1)).reshape((1, 8, 1))
        image = np.dstack([c1, c2]).astype(np.uint8)

        c1_expected = np.uint8([1, 5]).reshape((1, 2, 1))
        c2_expected = np.uint8([100+1, 100+4]).reshape((1, 2, 1))
        image_expected = np.dstack([c1_expected, c2_expected])

        image_aug = aug.augment_image(image)
        diff = np.abs(image_aug.astype(np.int32) - image_expected)
        assert image_aug.shape == (1, 2, 2)
        assert np.all(diff <= 1)


</source>
</class>

<class classid="109" nclones="3" nlines="10" similarity="70">
<source file="systems/imgaug-0.3.0/test/augmenters/test_segmentation.py" startline="185" endline="196" pcid="1961">
    def test_get_parameters(self):
        aug = iaa.Superpixels(
            p_replace=0.5, n_segments=2, max_size=100, interpolation="nearest")
        params = aug.get_parameters()
        assert isinstance(params[0], iap.Binomial)
        assert isinstance(params[0].p, iap.Deterministic)
        assert isinstance(params[1], iap.Deterministic)
        assert 0.5 - 1e-4 < params[0].p.value < 0.5 + 1e-4
        assert params[1].value == 2
        assert params[2] == 100
        assert params[3] == "nearest"

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="3274" endline="3285" pcid="2225">
                assert np.all(image_aug == 255)
                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == image.shape

    def test_get_parameters(self):
        # test get_parameters()
        aug = iaa.Invert(p=0.5, per_channel=False, min_value=10, max_value=20)
        params = aug.get_parameters()
        assert isinstance(params[0], iap.Binomial)
        assert isinstance(params[0].p, iap.Deterministic)
        assert isinstance(params[1], iap.Deterministic)
        assert 0.5 - 1e-4 < params[0].p.value < 0.5 + 1e-4
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="2592" endline="2603" pcid="2175">
                assert np.all(image_aug == 1)
                assert image_aug.dtype.name == "uint8"
                assert image_aug.shape == image.shape

    def test_get_parameters(self):
        # test get_parameters()
        aug = iaa.ReplaceElementwise(mask=0.5, replacement=2, per_channel=False)
        params = aug.get_parameters()
        assert isinstance(params[0], iap.Binomial)
        assert isinstance(params[0].p, iap.Deterministic)
        assert isinstance(params[1], iap.Deterministic)
        assert isinstance(params[2], iap.Deterministic)
</source>
</class>

<class classid="110" nclones="2" nlines="17" similarity="72">
<source file="systems/imgaug-0.3.0/test/augmenters/test_segmentation.py" startline="351" endline="371" pcid="1973">

    def test_replace_mask_is_mixed_integrationtest(self):
        image = np.uint8([
            [0, 1, 200, 201],
            [2, 3, 202, 203]
        ])
        cell_coordinates = np.float32([
            [1.0, 1.0],
            [3.0, 1.0]
        ])
        replace_mask = np.array([False, True], dtype=bool)

        image_seg = iaa.segment_voronoi(image, cell_coordinates, replace_mask)

        pixels2 = image[0:2, 2:4]
        avg_color2 = np.sum(pixels2).astype(np.float32) / pixels2.size
        image_expected = np.uint8([
            [0, 1, avg_color2, avg_color2],
            [2, 3, avg_color2, avg_color2],
        ])
        assert np.array_equal(image_seg, image_expected)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_segmentation.py" startline="372" endline="394" pcid="1974">

    def test_replace_mask_is_none_integrationtest(self):
        image = np.uint8([
            [0, 1, 200, 201],
            [2, 3, 202, 203]
        ])
        cell_coordinates = np.float32([
            [1.0, 1.0],
            [3.0, 1.0]
        ])
        replace_mask = None

        image_seg = iaa.segment_voronoi(image, cell_coordinates, replace_mask)

        pixels1 = image[0:2, 0:2]
        pixels2 = image[0:2, 2:4]
        avg_color1 = np.sum(pixels1).astype(np.float32) / pixels1.size
        avg_color2 = np.sum(pixels2).astype(np.float32) / pixels2.size
        image_expected = np.uint8([
            [avg_color1, avg_color1, avg_color2, avg_color2],
            [avg_color1, avg_color1, avg_color2, avg_color2],
        ])
        assert np.array_equal(image_seg, image_expected)
</source>
</class>

<class classid="111" nclones="4" nlines="10" similarity="81">
<source file="systems/imgaug-0.3.0/test/augmenters/test_segmentation.py" startline="495" endline="508" pcid="1982">

    def test_max_size_is_none(self):
        image = np.zeros((10, 20, 3), dtype=np.uint8)
        sampler = iaa.RegularGridPointsSampler(1, 1)
        aug = iaa.Voronoi(sampler, max_size=None)

        mock_imresize = mock.MagicMock()
        mock_imresize.return_value = image

        fname = "imgaug.imresize_single_image"
        with mock.patch(fname, mock_imresize):
            _image_aug = aug(image=image)

        assert mock_imresize.call_count == 0
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_segmentation.py" startline="509" endline="522" pcid="1983">

    def test_max_size_is_int_image_not_too_large(self):
        image = np.zeros((10, 20, 3), dtype=np.uint8)
        sampler = iaa.RegularGridPointsSampler(1, 1)
        aug = iaa.Voronoi(sampler, max_size=100)

        mock_imresize = mock.MagicMock()
        mock_imresize.return_value = image

        fname = "imgaug.imresize_single_image"
        with mock.patch(fname, mock_imresize):
            _image_aug = aug(image=image)

        assert mock_imresize.call_count == 0
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_segmentation.py" startline="523" endline="537" pcid="1984">

    def test_max_size_is_int_image_too_large(self):
        image = np.zeros((10, 20, 3), dtype=np.uint8)
        sampler = iaa.RegularGridPointsSampler(1, 1)
        aug = iaa.Voronoi(sampler, max_size=10)

        mock_imresize = mock.MagicMock()
        mock_imresize.return_value = image

        fname = "imgaug.imresize_single_image"
        with mock.patch(fname, mock_imresize):
            _image_aug = aug(image=image)

        assert mock_imresize.call_count == 1
        assert mock_imresize.call_args_list[0][0][1] == (5, 10)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_segmentation.py" startline="538" endline="552" pcid="1985">

    def test_interpolation(self):
        image = np.zeros((10, 20, 3), dtype=np.uint8)
        sampler = iaa.RegularGridPointsSampler(1, 1)
        aug = iaa.Voronoi(sampler, max_size=10, interpolation="cubic")

        mock_imresize = mock.MagicMock()
        mock_imresize.return_value = image

        fname = "imgaug.imresize_single_image"
        with mock.patch(fname, mock_imresize):
            _image_aug = aug(image=image)

        assert mock_imresize.call_count == 1
        assert mock_imresize.call_args_list[0][1]["interpolation"] == "cubic"
</source>
</class>

<class classid="112" nclones="3" nlines="11" similarity="83">
<source file="systems/imgaug-0.3.0/test/augmenters/test_segmentation.py" startline="614" endline="628" pcid="1995">

    def test_p_replace_is_zero(self):
        image = np.zeros((50, 50), dtype=np.uint8)
        sampler = iaa.RegularGridPointsSampler(50, 50)
        aug = iaa.Voronoi(sampler, p_replace=0.0)

        mock_segment_voronoi = mock.MagicMock()
        mock_segment_voronoi.return_value = image[..., np.newaxis]

        fname = "imgaug.augmenters.segmentation.segment_voronoi"
        with mock.patch(fname, mock_segment_voronoi):
            _image_aug = aug(image=image)

        replace_mask = mock_segment_voronoi.call_args_list[0][0][2]
        assert not np.any(replace_mask)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_segmentation.py" startline="644" endline="659" pcid="1997">

    def test_p_replace_is_50_percent(self):
        image = np.zeros((200, 200), dtype=np.uint8)
        sampler = iaa.RegularGridPointsSampler(200, 200)
        aug = iaa.Voronoi(sampler, p_replace=0.5)

        mock_segment_voronoi = mock.MagicMock()
        mock_segment_voronoi.return_value = image[..., np.newaxis]

        fname = "imgaug.augmenters.segmentation.segment_voronoi"
        with mock.patch(fname, mock_segment_voronoi):
            _image_aug = aug(image=image)

        replace_mask = mock_segment_voronoi.call_args_list[0][0][2]
        replace_fraction = np.average(replace_mask.astype(np.float32))
        assert 0.4 <= replace_fraction <= 0.6
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_segmentation.py" startline="629" endline="643" pcid="1996">

    def test_p_replace_is_one(self):
        image = np.zeros((50, 50), dtype=np.uint8)
        sampler = iaa.RegularGridPointsSampler(50, 50)
        aug = iaa.Voronoi(sampler, p_replace=1.0)

        mock_segment_voronoi = mock.MagicMock()
        mock_segment_voronoi.return_value = image[..., np.newaxis]

        fname = "imgaug.augmenters.segmentation.segment_voronoi"
        with mock.patch(fname, mock_segment_voronoi):
            _image_aug = aug(image=image)

        replace_mask = mock_segment_voronoi.call_args_list[0][0][2]
        assert np.all(replace_mask)
</source>
</class>

<class classid="113" nclones="3" nlines="28" similarity="70">
<source file="systems/imgaug-0.3.0/test/augmenters/test_segmentation.py" startline="766" endline="793" pcid="2004">
class TestUniformVoronoi(unittest.TestCase):
    def test___init___(self):
        rs = iarandom.RNG(10)

        mock_voronoi = mock.MagicMock()
        mock_voronoi.return_value = mock_voronoi
        fname = "imgaug.augmenters.segmentation.Voronoi.__init__"
        with mock.patch(fname, mock_voronoi):
            _ = iaa.UniformVoronoi(
                100,
                p_replace=0.5,
                max_size=5,
                interpolation="cubic",
                name="foo",
                deterministic=True,
                random_state=rs
            )

        assert mock_voronoi.call_count == 1
        assert isinstance(mock_voronoi.call_args_list[0][1]["points_sampler"],
                          iaa.UniformPointsSampler)
        assert np.isclose(mock_voronoi.call_args_list[0][1]["p_replace"],
                          0.5)
        assert mock_voronoi.call_args_list[0][1]["max_size"] == 5
        assert mock_voronoi.call_args_list[0][1]["interpolation"] == "cubic"
        assert mock_voronoi.call_args_list[0][1]["name"] == "foo"
        assert mock_voronoi.call_args_list[0][1]["deterministic"] is True
        assert mock_voronoi.call_args_list[0][1]["random_state"] is rs
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_segmentation.py" startline="815" endline="849" pcid="2006">
class TestRegularGridVoronoi(unittest.TestCase):
    def test___init___(self):
        rs = iarandom.RNG(10)

        mock_voronoi = mock.MagicMock()
        mock_voronoi.return_value = mock_voronoi
        fname = "imgaug.augmenters.segmentation.Voronoi.__init__"
        with mock.patch(fname, mock_voronoi):
            _ = iaa.RegularGridVoronoi(
                10,
                20,
                p_drop_points=0.6,
                p_replace=0.5,
                max_size=5,
                interpolation="cubic",
                name="foo",
                deterministic=True,
                random_state=rs
            )

        assert mock_voronoi.call_count == 1
        ps = mock_voronoi.call_args_list[0][1]["points_sampler"]
        assert isinstance(ps, iaa.DropoutPointsSampler)
        assert isinstance(ps.other_points_sampler,
                          iaa.RegularGridPointsSampler)
        assert np.isclose(ps.p_drop.p.value, 1-0.6)
        assert ps.other_points_sampler.n_rows.value == 10
        assert ps.other_points_sampler.n_cols.value == 20
        assert np.isclose(mock_voronoi.call_args_list[0][1]["p_replace"],
                          0.5)
        assert mock_voronoi.call_args_list[0][1]["max_size"] == 5
        assert mock_voronoi.call_args_list[0][1]["interpolation"] == "cubic"
        assert mock_voronoi.call_args_list[0][1]["name"] == "foo"
        assert mock_voronoi.call_args_list[0][1]["deterministic"] is True
        assert mock_voronoi.call_args_list[0][1]["random_state"] is rs
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_segmentation.py" startline="877" endline="911" pcid="2008">
class TestRelativeRegularGridVoronoi(unittest.TestCase):
    def test___init___(self):
        rs = iarandom.RNG(10)

        mock_voronoi = mock.MagicMock()
        mock_voronoi.return_value = mock_voronoi
        fname = "imgaug.augmenters.segmentation.Voronoi.__init__"
        with mock.patch(fname, mock_voronoi):
            _ = iaa.RelativeRegularGridVoronoi(
                0.1,
                0.2,
                p_drop_points=0.6,
                p_replace=0.5,
                max_size=5,
                interpolation="cubic",
                name="foo",
                deterministic=True,
                random_state=rs
            )

        assert mock_voronoi.call_count == 1
        ps = mock_voronoi.call_args_list[0][1]["points_sampler"]
        assert isinstance(ps, iaa.DropoutPointsSampler)
        assert isinstance(ps.other_points_sampler,
                          iaa.RelativeRegularGridPointsSampler)
        assert np.isclose(ps.p_drop.p.value, 1-0.6)
        assert np.isclose(ps.other_points_sampler.n_rows_frac.value, 0.1)
        assert np.isclose(ps.other_points_sampler.n_cols_frac.value, 0.2)
        assert np.isclose(mock_voronoi.call_args_list[0][1]["p_replace"],
                          0.5)
        assert mock_voronoi.call_args_list[0][1]["max_size"] == 5
        assert mock_voronoi.call_args_list[0][1]["interpolation"] == "cubic"
        assert mock_voronoi.call_args_list[0][1]["name"] == "foo"
        assert mock_voronoi.call_args_list[0][1]["deterministic"] is True
        assert mock_voronoi.call_args_list[0][1]["random_state"] is rs
</source>
</class>

<class classid="114" nclones="3" nlines="10" similarity="81">
<source file="systems/imgaug-0.3.0/test/augmenters/test_segmentation.py" startline="958" endline="969" pcid="2013">

    def test_sample_points(self):
        image = np.zeros((10, 10, 3), dtype=np.uint8)
        sampler = iaa.RegularGridPointsSampler(2, 2)
        points = sampler.sample_points([image], iarandom.RNG(1))[0]
        assert len(points) == 4
        assert np.allclose(points, [
            [2.5, 2.5],
            [7.5, 2.5],
            [2.5, 7.5],
            [7.5, 7.5]
        ])
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_segmentation.py" startline="1107" endline="1118" pcid="2026">

    def test_sample_points(self):
        image = np.zeros((10, 10, 3), dtype=np.uint8)
        sampler = iaa.RelativeRegularGridPointsSampler(0.2, 0.2)
        points = sampler.sample_points([image], iarandom.RNG(1))[0]
        assert len(points) == 4
        assert np.allclose(points, [
            [2.5, 2.5],
            [7.5, 2.5],
            [2.5, 7.5],
            [7.5, 7.5]
        ])
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_segmentation.py" startline="1534" endline="1548" pcid="2060">

    def test_max_is_above_point_count(self):
        image = np.zeros((10, 10, 3), dtype=np.uint8)
        other = iaa.RegularGridPointsSampler(2, 2)
        sampler = iaa.SubsamplingPointsSampler(other, 100)

        observed = sampler.sample_points([image], 1)[0]

        assert len(observed) == 4
        assert np.allclose(observed, [
            [2.5, 2.5],
            [7.5, 2.5],
            [2.5, 7.5],
            [7.5, 7.5]
        ])
</source>
</class>

<class classid="115" nclones="2" nlines="12" similarity="83">
<source file="systems/imgaug-0.3.0/test/augmenters/test_segmentation.py" startline="970" endline="985" pcid="2014">

    def test_sample_points_stochastic(self):
        image = np.zeros((10, 10, 3), dtype=np.uint8)
        sampler = iaa.RegularGridPointsSampler(1, iap.Choice([1, 2]))
        points = sampler.sample_points([image], iarandom.RNG(1))[0]

        matches_single_point = np.allclose(points, [
            [5.0, 5.0]
        ])
        matches_two_points = np.allclose(points, [
            [2.5, 5.0],
            [7.5, 5.0]
        ])

        assert len(points) in [1, 2]
        assert matches_single_point or matches_two_points
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_segmentation.py" startline="1119" endline="1135" pcid="2027">

    def test_sample_points_stochastic(self):
        image = np.zeros((10, 10, 3), dtype=np.uint8)
        sampler = iaa.RelativeRegularGridPointsSampler(0.1,
                                                       iap.Choice([0.1, 0.2]))
        points = sampler.sample_points([image], iarandom.RNG(1))[0]

        matches_single_point = np.allclose(points, [
            [5.0, 5.0]
        ])
        matches_two_points = np.allclose(points, [
            [2.5, 5.0],
            [7.5, 5.0]
        ])

        assert len(points) in [1, 2]
        assert matches_single_point or matches_two_points
</source>
</class>

<class classid="116" nclones="2" nlines="14" similarity="92">
<source file="systems/imgaug-0.3.0/test/augmenters/test_segmentation.py" startline="1292" endline="1308" pcid="2042">

    def test_random_state_propagates(self):
        image = np.zeros((1, 1, 3), dtype=np.uint8)
        points = np.linspace(0.0+0.9, 1000.0-0.9, num=1)
        points = np.stack([points, points], axis=-1)
        other = _FixedPointsSampler(points)
        sampler = iaa.DropoutPointsSampler(other, 0.5)

        _ = sampler.sample_points([image], 1)[0]
        rs_s1_1 = other.last_random_state
        _ = sampler.sample_points([image], 1)[0]
        rs_s1_2 = other.last_random_state
        _ = sampler.sample_points([image], 2)[0]
        rs_s2_1 = other.last_random_state

        assert rs_s1_1.equals(rs_s1_2)
        assert not rs_s1_1.equals(rs_s2_1)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_segmentation.py" startline="1571" endline="1587" pcid="2063">

    def test_random_state_propagates(self):
        image = np.zeros((1, 1, 3), dtype=np.uint8)
        points = np.linspace(0.0+0.9, 1000.0-0.9, num=1)
        points = np.stack([points, points], axis=-1)
        other = _FixedPointsSampler(points)
        sampler = iaa.SubsamplingPointsSampler(other, 100)

        _ = sampler.sample_points([image], 1)[0]
        rs_s1_1 = other.last_random_state
        _ = sampler.sample_points([image], 1)[0]
        rs_s1_2 = other.last_random_state
        _ = sampler.sample_points([image], 2)[0]
        rs_s2_1 = other.last_random_state

        assert rs_s1_1.equals(rs_s1_2)
        assert not rs_s1_1.equals(rs_s2_1)
</source>
</class>

<class classid="117" nclones="8" nlines="13" similarity="84">
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="35" endline="50" pcid="2066">
    def test___init___bad_datatypes(self):
        # test exceptions for wrong parameter types
        got_exception = False
        try:
            _ = iaa.Add(value="test")
        except Exception:
            got_exception = True
        assert got_exception

        got_exception = False
        try:
            _ = iaa.Add(value=1, per_channel="test")
        except Exception:
            got_exception = True
        assert got_exception

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="516" endline="531" pcid="2085">
    def test___init___bad_datatypes(self):
        # test exceptions for wrong parameter types
        got_exception = False
        try:
            _aug = iaa.AddElementwise(value="test")
        except Exception:
            got_exception = True
        assert got_exception

        got_exception = False
        try:
            _aug = iaa.AddElementwise(value=1, per_channel="test")
        except Exception:
            got_exception = True
        assert got_exception

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="2848" endline="2863" pcid="2188">
        for nb_seen in hist:
            density = nb_seen / len(ps)
            assert density - tolerance < density < density + tolerance

    def test___init___bad_datatypes(self):
        # test exceptions for wrong parameter types
        got_exception = False
        try:
            _ = iaa.CoarseSaltAndPepper(p="test", size_px=100)
        except Exception:
            got_exception = True
        assert got_exception

        got_exception = False
        try:
            _ = iaa.CoarseSaltAndPepper(p=0.5, size_px=None, size_percent=None)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="3217" endline="3232" pcid="2222">
        observed = aug_det.augment_keypoints(keypoints)
        expected = keypoints
        assert keypoints_equal(observed, expected)

    def test___init___bad_datatypes(self):
        # test exceptions for wrong parameter types
        got_exception = False
        try:
            _ = iaa.Invert(p="test")
        except Exception:
            got_exception = True
        assert got_exception

        got_exception = False
        try:
            _ = iaa.Invert(p=0.5, per_channel="test")
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="2535" endline="2550" pcid="2172">
                seen[1] += 1
        assert 150 < seen[0] < 250
        assert 150 < seen[1] < 250

    def test___init___bad_datatypes(self):
        # test exceptions for wrong parameter types
        got_exception = False
        try:
            _aug = iaa.ReplaceElementwise(mask="test", replacement=1)
        except Exception:
            got_exception = True
        assert got_exception

        got_exception = False
        try:
            _aug = iaa.ReplaceElementwise(mask=1, replacement=1, per_channel="test")
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="2067" endline="2082" pcid="2156">
                seen[1] += 1
        assert 150 < seen[0] < 250
        assert 150 < seen[1] < 250

    def test___init___bad_datatypes(self):
        # test exceptions for wrong parameter types
        got_exception = False
        try:
            _aug = iaa.MultiplyElementwise(mul="test")
        except Exception:
            got_exception = True
        assert got_exception

        got_exception = False
        try:
            _aug = iaa.MultiplyElementwise(mul=1, per_channel="test")
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="1173" endline="1188" pcid="2112">
    def test___init___bad_datatypes(self):
        # test exceptions for wrong parameter types
        got_exception = False
        try:
            _ = iaa.AdditiveGaussianNoise(loc="test")
        except Exception:
            got_exception = True
        assert got_exception

        got_exception = False
        try:
            _ = iaa.AdditiveGaussianNoise(scale="test")
        except Exception:
            got_exception = True
        assert got_exception

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="1572" endline="1587" pcid="2139">
                seen[1] += 1
        assert 150 < seen[0] < 250
        assert 150 < seen[1] < 250

    def test___init___bad_datatypes(self):
        # test exceptions for wrong parameter types
        got_exception = False
        try:
            _ = iaa.Multiply(mul="test")
        except Exception:
            got_exception = True
        assert got_exception

        got_exception = False
        try:
            _ = iaa.Multiply(mul=1, per_channel="test")
</source>
</class>

<class classid="118" nclones="13" nlines="19" similarity="73">
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="51" endline="76" pcid="2067">
    def test_add_zero(self):
        # no add, shouldnt change anything
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        images = np.array([base_img])
        images_list = [base_img]

        aug = iaa.Add(value=0)
        aug_det = aug.to_deterministic()

        observed = aug.augment_images(images)
        expected = images
        assert np.array_equal(observed, expected)
        assert observed.shape == (1, 3, 3, 1)

        observed = aug.augment_images(images_list)
        expected = images_list
        assert array_equal_lists(observed, expected)

        observed = aug_det.augment_images(images)
        expected = images
        assert np.array_equal(observed, expected)

        observed = aug_det.augment_images(images_list)
        expected = images_list
        assert array_equal_lists(observed, expected)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="1945" endline="1970" pcid="2150">
        observed = aug_det.augment_images(images_list)
        expected = [np.ones((3, 3, 1), dtype=np.uint8) * 120]
        assert array_equal_lists(observed, expected)

    def test_mul_is_below_one(self):
        # multiply <1.0
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        images = np.array([base_img])
        images_list = [base_img]

        aug = iaa.MultiplyElementwise(mul=0.8)
        aug_det = aug.to_deterministic()

        observed = aug.augment_images(images)
        expected = np.ones((1, 3, 3, 1), dtype=np.uint8) * 80
        assert np.array_equal(observed, expected)
        assert observed.shape == (1, 3, 3, 1)

        observed = aug.augment_images(images_list)
        expected = [np.ones((3, 3, 1), dtype=np.uint8) * 80]
        assert array_equal_lists(observed, expected)

        observed = aug_det.augment_images(images)
        expected = np.ones((1, 3, 3, 1), dtype=np.uint8) * 80
        assert np.array_equal(observed, expected)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="1893" endline="1918" pcid="2148">
class TestMultiplyElementwise(unittest.TestCase):
    def setUp(self):
        reseed()

    def test_mul_is_one(self):
        # no multiply, shouldnt change anything
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        images = np.array([base_img])
        images_list = [base_img]

        aug = iaa.MultiplyElementwise(mul=1.0)
        aug_det = aug.to_deterministic()

        observed = aug.augment_images(images)
        expected = images
        assert np.array_equal(observed, expected)
        assert observed.shape == (1, 3, 3, 1)

        observed = aug.augment_images(images_list)
        expected = images_list
        assert array_equal_lists(observed, expected)

        observed = aug_det.augment_images(images)
        expected = images
        assert np.array_equal(observed, expected)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="77" endline="102" pcid="2068">
    def test_add_one(self):
        # add > 0
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        images = np.array([base_img])
        images_list = [base_img]

        aug = iaa.Add(value=1)
        aug_det = aug.to_deterministic()

        observed = aug.augment_images(images)
        expected = images + 1
        assert np.array_equal(observed, expected)
        assert observed.shape == (1, 3, 3, 1)

        observed = aug.augment_images(images_list)
        expected = [images_list[0] + 1]
        assert array_equal_lists(observed, expected)

        observed = aug_det.augment_images(images)
        expected = images + 1
        assert np.array_equal(observed, expected)

        observed = aug_det.augment_images(images_list)
        expected = [images_list[0] + 1]
        assert array_equal_lists(observed, expected)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="532" endline="557" pcid="2086">
    def test_add_zero(self):
        # no add, shouldnt change anything
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        images = np.array([base_img])
        images_list = [base_img]

        aug = iaa.AddElementwise(value=0)
        aug_det = aug.to_deterministic()

        observed = aug.augment_images(images)
        expected = images
        assert np.array_equal(observed, expected)
        assert observed.shape == (1, 3, 3, 1)

        observed = aug.augment_images(images_list)
        expected = images_list
        assert array_equal_lists(observed, expected)

        observed = aug_det.augment_images(images)
        expected = images
        assert np.array_equal(observed, expected)

        observed = aug_det.augment_images(images_list)
        expected = images_list
        assert array_equal_lists(observed, expected)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="1919" endline="1944" pcid="2149">
        observed = aug_det.augment_images(images_list)
        expected = images_list
        assert array_equal_lists(observed, expected)

    def test_mul_is_above_one(self):
        # multiply >1.0
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        images = np.array([base_img])
        images_list = [base_img]

        aug = iaa.MultiplyElementwise(mul=1.2)
        aug_det = aug.to_deterministic()

        observed = aug.augment_images(images)
        expected = np.ones((1, 3, 3, 1), dtype=np.uint8) * 120
        assert np.array_equal(observed, expected)
        assert observed.shape == (1, 3, 3, 1)

        observed = aug.augment_images(images_list)
        expected = [np.ones((3, 3, 1), dtype=np.uint8) * 120]
        assert array_equal_lists(observed, expected)

        observed = aug_det.augment_images(images)
        expected = np.ones((1, 3, 3, 1), dtype=np.uint8) * 120
        assert np.array_equal(observed, expected)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="558" endline="583" pcid="2087">
    def test_add_one(self):
        # add > 0
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        images = np.array([base_img])
        images_list = [base_img]

        aug = iaa.AddElementwise(value=1)
        aug_det = aug.to_deterministic()

        observed = aug.augment_images(images)
        expected = images + 1
        assert np.array_equal(observed, expected)
        assert observed.shape == (1, 3, 3, 1)

        observed = aug.augment_images(images_list)
        expected = [images_list[0] + 1]
        assert array_equal_lists(observed, expected)

        observed = aug_det.augment_images(images)
        expected = images + 1
        assert np.array_equal(observed, expected)

        observed = aug_det.augment_images(images_list)
        expected = [images_list[0] + 1]
        assert array_equal_lists(observed, expected)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="1423" endline="1448" pcid="2132">
class TestMultiply(unittest.TestCase):
    def setUp(self):
        reseed()

    def test_mul_is_one(self):
        # no multiply, shouldnt change anything
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        images = np.array([base_img])
        images_list = [base_img]

        aug = iaa.Multiply(mul=1.0)
        aug_det = aug.to_deterministic()

        observed = aug.augment_images(images)
        expected = images
        assert np.array_equal(observed, expected)
        assert observed.shape == (1, 3, 3, 1)

        observed = aug.augment_images(images_list)
        expected = images_list
        assert array_equal_lists(observed, expected)

        observed = aug_det.augment_images(images)
        expected = images
        assert np.array_equal(observed, expected)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="1449" endline="1474" pcid="2133">
        observed = aug_det.augment_images(images_list)
        expected = images_list
        assert array_equal_lists(observed, expected)

    def test_mul_is_above_one(self):
        # multiply >1.0
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        images = np.array([base_img])
        images_list = [base_img]

        aug = iaa.Multiply(mul=1.2)
        aug_det = aug.to_deterministic()

        observed = aug.augment_images(images)
        expected = np.ones((1, 3, 3, 1), dtype=np.uint8) * 120
        assert np.array_equal(observed, expected)
        assert observed.shape == (1, 3, 3, 1)

        observed = aug.augment_images(images_list)
        expected = [np.ones((3, 3, 1), dtype=np.uint8) * 120]
        assert array_equal_lists(observed, expected)

        observed = aug_det.augment_images(images)
        expected = np.ones((1, 3, 3, 1), dtype=np.uint8) * 120
        assert np.array_equal(observed, expected)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="2396" endline="2421" pcid="2165">
class TestReplaceElementwise(unittest.TestCase):
    def setUp(self):
        reseed()

    def test_mask_is_always_zero(self):
        # no replace, shouldnt change anything
        base_img = np.ones((3, 3, 1), dtype=np.uint8) + 99
        images = np.array([base_img])
        images_list = [base_img]

        aug = iaa.ReplaceElementwise(mask=0, replacement=0)
        aug_det = aug.to_deterministic()

        observed = aug.augment_images(images)
        expected = images
        assert np.array_equal(observed, expected)
        assert observed.shape == (1, 3, 3, 1)

        observed = aug.augment_images(images_list)
        expected = images_list
        assert array_equal_lists(observed, expected)

        observed = aug_det.augment_images(images)
        expected = images
        assert np.array_equal(observed, expected)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="1203" endline="1227" pcid="2115">
    def test_p_is_zero(self):
        # no dropout, shouldnt change anything
        base_img = np.ones((512, 512, 1), dtype=np.uint8) * 255
        images = np.array([base_img])
        images_list = [base_img]

        aug = iaa.Dropout(p=0)
        observed = aug.augment_images(images)
        expected = images
        assert np.array_equal(observed, expected)

        observed = aug.augment_images(images_list)
        expected = images_list
        assert array_equal_lists(observed, expected)

        # 100% dropout, should drop everything
        aug = iaa.Dropout(p=1.0)
        observed = aug.augment_images(images)
        expected = np.zeros((1, 512, 512, 1), dtype=np.uint8)
        assert np.array_equal(observed, expected)

        observed = aug.augment_images(images_list)
        expected = [np.zeros((512, 512, 1), dtype=np.uint8)]
        assert array_equal_lists(observed, expected)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="1475" endline="1500" pcid="2134">
        observed = aug_det.augment_images(images_list)
        expected = [np.ones((3, 3, 1), dtype=np.uint8) * 120]
        assert array_equal_lists(observed, expected)

    def test_mul_is_below_one(self):
        # multiply <1.0
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        images = np.array([base_img])
        images_list = [base_img]

        aug = iaa.Multiply(mul=0.8)
        aug_det = aug.to_deterministic()

        observed = aug.augment_images(images)
        expected = np.ones((1, 3, 3, 1), dtype=np.uint8) * 80
        assert np.array_equal(observed, expected)
        assert observed.shape == (1, 3, 3, 1)

        observed = aug.augment_images(images_list)
        expected = [np.ones((3, 3, 1), dtype=np.uint8) * 80]
        assert array_equal_lists(observed, expected)

        observed = aug_det.augment_images(images)
        expected = np.ones((1, 3, 3, 1), dtype=np.uint8) * 80
        assert np.array_equal(observed, expected)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="2422" endline="2447" pcid="2166">
        observed = aug_det.augment_images(images_list)
        expected = images_list
        assert array_equal_lists(observed, expected)

    def test_mask_is_always_one(self):
        # replace at 100 percent prob., should change everything
        base_img = np.ones((3, 3, 1), dtype=np.uint8) + 99
        images = np.array([base_img])
        images_list = [base_img]

        aug = iaa.ReplaceElementwise(mask=1, replacement=0)
        aug_det = aug.to_deterministic()

        observed = aug.augment_images(images)
        expected = np.zeros((1, 3, 3, 1), dtype=np.uint8)
        assert np.array_equal(observed, expected)
        assert observed.shape == (1, 3, 3, 1)

        observed = aug.augment_images(images_list)
        expected = [np.zeros((3, 3, 1), dtype=np.uint8)]
        assert array_equal_lists(observed, expected)

        observed = aug_det.augment_images(images)
        expected = np.zeros((1, 3, 3, 1), dtype=np.uint8)
        assert np.array_equal(observed, expected)

</source>
</class>

<class classid="119" nclones="2" nlines="18" similarity="100">
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="103" endline="127" pcid="2069">
    def test_minus_one(self):
        # add < 0
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        images = np.array([base_img])
        images_list = [base_img]

        aug = iaa.Add(value=-1)
        aug_det = aug.to_deterministic()

        observed = aug.augment_images(images)
        expected = images - 1
        assert np.array_equal(observed, expected)

        observed = aug.augment_images(images_list)
        expected = [images_list[0] - 1]
        assert array_equal_lists(observed, expected)

        observed = aug_det.augment_images(images)
        expected = images - 1
        assert np.array_equal(observed, expected)

        observed = aug_det.augment_images(images_list)
        expected = [images_list[0] - 1]
        assert array_equal_lists(observed, expected)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="584" endline="608" pcid="2088">
    def test_add_minus_one(self):
        # add < 0
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        images = np.array([base_img])
        images_list = [base_img]

        aug = iaa.AddElementwise(value=-1)
        aug_det = aug.to_deterministic()

        observed = aug.augment_images(images)
        expected = images - 1
        assert np.array_equal(observed, expected)

        observed = aug.augment_images(images_list)
        expected = [images_list[0] - 1]
        assert array_equal_lists(observed, expected)

        observed = aug_det.augment_images(images)
        expected = images - 1
        assert np.array_equal(observed, expected)

        observed = aug_det.augment_images(images_list)
        expected = [images_list[0] - 1]
        assert array_equal_lists(observed, expected)

</source>
</class>

<class classid="120" nclones="2" nlines="12" similarity="91">
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="128" endline="143" pcid="2070">
    def test_uint8_every_possible_value(self):
        # uint8, every possible addition for base value 127
        for value_type in [float, int]:
            for per_channel in [False, True]:
                for value in np.arange(-255, 255+1):
                    aug = iaa.Add(value=value_type(value), per_channel=per_channel)
                    expected = np.clip(127 + value_type(value), 0, 255)

                    img = np.full((1, 1), 127, dtype=np.uint8)
                    img_aug = aug.augment_image(img)
                    assert img_aug.item(0) == expected

                    img = np.full((1, 1, 3), 127, dtype=np.uint8)
                    img_aug = aug.augment_image(img)
                    assert np.all(img_aug == expected)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="609" endline="624" pcid="2089">
    def test_uint8_every_possible_value(self):
        # uint8, every possible addition for base value 127
        for value_type in [int]:
            for per_channel in [False, True]:
                for value in np.arange(-255, 255+1):
                    aug = iaa.AddElementwise(value=value_type(value), per_channel=per_channel)
                    expected = np.clip(127 + value_type(value), 0, 255)

                    img = np.full((1, 1), 127, dtype=np.uint8)
                    img_aug = aug.augment_image(img)
                    assert img_aug.item(0) == expected

                    img = np.full((1, 1, 3), 127, dtype=np.uint8)
                    img_aug = aug.augment_image(img)
                    assert np.all(img_aug == expected)

</source>
</class>

<class classid="121" nclones="6" nlines="12" similarity="75">
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="185" endline="200" pcid="2073">
    def test_keypoints_dont_change(self):
        # keypoints shouldnt be changed
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        keypoints = [ia.KeypointsOnImage([ia.Keypoint(x=0, y=0), ia.Keypoint(x=1, y=1),
                                          ia.Keypoint(x=2, y=2)], shape=base_img.shape)]

        aug = iaa.Add(value=1)
        aug_det = iaa.Add(value=1).to_deterministic()
        observed = aug.augment_keypoints(keypoints)
        expected = keypoints
        assert keypoints_equal(observed, expected)

        observed = aug_det.augment_keypoints(keypoints)
        expected = keypoints
        assert keypoints_equal(observed, expected)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="3200" endline="3216" pcid="2221">
                assert False
        assert 300 - 75 < seen[0] < 300 + 75
        assert 700 - 75 < seen[1] < 700 + 75

    def test_keypoints_dont_change(self):
        # keypoints shouldnt be changed
        zeros = np.zeros((4, 4, 3), dtype=np.uint8)

        keypoints = [ia.KeypointsOnImage([ia.Keypoint(x=0, y=0), ia.Keypoint(x=1, y=1),
                                          ia.Keypoint(x=2, y=2)], shape=zeros.shape)]

        aug = iaa.Invert(p=1.0)
        aug_det = iaa.Invert(p=1.0).to_deterministic()
        observed = aug.augment_keypoints(keypoints)
        expected = keypoints
        assert keypoints_equal(observed, expected)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="2481" endline="2496" pcid="2169">
        assert seen[2] <= 10
        assert 150 < seen[0] < 250
        assert 150 < seen[1] < 250

    def test_keypoints_dont_change(self):
        # keypoints shouldnt be changed
        base_img = np.ones((3, 3, 1), dtype=np.uint8) + 99
        keypoints = [ia.KeypointsOnImage([ia.Keypoint(x=0, y=0), ia.Keypoint(x=1, y=1),
                                          ia.Keypoint(x=2, y=2)], shape=base_img.shape)]

        aug = iaa.ReplaceElementwise(mask=iap.Binomial(p=0.5), replacement=0)
        aug_det = iaa.ReplaceElementwise(mask=iap.Binomial(p=0.5), replacement=0).to_deterministic()
        observed = aug.augment_keypoints(keypoints)
        expected = keypoints
        assert keypoints_equal(observed, expected)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="650" endline="665" pcid="2091">
    def test_keypoints_dont_change(self):
        # keypoints shouldnt be changed
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        keypoints = [ia.KeypointsOnImage([ia.Keypoint(x=0, y=0), ia.Keypoint(x=1, y=1),
                                          ia.Keypoint(x=2, y=2)], shape=base_img.shape)]

        aug = iaa.AddElementwise(value=1)
        aug_det = iaa.AddElementwise(value=1).to_deterministic()
        observed = aug.augment_keypoints(keypoints)
        expected = keypoints
        assert keypoints_equal(observed, expected)

        observed = aug_det.augment_keypoints(keypoints)
        expected = keypoints
        assert keypoints_equal(observed, expected)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="1971" endline="1986" pcid="2151">
        observed = aug_det.augment_images(images_list)
        expected = [np.ones((3, 3, 1), dtype=np.uint8) * 80]
        assert array_equal_lists(observed, expected)

    def test_keypoints_dont_change(self):
        # keypoints shouldnt be changed
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        keypoints = [ia.KeypointsOnImage([ia.Keypoint(x=0, y=0), ia.Keypoint(x=1, y=1),
                                          ia.Keypoint(x=2, y=2)], shape=base_img.shape)]

        aug = iaa.MultiplyElementwise(mul=1.2)
        aug_det = iaa.Multiply(mul=1.2).to_deterministic()
        observed = aug.augment_keypoints(keypoints)
        expected = keypoints
        assert keypoints_equal(observed, expected)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="1501" endline="1516" pcid="2135">
        observed = aug_det.augment_images(images_list)
        expected = [np.ones((3, 3, 1), dtype=np.uint8) * 80]
        assert array_equal_lists(observed, expected)

    def test_keypoints_dont_change(self):
        # keypoints shouldnt be changed
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        keypoints = [ia.KeypointsOnImage([ia.Keypoint(x=0, y=0), ia.Keypoint(x=1, y=1),
                                          ia.Keypoint(x=2, y=2)], shape=base_img.shape)]

        aug = iaa.Multiply(mul=1.2)
        aug_det = iaa.Multiply(mul=1.2).to_deterministic()
        observed = aug.augment_keypoints(keypoints)
        expected = keypoints
        assert keypoints_equal(observed, expected)

</source>
</class>

<class classid="122" nclones="5" nlines="14" similarity="80">
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="240" endline="256" pcid="2076">
    def test_per_channel_with_probability(self):
        # test channelwise with probability
        aug = iaa.Add(value=iap.Choice([0, 1]), per_channel=0.5)
        seen = [0, 0]
        for _ in sm.xrange(400):
            observed = aug.augment_image(np.zeros((1, 1, 20), dtype=np.uint8))
            assert observed.shape == (1, 1, 20)

            uq = np.unique(observed)
            per_channel = (len(uq) == 2)
            if per_channel:
                seen[0] += 1
            else:
                seen[1] += 1
        assert 150 < seen[0] < 250
        assert 150 < seen[1] < 250

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="2049" endline="2066" pcid="2155">
        values = np.unique(sums)
        assert all([(value in values) for value in [0, 1, 2, 3]])
        assert observed.shape == (100, 100, 3)

    def test_per_channel_with_probability(self):
        # test channelwise with probability
        aug = iaa.MultiplyElementwise(mul=iap.Choice([0, 1]), per_channel=0.5)
        seen = [0, 0]
        for _ in sm.xrange(400):
            observed = aug.augment_image(np.ones((20, 20, 3), dtype=np.uint8))
            assert observed.shape == (20, 20, 3)

            sums = np.sum(observed, axis=2)
            values = np.unique(sums)
            all_values_found = all([(value in values) for value in [0, 1, 2, 3]])
            if all_values_found:
                seen[0] += 1
            else:
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="727" endline="742" pcid="2095">
    def test_per_channel_with_probability(self):
        # test channelwise with probability
        aug = iaa.AddElementwise(value=iap.Choice([0, 1]), per_channel=0.5)
        seen = [0, 0]
        for _ in sm.xrange(400):
            observed = aug.augment_image(np.zeros((20, 20, 3), dtype=np.uint8))
            sums = np.sum(observed, axis=2)
            values = np.unique(sums)
            all_values_found = all([(value in values) for value in [0, 1, 2, 3]])
            if all_values_found:
                seen[0] += 1
            else:
                seen[1] += 1
        assert 150 < seen[0] < 250
        assert 150 < seen[1] < 250

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="2517" endline="2534" pcid="2171">
        sums = np.sum(observed, axis=2)
        values = np.unique(sums)
        assert all([(value in values) for value in [0, 1, 2, 3]])

    def test_per_channel_with_probability(self):
        # test channelwise with probability
        aug = iaa.ReplaceElementwise(mask=iap.Choice([0, 1]), replacement=1, per_channel=0.5)
        seen = [0, 0]
        for _ in sm.xrange(400):
            observed = aug.augment_image(np.zeros((20, 20, 3), dtype=np.uint8))
            assert observed.shape == (20, 20, 3)

            sums = np.sum(observed, axis=2)
            values = np.unique(sums)
            all_values_found = all([(value in values) for value in [0, 1, 2, 3]])
            if all_values_found:
                seen[0] += 1
            else:
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="1555" endline="1571" pcid="2138">
        assert 0 in uq
        assert 2 in uq
        assert len(uq) == 2

    def test_per_channel_with_probability(self):
        # test channelwise with probability
        aug = iaa.Multiply(mul=iap.Choice([0, 2]), per_channel=0.5)
        seen = [0, 0]
        for _ in sm.xrange(400):
            observed = aug.augment_image(np.ones((1, 1, 20), dtype=np.uint8))
            assert observed.shape == (1, 1, 20)

            uq = np.unique(observed)
            per_channel = (len(uq) == 2)
            if per_channel:
                seen[0] += 1
            else:
</source>
</class>

<class classid="123" nclones="2" nlines="21" similarity="100">
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="315" endline="339" pcid="2081">
    def test_other_dtypes_bool(self):
        image = np.zeros((3, 3), dtype=bool)
        aug = iaa.Add(value=1)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == np.bool_
        assert np.all(image_aug == 1)

        image = np.full((3, 3), True, dtype=bool)
        aug = iaa.Add(value=1)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == np.bool_
        assert np.all(image_aug == 1)

        image = np.full((3, 3), True, dtype=bool)
        aug = iaa.Add(value=-1)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == np.bool_
        assert np.all(image_aug == 0)

        image = np.full((3, 3), True, dtype=bool)
        aug = iaa.Add(value=-2)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == np.bool_
        assert np.all(image_aug == 0)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="800" endline="825" pcid="2100">
    def test_other_dtypes_bool(self):
        # bool
        image = np.zeros((3, 3), dtype=bool)
        aug = iaa.AddElementwise(value=1)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == np.bool_
        assert np.all(image_aug == 1)

        image = np.full((3, 3), True, dtype=bool)
        aug = iaa.AddElementwise(value=1)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == np.bool_
        assert np.all(image_aug == 1)

        image = np.full((3, 3), True, dtype=bool)
        aug = iaa.AddElementwise(value=-1)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == np.bool_
        assert np.all(image_aug == 0)

        image = np.full((3, 3), True, dtype=bool)
        aug = iaa.AddElementwise(value=-2)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == np.bool_
        assert np.all(image_aug == 0)

</source>
</class>

<class classid="124" nclones="2" nlines="69" similarity="94">
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="340" endline="420" pcid="2082">
    def test_other_dtypes_uint_int(self):
        for dtype in [np.uint8, np.uint16, np.int8, np.int16]:
            min_value, center_value, max_value = iadt.get_value_range_of_dtype(dtype)

            image = np.full((3, 3), min_value, dtype=dtype)
            aug = iaa.Add(1)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == min_value + 1)

            image = np.full((3, 3), min_value + 10, dtype=dtype)
            aug = iaa.Add(11)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == min_value + 21)

            image = np.full((3, 3), max_value - 2, dtype=dtype)
            aug = iaa.Add(1)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == max_value - 1)

            image = np.full((3, 3), max_value - 1, dtype=dtype)
            aug = iaa.Add(1)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == max_value)

            image = np.full((3, 3), max_value - 1, dtype=dtype)
            aug = iaa.Add(2)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == max_value)

            image = np.full((3, 3), min_value + 10, dtype=dtype)
            aug = iaa.Add(-9)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == min_value + 1)

            image = np.full((3, 3), min_value + 10, dtype=dtype)
            aug = iaa.Add(-10)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == min_value)

            image = np.full((3, 3), min_value + 10, dtype=dtype)
            aug = iaa.Add(-11)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == min_value)

            for _ in sm.xrange(10):
                image = np.full((1, 1, 3), 20, dtype=dtype)
                aug = iaa.Add(iap.Uniform(-10, 10))
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(10 <= image_aug, image_aug <= 30))
                assert len(np.unique(image_aug)) == 1

                image = np.full((1, 1, 100), 20, dtype=dtype)
                aug = iaa.Add(iap.Uniform(-10, 10), per_channel=True)
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(10 <= image_aug, image_aug <= 30))
                assert len(np.unique(image_aug)) > 1

                image = np.full((1, 1, 3), 20, dtype=dtype)
                aug = iaa.Add(iap.DiscreteUniform(-10, 10))
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(10 <= image_aug, image_aug <= 30))
                assert len(np.unique(image_aug)) == 1

                image = np.full((1, 1, 100), 20, dtype=dtype)
                aug = iaa.Add(iap.DiscreteUniform(-10, 10), per_channel=True)
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(10 <= image_aug, image_aug <= 30))
                assert len(np.unique(image_aug)) > 1

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="826" endline="909" pcid="2101">
    def test_other_dtypes_uint_int(self):
        # uint, int
        for dtype in [np.uint8, np.uint16, np.int8, np.int16]:
            min_value, center_value, max_value = iadt.get_value_range_of_dtype(dtype)

            image = np.full((3, 3), min_value, dtype=dtype)
            aug = iaa.AddElementwise(1)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == min_value + 1)

            image = np.full((3, 3), min_value + 10, dtype=dtype)
            aug = iaa.AddElementwise(11)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == min_value + 21)

            image = np.full((3, 3), max_value - 2, dtype=dtype)
            aug = iaa.AddElementwise(1)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == max_value - 1)

            image = np.full((3, 3), max_value - 1, dtype=dtype)
            aug = iaa.AddElementwise(1)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == max_value)

            image = np.full((3, 3), max_value - 1, dtype=dtype)
            aug = iaa.AddElementwise(2)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == max_value)

            image = np.full((3, 3), min_value + 10, dtype=dtype)
            aug = iaa.AddElementwise(-9)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == min_value + 1)

            image = np.full((3, 3), min_value + 10, dtype=dtype)
            aug = iaa.AddElementwise(-10)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == min_value)

            image = np.full((3, 3), min_value + 10, dtype=dtype)
            aug = iaa.AddElementwise(-11)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == min_value)

            for _ in sm.xrange(10):
                image = np.full((5, 5, 3), 20, dtype=dtype)
                aug = iaa.AddElementwise(iap.Uniform(-10, 10))
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(10 <= image_aug, image_aug <= 30))
                assert len(np.unique(image_aug)) > 1
                assert np.all(image_aug[..., 0] == image_aug[..., 1])

                image = np.full((1, 1, 100), 20, dtype=dtype)
                aug = iaa.AddElementwise(iap.Uniform(-10, 10), per_channel=True)
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(10 <= image_aug, image_aug <= 30))
                assert len(np.unique(image_aug)) > 1

                image = np.full((5, 5, 3), 20, dtype=dtype)
                aug = iaa.AddElementwise(iap.DiscreteUniform(-10, 10))
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(10 <= image_aug, image_aug <= 30))
                assert len(np.unique(image_aug)) > 1
                assert np.all(image_aug[..., 0] == image_aug[..., 1])

                image = np.full((1, 1, 100), 20, dtype=dtype)
                aug = iaa.AddElementwise(iap.DiscreteUniform(-10, 10), per_channel=True)
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(10 <= image_aug, image_aug <= 30))
                assert len(np.unique(image_aug)) > 1

</source>
</class>

<class classid="125" nclones="2" nlines="75" similarity="97">
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="421" endline="511" pcid="2083">
    def test_other_dtypes_float(self):
        # float
        for dtype in [np.float16, np.float32]:
            min_value, center_value, max_value = iadt.get_value_range_of_dtype(dtype)

            if dtype == np.float16:
                atol = 1e-3 * max_value
            else:
                atol = 1e-9 * max_value
            _allclose = functools.partial(np.allclose, atol=atol, rtol=0)

            image = np.full((3, 3), min_value, dtype=dtype)
            aug = iaa.Add(1)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, min_value + 1)

            image = np.full((3, 3), min_value + 10, dtype=dtype)
            aug = iaa.Add(11)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, min_value + 21)

            image = np.full((3, 3), max_value - 2, dtype=dtype)
            aug = iaa.Add(1)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, max_value - 1)

            image = np.full((3, 3), max_value - 1, dtype=dtype)
            aug = iaa.Add(1)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, max_value)

            image = np.full((3, 3), max_value - 1, dtype=dtype)
            aug = iaa.Add(2)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, max_value)

            image = np.full((3, 3), min_value + 10, dtype=dtype)
            aug = iaa.Add(-9)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, min_value + 1)

            image = np.full((3, 3), min_value + 10, dtype=dtype)
            aug = iaa.Add(-10)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, min_value)

            image = np.full((3, 3), min_value + 10, dtype=dtype)
            aug = iaa.Add(-11)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, min_value)

            for _ in sm.xrange(10):
                image = np.full((50, 1, 3), 0, dtype=dtype)
                aug = iaa.Add(iap.Uniform(-10, 10))
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(-10 - 1e-2 < image_aug, image_aug < 10 + 1e-2))
                assert np.allclose(image_aug[1:, :, 0], image_aug[:-1, :, 0])
                assert np.allclose(image_aug[..., 0], image_aug[..., 1])

                image = np.full((1, 1, 100), 0, dtype=dtype)
                aug = iaa.Add(iap.Uniform(-10, 10), per_channel=True)
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(-10 - 1e-2 < image_aug, image_aug < 10 + 1e-2))
                assert not np.allclose(image_aug[:, :, 1:], image_aug[:, :, :-1])

                image = np.full((50, 1, 3), 0, dtype=dtype)
                aug = iaa.Add(iap.DiscreteUniform(-10, 10))
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(-10 - 1e-2 < image_aug, image_aug < 10 + 1e-2))
                assert np.allclose(image_aug[1:, :, 0], image_aug[:-1, :, 0])
                assert np.allclose(image_aug[..., 0], image_aug[..., 1])

                image = np.full((1, 1, 100), 0, dtype=dtype)
                aug = iaa.Add(iap.DiscreteUniform(-10, 10), per_channel=True)
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(-10 - 1e-2 < image_aug, image_aug < 10 + 1e-2))
                assert not np.allclose(image_aug[:, :, 1:], image_aug[:, :, :-1])


</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="910" endline="1000" pcid="2102">
    def test_other_dtypes_float(self):
        # float
        for dtype in [np.float16, np.float32]:
            min_value, center_value, max_value = iadt.get_value_range_of_dtype(dtype)

            if dtype == np.float16:
                atol = 1e-3 * max_value
            else:
                atol = 1e-9 * max_value
            _allclose = functools.partial(np.allclose, atol=atol, rtol=0)

            image = np.full((3, 3), min_value, dtype=dtype)
            aug = iaa.AddElementwise(1)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, min_value + 1)

            image = np.full((3, 3), min_value + 10, dtype=dtype)
            aug = iaa.AddElementwise(11)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, min_value + 21)

            image = np.full((3, 3), max_value - 2, dtype=dtype)
            aug = iaa.AddElementwise(1)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, max_value - 1)

            image = np.full((3, 3), max_value - 1, dtype=dtype)
            aug = iaa.AddElementwise(1)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, max_value)

            image = np.full((3, 3), max_value - 1, dtype=dtype)
            aug = iaa.AddElementwise(2)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, max_value)

            image = np.full((3, 3), min_value + 10, dtype=dtype)
            aug = iaa.AddElementwise(-9)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, min_value + 1)

            image = np.full((3, 3), min_value + 10, dtype=dtype)
            aug = iaa.AddElementwise(-10)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, min_value)

            image = np.full((3, 3), min_value + 10, dtype=dtype)
            aug = iaa.AddElementwise(-11)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, min_value)

            for _ in sm.xrange(10):
                image = np.full((50, 1, 3), 0, dtype=dtype)
                aug = iaa.AddElementwise(iap.Uniform(-10, 10))
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(-10 - 1e-2 < image_aug, image_aug < 10 + 1e-2))
                assert not np.allclose(image_aug[1:, :, 0], image_aug[:-1, :, 0])
                assert np.allclose(image_aug[..., 0], image_aug[..., 1])

                image = np.full((1, 1, 100), 0, dtype=dtype)
                aug = iaa.AddElementwise(iap.Uniform(-10, 10), per_channel=True)
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(-10 - 1e-2 < image_aug, image_aug < 10 + 1e-2))
                assert not np.allclose(image_aug[:, :, 1:], image_aug[:, :, :-1])

                image = np.full((50, 1, 3), 0, dtype=dtype)
                aug = iaa.AddElementwise(iap.DiscreteUniform(-10, 10))
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(-10 - 1e-2 < image_aug, image_aug < 10 + 1e-2))
                assert not np.allclose(image_aug[1:, :, 0], image_aug[:-1, :, 0])
                assert np.allclose(image_aug[..., 0], image_aug[..., 1])

                image = np.full((1, 1, 100), 0, dtype=dtype)
                aug = iaa.AddElementwise(iap.DiscreteUniform(-10, 10), per_channel=True)
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(-10 - 1e-2 < image_aug, image_aug < 10 + 1e-2))
                assert not np.allclose(image_aug[:, :, 1:], image_aug[:, :, :-1])


</source>
</class>

<class classid="126" nclones="2" nlines="20" similarity="95">
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="695" endline="718" pcid="2093">
    def test_samples_change_by_spatial_location(self):
        # values should change between pixels
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        images = np.array([base_img])

        aug = iaa.AddElementwise(value=(-50, 50))

        nb_same = 0
        nb_different = 0
        nb_iterations = 1000
        for i in sm.xrange(nb_iterations):
            observed_aug = aug.augment_images(images)
            observed_aug_flat = observed_aug.flatten()
            last = None
            for j in sm.xrange(observed_aug_flat.size):
                if last is not None:
                    v = observed_aug_flat[j]
                    if v - 0.0001 <= last <= v + 0.0001:
                        nb_same += 1
                    else:
                        nb_different += 1
                last = observed_aug_flat[j]
        assert nb_different > 0.9 * (nb_different + nb_same)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="2016" endline="2039" pcid="2153">
                last_aug_det = observed_aug_det
        assert nb_changed_aug >= int(nb_iterations * 0.95)
        assert nb_changed_aug_det == 0

    def test_samples_change_by_spatial_location(self):
        # values should change between pixels
        base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
        images = np.array([base_img])

        aug = iaa.MultiplyElementwise(mul=(0.5, 1.5))

        nb_same = 0
        nb_different = 0
        nb_iterations = 1000
        for i in sm.xrange(nb_iterations):
            observed_aug = aug.augment_images(images)
            observed_aug_flat = observed_aug.flatten()
            last = None
            for j in sm.xrange(observed_aug_flat.size):
                if last is not None:
                    v = observed_aug_flat[j]
                    if v - 0.0001 <= last <= v + 0.0001:
                        nb_same += 1
                    else:
</source>
</class>

<class classid="127" nclones="3" nlines="16" similarity="75">
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="1291" endline="1308" pcid="2118">
                last_aug_det = observed_aug_det
        assert nb_changed_aug >= int(nb_iterations * 0.95)
        assert nb_changed_aug_det == 0

    def test_stochastic_parameter_as_p(self):
        # varying p by stochastic parameter
        aug = iaa.Dropout(p=iap.Binomial(1-iap.Choice([0.0, 0.5])))
        images = np.ones((1, 20, 20, 1), dtype=np.uint8) * 255
        seen = [0, 0, 0]
        for i in sm.xrange(400):
            observed = aug.augment_images(images)
            p = np.mean(observed == 0)
            if 0.4 < p < 0.6:
                seen[0] += 1
            elif p < 0.1:
                seen[1] += 1
            else:
                seen[2] += 1
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="1376" endline="1393" pcid="2127">
                found = True
                break
        assert found

    def test_stochastic_parameter_as_p(self):
        # varying p by stochastic parameter
        aug = iaa.CoarseDropout(p=iap.Binomial(1-iap.Choice([0.0, 0.5])), size_px=50)
        images = np.ones((1, 100, 100, 1), dtype=np.uint8) * 255
        seen = [0, 0, 0]
        for i in sm.xrange(400):
            observed = aug.augment_images(images)
            p = np.mean(observed == 0)
            if 0.4 < p < 0.6:
                seen[0] += 1
            elif p < 0.1:
                seen[1] += 1
            else:
                seen[2] += 1
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="2462" endline="2480" pcid="2168">
            nb_diff_all += nb_diff
        p = nb_diff_all / (nb_iterations * 100 * 100)
        assert 0.45 <= p <= 0.55

    def test_mask_is_list(self):
        # mask is list
        aug = iaa.ReplaceElementwise(mask=[0.2, 0.7], replacement=1)
        img = np.zeros((20, 20, 1), dtype=np.uint8)

        seen = [0, 0, 0]
        for i in sm.xrange(400):
            observed = aug.augment_image(img)
            p = np.mean(observed)
            if 0.1 < p < 0.3:
                seen[0] += 1
            elif 0.6 < p < 0.8:
                seen[1] += 1
            else:
                seen[2] += 1
</source>
</class>

<class classid="128" nclones="2" nlines="26" similarity="100">
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="1645" endline="1676" pcid="2144">
        hm = ia.quokka_heatmap()
        hm_aug = aug.augment_heatmaps([hm])[0]
        assert np.allclose(hm.arr_0to1, hm_aug.arr_0to1)

    def test_other_dtypes_bool(self):
        # bool
        image = np.zeros((3, 3), dtype=bool)
        aug = iaa.Multiply(1.0)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == np.bool_
        assert np.all(image_aug == 0)

        image = np.full((3, 3), True, dtype=bool)
        aug = iaa.Multiply(1.0)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == np.bool_
        assert np.all(image_aug == 1)

        image = np.full((3, 3), True, dtype=bool)
        aug = iaa.Multiply(2.0)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == np.bool_
        assert np.all(image_aug == 1)

        image = np.full((3, 3), True, dtype=bool)
        aug = iaa.Multiply(0.0)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == np.bool_
        assert np.all(image_aug == 0)

        image = np.full((3, 3), True, dtype=bool)
        aug = iaa.Multiply(-1.0)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="2140" endline="2171" pcid="2161">
        hm = ia.quokka_heatmap()
        hm_aug = aug.augment_heatmaps([hm])[0]
        assert np.allclose(hm.arr_0to1, hm_aug.arr_0to1)

    def test_other_dtypes_bool(self):
        # bool
        image = np.zeros((3, 3), dtype=bool)
        aug = iaa.MultiplyElementwise(1.0)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == np.bool_
        assert np.all(image_aug == 0)

        image = np.full((3, 3), True, dtype=bool)
        aug = iaa.MultiplyElementwise(1.0)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == np.bool_
        assert np.all(image_aug == 1)

        image = np.full((3, 3), True, dtype=bool)
        aug = iaa.MultiplyElementwise(2.0)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == np.bool_
        assert np.all(image_aug == 1)

        image = np.full((3, 3), True, dtype=bool)
        aug = iaa.MultiplyElementwise(0.0)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == np.bool_
        assert np.all(image_aug == 0)

        image = np.full((3, 3), True, dtype=bool)
        aug = iaa.MultiplyElementwise(-1.0)
</source>
</class>

<class classid="129" nclones="2" nlines="91" similarity="74">
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="1677" endline="1797" pcid="2145">
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == np.bool_
        assert np.all(image_aug == 0)

    def test_other_dtypes_uint_int(self):
        # uint, int
        for dtype in [np.uint8, np.uint16, np.int8, np.int16]:
            dtype = np.dtype(dtype)
            min_value, center_value, max_value = iadt.get_value_range_of_dtype(dtype)

            image = np.full((3, 3), 10, dtype=dtype)
            aug = iaa.Multiply(1)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == 10)

            image = np.full((3, 3), 10, dtype=dtype)
            aug = iaa.Multiply(10)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == 100)

            image = np.full((3, 3), 10, dtype=dtype)
            aug = iaa.Multiply(0.5)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == 5)

            image = np.full((3, 3), 0, dtype=dtype)
            aug = iaa.Multiply(0)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == 0)

            if np.dtype(dtype).kind == "u":
                image = np.full((3, 3), 10, dtype=dtype)
                aug = iaa.Multiply(-1)
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(image_aug == 0)
            else:
                image = np.full((3, 3), 10, dtype=dtype)
                aug = iaa.Multiply(-1)
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(image_aug == -10)

            image = np.full((3, 3), int(center_value), dtype=dtype)
            aug = iaa.Multiply(1)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == int(center_value))

            image = np.full((3, 3), int(center_value), dtype=dtype)
            aug = iaa.Multiply(1.2)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == int(1.2 * int(center_value)))

            if np.dtype(dtype).kind == "u":
                image = np.full((3, 3), int(center_value), dtype=dtype)
                aug = iaa.Multiply(100)
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(image_aug == max_value)

            image = np.full((3, 3), max_value, dtype=dtype)
            aug = iaa.Multiply(1)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == max_value)

            # non-uint8 currently don't increase the itemsize
            if dtype.name == "uint8":
                image = np.full((3, 3), max_value, dtype=dtype)
                aug = iaa.Multiply(10)
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(image_aug == max_value)

            image = np.full((3, 3), max_value, dtype=dtype)
            aug = iaa.Multiply(0)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == 0)

            # non-uint8 currently don't increase the itemsize
            if dtype.name == "uint8":
                image = np.full((3, 3), max_value, dtype=dtype)
                aug = iaa.Multiply(-2)
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(image_aug == min_value)

            # non-uint8 currently don't increase the itemsize
            if dtype.name == "uint8":
                for _ in sm.xrange(10):
                    image = np.full((1, 1, 3), 10, dtype=dtype)
                    aug = iaa.Multiply(iap.Uniform(0.5, 1.5))
                    image_aug = aug.augment_image(image)
                    assert image_aug.dtype.type == dtype
                    assert np.all(np.logical_and(5 <= image_aug, image_aug <= 15))
                    assert len(np.unique(image_aug)) == 1

                    image = np.full((1, 1, 100), 10, dtype=dtype)
                    aug = iaa.Multiply(iap.Uniform(0.5, 1.5), per_channel=True)
                    image_aug = aug.augment_image(image)
                    assert image_aug.dtype.type == dtype
                    assert np.all(np.logical_and(5 <= image_aug, image_aug <= 15))
                    assert len(np.unique(image_aug)) > 1

                    image = np.full((1, 1, 3), 10, dtype=dtype)
                    aug = iaa.Multiply(iap.DiscreteUniform(1, 3))
                    image_aug = aug.augment_image(image)
                    assert image_aug.dtype.type == dtype
                    assert np.all(np.logical_and(10 <= image_aug, image_aug <= 30))
                    assert len(np.unique(image_aug)) == 1

                    image = np.full((1, 1, 100), 10, dtype=dtype)
                    aug = iaa.Multiply(iap.DiscreteUniform(1, 3), per_channel=True)
                    image_aug = aug.augment_image(image)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="2172" endline="2298" pcid="2162">
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == np.bool_
        assert np.all(image_aug == 0)

    def test_other_dtypes_uint_int(self):
        # uint, int
        for dtype in [np.uint8, np.uint16, np.int8, np.int16]:
            dtype = np.dtype(dtype)
            min_value, center_value, max_value = iadt.get_value_range_of_dtype(dtype)

            image = np.full((3, 3), 10, dtype=dtype)
            aug = iaa.MultiplyElementwise(1)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == 10)

            # deactivated, because itemsize increase was deactivated
            # image = np.full((3, 3), 10, dtype=dtype)
            # aug = iaa.MultiplyElementwise(10)
            # image_aug = aug.augment_image(image)
            # assert image_aug.dtype.type == dtype
            # assert np.all(image_aug == 100)

            image = np.full((3, 3), 10, dtype=dtype)
            aug = iaa.MultiplyElementwise(0.5)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == 5)

            image = np.full((3, 3), 0, dtype=dtype)
            aug = iaa.MultiplyElementwise(0)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == 0)

            # partially deactivated, because itemsize increase was deactivated
            if dtype.name == "uint8":
                if dtype.kind == "u":
                    image = np.full((3, 3), 10, dtype=dtype)
                    aug = iaa.MultiplyElementwise(-1)
                    image_aug = aug.augment_image(image)
                    assert image_aug.dtype.type == dtype
                    assert np.all(image_aug == 0)
                else:
                    image = np.full((3, 3), 10, dtype=dtype)
                    aug = iaa.MultiplyElementwise(-1)
                    image_aug = aug.augment_image(image)
                    assert image_aug.dtype.type == dtype
                    assert np.all(image_aug == -10)

            image = np.full((3, 3), int(center_value), dtype=dtype)
            aug = iaa.MultiplyElementwise(1)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == int(center_value))

            # deactivated, because itemsize increase was deactivated
            # image = np.full((3, 3), int(center_value), dtype=dtype)
            # aug = iaa.MultiplyElementwise(1.2)
            # image_aug = aug.augment_image(image)
            # assert image_aug.dtype.type == dtype
            # assert np.all(image_aug == int(1.2 * int(center_value)))

            # deactivated, because itemsize increase was deactivated
            if dtype.name == "uint8":
                if dtype.kind == "u":
                    image = np.full((3, 3), int(center_value), dtype=dtype)
                    aug = iaa.MultiplyElementwise(100)
                    image_aug = aug.augment_image(image)
                    assert image_aug.dtype.type == dtype
                    assert np.all(image_aug == max_value)

            image = np.full((3, 3), max_value, dtype=dtype)
            aug = iaa.MultiplyElementwise(1)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == max_value)

            # deactivated, because itemsize increase was deactivated
            # image = np.full((3, 3), max_value, dtype=dtype)
            # aug = iaa.MultiplyElementwise(10)
            # image_aug = aug.augment_image(image)
            # assert image_aug.dtype.type == dtype
            # assert np.all(image_aug == max_value)

            image = np.full((3, 3), max_value, dtype=dtype)
            aug = iaa.MultiplyElementwise(0)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == 0)

            # deactivated, because itemsize increase was deactivated
            # image = np.full((3, 3), max_value, dtype=dtype)
            # aug = iaa.MultiplyElementwise(-2)
            # image_aug = aug.augment_image(image)
            # assert image_aug.dtype.type == dtype
            # assert np.all(image_aug == min_value)

            # partially deactivated, because itemsize increase was deactivated
            if dtype.name == "uint8":
                for _ in sm.xrange(10):
                    image = np.full((5, 5, 3), 10, dtype=dtype)
                    aug = iaa.MultiplyElementwise(iap.Uniform(0.5, 1.5))
                    image_aug = aug.augment_image(image)
                    assert image_aug.dtype.type == dtype
                    assert np.all(np.logical_and(5 <= image_aug, image_aug <= 15))
                    assert len(np.unique(image_aug)) > 1
                    assert np.all(image_aug[..., 0] == image_aug[..., 1])

                    image = np.full((1, 1, 100), 10, dtype=dtype)
                    aug = iaa.MultiplyElementwise(iap.Uniform(0.5, 1.5), per_channel=True)
                    image_aug = aug.augment_image(image)
                    assert image_aug.dtype.type == dtype
                    assert np.all(np.logical_and(5 <= image_aug, image_aug <= 15))
                    assert len(np.unique(image_aug)) > 1

                    image = np.full((5, 5, 3), 10, dtype=dtype)
                    aug = iaa.MultiplyElementwise(iap.DiscreteUniform(1, 3))
                    image_aug = aug.augment_image(image)
                    assert image_aug.dtype.type == dtype
                    assert np.all(np.logical_and(10 <= image_aug, image_aug <= 30))
                    assert len(np.unique(image_aug)) > 1
                    assert np.all(image_aug[..., 0] == image_aug[..., 1])

                    image = np.full((1, 1, 100), 10, dtype=dtype)
                    aug = iaa.MultiplyElementwise(iap.DiscreteUniform(1, 3), per_channel=True)
                    image_aug = aug.augment_image(image)
</source>
</class>

<class classid="130" nclones="2" nlines="32" similarity="85">
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="1798" endline="1888" pcid="2146">
                    assert image_aug.dtype.type == dtype
                    assert np.all(np.logical_and(10 <= image_aug, image_aug <= 30))
                    assert len(np.unique(image_aug)) > 1

    def test_other_dtypes_float(self):
        # float
        for dtype in [np.float16, np.float32]:
            min_value, center_value, max_value = iadt.get_value_range_of_dtype(dtype)

            if dtype == np.float16:
                atol = 1e-3 * max_value
            else:
                atol = 1e-9 * max_value
            _allclose = functools.partial(np.allclose, atol=atol, rtol=0)

            image = np.full((3, 3), 10.0, dtype=dtype)
            aug = iaa.Multiply(1.0)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, 10.0)

            image = np.full((3, 3), 10.0, dtype=dtype)
            aug = iaa.Multiply(2.0)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, 20.0)

            # deactivated, because itemsize increase was deactivated
            # image = np.full((3, 3), max_value, dtype=dtype)
            # aug = iaa.Multiply(-10)
            # image_aug = aug.augment_image(image)
            # assert image_aug.dtype.type == dtype
            # assert _allclose(image_aug, min_value)

            image = np.full((3, 3), max_value, dtype=dtype)
            aug = iaa.Multiply(0.0)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, 0.0)

            image = np.full((3, 3), max_value, dtype=dtype)
            aug = iaa.Multiply(0.5)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, 0.5*max_value)

            # deactivated, because itemsize increase was deactivated
            # image = np.full((3, 3), min_value, dtype=dtype)
            # aug = iaa.Multiply(-2.0)
            # image_aug = aug.augment_image(image)
            # assert image_aug.dtype.type == dtype
            # assert _allclose(image_aug, max_value)

            image = np.full((3, 3), min_value, dtype=dtype)
            aug = iaa.Multiply(0.0)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, 0.0)

            # using tolerances of -100 - 1e-2 and 100 + 1e-2 is not enough for float16, had to be increased to -/+ 1e-1
            # deactivated, because itemsize increase was deactivated
            """
            for _ in sm.xrange(10):
                image = np.full((1, 1, 3), 10.0, dtype=dtype)
                aug = iaa.Multiply(iap.Uniform(-10, 10))
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(-100 - 1e-1 < image_aug, image_aug < 100 + 1e-1))
                assert np.allclose(image_aug[1:, :, 0], image_aug[:-1, :, 0])
                assert np.allclose(image_aug[..., 0], image_aug[..., 1])

                image = np.full((1, 1, 100), 10.0, dtype=dtype)
                aug = iaa.Multiply(iap.Uniform(-10, 10), per_channel=True)
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(-100 - 1e-1 < image_aug, image_aug < 100 + 1e-1))
                assert not np.allclose(image_aug[:, :, 1:], image_aug[:, :, :-1])

                image = np.full((1, 1, 3), 10.0, dtype=dtype)
                aug = iaa.Multiply(iap.DiscreteUniform(-10, 10))
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(-100 - 1e-1 < image_aug, image_aug < 100 + 1e-1))
                assert np.allclose(image_aug[1:, :, 0], image_aug[:-1, :, 0])
                assert np.allclose(image_aug[..., 0], image_aug[..., 1])

                image = np.full((1, 1, 100), 10.0, dtype=dtype)
                aug = iaa.Multiply(iap.DiscreteUniform(-10, 10), per_channel=True)
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(-100 - 1e-1 < image_aug, image_aug < 100 + 1e-1))
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="2299" endline="2391" pcid="2163">
                    assert image_aug.dtype.type == dtype
                    assert np.all(np.logical_and(10 <= image_aug, image_aug <= 30))
                    assert len(np.unique(image_aug)) > 1

    def test_other_dtypes_float(self):
        # float
        for dtype in [np.float16, np.float32]:
            dtype = np.dtype(dtype)
            min_value, center_value, max_value = iadt.get_value_range_of_dtype(dtype)

            if dtype == np.float16:
                atol = 1e-3 * max_value
            else:
                atol = 1e-9 * max_value
            _allclose = functools.partial(np.allclose, atol=atol, rtol=0)

            image = np.full((3, 3), 10.0, dtype=dtype)
            aug = iaa.MultiplyElementwise(1.0)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, 10.0)

            # deactivated, because itemsize increase was deactivated
            # image = np.full((3, 3), 10.0, dtype=dtype)
            # aug = iaa.MultiplyElementwise(2.0)
            # image_aug = aug.augment_image(image)
            # assert image_aug.dtype.type == dtype
            # assert _allclose(image_aug, 20.0)

            # deactivated, because itemsize increase was deactivated
            # image = np.full((3, 3), max_value, dtype=dtype)
            # aug = iaa.MultiplyElementwise(-10)
            # image_aug = aug.augment_image(image)
            # assert image_aug.dtype.type == dtype
            # assert _allclose(image_aug, min_value)

            image = np.full((3, 3), max_value, dtype=dtype)
            aug = iaa.MultiplyElementwise(0.0)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, 0.0)

            image = np.full((3, 3), max_value, dtype=dtype)
            aug = iaa.MultiplyElementwise(0.5)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, 0.5*max_value)

            # deactivated, because itemsize increase was deactivated
            # image = np.full((3, 3), min_value, dtype=dtype)
            # aug = iaa.MultiplyElementwise(-2.0)
            # image_aug = aug.augment_image(image)
            # assert image_aug.dtype.type == dtype
            # assert _allclose(image_aug, max_value)

            image = np.full((3, 3), min_value, dtype=dtype)
            aug = iaa.MultiplyElementwise(0.0)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert _allclose(image_aug, 0.0)

            # using tolerances of -100 - 1e-2 and 100 + 1e-2 is not enough for float16, had to be increased to -/+ 1e-1
            # deactivated, because itemsize increase was deactivated
            """
            for _ in sm.xrange(10):
                image = np.full((50, 1, 3), 10.0, dtype=dtype)
                aug = iaa.MultiplyElementwise(iap.Uniform(-10, 10))
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(-100 - 1e-1 < image_aug, image_aug < 100 + 1e-1))
                assert not np.allclose(image_aug[1:, :, 0], image_aug[:-1, :, 0])
                assert np.allclose(image_aug[..., 0], image_aug[..., 1])

                image = np.full((1, 1, 100), 10.0, dtype=dtype)
                aug = iaa.MultiplyElementwise(iap.Uniform(-10, 10), per_channel=True)
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(-100 - 1e-1 < image_aug, image_aug < 100 + 1e-1))
                assert not np.allclose(image_aug[:, :, 1:], image_aug[:, :, :-1])

                image = np.full((50, 1, 3), 10.0, dtype=dtype)
                aug = iaa.MultiplyElementwise(iap.DiscreteUniform(-10, 10))
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(-100 - 1e-1 < image_aug, image_aug < 100 + 1e-1))
                assert not np.allclose(image_aug[1:, :, 0], image_aug[:-1, :, 0])
                assert np.allclose(image_aug[..., 0], image_aug[..., 1])

                image = np.full((1, 1, 100), 10, dtype=dtype)
                aug = iaa.MultiplyElementwise(iap.DiscreteUniform(-10, 10), per_channel=True)
                image_aug = aug.augment_image(image)
                assert image_aug.dtype.type == dtype
                assert np.all(np.logical_and(-100 - 1e-1 < image_aug, image_aug < 100 + 1e-1))
</source>
</class>

<class classid="131" nclones="3" nlines="15" similarity="100">
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="2797" endline="2812" pcid="2185">
        observed = aug.augment_image(base_img)
        p = np.mean(observed != 128)
        assert 0.4 < p < 0.6

    def test_size_px(self):
        aug1 = iaa.CoarseSaltAndPepper(p=0.5, size_px=100)
        aug2 = iaa.CoarseSaltAndPepper(p=0.5, size_px=10)
        base_img = np.zeros((100, 100, 1), dtype=np.uint8) + 128
        ps1 = []
        ps2 = []
        for _ in sm.xrange(100):
            observed1 = aug1.augment_image(base_img)
            observed2 = aug2.augment_image(base_img)
            p1 = np.mean(observed1 != 128)
            p2 = np.mean(observed2 != 128)
            ps1.append(p1)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="3019" endline="3034" pcid="2206">
        observed = aug.augment_image(base_img)
        p = np.mean(observed != 128)
        assert 0.4 < p < 0.6

    def test_size_px(self):
        aug1 = iaa.CoarsePepper(p=0.5, size_px=100)
        aug2 = iaa.CoarsePepper(p=0.5, size_px=10)
        base_img = np.zeros((100, 100, 1), dtype=np.uint8) + 128
        ps1 = []
        ps2 = []
        for _ in sm.xrange(100):
            observed1 = aug1.augment_image(base_img)
            observed2 = aug2.augment_image(base_img)
            p1 = np.mean(observed1 != 128)
            p2 = np.mean(observed2 != 128)
            ps1.append(p1)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="2908" endline="2923" pcid="2195">
        observed = aug.augment_image(base_img)
        p = np.mean(observed != 128)
        assert 0.4 < p < 0.6

    def test_size_px(self):
        aug1 = iaa.CoarseSalt(p=0.5, size_px=100)
        aug2 = iaa.CoarseSalt(p=0.5, size_px=10)
        base_img = np.zeros((100, 100, 1), dtype=np.uint8) + 128
        ps1 = []
        ps2 = []
        for _ in sm.xrange(100):
            observed1 = aug1.augment_image(base_img)
            observed2 = aug2.augment_image(base_img)
            p1 = np.mean(observed1 != 128)
            p2 = np.mean(observed2 != 128)
            ps1.append(p1)
</source>
</class>

<class classid="132" nclones="3" nlines="18" similarity="100">
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="2813" endline="2831" pcid="2186">
            ps2.append(p2)
        assert 0.4 < np.mean(ps2) < 0.6
        assert np.std(ps1)*1.5 < np.std(ps2)

    def test_p_is_list(self):
        aug = iaa.CoarseSaltAndPepper(p=[0.2, 0.5], size_px=100)
        base_img = np.zeros((100, 100, 1), dtype=np.uint8) + 128
        seen = [0, 0, 0]
        for _ in sm.xrange(200):
            observed = aug.augment_image(base_img)
            p = np.mean(observed != 128)
            diff_020 = abs(0.2 - p)
            diff_050 = abs(0.5 - p)
            if diff_020 < 0.025:
                seen[0] += 1
            elif diff_050 < 0.025:
                seen[1] += 1
            else:
                seen[2] += 1
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="2924" endline="2942" pcid="2196">
            ps2.append(p2)
        assert 0.4 < np.mean(ps2) < 0.6
        assert np.std(ps1)*1.5 < np.std(ps2)

    def test_p_is_list(self):
        aug = iaa.CoarseSalt(p=[0.2, 0.5], size_px=100)
        base_img = np.zeros((100, 100, 1), dtype=np.uint8) + 128
        seen = [0, 0, 0]
        for _ in sm.xrange(200):
            observed = aug.augment_image(base_img)
            p = np.mean(observed != 128)
            diff_020 = abs(0.2 - p)
            diff_050 = abs(0.5 - p)
            if diff_020 < 0.025:
                seen[0] += 1
            elif diff_050 < 0.025:
                seen[1] += 1
            else:
                seen[2] += 1
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="3035" endline="3053" pcid="2207">
            ps2.append(p2)
        assert 0.4 < np.mean(ps2) < 0.6
        assert np.std(ps1)*1.5 < np.std(ps2)

    def test_p_is_list(self):
        aug = iaa.CoarsePepper(p=[0.2, 0.5], size_px=100)
        base_img = np.zeros((100, 100, 1), dtype=np.uint8) + 128
        seen = [0, 0, 0]
        for _ in sm.xrange(200):
            observed = aug.augment_image(base_img)
            p = np.mean(observed != 128)
            diff_020 = abs(0.2 - p)
            diff_050 = abs(0.5 - p)
            if diff_020 < 0.025:
                seen[0] += 1
            elif diff_050 < 0.025:
                seen[1] += 1
            else:
                seen[2] += 1
</source>
</class>

<class classid="133" nclones="3" nlines="14" similarity="100">
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="2832" endline="2847" pcid="2187">
        assert seen[2] < 10
        assert 75 < seen[0] < 125
        assert 75 < seen[1] < 125

    def test_p_is_tuple(self):
        aug = iaa.CoarseSaltAndPepper(p=(0.0, 1.0), size_px=50)
        base_img = np.zeros((50, 50, 1), dtype=np.uint8) + 128
        ps = []
        for _ in sm.xrange(200):
            observed = aug.augment_image(base_img)
            p = np.mean(observed != 128)
            ps.append(p)

        nb_bins = 5
        hist, _ = np.histogram(ps, bins=nb_bins, range=(0.0, 1.0), density=False)
        tolerance = 0.05
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="2943" endline="2958" pcid="2197">
        assert seen[2] < 10
        assert 75 < seen[0] < 125
        assert 75 < seen[1] < 125

    def test_p_is_tuple(self):
        aug = iaa.CoarseSalt(p=(0.0, 1.0), size_px=50)
        base_img = np.zeros((50, 50, 1), dtype=np.uint8) + 128
        ps = []
        for _ in sm.xrange(200):
            observed = aug.augment_image(base_img)
            p = np.mean(observed != 128)
            ps.append(p)

        nb_bins = 5
        hist, _ = np.histogram(ps, bins=nb_bins, range=(0.0, 1.0), density=False)
        tolerance = 0.05
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="3054" endline="3069" pcid="2208">
        assert seen[2] < 10
        assert 75 < seen[0] < 125
        assert 75 < seen[1] < 125

    def test_p_is_tuple(self):
        aug = iaa.CoarsePepper(p=(0.0, 1.0), size_px=50)
        base_img = np.zeros((50, 50, 1), dtype=np.uint8) + 128
        ps = []
        for _ in sm.xrange(200):
            observed = aug.augment_image(base_img)
            p = np.mean(observed != 128)
            ps.append(p)

        nb_bins = 5
        hist, _ = np.histogram(ps, bins=nb_bins, range=(0.0, 1.0), density=False)
        tolerance = 0.05
</source>
</class>

<class classid="134" nclones="2" nlines="11" similarity="90">
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="3123" endline="3135" pcid="2216">
        expected = zeros
        assert observed.dtype.name == "uint8"
        assert np.array_equal(observed, expected)

    def test_min_value_and_max_value_set(self):
        zeros = np.zeros((4, 4, 3), dtype=np.uint8)

        observed = iaa.Invert(p=1.0, max_value=200, min_value=100).augment_image(zeros + 200)
        expected = zeros + 100
        assert observed.dtype.name == "uint8"
        assert np.array_equal(observed, expected)

        observed = iaa.Invert(p=1.0, max_value=200, min_value=100).augment_image(zeros + 100)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="3136" endline="3150" pcid="2217">
        expected = zeros + 200
        assert observed.dtype.name == "uint8"
        assert np.array_equal(observed, expected)

    def test_min_value_and_max_value_set_with_float_image(self):
        # with min/max and float inputs
        zeros = np.zeros((4, 4, 3), dtype=np.uint8)

        zeros_f32 = zeros.astype(np.float32)
        observed = iaa.Invert(p=1.0, max_value=200, min_value=100).augment_image(zeros_f32 + 200)
        expected = zeros_f32 + 100
        assert observed.dtype.name == "float32"
        assert np.array_equal(observed, expected)

        observed = iaa.Invert(p=1.0, max_value=200, min_value=100).augment_image(zeros_f32 + 100)
</source>
</class>

<class classid="135" nclones="4" nlines="33" similarity="70">
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="3293" endline="3329" pcid="2227">
        hm = ia.quokka_heatmap()
        hm_aug = aug.augment_heatmaps([hm])[0]
        assert np.allclose(hm.arr_0to1, hm_aug.arr_0to1)

    def test_other_dtypes_p_is_zero(self):
        # with p=0.0
        aug = iaa.Invert(p=0.0)
        dtypes = [bool,
                  np.uint8, np.uint16, np.uint32, np.uint64,
                  np.int8, np.int16, np.int32, np.int64,
                  np.float16, np.float32, np.float64, np.float128]
        for dtype in dtypes:
            min_value, center_value, max_value = iadt.get_value_range_of_dtype(dtype)
            kind = np.dtype(dtype).kind
            image_min = np.full((3, 3), min_value, dtype=dtype)
            if dtype is not bool:
                image_center = np.full((3, 3), center_value if kind == "f" else int(center_value), dtype=dtype)
            image_max = np.full((3, 3), max_value, dtype=dtype)
            image_min_aug = aug.augment_image(image_min)
            image_center_aug = None
            if dtype is not bool:
                image_center_aug = aug.augment_image(image_center)
            image_max_aug = aug.augment_image(image_max)

            assert image_min_aug.dtype == np.dtype(dtype)
            if image_center_aug is not None:
                assert image_center_aug.dtype == np.dtype(dtype)
            assert image_max_aug.dtype == np.dtype(dtype)

            if dtype is bool:
                assert np.all(image_min_aug == image_min)
                assert np.all(image_max_aug == image_max)
            elif np.dtype(dtype).kind in ["i", "u"]:
                assert np.array_equal(image_min_aug, image_min)
                assert np.array_equal(image_center_aug, image_center)
                assert np.array_equal(image_max_aug, image_max)
            else:
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="3330" endline="3365" pcid="2228">
                assert np.allclose(image_min_aug, image_min)
                assert np.allclose(image_center_aug, image_center)
                assert np.allclose(image_max_aug, image_max)

    def test_other_dtypes_p_is_one(self):
        # with p=1.0
        aug = iaa.Invert(p=1.0)
        dtypes = [np.uint8, np.uint16, np.uint32, np.uint64,
                  np.int8, np.int16, np.int32, np.int64,
                  np.float16, np.float32, np.float64, np.float128]
        for dtype in dtypes:
            min_value, center_value, max_value = iadt.get_value_range_of_dtype(dtype)
            kind = np.dtype(dtype).kind
            image_min = np.full((3, 3), min_value, dtype=dtype)
            if dtype is not bool:
                image_center = np.full((3, 3), center_value if kind == "f" else int(center_value), dtype=dtype)
            image_max = np.full((3, 3), max_value, dtype=dtype)
            image_min_aug = aug.augment_image(image_min)
            image_center_aug = None
            if dtype is not bool:
                image_center_aug = aug.augment_image(image_center)
            image_max_aug = aug.augment_image(image_max)

            assert image_min_aug.dtype == np.dtype(dtype)
            if image_center_aug is not None:
                assert image_center_aug.dtype == np.dtype(dtype)
            assert image_max_aug.dtype == np.dtype(dtype)

            if dtype is bool:
                assert np.all(image_min_aug == image_max)
                assert np.all(image_max_aug == image_min)
            elif np.dtype(dtype).kind in ["i", "u"]:
                assert np.array_equal(image_min_aug, image_max)
                assert np.allclose(image_center_aug, image_center, atol=1.0+1e-4, rtol=0)
                assert np.array_equal(image_max_aug, image_min)
            else:
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="3366" endline="3403" pcid="2229">
                assert np.allclose(image_min_aug, image_max)
                assert np.allclose(image_center_aug, image_center)
                assert np.allclose(image_max_aug, image_min)

    def test_other_dtypes_p_is_one_with_min_value(self):
        # with p=1.0 and min_value
        aug = iaa.Invert(p=1.0, min_value=1)
        dtypes = [np.uint8, np.uint16, np.uint32,
                  np.int8, np.int16, np.int32,
                  np.float16, np.float32]
        for dtype in dtypes:
            _min_value, _center_value, max_value = iadt.get_value_range_of_dtype(dtype)
            min_value = 1
            kind = np.dtype(dtype).kind
            center_value = min_value + 0.5 * (max_value - min_value)
            image_min = np.full((3, 3), min_value, dtype=dtype)
            if dtype is not bool:
                image_center = np.full((3, 3), center_value if kind == "f" else int(center_value), dtype=dtype)
            image_max = np.full((3, 3), max_value, dtype=dtype)
            image_min_aug = aug.augment_image(image_min)
            image_center_aug = None
            if dtype is not bool:
                image_center_aug = aug.augment_image(image_center)
            image_max_aug = aug.augment_image(image_max)

            assert image_min_aug.dtype == np.dtype(dtype)
            if image_center_aug is not None:
                assert image_center_aug.dtype == np.dtype(dtype)
            assert image_max_aug.dtype == np.dtype(dtype)

            if dtype is bool:
                assert np.all(image_min_aug == 1)
                assert np.all(image_max_aug == 1)
            elif np.dtype(dtype).kind in ["i", "u"]:
                assert np.array_equal(image_min_aug, image_max)
                assert np.allclose(image_center_aug, image_center, atol=1.0+1e-4, rtol=0)
                assert np.array_equal(image_max_aug, image_min)
            else:
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_arithmetic.py" startline="3404" endline="3446" pcid="2230">
                assert np.allclose(image_min_aug, image_max)
                assert np.allclose(image_center_aug, image_center)
                assert np.allclose(image_max_aug, image_min)

    def test_other_dtypes_p_is_one_with_max_value(self):
        # with p=1.0 and max_value
        aug = iaa.Invert(p=1.0, max_value=16)
        dtypes = [np.uint8, np.uint16, np.uint32,
                  np.int8, np.int16, np.int32,
                  np.float16, np.float32]
        for dtype in dtypes:
            min_value, _center_value, _max_value = iadt.get_value_range_of_dtype(dtype)
            max_value = 16
            kind = np.dtype(dtype).kind
            center_value = min_value + 0.5 * (max_value - min_value)
            image_min = np.full((3, 3), min_value, dtype=dtype)
            if dtype is not bool:
                image_center = np.full((3, 3), center_value if kind == "f" else int(center_value), dtype=dtype)
            image_max = np.full((3, 3), max_value, dtype=dtype)
            image_min_aug = aug.augment_image(image_min)
            image_center_aug = None
            if dtype is not bool:
                image_center_aug = aug.augment_image(image_center)
            image_max_aug = aug.augment_image(image_max)

            assert image_min_aug.dtype == np.dtype(dtype)
            if image_center_aug is not None:
                assert image_center_aug.dtype == np.dtype(dtype)
            assert image_max_aug.dtype == np.dtype(dtype)

            if dtype is bool:
                assert not np.any(image_min_aug == 1)
                assert not np.any(image_max_aug == 1)
            elif np.dtype(dtype).kind in ["i", "u"]:
                assert np.array_equal(image_min_aug, image_max)
                assert np.allclose(image_center_aug, image_center, atol=1.0+1e-4, rtol=0)
                assert np.array_equal(image_max_aug, image_min)
            else:
                assert np.allclose(image_min_aug, image_max)
                if dtype is np.float16:
                    # for float16, this is off by about 10
                    assert np.allclose(image_center_aug, image_center, atol=0.001*np.finfo(dtype).max)
                else:
</source>
</class>

<class classid="136" nclones="4" nlines="13" similarity="85">
<source file="systems/imgaug-0.3.0/test/augmenters/test_blend.py" startline="480" endline="494" pcid="2269">

    def test_heatmaps_factor_is_1_with_affines_and_per_channel(self):
        for per_channel in [False, True]:
            with self.subTest(per_channel=per_channel):
                aug = iaa.Alpha(
                    1,
                    iaa.Affine(translate_px={"x": 1}),
                    iaa.Affine(translate_px={"x": -1}),
                    per_channel=per_channel)
                observed = aug.augment_heatmaps([self.heatmaps])[0]
                assert observed.shape == self.heatmaps.shape
                assert 0 - 1e-6 < self.heatmaps.min_value < 0 + 1e-6
                assert 1 - 1e-6 < self.heatmaps.max_value < 1 + 1e-6
                assert np.allclose(observed.get_arr(),
                                   self.heatmaps_r1.get_arr())
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blend.py" startline="529" endline="541" pcid="2273">

    def test_segmaps_factor_is_0_with_affines_and_per_channel(self):
        for per_channel in [False, True]:
            with self.subTest(per_channel=per_channel):
                aug = iaa.Alpha(
                    0,
                    iaa.Affine(translate_px={"x": 1}),
                    iaa.Affine(translate_px={"x": -1}),
                    per_channel=per_channel)
                observed = aug.augment_segmentation_maps([self.segmaps])[0]
                assert observed.shape == self.segmaps.shape
                assert np.array_equal(observed.get_arr(),
                                      self.segmaps_l1.get_arr())
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blend.py" startline="495" endline="507" pcid="2270">

    def test_segmaps_factor_is_1_with_affines_and_per_channel(self):
        for per_channel in [False, True]:
            with self.subTest(per_channel=per_channel):
                aug = iaa.Alpha(
                    1,
                    iaa.Affine(translate_px={"x": 1}),
                    iaa.Affine(translate_px={"x": -1}),
                    per_channel=per_channel)
                observed = aug.augment_segmentation_maps([self.segmaps])[0]
                assert observed.shape == self.segmaps.shape
                assert np.array_equal(observed.get_arr(),
                                      self.segmaps_r1.get_arr())
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blend.py" startline="514" endline="528" pcid="2272">

    def test_heatmaps_factor_is_0_with_affines_and_per_channel(self):
        for per_channel in [False, True]:
            with self.subTest(per_channel=per_channel):
                aug = iaa.Alpha(
                    0,
                    iaa.Affine(translate_px={"x": 1}),
                    iaa.Affine(translate_px={"x": -1}),
                    per_channel=per_channel)
                observed = aug.augment_heatmaps([self.heatmaps])[0]
                assert observed.shape == self.heatmaps.shape
                assert 0 - 1e-6 < self.heatmaps.min_value < 0 + 1e-6
                assert 1 - 1e-6 < self.heatmaps.max_value < 1 + 1e-6
                assert np.allclose(observed.get_arr(),
                                   self.heatmaps_l1.get_arr())
</source>
</class>

<class classid="137" nclones="2" nlines="12" similarity="83">
<source file="systems/imgaug-0.3.0/test/augmenters/test_blend.py" startline="601" endline="613" pcid="2279">

    def test_images_with_per_channel_in_both_alpha_and_child(self):
        image = np.zeros((1, 1, 1000), dtype=np.uint8)
        aug = iaa.Alpha(
            1.0,
            iaa.Add((0, 100), per_channel=True),
            None,
            per_channel=True)
        observed = aug.augment_image(image)
        uq = np.unique(observed)
        assert len(uq) > 1
        assert np.max(observed) > 80
        assert np.min(observed) < 20
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blend.py" startline="614" endline="626" pcid="2280">

    def test_images_with_per_channel_in_alpha_and_tuple_as_factor(self):
        image = np.zeros((1, 1, 1000), dtype=np.uint8)
        aug = iaa.Alpha(
            (0.0, 1.0),
            iaa.Add(100),
            None,
            per_channel=True)
        observed = aug.augment_image(image)
        uq = np.unique(observed)
        assert len(uq) > 1
        assert np.max(observed) > 80
        assert np.min(observed) < 20
</source>
</class>

<class classid="138" nclones="4" nlines="14" similarity="86">
<source file="systems/imgaug-0.3.0/test/augmenters/test_blend.py" startline="741" endline="757" pcid="2293">

    def test_keypoints_hooks_limit_propagation(self):
        aug = iaa.Alpha(
            0.0,
            iaa.Affine(translate_px={"x": 1}),
            iaa.Affine(translate_px={"y": 1}),
            name="AlphaTest")

        def propagator(kpsoi_to_aug, augmenter, parents, default):
            if "Alpha" in augmenter.name:
                return False
            else:
                return default

        hooks = ia.HooksKeypoints(propagator=propagator)
        observed = aug.augment_keypoints([self.kpsoi], hooks=hooks)[0]
        assert keypoints_equal([observed], [self.kpsoi])
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blend.py" startline="865" endline="883" pcid="2303">

    def test_polygons_hooks_limit_propagation(self):
        aug = iaa.Alpha(
            0.0,
            iaa.Affine(translate_px={"x": 1}),
            iaa.Affine(translate_px={"y": 1}),
            name="AlphaTest")

        def propagator(psoi_to_aug, augmenter, parents, default):
            if "Alpha" in augmenter.name:
                return False
            else:
                return default

        # no hooks for polygons yet, so we use HooksKeypoints
        hooks = ia.HooksKeypoints(propagator=propagator)
        observed = aug.augment_polygons([self.psoi], hooks=hooks)[0]
        assert observed.polygons[0].exterior_almost_equals(
            self.psoi.polygons[0])
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blend.py" startline="1471" endline="1489" pcid="2358">

    def test_polygons_hooks_limit_propagation(self):
        aug = iaa.AlphaElementwise(
            0.0,
            iaa.Affine(translate_px={"x": 1}),
            iaa.Affine(translate_px={"y": 1}),
            name="AlphaTest")

        def propagator(psoi_to_aug, augmenter, parents, default):
            if "Alpha" in augmenter.name:
                return False
            else:
                return default

        # no hooks for polygons yet, so we use HooksKeypoints
        hooks = ia.HooksKeypoints(propagator=propagator)
        observed = aug.augment_polygons([self.psoi], hooks=hooks)[0]
        assert observed.polygons[0].exterior_almost_equals(
            self.psoi.polygons[0])
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blend.py" startline="1311" endline="1327" pcid="2348">

    def test_keypoints_hooks_limit_propagation(self):
        aug = iaa.AlphaElementwise(
            0.0,
            iaa.Affine(translate_px={"x": 1}),
            iaa.Affine(translate_px={"y": 1}),
            name="AlphaElementwiseTest")

        def propagator(kpsoi_to_aug, augmenter, parents, default):
            if "AlphaElementwise" in augmenter.name:
                return False
            else:
                return default

        hooks = ia.HooksKeypoints(propagator=propagator)
        observed = aug.augment_keypoints([self.kpsoi], hooks=hooks)[0]
        assert keypoints_equal([observed], [self.kpsoi])
</source>
</class>

<class classid="139" nclones="2" nlines="10" similarity="100">
<source file="systems/imgaug-0.3.0/test/augmenters/test_blend.py" startline="778" endline="788" pcid="2297">

    def test_polygons_factor_is_0(self):
        aug = iaa.Alpha(0.0, iaa.Noop(), iaa.Affine(translate_px={"x": 1}))
        observed = aug.augment_polygons([self.psoi])
        expected = self.psoi.shift(left=1)
        assert len(observed) == 1
        assert len(observed[0].polygons) == 1
        assert observed[0].shape == self.psoi.shape
        assert observed[0].polygons[0].exterior_almost_equals(
            expected.polygons[0])
        assert observed[0].polygons[0].is_valid
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blend.py" startline="789" endline="799" pcid="2298">

    def test_polygons_factor_is_0499(self):
        aug = iaa.Alpha(0.499, iaa.Noop(), iaa.Affine(translate_px={"x": 1}))
        observed = aug.augment_polygons([self.psoi])
        expected = self.psoi.shift(left=1)
        assert len(observed) == 1
        assert len(observed[0].polygons) == 1
        assert observed[0].shape == self.psoi.shape
        assert observed[0].polygons[0].exterior_almost_equals(
            expected.polygons[0])
        assert observed[0].polygons[0].is_valid
</source>
</class>

<class classid="140" nclones="8" nlines="13" similarity="76">
<source file="systems/imgaug-0.3.0/test/augmenters/test_blend.py" startline="800" endline="813" pcid="2299">

    def test_polygons_factor_is_1_and_per_channel(self):
        aug = iaa.Alpha(
            1.0,
            iaa.Noop(),
            iaa.Affine(translate_px={"x": 1}),
            per_channel=True)
        observed = aug.augment_polygons([self.psoi])
        assert len(observed) == 1
        assert len(observed[0].polygons) == 1
        assert observed[0].shape == self.psoi.shape
        assert observed[0].polygons[0].exterior_almost_equals(
            self.psoi.polygons[0])
        assert observed[0].polygons[0].is_valid
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blend.py" startline="814" endline="828" pcid="2300">

    def test_polygons_factor_is_0_and_per_channel(self):
        aug = iaa.Alpha(
            0.0,
            iaa.Noop(),
            iaa.Affine(translate_px={"x": 1}),
            per_channel=True)
        observed = aug.augment_polygons([self.psoi])
        expected = self.psoi.shift(left=1)
        assert len(observed) == 1
        assert len(observed[0].polygons) == 1
        assert observed[0].shape == self.psoi.shape
        assert observed[0].polygons[0].exterior_almost_equals(
            expected.polygons[0])
        assert observed[0].polygons[0].is_valid
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blend.py" startline="1354" endline="1367" pcid="2352">

    def test_polygons_factor_is_0(self):
        aug = iaa.AlphaElementwise(
            0.0,
            iaa.Noop(),
            iaa.Affine(translate_px={"x": 1}))
        observed = aug.augment_polygons([self.psoi])
        expected = self.psoi.shift(left=1)
        assert len(observed) == 1
        assert len(observed[0].polygons) == 1
        assert observed[0].shape == self.psoi.shape
        assert observed[0].polygons[0].exterior_almost_equals(
            expected.polygons[0])
        assert observed[0].polygons[0].is_valid
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blend.py" startline="1328" endline="1340" pcid="2350">

    def test_polygons_factor_is_1(self):
        aug = iaa.AlphaElementwise(
            1.0,
            iaa.Noop(),
            iaa.Affine(translate_px={"x": 1}))
        observed = aug.augment_polygons([self.psoi])
        assert len(observed) == 1
        assert len(observed[0].polygons) == 1
        assert observed[0].shape == self.psoi.shape
        assert observed[0].polygons[0].exterior_almost_equals(
            self.psoi.polygons[0])
        assert observed[0].polygons[0].is_valid
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blend.py" startline="1341" endline="1353" pcid="2351">

    def test_polygons_factor_is_0501(self):
        aug = iaa.AlphaElementwise(
            0.501,
            iaa.Noop(),
            iaa.Affine(translate_px={"x": 1}))
        observed = aug.augment_polygons([self.psoi])
        assert len(observed) == 1
        assert len(observed[0].polygons) == 1
        assert observed[0].shape == self.psoi.shape
        assert observed[0].polygons[0].exterior_almost_equals(
            self.psoi.polygons[0])
        assert observed[0].polygons[0].is_valid
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blend.py" startline="1382" endline="1395" pcid="2354">

    def test_polygons_factor_is_1_and_per_channel(self):
        aug = iaa.AlphaElementwise(
            1.0,
            iaa.Noop(),
            iaa.Affine(translate_px={"x": 1}),
            per_channel=True)
        observed = aug.augment_polygons([self.psoi])
        assert len(observed) == 1
        assert len(observed[0].polygons) == 1
        assert observed[0].shape == self.psoi.shape
        assert observed[0].polygons[0].exterior_almost_equals(
            self.psoi.polygons[0])
        assert observed[0].polygons[0].is_valid
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blend.py" startline="1368" endline="1381" pcid="2353">

    def test_polygons_factor_is_0499(self):
        aug = iaa.AlphaElementwise(
            0.499,
            iaa.Noop(),
            iaa.Affine(translate_px={"x": 1}))
        observed = aug.augment_polygons([self.psoi])
        expected = self.psoi.shift(left=1)
        assert len(observed) == 1
        assert len(observed[0].polygons) == 1
        assert observed[0].shape == self.psoi.shape
        assert observed[0].polygons[0].exterior_almost_equals(
            expected.polygons[0])
        assert observed[0].polygons[0].is_valid
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blend.py" startline="1396" endline="1410" pcid="2355">

    def test_polygons_factor_is_0_and_per_channel(self):
        aug = iaa.AlphaElementwise(
            0.0,
            iaa.Noop(),
            iaa.Affine(translate_px={"x": 1}),
            per_channel=True)
        observed = aug.augment_polygons([self.psoi])
        expected = self.psoi.shift(left=1)
        assert len(observed) == 1
        assert len(observed[0].polygons) == 1
        assert observed[0].shape == self.psoi.shape
        assert observed[0].polygons[0].exterior_almost_equals(
            expected.polygons[0])
        assert observed[0].polygons[0].is_valid
</source>
</class>

<class classid="141" nclones="2" nlines="28" similarity="70">
<source file="systems/imgaug-0.3.0/test/augmenters/test_blend.py" startline="829" endline="857" pcid="2301">

    def test_polygons_factor_is_choice_around_050_and_per_channel(self):
        aug = iaa.Alpha(
            iap.Choice([0.49, 0.51]),
            iaa.Noop(),
            iaa.Affine(translate_px={"x": 1}),
            per_channel=True)
        psoi = self.psoi
        expected_same = psoi.deepcopy()
        expected_shifted = psoi.shift(left=1)
        seen = [0, 0, 0]
        for _ in sm.xrange(200):
            observed = aug.augment_polygons([psoi])[0]
            # We use here allclose() instead of exterior_almost_equals()
            # as the latter one is much slower and we don't have to deal
            # with tricky geometry changes here, just naive shifting.
            if np.allclose(observed.polygons[0].exterior,
                           expected_same.polygons[0].exterior,
                           rtol=0, atol=0.1):
                seen[0] += 1
            elif np.allclose(observed.polygons[0].exterior,
                             expected_shifted.polygons[0].exterior,
                             rtol=0, atol=0.1):
                seen[1] += 1
            else:
                seen[2] += 1
        assert 100 - 50 < seen[0] < 100 + 50
        assert 100 - 50 < seen[1] < 100 + 50
        assert seen[2] == 0
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blend.py" startline="1411" endline="1460" pcid="2356">

    def test_polygons_factor_is_choice_around_050_and_per_channel(self):
        aug = iaa.AlphaElementwise(
            iap.Choice([0.49, 0.51]),
            iaa.Noop(),
            iaa.Affine(translate_px={"x": 1}),
            per_channel=True)
        ps = [ia.Polygon([(0, 0), (15, 0), (10, 0), (10, 5), (10, 10),
                          (5, 10), (5, 5), (0, 10), (0, 5), (0, 0)])]
        psoi = ia.PolygonsOnImage(ps, shape=(15, 15, 3))

        expected_same = psoi.deepcopy()
        expected_shifted = psoi.shift(left=1)

        nb_iterations = 400
        seen = [0, 0, 0]
        for _ in sm.xrange(nb_iterations):
            observed = aug.augment_polygons([psoi])[0]
            # We use here allclose() instead of exterior_almost_equals()
            # as the latter one is much slower and we don't have to deal
            # with tricky geometry changes here, just naive shifting.
            if np.allclose(observed.polygons[0].exterior,
                           expected_same.polygons[0].exterior,
                           rtol=0, atol=0.1):
                seen[0] += 1
            elif np.allclose(observed.polygons[0].exterior,
                             expected_shifted.polygons[0].exterior,
                             rtol=0, atol=0.1):
                seen[1] += 1
            else:
                seen[2] += 1

        # This code can be used if the polygon augmentation mode is
        # AlphaElementwise._MODE_POINTWISE. Currently it is _MODE_EITHER_OR.
        #
        # nb_points = len(ps[0].exterior)
        # p_all_same = 2 * ((1/2)**nb_points)  # all points moved in same way
        # expected_iter = nb_iterations*p_all_same
        # expected_iter_notsame = nb_iterations*(1-p_all_same)
        # atol = nb_iterations * (5*p_all_same)
        #
        # assert np.isclose(seen[0], expected_iter, rtol=0, atol=atol)
        # assert np.isclose(seen[1], expected_iter, rtol=0, atol=atol)
        # assert np.isclose(seen[2], expected_iter_notsame, rtol=0, atol=atol)

        expected_iter = nb_iterations*0.5
        atol = nb_iterations*0.15
        assert np.isclose(seen[0], expected_iter, rtol=0, atol=atol)
        assert np.isclose(seen[1], expected_iter, rtol=0, atol=atol)
        assert seen[2] == 0
</source>
</class>

<class classid="142" nclones="4" nlines="10" similarity="72">
<source file="systems/imgaug-0.3.0/test/augmenters/test_blend.py" startline="1034" endline="1044" pcid="2322">

    def test_heatmaps_factor_is_1_with_affines(self):
        aug = iaa.AlphaElementwise(
            1,
            iaa.Affine(translate_px={"x": 1}),
            iaa.Affine(translate_px={"x": -1}))
        observed = aug.augment_heatmaps([self.heatmaps])[0]
        assert observed.shape == (3, 3, 3)
        assert 0 - 1e-6 < observed.min_value < 0 + 1e-6
        assert 1 - 1e-6 < observed.max_value < 1 + 1e-6
        assert np.allclose(observed.get_arr(), self.heatmaps_r1.get_arr())
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blend.py" startline="1180" endline="1191" pcid="2337">

    def test_heatmaps_and_per_channel_factor_is_ones(self):
        aug = iaa.AlphaElementwise(
            _DummyMaskParameter(inverted=True),
            iaa.Affine(translate_px={"x": 1}),
            iaa.Affine(translate_px={"x": -1}),
            per_channel=True)
        observed = aug.augment_heatmaps([self.heatmaps])[0]
        assert observed.shape == (3, 3, 3)
        assert 0 - 1e-6 < observed.min_value < 0 + 1e-6
        assert 1 - 1e-6 < observed.max_value < 1 + 1e-6
        assert np.allclose(observed.get_arr(), self.heatmaps_l1.get_arr())
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blend.py" startline="1168" endline="1179" pcid="2336">

    def test_heatmaps_and_per_channel_factor_is_zeros(self):
        aug = iaa.AlphaElementwise(
            _DummyMaskParameter(inverted=False),
            iaa.Affine(translate_px={"x": 1}),
            iaa.Affine(translate_px={"x": -1}),
            per_channel=True)
        observed = aug.augment_heatmaps([self.heatmaps])[0]
        assert observed.shape == (3, 3, 3)
        assert 0 - 1e-6 < observed.min_value < 0 + 1e-6
        assert 1 - 1e-6 < observed.max_value < 1 + 1e-6
        assert np.allclose(observed.get_arr(), self.heatmaps_r1.get_arr())
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_blend.py" startline="1060" endline="1070" pcid="2325">

    def test_heatmaps_factor_is_0_with_affines(self):
        aug = iaa.AlphaElementwise(
            0,
            iaa.Affine(translate_px={"x": 1}),
            iaa.Affine(translate_px={"x": -1}))
        observed = aug.augment_heatmaps([self.heatmaps])[0]
        assert observed.shape == (3, 3, 3)
        assert 0 - 1e-6 < observed.min_value < 0 + 1e-6
        assert 1 - 1e-6 < observed.max_value < 1 + 1e-6
        assert np.allclose(observed.get_arr(), self.heatmaps_l1.get_arr())
</source>
</class>

<class classid="143" nclones="4" nlines="21" similarity="90">
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="329" endline="350" pcid="2393">
    def test_size_is_list_of_ints(self):
        aug = iaa.Resize([12, 14])
        seen2d = [False, False]
        seen3d = [False, False]
        for _ in sm.xrange(100):
            observed2d = aug.augment_image(self.image2d)
            observed3d = aug.augment_image(self.image3d)
            assert observed2d.shape in [(12, 12), (14, 14)]
            assert observed3d.shape in [(12, 12, 3), (14, 14, 3)]
            if observed2d.shape == (12, 12):
                seen2d[0] = True
            else:
                seen2d[1] = True
            if observed3d.shape == (12, 12, 3):
                seen3d[0] = True
            else:
                seen3d[1] = True
            if all(seen2d) and all(seen3d):
                break
        assert np.all(seen2d)
        assert np.all(seen3d)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="518" endline="539" pcid="2409">
    def test_change_height_by_fixed_int_width_by_stochastic_parameter(self):
        aug = iaa.Resize({"height": 12, "width": iap.Choice([12, 14])})
        seen2d = [False, False]
        seen3d = [False, False]
        for _ in sm.xrange(100):
            observed2d = aug.augment_image(self.image2d)
            observed3d = aug.augment_image(self.image3d)
            assert observed2d.shape in [(12, 12), (12, 14)]
            assert observed3d.shape in [(12, 12, 3), (12, 14, 3)]
            if observed2d.shape == (12, 12):
                seen2d[0] = True
            else:
                seen2d[1] = True
            if observed3d.shape == (12, 12, 3):
                seen3d[0] = True
            else:
                seen3d[1] = True
            if np.all(seen2d) and np.all(seen3d):
                break
        assert np.all(seen2d)
        assert np.all(seen3d)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="496" endline="517" pcid="2408">
    def test_change_height_by_fixed_int_width_by_list_of_ints(self):
        aug = iaa.Resize({"height": 12, "width": [12, 14]})
        seen2d = [False, False]
        seen3d = [False, False]
        for _ in sm.xrange(100):
            observed2d = aug.augment_image(self.image2d)
            observed3d = aug.augment_image(self.image3d)
            assert observed2d.shape in [(12, 12), (12, 14)]
            assert observed3d.shape in [(12, 12, 3), (12, 14, 3)]
            if observed2d.shape == (12, 12):
                seen2d[0] = True
            else:
                seen2d[1] = True
            if observed3d.shape == (12, 12, 3):
                seen3d[0] = True
            else:
                seen3d[1] = True
            if np.all(seen2d) and np.all(seen3d):
                break
        assert np.all(seen2d)
        assert np.all(seen3d)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="474" endline="495" pcid="2407">
    def test_change_height_by_list_of_ints_width_by_fixed_int(self):
        aug = iaa.Resize({"height": [12, 14], "width": 12})
        seen2d = [False, False]
        seen3d = [False, False]
        for _ in sm.xrange(100):
            observed2d = aug.augment_image(self.image2d)
            observed3d = aug.augment_image(self.image3d)
            assert observed2d.shape in [(12, 12), (14, 12)]
            assert observed3d.shape in [(12, 12, 3), (14, 12, 3)]
            if observed2d.shape == (12, 12):
                seen2d[0] = True
            else:
                seen2d[1] = True
            if observed3d.shape == (12, 12, 3):
                seen3d[0] = True
            else:
                seen3d[1] = True
            if np.all(seen2d) and np.all(seen3d):
                break
        assert np.all(seen2d)
        assert np.all(seen3d)

</source>
</class>

<class classid="144" nclones="2" nlines="25" similarity="92">
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="351" endline="376" pcid="2394">
    def test_size_is_tuple_of_ints(self):
        aug = iaa.Resize((12, 14))
        seen2d = [False, False, False]
        seen3d = [False, False, False]
        for _ in sm.xrange(100):
            observed2d = aug.augment_image(self.image2d)
            observed3d = aug.augment_image(self.image3d)
            assert observed2d.shape in [(12, 12), (13, 13), (14, 14)]
            assert observed3d.shape in [(12, 12, 3), (13, 13, 3), (14, 14, 3)]
            if observed2d.shape == (12, 12):
                seen2d[0] = True
            elif observed2d.shape == (13, 13):
                seen2d[1] = True
            else:
                seen2d[2] = True
            if observed3d.shape == (12, 12, 3):
                seen3d[0] = True
            elif observed3d.shape == (13, 13, 3):
                seen3d[1] = True
            else:
                seen3d[2] = True
            if all(seen2d) and all(seen3d):
                break
        assert np.all(seen2d)
        assert np.all(seen3d)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="540" endline="565" pcid="2410">
    def test_change_height_by_tuple_of_ints_width_by_fixed_int(self):
        aug = iaa.Resize({"height": (12, 14), "width": 12})
        seen2d = [False, False, False]
        seen3d = [False, False, False]
        for _ in sm.xrange(100):
            observed2d = aug.augment_image(self.image2d)
            observed3d = aug.augment_image(self.image3d)
            assert observed2d.shape in [(12, 12), (13, 12), (14, 12)]
            assert observed3d.shape in [(12, 12, 3), (13, 12, 3), (14, 12, 3)]
            if observed2d.shape == (12, 12):
                seen2d[0] = True
            elif observed2d.shape == (13, 12):
                seen2d[1] = True
            else:
                seen2d[2] = True
            if observed3d.shape == (12, 12, 3):
                seen3d[0] = True
            elif observed3d.shape == (13, 12, 3):
                seen3d[1] = True
            else:
                seen3d[2] = True
            if np.all(seen2d) and np.all(seen3d):
                break
        assert np.all(seen2d)
        assert np.all(seen3d)

</source>
</class>

<class classid="145" nclones="2" nlines="27" similarity="92">
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="582" endline="609" pcid="2412">
    def test_size_is_list(self):
        aug = iaa.Resize([2.0, 4.0])
        seen2d = [False, False]
        seen3d = [False, False]
        expected_shapes_2d = [
            (self.image2d.shape[0]*2, self.image2d.shape[1]*2),
            (self.image2d.shape[0]*4, self.image2d.shape[1]*4)]
        expected_shapes_3d = [
            (self.image3d.shape[0]*2, self.image3d.shape[1]*2, 3),
            (self.image3d.shape[0]*4, self.image3d.shape[1]*4, 3)]
        for _ in sm.xrange(100):
            observed2d = aug.augment_image(self.image2d)
            observed3d = aug.augment_image(self.image3d)
            assert observed2d.shape in expected_shapes_2d
            assert observed3d.shape in expected_shapes_3d
            if observed2d.shape == expected_shapes_2d[0]:
                seen2d[0] = True
            else:
                seen2d[1] = True
            if observed3d.shape == expected_shapes_3d[0]:
                seen3d[0] = True
            else:
                seen3d[1] = True
            if np.all(seen2d) and np.all(seen3d):
                break
        assert np.all(seen2d)
        assert np.all(seen3d)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="610" endline="637" pcid="2413">
    def test_size_is_stochastic_parameter(self):
        aug = iaa.Resize(iap.Choice([2.0, 4.0]))
        seen2d = [False, False]
        seen3d = [False, False]
        expected_shapes_2d = [
            (self.image2d.shape[0]*2, self.image2d.shape[1]*2),
            (self.image2d.shape[0]*4, self.image2d.shape[1]*4)]
        expected_shapes_3d = [
            (self.image3d.shape[0]*2, self.image3d.shape[1]*2, 3),
            (self.image3d.shape[0]*4, self.image3d.shape[1]*4, 3)]
        for _ in sm.xrange(100):
            observed2d = aug.augment_image(self.image2d)
            observed3d = aug.augment_image(self.image3d)
            assert observed2d.shape in expected_shapes_2d
            assert observed3d.shape in expected_shapes_3d
            if observed2d.shape == expected_shapes_2d[0]:
                seen2d[0] = True
            else:
                seen2d[1] = True
            if observed3d.shape == expected_shapes_3d[0]:
                seen3d[0] = True
            else:
                seen3d[1] = True
            if all(seen2d) and all(seen3d):
                break
        assert np.all(seen2d)
        assert np.all(seen3d)

</source>
</class>

<class classid="146" nclones="2" nlines="26" similarity="88">
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="638" endline="663" pcid="2414">
    def test_decrease_size_by_tuple_of_floats__one_for_both_sides(self):
        image2d = self.image2d[0:4, 0:4]
        image3d = self.image3d[0:4, 0:4, :]
        aug = iaa.Resize((0.76, 1.0))
        not_seen2d = set()
        not_seen3d = set()
        for size in sm.xrange(3, 4+1):
            not_seen2d.add((size, size))
        for size in sm.xrange(3, 4+1):
            not_seen3d.add((size, size, 3))
        possible2d = set(list(not_seen2d))
        possible3d = set(list(not_seen3d))
        for _ in sm.xrange(100):
            observed2d = aug.augment_image(image2d)
            observed3d = aug.augment_image(image3d)
            assert observed2d.shape in possible2d
            assert observed3d.shape in possible3d
            if observed2d.shape in not_seen2d:
                not_seen2d.remove(observed2d.shape)
            if observed3d.shape in not_seen3d:
                not_seen3d.remove(observed3d.shape)
            if not not_seen2d and not not_seen3d:
                break
        assert not not_seen2d
        assert not not_seen3d

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="664" endline="691" pcid="2415">
    def test_decrease_size_by_tuples_of_floats__one_per_side(self):
        image2d = self.image2d[0:4, 0:4]
        image3d = self.image3d[0:4, 0:4, :]
        aug = iaa.Resize({"height": (0.76, 1.0), "width": (0.76, 1.0)})
        not_seen2d = set()
        not_seen3d = set()
        for hsize in sm.xrange(3, 4+1):
            for wsize in sm.xrange(3, 4+1):
                not_seen2d.add((hsize, wsize))
        for hsize in sm.xrange(3, 4+1):
            for wsize in sm.xrange(3, 4+1):
                not_seen3d.add((hsize, wsize, 3))
        possible2d = set(list(not_seen2d))
        possible3d = set(list(not_seen3d))
        for _ in sm.xrange(100):
            observed2d = aug.augment_image(image2d)
            observed3d = aug.augment_image(image3d)
            assert observed2d.shape in possible2d
            assert observed3d.shape in possible3d
            if observed2d.shape in not_seen2d:
                not_seen2d.remove(observed2d.shape)
            if observed3d.shape in not_seen3d:
                not_seen3d.remove(observed3d.shape)
            if not not_seen2d and not not_seen3d:
                break
        assert not not_seen2d
        assert not not_seen3d

</source>
</class>

<class classid="147" nclones="2" nlines="26" similarity="88">
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="827" endline="858" pcid="2429">
    def test_pad_heatmaps_by_1px_each_side_on_its_own(self):
        pads = [
            (1, 0, 0, 0),
            (0, 1, 0, 0),
            (0, 0, 1, 0),
            (0, 0, 0, 1),
        ]
        for pad in pads:
            with self.subTest(px=pad):
                aug = iaa.Pad(px=pad, keep_size=False)

                top, right, bottom, left = pad

                heatmaps_arr = self.heatmap.get_arr()
                heatmaps_arr_padded = np.pad(
                    heatmaps_arr,
                    ((top, bottom), (left, right)),
                    mode="constant",
                    constant_values=0)
                heatmaps = [ia.HeatmapsOnImage(
                    heatmaps_arr, shape=self.image.shape)]
                image_padded_shape = list(self.image.shape)
                image_padded_shape[0] += top + bottom
                image_padded_shape[1] += left + right

                observed = aug.augment_heatmaps(heatmaps)[0]

                assert observed.shape == tuple(image_padded_shape)
                assert 0 - 1e-6 < observed.min_value < 0 + 1e-6
                assert 1 - 1e-6 < observed.max_value < 1 + 1e-6
                assert np.array_equal(observed.get_arr(), heatmaps_arr_padded)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="859" endline="888" pcid="2430">
    def test_pad_segmaps_by_1px_each_side_on_its_own(self):
        pads = [
            (1, 0, 0, 0),
            (0, 1, 0, 0),
            (0, 0, 1, 0),
            (0, 0, 0, 1),
        ]
        for pad in pads:
            with self.subTest(px=pad):
                aug = iaa.Pad(px=pad, keep_size=False)

                top, right, bottom, left = pad

                segmaps_arr = self.segmap.get_arr()
                segmaps_arr_padded = np.pad(
                    segmaps_arr,
                    ((top, bottom), (left, right)),
                    mode="constant",
                    constant_values=0)
                segmaps = [SegmentationMapsOnImage(
                    segmaps_arr, shape=self.image.shape)]
                image_padded_shape = list(self.image.shape)
                image_padded_shape[0] += top + bottom
                image_padded_shape[1] += left + right

                observed = aug.augment_segmentation_maps(segmaps)[0]

                assert observed.shape == tuple(image_padded_shape)
                assert np.array_equal(observed.get_arr(), segmaps_arr_padded)

</source>
</class>

<class classid="148" nclones="4" nlines="62" similarity="70">
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="889" endline="975" pcid="2431">
    def test_pad_each_side_on_its_own_by_tuple_of_ints(self):
        def _to_range_tuple(val):
            return val if isinstance(val, tuple) else (val, val)

        pads = [
            ((0, 2), 0, 0, 0),
            (0, (0, 2), 0, 0),
            (0, 0, (0, 2), 0),
            (0, 0, 0, (0, 2)),
        ]
        for pad in pads:
            with self.subTest(px=pad):
                aug = iaa.Pad(px=pad, keep_size=False)
                aug_det = aug.to_deterministic()

                top, right, bottom, left = pad

                images_padded = []
                keypoints_padded = []
                top_range = _to_range_tuple(top)
                right_range = _to_range_tuple(right)
                bottom_range = _to_range_tuple(bottom)
                left_range = _to_range_tuple(left)

                top_values = sm.xrange(top_range[0], top_range[1]+1)
                right_values = sm.xrange(right_range[0], right_range[1]+1)
                bottom_values = sm.xrange(bottom_range[0], bottom_range[1]+1)
                left_values = sm.xrange(left_range[0], left_range[1]+1)

                for top_val in top_values:
                    for right_val in right_values:
                        for bottom_val in bottom_values:
                            for left_val in left_values:
                                images_padded.append(
                                    np.pad(
                                        self.image,
                                        ((top_val, bottom_val),
                                         (left_val, right_val),
                                         (0, 0)),
                                        mode="constant",
                                        constant_values=0
                                    )
                                )
                                keypoints_padded.append(
                                    self.kpsoi[0].shift(x=left_val, y=top_val))

                movements = []
                movements_det = []
                for i in sm.xrange(100):
                    observed = aug.augment_images(self.images)

                    matches = [
                        (1 if np.array_equal(observed,
                                             np.array([base_img_padded]))
                         else 0)
                        for base_img_padded
                        in images_padded
                    ]
                    movements.append(np.argmax(np.array(matches)))
                    assert any([val == 1 for val in matches])

                    observed = aug_det.augment_images(self.images)
                    matches = [
                        (1 if np.array_equal(observed,
                                             np.array([base_img_padded]))
                         else 0)
                        for base_img_padded
                        in images_padded
                    ]
                    movements_det.append(np.argmax(np.array(matches)))
                    assert any([val == 1 for val in matches])

                    observed = aug.augment_images([self.image])
                    assert any([
                        array_equal_lists(observed, [base_img_padded])
                        for base_img_padded
                        in images_padded])

                    observed = aug.augment_keypoints(self.kpsoi)
                    assert any([
                        keypoints_equal(observed, [kp])
                        for kp
                        in keypoints_padded])

                assert len(set(movements)) == 3
                assert len(set(movements_det)) == 1

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="976" endline="1050" pcid="2433">
    def test_pad_each_side_on_its_own_by_list_of_ints(self):
        # test pad by list of exact pixel values
        pads = [
            ([0, 2], 0, 0, 0),
            (0, [0, 2], 0, 0),
            (0, 0, [0, 2], 0),
            (0, 0, 0, [0, 2]),
        ]
        for pad in pads:
            top, right, bottom, left = pad
            aug = iaa.Pad(px=pad, keep_size=False)
            aug_det = aug.to_deterministic()

            images_padded = []
            keypoints_padded = []
            top_range = top if isinstance(top, list) else [top]
            right_range = right if isinstance(right, list) else [right]
            bottom_range = bottom if isinstance(bottom, list) else [bottom]
            left_range = left if isinstance(left, list) else [left]

            for top_val in top_range:
                for right_val in right_range:
                    for bottom_val in bottom_range:
                        for left_val in left_range:
                            images_padded.append(
                                np.pad(
                                    self.image,
                                    ((top_val, bottom_val),
                                     (left_val, right_val),
                                     (0, 0)),
                                    mode="constant",
                                    constant_values=0
                                )
                            )
                            keypoints_padded.append(
                                self.kpsoi[0].shift(x=left_val, y=top_val))

            movements = []
            movements_det = []
            for i in sm.xrange(100):
                observed = aug.augment_images(self.images)
                matches = [
                    (1 if np.array_equal(observed,
                                         np.array([base_img_padded]))
                     else 0)
                    for base_img_padded
                    in images_padded]
                movements.append(np.argmax(np.array(matches)))
                assert any([val == 1 for val in matches])

                observed = aug_det.augment_images(self.images)
                matches = [
                    (1 if np.array_equal(observed,
                                         np.array([base_img_padded]))
                     else 0)
                    for base_img_padded
                    in images_padded]
                movements_det.append(np.argmax(np.array(matches)))
                assert any([val == 1 for val in matches])

                observed = aug.augment_images([self.image])
                assert any([
                    array_equal_lists(observed, [base_img_padded])
                    for base_img_padded
                    in images_padded])

                observed = aug.augment_keypoints(self.kpsoi)
                assert any([
                    keypoints_equal(observed, [kp])
                    for kp
                    in keypoints_padded])

            assert len(set(movements)) == 2
            assert len(set(movements_det)) == 1

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="1949" endline="2031" pcid="2483">
                assert np.array_equal(observed.get_arr(), segmaps_arr_cropped)

    def test_crop_by_tuple_of_ints_on_each_side_on_its_own(self):
        def _to_range_tuple(val):
            return val if isinstance(val, tuple) else (val, val)

        crops = [
            ((0, 2), 0, 0, 0),
            (0, (0, 2), 0, 0),
            (0, 0, (0, 2), 0),
            (0, 0, 0, (0, 2)),
        ]
        for crop in crops:
            with self.subTest(px=crop):
                aug = iaa.Crop(px=crop, keep_size=False)
                aug_det = aug.to_deterministic()

                top, right, bottom, left = crop
                height, width = self.image.shape[0:2]

                top_range = _to_range_tuple(top)
                right_range = _to_range_tuple(right)
                bottom_range = _to_range_tuple(bottom)
                left_range = _to_range_tuple(left)

                top_values = sm.xrange(top_range[0], top_range[1]+1)
                right_values = sm.xrange(right_range[0], right_range[1]+1)
                bottom_values = sm.xrange(bottom_range[0], bottom_range[1]+1)
                left_values = sm.xrange(left_range[0], left_range[1]+1)

                images_cropped = []
                keypoints_cropped = []
                for top_val in top_values:
                    for right_val in right_values:
                        for bottom_val in bottom_values:
                            for left_val in left_values:
                                images_cropped.append(
                                    self.image[top_val:height-bottom_val,
                                               left_val:width-right_val,
                                               :]
                                )
                                keypoints_cropped.append(
                                    self.kpsoi[0].shift(
                                        x=-left_val, y=-top_val)
                                )

                movements = []
                movements_det = []
                for i in sm.xrange(100):
                    observed = aug.augment_images(self.images)

                    matches = [
                        (1
                         if np.array_equal(observed,
                                           np.array([base_img_cropped]))
                         else 0)
                        for base_img_cropped
                        in images_cropped]
                    movements.append(np.argmax(np.array(matches)))
                    assert any([val == 1 for val in matches])

                    observed = aug_det.augment_images(self.images)
                    matches = [
                        (1
                         if np.array_equal(observed,
                                           np.array([base_img_cropped]))
                         else 0)
                        for base_img_cropped
                        in images_cropped]
                    movements_det.append(np.argmax(np.array(matches)))
                    assert any([val == 1 for val in matches])

                    observed = aug.augment_images([self.image])
                    assert any([array_equal_lists(observed, [base_img_cropped])
                                for base_img_cropped
                                in images_cropped])

                    observed = aug.augment_keypoints(self.kpsoi)
                    assert any([keypoints_equal(observed, [kp])
                                for kp
                                in keypoints_cropped])

                assert len(set(movements)) == 3
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="2032" endline="2105" pcid="2485">
                assert len(set(movements_det)) == 1

    def test_crop_by_list_of_ints_on_each_side_on_its_own(self):
        # test crop by list of exact pixel values
        crops = [
            ([0, 2], 0, 0, 0),
            (0, [0, 2], 0, 0),
            (0, 0, [0, 2], 0),
            (0, 0, 0, [0, 2]),
        ]
        for crop in crops:
            with self.subTest(px=crop):
                aug = iaa.Crop(px=crop, keep_size=False)
                aug_det = aug.to_deterministic()

                top, right, bottom, left = crop
                height, width = self.image.shape[0:2]

                top_range = top if isinstance(top, list) else [top]
                right_range = right if isinstance(right, list) else [right]
                bottom_range = bottom if isinstance(bottom, list) else [bottom]
                left_range = left if isinstance(left, list) else [left]

                images_cropped = []
                keypoints_cropped = []
                for top_val in top_range:
                    for right_val in right_range:
                        for bottom_val in bottom_range:
                            for left_val in left_range:
                                images_cropped.append(
                                    self.image[top_val:height-bottom_val,
                                               left_val:width-right_val,
                                               :]
                                )
                                keypoints_cropped.append(
                                    self.kpsoi[0].shift(
                                        x=-left_val, y=-top_val)
                                )

                movements = []
                movements_det = []
                for i in sm.xrange(100):
                    observed = aug.augment_images(self.images)
                    matches = [
                        (1
                         if np.array_equal(observed,
                                           np.array([base_img_cropped]))
                         else 0)
                        for base_img_cropped
                        in images_cropped]
                    movements.append(np.argmax(np.array(matches)))
                    assert any([val == 1 for val in matches])

                    observed = aug_det.augment_images(self.images)
                    matches = [
                        (1
                         if np.array_equal(observed,
                                           np.array([base_img_cropped]))
                         else 0)
                        for base_img_cropped in images_cropped]
                    movements_det.append(np.argmax(np.array(matches)))
                    assert any([val == 1 for val in matches])

                    observed = aug.augment_images([self.image])
                    assert any([array_equal_lists(observed, [base_img_cropped])
                                for base_img_cropped
                                in images_cropped])

                    observed = aug.augment_keypoints(self.kpsoi)
                    assert any([keypoints_equal(observed, [kp])
                                for kp
                                in keypoints_cropped])

                assert len(set(movements)) == 2
</source>
</class>

<class classid="149" nclones="4" nlines="23" similarity="72">
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="1051" endline="1080" pcid="2434">
    def test_pad_heatmaps_smaller_than_img_by_tuple_of_ints_without_ks(self):
        # pad smaller heatmaps
        # heatmap is (6, 4), image is (6, 16)
        # image is padded by (2, 4, 2, 4)
        # expected image size: (10, 24)
        # expected heatmap size: (10, 6)
        aug = iaa.Pad(px=(2, 4, 2, 4), keep_size=False)
        heatmaps_arr_small = np.float32([
            [0, 0, 0, 0],
            [0, 1.0, 1.0, 0],
            [0, 1.0, 1.0, 0],
            [0, 1.0, 1.0, 0],
            [0, 1.0, 1.0, 0],
            [0, 0, 0, 0]
        ])
        top, bottom, left, right = 2, 2, 1, 1
        heatmaps_arr_small_padded = np.pad(
            heatmaps_arr_small,
            ((top, bottom), (left, right)),
            mode="constant",
            constant_values=0)
        heatmaps = [ia.HeatmapsOnImage(heatmaps_arr_small, shape=(6, 16))]
        observed = aug.augment_heatmaps(heatmaps)[0]

        assert observed.shape == (10, 24)
        assert observed.arr_0to1.shape == (10, 6, 1)
        assert 0 - 1e-6 < observed.min_value < 0 + 1e-6
        assert 1 - 1e-6 < observed.max_value < 1 + 1e-6
        assert np.allclose(observed.arr_0to1[..., 0], heatmaps_arr_small_padded)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="1491" endline="1521" pcid="2458">
    def test_pad_heatmaps_smaller_than_img_by_floats_without_keep_size(self):
        # pad smaller heatmaps
        # heatmap is (6, 4), image is (6, 16)
        # image is padded by (0.5, 0.25, 0.5, 0.25)
        # expected image size: (12, 24)
        # expected heatmap size: (12, 6)
        aug = iaa.Pad(percent=(0.5, 0.25, 0.5, 0.25), keep_size=False)
        heatmaps_arr_small = np.float32([
            [0, 0, 0, 0],
            [0, 1.0, 1.0, 0],
            [0, 1.0, 1.0, 0],
            [0, 1.0, 1.0, 0],
            [0, 1.0, 1.0, 0],
            [0, 0, 0, 0]
        ])
        top, bottom, left, right = 3, 3, 1, 1
        heatmaps_arr_small_padded = np.pad(
            heatmaps_arr_small,
            ((top, bottom), (left, right)),
            mode="constant",
            constant_values=0)
        heatmaps = [ia.HeatmapsOnImage(heatmaps_arr_small, shape=(6, 16))]

        observed = aug.augment_heatmaps(heatmaps)[0]

        assert observed.shape == (12, 24)
        assert observed.arr_0to1.shape == (12, 6, 1)
        assert 0 - 1e-6 < observed.min_value < 0 + 1e-6
        assert 1 - 1e-6 < observed.max_value < 1 + 1e-6
        assert np.allclose(observed.arr_0to1[..., 0], heatmaps_arr_small_padded)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="1546" endline="1582" pcid="2460">
    def test_pad_heatmaps_smaller_than_img_by_floats_with_keep_size(self):
        # pad smaller heatmaps, with keep_size=True
        # heatmap is (6, 4), image is (6, 16)
        # image is padded by (0.5, 0.25, 0.5, 0.25)
        # expected image size: (12, 24) -> (6, 16) after resize
        # expected heatmap size: (12, 6) -> (6, 4) after resize
        aug = iaa.Pad(percent=(0.5, 0.25, 0.5, 0.25), keep_size=True)
        heatmaps_arr_small = np.float32([
            [0, 0, 0, 0],
            [0, 1.0, 1.0, 0],
            [0, 1.0, 1.0, 0],
            [0, 1.0, 1.0, 0],
            [0, 1.0, 1.0, 0],
            [0, 0, 0, 0]
        ])
        top, bottom, left, right = 3, 3, 1, 1
        heatmaps_arr_small_padded = np.pad(
            heatmaps_arr_small,
            ((top, bottom), (left, right)),
            mode="constant",
            constant_values=0)
        heatmaps = [ia.HeatmapsOnImage(heatmaps_arr_small, shape=(6, 16))]

        observed = aug.augment_heatmaps(heatmaps)[0]
        assert observed.shape == (6, 16)
        assert observed.arr_0to1.shape == (6, 4, 1)
        assert 0 - 1e-6 < observed.min_value < 0 + 1e-6
        assert 1 - 1e-6 < observed.max_value < 1 + 1e-6
        assert np.allclose(
            observed.arr_0to1[..., 0],
            np.clip(
                ia.imresize_single_image(
                    heatmaps_arr_small_padded, (6, 4), interpolation="cubic"),
                0, 1.0
            )
        )

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="1107" endline="1146" pcid="2436">
    def test_pad_heatmaps_smaller_than_img_by_tuple_of_ints_with_ks(self):
        # pad smaller heatmaps, with keep_size=True
        # heatmap is (6, 4), image is (6, 16)
        # image is padded by (2, 4, 2, 4)
        # expected image size: (10, 24) -> (6, 16) after resize
        # expected heatmap size: (10, 6) -> (6, 4) after resize
        aug = iaa.Pad(px=(2, 4, 2, 4), keep_size=True)
        heatmaps_arr_small = np.float32([
            [0, 0, 0, 0],
            [0, 1.0, 1.0, 0],
            [0, 1.0, 1.0, 0],
            [0, 1.0, 1.0, 0],
            [0, 1.0, 1.0, 0],
            [0, 0, 0, 0]
        ])
        top, bottom, left, right = 2, 2, 1, 1
        heatmaps_arr_small_padded = np.pad(
            heatmaps_arr_small,
            ((top, bottom), (left, right)),
            mode="constant",
            constant_values=0)
        heatmaps = [ia.HeatmapsOnImage(heatmaps_arr_small, shape=(6, 16))]

        observed = aug.augment_heatmaps(heatmaps)[0]

        assert observed.shape == (6, 16)
        assert observed.arr_0to1.shape == (6, 4, 1)
        assert 0 - 1e-6 < observed.min_value < 0 + 1e-6
        assert 1 - 1e-6 < observed.max_value < 1 + 1e-6
        assert np.allclose(
            observed.arr_0to1[..., 0],
            np.clip(
                ia.imresize_single_image(
                    heatmaps_arr_small_padded,
                    (6, 4),
                    interpolation="cubic"),
                0, 1.0
            )
        )

</source>
</class>

<class classid="150" nclones="4" nlines="21" similarity="73">
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="1081" endline="1106" pcid="2435">
    def test_pad_segmaps_smaller_than_img_by_tuple_of_ints_without_ks(self):
        # pad smaller segmaps
        # same sizes and paddings as above
        aug = iaa.Pad(px=(2, 4, 2, 4), keep_size=False)
        segmaps_arr_small = np.int32([
            [0, 0, 0, 0],
            [0, 1, 1, 0],
            [0, 1, 1, 0],
            [0, 1, 1, 0],
            [0, 1, 1, 0],
            [0, 0, 0, 0]
        ])
        segmaps = [SegmentationMapsOnImage(segmaps_arr_small, shape=(6, 16))]
        top, bottom, left, right = 2, 2, 1, 1
        segmaps_arr_small_padded = np.pad(
            segmaps_arr_small,
            ((top, bottom), (left, right)),
            mode="constant",
            constant_values=0)

        observed = aug.augment_segmentation_maps(segmaps)[0]

        assert observed.shape == (10, 24)
        assert observed.arr.shape == (10, 6, 1)
        assert np.array_equal(observed.arr[..., 0], segmaps_arr_small_padded)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="1522" endline="1545" pcid="2459">
    def test_pad_segmaps_smaller_than_img_by_floats_without_keep_size(self):
        aug = iaa.Pad(percent=(0.5, 0.25, 0.5, 0.25), keep_size=False)
        segmaps_arr_small = np.int32([
            [0, 0, 0, 0],
            [0, 1, 1, 0],
            [0, 1, 1, 0],
            [0, 1, 1, 0],
            [0, 1, 1, 0],
            [0, 0, 0, 0]
        ])
        top, bottom, left, right = 3, 3, 1, 1
        segmaps_arr_small_padded = np.pad(
            segmaps_arr_small,
            ((top, bottom), (left, right)),
            mode="constant",
            constant_values=0)
        segmaps = [SegmentationMapsOnImage(segmaps_arr_small, shape=(6, 16))]

        observed = aug.augment_segmentation_maps(segmaps)[0]

        assert observed.shape == (12, 24)
        assert observed.arr.shape == (12, 6, 1)
        assert np.array_equal(observed.arr[..., 0], segmaps_arr_small_padded)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="1583" endline="1610" pcid="2461">
    def test_pad_segmaps_smaller_than_img_by_floats_with_keep_size(self):
        aug = iaa.Pad(percent=(0.5, 0.25, 0.5, 0.25), keep_size=True)
        segmaps_arr_small = np.int32([
            [0, 0, 0, 0],
            [0, 1, 1, 0],
            [0, 1, 1, 0],
            [0, 1, 1, 0],
            [0, 1, 1, 0],
            [0, 0, 0, 0]
        ])
        top, bottom, left, right = 3, 3, 1, 1
        segmaps_arr_small_padded = np.pad(
            segmaps_arr_small,
            ((top, bottom), (left, right)),
            mode="constant",
            constant_values=0)
        segmaps = [SegmentationMapsOnImage(segmaps_arr_small, shape=(6, 16))]

        observed = aug.augment_segmentation_maps(segmaps)[0]

        assert observed.shape == (6, 16)
        assert observed.arr.shape == (6, 4, 1)
        assert np.array_equal(
            observed.arr[..., 0],
            ia.imresize_single_image(
                segmaps_arr_small_padded, (6, 4), interpolation="nearest")
        )

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="1147" endline="1179" pcid="2437">
    def test_pad_segmaps_smaller_than_img_by_tuple_of_ints_with_keep_size(self):
        # pad smaller segmaps, with keep_size=True
        # same sizes and paddings as above
        aug = iaa.Pad(px=(2, 4, 2, 4), keep_size=True)
        segmaps_arr_small = np.int32([
            [0, 0, 0, 0],
            [0, 1, 1, 0],
            [0, 1, 1, 0],
            [0, 1, 1, 0],
            [0, 1, 1, 0],
            [0, 0, 0, 0]
        ])
        top, bottom, left, right = 2, 2, 1, 1
        segmaps_arr_small_padded = np.pad(
            segmaps_arr_small,
            ((top, bottom), (left, right)),
            mode="constant",
            constant_values=0)
        segmaps = [SegmentationMapsOnImage(segmaps_arr_small, shape=(6, 16))]

        observed = aug.augment_segmentation_maps(segmaps)[0]

        assert observed.shape == (6, 16)
        assert observed.arr.shape == (6, 4, 1)
        assert np.array_equal(
            observed.arr[..., 0],
            ia.imresize_single_image(
                segmaps_arr_small_padded,
                (6, 4),
                interpolation="nearest"
            ),
        )

</source>
</class>

<class classid="151" nclones="2" nlines="11" similarity="90">
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="1180" endline="1191" pcid="2438">
    def test_pad_keypoints_by_tuple_of_fixed_ints_without_keep_size(self):
        aug = iaa.Pad((2, 0, 4, 4), keep_size=False)
        kps = [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=0)]
        kpsoi = ia.KeypointsOnImage(kps, shape=(4, 4, 3))
        kpsoi_aug = aug.augment_keypoints([kpsoi])[0]
        assert kpsoi_aug.shape == (10, 8, 3)
        assert len(kpsoi_aug.keypoints) == 2
        assert np.allclose(kpsoi_aug.keypoints[0].x, 4+1)
        assert np.allclose(kpsoi_aug.keypoints[0].y, 2+2)
        assert np.allclose(kpsoi_aug.keypoints[1].x, 4+3)
        assert np.allclose(kpsoi_aug.keypoints[1].y, 2+0)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="1611" endline="1622" pcid="2462">
    def test_pad_keypoints_by_floats_without_keep_size(self):
        aug = iaa.Pad(percent=(0.5, 0, 1.0, 1.0), keep_size=False)
        kps = [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=0)]
        kpsoi = ia.KeypointsOnImage(kps, shape=(4, 4, 3))
        kpsoi_aug = aug.augment_keypoints([kpsoi])[0]
        assert kpsoi_aug.shape == (10, 8, 3)
        assert len(kpsoi_aug.keypoints) == 2
        assert np.allclose(kpsoi_aug.keypoints[0].x, 4+1)
        assert np.allclose(kpsoi_aug.keypoints[0].y, 2+2)
        assert np.allclose(kpsoi_aug.keypoints[1].x, 4+3)
        assert np.allclose(kpsoi_aug.keypoints[1].y, 2+0)

</source>
</class>

<class classid="152" nclones="2" nlines="11" similarity="90">
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="1192" endline="1203" pcid="2439">
    def test_pad_keypoints_by_tuple_of_fixed_ints_with_keep_size(self):
        aug = iaa.Pad((2, 0, 4, 4), keep_size=True)
        kps = [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=0)]
        kpsoi = ia.KeypointsOnImage(kps, shape=(4, 4, 3))
        kpsoi_aug = aug.augment_keypoints([kpsoi])[0]
        assert kpsoi_aug.shape == (4, 4, 3)
        assert len(kpsoi_aug.keypoints) == 2
        assert np.allclose(kpsoi_aug.keypoints[0].x, ((4+1)/8)*4)
        assert np.allclose(kpsoi_aug.keypoints[0].y, ((2+2)/10)*4)
        assert np.allclose(kpsoi_aug.keypoints[1].x, ((4+3)/8)*4)
        assert np.allclose(kpsoi_aug.keypoints[1].y, ((2+0)/10)*4)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="1623" endline="1634" pcid="2463">
    def test_pad_keypoints_by_floats_with_keep_size(self):
        aug = iaa.Pad(percent=(0.5, 0, 1.0, 1.0), keep_size=True)
        kps = [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=0)]
        kpsoi = ia.KeypointsOnImage(kps, shape=(4, 4, 3))
        kpsoi_aug = aug.augment_keypoints([kpsoi])[0]
        assert kpsoi_aug.shape == (4, 4, 3)
        assert len(kpsoi_aug.keypoints) == 2
        assert np.allclose(kpsoi_aug.keypoints[0].x, ((4+1)/8)*4)
        assert np.allclose(kpsoi_aug.keypoints[0].y, ((2+2)/10)*4)
        assert np.allclose(kpsoi_aug.keypoints[1].x, ((4+3)/8)*4)
        assert np.allclose(kpsoi_aug.keypoints[1].y, ((2+0)/10)*4)

</source>
</class>

<class classid="153" nclones="4" nlines="14" similarity="71">
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="1204" endline="1220" pcid="2440">
    def test_pad_polygons_by_tuple_of_fixed_ints_without_keep_size(self):
        aug = iaa.Pad((2, 0, 4, 4), keep_size=False)
        polygons = [ia.Polygon([(0, 0), (4, 0), (4, 4), (0, 4)]),
                    ia.Polygon([(1, 1), (5, 1), (5, 5), (1, 5)])]
        psoi = ia.PolygonsOnImage(polygons, shape=(4, 4, 3))
        psoi_aug = aug.augment_polygons([psoi, psoi])
        assert len(psoi_aug) == 2
        for psoi_aug_i in psoi_aug:
            assert psoi_aug_i.shape == (10, 8, 3)
            assert len(psoi_aug_i.polygons) == 2
            assert psoi_aug_i.polygons[0].exterior_almost_equals(
                ia.Polygon([(4, 2), (8, 2), (8, 6), (4, 6)])
            )
            assert psoi_aug_i.polygons[1].exterior_almost_equals(
                ia.Polygon([(5, 3), (9, 3), (9, 7), (5, 7)])
            )

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="2221" endline="2239" pcid="2492">
        assert np.allclose(kpsoi_aug.keypoints[0].y, ((6-1)/9)*14)
        assert np.allclose(kpsoi_aug.keypoints[1].x, ((8-4)/10)*14)
        assert np.allclose(kpsoi_aug.keypoints[1].y, ((5-1)/9)*14)

    def test_crop_polygons_by_fixed_ints_without_keep_size(self):
        aug = iaa.Crop((1, 0, 4, 4), keep_size=False)
        polygons = [ia.Polygon([(0, 0), (4, 0), (4, 4), (0, 4)]),
                    ia.Polygon([(1, 1), (5, 1), (5, 5), (1, 5)])]
        psoi = ia.PolygonsOnImage(polygons, shape=(10, 10, 3))

        psoi_aug = aug.augment_polygons([psoi, psoi])

        assert len(psoi_aug) == 2
        for psoi_aug_i in psoi_aug:
            assert psoi_aug_i.shape == (5, 6, 3)
            assert len(psoi_aug_i.polygons) == 2
            assert psoi_aug_i.polygons[0].exterior_almost_equals(
                ia.Polygon([(0-4, 0-1), (4-4, 0-1), (4-4, 4-1), (0-4, 4-1)])
            )
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="2463" endline="2481" pcid="2506">
        assert len(kpsoi_aug.keypoints) == 2
        assert np.allclose(kpsoi_aug.keypoints[0].x, ((12-2)/18)*20)
        assert np.allclose(kpsoi_aug.keypoints[0].y, ((10-4)/4)*16)
        assert np.allclose(kpsoi_aug.keypoints[1].x, ((8-2)/18)*20)
        assert np.allclose(kpsoi_aug.keypoints[1].y, ((12-4)/4)*16)

    def test_crop_polygons_by_fixed_floats_without_keep_size(self):
        aug = iaa.Crop(percent=(0.2, 0, 0.5, 0.1), keep_size=False)
        polygons = [ia.Polygon([(0, 0), (4, 0), (4, 4), (0, 4)]),
                    ia.Polygon([(1, 1), (5, 1), (5, 5), (1, 5)])]
        psoi = ia.PolygonsOnImage(polygons, shape=(10, 10, 3))

        psoi_aug = aug.augment_polygons([psoi, psoi])

        assert len(psoi_aug) == 2
        for psoi_aug_i in psoi_aug:
            assert psoi_aug_i.shape == (3, 9, 3)
            assert len(psoi_aug_i.polygons) == 2
            assert psoi_aug_i.polygons[0].exterior_almost_equals(
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="1635" endline="1652" pcid="2464">
    def test_pad_polygons_by_floats_without_keep_size(self):
        aug = iaa.Pad(percent=(0.5, 0, 1.0, 1.0), keep_size=False)
        psoi = ia.PolygonsOnImage([
            ia.Polygon([(0, 0), (4, 0), (4, 4), (0, 4)]),
            ia.Polygon([(1, 1), (5, 1), (5, 5), (1, 5)])
        ], shape=(4, 4, 3))
        psoi_aug = aug.augment_polygons([psoi, psoi])
        assert len(psoi_aug) == 2
        for psoi_aug_i in psoi_aug:
            assert psoi_aug_i.shape == (10, 8, 3)
            assert len(psoi_aug_i.polygons) == 2
            assert psoi_aug_i.polygons[0].exterior_almost_equals(
                ia.Polygon([(4, 2), (8, 2), (8, 6), (4, 6)])
            )
            assert psoi_aug_i.polygons[1].exterior_almost_equals(
                ia.Polygon([(5, 3), (9, 3), (9, 7), (5, 7)])
            )

</source>
</class>

<class classid="154" nclones="4" nlines="20" similarity="70">
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="1221" endline="1243" pcid="2441">
    def test_pad_polygons_by_tuple_of_fixed_ints_with_keep_size(self):
        aug = iaa.Pad((2, 0, 4, 4), keep_size=True)
        polygons = [ia.Polygon([(0, 0), (4, 0), (4, 4), (0, 4)]),
                    ia.Polygon([(1, 1), (5, 1), (5, 5), (1, 5)])]
        psoi = ia.PolygonsOnImage(polygons, shape=(4, 4, 3))
        psoi_aug = aug.augment_polygons([psoi, psoi])
        assert len(psoi_aug) == 2
        for psoi_aug_i in psoi_aug:
            assert psoi_aug_i.shape == (4, 4, 3)
            assert len(psoi_aug_i.polygons) == 2
            assert psoi_aug_i.polygons[0].exterior_almost_equals(
                ia.Polygon([(4*(4/8), 4*(2/10)),
                            (4*(8/8), 4*(2/10)),
                            (4*(8/8), 4*(6/10)),
                            (4*(4/8), 4*(6/10))])
            )
            assert psoi_aug_i.polygons[1].exterior_almost_equals(
                ia.Polygon([(4*(5/8), 4*(3/10)),
                            (4*(9/8), 4*(3/10)),
                            (4*(9/8), 4*(7/10)),
                            (4*(5/8), 4*(7/10))])
            )

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="1653" endline="1677" pcid="2465">
    def test_pad_polygons_by_floats_with_keep_size(self):
        # polygons, with keep_size=True
        aug = iaa.Pad(percent=(0.5, 0, 1.0, 1.0), keep_size=True)
        psoi = ia.PolygonsOnImage([
            ia.Polygon([(0, 0), (4, 0), (4, 4), (0, 4)]),
            ia.Polygon([(1, 1), (5, 1), (5, 5), (1, 5)])
        ], shape=(4, 4, 3))
        psoi_aug = aug.augment_polygons([psoi, psoi])
        assert len(psoi_aug) == 2
        for psoi_aug_i in psoi_aug:
            assert psoi_aug_i.shape == (4, 4, 3)
            assert len(psoi_aug_i.polygons) == 2
            assert psoi_aug_i.polygons[0].exterior_almost_equals(
                ia.Polygon([(4*(4/8), 4*(2/10)),
                            (4*(8/8), 4*(2/10)),
                            (4*(8/8), 4*(6/10)),
                            (4*(4/8), 4*(6/10))])
            )
            assert psoi_aug_i.polygons[1].exterior_almost_equals(
                ia.Polygon([(4*(5/8), 4*(3/10)),
                            (4*(9/8), 4*(3/10)),
                            (4*(9/8), 4*(7/10)),
                            (4*(5/8), 4*(7/10))])
            )

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="2240" endline="2264" pcid="2493">
            assert psoi_aug_i.polygons[1].exterior_almost_equals(
                ia.Polygon([(1-4, 1-1), (5-4, 1-1), (5-4, 5-1), (1-4, 5-1)])
            )

    def test_crop_polygons_by_fixed_ints_with_keep_size(self):
        aug = iaa.Crop((1, 0, 4, 4), keep_size=True)
        polygons = [ia.Polygon([(0, 0), (4, 0), (4, 4), (0, 4)]),
                    ia.Polygon([(1, 1), (5, 1), (5, 5), (1, 5)])]
        psoi = ia.PolygonsOnImage(polygons, shape=(10, 10, 3))

        psoi_aug = aug.augment_polygons([psoi, psoi])

        assert len(psoi_aug) == 2
        for psoi_aug_i in psoi_aug:
            assert psoi_aug_i.shape == (10, 10, 3)
            assert len(psoi_aug_i.polygons) == 2
            assert psoi_aug_i.polygons[0].exterior_almost_equals(
                ia.Polygon([(10*(-4/6), 10*(-1/5)),
                            (10*(0/6), 10*(-1/5)),
                            (10*(0/6), 10*(3/5)),
                            (10*(-4/6), 10*(3/5))])
            )
            assert psoi_aug_i.polygons[1].exterior_almost_equals(
                ia.Polygon([(10*(-3/6), 10*(0/5)),
                            (10*(1/6), 10*(0/5)),
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="2482" endline="2506" pcid="2507">
                ia.Polygon([(0-1, 0-2), (4-1, 0-2), (4-1, 4-2), (0-1, 4-2)])
            )
            assert psoi_aug_i.polygons[1].exterior_almost_equals(
                ia.Polygon([(1-1, 1-2), (5-1, 1-2), (5-1, 5-2), (1-1, 5-2)])
            )

    def test_crop_polygons_by_fixed_floats_with_keep_size(self):
        aug = iaa.Crop(percent=(0.2, 0, 0.5, 0.1), keep_size=True)
        polygons = [ia.Polygon([(0, 0), (4, 0), (4, 4), (0, 4)]),
                    ia.Polygon([(1, 1), (5, 1), (5, 5), (1, 5)])]
        psoi = ia.PolygonsOnImage(polygons, shape=(10, 10, 3))

        psoi_aug = aug.augment_polygons([psoi, psoi])

        assert len(psoi_aug) == 2
        for psoi_aug_i in psoi_aug:
            assert psoi_aug_i.shape == (10, 10, 3)
            assert len(psoi_aug_i.polygons) == 2
            assert psoi_aug_i.polygons[0].exterior_almost_equals(
                ia.Polygon([(10*(-1/9), 10*(-2/3)),
                            (10*(3/9), 10*(-2/3)),
                            (10*(3/9), 10*(2/3)),
                            (10*(-1/9), 10*(2/3))])
            )
            assert psoi_aug_i.polygons[1].exterior_almost_equals(
</source>
</class>

<class classid="155" nclones="3" nlines="18" similarity="77">
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="1244" endline="1266" pcid="2442">
    def test_pad_mode_is_stochastic_parameter(self):
        aug = iaa.Pad(px=(0, 1, 0, 0),
                      pad_mode=iap.Choice(["constant", "maximum", "edge"]),
                      pad_cval=0,
                      keep_size=False)

        image = np.zeros((1, 2), dtype=np.uint8)
        image[0, 0] = 100
        image[0, 1] = 50

        seen = [0, 0, 0]
        for _ in sm.xrange(300):
            observed = aug.augment_image(image)
            if observed[0, 2] == 0:
                seen[0] += 1
            elif observed[0, 2] == 100:
                seen[1] += 1
            elif observed[0, 2] == 50:
                seen[2] += 1
            else:
                assert False
        assert np.all([100 - 50 < v < 100 + 50 for v in seen])

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="1332" endline="1352" pcid="2448">
    def test_pad_cval_is_tuple(self):
        aug = iaa.Pad(px=(0, 1, 0, 0),
                      pad_mode="constant",
                      pad_cval=(50, 52),
                      keep_size=False)
        image = np.zeros((1, 1), dtype=np.uint8)

        seen = [0, 0, 0]
        for _ in sm.xrange(300):
            observed = aug.augment_image(image)

            if observed[0, 1] == 50:
                seen[0] += 1
            elif observed[0, 1] == 51:
                seen[1] += 1
            elif observed[0, 1] == 52:
                seen[2] += 1
            else:
                assert False
        assert np.all([100 - 50 < v < 100 + 50 for v in seen])

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="1315" endline="1331" pcid="2447">
    def test_pad_cval_is_stochastic_parameter(self):
        aug = iaa.Pad(px=(0, 1, 0, 0),
                      pad_mode="constant",
                      pad_cval=iap.Choice([50, 100]),
                      keep_size=False)
        image = np.zeros((1, 1), dtype=np.uint8)
        seen = [0, 0]
        for _ in sm.xrange(200):
            observed = aug.augment_image(image)
            if observed[0, 1] == 50:
                seen[0] += 1
            elif observed[0, 1] == 100:
                seen[1] += 1
            else:
                assert False
        assert np.all([100 - 50 < v < 100 + 50 for v in seen])

</source>
</class>

<class classid="156" nclones="2" nlines="11" similarity="81">
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="1267" endline="1278" pcid="2443">
    def test_bad_datatype_for_pad_mode_causes_failure(self):
        got_exception = False
        try:
            _aug = iaa.Pad(px=(0, 1, 0, 0),
                           pad_mode=False,
                           pad_cval=0,
                           keep_size=False)
        except Exception as exc:
            assert "Expected pad_mode to be " in str(exc)
            got_exception = True
        assert got_exception

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="1353" endline="1364" pcid="2449">
    def test_invalid_pad_cval_datatype_leads_to_failure(self):
        got_exception = False
        try:
            _aug = iaa.Pad(px=(0, 1, 0, 0),
                           pad_mode="constant",
                           pad_cval="test",
                           keep_size=False)
        except Exception as exc:
            assert "Expected " in str(exc)
            got_exception = True
        assert got_exception

</source>
</class>

<class classid="157" nclones="2" nlines="27" similarity="71">
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="1432" endline="1462" pcid="2456">
    def test_pad_each_side_by_100_percent_without_keep_size(self):
        image = np.zeros((4, 4), dtype=np.uint8)
        image[0, 0] = 255
        image[3, 0] = 255
        image[0, 3] = 255
        image[3, 3] = 255
        height, width = image.shape[0:2]
        pads = [
            (1.0, 0, 0, 0),
            (0, 1.0, 0, 0),
            (0, 0, 1.0, 0),
            (0, 0, 0, 1.0),
        ]
        for pad in pads:
            with self.subTest(pad=pad):
                top, right, bottom, left = pad
                top_px = int(top * height)
                right_px = int(right * width)
                bottom_px = int(bottom * height)
                left_px = int(left * width)
                aug = iaa.Pad(percent=pad, keep_size=False)
                image_padded = np.pad(
                    image,
                    ((top_px, bottom_px), (left_px, right_px)),
                    mode="constant",
                    constant_values=0)

                observed = aug.augment_image(image)

                assert np.array_equal(observed, image_padded)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="1463" endline="1490" pcid="2457">
    def test_pad_keypoints_each_side_by_100_percent_without_keep_size(self):
        image = np.zeros((4, 4), dtype=np.uint8)
        image[0, 0] = 255
        image[3, 0] = 255
        image[0, 3] = 255
        image[3, 3] = 255
        height, width = image.shape[0:2]
        kps = [ia.Keypoint(x=0, y=0), ia.Keypoint(x=3, y=3),
               ia.Keypoint(x=3, y=3)]
        keypoints = [ia.KeypointsOnImage(kps, shape=(4, 4))]
        pads = [
            (1.0, 0, 0, 0),
            (0, 1.0, 0, 0),
            (0, 0, 1.0, 0),
            (0, 0, 0, 1.0),
        ]
        for pad in pads:
            with self.subTest(pad=pad):
                top, right, bottom, left = pad
                top_px = int(top * height)
                left_px = int(left * width)
                aug = iaa.Pad(percent=pad, keep_size=False)
                keypoints_moved = [keypoints[0].shift(x=left_px, y=top_px)]

                observed = aug.augment_keypoints(keypoints)

                assert keypoints_equal(observed, keypoints_moved)

</source>
</class>

<class classid="158" nclones="2" nlines="16" similarity="81">
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="1709" endline="1725" pcid="2468">
    def test_pad_by_list_of_floats_at_top_side_without_keep_size(self):
        aug = iaa.Pad(percent=([0.0, 1.0], 0, 0, 0), keep_size=False)
        seen = [0, 0, 0, 0, 0]
        for _ in sm.xrange(500):
            observed = aug.augment_image(
                np.zeros((4, 4), dtype=np.uint8) + 255)
            n_padded = 0
            while np.all(observed[0, :] == 0):
                n_padded += 1
                observed = observed[1:, :]
            seen[n_padded] += 1
        assert 250 - 50 < seen[0] < 250 + 50
        assert seen[1] == 0
        assert seen[2] == 0
        assert seen[3] == 0
        assert 250 - 50 < seen[4] < 250 + 50

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="1726" endline="1742" pcid="2469">
    def test_pad_by_list_of_floats_at_right_side_without_keep_size(self):
        aug = iaa.Pad(percent=(0, [0.0, 1.0], 0, 0), keep_size=False)
        seen = [0, 0, 0, 0, 0]
        for _ in sm.xrange(500):
            observed = aug.augment_image(
                np.zeros((4, 4), dtype=np.uint8) + 255)
            n_padded = 0
            while np.all(observed[:, -1] == 0):
                n_padded += 1
                observed = observed[:, 0:-1]
            seen[n_padded] += 1
        assert 250 - 50 < seen[0] < 250 + 50
        assert seen[1] == 0
        assert seen[2] == 0
        assert seen[3] == 0
        assert 250 - 50 < seen[4] < 250 + 50

</source>
</class>

<class classid="159" nclones="4" nlines="11" similarity="90">
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="1787" endline="1800" pcid="2472">
    def test_pad_other_dtypes_bool_by_int_without_keep_size(self):
        aug = iaa.Pad(px=(1, 0, 0, 0), keep_size=False)
        mask = np.zeros((4, 3), dtype=bool)
        mask[2, 1] = True
        image = np.zeros((3, 3), dtype=bool)
        image[1, 1] = True

        image_aug = aug.augment_image(image)

        assert image_aug.dtype.name == image.dtype.name
        assert image_aug.shape == (4, 3)
        assert np.all(image_aug[~mask] == 0)
        assert np.all(image_aug[mask] == 1)

</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="3406" endline="3419" pcid="2569">
                aug = iaa.CropToFixedSize(height=1, width=1)

                image_aug = aug(image=image)

                expected_height = 0 if shape[0] == 0 else 1
                expected_width = 0 if shape[1] == 0 else 1
                expected_shape = tuple([expected_height, expected_width]
                                       + list(shape[2:]))
                assert image_aug.shape == expected_shape

    def test_other_dtypes_bool(self):
        aug = iaa.CropToFixedSize(height=2, width=3, position="center-top")
        mask = np.zeros((2, 3), dtype=bool)
        mask[0, 1] = True
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="2638" endline="2650" pcid="2514">
                        "crop amounts in CropAndPad"
                        in str(warning.message)
                    )

                assert image_aug.shape == image.shape

    def test_other_dtypes_bool(self):
        aug = iaa.Crop(px=(1, 0, 0, 0), keep_size=False)
        mask = np.zeros((2, 3), dtype=bool)
        mask[0, 1] = True

        image = np.zeros((3, 3), dtype=bool)
        image[1, 1] = True
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="3014" endline="3027" pcid="2540">
                image_aug = aug(image=image)

                expected_height = 1
                expected_width = 1
                expected_shape = tuple([expected_height, expected_width]
                                       + list(shape[2:]))
                assert image_aug.shape == expected_shape

    def test_other_dtypes_bool(self):
        aug = iaa.PadToFixedSize(height=4, width=3, position="center-top")
        mask = np.zeros((4, 3), dtype=bool)
        mask[2, 1] = True
        image = np.zeros((3, 3), dtype=bool)
        image[1, 1] = True
</source>
</class>

<class classid="160" nclones="4" nlines="28" similarity="75">
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="1801" endline="1834" pcid="2473">
    def test_pad_other_dtypes_uint_int_by_int_without_keep_size(self):
        aug = iaa.Pad(px=(1, 0, 0, 0), keep_size=False)

        mask = np.zeros((4, 3), dtype=bool)
        mask[2, 1] = True

        dtypes = ["uint8", "uint16", "uint32", "uint64",
                  "int8", "int16", "int32", "int64"]

        for dtype in dtypes:
            with self.subTest(dtype=dtype):
                min_value, center_value, max_value = \
                    iadt.get_value_range_of_dtype(dtype)

                if np.dtype(dtype).kind == "i":
                    values = [
                        1, 5, 10, 100, int(0.1 * max_value),
                        int(0.2 * max_value), int(0.5 * max_value),
                        max_value - 100, max_value]
                    values = values + [(-1) * value for value in values]
                else:
                    values = [
                        1, 5, 10, 100, int(center_value),
                        int(0.1 * max_value), int(0.2 * max_value),
                        int(0.5 * max_value), max_value - 100, max_value]

                for value in values:
                    image = np.zeros((3, 3), dtype=dtype)
                    image[1, 1] = value
                    image_aug = aug.augment_image(image)
                    assert image_aug.dtype.name == dtype
                    assert image_aug.shape == (4, 3)
                    assert np.all(image_aug[~mask] == 0)
                    assert np.all(image_aug[mask] == value)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="3420" endline="3453" pcid="2570">
        image = np.zeros((3, 3), dtype=bool)
        image[1, 1] = True

        image_aug = aug.augment_image(image)

        assert image_aug.dtype.name == image.dtype.name
        assert image_aug.shape == (2, 3)
        assert np.all(image_aug[~mask] == 0)
        assert np.all(image_aug[mask] == 1)

    def test_other_dtypes_uint_int(self):
        aug = iaa.CropToFixedSize(height=2, width=3, position="center-top")
        mask = np.zeros((2, 3), dtype=bool)
        mask[0, 1] = True

        dtypes = ["uint8", "uint16", "uint32", "uint64",
                  "int8", "int16", "int32", "int64"]

        for dtype in dtypes:
            min_value, center_value, max_value = \
                iadt.get_value_range_of_dtype(dtype)

            if np.dtype(dtype).kind == "i":
                values = [
                    1, 5, 10, 100, int(0.1 * max_value), int(0.2 * max_value),
                    int(0.5 * max_value), max_value - 100, max_value]
                values = values + [(-1) * value for value in values]
            else:
                values = [
                    1, 5, 10, 100, int(center_value), int(0.1 * max_value),
                    int(0.2 * max_value), int(0.5 * max_value),
                    max_value - 100, max_value]

            for value in values:
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="3028" endline="3062" pcid="2541">

        image_aug = aug.augment_image(image)

        assert image_aug.dtype.name == image.dtype.name
        assert image_aug.shape == (4, 3)
        assert np.all(image_aug[~mask] == 0)
        assert np.all(image_aug[mask] == 1)

    def test_other_dtypes_uint_int(self):
        aug = iaa.PadToFixedSize(height=4, width=3, position="center-top")
        dtypes = ["uint8", "uint16", "uint32", "uint64",
                  "int8", "int16", "int32", "int64"]

        mask = np.zeros((4, 3), dtype=bool)
        mask[2, 1] = True

        for dtype in dtypes:
            min_value, center_value, max_value = \
                iadt.get_value_range_of_dtype(dtype)

            if np.dtype(dtype).kind == "i":
                values = [
                    1, 5, 10, 100, int(0.1 * max_value),
                    int(0.2 * max_value), int(0.5 * max_value),
                    max_value - 100, max_value]
                values = values + [(-1) * value for value in values]
            else:
                values = [
                    1, 5, 10, 100, int(center_value), int(0.1 * max_value),
                    int(0.2 * max_value), int(0.5 * max_value),
                    max_value - 100, max_value]

            for value in values:
                with self.subTest(dtype=dtype, value=value):
                    image = np.zeros((3, 3), dtype=dtype)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="2651" endline="2683" pcid="2515">
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.name == image.dtype.name
        assert image_aug.shape == (2, 3)
        assert np.all(image_aug[~mask] == 0)
        assert np.all(image_aug[mask] == 1)

    def test_other_dtypes_uint_int(self):
        aug = iaa.Crop(px=(1, 0, 0, 0), keep_size=False)
        mask = np.zeros((2, 3), dtype=bool)
        mask[0, 1] = True

        dtypes = ["uint8", "uint16", "uint32", "uint64",
                  "int8", "int16", "int32", "int64"]

        for dtype in dtypes:
            with self.subTest(dtype=dtype):
                min_value, center_value, max_value = \
                    iadt.get_value_range_of_dtype(dtype)

                if np.dtype(dtype).kind == "i":
                    values = [
                        1, 5, 10, 100, int(0.1 * max_value),
                        int(0.2 * max_value), int(0.5 * max_value),
                        max_value - 100, max_value]
                    values = values + [(-1) * value for value in values]
                else:
                    values = [
                        1, 5, 10, 100, int(center_value), int(0.1 * max_value),
                        int(0.2 * max_value), int(0.5 * max_value),
                        max_value - 100, max_value]

                for value in values:
                    image = np.zeros((3, 3), dtype=dtype)
</source>
</class>

<class classid="161" nclones="2" nlines="14" similarity="71">
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="2106" endline="2127" pcid="2486">
                assert len(set(movements_det)) == 1

    def test_crop_heatmaps_smaller_than_img_by_fixed_ints_without_ks(self):
        # crop smaller heatmaps
        # heatmap is (6, 8), image is (6, 16)
        # image is cropped by (1, 4, 1, 4)
        # expected image size: (4, 8)
        # expected heatmap size: (4, 4)
        aug = iaa.Crop(px=(1, 4, 1, 4), keep_size=False)
        heatmaps_arr_small = np.zeros((6, 8), dtype=np.float32)
        heatmaps_arr_small[1:-1, 1:-1] = 1.0
        heatmaps = HeatmapsOnImage(heatmaps_arr_small, shape=(6, 16))
        top, bottom, left, right = 1, 1, 2, 2
        heatmaps_arr_small_cropped = \
            heatmaps_arr_small[top:-bottom, left:-right]

        observed = aug.augment_heatmaps([heatmaps])[0]

        assert observed.shape == (4, 8)
        assert observed.arr_0to1.shape == (4, 4, 1)
        assert 0 - 1e-6 < observed.min_value < 0 + 1e-6
        assert 1 - 1e-6 < observed.max_value < 1 + 1e-6
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="2349" endline="2369" pcid="2500">
                keypoints_moved = [keypoints[0].shift(x=-left_px, y=-top_px)]
                observed = aug.augment_keypoints(keypoints)
                assert keypoints_equal(observed, keypoints_moved)

    def test_crop_heatmaps_smaller_than_img_by_fixed_floats_without_ks(self):
        # crop smaller heatmaps
        # heatmap is (8, 12), image is (16, 32)
        # image is cropped by (0.25, 0.25, 0.25, 0.25)
        # expected image size: (8, 16)
        # expected heatmap size: (4, 6)
        aug = iaa.Crop(percent=(0.25, 0.25, 0.25, 0.25), keep_size=False)
        heatmaps_arr_small = np.zeros((8, 12), dtype=np.float32)
        heatmaps_arr_small[2:-2, 4:-4] = 1.0
        heatmaps = ia.HeatmapsOnImage(heatmaps_arr_small, shape=(16, 32))
        top, bottom, left, right = 2, 2, 3, 3
        heatmaps_arr_small_cropped = \
            heatmaps_arr_small[top:-bottom, left:-right]

        observed = aug.augment_heatmaps([heatmaps])[0]

        assert observed.shape == (8, 16)
</source>
</class>

<class classid="162" nclones="2" nlines="11" similarity="90">
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="2128" endline="2141" pcid="2487">
        assert np.allclose(observed.arr_0to1[..., 0],
                           heatmaps_arr_small_cropped)

    def test_crop_segmaps_smaller_than_img_by_fixed_ints_without_ks(self):
        aug = iaa.Crop(px=(1, 4, 1, 4), keep_size=False)
        segmaps_arr_small = np.zeros((6, 8), dtype=np.int32)
        segmaps_arr_small[1:-1, 1:-1] = 1
        segmaps = SegmentationMapsOnImage(segmaps_arr_small, shape=(6, 16))
        top, bottom, left, right = 1, 1, 2, 2
        segmaps_arr_small_cropped = segmaps_arr_small[top:-bottom, left:-right]

        observed = aug.augment_segmentation_maps([segmaps])[0]

        assert observed.shape == (4, 8)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="2370" endline="2383" pcid="2501">
        assert observed.arr_0to1.shape == (4, 6, 1)
        assert 0 - 1e-6 < observed.min_value < 0 + 1e-6
        assert 1 - 1e-6 < observed.max_value < 1 + 1e-6
        assert np.allclose(observed.arr_0to1[..., 0], heatmaps_arr_small_cropped)

    def test_crop_segmaps_smaller_than_img_by_fixed_floats_without_ks(self):
        aug = iaa.Crop(percent=(0.25, 0.25, 0.25, 0.25), keep_size=False)
        segmaps_arr_small = np.zeros((8, 12), dtype=np.int32)
        segmaps_arr_small[2:-2, 4:-4] = 1
        segmaps = SegmentationMapsOnImage(segmaps_arr_small, shape=(16, 32))
        top, bottom, left, right = 2, 2, 3, 3
        segmaps_arr_small_cropped = segmaps_arr_small[top:-bottom, left:-right]

        observed = aug.augment_segmentation_maps([segmaps])[0]
</source>
</class>

<class classid="163" nclones="4" nlines="19" similarity="71">
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="2142" endline="2172" pcid="2488">
        assert observed.arr.shape == (4, 4, 1)
        assert np.array_equal(observed.arr[..., 0], segmaps_arr_small_cropped)

    def test_crop_heatmaps_smaller_than_img_by_fixed_ints_with_ks(self):
        # crop smaller heatmaps, with keep_size=True
        # heatmap is (6, 8), image is (6, 16)
        # image is cropped by (1, 4, 1, 4)
        # expected image size: (4, 8) -> (6, 16) after resize
        # expected heatmap size: (4, 4) -> (6, 4) after resize
        aug = iaa.Crop(px=(1, 4, 1, 4), keep_size=True)
        heatmaps_arr_small = np.zeros((6, 8), dtype=np.float32)
        heatmaps_arr_small[1:-1, 1:-1] = 1.0
        heatmaps = HeatmapsOnImage(heatmaps_arr_small, shape=(6, 16))
        top, bottom, left, right = 1, 1, 2, 2
        heatmaps_arr_small_cropped = \
            heatmaps_arr_small[top:-bottom, left:-right]

        observed = aug.augment_heatmaps([heatmaps])[0]

        assert observed.shape == (6, 16)
        assert observed.arr_0to1.shape == (6, 8, 1)
        assert 0 - 1e-6 < observed.min_value < 0 + 1e-6
        assert 1 - 1e-6 < observed.max_value < 1 + 1e-6
        assert np.allclose(
            observed.arr_0to1[..., 0],
            np.clip(
                ia.imresize_single_image(
                    heatmaps_arr_small_cropped,
                    (6, 8),
                    interpolation="cubic"),
                0,
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="2384" endline="2414" pcid="2502">

        assert observed.shape == (8, 16)
        assert observed.arr.shape == (4, 6, 1)
        assert np.array_equal(observed.arr[..., 0], segmaps_arr_small_cropped)

    def test_crop_heatmaps_smaller_than_img_by_fixed_floats_with_ks(self):
        # crop smaller heatmaps, with keep_size=True
        # heatmap is (8, 12), image is (16, 32)
        # image is cropped by (0.25, 0.25, 0.25, 0.25)
        # expected image size: (8, 16) -> (16, 32) after resize
        # expected heatmap size: (4, 6) -> (8, 12) after resize
        aug = iaa.Crop(percent=(0.25, 0.25, 0.25, 0.25), keep_size=True)
        heatmaps_arr_small = np.zeros((8, 12), dtype=np.float32)
        heatmaps_arr_small[2:-2, 4:-4] = 1.0
        heatmaps = ia.HeatmapsOnImage(heatmaps_arr_small, shape=(16, 32))
        top, bottom, left, right = 2, 2, 3, 3
        heatmaps_arr_small_cropped = \
            heatmaps_arr_small[top:-bottom, left:-right]

        observed = aug.augment_heatmaps([heatmaps])[0]

        assert observed.shape == (16, 32)
        assert observed.arr_0to1.shape == (8, 12, 1)
        assert 0 - 1e-6 < observed.min_value < 0 + 1e-6
        assert 1 - 1e-6 < observed.max_value < 1 + 1e-6
        assert np.allclose(
            observed.arr_0to1[..., 0],
            np.clip(
                ia.imresize_single_image(
                    heatmaps_arr_small_cropped,
                    (8, 12),
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="2173" endline="2192" pcid="2489">
                1.0
            )
        )

    def test_crop_segmaps_smaller_than_img_by_fixed_ints_with_ks(self):
        aug = iaa.Crop(px=(1, 4, 1, 4), keep_size=True)
        segmaps_arr_small = np.zeros((6, 8), dtype=np.int32)
        segmaps_arr_small[1:-1, 1:-1] = 1
        segmaps = SegmentationMapsOnImage(segmaps_arr_small, shape=(6, 16))
        top, bottom, left, right = 1, 1, 2, 2
        segmaps_arr_small_cropped = segmaps_arr_small[top:-bottom, left:-right]

        observed = aug.augment_segmentation_maps([segmaps])[0]

        assert observed.shape == (6, 16)
        assert observed.arr.shape == (6, 8, 1)
        assert np.array_equal(
            observed.arr[..., 0],
            ia.imresize_single_image(
                segmaps_arr_small_cropped,
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="2415" endline="2434" pcid="2503">
                    interpolation="cubic"),
                0,
                1.0
            )
        )

    def test_crop_segmaps_smaller_than_img_by_fixed_floats_with_ks(self):
        aug = iaa.Crop(percent=(0.25, 0.25, 0.25, 0.25), keep_size=True)
        segmaps_arr_small = np.zeros((8, 12), dtype=np.int32)
        segmaps_arr_small[2:-2, 4:-4] = 1
        segmaps = SegmentationMapsOnImage(segmaps_arr_small, shape=(16, 32))
        top, bottom, left, right = 2, 2, 3, 3
        segmaps_arr_small_cropped = segmaps_arr_small[top:-bottom, left:-right]

        observed = aug.augment_segmentation_maps([segmaps])[0]

        assert observed.shape == (16, 32)
        assert observed.arr.shape == (8, 12, 1)
        assert np.allclose(
            observed.arr[..., 0],
</source>
</class>

<class classid="164" nclones="2" nlines="11" similarity="90">
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="2193" endline="2206" pcid="2490">
                (6, 8),
                interpolation="nearest"),
        )

    def test_crop_keypoints_by_fixed_ints_without_keep_size(self):
        aug = iaa.Crop((1, 0, 4, 4), keep_size=False)
        kps = [ia.Keypoint(x=3, y=6), ia.Keypoint(x=8, y=5)]
        kpsoi = ia.KeypointsOnImage(kps, shape=(14, 14, 3))

        kpsoi_aug = aug.augment_keypoints([kpsoi])[0]

        assert kpsoi_aug.shape == (9, 10, 3)
        assert len(kpsoi_aug.keypoints) == 2
        assert np.allclose(kpsoi_aug.keypoints[0].x, 3-4)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="2435" endline="2448" pcid="2504">
            ia.imresize_single_image(
                segmaps_arr_small_cropped,
                (8, 12),
                interpolation="nearest")
        )

    def test_crop_keypoints_by_fixed_floats_without_keep_size(self):
        aug = iaa.Crop(percent=(0.25, 0, 0.5, 0.1), keep_size=False)
        kps = [ia.Keypoint(x=12, y=10), ia.Keypoint(x=8, y=12)]
        kpsoi = ia.KeypointsOnImage(kps, shape=(16, 20, 3))

        kpsoi_aug = aug.augment_keypoints([kpsoi])[0]

        assert kpsoi_aug.shape == (4, 18, 3)
</source>
</class>

<class classid="165" nclones="2" nlines="11" similarity="90">
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="2207" endline="2220" pcid="2491">
        assert np.allclose(kpsoi_aug.keypoints[0].y, 6-1)
        assert np.allclose(kpsoi_aug.keypoints[1].x, 8-4)
        assert np.allclose(kpsoi_aug.keypoints[1].y, 5-1)

    def test_crop_keypoints_by_fixed_ints_with_keep_size(self):
        aug = iaa.Crop((1, 0, 4, 4), keep_size=True)
        kps = [ia.Keypoint(x=3, y=6), ia.Keypoint(x=8, y=5)]
        kpsoi = ia.KeypointsOnImage(kps, shape=(14, 14, 3))

        kpsoi_aug = aug.augment_keypoints([kpsoi])[0]

        assert kpsoi_aug.shape == (14, 14, 3)
        assert len(kpsoi_aug.keypoints) == 2
        assert np.allclose(kpsoi_aug.keypoints[0].x, ((3-4)/10)*14)
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="2449" endline="2462" pcid="2505">
        assert len(kpsoi_aug.keypoints) == 2
        assert np.allclose(kpsoi_aug.keypoints[0].x, 12-2)
        assert np.allclose(kpsoi_aug.keypoints[0].y, 10-4)
        assert np.allclose(kpsoi_aug.keypoints[1].x, 8-2)
        assert np.allclose(kpsoi_aug.keypoints[1].y, 12-4)

    def test_crop_keypoints_by_fixed_floats_with_keep_size(self):
        aug = iaa.Crop(percent=(0.25, 0, 0.5, 0.1), keep_size=True)
        kps = [ia.Keypoint(x=12, y=10), ia.Keypoint(x=8, y=12)]
        kpsoi = ia.KeypointsOnImage(kps, shape=(16, 20, 3))

        kpsoi_aug = aug.augment_keypoints([kpsoi])[0]

        assert kpsoi_aug.shape == (16, 20, 3)
</source>
</class>

<class classid="166" nclones="2" nlines="20" similarity="70">
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="2301" endline="2325" pcid="2498">
            assert "Expected " in str(exc)
            got_exception = True
        assert got_exception

    def test_crop_by_fixed_float_on_each_side_on_its_own(self):
        image = np.random.randint(0, 255, size=(50, 50), dtype=np.uint8)
        height, width = image.shape[0:2]
        crops = [
            (0.1, 0, 0, 0),
            (0, 0.1, 0, 0),
            (0, 0, 0.1, 0),
            (0, 0, 0, 0.1),
        ]
        for crop in crops:
            with self.subTest(percent=crop):
                aug = iaa.Crop(percent=crop, keep_size=False)

                top, right, bottom, left = crop
                top_px = int(round(top * height))
                right_px = int(round(right * width))
                bottom_px = int(round(bottom * height))
                left_px = int(round(left * width))

                # dont use :-bottom_px and ;-right_px here, because these
                # values can be 0
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="2326" endline="2348" pcid="2499">
                image_cropped = image[top_px:50-bottom_px, left_px:50-right_px]
                observed = aug.augment_image(image)
                assert np.array_equal(observed, image_cropped)

    def test_crop_keypoints_by_fixed_float_on_each_side_on_its_own(self):
        height, width = (50, 50)
        kps = [ia.Keypoint(x=10, y=11), ia.Keypoint(x=20, y=21),
               ia.Keypoint(x=30, y=31)]
        keypoints = [ia.KeypointsOnImage(kps, shape=(height, width))]
        crops = [
            (0.1, 0, 0, 0),
            (0, 0.1, 0, 0),
            (0, 0, 0.1, 0),
            (0, 0, 0, 0.1),
        ]
        for crop in crops:
            with self.subTest(percent=crop):
                aug = iaa.Crop(percent=crop, keep_size=False)

                top, right, bottom, left = crop
                top_px = int(round(top * height))
                left_px = int(round(left * width))

</source>
</class>

<class classid="167" nclones="2" nlines="13" similarity="92">
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="2532" endline="2545" pcid="2510">
        for _ in sm.xrange(500):
            observed = aug.augment_image(image)
            n_cropped = 40 - observed.shape[1]
            seen[n_cropped] += 1
        assert np.all([v > 30 for v in seen])

    def test_crop_by_list_of_floats_on_top_side_without_ks(self):
        aug = iaa.Crop(percent=([0.0, 0.1], 0, 0, 0), keep_size=False)
        image = np.zeros((40, 40), dtype=np.uint8) + 255
        seen = [0, 0, 0, 0, 0]
        for _ in sm.xrange(500):
            observed = aug.augment_image(image)
            n_cropped = 40 - observed.shape[0]
            seen[n_cropped] += 1
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="2546" endline="2559" pcid="2511">
        assert 250 - 50 < seen[0] < 250 + 50
        assert seen[1] == 0
        assert seen[2] == 0
        assert seen[3] == 0
        assert 250 - 50 < seen[4] < 250 + 50

    def test_crop_by_list_of_floats_on_right_side_without_ks(self):
        aug = iaa.Crop(percent=(0, [0.0, 0.1], 0, 0), keep_size=False)
        image = np.zeros((40, 40), dtype=np.uint8) + 255
        seen = [0, 0, 0, 0, 0]
        for _ in sm.xrange(500):
            observed = aug.augment_image(image)
            n_cropped = 40 - observed.shape[1]
            seen[n_cropped] += 1
</source>
</class>

<class classid="168" nclones="3" nlines="13" similarity="92">
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="2824" endline="2839" pcid="2528">
            [50, 50, 100, 100],
            [150, 150, 200, 200],
            [150, 150, 200, 200]
        ])
        assert observed.dtype.name == "uint8"
        assert observed.shape == (4, 4)
        assert np.array_equal(observed, expected)

    def test_image_pad_at_left_top(self):
        # explicit non-center position test
        aug = iaa.PadToFixedSize(
            height=3, width=3, pad_mode="constant", pad_cval=128,
            position="left-top")
        img1x1 = np.uint8([[255]])
        observed = aug.augment_image(img1x1)
        expected = np.uint8([
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="2857" endline="2873" pcid="2530">
            [255, 128, 128],
            [128, 128, 128],
            [128, 128, 128]
        ])
        assert observed.dtype.name == "uint8"
        assert observed.shape == (3, 3)
        assert np.array_equal(observed, expected)

    def test_image_pad_at_bottom_center_given_as_tuple_of_floats(self):
        aug = iaa.PadToFixedSize(
            height=3, width=3, pad_mode="constant", pad_cval=128,
            position=(0.5, 1.0))
        img1x1 = np.uint8([[255]])

        observed = aug.augment_image(img1x1)

        expected = np.uint8([
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="2840" endline="2856" pcid="2529">
            [128, 128, 128],
            [128, 128, 128],
            [128, 128, 255]
        ])
        assert observed.dtype.name == "uint8"
        assert observed.shape == (3, 3)
        assert np.array_equal(observed, expected)

    def test_image_pad_at_right_bottom(self):
        aug = iaa.PadToFixedSize(
            height=3, width=3, pad_mode="constant", pad_cval=128,
            position="right-bottom")
        img1x1 = np.uint8([[255]])

        observed = aug.augment_image(img1x1)

        expected = np.uint8([
</source>
</class>

<class classid="169" nclones="2" nlines="13" similarity="76">
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="2920" endline="2938" pcid="2535">
        kpsoi = ia.KeypointsOnImage([ia.Keypoint(x=1, y=1)], shape=(3, 3))

        observed = aug.augment_keypoints([kpsoi])

        expected = ia.KeypointsOnImage([ia.Keypoint(x=1, y=1)], shape=(4, 4))
        assert observed[0].shape == expected.shape
        assert keypoints_equal(observed, [expected])

    def test_heatmaps__pad_mode_should_be_ignored(self):
        # basic heatmaps test
        # pad_mode should be ignored for heatmaps
        aug = iaa.PadToFixedSize(
            height=3, width=3, pad_mode="edge", position="center")
        heatmaps_arr = np.zeros((1, 1, 1), dtype=np.float32) + 1.0
        heatmaps = ia.HeatmapsOnImage(heatmaps_arr, shape=(1, 1, 3))

        observed = aug.augment_heatmaps([heatmaps])[0]

        expected = np.float32([
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="2955" endline="2973" pcid="2537">
        observed = aug.augment_heatmaps([heatmaps])[0]

        expected = np.zeros((16, 16, 1), dtype=np.float32) + 1.0
        expected[:, 0, 0] = 0.0
        expected[0, :, 0] = 0.0
        assert observed.shape == (32, 32, 3)
        assert np.allclose(observed.arr_0to1, expected)

    def test_segmaps__pad_mode_should_be_ignored(self):
        # basic segmaps test
        # pad_mode should be ignored for segmaps
        aug = iaa.PadToFixedSize(
            height=3, width=3, pad_mode="edge", position="center")
        segmaps_arr = np.ones((1, 1, 1), dtype=np.int32)
        segmaps = SegmentationMapsOnImage(segmaps_arr, shape=(1, 1, 3))

        observed = aug.augment_segmentation_maps([segmaps])[0]

        expected = np.int32([
</source>
</class>

<class classid="170" nclones="2" nlines="11" similarity="75">
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="3112" endline="3125" pcid="2546">
            [128, 129, 130],
            [131, 132, 133],
            [134, 135, 136]
        ])

        observed = aug.augment_image(image)

        assert observed.dtype.name == "uint8"
        assert observed.shape == (1, 1)

    def test_image3d_that_needs_to_be_cropped_on_both_sides(self):
        aug = iaa.CropToFixedSize(height=1, width=1)
        image = np.uint8([
            [128, 129, 130],
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="3126" endline="3142" pcid="2547">
            [131, 132, 133],
            [134, 135, 136]
        ])
        image3d = np.atleast_3d(image)

        observed = aug.augment_image(image3d)

        assert observed.dtype.name == "uint8"
        assert observed.shape == (1, 1, 1)

    def test_image3d_rgb_that_needs_to_be_cropped_on_both_sides(self):
        aug = iaa.CropToFixedSize(height=1, width=1)
        image = np.uint8([
            [128, 129, 130],
            [131, 132, 133],
            [134, 135, 136]
        ])
</source>
</class>

<class classid="171" nclones="4" nlines="11" similarity="72">
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="3700" endline="3714" pcid="2590">
        kpsoi = self.kpsoi

        kpoi_aug = aug.augment_keypoints([kpsoi])[0]

        assert kpoi_aug.shape == (3, 4, 3)
        assert np.isclose(kpoi_aug.keypoints[0].x, 0, rtol=0, atol=1e-4)
        assert np.isclose(kpoi_aug.keypoints[0].y, 0, rtol=0, atol=1e-4)
        assert np.isclose(kpoi_aug.keypoints[1].x, 1, rtol=0, atol=1e-4)
        assert np.isclose(kpoi_aug.keypoints[1].y, 0, rtol=0, atol=1e-4)
        assert np.isclose(kpoi_aug.keypoints[2].x, 2, rtol=0, atol=1e-4)
        assert np.isclose(kpoi_aug.keypoints[2].y, 2, rtol=0, atol=1e-4)

    def test_heatmaps_specific_interpolation_set_to_no_nearest(self):
        aug = iaa.KeepSizeByResize(
            self.children,
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="3747" endline="3761" pcid="2593">
            self.children,
            interpolation="cubic",
            interpolation_heatmaps=iaa.KeepSizeByResize.NO_RESIZE)

        heatmaps_oi = self.heatmaps

        heatmaps_oi_aug = aug.augment_heatmaps([heatmaps_oi])[0]

        assert heatmaps_oi_aug.arr_0to1.shape == (3, 4, 1)
        assert np.allclose(
            heatmaps_oi_aug.arr_0to1, heatmaps_oi.arr_0to1[1:, :, :])

    def test_heatmaps_specific_interpolation_set_to_same_as_images(self):
        aug = iaa.KeepSizeByResize(
            self.children,
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="3772" endline="3784" pcid="2595">
            heatmaps_oi_aug.arr_0to1, heatmaps_oi_cubic.arr_0to1)

    def test_segmaps_general_interpolation_set_to_cubic(self):
        aug = iaa.KeepSizeByResize(self.children, interpolation="cubic")
        segmaps_oi = self.segmaps
        segmaps_oi_nearest = self.segmaps_nearest

        segmaps_oi_aug = aug.augment_segmentation_maps([segmaps_oi])[0]

        assert segmaps_oi_aug.arr.shape == (4, 4, 1)
        assert np.array_equal(segmaps_oi_aug.arr, segmaps_oi_nearest.arr)

    def test_segmaps_specific_interpolation_set_to_nearest(self):
</source>
<source file="systems/imgaug-0.3.0/test/augmenters/test_size.py" startline="3733" endline="3746" pcid="2592">
        heatmaps_oi = self.heatmaps
        heatmaps_oi_cubic = self.heatmaps_cubic
        heatmaps_oi_nearest = self.heatmaps_nearest

        hmoi_aug = aug.augment_heatmaps([heatmaps_oi])[0]

        assert hmoi_aug.arr_0to1.shape == (4, 4, 1)
        assert (
            np.allclose(hmoi_aug.arr_0to1, heatmaps_oi_nearest.arr_0to1)
            or np.allclose(hmoi_aug.arr_0to1, heatmaps_oi_cubic.arr_0to1)
        )

    def test_heatmaps_specific_interpolation_set_to_no_resize(self):
        aug = iaa.KeepSizeByResize(
</source>
</class>

<class classid="172" nclones="2" nlines="45" similarity="76">
<source file="systems/imgaug-0.3.0/test/augmentables/test_normalization.py" startline="79" endline="147" pcid="2605">
    def test_invert_normalize_heatmaps(self):
        def _norm_and_invert(heatmaps, images):
            return normalization.invert_normalize_heatmaps(
                normalization.normalize_heatmaps(heatmaps, shapes=images),
                heatmaps
            )

        # ----
        # None
        # ----
        observed = normalization.invert_normalize_heatmaps(None, None)
        assert observed is None

        # ----
        # array
        # ----
        for images in [[np.zeros((1, 1, 3), dtype=np.uint8)],
                       np.zeros((1, 1, 1, 3), dtype=np.uint8)]:
            before = np.zeros((1, 1, 1, 1), dtype=np.float32) + 0.1
            after = _norm_and_invert(before, images=images)
            assert ia.is_np_array(after)
            assert after.shape == (1, 1, 1, 1)
            assert after.dtype.name == "float32"
            assert np.allclose(after, before)

        # ----
        # single HeatmapsOnImage
        # ----
        before = ia.HeatmapsOnImage(
                    np.zeros((1, 1, 1), dtype=np.float32) + 0.1,
                    shape=(1, 1, 3))
        after = _norm_and_invert(before, images=None)
        assert isinstance(after, ia.HeatmapsOnImage)
        assert after.shape == before.shape
        assert np.allclose(after.arr_0to1, before.arr_0to1)

        # ----
        # empty iterable
        # ----
        before = []
        after = _norm_and_invert(before, images=None)
        assert isinstance(after, list)
        assert len(after) == 0

        # ----
        # iterable of arrays
        # ----
        for images in [[np.zeros((1, 1, 3), dtype=np.uint8)],
                       np.zeros((1, 1, 1, 3), dtype=np.uint8)]:
            before = [np.zeros((1, 1, 1), dtype=np.float32) + 0.1]
            after = _norm_and_invert(before, images=images)
            assert isinstance(after, list)
            assert len(after) == 1
            assert after[0].shape == (1, 1, 1)
            assert after[0].dtype.name == "float32"
            assert np.allclose(after[0], before[0])

        # ----
        # iterable of HeatmapsOnImage
        # ----
        before = [ia.HeatmapsOnImage(
                    np.zeros((1, 1, 1), dtype=np.float32) + 0.1,
                    shape=(1, 1, 3))]
        after = _norm_and_invert(before, images=None)
        assert isinstance(after, list)
        assert isinstance(after[0], ia.HeatmapsOnImage)
        assert after[0].shape == before[0].shape
        assert np.allclose(after[0].arr_0to1, before[0].arr_0to1)

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_normalization.py" startline="148" endline="219" pcid="2607">
    def test_invert_normalize_segmentation_maps(self):
        def _norm_and_invert(segmaps, images):
            return normalization.invert_normalize_segmentation_maps(
                normalization.normalize_segmentation_maps(
                    segmaps, shapes=images),
                segmaps
            )

        # ----
        # None
        # ----
        observed = normalization.invert_normalize_segmentation_maps(None, None)
        assert observed is None

        # ----
        # array
        # ----
        for dt in [np.dtype("int32"), np.dtype("uint16"), np.dtype(bool)]:
            for images in [[np.zeros((1, 1, 3), dtype=np.uint8)],
                           np.zeros((1, 1, 3), dtype=np.uint8)]:
                before = np.ones((1, 1, 1, 1), dtype=dt)
                after = _norm_and_invert(before, images=images)
                assert ia.is_np_array(after)
                assert after.shape == (1, 1, 1, 1)
                assert after.dtype.name == dt.name
                assert np.array_equal(after, before)

        # ----
        # single SegmentationMapsOnImage
        # ----
        before = ia.SegmentationMapsOnImage(
                     np.zeros((1, 1, 1), dtype=np.int32) + 1,
                     shape=(1, 1, 3))
        after = _norm_and_invert(before, images=None)
        assert isinstance(after, ia.SegmentationMapsOnImage)
        assert after.shape == before.shape
        assert np.array_equal(after.arr, before.arr)

        # ----
        # empty iterable
        # ----
        before = []
        after = _norm_and_invert(before, images=None)
        assert isinstance(after, list)
        assert len(after) == 0

        # ----
        # iterable of arrays
        # ----
        for dt in [np.dtype("int32"), np.dtype("uint16"), np.dtype(bool)]:
            for images in [[np.zeros((1, 1, 3), dtype=np.uint8)],
                           np.zeros((1, 1, 1, 3), dtype=np.uint8)]:
                before = [np.ones((1, 1, 1), dtype=dt)]
                after = _norm_and_invert(before, images=images)
                assert isinstance(after, list)
                assert len(after) == 1
                assert after[0].shape == (1, 1, 1)
                assert after[0].dtype.name == dt.name
                assert np.array_equal(after[0], before[0])

        # ----
        # iterable of SegmentationMapsOnImage
        # ----
        before = [ia.SegmentationMapsOnImage(
                    np.zeros((1, 1, 1), dtype=np.int32) + 1,
                    shape=(1, 1, 3))]
        after = _norm_and_invert(before, images=None)
        assert isinstance(after, list)
        assert isinstance(after[0], ia.SegmentationMapsOnImage)
        assert after[0].shape == before[0].shape
        assert np.allclose(after[0].arr, before[0].arr)

</source>
</class>

<class classid="173" nclones="2" nlines="241" similarity="72">
<source file="systems/imgaug-0.3.0/test/augmentables/test_normalization.py" startline="1317" endline="1664" pcid="2620">
    def test_normalize_keypoints(self):
        def _assert_single_image_expected(inputs):
            # --> images None
            with self.assertRaises(ValueError):
                _keypoints_norm = normalization.normalize_keypoints(
                    inputs, None)

            # --> too many images
            with self.assertRaises(ValueError):
                _keypoints_norm = normalization.normalize_keypoints(
                    inputs,
                    shapes=np.zeros((2, 1, 1, 3), dtype=np.uint8)
                )

            # --> too many images
            with self.assertRaises(ValueError):
                _keypoints_norm = normalization.normalize_keypoints(
                    inputs,
                    shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                            np.zeros((1, 1, 3), dtype=np.uint8)]
                )

        # ----
        # None
        # ----
        keypoints_norm = normalization.normalize_keypoints(None)
        assert keypoints_norm is None

        # ----
        # array
        # ----
        for dt in [np.dtype("float32"), np.dtype("int16"), np.dtype("uint16")]:
            keypoints_norm = normalization.normalize_keypoints(
                np.zeros((1, 1, 2), dtype=dt) + 1,
                shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
            )
            assert isinstance(keypoints_norm, list)
            assert isinstance(keypoints_norm[0], ia.KeypointsOnImage)
            assert len(keypoints_norm[0].keypoints) == 1
            assert np.allclose(keypoints_norm[0].to_xy_array(), 1)

            keypoints_norm = normalization.normalize_keypoints(
                np.zeros((1, 5, 2), dtype=dt) + 1,
                shapes=np.zeros((1, 1, 1, 3), dtype=np.uint8)
            )
            assert isinstance(keypoints_norm, list)
            assert isinstance(keypoints_norm[0], ia.KeypointsOnImage)
            assert len(keypoints_norm[0].keypoints) == 5
            assert np.allclose(keypoints_norm[0].to_xy_array(), 1)

            # --> keypoints for too many images
            with self.assertRaises(ValueError):
                _keypoints_norm = normalization.normalize_keypoints(
                    np.zeros((2, 1, 2), dtype=dt) + 1,
                    shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
                )

            # --> too few keypoints
            with self.assertRaises(ValueError):
                _keypoints_norm = normalization.normalize_keypoints(
                    np.zeros((1, 1, 2), dtype=dt) + 1,
                    shapes=np.zeros((2, 1, 1, 3), dtype=np.uint8)
                )

            # --> wrong keypoints shape
            with self.assertRaises(ValueError):
                _keypoints_norm = normalization.normalize_keypoints(
                    np.zeros((1, 1, 100), dtype=dt) + 1,
                    shapes=np.zeros((1, 1, 1, 3), dtype=np.uint8)
                )

            _assert_single_image_expected(np.zeros((1, 1, 2), dtype=dt) + 1)

        # ----
        # (x,y)
        # ----
        keypoints_norm = normalization.normalize_keypoints(
            (1, 2),
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert isinstance(keypoints_norm, list)
        assert isinstance(keypoints_norm[0], ia.KeypointsOnImage)
        assert len(keypoints_norm[0].keypoints) == 1
        assert keypoints_norm[0].keypoints[0].x == 1
        assert keypoints_norm[0].keypoints[0].y == 2

        _assert_single_image_expected((1, 2))

        # ----
        # single Keypoint instance
        # ----
        keypoints_norm = normalization.normalize_keypoints(
            ia.Keypoint(x=1, y=2),
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert isinstance(keypoints_norm, list)
        assert isinstance(keypoints_norm[0], ia.KeypointsOnImage)
        assert len(keypoints_norm[0].keypoints) == 1
        assert keypoints_norm[0].keypoints[0].x == 1
        assert keypoints_norm[0].keypoints[0].y == 2

        _assert_single_image_expected(ia.Keypoint(x=1, y=2))

        # ----
        # single KeypointsOnImage instance
        # ----
        keypoints_norm = normalization.normalize_keypoints(
            ia.KeypointsOnImage([ia.Keypoint(x=1, y=2)], shape=(1, 1, 3)),
            shapes=None
        )
        assert isinstance(keypoints_norm, list)
        assert isinstance(keypoints_norm[0], ia.KeypointsOnImage)
        assert len(keypoints_norm[0].keypoints) == 1
        assert keypoints_norm[0].keypoints[0].x == 1
        assert keypoints_norm[0].keypoints[0].y == 2

        # ----
        # empty iterable
        # ----
        keypoints_norm = normalization.normalize_keypoints(
            [], shapes=None
        )
        assert keypoints_norm is None

        # ----
        # iterable of array
        # ----
        for dt in [np.dtype("float32"), np.dtype("int16"), np.dtype("uint16")]:
            keypoints_norm = normalization.normalize_keypoints(
                [np.zeros((1, 2), dtype=dt) + 1],
                shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
            )
            assert isinstance(keypoints_norm, list)
            assert isinstance(keypoints_norm[0], ia.KeypointsOnImage)
            assert len(keypoints_norm[0].keypoints) == 1
            assert np.allclose(keypoints_norm[0].to_xy_array(), 1)

            keypoints_norm = normalization.normalize_keypoints(
                [np.zeros((5, 2), dtype=dt) + 1],
                shapes=np.zeros((1, 1, 1, 3), dtype=np.uint8)
            )
            assert isinstance(keypoints_norm, list)
            assert isinstance(keypoints_norm[0], ia.KeypointsOnImage)
            assert len(keypoints_norm[0].keypoints) == 5
            assert np.allclose(keypoints_norm[0].to_xy_array(), 1)

            # --> keypoints for too many images
            with self.assertRaises(ValueError):
                _keypoints_norm = normalization.normalize_keypoints(
                    [
                        np.zeros((1, 2), dtype=dt) + 1,
                        np.zeros((1, 2), dtype=dt) + 1
                    ],
                    shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
                )

            # --> too few keypoints
            with self.assertRaises(ValueError):
                _keypoints_norm = normalization.normalize_keypoints(
                    [np.zeros((1, 2), dtype=dt) + 1],
                    shapes=np.zeros((2, 1, 1, 3), dtype=np.uint8)
                )

            # --> images None
            with self.assertRaises(ValueError):
                _keypoints_norm = normalization.normalize_keypoints(
                    [np.zeros((1, 2), dtype=dt) + 1],
                    shapes=None
                )

            # --> wrong shape
            with self.assertRaises(ValueError):
                _keypoints_norm = normalization.normalize_keypoints(
                    [np.zeros((1, 100), dtype=dt) + 1],
                    shapes=np.zeros((1, 1, 1, 3), dtype=np.uint8)
                )

        # ----
        # iterable of (x,y)
        # ----
        keypoints_norm = normalization.normalize_keypoints(
            [(1, 2), (3, 4)],
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert isinstance(keypoints_norm, list)
        assert isinstance(keypoints_norm[0], ia.KeypointsOnImage)
        assert len(keypoints_norm[0].keypoints) == 2
        assert keypoints_norm[0].keypoints[0].x == 1
        assert keypoints_norm[0].keypoints[0].y == 2
        assert keypoints_norm[0].keypoints[1].x == 3
        assert keypoints_norm[0].keypoints[1].y == 4

        # may only be used for single images
        with self.assertRaises(ValueError):
            _keypoints_norm = normalization.normalize_keypoints(
                [(1, 2)],
                shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                        np.zeros((1, 1, 3), dtype=np.uint8)]
            )

        # ----
        # iterable of Keypoint
        # ----
        keypoints_norm = normalization.normalize_keypoints(
            [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=4)],
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert isinstance(keypoints_norm, list)
        assert isinstance(keypoints_norm[0], ia.KeypointsOnImage)
        assert len(keypoints_norm[0].keypoints) == 2
        assert keypoints_norm[0].keypoints[0].x == 1
        assert keypoints_norm[0].keypoints[0].y == 2
        assert keypoints_norm[0].keypoints[1].x == 3
        assert keypoints_norm[0].keypoints[1].y == 4

        # may only be used for single images
        with self.assertRaises(ValueError):
            _keypoints_norm = normalization.normalize_keypoints(
                [ia.Keypoint(x=1, y=2)],
                shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                        np.zeros((1, 1, 3), dtype=np.uint8)]
            )

        # ----
        # iterable of KeypointsOnImage
        # ----
        keypoints_norm = normalization.normalize_keypoints(
            [
                ia.KeypointsOnImage([ia.Keypoint(x=1, y=2)], shape=(1, 1, 3)),
                ia.KeypointsOnImage([ia.Keypoint(x=3, y=4)], shape=(1, 1, 3)),
            ],
            shapes=None
        )
        assert isinstance(keypoints_norm, list)

        assert isinstance(keypoints_norm[0], ia.KeypointsOnImage)
        assert len(keypoints_norm[0].keypoints) == 1
        assert keypoints_norm[0].keypoints[0].x == 1
        assert keypoints_norm[0].keypoints[0].y == 2

        assert isinstance(keypoints_norm[1], ia.KeypointsOnImage)
        assert len(keypoints_norm[1].keypoints) == 1
        assert keypoints_norm[1].keypoints[0].x == 3
        assert keypoints_norm[1].keypoints[0].y == 4

        # ----
        # iterable of empty interables
        # ----
        keypoints_norm = normalization.normalize_keypoints(
            [[]],
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert keypoints_norm is None

        # ----
        # iterable of iterable of (x,y)
        # ----
        keypoints_norm = normalization.normalize_keypoints(
            [
                [(1, 2), (3, 4)],
                [(5, 6), (7, 8)]
            ],
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                    np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert isinstance(keypoints_norm, list)
        assert isinstance(keypoints_norm[0], ia.KeypointsOnImage)
        assert len(keypoints_norm[0].keypoints) == 2
        assert keypoints_norm[0].keypoints[0].x == 1
        assert keypoints_norm[0].keypoints[0].y == 2
        assert keypoints_norm[0].keypoints[1].x == 3
        assert keypoints_norm[0].keypoints[1].y == 4

        assert len(keypoints_norm[1].keypoints) == 2
        assert keypoints_norm[1].keypoints[0].x == 5
        assert keypoints_norm[1].keypoints[0].y == 6
        assert keypoints_norm[1].keypoints[1].x == 7
        assert keypoints_norm[1].keypoints[1].y == 8

        # --> images None
        with self.assertRaises(ValueError):
            _keypoints_norm = normalization.normalize_keypoints(
                [
                    [(1, 2), (3, 4)],
                    [(5, 6), (7, 8)]
                ],
                shapes=None
            )

        # --> different number of images
        with self.assertRaises(ValueError):
            _keypoints_norm = normalization.normalize_keypoints(
                [
                    [(1, 2), (3, 4)],
                    [(5, 6), (7, 8)]
                ],
                shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                        np.zeros((1, 1, 3), dtype=np.uint8),
                        np.zeros((1, 1, 3), dtype=np.uint8)]
            )

        # ----
        # iterable of iterable of Keypoint
        # ----
        keypoints_norm = normalization.normalize_keypoints(
            [
                [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=4)],
                [ia.Keypoint(x=5, y=6), ia.Keypoint(x=7, y=8)]
            ],
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                    np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert isinstance(keypoints_norm, list)
        assert isinstance(keypoints_norm[0], ia.KeypointsOnImage)
        assert len(keypoints_norm[0].keypoints) == 2
        assert keypoints_norm[0].keypoints[0].x == 1
        assert keypoints_norm[0].keypoints[0].y == 2
        assert keypoints_norm[0].keypoints[1].x == 3
        assert keypoints_norm[0].keypoints[1].y == 4

        assert len(keypoints_norm[1].keypoints) == 2
        assert keypoints_norm[1].keypoints[0].x == 5
        assert keypoints_norm[1].keypoints[0].y == 6
        assert keypoints_norm[1].keypoints[1].x == 7
        assert keypoints_norm[1].keypoints[1].y == 8

        # --> images None
        with self.assertRaises(ValueError):
            _keypoints_norm = normalization.normalize_keypoints(
                [
                    [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=4)],
                    [ia.Keypoint(x=5, y=6), ia.Keypoint(x=7, y=8)]
                ],
                shapes=None
            )

        # --> different number of images
        with self.assertRaises(ValueError):
            _keypoints_norm = normalization.normalize_keypoints(
                [
                    [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=4)],
                    [ia.Keypoint(x=5, y=6), ia.Keypoint(x=7, y=8)]
                ],
                shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                        np.zeros((1, 1, 3), dtype=np.uint8),
                        np.zeros((1, 1, 3), dtype=np.uint8)]
            )

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_normalization.py" startline="1665" endline="2058" pcid="2622">
    def test_normalize_bounding_boxes(self):
        def _assert_single_image_expected(inputs):
            # --> images None
            with self.assertRaises(ValueError):
                _bbs_norm = normalization.normalize_bounding_boxes(
                    inputs,
                    shapes=None
                )

            # --> too many images
            with self.assertRaises(ValueError):
                _bbs_norm = normalization.normalize_bounding_boxes(
                    inputs,
                    shapes=np.zeros((2, 1, 1, 3), dtype=np.uint8)
                )

            # --> too many images
            with self.assertRaises(ValueError):
                _bbs_norm = normalization.normalize_bounding_boxes(
                    inputs,
                    shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                            np.zeros((1, 1, 3), dtype=np.uint8)]
                )

        # ----
        # None
        # ----
        bbs_norm = normalization.normalize_bounding_boxes(None)
        assert bbs_norm is None

        # ----
        # array
        # ----
        for dt in [np.dtype("float32"), np.dtype("int16"), np.dtype("uint16")]:
            bbs_norm = normalization.normalize_bounding_boxes(
                np.zeros((1, 1, 4), dtype=dt) + 1,
                shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
            )
            assert isinstance(bbs_norm, list)
            assert isinstance(bbs_norm[0], ia.BoundingBoxesOnImage)
            assert len(bbs_norm[0].bounding_boxes) == 1
            assert np.allclose(bbs_norm[0].to_xyxy_array(), 1)

            bbs_norm = normalization.normalize_bounding_boxes(
                np.zeros((1, 5, 4), dtype=dt) + 1,
                shapes=np.zeros((1, 1, 1, 3), dtype=np.uint8)
            )
            assert isinstance(bbs_norm, list)
            assert isinstance(bbs_norm[0], ia.BoundingBoxesOnImage)
            assert len(bbs_norm[0].bounding_boxes) == 5
            assert np.allclose(bbs_norm[0].to_xyxy_array(), 1)

            # --> bounding boxes for too many images
            with self.assertRaises(ValueError):
                _bbs_norm = normalization.normalize_bounding_boxes(
                    np.zeros((2, 1, 4), dtype=dt) + 1,
                    shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
                )

            # --> too few bounding boxes
            with self.assertRaises(ValueError):
                _bbs_norm = normalization.normalize_bounding_boxes(
                    np.zeros((1, 1, 4), dtype=dt) + 1,
                    shapes=np.zeros((2, 1, 1, 3), dtype=np.uint8)
                )

            # --> wrong keypoints shape
            with self.assertRaises(ValueError):
                _bbs_norm = normalization.normalize_bounding_boxes(
                    np.zeros((1, 1, 100), dtype=dt) + 1,
                    shapes=np.zeros((1, 1, 1, 3), dtype=np.uint8)
                )

            _assert_single_image_expected(np.zeros((1, 1, 4), dtype=dt) + 1)

        # ----
        # (x1,y1,x2,y2)
        # ----
        bbs_norm = normalization.normalize_bounding_boxes(
            (1, 2, 3, 4),
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert isinstance(bbs_norm, list)
        assert isinstance(bbs_norm[0], ia.BoundingBoxesOnImage)
        assert len(bbs_norm[0].bounding_boxes) == 1
        assert bbs_norm[0].bounding_boxes[0].x1 == 1
        assert bbs_norm[0].bounding_boxes[0].y1 == 2
        assert bbs_norm[0].bounding_boxes[0].x2 == 3
        assert bbs_norm[0].bounding_boxes[0].y2 == 4

        _assert_single_image_expected((1, 2, 3, 4))

        # ----
        # single BoundingBox instance
        # ----
        bbs_norm = normalization.normalize_bounding_boxes(
            ia.BoundingBox(x1=1, y1=2, x2=3, y2=4),
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert isinstance(bbs_norm, list)
        assert isinstance(bbs_norm[0], ia.BoundingBoxesOnImage)
        assert len(bbs_norm[0].bounding_boxes) == 1
        assert bbs_norm[0].bounding_boxes[0].x1 == 1
        assert bbs_norm[0].bounding_boxes[0].y1 == 2
        assert bbs_norm[0].bounding_boxes[0].x2 == 3
        assert bbs_norm[0].bounding_boxes[0].y2 == 4

        _assert_single_image_expected(ia.BoundingBox(x1=1, y1=2, x2=3, y2=4))

        # ----
        # single BoundingBoxesOnImage instance
        # ----
        bbs_norm = normalization.normalize_bounding_boxes(
            ia.BoundingBoxesOnImage(
                [ia.BoundingBox(x1=1, y1=2, x2=3, y2=4)],
                shape=(1, 1, 3)),
            shapes=None
        )
        assert isinstance(bbs_norm, list)
        assert isinstance(bbs_norm[0], ia.BoundingBoxesOnImage)
        assert len(bbs_norm[0].bounding_boxes) == 1
        assert bbs_norm[0].bounding_boxes[0].x1 == 1
        assert bbs_norm[0].bounding_boxes[0].y1 == 2
        assert bbs_norm[0].bounding_boxes[0].x2 == 3
        assert bbs_norm[0].bounding_boxes[0].y2 == 4

        # ----
        # empty iterable
        # ----
        bbs_norm = normalization.normalize_bounding_boxes([], shapes=None)
        assert bbs_norm is None

        # ----
        # iterable of array
        # ----
        for dt in [np.dtype("float32"), np.dtype("int16"), np.dtype("uint16")]:
            bbs_norm = normalization.normalize_bounding_boxes(
                [np.zeros((1, 4), dtype=dt) + 1],
                shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
            )
            assert isinstance(bbs_norm, list)
            assert isinstance(bbs_norm[0], ia.BoundingBoxesOnImage)
            assert len(bbs_norm[0].bounding_boxes) == 1
            assert np.allclose(bbs_norm[0].to_xyxy_array(), 1)

            bbs_norm = normalization.normalize_bounding_boxes(
                [np.zeros((5, 4), dtype=dt) + 1],
                shapes=np.zeros((1, 1, 1, 3), dtype=np.uint8)
            )
            assert isinstance(bbs_norm, list)
            assert isinstance(bbs_norm[0], ia.BoundingBoxesOnImage)
            assert len(bbs_norm[0].bounding_boxes) == 5
            assert np.allclose(bbs_norm[0].to_xyxy_array(), 1)

            # --> bounding boxes for too many images
            with self.assertRaises(ValueError):
                _bbs_norm = normalization.normalize_bounding_boxes(
                    [
                        np.zeros((1, 4), dtype=dt) + 1,
                        np.zeros((1, 4), dtype=dt) + 1
                    ],
                    shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
                )

            # --> too few bounding boxes
            with self.assertRaises(ValueError):
                _bbs_norm = normalization.normalize_bounding_boxes(
                    [np.zeros((1, 4), dtype=dt) + 1],
                    shapes=np.zeros((2, 1, 1, 3), dtype=np.uint8)
                )

            # --> images None
            with self.assertRaises(ValueError):
                _bbs_norm = normalization.normalize_bounding_boxes(
                    [np.zeros((1, 4), dtype=dt) + 1],
                    shapes=None
                )

            # --> wrong shape
            with self.assertRaises(ValueError):
                _bbs_norm = normalization.normalize_bounding_boxes(
                    [np.zeros((1, 100), dtype=dt) + 1],
                    shapes=np.zeros((1, 1, 1, 3), dtype=np.uint8)
                )

        # ----
        # iterable of (x1,y1,x2,y2)
        # ----
        bbs_norm = normalization.normalize_bounding_boxes(
            [(1, 2, 3, 4), (5, 6, 7, 8)],
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert isinstance(bbs_norm, list)
        assert isinstance(bbs_norm[0], ia.BoundingBoxesOnImage)
        assert len(bbs_norm[0].bounding_boxes) == 2
        assert bbs_norm[0].bounding_boxes[0].x1 == 1
        assert bbs_norm[0].bounding_boxes[0].y1 == 2
        assert bbs_norm[0].bounding_boxes[0].x2 == 3
        assert bbs_norm[0].bounding_boxes[0].y2 == 4
        assert bbs_norm[0].bounding_boxes[1].x1 == 5
        assert bbs_norm[0].bounding_boxes[1].y1 == 6
        assert bbs_norm[0].bounding_boxes[1].x2 == 7
        assert bbs_norm[0].bounding_boxes[1].y2 == 8

        # may only be used for single images
        with self.assertRaises(ValueError):
            _bbs_norm = normalization.normalize_bounding_boxes(
                [(1, 2, 3, 4)],
                shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                        np.zeros((1, 1, 3), dtype=np.uint8)]
            )

        # ----
        # iterable of BoundingBox
        # ----
        bbs_norm = normalization.normalize_bounding_boxes(
            [
                ia.BoundingBox(x1=1, y1=2, x2=3, y2=4),
                ia.BoundingBox(x1=5, y1=6, x2=7, y2=8)
            ],
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert isinstance(bbs_norm, list)
        assert isinstance(bbs_norm[0], ia.BoundingBoxesOnImage)
        assert len(bbs_norm[0].bounding_boxes) == 2
        assert bbs_norm[0].bounding_boxes[0].x1 == 1
        assert bbs_norm[0].bounding_boxes[0].y1 == 2
        assert bbs_norm[0].bounding_boxes[0].x2 == 3
        assert bbs_norm[0].bounding_boxes[0].y2 == 4
        assert bbs_norm[0].bounding_boxes[1].x1 == 5
        assert bbs_norm[0].bounding_boxes[1].y1 == 6
        assert bbs_norm[0].bounding_boxes[1].x2 == 7
        assert bbs_norm[0].bounding_boxes[1].y2 == 8

        # may only be used for single images
        with self.assertRaises(ValueError):
            _bbs_norm = normalization.normalize_bounding_boxes(
                [ia.BoundingBox(x1=1, y1=2, x2=3, y2=4)],
                shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                        np.zeros((1, 1, 3), dtype=np.uint8)]
            )

        # ----
        # iterable of BoundingBoxesOnImage
        # ----
        bbs_norm = normalization.normalize_bounding_boxes(
            [
                ia.BoundingBoxesOnImage(
                    [ia.BoundingBox(x1=1, y1=2, x2=3, y2=4)],
                    shape=(1, 1, 3)),
                ia.BoundingBoxesOnImage(
                    [ia.BoundingBox(x1=5, y1=6, x2=7, y2=8)],
                    shape=(1, 1, 3))
            ],
            shapes=None
        )
        assert isinstance(bbs_norm, list)

        assert isinstance(bbs_norm[0], ia.BoundingBoxesOnImage)
        assert len(bbs_norm[0].bounding_boxes) == 1
        assert bbs_norm[0].bounding_boxes[0].x1 == 1
        assert bbs_norm[0].bounding_boxes[0].y1 == 2
        assert bbs_norm[0].bounding_boxes[0].x2 == 3
        assert bbs_norm[0].bounding_boxes[0].y2 == 4

        assert isinstance(bbs_norm[1], ia.BoundingBoxesOnImage)
        assert len(bbs_norm[1].bounding_boxes) == 1
        assert bbs_norm[1].bounding_boxes[0].x1 == 5
        assert bbs_norm[1].bounding_boxes[0].y1 == 6
        assert bbs_norm[1].bounding_boxes[0].x2 == 7
        assert bbs_norm[1].bounding_boxes[0].y2 == 8

        # ----
        # iterable of empty interables
        # ----
        bbs_norm = normalization.normalize_bounding_boxes(
            [[]],
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert bbs_norm is None

        # ----
        # iterable of iterable of (x1,y1,x2,y2)
        # ----
        bbs_norm = normalization.normalize_bounding_boxes(
            [
                [(1, 2, 3, 4)],
                [(5, 6, 7, 8), (9, 10, 11, 12)]
            ],
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                    np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert isinstance(bbs_norm, list)
        assert isinstance(bbs_norm[0], ia.BoundingBoxesOnImage)
        assert len(bbs_norm[0].bounding_boxes) == 1
        assert bbs_norm[0].bounding_boxes[0].x1 == 1
        assert bbs_norm[0].bounding_boxes[0].y1 == 2
        assert bbs_norm[0].bounding_boxes[0].x2 == 3
        assert bbs_norm[0].bounding_boxes[0].y2 == 4

        assert len(bbs_norm[1].bounding_boxes) == 2
        assert bbs_norm[1].bounding_boxes[0].x1 == 5
        assert bbs_norm[1].bounding_boxes[0].y1 == 6
        assert bbs_norm[1].bounding_boxes[0].x2 == 7
        assert bbs_norm[1].bounding_boxes[0].y2 == 8

        assert bbs_norm[1].bounding_boxes[1].x1 == 9
        assert bbs_norm[1].bounding_boxes[1].y1 == 10
        assert bbs_norm[1].bounding_boxes[1].x2 == 11
        assert bbs_norm[1].bounding_boxes[1].y2 == 12

        # --> images None
        with self.assertRaises(ValueError):
            _bbs_norm = normalization.normalize_bounding_boxes(
                [
                    [(1, 2, 3, 4), (3, 4, 5, 6)],
                    [(5, 6, 7, 8), (7, 8, 9, 10)]
                ],
                shapes=None
            )

        # --> different number of images
        with self.assertRaises(ValueError):
            _bbs_norm = normalization.normalize_bounding_boxes(
                [
                    [(1, 2, 3, 4)],
                    [(5, 6, 7, 8)]
                ],
                [np.zeros((1, 1, 3), dtype=np.uint8),
                 np.zeros((1, 1, 3), dtype=np.uint8),
                 np.zeros((1, 1, 3), dtype=np.uint8)]
            )

        # ----
        # iterable of iterable of Keypoint
        # ----
        bbs_norm = normalization.normalize_bounding_boxes(
            [
                [ia.BoundingBox(x1=1, y1=2, x2=3, y2=4),
                 ia.BoundingBox(x1=5, y1=6, x2=7, y2=8)],
                [ia.BoundingBox(x1=9, y1=10, x2=11, y2=12),
                 ia.BoundingBox(x1=13, y1=14, x2=15, y2=16)]
            ],
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                    np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert isinstance(bbs_norm, list)
        assert isinstance(bbs_norm[0], ia.BoundingBoxesOnImage)
        assert len(bbs_norm[0].bounding_boxes) == 2
        assert bbs_norm[0].bounding_boxes[0].x1 == 1
        assert bbs_norm[0].bounding_boxes[0].y1 == 2
        assert bbs_norm[0].bounding_boxes[0].x2 == 3
        assert bbs_norm[0].bounding_boxes[0].y2 == 4
        assert bbs_norm[0].bounding_boxes[1].x1 == 5
        assert bbs_norm[0].bounding_boxes[1].y1 == 6
        assert bbs_norm[0].bounding_boxes[1].x2 == 7
        assert bbs_norm[0].bounding_boxes[1].y2 == 8

        assert len(bbs_norm[1].bounding_boxes) == 2
        assert bbs_norm[1].bounding_boxes[0].x1 == 9
        assert bbs_norm[1].bounding_boxes[0].y1 == 10
        assert bbs_norm[1].bounding_boxes[0].x2 == 11
        assert bbs_norm[1].bounding_boxes[0].y2 == 12
        assert bbs_norm[1].bounding_boxes[1].x1 == 13
        assert bbs_norm[1].bounding_boxes[1].y1 == 14
        assert bbs_norm[1].bounding_boxes[1].x2 == 15
        assert bbs_norm[1].bounding_boxes[1].y2 == 16

        # --> images None
        with self.assertRaises(ValueError):
            _bbs_norm = normalization.normalize_bounding_boxes(
                [
                    [ia.BoundingBox(x1=1, y1=2, x2=3, y2=4),
                     ia.BoundingBox(x1=5, y1=6, x2=7, y2=8)],
                    [ia.BoundingBox(x1=9, y1=10, x2=11, y2=12),
                     ia.BoundingBox(x1=13, y1=14, x2=15, y2=16)]
                ],
                shapes=None
            )

        # --> different number of images
        with self.assertRaises(ValueError):
            _bbs_norm = normalization.normalize_bounding_boxes(
                [
                    [ia.BoundingBox(x1=1, y1=2, x2=3, y2=4),
                     ia.BoundingBox(x1=5, y1=6, x2=7, y2=8)],
                    [ia.BoundingBox(x1=9, y1=10, x2=11, y2=12),
                     ia.BoundingBox(x1=13, y1=14, x2=15, y2=16)]
                ],
                shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                        np.zeros((1, 1, 3), dtype=np.uint8),
                        np.zeros((1, 1, 3), dtype=np.uint8)]
            )
    
</source>
</class>

<class classid="174" nclones="3" nlines="13" similarity="85">
<source file="systems/imgaug-0.3.0/test/augmentables/test_normalization.py" startline="1318" endline="1341" pcid="2621">
        def _assert_single_image_expected(inputs):
            # --> images None
            with self.assertRaises(ValueError):
                _keypoints_norm = normalization.normalize_keypoints(
                    inputs, None)

            # --> too many images
            with self.assertRaises(ValueError):
                _keypoints_norm = normalization.normalize_keypoints(
                    inputs,
                    shapes=np.zeros((2, 1, 1, 3), dtype=np.uint8)
                )

            # --> too many images
            with self.assertRaises(ValueError):
                _keypoints_norm = normalization.normalize_keypoints(
                    inputs,
                    shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                            np.zeros((1, 1, 3), dtype=np.uint8)]
                )

        # ----
        # None
        # ----
</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_normalization.py" startline="2060" endline="2079" pcid="2625">
        def _assert_single_image_expected(inputs):
            # --> images None
            with self.assertRaises(ValueError):
                _polygons_norm = normalization.normalize_polygons(
                    inputs, shapes=None)

            # --> too many images
            with self.assertRaises(ValueError):
                _polygons_norm = normalization.normalize_polygons(
                    inputs,
                    shapes=np.zeros((2, 1, 1, 3), dtype=np.uint8))

            # --> too many images
            with self.assertRaises(ValueError):
                _polygons_norm = normalization.normalize_polygons(
                    inputs,
                    shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                            np.zeros((1, 1, 3), dtype=np.uint8)]
                )

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_normalization.py" startline="1666" endline="1691" pcid="2623">
        def _assert_single_image_expected(inputs):
            # --> images None
            with self.assertRaises(ValueError):
                _bbs_norm = normalization.normalize_bounding_boxes(
                    inputs,
                    shapes=None
                )

            # --> too many images
            with self.assertRaises(ValueError):
                _bbs_norm = normalization.normalize_bounding_boxes(
                    inputs,
                    shapes=np.zeros((2, 1, 1, 3), dtype=np.uint8)
                )

            # --> too many images
            with self.assertRaises(ValueError):
                _bbs_norm = normalization.normalize_bounding_boxes(
                    inputs,
                    shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                            np.zeros((1, 1, 3), dtype=np.uint8)]
                )

        # ----
        # None
        # ----
</source>
</class>

<class classid="175" nclones="2" nlines="38" similarity="84">
<source file="systems/imgaug-0.3.0/test/augmentables/test_normalization.py" startline="2891" endline="2950" pcid="2629">
    def test_estimate_heatmaps_norm_type(self):
        ntype = normalization.estimate_heatmaps_norm_type(None)
        assert ntype == "None"

        ntype = normalization.estimate_heatmaps_norm_type(
            np.zeros((1, 1, 1, 1), dtype=np.float32))
        assert ntype == "array[float]"

        ntype = normalization.estimate_heatmaps_norm_type(
            ia.HeatmapsOnImage(
                np.zeros((1, 1, 1), dtype=np.float32),
                shape=(1, 1, 1)
            )
        )
        assert ntype == "HeatmapsOnImage"

        ntype = normalization.estimate_heatmaps_norm_type([])
        assert ntype == "iterable[empty]"

        ntype = normalization.estimate_heatmaps_norm_type(
            [np.zeros((1, 1, 1), dtype=np.float32)])
        assert ntype == "iterable-array[float]"

        ntype = normalization.estimate_heatmaps_norm_type([
            ia.HeatmapsOnImage(np.zeros((1, 1, 1), dtype=np.float32),
                               shape=(1, 1, 1))
        ])
        assert ntype == "iterable-HeatmapsOnImage"

        # --
        # error cases
        # --
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_heatmaps_norm_type(1)

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_heatmaps_norm_type("foo")

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_heatmaps_norm_type(
                np.zeros((1, 1, 1), dtype=np.int32))

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_heatmaps_norm_type([1])

        # wrong class
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_heatmaps_norm_type(
                ia.KeypointsOnImage([], shape=(1, 1, 1)))

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_heatmaps_norm_type([[]])

        # list of list of Heatmaps, only list of Heatmaps is max
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_heatmaps_norm_type([
                [ia.HeatmapsOnImage(np.zeros((1, 1, 1), dtype=np.float32),
                                    shape=(1, 1, 1))]
            ])

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_normalization.py" startline="2951" endline="3009" pcid="2630">
    def test_estimate_segmaps_norm_type(self):
        ntype = normalization.estimate_segmaps_norm_type(None)
        assert ntype == "None"

        for name, dt in zip(["int", "uint", "bool"],
                            [np.int32, np.uint16, bool]):
            ntype = normalization.estimate_segmaps_norm_type(
                np.zeros((1, 1, 1, 1), dtype=dt))
            assert ntype == "array[%s]" % (name,)

        ntype = normalization.estimate_segmaps_norm_type(
            ia.SegmentationMapsOnImage(
                np.zeros((1, 1, 1), dtype=np.int32),
                shape=(1, 1, 1)
            )
        )
        assert ntype == "SegmentationMapsOnImage"

        ntype = normalization.estimate_segmaps_norm_type([])
        assert ntype == "iterable[empty]"

        ntype = normalization.estimate_segmaps_norm_type(
            [np.zeros((1, 1, 1), dtype=np.int32)])
        assert ntype == "iterable-array[int]"

        ntype = normalization.estimate_segmaps_norm_type([
            ia.SegmentationMapsOnImage(np.zeros((1, 1, 1), dtype=np.int32),
                                       shape=(1, 1, 1))
        ])
        assert ntype == "iterable-SegmentationMapsOnImage"

        # --
        # error cases
        # --
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_segmaps_norm_type(1)

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_segmaps_norm_type("foo")

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_segmaps_norm_type([1])

        # wrong class
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_segmaps_norm_type(
                ia.KeypointsOnImage([], shape=(1, 1, 1)))

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_segmaps_norm_type([[]])

        # list of list of SegMap, only list of SegMap is max
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_segmaps_norm_type([
                [ia.SegmentationMapsOnImage(
                    np.zeros((1, 1, 1, 1), dtype=np.int32),
                    shape=(1, 1, 1))]
            ])

</source>
</class>

<class classid="176" nclones="2" nlines="55" similarity="71">
<source file="systems/imgaug-0.3.0/test/augmentables/test_normalization.py" startline="3010" endline="3087" pcid="2631">
    def test_estimate_keypoints_norm_type(self):
        ntype = normalization.estimate_keypoints_norm_type(None)
        assert ntype == "None"

        for name, dt in zip(["float", "int", "uint"],
                            [np.float32, np.int32, np.uint16]):
            ntype = normalization.estimate_keypoints_norm_type(
                np.zeros((1, 5, 2), dtype=dt))
            assert ntype == "array[%s]" % (name,)

        ntype = normalization.estimate_keypoints_norm_type((1, 2))
        assert ntype == "tuple[number,size=2]"

        ntype = normalization.estimate_keypoints_norm_type(
            ia.Keypoint(x=1, y=2))
        assert ntype == "Keypoint"

        ntype = normalization.estimate_keypoints_norm_type(
            ia.KeypointsOnImage([ia.Keypoint(x=1, y=2)], shape=(1, 1, 3)))
        assert ntype == "KeypointsOnImage"

        ntype = normalization.estimate_keypoints_norm_type([])
        assert ntype == "iterable[empty]"

        for name, dt in zip(["float", "int", "uint"],
                            [np.float32, np.int32, np.uint16]):
            ntype = normalization.estimate_keypoints_norm_type(
                [np.zeros((5, 2), dtype=dt)])
            assert ntype == "iterable-array[%s]" % (name,)

        ntype = normalization.estimate_keypoints_norm_type([(1, 2)])
        assert ntype == "iterable-tuple[number,size=2]"

        ntype = normalization.estimate_keypoints_norm_type(
            [ia.Keypoint(x=1, y=2)])
        assert ntype == "iterable-Keypoint"

        ntype = normalization.estimate_keypoints_norm_type([
            ia.KeypointsOnImage([ia.Keypoint(x=1, y=2)], shape=(1, 1, 3))])
        assert ntype == "iterable-KeypointsOnImage"

        ntype = normalization.estimate_keypoints_norm_type([[]])
        assert ntype == "iterable-iterable[empty]"

        ntype = normalization.estimate_keypoints_norm_type([[(1, 2)]])
        assert ntype == "iterable-iterable-tuple[number,size=2]"

        ntype = normalization.estimate_keypoints_norm_type(
            [[ia.Keypoint(x=1, y=2)]])
        assert ntype == "iterable-iterable-Keypoint"

        # --
        # error cases
        # --
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_keypoints_norm_type(1)

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_keypoints_norm_type("foo")

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_keypoints_norm_type([1])

        # wrong class
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_keypoints_norm_type(
                ia.HeatmapsOnImage(np.zeros((1, 1, 1), dtype=np.float32),
                                   shape=(1, 1, 1)))

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_keypoints_norm_type([[[]]])

        # list of list of list of keypoints,
        # only list of list of keypoints is max
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_keypoints_norm_type(
                [[[ia.Keypoint(x=1, y=2)]]])

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_normalization.py" startline="3088" endline="3170" pcid="2632">
    def test_estimate_bounding_boxes_norm_type(self):
        ntype = normalization.estimate_bounding_boxes_norm_type(None)
        assert ntype == "None"

        for name, dt in zip(["float", "int", "uint"],
                            [np.float32, np.int32, np.uint16]):
            ntype = normalization.estimate_bounding_boxes_norm_type(
                np.zeros((1, 5, 4), dtype=dt))
            assert ntype == "array[%s]" % (name,)

        ntype = normalization.estimate_bounding_boxes_norm_type((1, 2, 3, 4))
        assert ntype == "tuple[number,size=4]"

        ntype = normalization.estimate_bounding_boxes_norm_type(
            ia.BoundingBox(x1=1, y1=2, x2=3, y2=4))
        assert ntype == "BoundingBox"

        ntype = normalization.estimate_bounding_boxes_norm_type(
            ia.BoundingBoxesOnImage(
                [ia.BoundingBox(x1=1, y1=2, x2=3, y2=4)], shape=(1, 1, 3)))
        assert ntype == "BoundingBoxesOnImage"

        ntype = normalization.estimate_bounding_boxes_norm_type([])
        assert ntype == "iterable[empty]"

        for name, dt in zip(["float", "int", "uint"],
                            [np.float32, np.int32, np.uint16]):
            ntype = normalization.estimate_bounding_boxes_norm_type(
                [np.zeros((5, 4), dtype=dt)])
            assert ntype == "iterable-array[%s]" % (name,)

        ntype = normalization.estimate_bounding_boxes_norm_type([(1, 2, 3, 4)])
        assert ntype == "iterable-tuple[number,size=4]"

        ntype = normalization.estimate_bounding_boxes_norm_type([
            ia.BoundingBox(x1=1, y1=2, x2=3, y2=4)])
        assert ntype == "iterable-BoundingBox"

        ntype = normalization.estimate_bounding_boxes_norm_type([
            ia.BoundingBoxesOnImage([ia.BoundingBox(x1=1, y1=2, x2=3, y2=4)],
                                    shape=(1, 1, 3))])
        assert ntype == "iterable-BoundingBoxesOnImage"

        ntype = normalization.estimate_bounding_boxes_norm_type([[]])
        assert ntype == "iterable-iterable[empty]"

        ntype = normalization.estimate_bounding_boxes_norm_type(
            [[(1, 2, 3, 4)]])
        assert ntype == "iterable-iterable-tuple[number,size=4]"

        ntype = normalization.estimate_bounding_boxes_norm_type(
            [[ia.BoundingBox(x1=1, y1=2, x2=3, y2=4)]])
        assert ntype == "iterable-iterable-BoundingBox"

        # --
        # error cases
        # --
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_bounding_boxes_norm_type(1)

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_bounding_boxes_norm_type("foo")

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_bounding_boxes_norm_type([1])

        # wrong class
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_bounding_boxes_norm_type(
                ia.HeatmapsOnImage(
                    np.zeros((1, 1, 1), dtype=np.float32),
                    shape=(1, 1, 1))
            )

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_bounding_boxes_norm_type([[[]]])

        # list of list of list of bounding boxes,
        # only list of list of bounding boxes is max
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_bounding_boxes_norm_type([[[
                ia.BoundingBox(x1=1, y1=2, x2=3, y2=4)]]])

</source>
</class>

<class classid="177" nclones="2" nlines="74" similarity="97">
<source file="systems/imgaug-0.3.0/test/augmentables/test_normalization.py" startline="3171" endline="3285" pcid="2633">
    def test_estimate_polygons_norm_type(self):
        points = [(0, 0), (10, 0), (10, 10)]

        ntype = normalization.estimate_polygons_norm_type(None)
        assert ntype == "None"

        for name, dt in zip(["float", "int", "uint"],
                            [np.float32, np.int32, np.uint16]):
            ntype = normalization.estimate_polygons_norm_type(
                np.zeros((1, 2, 5, 2), dtype=dt)
            )
            assert ntype == "array[%s]" % (name,)

        ntype = normalization.estimate_polygons_norm_type(
            ia.Polygon(points)
        )
        assert ntype == "Polygon"

        ntype = normalization.estimate_polygons_norm_type(
            ia.PolygonsOnImage(
                [ia.Polygon(points)], shape=(1, 1, 3))
        )
        assert ntype == "PolygonsOnImage"

        ntype = normalization.estimate_polygons_norm_type([])
        assert ntype == "iterable[empty]"

        for name, dt in zip(["float", "int", "uint"],
                            [np.float32, np.int32, np.uint16]):
            ntype = normalization.estimate_polygons_norm_type(
                [np.zeros((5, 4), dtype=dt)]
            )
            assert ntype == "iterable-array[%s]" % (name,)

        ntype = normalization.estimate_polygons_norm_type(points)
        assert ntype == "iterable-tuple[number,size=2]"

        ntype = normalization.estimate_polygons_norm_type(
            [ia.Keypoint(x=x, y=y) for x, y in points]
        )
        assert ntype == "iterable-Keypoint"

        ntype = normalization.estimate_polygons_norm_type([ia.Polygon(points)])
        assert ntype == "iterable-Polygon"

        ntype = normalization.estimate_polygons_norm_type(
            [ia.PolygonsOnImage([ia.Polygon(points)],
                                shape=(1, 1, 3))]
        )
        assert ntype == "iterable-PolygonsOnImage"

        ntype = normalization.estimate_polygons_norm_type([[]])
        assert ntype == "iterable-iterable[empty]"

        for name, dt in zip(["float", "int", "uint"],
                            [np.float32, np.int32, np.uint16]):
            ntype = normalization.estimate_polygons_norm_type(
                [[np.zeros((5, 4), dtype=dt)]]
            )
            assert ntype == "iterable-iterable-array[%s]" % (name,)

        ntype = normalization.estimate_polygons_norm_type([points])
        assert ntype == "iterable-iterable-tuple[number,size=2]"

        ntype = normalization.estimate_polygons_norm_type([[
            ia.Keypoint(x=x, y=y) for x, y in points
        ]])
        assert ntype == "iterable-iterable-Keypoint"

        ntype = normalization.estimate_polygons_norm_type(
            [[ia.Polygon(points)]]
        )
        assert ntype == "iterable-iterable-Polygon"

        ntype = normalization.estimate_polygons_norm_type([[[]]])
        assert ntype == "iterable-iterable-iterable[empty]"

        ntype = normalization.estimate_polygons_norm_type([[points]])
        assert ntype == "iterable-iterable-iterable-tuple[number,size=2]"

        ntype = normalization.estimate_polygons_norm_type(
            [[[ia.Keypoint(x=x, y=y) for x, y in points]]]
        )
        assert ntype == "iterable-iterable-iterable-Keypoint"

        # --
        # error cases
        # --
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_polygons_norm_type(1)

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_polygons_norm_type("foo")

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_polygons_norm_type([1])

        # wrong class
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_polygons_norm_type(
                ia.HeatmapsOnImage(
                    np.zeros((1, 1, 1), dtype=np.float32),
                    shape=(1, 1, 1))
            )

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_polygons_norm_type([[[[]]]])

        # list of list of list of polygons,
        # only list of list of polygons is max
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_polygons_norm_type([[[
                ia.Polygon(points)]]]
            )
    
</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_normalization.py" startline="3286" endline="3400" pcid="2634">
    def test_estimate_line_strings_norm_type(self):
        points = [(0, 0), (10, 0), (10, 10)]

        ntype = normalization.estimate_line_strings_norm_type(None)
        assert ntype == "None"

        for name, dt in zip(["float", "int", "uint"],
                            [np.float32, np.int32, np.uint16]):
            ntype = normalization.estimate_line_strings_norm_type(
                np.zeros((1, 2, 5, 2), dtype=dt)
            )
            assert ntype == "array[%s]" % (name,)

        ntype = normalization.estimate_line_strings_norm_type(
            ia.LineString(points)
        )
        assert ntype == "LineString"

        ntype = normalization.estimate_line_strings_norm_type(
            ia.LineStringsOnImage(
                [ia.LineString(points)], shape=(1, 1, 3))
        )
        assert ntype == "LineStringsOnImage"

        ntype = normalization.estimate_line_strings_norm_type([])
        assert ntype == "iterable[empty]"

        for name, dt in zip(["float", "int", "uint"],
                            [np.float32, np.int32, np.uint16]):
            ntype = normalization.estimate_line_strings_norm_type(
                [np.zeros((5, 4), dtype=dt)]
            )
            assert ntype == "iterable-array[%s]" % (name,)

        ntype = normalization.estimate_line_strings_norm_type(points)
        assert ntype == "iterable-tuple[number,size=2]"

        ntype = normalization.estimate_line_strings_norm_type(
            [ia.Keypoint(x=x, y=y) for x, y in points]
        )
        assert ntype == "iterable-Keypoint"

        ntype = normalization.estimate_line_strings_norm_type(
            [ia.LineString(points)])
        assert ntype == "iterable-LineString"

        ntype = normalization.estimate_line_strings_norm_type(
            [ia.LineStringsOnImage([ia.LineString(points)],
                                   shape=(1, 1, 3))]
        )
        assert ntype == "iterable-LineStringsOnImage"

        ntype = normalization.estimate_line_strings_norm_type([[]])
        assert ntype == "iterable-iterable[empty]"

        for name, dt in zip(["float", "int", "uint"],
                            [np.float32, np.int32, np.uint16]):
            ntype = normalization.estimate_line_strings_norm_type(
                [[np.zeros((5, 4), dtype=dt)]]
            )
            assert ntype == "iterable-iterable-array[%s]" % (name,)

        ntype = normalization.estimate_line_strings_norm_type([points])
        assert ntype == "iterable-iterable-tuple[number,size=2]"

        ntype = normalization.estimate_line_strings_norm_type([[
            ia.Keypoint(x=x, y=y) for x, y in points
        ]])
        assert ntype == "iterable-iterable-Keypoint"

        ntype = normalization.estimate_line_strings_norm_type(
            [[ia.LineString(points)]]
        )
        assert ntype == "iterable-iterable-LineString"

        ntype = normalization.estimate_line_strings_norm_type([[[]]])
        assert ntype == "iterable-iterable-iterable[empty]"

        ntype = normalization.estimate_line_strings_norm_type([[points]])
        assert ntype == "iterable-iterable-iterable-tuple[number,size=2]"

        ntype = normalization.estimate_line_strings_norm_type(
            [[[ia.Keypoint(x=x, y=y) for x, y in points]]]
        )
        assert ntype == "iterable-iterable-iterable-Keypoint"

        # --
        # error cases
        # --
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_line_strings_norm_type(1)

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_line_strings_norm_type("foo")

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_line_strings_norm_type([1])

        # wrong class
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_line_strings_norm_type(
                ia.HeatmapsOnImage(
                    np.zeros((1, 1, 1), dtype=np.float32),
                    shape=(1, 1, 1))
            )

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_line_strings_norm_type([[[[]]]])

        # list of list of list of LineStrings,
        # only list of list of LineStrings is max
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_line_strings_norm_type([[[
                ia.LineString(points)]]]
            )
</source>
</class>

<class classid="178" nclones="10" nlines="12" similarity="71">
<source file="systems/imgaug-0.3.0/test/augmentables/test_utils.py" startline="57" endline="72" pcid="2638">
    def test_2_points_0_steps(self):
        points = [
            (0, 0),
            (1, 2)
        ]

        inter = interpolate_points(points, 0)

        assert np.allclose(
            inter,
            np.float32([
                [0, 0],
                [1, 2]
            ])
        )

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_utils.py" startline="231" endline="247" pcid="2649">
    def test_2_points_dist_1_not_closed(self):
        points = [
            (0, 0),
            (0, 2)
        ]

        inter = interpolate_points_by_max_distance(points, 1.0, closed=False)

        assert np.allclose(
            inter,
            np.float32([
                [0, 0],
                [0, 1.0],
                [0, 2]
            ])
        )

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_utils.py" startline="73" endline="90" pcid="2639">
    def test_2_points_1_step(self):
        points = [
            (0, 0),
            (1, 2)
        ]

        inter = interpolate_points(points, 1)

        assert np.allclose(
            inter,
            np.float32([
                [0, 0],
                [0.5, 1.0],
                [1, 2],
                [0.5, 1.0]
            ])
        )

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_utils.py" startline="91" endline="107" pcid="2640">
    def test_2_points_1_step_not_closed(self):
        points = [
            (0, 0),
            (1, 2)
        ]

        inter = interpolate_points(points, 1, closed=False)

        assert np.allclose(
            inter,
            np.float32([
                [0, 0],
                [0.5, 1.0],
                [1, 2]
            ])
        )

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_utils.py" startline="213" endline="230" pcid="2648">
    def test_2_points_dist_1(self):
        points = [
            (0, 0),
            (0, 2)
        ]

        inter = interpolate_points_by_max_distance(points, 1.0)

        assert np.allclose(
            inter,
            np.float32([
                [0, 0],
                [0, 1.0],
                [0, 2],
                [0, 1.0]
            ])
        )

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_utils.py" startline="268" endline="287" pcid="2651">
    def test_3_points_dist_1_not_closed(self):
        points = [
            (0, 0),
            (0, 2),
            (2, 0)
        ]

        inter = interpolate_points_by_max_distance(points, 1.0, closed=False)

        assert np.allclose(
            inter,
            np.float32([
                [0, 0],
                [0, 1.0],
                [0, 2],
                [1.0, 1.0],
                [2, 0]
            ])
        )

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_utils.py" startline="126" endline="146" pcid="2642">
    def test_3_points_1_step(self):
        points = [
            (0, 0),
            (1, 2),
            (0.5, 3)
        ]

        inter = interpolate_points(points, 1)

        assert np.allclose(
            inter,
            np.float32([
                [0, 0],
                [0.5, 1.0],
                [1, 2],
                [0.75, 2.5],
                [0.5, 3],
                [0.25, 1.5]
            ])
        )

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_utils.py" startline="108" endline="125" pcid="2641">
    def test_3_points_0_steps(self):
        points = [
            (0, 0),
            (1, 2),
            (0.5, 3)
        ]

        inter = interpolate_points(points, 0)

        assert np.allclose(
            inter,
            np.float32([
                [0, 0],
                [1, 2],
                [0.5, 3]
            ])
        )

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_utils.py" startline="248" endline="267" pcid="2650">
    def test_3_points_dist_1(self):
        points = [
            (0, 0),
            (0, 2),
            (2, 0)
        ]

        inter = interpolate_points_by_max_distance(points, 1.0)
        assert np.allclose(
            inter,
            np.float32([
                [0, 0],
                [0, 1.0],
                [0, 2],
                [1.0, 1.0],
                [2, 0],
                [1.0, 0]
            ])
        )

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_utils.py" startline="147" endline="166" pcid="2643">
    def test_3_points_1_step_not_closed(self):
        points = [
            (0, 0),
            (1, 2),
            (0.5, 3)
        ]

        inter = interpolate_points(points, 1, closed=False)

        assert np.allclose(
            inter,
            np.float32([
                [0, 0],
                [0.5, 1.0],
                [1, 2],
                [0.75, 2.5],
                [0.5, 3]
            ])
        )

</source>
</class>

<class classid="179" nclones="2" nlines="13" similarity="100">
<source file="systems/imgaug-0.3.0/test/augmentables/test_polys.py" startline="73" endline="91" pcid="2657">
    def test_exterior_is_float32_array(self):
        poly = ia.Polygon(
            np.float32([
                [0.0, 0.0],
                [1.0, 1.0],
                [0.5, 2.5]
            ])
        )

        assert poly.exterior.dtype.name == "float32"
        assert np.allclose(
            poly.exterior,
            np.float32([
                [0.0, 0.0],
                [1.0, 1.0],
                [0.5, 2.5]
            ])
        )

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_polys.py" startline="92" endline="110" pcid="2658">
    def test_exterior_is_float64_array(self):
        poly = ia.Polygon(
            np.float64([
                [0.0, 0.0],
                [1.0, 1.0],
                [0.5, 2.5]
            ])
        )

        assert poly.exterior.dtype.name == "float32"
        assert np.allclose(
            poly.exterior,
            np.float32([
                [0.0, 0.0],
                [1.0, 1.0],
                [0.5, 2.5]
            ])
        )

</source>
</class>

<class classid="180" nclones="3" nlines="12" similarity="100">
<source file="systems/imgaug-0.3.0/test/augmentables/test_polys.py" startline="290" endline="306" pcid="2692">
    def test_project_square_to_image_of_identical_shape(self):
        poly = ia.Polygon([(0, 0), (1, 0), (1, 1), (0, 1)])

        poly_proj = poly.project((1, 1), (1, 1))

        assert poly_proj.exterior.dtype.name == "float32"
        assert poly_proj.exterior.shape == (4, 2)
        assert np.allclose(
            poly_proj.exterior,
            np.float32([
                [0, 0],
                [1, 0],
                [1, 1],
                [0, 1]
            ])
        )

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_polys.py" startline="307" endline="323" pcid="2693">
    def test_project_square_to_image_with_twice_the_height_and_width(self):
        poly = ia.Polygon([(0, 0), (1, 0), (1, 1), (0, 1)])

        poly_proj = poly.project((1, 1), (2, 2))

        assert poly_proj.exterior.dtype.name == "float32"
        assert poly_proj.exterior.shape == (4, 2)
        assert np.allclose(
            poly_proj.exterior,
            np.float32([
                [0, 0],
                [2, 0],
                [2, 2],
                [0, 2]
            ])
        )

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_polys.py" startline="324" endline="340" pcid="2694">
    def test_project_square_to_image_with_twice_the_height_but_same_width(self):
        poly = ia.Polygon([(0, 0), (1, 0), (1, 1), (0, 1)])

        poly_proj = poly.project((1, 1), (2, 1))

        assert poly_proj.exterior.dtype.name == "float32"
        assert poly_proj.exterior.shape == (4, 2)
        assert np.allclose(
            poly_proj.exterior,
            np.float32([
                [0, 0],
                [1, 0],
                [1, 2],
                [0, 2]
            ])
        )

</source>
</class>

<class classid="181" nclones="3" nlines="10" similarity="80">
<source file="systems/imgaug-0.3.0/test/augmentables/test_polys.py" startline="532" endline="544" pcid="2724">
    def test_polygon_with_zero_points_fails(self):
        poly = ia.Polygon([])
        got_exception = False
        try:
            poly.is_out_of_image((1, 1, 3))
        except Exception as exc:
            assert (
                "Cannot determine whether the polygon is inside the "
                "image" in str(exc))
            got_exception = True
        assert got_exception


</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_polys.py" startline="1430" endline="1442" pcid="2791">
    def test_zero_point_polygon_fails(self):
        # zero point polygon
        poly = ia.Polygon([])
        got_exception = False
        try:
            _ = poly.to_shapely_line_string()
        except Exception as exc:
            assert (
                "Conversion to shapely line string requires at least two "
                "points" in str(exc))
            got_exception = True
        assert got_exception

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_polys.py" startline="1417" endline="1429" pcid="2790">
    def test_one_point_polygon_fails(self):
        # one point polygon
        poly = ia.Polygon([(0, 0)])
        got_exception = False
        try:
            _ = poly.to_shapely_line_string()
        except Exception as exc:
            assert (
                "Conversion to shapely line string requires at least two "
                "points" in str(exc))
            got_exception = True
        assert got_exception

</source>
</class>

<class classid="182" nclones="3" nlines="28" similarity="75">
<source file="systems/imgaug-0.3.0/test/augmentables/test_polys.py" startline="837" endline="874" pcid="2749">
    def test_square_polygon(self):
        # simple drawing of square
        poly = ia.Polygon([(2, 2), (8, 2), (8, 8), (2, 8)])
        image = self.image
        image_poly = poly.draw_on_image(image,
                                        color=[32, 128, 32],
                                        color_face=[32, 128, 32],
                                        color_lines=[0, 255, 0],
                                        color_points=[0, 255, 0],
                                        alpha=1.0,
                                        alpha_face=1.0,
                                        alpha_lines=1.0,
                                        alpha_points=0.0,
                                        raise_if_out_of_image=False)
        assert image_poly.dtype.type == np.uint8
        assert image_poly.shape == (10, 10, 3)
        # draw did not change original image (copy=True)
        assert np.sum(image) == 3 * np.sum(np.arange(100))

        for c_idx, value in enumerate([0, 255, 0]):
            # left boundary
            assert np.all(image_poly[2:9, 2:3, c_idx]
                          == np.zeros((7, 1), dtype=np.uint8) + value)
            # right boundary
            assert np.all(image_poly[2:9, 8:9, c_idx]
                          == np.zeros((7, 1), dtype=np.uint8) + value)
            # top boundary
            assert np.all(image_poly[2:3, 2:9, c_idx]
                          == np.zeros((1, 7), dtype=np.uint8) + value)
            # bottom boundary
            assert np.all(image_poly[8:9, 2:9, c_idx]
                          == np.zeros((1, 7), dtype=np.uint8) + value)
        expected = np.tile(
            np.uint8([32, 128, 32]).reshape((1, 1, 3)),
            (5, 5, 1)
        )
        assert np.all(image_poly[3:8, 3:8, :] == expected)

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_polys.py" startline="946" endline="980" pcid="2752">
    def test_square_polygon_half_outside_of_image(self):
        # drawing of poly that is half out of image
        poly = ia.Polygon([(2, 2+5), (8, 2+5), (8, 8+5), (2, 8+5)])
        image = self.image
        image_poly = poly.draw_on_image(image,
                                        color=[32, 128, 32],
                                        color_face=[32, 128, 32],
                                        color_lines=[0, 255, 0],
                                        color_points=[0, 255, 0],
                                        alpha=1.0,
                                        alpha_face=1.0,
                                        alpha_lines=1.0,
                                        alpha_points=0.0,
                                        raise_if_out_of_image=False)
        assert image_poly.dtype.type == np.uint8
        assert image_poly.shape == (10, 10, 3)
        # draw did not change original image (copy=True)
        assert np.sum(image) == 3 * np.sum(np.arange(100))

        for c_idx, value in enumerate([0, 255, 0]):
            # left boundary
            assert np.all(image_poly[2+5:, 2:3, c_idx]
                          == np.zeros((3, 1), dtype=np.uint8) + value)
            # right boundary
            assert np.all(image_poly[2+5:, 8:9, c_idx]
                          == np.zeros((3, 1), dtype=np.uint8) + value)
            # top boundary
            assert np.all(image_poly[2+5:3+5, 2:9, c_idx]
                          == np.zeros((1, 7), dtype=np.uint8) + value)
        expected = np.tile(
            np.uint8([32, 128, 32]).reshape((1, 1, 3)),
            (2, 5, 1)
        )
        assert np.all(image_poly[3+5:, 3:8, :] == expected)

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_polys.py" startline="875" endline="910" pcid="2750">
    def test_square_polygon_use_no_color_subargs(self):
        # simple drawing of square, use only "color" arg
        poly = ia.Polygon([(2, 2), (8, 2), (8, 8), (2, 8)])
        image = self.image
        image_poly = poly.draw_on_image(image,
                                        color=[0, 255, 0],
                                        alpha=1.0,
                                        alpha_face=1.0,
                                        alpha_lines=1.0,
                                        alpha_points=0.0,
                                        raise_if_out_of_image=False)
        assert image_poly.dtype.type == np.uint8
        assert image_poly.shape == (10, 10, 3)
        # draw did not change original image (copy=True)
        assert np.sum(image) == 3 * np.sum(np.arange(100))

        for c_idx, value in enumerate([0, 0.5*255, 0]):
            value = int(np.round(value))
            # left boundary
            assert np.all(image_poly[2:9, 2:3, c_idx]
                          == np.zeros((7, 1), dtype=np.uint8) + value)
            # right boundary
            assert np.all(image_poly[2:9, 8:9, c_idx]
                          == np.zeros((7, 1), dtype=np.uint8) + value)
            # top boundary
            assert np.all(image_poly[2:3, 2:9, c_idx]
                          == np.zeros((1, 7), dtype=np.uint8) + value)
            # bottom boundary
            assert np.all(image_poly[8:9, 2:9, c_idx]
                          == np.zeros((1, 7), dtype=np.uint8) + value)
        expected = np.tile(
            np.uint8([0, 255, 0]).reshape((1, 1, 3)),
            (5, 5, 1)
        )
        assert np.all(image_poly[3:8, 3:8, :] == expected)

</source>
</class>

<class classid="183" nclones="3" nlines="19" similarity="70">
<source file="systems/imgaug-0.3.0/test/augmentables/test_polys.py" startline="981" endline="1003" pcid="2753">
    def test_square_polygon_half_outside_of_image_with_raise_if_ooi(self):
        # drawing of poly that is half out of image, with
        # raise_if_out_of_image=True
        poly = ia.Polygon([(2, 2+5), (8, 2+5), (8, 8+5), (0, 8+5)])
        image = self.image
        got_exception = False
        try:
            _ = poly.draw_on_image(image,
                                   color=[32, 128, 32],
                                   color_face=[32, 128, 32],
                                   color_lines=[0, 255, 0],
                                   color_points=[0, 255, 0],
                                   alpha=1.0,
                                   alpha_face=1.0,
                                   alpha_lines=1.0,
                                   alpha_points=0.0,
                                   raise_if_out_of_image=True)
        except Exception as exc:
            assert "Cannot draw polygon" in str(exc)
            got_exception = True
        # only polygons fully outside of the image plane lead to exceptions
        assert not got_exception

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_polys.py" startline="1021" endline="1043" pcid="2755">
    def test_polygon_fully_outside_of_image_with_raise_if_ooi(self):
        # drawing of poly that is fully out of image,
        # with raise_if_out_of_image=True
        poly = ia.Polygon([(100, 100), (100+10, 100), (100+10, 100+10),
                           (100, 100+10)])
        image = self.image
        got_exception = False
        try:
            _ = poly.draw_on_image(image,
                                   color=[32, 128, 32],
                                   color_face=[32, 128, 32],
                                   color_lines=[0, 255, 0],
                                   color_points=[0, 255, 0],
                                   alpha=1.0,
                                   alpha_face=1.0,
                                   alpha_lines=1.0,
                                   alpha_points=0.0,
                                   raise_if_out_of_image=True)
        except Exception as exc:
            assert "Cannot draw polygon" in str(exc)
            got_exception = True
        assert got_exception

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_polys.py" startline="1004" endline="1020" pcid="2754">
    def test_polygon_fully_outside_of_image(self):
        # drawing of poly that is fully out of image
        poly = ia.Polygon([(100, 100), (100+10, 100), (100+10, 100+10),
                           (100, 100+10)])
        image = self.image
        image_poly = poly.draw_on_image(image,
                                        color=[32, 128, 32],
                                        color_face=[32, 128, 32],
                                        color_lines=[0, 255, 0],
                                        color_points=[0, 255, 0],
                                        alpha=1.0,
                                        alpha_face=1.0,
                                        alpha_lines=1.0,
                                        alpha_points=0.0,
                                        raise_if_out_of_image=False)
        assert np.array_equal(image_poly, image)

</source>
</class>

<class classid="184" nclones="2" nlines="20" similarity="80">
<source file="systems/imgaug-0.3.0/test/augmentables/test_polys.py" startline="1044" endline="1067" pcid="2756">
    def test_only_lines_visible(self):
        # face+points invisible via alpha
        poly = ia.Polygon([(2, 2), (8, 2), (8, 8), (2, 8)])
        image = self.image
        image_poly = poly.draw_on_image(image,
                                        color=[32, 128, 32],
                                        color_face=[32, 128, 32],
                                        color_lines=[0, 255, 0],
                                        color_points=[0, 255, 0],
                                        alpha=1.0,
                                        alpha_face=0.0,
                                        alpha_lines=1.0,
                                        alpha_points=0.0,
                                        raise_if_out_of_image=False)
        assert image_poly.dtype.type == np.uint8
        assert image_poly.shape == (10, 10, 3)
        # draw did not change original image (copy=True)
        assert np.sum(image) == 3 * np.sum(np.arange(100))
        for c_idx, value in enumerate([0, 255, 0]):
            # left boundary
            assert np.all(image_poly[2:9, 2:3, c_idx]
                          == np.zeros((7, 1), dtype=np.uint8) + value)
        assert np.all(image_poly[3:8, 3:8, :] == image[3:8, 3:8, :])

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_polys.py" startline="1068" endline="1090" pcid="2757">
    def test_only_face_visible(self):
        # boundary+points invisible via alpha
        poly = ia.Polygon([(2, 2), (8, 2), (8, 8), (2, 8)])
        image = self.image
        image_poly = poly.draw_on_image(image,
                                        color=[32, 128, 32],
                                        color_face=[32, 128, 32],
                                        color_lines=[0, 255, 0],
                                        color_points=[0, 255, 0],
                                        alpha=1.0,
                                        alpha_face=1.0,
                                        alpha_lines=0.0,
                                        alpha_points=0.0,
                                        raise_if_out_of_image=False)
        assert image_poly.dtype.type == np.uint8
        assert image_poly.shape == (10, 10, 3)
        # draw did not change original image (copy=True)
        assert np.sum(image) == 3 * np.sum(np.arange(100))
        expected = np.tile(
            np.uint8([32, 128, 32]).reshape((1, 1, 3)), (6, 6, 1)
        )
        assert np.all(image_poly[2:8, 2:8, :] == expected)

</source>
</class>

<class classid="185" nclones="2" nlines="24" similarity="76">
<source file="systems/imgaug-0.3.0/test/augmentables/test_polys.py" startline="1091" endline="1118" pcid="2758">
    def test_alpha_is_080(self):
        # alpha=0.8
        poly = ia.Polygon([(2, 2), (8, 2), (8, 8), (2, 8)])
        image = self.image
        image_poly = poly.draw_on_image(image,
                                        color=[32, 128, 32],
                                        color_face=[32, 128, 32],
                                        color_lines=[0, 255, 0],
                                        color_points=[0, 255, 0],
                                        alpha=0.8,
                                        alpha_points=0.0,
                                        raise_if_out_of_image=False)
        assert image_poly.dtype.type == np.uint8
        assert image_poly.shape == (10, 10, 3)
        for c_idx, value in enumerate([0, 255, 0]):
            expected = np.round(
                (1-0.8)*image[2:9, 8:9, c_idx]
                + np.full((7, 1), 0.8*value, dtype=np.float32)
            ).astype(np.uint8)

            # right boundary
            assert np.all(image_poly[2:9, 8:9, c_idx] == expected)
        expected = (0.8 * 0.5) * np.tile(
            np.uint8([32, 128, 32]).reshape((1, 1, 3)), (5, 5, 1)
        ) + (1 - (0.8 * 0.5)) * image[3:8, 3:8, :]
        assert np.all(image_poly[3:8, 3:8, :]
                      == np.round(expected).astype(np.uint8))

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_polys.py" startline="1119" endline="1181" pcid="2759">
    def test_face_and_lines_at_half_visibility(self):
        # alpha of fill and perimeter 0.5
        poly = ia.Polygon([(2, 2), (8, 2), (8, 8), (2, 8)])
        image = self.image
        image_poly = poly.draw_on_image(image,
                                        color=[32, 128, 32],
                                        color_face=[32, 128, 32],
                                        color_lines=[0, 255, 0],
                                        color_points=[0, 255, 0],
                                        alpha=1.0,
                                        alpha_face=0.5,
                                        alpha_lines=0.5,
                                        alpha_points=0.0,
                                        raise_if_out_of_image=False)
        assert image_poly.dtype.type == np.uint8
        assert image_poly.shape == (10, 10, 3)
        for c_idx, value in enumerate([0, 255, 0]):
            expected = np.round(
                0.5*image[2:9, 8:9, c_idx]
                + np.full((7, 1), 0.5*value, dtype=np.float32)
            ).astype(np.uint8)

            # right boundary
            assert np.all(image_poly[2:9, 8:9, c_idx] == expected)

        expected = 0.5 * np.tile(
            np.uint8([32, 128, 32]).reshape((1, 1, 3)), (5, 5, 1)
        ) + 0.5 * image[3:8, 3:8, :]
        assert np.all(image_poly[3:8, 3:8, :]
                      == np.round(expected).astype(np.uint8))

        # copy=False
        # test deactivated as the function currently does not offer a copy
        # argument
        """
        image_cp = np.copy(image)
        poly = ia.Polygon([(2, 2), (8, 2), (8, 8), (2, 8)])
        image_poly = poly.draw_on_image(image_cp,
                                        color_face=[32, 128, 32],
                                        color_boundary=[0, 255, 0],
                                        alpha_face=1.0,
                                        alpha_boundary=1.0,
                                        raise_if_out_of_image=False)
        assert image_poly.dtype.type == np.uint8
        assert image_poly.shape == (10, 10, 3)
        assert np.all(image_cp == image_poly)
        assert not np.all(image_cp == image)
        for c_idx, value in enumerate([0, 255, 0]):
            # left boundary
            assert np.all(image_poly[2:9, 2:3, c_idx]
                          == np.zeros((6, 1, 3), dtype=np.uint8) + value)
            # left boundary
            assert np.all(image_cp[2:9, 2:3, c_idx]
                          == np.zeros((6, 1, 3), dtype=np.uint8) + value)
        expected = np.tile(
            np.uint8([32, 128, 32]).reshape((1, 1, 3)),
            (5, 5, 1)
        )
        assert np.all(image_poly[3:8, 3:8, :] == expected)
        assert np.all(image_cp[3:8, 3:8, :] == expected)
        """


</source>
</class>

<class classid="186" nclones="2" nlines="10" similarity="90">
<source file="systems/imgaug-0.3.0/test/augmentables/test_polys.py" startline="1947" endline="1959" pcid="2867">
    def test_with_one_polygon(self):
        # standard case with one polygon
        poly_oi = ia.PolygonsOnImage(
            [ia.Polygon([(0, 0), (1, 0), (1, 1), (0, 1)])],
            shape=(10, 10, 3)
        )
        assert len(poly_oi.polygons) == 1
        assert np.allclose(
            poly_oi.polygons[0].exterior,
            [(0, 0), (1, 0), (1, 1), (0, 1)],
            rtol=0, atol=1e-4)
        assert poly_oi.shape == (10, 10, 3)

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_polys.py" startline="2083" endline="2096" pcid="2877">
    def test_new_shape_is_2x_width_and_10x_height_of_old_shape(self):
        # 2x increase in width, 10x decrease in height
        poly_oi = ia.PolygonsOnImage(
            [ia.Polygon([(0, 0), (50, 0), (50, 100), (0, 100)])],
            shape=(100, 100, 3)
        )
        poly_oi_proj = poly_oi.on((10, 200, 3))
        assert np.allclose(
            poly_oi_proj.polygons[0].exterior,
            [(0, 0), (100, 0), (100, 10), (0, 10)],
            rtol=0, atol=1e-4)
        assert poly_oi_proj.shape == (10, 200, 3)


</source>
</class>

<class classid="187" nclones="3" nlines="20" similarity="90">
<source file="systems/imgaug-0.3.0/test/augmentables/test_polys.py" startline="1960" endline="1982" pcid="2868">
    def test_with_multiple_polygons(self):
        # standard case with multiple polygons
        poly_oi = ia.PolygonsOnImage(
            [ia.Polygon([(0, 0), (1, 0), (1, 1), (0, 1)]),
             ia.Polygon([(0, 0), (1, 0), (1, 1)]),
             ia.Polygon([(0.5, 0), (1, 0.5), (0.5, 1), (0, 0.5)])],
            shape=(10, 10, 3)
        )
        assert len(poly_oi.polygons) == 3
        assert np.allclose(
            poly_oi.polygons[0].exterior,
            [(0, 0), (1, 0), (1, 1), (0, 1)],
            rtol=0, atol=1e-4)
        assert np.allclose(
            poly_oi.polygons[1].exterior,
            [(0, 0), (1, 0), (1, 1)],
            rtol=0, atol=1e-4)
        assert np.allclose(
            poly_oi.polygons[2].exterior,
            [(0.5, 0), (1, 0.5), (0.5, 1), (0, 0.5)],
            rtol=0, atol=1e-4)
        assert poly_oi.shape == (10, 10, 3)

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_polys.py" startline="2037" endline="2059" pcid="2875">
    def test_new_shape_is_identical_to_old_shape(self):
        # size unchanged
        poly_oi = ia.PolygonsOnImage(
            [ia.Polygon([(0, 0), (1, 0), (1, 1), (0, 1)]),
             ia.Polygon([(0, 0), (1, 0), (1, 1)]),
             ia.Polygon([(0.5, 0), (1, 0.5), (0.5, 1), (0, 0.5)])],
            shape=(1, 1, 3)
        )
        poly_oi_proj = poly_oi.on((1, 1, 3))
        assert np.allclose(
            poly_oi_proj.polygons[0].exterior,
            [(0, 0), (1, 0), (1, 1), (0, 1)],
            rtol=0, atol=1e-4)
        assert np.allclose(
            poly_oi_proj.polygons[1].exterior,
            [(0, 0), (1, 0), (1, 1)],
            rtol=0, atol=1e-4)
        assert np.allclose(
            poly_oi_proj.polygons[2].exterior,
            [(0.5, 0), (1, 0.5), (0.5, 1), (0, 0.5)],
            rtol=0, atol=1e-4)
        assert poly_oi_proj.shape == (1, 1, 3)

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_polys.py" startline="2060" endline="2082" pcid="2876">
    def test_new_shape_is_10x_smaller_than_old_shape(self):
        # 10x decrease in size
        poly_oi = ia.PolygonsOnImage(
            [ia.Polygon([(0, 0), (10, 0), (10, 10), (0, 10)]),
             ia.Polygon([(0, 0), (10, 0), (10, 10)]),
             ia.Polygon([(5, 0), (10, 5), (5, 10), (0, 5)])],
            shape=(10, 10, 3)
        )
        poly_oi_proj = poly_oi.on((1, 1, 3))
        assert np.allclose(
            poly_oi_proj.polygons[0].exterior,
            [(0, 0), (1, 0), (1, 1), (0, 1)],
            rtol=0, atol=1e-4)
        assert np.allclose(
            poly_oi_proj.polygons[1].exterior,
            [(0, 0), (1, 0), (1, 1)],
            rtol=0, atol=1e-4)
        assert np.allclose(
            poly_oi_proj.polygons[2].exterior,
            [(0.5, 0), (1, 0.5), (0.5, 1), (0, 0.5)],
            rtol=0, atol=1e-4)
        assert poly_oi_proj.shape == (1, 1, 3)

</source>
</class>

<class classid="188" nclones="2" nlines="10" similarity="100">
<source file="systems/imgaug-0.3.0/test/augmentables/test_polys.py" startline="2210" endline="2221" pcid="2885">
    def test_with_one_polygon_fully_inside(self):
        # one polygon, fully inside
        poly_oi = ia.PolygonsOnImage(
            [ia.Polygon([(1, 1), (8, 1), (8, 9), (1, 9)])],
            shape=(10, 11, 3))
        poly_oi_clip = poly_oi.clip_out_of_image()
        assert len(poly_oi_clip.polygons) == 1
        for point_search in [(1, 1), (8, 1), (8, 9), (1, 9)]:
            assert self._any_point_close(poly_oi_clip.polygons[0].exterior,
                                         point_search)
        assert poly_oi_clip.shape == (10, 11, 3)

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_polys.py" startline="2222" endline="2233" pcid="2886">
    def test_with_one_polygon_partially_ooi(self):
        # one polygon, partially outside
        poly_oi = ia.PolygonsOnImage(
            [ia.Polygon([(1, 1), (15, 1), (15, 9), (1, 9)])],
            shape=(10, 11, 3))
        poly_oi_clip = poly_oi.clip_out_of_image()
        assert len(poly_oi_clip.polygons) == 1
        for point_search in [(1, 1), (11, 1), (11, 9), (1, 9)]:
            assert self._any_point_close(poly_oi_clip.polygons[0].exterior,
                                         point_search)
        assert poly_oi_clip.shape == (10, 11, 3)

</source>
</class>

<class classid="189" nclones="2" nlines="27" similarity="73">
<source file="systems/imgaug-0.3.0/test/augmentables/test_polys.py" startline="2293" endline="2320" pcid="2891">
    def test_with_two_polygons(self):
        poly_oi = ia.PolygonsOnImage(
            [ia.Polygon([(1, 1), (8, 1), (8, 9), (1, 9)]),
             ia.Polygon([(2, 2), (16, 2), (16, 10), (2, 10)])],
            shape=(10, 11, 3))
        poly_oi_copy = poly_oi.copy()
        assert len(poly_oi_copy.polygons) == 2
        assert np.allclose(poly_oi_copy.polygons[0].exterior,
                           [(1, 1), (8, 1), (8, 9), (1, 9)],
                           rtol=0, atol=1e-4)
        assert np.allclose(poly_oi_copy.polygons[1].exterior,
                           [(2, 2), (16, 2), (16, 10), (2, 10)],
                           rtol=0, atol=1e-4)

        poly_oi_copy.shape = (20, 30, 3)
        assert poly_oi.shape == (10, 11, 3)
        assert poly_oi_copy.shape == (20, 30, 3)

        # make sure that changing the polygons only affects the copy
        poly_oi_copy.polygons = [ia.Polygon([(0, 0), (1, 0), (1, 1)])]
        assert np.allclose(poly_oi.polygons[0].exterior,
                           [(1, 1), (8, 1), (8, 9), (1, 9)],
                           rtol=0, atol=1e-4)
        assert np.allclose(poly_oi_copy.polygons[0].exterior,
                           [(0, 0), (1, 0), (1, 1)],
                           rtol=0, atol=1e-4)


</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_polys.py" startline="2322" endline="2358" pcid="2892">
    def test_with_two_polygons(self):
        poly_oi = ia.PolygonsOnImage(
            [ia.Polygon([(1, 1), (8, 1), (8, 9), (1, 9)]),
             ia.Polygon([(2, 2), (16, 2), (16, 10), (2, 10)])],
            shape=(10, 11, 3))
        poly_oi_copy = poly_oi.deepcopy()
        assert len(poly_oi_copy.polygons) == 2
        assert np.allclose(poly_oi_copy.polygons[0].exterior,
                           [(1, 1), (8, 1), (8, 9), (1, 9)],
                           rtol=0, atol=1e-4)
        assert np.allclose(poly_oi_copy.polygons[1].exterior,
                           [(2, 2), (16, 2), (16, 10), (2, 10)],
                           rtol=0, atol=1e-4)

        poly_oi_copy.shape = (20, 30, 3)
        assert poly_oi.shape == (10, 11, 3)
        assert poly_oi_copy.shape == (20, 30, 3)

        # make sure that changing the polygons only affects the copy
        poly_oi_copy.polygons[0] = ia.Polygon([(0, 0), (1, 0), (1, 1)])
        assert np.allclose(poly_oi.polygons[0].exterior,
                           [(1, 1), (8, 1), (8, 9), (1, 9)],
                           rtol=0, atol=1e-4)
        assert np.allclose(poly_oi_copy.polygons[0].exterior,
                           [(0, 0), (1, 0), (1, 1)],
                           rtol=0, atol=1e-4)

        # make sure that the arrays were also copied
        poly_oi_copy.polygons[1].exterior[0][0] = 100
        assert np.allclose(poly_oi.polygons[1].exterior,
                           [(2, 2), (16, 2), (16, 10), (2, 10)],
                           rtol=0, atol=1e-4)
        assert np.allclose(poly_oi_copy.polygons[1].exterior,
                           [(100, 2), (16, 2), (16, 10), (2, 10)],
                           rtol=0, atol=1e-4)


</source>
</class>

<class classid="190" nclones="3" nlines="14" similarity="80">
<source file="systems/imgaug-0.3.0/test/augmentables/test_polys.py" startline="2439" endline="2454" pcid="2899">
    def test_recover_from_line(self):
        cpr = _ConcavePolygonRecoverer()

        poly = [(0, 0), (1, 0), (2, 0)]
        old_polygon = ia.Polygon(poly)
        poly_concave = cpr.recover_from(poly, old_polygon)
        assert poly_concave.is_valid
        found = [False] * len(poly)
        for i, point in enumerate(poly):
            for point_ext in poly_concave.exterior:
                dist = np.sqrt((point[0] - point_ext[0])**2
                               + (point[1] - point_ext[1])**2)
                if dist < 0.025:
                    found[i] = True
        assert np.all(found)

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_polys.py" startline="2471" endline="2487" pcid="2901">
    def test_recover_from_invalid_polygon(self):
        cpr = _ConcavePolygonRecoverer()
        poly = [(0, 0), (0.5, 0), (0.5, 1.2), (1, 0), (1, 1), (0, 1)]
        old_polygon = ia.Polygon(poly)
        poly_concave = cpr.recover_from(poly, old_polygon)
        assert poly_concave.is_valid
        found = [False] * len(poly)
        for i, point in enumerate(poly):
            for point_ext in poly_concave.exterior:
                dist = np.sqrt(
                    (point[0] - point_ext[0])**2
                    + (point[1] - point_ext[1])**2
                )
                if dist < 0.025:
                    found[i] = True
        assert np.all(found)

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_polys.py" startline="2455" endline="2470" pcid="2900">
    def test_recover_from_polygon_with_duplicate_points(self):
        cpr = _ConcavePolygonRecoverer()

        poly = [(0, 0), (1, 0), (1, 0), (1, 1)]
        old_polygon = ia.Polygon(poly)
        poly_concave = cpr.recover_from(poly, old_polygon)
        assert poly_concave.is_valid
        found = [False] * len(poly)
        for i, point in enumerate(poly):
            for point_ext in poly_concave.exterior:
                dist = np.sqrt((point[0] - point_ext[0])**2
                               + (point[1] - point_ext[1])**2)
                if dist < 0.01:
                    found[i] = True
        assert np.all(found)

</source>
</class>

<class classid="191" nclones="3" nlines="11" similarity="72">
<source file="systems/imgaug-0.3.0/test/augmentables/test_bbs.py" startline="551" endline="564" pcid="2976">
    def test_draw_on_image_bb_outside_of_image(self):
        image = np.zeros((10, 10, 3), dtype=np.uint8)
        bb = ia.BoundingBox(y1=-1, x1=-1, y2=2, x2=2)
        bb_mask = np.zeros(image.shape[0:2], dtype=np.bool)
        bb_mask[2, 0:3] = True
        bb_mask[0:3, 2] = True

        image_bb = bb.draw_on_image(
            image, color=[255, 255, 255], alpha=1.0, size=1, copy=True,
            raise_if_out_of_image=False)

        assert np.all(image_bb[bb_mask] == [255, 255, 255])
        assert np.all(image_bb[~bb_mask] == [0, 0, 0])

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_bbs.py" startline="565" endline="578" pcid="2977">
    def test_draw_on_image_bb_outside_of_image_and_very_small(self):
        image, bb, bb_mask = self._get_standard_draw_on_image_vars()
        bb = ia.BoundingBox(y1=-1, x1=-1, y2=1, x2=1)
        bb_mask = np.zeros(image.shape[0:2], dtype=np.bool)
        bb_mask[0:1+1, 1] = True
        bb_mask[1, 0:1+1] = True

        image_bb = bb.draw_on_image(
            image, color=[255, 255, 255], alpha=1.0, size=1, copy=True,
            raise_if_out_of_image=False)

        assert np.all(image_bb[bb_mask] == [255, 255, 255])
        assert np.all(image_bb[~bb_mask] == [0, 0, 0])

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_bbs.py" startline="579" endline="591" pcid="2978">
    def test_draw_on_image_size_2(self):
        image, bb, _ = self._get_standard_draw_on_image_vars()
        bb_mask = np.zeros(image.shape[0:2], dtype=np.bool)
        bb_mask[0:5, 0:5] = True
        bb_mask[2, 2] = False

        image_bb = bb.draw_on_image(
            image, color=[255, 255, 255], alpha=1.0, size=2, copy=True,
            raise_if_out_of_image=False)

        assert np.all(image_bb[bb_mask] == [255, 255, 255])
        assert np.all(image_bb[~bb_mask] == [0, 0, 0])

</source>
</class>

<class classid="192" nclones="3" nlines="10" similarity="70">
<source file="systems/imgaug-0.3.0/test/augmentables/test_bbs.py" startline="623" endline="635" pcid="2983">
    def test_extract_from_image_bb_partially_out_of_image(self):
        image = iarandom.RNG(1234).integers(0, 255, size=(10, 10, 3))

        bb = ia.BoundingBox(y1=8, y2=11, x1=8, x2=11)
        image_sub = bb.extract_from_image(image)

        image_pad = np.pad(
            image,
            ((0, 1), (0, 1), (0, 0)),
            mode="constant",
            constant_values=0)  # pad at bottom and right each 1px (black)
        assert np.array_equal(image_sub, image_pad[8:11, 8:11, :])

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_bbs.py" startline="649" endline="661" pcid="2985">
    def test_extract_from_image_bb_partially_out_of_image_top_left(self):
        image = iarandom.RNG(1234).integers(0, 255, size=(10, 10, 3))

        bb = ia.BoundingBox(y1=-1, y2=3, x1=-1, x2=4)
        image_sub = bb.extract_from_image(image)

        image_pad = np.pad(
            image,
            ((1, 0), (1, 0), (0, 0)),
            mode="constant",
            constant_values=0)  # pad at top and left each 1px (black)
        assert np.array_equal(image_sub, image_pad[0:4, 0:5, :])

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_bbs.py" startline="636" endline="648" pcid="2984">
    def test_extract_from_image_bb_partially_out_of_image_no_channels(self):
        image = iarandom.RNG(1234).integers(0, 255, size=(10, 10))

        bb = ia.BoundingBox(y1=8, y2=11, x1=8, x2=11)
        image_sub = bb.extract_from_image(image)

        image_pad = np.pad(
            image,
            ((0, 1), (0, 1)),
            mode="constant",
            constant_values=0)  # pad at bottom and right each 1px (black)
        assert np.array_equal(image_sub, image_pad[8:11, 8:11])

</source>
</class>

<class classid="193" nclones="4" nlines="14" similarity="70">
<source file="systems/imgaug-0.3.0/test/augmentables/test_bbs.py" startline="806" endline="821" pcid="3002">
    def test_on_same_height_width(self):
        bb1 = ia.BoundingBox(y1=10, x1=20, y2=30, x2=40)
        bb2 = ia.BoundingBox(y1=15, x1=25, y2=35, x2=45)
        bbsoi = ia.BoundingBoxesOnImage([bb1, bb2], shape=(40, 50, 3))

        bbsoi_projected = bbsoi.on((40, 50))

        assert bbsoi_projected.bounding_boxes[0].y1 == 10
        assert bbsoi_projected.bounding_boxes[0].x1 == 20
        assert bbsoi_projected.bounding_boxes[0].y2 == 30
        assert bbsoi_projected.bounding_boxes[0].x2 == 40
        assert bbsoi_projected.bounding_boxes[1].y1 == 15
        assert bbsoi_projected.bounding_boxes[1].x1 == 25
        assert bbsoi_projected.bounding_boxes[1].y2 == 35
        assert bbsoi_projected.bounding_boxes[1].x2 == 45

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_bbs.py" startline="1031" endline="1051" pcid="3016">
    def test_deepcopy(self):
        bb1 = ia.BoundingBox(y1=10, x1=20, y2=30, x2=40)
        bb2 = ia.BoundingBox(y1=15, x1=25, y2=35, x2=51)
        bbsoi = ia.BoundingBoxesOnImage([bb1, bb2], shape=(40, 50, 3))

        bbsoi_copy = bbsoi.deepcopy()

        assert len(bbsoi.bounding_boxes) == 2
        assert bbsoi_copy.bounding_boxes[0].y1 == 10
        assert bbsoi_copy.bounding_boxes[0].x1 == 20
        assert bbsoi_copy.bounding_boxes[0].y2 == 30
        assert bbsoi_copy.bounding_boxes[0].x2 == 40
        assert bbsoi_copy.bounding_boxes[1].y1 == 15
        assert bbsoi_copy.bounding_boxes[1].x1 == 25
        assert bbsoi_copy.bounding_boxes[1].y2 == 35
        assert bbsoi_copy.bounding_boxes[1].x2 == 51

        bbsoi_copy.bounding_boxes[0].y1 = 0
        assert bbsoi.bounding_boxes[0].y1 == 10
        assert bbsoi_copy.bounding_boxes[0].y1 == 0

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_bbs.py" startline="976" endline="992" pcid="3013">
    def test_clip_out_of_image(self):
        bb1 = ia.BoundingBox(y1=10, x1=20, y2=30, x2=40)
        bb2 = ia.BoundingBox(y1=15, x1=25, y2=35, x2=51)
        bbsoi = ia.BoundingBoxesOnImage([bb1, bb2], shape=(40, 50, 3))

        bbsoi_clip = bbsoi.clip_out_of_image()

        assert len(bbsoi_clip.bounding_boxes) == 2
        assert bbsoi_clip.bounding_boxes[0].y1 == 10
        assert bbsoi_clip.bounding_boxes[0].x1 == 20
        assert bbsoi_clip.bounding_boxes[0].y2 == 30
        assert bbsoi_clip.bounding_boxes[0].x2 == 40
        assert bbsoi_clip.bounding_boxes[1].y1 == 15
        assert bbsoi_clip.bounding_boxes[1].x1 == 25
        assert bbsoi_clip.bounding_boxes[1].y2 == 35
        assert np.isclose(bbsoi_clip.bounding_boxes[1].x2, 50)

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_bbs.py" startline="1010" endline="1030" pcid="3015">
    def test_copy(self):
        bb1 = ia.BoundingBox(y1=10, x1=20, y2=30, x2=40)
        bb2 = ia.BoundingBox(y1=15, x1=25, y2=35, x2=51)
        bbsoi = ia.BoundingBoxesOnImage([bb1, bb2], shape=(40, 50, 3))

        bbsoi_copy = bbsoi.copy()

        assert len(bbsoi.bounding_boxes) == 2
        assert bbsoi_copy.bounding_boxes[0].y1 == 10
        assert bbsoi_copy.bounding_boxes[0].x1 == 20
        assert bbsoi_copy.bounding_boxes[0].y2 == 30
        assert bbsoi_copy.bounding_boxes[0].x2 == 40
        assert bbsoi_copy.bounding_boxes[1].y1 == 15
        assert bbsoi_copy.bounding_boxes[1].x1 == 25
        assert bbsoi_copy.bounding_boxes[1].y2 == 35
        assert bbsoi_copy.bounding_boxes[1].x2 == 51

        bbsoi_copy.bounding_boxes[0].y1 = 0
        assert bbsoi.bounding_boxes[0].y1 == 0
        assert bbsoi_copy.bounding_boxes[0].y1 == 0

</source>
</class>

<class classid="194" nclones="2" nlines="13" similarity="92">
<source file="systems/imgaug-0.3.0/test/augmentables/test_bbs.py" startline="822" endline="837" pcid="3003">
    def test_on_upscaled_by_2(self):
        bb1 = ia.BoundingBox(y1=10, x1=20, y2=30, x2=40)
        bb2 = ia.BoundingBox(y1=15, x1=25, y2=35, x2=45)
        bbsoi = ia.BoundingBoxesOnImage([bb1, bb2], shape=(40, 50, 3))

        bbsoi_projected = bbsoi.on((40*2, 50*2, 3))

        assert bbsoi_projected.bounding_boxes[0].y1 == 10*2
        assert bbsoi_projected.bounding_boxes[0].x1 == 20*2
        assert bbsoi_projected.bounding_boxes[0].y2 == 30*2
        assert bbsoi_projected.bounding_boxes[0].x2 == 40*2
        assert bbsoi_projected.bounding_boxes[1].y1 == 15*2
        assert bbsoi_projected.bounding_boxes[1].x1 == 25*2
        assert bbsoi_projected.bounding_boxes[1].y2 == 35*2
        assert bbsoi_projected.bounding_boxes[1].x2 == 45*2

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_bbs.py" startline="838" endline="853" pcid="3004">
    def test_on_upscaled_by_2_with_shape_given_as_array(self):
        bb1 = ia.BoundingBox(y1=10, x1=20, y2=30, x2=40)
        bb2 = ia.BoundingBox(y1=15, x1=25, y2=35, x2=45)
        bbsoi = ia.BoundingBoxesOnImage([bb1, bb2], shape=(40, 50, 3))

        bbsoi_projected = bbsoi.on(np.zeros((40*2, 50*2, 3), dtype=np.uint8))

        assert bbsoi_projected.bounding_boxes[0].y1 == 10*2
        assert bbsoi_projected.bounding_boxes[0].x1 == 20*2
        assert bbsoi_projected.bounding_boxes[0].y2 == 30*2
        assert bbsoi_projected.bounding_boxes[0].x2 == 40*2
        assert bbsoi_projected.bounding_boxes[1].y1 == 15*2
        assert bbsoi_projected.bounding_boxes[1].x1 == 25*2
        assert bbsoi_projected.bounding_boxes[1].y2 == 35*2
        assert bbsoi_projected.bounding_boxes[1].x2 == 45*2

</source>
</class>

<class classid="195" nclones="2" nlines="15" similarity="86">
<source file="systems/imgaug-0.3.0/test/augmentables/test_bbs.py" startline="854" endline="872" pcid="3005">
    def test_from_xyxy_array_float(self):
        xyxy = np.float32([
            [0.0, 0.0, 1.0, 1.0],
            [1.0, 2.0, 3.0, 4.0]
        ])

        bbsoi = ia.BoundingBoxesOnImage.from_xyxy_array(xyxy, shape=(40, 50, 3))

        assert len(bbsoi.bounding_boxes) == 2
        assert np.allclose(bbsoi.bounding_boxes[0].x1, 0.0)
        assert np.allclose(bbsoi.bounding_boxes[0].y1, 0.0)
        assert np.allclose(bbsoi.bounding_boxes[0].x2, 1.0)
        assert np.allclose(bbsoi.bounding_boxes[0].y2, 1.0)
        assert np.allclose(bbsoi.bounding_boxes[1].x1, 1.0)
        assert np.allclose(bbsoi.bounding_boxes[1].y1, 2.0)
        assert np.allclose(bbsoi.bounding_boxes[1].x2, 3.0)
        assert np.allclose(bbsoi.bounding_boxes[1].y2, 4.0)
        assert bbsoi.shape == (40, 50, 3)

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_bbs.py" startline="873" endline="891" pcid="3006">
    def test_from_xyxy_array_int32(self):
        xyxy = np.int32([
            [0, 0, 1, 1],
            [1, 2, 3, 4]
        ])

        bbsoi = ia.BoundingBoxesOnImage.from_xyxy_array(xyxy, shape=(40, 50, 3))

        assert len(bbsoi.bounding_boxes) == 2
        assert np.allclose(bbsoi.bounding_boxes[0].x1, 0.0)
        assert np.allclose(bbsoi.bounding_boxes[0].y1, 0.0)
        assert np.allclose(bbsoi.bounding_boxes[0].x2, 1.0)
        assert np.allclose(bbsoi.bounding_boxes[0].y2, 1.0)
        assert np.allclose(bbsoi.bounding_boxes[1].x1, 1.0)
        assert np.allclose(bbsoi.bounding_boxes[1].y1, 2.0)
        assert np.allclose(bbsoi.bounding_boxes[1].x2, 3.0)
        assert np.allclose(bbsoi.bounding_boxes[1].y2, 4.0)
        assert bbsoi.shape == (40, 50, 3)

</source>
</class>

<class classid="196" nclones="2" nlines="12" similarity="83">
<source file="systems/imgaug-0.3.0/test/augmentables/test_bbs.py" startline="1052" endline="1066" pcid="3017">
    def test_string_conversion(self):
        bb1 = ia.BoundingBox(y1=10, x1=20, y2=30, x2=40)
        bb2 = ia.BoundingBox(y1=15, x1=25, y2=35, x2=51)
        bbsoi = ia.BoundingBoxesOnImage([bb1, bb2], shape=(40, 50, 3))

        bb1_expected = "BoundingBox(x1=20.0000, y1=10.0000, " \
                       "x2=40.0000, y2=30.0000, label=None)"
        bb2_expected = "BoundingBox(x1=25.0000, y1=15.0000, " \
                       "x2=51.0000, y2=35.0000, label=None)"
        expected = "BoundingBoxesOnImage([%s, %s], shape=(40, 50, 3))" % (
            bb1_expected, bb2_expected)
        assert (
            bbsoi.__repr__()
            == bbsoi.__str__()
            == expected
</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_bbs.py" startline="1067" endline="1080" pcid="3018">
        )

    def test_string_conversion_labels_are_not_none(self):
        bb1 = ia.BoundingBox(y1=10, x1=20, y2=30, x2=40, label="foo")
        bb2 = ia.BoundingBox(y1=15, x1=25, y2=35, x2=51, label="bar")
        bbsoi = ia.BoundingBoxesOnImage([bb1, bb2], shape=(40, 50, 3))

        bb1_expected = "BoundingBox(x1=20.0000, y1=10.0000, " \
                       "x2=40.0000, y2=30.0000, label=foo)"
        bb2_expected = "BoundingBox(x1=25.0000, y1=15.0000, " \
                       "x2=51.0000, y2=35.0000, label=bar)"
        expected = "BoundingBoxesOnImage([%s, %s], shape=(40, 50, 3))" % (
            bb1_expected, bb2_expected)
        assert (
</source>
</class>

<class classid="197" nclones="2" nlines="13" similarity="84">
<source file="systems/imgaug-0.3.0/test/augmentables/test_kps.py" startline="190" endline="205" pcid="3043">
    def test_generate_similar_points_manhattan_1_step_list(self):
        kp = ia.Keypoint(y=4, x=5)
        kps_manhatten = kp.generate_similar_points_manhattan(
            1, 1.0, return_array=False)
        assert len(kps_manhatten) == 5
        expected = [(4, 5), (3, 5), (4, 6), (5, 5), (4, 4)]
        for y, x in expected:
            assert any([
                np.allclose(
                    [y, x],
                    [kp_manhatten.y, kp_manhatten.x]
                )
                for kp_manhatten
                in kps_manhatten
            ])

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_kps.py" startline="206" endline="221" pcid="3044">
    def test_generate_similar_points_manhattan_1_step_array(self):
        kp = ia.Keypoint(y=4, x=5)
        kps_manhatten = kp.generate_similar_points_manhattan(
            1, 1.0, return_array=True)
        assert kps_manhatten.shape == (5, 2)
        expected = [(4, 5), (3, 5), (4, 6), (5, 5), (4, 4)]
        for y, x in expected:
            assert any([
                np.allclose(
                    [y, x],
                    [kp_manhatten_y, kp_manhatten_x]
                )
                for kp_manhatten_x, kp_manhatten_y
                in kps_manhatten
            ])

</source>
</class>

<class classid="198" nclones="9" nlines="13" similarity="75">
<source file="systems/imgaug-0.3.0/test/augmentables/test_kps.py" startline="294" endline="309" pcid="3053">
    def test_draw_on_image(self):
        kps = [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=4)]
        kpi = ia.KeypointsOnImage(keypoints=kps, shape=(5, 5, 3))
        image = np.zeros((5, 5, 3), dtype=np.uint8) + 10

        kps_mask = np.zeros(image.shape[0:2], dtype=np.bool)
        kps_mask[2, 1] = 1
        kps_mask[4, 3] = 1

        image_kps = kpi.draw_on_image(
            image, color=[0, 255, 0], size=1, copy=True,
            raise_if_out_of_image=False)

        assert np.all(image_kps[kps_mask] == [0, 255, 0])
        assert np.all(image_kps[~kps_mask] == [10, 10, 10])

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_kps.py" startline="329" endline="347" pcid="3055">
    def test_draw_on_image_size_3(self):
        kps = [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=4)]
        kpi = ia.KeypointsOnImage(keypoints=kps, shape=(5, 5, 3))
        image = np.zeros((5, 5, 3), dtype=np.uint8) + 10

        kps_mask = np.zeros(image.shape[0:2], dtype=np.bool)
        kps_mask[2, 1] = 1
        kps_mask[4, 3] = 1

        image_kps = kpi.draw_on_image(
            image, color=[0, 255, 0], size=3, copy=True,
            raise_if_out_of_image=False)
        kps_mask_size3 = np.copy(kps_mask)
        kps_mask_size3[2-1:2+1+1, 1-1:1+1+1] = 1
        kps_mask_size3[4-1:4+1+1, 3-1:3+1+1] = 1

        assert np.all(image_kps[kps_mask_size3] == [0, 255, 0])
        assert np.all(image_kps[~kps_mask_size3] == [10, 10, 10])

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_kps.py" startline="400" endline="418" pcid="3059">
    def test_draw_on_image_keypoint_is_outside_of_image(self):
        kps = [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=4)]
        kpi = ia.KeypointsOnImage(
            keypoints=kps + [ia.Keypoint(x=100, y=100)],
            shape=(5, 5, 3)
        )
        image = np.zeros((5, 5, 3), dtype=np.uint8) + 10

        kps_mask = np.zeros(image.shape[0:2], dtype=np.bool)
        kps_mask[2, 1] = 1
        kps_mask[4, 3] = 1

        image_kps = kpi.draw_on_image(
            image, color=[0, 255, 0], size=1, copy=True,
            raise_if_out_of_image=False)

        assert np.all(image_kps[kps_mask] == [0, 255, 0])
        assert np.all(image_kps[~kps_mask] == [10, 10, 10])

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_kps.py" startline="364" endline="379" pcid="3057">
    def test_draw_on_image_single_int_as_color(self):
        kps = [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=4)]
        kpi = ia.KeypointsOnImage(keypoints=kps, shape=(5, 5, 3))
        image = np.zeros((5, 5, 3), dtype=np.uint8) + 10

        kps_mask = np.zeros(image.shape[0:2], dtype=np.bool)
        kps_mask[2, 1] = 1
        kps_mask[4, 3] = 1

        image_kps = kpi.draw_on_image(
            image, color=255, size=1, copy=True,
            raise_if_out_of_image=False)

        assert np.all(image_kps[kps_mask] == [255, 255, 255])
        assert np.all(image_kps[~kps_mask] == [10, 10, 10])

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_kps.py" startline="380" endline="399" pcid="3058">
    def test_draw_on_image_copy_is_false(self):
        kps = [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=4)]
        kpi = ia.KeypointsOnImage(keypoints=kps, shape=(5, 5, 3))
        image = np.zeros((5, 5, 3), dtype=np.uint8) + 10

        kps_mask = np.zeros(image.shape[0:2], dtype=np.bool)
        kps_mask[2, 1] = 1
        kps_mask[4, 3] = 1

        image2 = np.copy(image)
        image_kps = kpi.draw_on_image(
            image2, color=[0, 255, 0], size=1, copy=False,
            raise_if_out_of_image=False)

        assert np.all(image2 == image_kps)
        assert np.all(image_kps[kps_mask] == [0, 255, 0])
        assert np.all(image_kps[~kps_mask] == [10, 10, 10])
        assert np.all(image2[kps_mask] == [0, 255, 0])
        assert np.all(image2[~kps_mask] == [10, 10, 10])

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_kps.py" startline="348" endline="363" pcid="3056">
    def test_draw_on_image_blue_color(self):
        kps = [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=4)]
        kpi = ia.KeypointsOnImage(keypoints=kps, shape=(5, 5, 3))
        image = np.zeros((5, 5, 3), dtype=np.uint8) + 10

        kps_mask = np.zeros(image.shape[0:2], dtype=np.bool)
        kps_mask[2, 1] = 1
        kps_mask[4, 3] = 1

        image_kps = kpi.draw_on_image(
            image, color=[0, 0, 255], size=1, copy=True,
            raise_if_out_of_image=False)

        assert np.all(image_kps[kps_mask] == [0, 0, 255])
        assert np.all(image_kps[~kps_mask] == [10, 10, 10])

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_kps.py" startline="434" endline="451" pcid="3061">
    def test_draw_on_image_one_kp_at_bottom_right_corner(self):
        kps = [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=4)]
        kpi = ia.KeypointsOnImage(
            keypoints=kps + [ia.Keypoint(x=5, y=5)],
            shape=(5, 5, 3))
        image = np.zeros((5, 5, 3), dtype=np.uint8) + 10

        kps_mask = np.zeros(image.shape[0:2], dtype=np.bool)
        kps_mask[2, 1] = 1
        kps_mask[4, 3] = 1

        image_kps = kpi.draw_on_image(
            image, color=[0, 255, 0], size=1, copy=True,
            raise_if_out_of_image=False)

        assert np.all(image_kps[kps_mask] == [0, 255, 0])
        assert np.all(image_kps[~kps_mask] == [10, 10, 10])

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_kps.py" startline="452" endline="469" pcid="3062">
    def test_draw_on_image_one_kp_at_bottom_right_corner_and_raise_true(self):
        kps = [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=4)]
        kpi = ia.KeypointsOnImage(
            keypoints=kps + [ia.Keypoint(x=5, y=5)],
            shape=(5, 5, 3))
        image = np.zeros((5, 5, 3), dtype=np.uint8) + 10

        kps_mask = np.zeros(image.shape[0:2], dtype=np.bool)
        kps_mask[2, 1] = 1
        kps_mask[4, 3] = 1

        with self.assertRaises(Exception) as context:
            _ = kpi.draw_on_image(
                image, color=[0, 255, 0], size=1, copy=True,
                raise_if_out_of_image=True)

        assert "Cannot draw keypoint" in str(context.exception)

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_kps.py" startline="419" endline="433" pcid="3060">
    def test_draw_on_image_keypoint_is_outside_of_image_and_raise_true(self):
        kps = [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=4)]
        kpi = ia.KeypointsOnImage(
            keypoints=kps + [ia.Keypoint(x=100, y=100)],
            shape=(5, 5, 3)
        )
        image = np.zeros((5, 5, 3), dtype=np.uint8) + 10

        with self.assertRaises(Exception) as context:
            _ = kpi.draw_on_image(
                image, color=[0, 255, 0], size=1, copy=True,
                raise_if_out_of_image=True)

        assert "Cannot draw keypoint" in str(context.exception)

</source>
</class>

<class classid="199" nclones="3" nlines="14" similarity="80">
<source file="systems/imgaug-0.3.0/test/augmentables/test_kps.py" startline="598" endline="615" pcid="3074">
    def test_from_keypoint_image_dict_as_if_not_found_thresh_20(self):
        kps_image = np.zeros((5, 5, 2), dtype=np.uint8)
        kps_image[2, 1, 0] = 255
        kps_image[4, 3, 1] = 10

        kpi2 = ia.KeypointsOnImage.from_keypoint_image(
            kps_image,
            if_not_found_coords={"x": -1, "y": -2},
            threshold=20,
            nb_channels=3)

        assert kpi2.shape == (5, 5, 3)
        assert len(kpi2.keypoints) == 2
        assert kpi2.keypoints[0].y == 2.5
        assert kpi2.keypoints[0].x == 1.5
        assert kpi2.keypoints[1].y == -2
        assert kpi2.keypoints[1].x == -1

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_kps.py" startline="616" endline="633" pcid="3075">
    def test_from_keypoint_image_tuple_as_if_not_found_thresh_20(self):
        kps_image = np.zeros((5, 5, 2), dtype=np.uint8)
        kps_image[2, 1, 0] = 255
        kps_image[4, 3, 1] = 10

        kpi2 = ia.KeypointsOnImage.from_keypoint_image(
            kps_image,
            if_not_found_coords=(-1, -2),
            threshold=20,
            nb_channels=3)

        assert kpi2.shape == (5, 5, 3)
        assert len(kpi2.keypoints) == 2
        assert kpi2.keypoints[0].y == 2.5
        assert kpi2.keypoints[0].x == 1.5
        assert kpi2.keypoints[1].y == -2
        assert kpi2.keypoints[1].x == -1

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_kps.py" startline="634" endline="649" pcid="3076">
    def test_from_keypoint_image_none_as_if_not_found_thresh_20(self):
        kps_image = np.zeros((5, 5, 2), dtype=np.uint8)
        kps_image[2, 1, 0] = 255
        kps_image[4, 3, 1] = 10

        kpi2 = ia.KeypointsOnImage.from_keypoint_image(
            kps_image,
            if_not_found_coords=None,
            threshold=20,
            nb_channels=3)

        assert kpi2.shape == (5, 5, 3)
        assert len(kpi2.keypoints) == 1
        assert kpi2.keypoints[0].y == 2.5
        assert kpi2.keypoints[0].x == 1.5

</source>
</class>

<class classid="200" nclones="4" nlines="10" similarity="70">
<source file="systems/imgaug-0.3.0/test/augmentables/test_kps.py" startline="795" endline="807" pcid="3086">
    def test_from_distance_maps_nb_channels_4(self):
        distance_maps = self._get_distance_maps_for_from_dmap_tests()

        kpi = ia.KeypointsOnImage.from_distance_maps(distance_maps,
                                                     nb_channels=4)

        assert len(kpi.keypoints) == 2
        assert kpi.keypoints[0].x == 2
        assert kpi.keypoints[0].y == 2
        assert kpi.keypoints[1].x == 4
        assert kpi.keypoints[1].y == 2
        assert kpi.shape == (4, 5, 4)

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_kps.py" startline="824" endline="836" pcid="3088">
    def test_from_distance_maps_if_not_found_is_tuple_thresh_009(self):
        distance_maps = self._get_distance_maps_for_from_dmap_tests()

        kpi = ia.KeypointsOnImage.from_distance_maps(
            distance_maps, if_not_found_coords=(1, 1), threshold=0.09)

        assert len(kpi.keypoints) == 2
        assert kpi.keypoints[0].x == 2
        assert kpi.keypoints[0].y == 2
        assert kpi.keypoints[1].x == 1
        assert kpi.keypoints[1].y == 1
        assert kpi.shape == (4, 5)

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_kps.py" startline="837" endline="851" pcid="3089">
    def test_from_distance_maps_if_not_found_is_dict_thresh_009(self):
        distance_maps = self._get_distance_maps_for_from_dmap_tests()

        kpi = ia.KeypointsOnImage.from_distance_maps(
            distance_maps,
            if_not_found_coords={"x": 1, "y": 2},
            threshold=0.09)

        assert len(kpi.keypoints) == 2
        assert kpi.keypoints[0].x == 2
        assert kpi.keypoints[0].y == 2
        assert kpi.keypoints[1].x == 1
        assert kpi.keypoints[1].y == 2
        assert kpi.shape == (4, 5)

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_kps.py" startline="852" endline="864" pcid="3090">
    def test_from_distance_maps_if_not_found_is_none_thresh_009(self):
        distance_maps = self._get_distance_maps_for_from_dmap_tests()

        kpi = ia.KeypointsOnImage.from_distance_maps(
            distance_maps,
            if_not_found_coords=None,
            threshold=0.09)

        assert len(kpi.keypoints) == 1
        assert kpi.keypoints[0].x == 2
        assert kpi.keypoints[0].y == 2
        assert kpi.shape == (4, 5)

</source>
</class>

<class classid="201" nclones="2" nlines="13" similarity="100">
<source file="systems/imgaug-0.3.0/test/augmentables/test_kps.py" startline="876" endline="893" pcid="3092">
    def test_copy(self):
        kps = [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=4)]
        kpi = ia.KeypointsOnImage(keypoints=kps, shape=(5, 5, 3))

        kpi2 = kpi.copy()

        assert kpi2.keypoints[0].x == 1
        assert kpi2.keypoints[0].y == 2
        assert kpi2.keypoints[1].x == 3
        assert kpi2.keypoints[1].y == 4

        kps[0].x = 100

        assert kpi2.keypoints[0].x == 100
        assert kpi2.keypoints[0].y == 2
        assert kpi2.keypoints[1].x == 3
        assert kpi2.keypoints[1].y == 4

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_kps.py" startline="894" endline="911" pcid="3093">
    def test_deepcopy(self):
        kps = [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=4)]
        kpi = ia.KeypointsOnImage(keypoints=kps, shape=(5, 5, 3))

        kpi2 = kpi.deepcopy()

        assert kpi2.keypoints[0].x == 1
        assert kpi2.keypoints[0].y == 2
        assert kpi2.keypoints[1].x == 3
        assert kpi2.keypoints[1].y == 4

        kps[0].x = 100

        assert kpi2.keypoints[0].x == 1
        assert kpi2.keypoints[0].y == 2
        assert kpi2.keypoints[1].x == 3
        assert kpi2.keypoints[1].y == 4

</source>
</class>

<class classid="202" nclones="2" nlines="11" similarity="72">
<source file="systems/imgaug-0.3.0/test/augmentables/test_segmaps.py" startline="79" endline="93" pcid="3097">
    def test_bool_arr_2d(self):
        arr = np.array([
            [0, 0, 1],
            [0, 1, 1],
            [1, 1, 1]
        ], dtype=bool).reshape((3, 3))

        segmap = ia.SegmentationMapsOnImage(arr, shape=(3, 3))

        assert segmap.shape == (3, 3)
        assert segmap.arr.dtype.name == "int32"
        assert segmap.arr.shape == (3, 3, 1)
        assert np.array_equal(segmap.arr,
                              arr.reshape((3, 3, 1)).astype(np.int32))

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_segmaps.py" startline="94" endline="109" pcid="3098">
    def test_bool_arr_3d(self):
        arr = np.array([
            [0, 0, 1],
            [0, 1, 1],
            [1, 1, 1]
        ], dtype=bool).reshape((3, 3, 1))
        arr = np.tile(arr, (1, 1, 5))

        segmap = ia.SegmentationMapsOnImage(arr, shape=(3, 3))

        assert segmap.shape == (3, 3)
        assert segmap.arr.dtype.name == "int32"
        assert segmap.arr.shape == (3, 3, 5)
        assert np.array_equal(segmap.arr, arr.astype(np.int32))

    # is this different from the test_bool_* tests?
</source>
</class>

<class classid="203" nclones="2" nlines="12" similarity="100">
<source file="systems/imgaug-0.3.0/test/augmentables/test_segmaps.py" startline="132" endline="145" pcid="3100">
    def test_uint32_fails(self):
        got_exception = False
        try:
            arr = np.array([
                [0, 0, 1],
                [0, 2, 1],
                [1, 3, 1]
            ], dtype=np.uint32)
            _segmap = ia.SegmentationMapsOnImage(arr, shape=(3, 3, 3))
        except Exception as exc:
            assert "only uint8 and uint16 " in str(exc)
            got_exception = True
        assert got_exception

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_segmaps.py" startline="146" endline="159" pcid="3101">
    def test_uint64_fails(self):
        got_exception = False
        try:
            arr = np.array([
                [0, 0, 1],
                [0, 2, 1],
                [1, 3, 1]
            ], dtype=np.int64)
            _segmap = ia.SegmentationMapsOnImage(arr, shape=(3, 3, 3))
        except Exception as exc:
            assert "only int8, int16 and int32 " in str(exc)
            got_exception = True
        assert got_exception

</source>
</class>

<class classid="204" nclones="2" nlines="18" similarity="73">
<source file="systems/imgaug-0.3.0/test/augmentables/test_segmaps.py" startline="201" endline="224" pcid="3104">
    def test_uint_int(self):
        dtypes = ["int8", "int16", "int32", "uint8", "uint16"]
        ndims = [2, 3]

        for dtype, ndim in itertools.product(dtypes, ndims):
            with self.subTest(dtype=dtype, ndim=ndim):
                dtype = np.dtype(dtype)
                shape = (3, 3) if ndim == 2 else (3, 3, 1)
                arr = np.array([
                    [0, 0, 1],
                    [0, 2, 1],
                    [1, 3, 1]
                ], dtype=dtype).reshape(shape)
                segmap = ia.SegmentationMapsOnImage(arr, shape=(3, 3))

                observed = segmap.get_arr()

                assert segmap.arr.dtype.name == "int32"
                assert segmap.arr.ndim == 3
                assert np.array_equal(observed, arr)
                assert observed.dtype.name == dtype.name
                assert observed.ndim == ndim
                assert np.array_equal(observed, arr)

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_segmaps.py" startline="225" endline="246" pcid="3105">
    def test_bool(self):
        ndims = [2, 3]
        for ndim in ndims:
            with self.subTest(ndim=ndim):
                shape = (3, 3) if ndim == 2 else (3, 3, 1)
                arr = np.array([
                    [0, 0, 1],
                    [0, 1, 1],
                    [1, 1, 1]
                ], dtype=bool).reshape(shape)
                segmap = ia.SegmentationMapsOnImage(arr, shape=(3, 3))

                observed = segmap.get_arr()

                assert segmap.arr.dtype.name == "int32"
                assert segmap.arr.ndim == 3
                assert np.array_equal(observed, arr)
                assert observed.dtype.kind == "b"
                assert observed.ndim == ndim
                assert np.array_equal(observed, arr)


</source>
</class>

<class classid="205" nclones="3" nlines="11" similarity="72">
<source file="systems/imgaug-0.3.0/test/augmentables/test_segmaps.py" startline="261" endline="276" pcid="3108">
    def test_with_two_classes(self):
        # simple example with 2 classes
        col0 = self.col(0)
        col1 = self.col(1)
        expected = np.uint8([
            [col0, col1, col1],
            [col0, col1, col1],
            [col0, col1, col1]
        ])

        observed = self.segmap.draw()

        assert isinstance(observed, list)
        assert len(observed) == 1
        assert np.array_equal(observed[0], expected)

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_segmaps.py" startline="431" endline="445" pcid="3117">
    def test_alpha_only_segmap_is_visible(self):
        # only segmap visible
        observed = self.segmap.draw_on_image(self.image, alpha=1.0,
                                             draw_background=True)
        col0 = self.col(0)
        col1 = self.col(1)
        expected = np.uint8([
            [col0, col1, col1],
            [col0, col1, col1],
            [col0, col1, col1]
        ])
        assert isinstance(observed, list)
        assert len(observed) == 1
        assert np.array_equal(observed[0], expected)

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_segmaps.py" startline="335" endline="350" pcid="3111">
    def test_colors(self):
        # custom choice of colors
        col0 = (10, 10, 10)
        col1 = (50, 51, 52)
        expected = np.uint8([
            [col0, col1, col1],
            [col0, col1, col1],
            [col0, col1, col1]
        ])

        observed = self.segmap.draw(colors=[col0, col1])

        assert isinstance(observed, list)
        assert len(observed) == 1
        assert np.array_equal(observed[0], expected)

</source>
</class>

<class classid="206" nclones="2" nlines="22" similarity="73">
<source file="systems/imgaug-0.3.0/test/augmentables/test_segmaps.py" startline="277" endline="304" pcid="3109">
    def test_use_size_arg_to_resize_to_2x(self):
        # same example, with resizing to 2x the size
        double_size_args = [
            (6, 6),
            (2.0, 2.0),
            6,
            2.0
        ]

        col0 = self.col(0)
        col1 = self.col(1)
        expected = np.uint8([
            [col0, col1, col1],
            [col0, col1, col1],
            [col0, col1, col1]
        ])
        expected = ia.imresize_single_image(expected,
                                            (6, 6),
                                            interpolation="nearest")

        for double_size_arg in double_size_args:
            with self.subTest(size=double_size_arg):
                observed = self.segmap.draw(size=double_size_arg)

                assert isinstance(observed, list)
                assert len(observed) == 1
                assert np.array_equal(observed[0], expected)

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_segmaps.py" startline="305" endline="334" pcid="3110">
    def test_use_size_arg_to_keep_at_same_size(self):
        # same example, keeps size at 3x3 via None and (int)3 or (float)1.0
        size_args = [
            None,
            (None, None),
            (3, None),
            (None, 3),
            (1.0, None),
            (None, 1.0)
        ]

        col0 = self.col(0)
        col1 = self.col(1)
        expected = np.uint8([
            [col0, col1, col1],
            [col0, col1, col1],
            [col0, col1, col1]
        ])
        expected = ia.imresize_single_image(expected,
                                            (3, 3),
                                            interpolation="nearest")

        for size_arg in size_args:
            with self.subTest(size=size_arg):
                observed = self.segmap.draw(size=size_arg)

                assert isinstance(observed, list)
                assert len(observed) == 1
                assert np.array_equal(observed[0], expected)

</source>
</class>

<class classid="207" nclones="2" nlines="17" similarity="70">
<source file="systems/imgaug-0.3.0/test/augmentables/test_segmaps.py" startline="514" endline="535" pcid="3120">
    def test_non_binary_alpha_with_draw_background(self):
        # overlay without background drawn
        im = self.image
        segmap = self.segmap

        a1 = 0.7
        a0 = 1.0 - a1

        observed = segmap.draw_on_image(im, alpha=a1, draw_background=False)

        col1 = np.uint8(self.col(1))
        expected = np.float32([
            [im[0, 0, :], a0*im[0, 1, :] + a1*col1, a0*im[0, 2, :] + a1*col1],
            [im[1, 0, :], a0*im[1, 1, :] + a1*col1, a0*im[1, 2, :] + a1*col1],
            [im[2, 0, :], a0*im[2, 1, :] + a1*col1, a0*im[2, 2, :] + a1*col1]
        ])
        d_max = np.max(np.abs(observed[0].astype(np.float32) - expected))
        assert isinstance(observed, list)
        assert len(observed) == 1
        assert observed[0].shape == expected.shape
        assert d_max <= 1.0 + 1e-4

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_segmaps.py" startline="536" endline="559" pcid="3121">
    def test_non_binary_alpha_with_draw_background_and_bg_class_id(self):
        # overlay without background drawn
        # different background class id
        image = self.image
        segmap = self.segmap

        a1 = 0.7
        a0 = 1.0 - a1

        observed = segmap.draw_on_image(image, alpha=a1, draw_background=False,
                                        background_class_id=1)

        col0 = np.uint8(self.col(0))
        expected = np.float32([
            [a0*image[0, 0, :] + a1*col0, image[0, 1, :], image[0, 2, :]],
            [a0*image[1, 0, :] + a1*col0, image[1, 1, :], image[1, 2, :]],
            [a0*image[2, 0, :] + a1*col0, image[2, 1, :], image[2, 2, :]]
        ])
        d_max = np.max(np.abs(observed[0].astype(np.float32) - expected))
        assert isinstance(observed, list)
        assert len(observed) == 1
        assert observed[0].shape == expected.shape
        assert d_max <= 1.0 + 1e-4

</source>
</class>

<class classid="208" nclones="2" nlines="29" similarity="86">
<source file="systems/imgaug-0.3.0/test/augmentables/test_segmaps.py" startline="589" endline="627" pcid="3123">
    def test_resize_segmentation_map_to_image(self):
        # resizing of segmap to image
        arr = np.int32([
            [0, 1, 1]
        ])
        segmap = ia.SegmentationMapsOnImage(arr, shape=(3, 3))

        image = np.uint8([
            [0, 10, 20],
            [30, 40, 50],
            [60, 70, 80]
        ])
        image = np.tile(image[:, :, np.newaxis], (1, 1, 3))

        a1 = 0.7
        a0 = 1.0 - a1

        observed = segmap.draw_on_image(image, alpha=a1, draw_background=True,
                                        resize="segmentation_map")

        col0 = self.col(0)
        col1 = self.col(1)
        expected = np.uint8([
            [col0, col1, col1],
            [col0, col1, col1],
            [col0, col1, col1]
        ])
        expected = a0 * image + a1 * expected
        d_max = np.max(
            np.abs(
                observed[0].astype(np.float32)
                - expected.astype(np.float32)
            )
        )
        assert isinstance(observed, list)
        assert len(observed) == 1
        assert observed[0].shape == expected.shape
        assert d_max <= 1.0 + 1e-4

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_segmaps.py" startline="628" endline="666" pcid="3124">
    def test_resize_image_to_segmentation_map(self):
        # resizing of image to segmap
        arr = np.int32([
            [0, 1, 1],
            [0, 1, 1],
            [0, 1, 1]
        ])
        segmap = ia.SegmentationMapsOnImage(arr, shape=(1, 3))

        image = np.uint8([[0, 10, 20]])
        image = np.tile(image[:, :, np.newaxis], (1, 1, 3))
        image_rs = ia.imresize_single_image(
            image, arr.shape[0:2], interpolation="cubic")

        a1 = 0.7
        a0 = 1.0 - a1

        observed = segmap.draw_on_image(image, alpha=a1, draw_background=True,
                                        resize="image")

        col0 = self.col(0)
        col1 = self.col(1)
        expected = np.uint8([
            [col0, col1, col1],
            [col0, col1, col1],
            [col0, col1, col1]
        ])
        expected = a0 * image_rs + a1 * expected
        d_max = np.max(
            np.abs(
                observed[0].astype(np.float32)
                - expected.astype(np.float32)
            )
        )
        assert isinstance(observed, list)
        assert len(observed) == 1
        assert observed[0].shape == expected.shape
        assert d_max <= 1.0 + 1e-4

</source>
</class>

<class classid="209" nclones="3" nlines="14" similarity="85">
<source file="systems/imgaug-0.3.0/test/augmentables/test_heatmaps.py" startline="190" endline="205" pcid="3156">
    def test_defaults(self):
        heatmaps = self.heatmaps
        heatmaps_padded = heatmaps.pad(top=1, right=2, bottom=3, left=4)
        assert heatmaps_padded.arr_0to1.shape == (2+(1+3), 2+(4+2), 1)
        assert np.allclose(
            heatmaps_padded.arr_0to1[:, :, 0],
            np.float32([
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0],
                [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0],
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
            ])
        )

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_heatmaps.py" startline="223" endline="240" pcid="3158">
    def test_mode_edge(self):
        heatmaps = self.heatmaps
        heatmaps_padded = heatmaps.pad(top=1, right=2, bottom=3, left=4,
                                       mode="edge")
        assert heatmaps_padded.arr_0to1.shape == (2+(1+3), 2+(4+2), 1)
        assert np.allclose(
            heatmaps_padded.arr_0to1[:, :, 0],
            np.float32([
                [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0],
                [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0],
                [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0],
                [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0],
                [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0],
                [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0]
            ])
        )


</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_heatmaps.py" startline="206" endline="222" pcid="3157">
    def test_mode_constant_with_cval_050(self):
        heatmaps = self.heatmaps
        heatmaps_padded = heatmaps.pad(top=1, right=2, bottom=3, left=4,
                                       cval=0.5)
        assert heatmaps_padded.arr_0to1.shape == (2+(1+3), 2+(4+2), 1)
        assert np.allclose(
            heatmaps_padded.arr_0to1[:, :, 0],
            np.float32([
                [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5],
                [0.5, 0.5, 0.5, 0.5, 0.0, 1.0, 0.5, 0.5],
                [0.5, 0.5, 0.5, 0.5, 0.0, 1.0, 0.5, 0.5],
                [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5],
                [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5],
                [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]
            ])
        )

</source>
</class>

<class classid="210" nclones="3" nlines="10" similarity="90">
<source file="systems/imgaug-0.3.0/test/augmentables/test_heatmaps.py" startline="250" endline="262" pcid="3160">
    def test_square_ratio_with_default_mode_and_cval(self):
        heatmaps = self.heatmaps
        heatmaps_padded = heatmaps.pad_to_aspect_ratio(1.0)
        assert heatmaps_padded.arr_0to1.shape == (3, 3, 1)
        assert np.allclose(
            heatmaps_padded.arr_0to1[:, :, 0],
            np.float32([
                [0.0, 0.0, 1.0],
                [0.0, 0.0, 1.0],
                [0.0, 0.0, 0.0]
            ])
        )

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_heatmaps.py" startline="263" endline="275" pcid="3161">
    def test_square_ratio_with_cval_050(self):
        heatmaps = self.heatmaps
        heatmaps_padded = heatmaps.pad_to_aspect_ratio(1.0, cval=0.5)
        assert heatmaps_padded.arr_0to1.shape == (3, 3, 1)
        assert np.allclose(
            heatmaps_padded.arr_0to1[:, :, 0],
            np.float32([
                [0.0, 0.0, 1.0],
                [0.0, 0.0, 1.0],
                [0.5, 0.5, 0.5]
            ])
        )

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_heatmaps.py" startline="276" endline="288" pcid="3162">
    def test_square_ratio_with_edge_mode(self):
        heatmaps = self.heatmaps
        heatmaps_padded = heatmaps.pad_to_aspect_ratio(1.0, mode="edge")
        assert heatmaps_padded.arr_0to1.shape == (3, 3, 1)
        assert np.allclose(
            heatmaps_padded.arr_0to1[:, :, 0],
            np.float32([
                [0.0, 0.0, 1.0],
                [0.0, 0.0, 1.0],
                [0.0, 0.0, 1.0]
            ])
        )

</source>
</class>

<class classid="211" nclones="2" nlines="13" similarity="100">
<source file="systems/imgaug-0.3.0/test/augmentables/test_heatmaps.py" startline="325" endline="341" pcid="3165">
    def test_with_kernel_size_2(self):
        heatmaps_arr = np.float32([
            [0.0, 0.0, 0.5, 1.0],
            [0.0, 0.0, 0.5, 1.0],
            [0.0, 0.0, 0.5, 1.0],
            [0.0, 0.0, 0.5, 1.0]
        ])
        heatmaps = ia.HeatmapsOnImage(heatmaps_arr, shape=(4, 4, 3))

        heatmaps_pooled = heatmaps.avg_pool(2)
        assert heatmaps_pooled.arr_0to1.shape == (2, 2, 1)
        assert np.allclose(
            heatmaps_pooled.arr_0to1[:, :, 0],
            np.float32([[0.0, 0.75],
                        [0.0, 0.75]])
        )

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_heatmaps.py" startline="343" endline="360" pcid="3166">
    def test_with_kernel_size_2(self):
        heatmaps_arr = np.float32([
            [0.0, 0.0, 0.5, 1.0],
            [0.0, 0.0, 0.5, 1.0],
            [0.0, 0.0, 0.5, 1.0],
            [0.0, 0.0, 0.5, 1.0]
        ])
        heatmaps = ia.HeatmapsOnImage(heatmaps_arr, shape=(4, 4, 3))

        heatmaps_pooled = heatmaps.max_pool(2)
        assert heatmaps_pooled.arr_0to1.shape == (2, 2, 1)
        assert np.allclose(
            heatmaps_pooled.arr_0to1[:, :, 0],
            np.float32([[0.0, 1.0],
                        [0.0, 1.0]])
        )


</source>
</class>

<class classid="212" nclones="2" nlines="13" similarity="78">
<source file="systems/imgaug-0.3.0/test/augmentables/test_heatmaps.py" startline="362" endline="380" pcid="3167">
    def test_resize_to_exact_shape(self):
        heatmaps_arr = np.float32([
            [0.0, 1.0]
        ])
        heatmaps = ia.HeatmapsOnImage(heatmaps_arr, shape=(4, 4, 3))

        heatmaps_scaled = heatmaps.resize((4, 4), interpolation="nearest")
        assert heatmaps_scaled.arr_0to1.shape == (4, 4, 1)
        assert heatmaps_scaled.arr_0to1.dtype.name == "float32"
        assert np.allclose(
            heatmaps_scaled.arr_0to1[:, :, 0],
            np.float32([
                [0.0, 0.0, 1.0, 1.0],
                [0.0, 0.0, 1.0, 1.0],
                [0.0, 0.0, 1.0, 1.0],
                [0.0, 0.0, 1.0, 1.0]
            ])
        )

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_heatmaps.py" startline="381" endline="398" pcid="3168">
    def test_resize_to_twice_the_size(self):
        heatmaps_arr = np.float32([
            [0.0, 1.0]
        ])
        heatmaps = ia.HeatmapsOnImage(heatmaps_arr, shape=(4, 4, 3))

        heatmaps_scaled = heatmaps.resize(2.0, interpolation="nearest")
        assert heatmaps_scaled.arr_0to1.shape == (2, 4, 1)
        assert heatmaps_scaled.arr_0to1.dtype.name == "float32"
        assert np.allclose(
            heatmaps_scaled.arr_0to1[:, :, 0],
            np.float32([
                [0.0, 0.0, 1.0, 1.0],
                [0.0, 0.0, 1.0, 1.0]
            ])
        )


</source>
</class>

<class classid="213" nclones="2" nlines="11" similarity="90">
<source file="systems/imgaug-0.3.0/test/augmentables/test_heatmaps.py" startline="400" endline="414" pcid="3169">
    def test_3d_uint8_array(self):
        hm = ia.HeatmapsOnImage.from_uint8(
            np.uint8([
                [0, 128, 255],
                [255, 128, 0]
            ])[..., np.newaxis],
            (20, 30, 3)
        )
        assert hm.shape == (20, 30, 3)
        assert hm.arr_0to1.shape == (2, 3, 1)
        assert np.allclose(hm.arr_0to1[..., 0], np.float32([
            [0, 128/255, 1.0],
            [1.0, 128/255, 0]
        ]))

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_heatmaps.py" startline="415" endline="429" pcid="3170">
    def test_2d_uint8_array(self):
        hm = ia.HeatmapsOnImage.from_uint8(
            np.uint8([
                [0, 128, 255],
                [255, 128, 0]
            ]),
            (20, 30, 3)
        )
        assert hm.shape == (20, 30, 3)
        assert hm.arr_0to1.shape == (2, 3, 1)
        assert np.allclose(hm.arr_0to1[..., 0], np.float32([
            [0, 128/255, 1.0],
            [1.0, 128/255, 0]
        ]))

</source>
</class>

<class classid="214" nclones="3" nlines="10" similarity="70">
<source file="systems/imgaug-0.3.0/test/augmentables/test_heatmaps.py" startline="452" endline="467" pcid="3172">
    def test_increase_max_value(self):
        # (0.0, 1.0) -> (0.0, 2.0)
        arr = np.float32([
            [0.0, 0.5, 1.0],
            [1.0, 0.5, 0.0]
        ])

        observed = ia.HeatmapsOnImage.change_normalization(
            arr, (0.0, 1.0), (0.0, 2.0))

        expected = np.float32([
            [0.0, 1.0, 2.0],
            [2.0, 1.0, 0.0]
        ])
        assert np.allclose(observed, expected)

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_heatmaps.py" startline="484" endline="499" pcid="3174">
    def test_increase_min_and_max_value__non_standard_source(self):
        # (-1.0, 1.0) -> (1.0, 3.0)
        arr = np.float32([
            [-1.0, 0.0, 1.0],
            [1.0, 0.0, -1.0]
        ])

        observed = ia.HeatmapsOnImage.change_normalization(
            arr, (-1.0, 1.0), (1.0, 3.0))

        expected = np.float32([
            [1.0, 2.0, 3.0],
            [3.0, 2.0, 1.0]
        ])
        assert np.allclose(observed, expected)

</source>
<source file="systems/imgaug-0.3.0/test/augmentables/test_heatmaps.py" startline="468" endline="483" pcid="3173">
    def test_decrease_min_and_max_value(self):
        # (0.0, 1.0) -> (-1.0, 0.0)
        arr = np.float32([
            [0.0, 0.5, 1.0],
            [1.0, 0.5, 0.0]
        ])

        observed = ia.HeatmapsOnImage.change_normalization(
            arr, (0.0, 1.0), (-1.0, 0.0))

        expected = np.float32([
            [-1.0, -0.5, 0.0],
            [0.0, -0.5, -1.0]
        ])
        assert np.allclose(observed, expected)

</source>
</class>

<class classid="215" nclones="2" nlines="18" similarity="83">
<source file="systems/imgaug-0.3.0/test/test_dtypes.py" startline="277" endline="299" pcid="3220">
    def test_many_items_list_input_single_dtype(self):
        arrs = [
            np.array([0.0, 0.1, 0.9, 127.0+0.0, -128.0-0.0], dtype=np.float32),
            np.array([0.0, 0.1, 0.9, 127.0+1.0, -128.0-1.0], dtype=np.float32)
        ]
        dtypes = np.int8

        observed = iadt.restore_dtypes_(
            [np.copy(arr) for arr in arrs],
            dtypes,
            clip=False,
            round=False)

        expected = [
            np.array([0, 0, 0, 127, -128], dtype=np.int8),
            np.array([0, 0, 0, -128+1-1, 127-1+1], dtype=np.int8)
        ]
        assert len(observed) == 2
        assert observed[0].dtype.name == "int8"
        assert observed[1].dtype.name == "int8"
        assert np.array_equal(observed[0], expected[0])
        assert np.array_equal(observed[1], expected[1])

</source>
<source file="systems/imgaug-0.3.0/test/test_dtypes.py" startline="300" endline="322" pcid="3221">
    def test_many_items_list_input_many_dtypes(self):
        arrs = [
            np.array([0.0, 0.1, 0.9, 127.0+1.0, -128.0-1.0], dtype=np.float32),
            np.array([0.0, 0.1, 0.9, 127.0+1.0, -128.0-1.0], dtype=np.float32)
        ]
        dtypes = [np.int8, np.int16]

        observed = iadt.restore_dtypes_(
            [np.copy(arr) for arr in arrs],
            dtypes,
            clip=False,
            round=False)

        expected = [
            np.array([0, 0, 0, -128+1-1, 127-1+1], dtype=np.int8),
            np.array([0, 0, 0, 127+1, -128-1], dtype=np.int16)
        ]
        assert len(observed) == 2
        assert observed[0].dtype.name == "int8"
        assert observed[1].dtype.name == "int16"
        assert np.array_equal(observed[0], expected[0])
        assert np.array_equal(observed[1], expected[1])

</source>
</class>

<class classid="216" nclones="2" nlines="13" similarity="92">
<source file="systems/imgaug-0.3.0/test/test_dtypes.py" startline="493" endline="508" pcid="3235">
    def test_with_lists_of_identical_dtypes(self):
        dts = [
            np.int8, np.int16, np.int32, np.int64,
            np.uint8, np.uint16, np.uint32, np.uint64,
            np.float16, np.float32, np.float64,
            np.bool_
        ]

        for dt in dts:
            dt = np.dtype(dt)
            for length in [1, 2, 3]:
                with self.subTest(dtype=dt.name, length=length):
                    inputs = [dt for _ in range(length)]
                    promoted_dt = iadt.get_minimal_dtype(inputs)
                    assert promoted_dt.name == dt.name

</source>
<source file="systems/imgaug-0.3.0/test/test_dtypes.py" startline="509" endline="525" pcid="3236">
    def test_with_lists_of_identical_dtype_arrays(self):
        dts = [
            np.int8, np.int16, np.int32, np.int64,
            np.uint8, np.uint16, np.uint32, np.uint64,
            np.float16, np.float32, np.float64,
            np.bool_
        ]

        for dt in dts:
            dt = np.dtype(dt)
            for length in [1, 2, 3]:
                with self.subTest(dtype=dt.name, length=length):
                    inputs = [np.zeros((1, 1, 3), dtype=dt)
                              for _ in range(length)]
                    promoted_dt = iadt.get_minimal_dtype(inputs)
                    assert promoted_dt.name == dt.name

</source>
</class>

<class classid="217" nclones="2" nlines="14" similarity="71">
<source file="systems/imgaug-0.3.0/test/test_dtypes.py" startline="589" endline="605" pcid="3240">
    def test_calls_subfunctions_dtypes_set(self, mock_cd, mock_gmd):
        mock_gmd.return_value = np.dtype("int16")
        mock_cd.return_value = "foo"
        arrays = [np.zeros((1,), dtype=np.int8)]

        observed = iadt.promote_array_dtypes_(
            arrays,
            dtypes=["float32"])

        assert mock_gmd.call_count == 1
        assert mock_cd.call_count == 1
        # call 0, args, arg 0, dtype 0
        assert mock_gmd.call_args_list[0][0][0][0] == "float32"
        assert mock_gmd.call_args_list[0][1]["increase_itemsize_factor"] == 1
        assert mock_cd.call_args_list[0][0][0] is arrays
        assert observed == "foo"

</source>
<source file="systems/imgaug-0.3.0/test/test_dtypes.py" startline="608" endline="625" pcid="3241">
    def test_calls_subfunctions_increase_itemsize_factor_set(self, mock_cd,
                                                             mock_gmd):
        mock_gmd.return_value = np.dtype("int16")
        mock_cd.return_value = "foo"
        arrays = [np.zeros((1,), dtype=np.int8)]

        observed = iadt.promote_array_dtypes_(
            arrays,
            increase_itemsize_factor=2)

        assert mock_gmd.call_count == 1
        assert mock_cd.call_count == 1
        # call 0, args, arg 0, dtype 0
        assert mock_gmd.call_args_list[0][0][0][0].name == "int8"
        assert mock_gmd.call_args_list[0][1]["increase_itemsize_factor"] == 2
        assert mock_cd.call_args_list[0][0][0] is arrays
        assert observed == "foo"

</source>
</class>

<class classid="218" nclones="10" nlines="11" similarity="72">
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="1013" endline="1028" pcid="3422">
        )

    def test_value_is_list(self):
        param = iap.Choice([0, 1, 2])

        sample = param.draw_sample()
        samples = param.draw_samples((10, 5))

        assert sample.shape == tuple()
        assert samples.shape == (10, 5)
        assert sample in [0, 1, 2]
        assert np.all(
            np.logical_or(
                np.logical_or(samples == 0, samples == 1),
                samples == 2
            )
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="1219" endline="1234" pcid="3438">
            )

    def test_lower_bound_is_negative(self):
        param = iap.DiscreteUniform(-1, 1)

        sample = param.draw_sample()
        samples = param.draw_samples((10, 5))

        assert sample.shape == tuple()
        assert samples.shape == (10, 5)
        assert sample in [-1, 0, 1]
        assert np.all(
            np.logical_or(
                np.logical_or(samples == -1, samples == 0),
                samples == 1
            )
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="1189" endline="1204" pcid="3436">
        )

    def test_bounds_are_ints(self):
        param = iap.DiscreteUniform(0, 2)

        sample = param.draw_sample()
        samples = param.draw_samples((10, 5))

        assert sample.shape == tuple()
        assert samples.shape == (10, 5)
        assert sample in [0, 1, 2]
        assert np.all(
            np.logical_or(
                np.logical_or(samples == 0, samples == 1),
                samples == 2
            )
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="1900" endline="1915" pcid="3493">
        )

    def test_arguments_are_integers(self):
        param = iap.Uniform(-1, 1)

        sample = param.draw_sample()
        samples = param.draw_samples((10, 5))

        assert sample.shape == tuple()
        assert samples.shape == (10, 5)
        assert -1.0 - _eps(sample) < sample < 1.0 + _eps(sample)
        assert np.all(
            np.logical_and(
                -1.0 - _eps(samples) < samples,
                samples < 1.0 + _eps(samples)
            )
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="1253" endline="1270" pcid="3440">
        )

    def test_lower_and_upper_bound_have_wrong_order(self):
        param = iap.DiscreteUniform(1, -1)

        sample = param.draw_sample()
        samples = param.draw_samples((10, 5))

        assert sample.shape == tuple()
        assert samples.shape == (10, 5)
        assert sample in [-1, 0, 1]
        assert np.all(
            np.logical_or(
                np.logical_or(
                    samples == -1, samples == 0
                ),
                samples == 1
            )
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="1235" endline="1252" pcid="3439">
        )

    def test_bounds_are_floats(self):
        param = iap.DiscreteUniform(-1.2, 1.2)

        sample = param.draw_sample()
        samples = param.draw_samples((10, 5))

        assert sample.shape == tuple()
        assert samples.shape == (10, 5)
        assert sample in [-1, 0, 1]
        assert np.all(
            np.logical_or(
                np.logical_or(
                    samples == -1, samples == 0
                ),
                samples == 1
            )
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="1916" endline="1931" pcid="3494">
        )

    def test_arguments_are_identical(self):
        param = iap.Uniform(1, 1)

        sample = param.draw_sample()
        samples = param.draw_samples((10, 5))

        assert sample.shape == tuple()
        assert samples.shape == (10, 5)
        assert 1.0 - _eps(sample) < sample < 1.0 + _eps(sample)
        assert np.all(
            np.logical_and(
                1.0 - _eps(samples) < samples,
                samples < 1.0 + _eps(samples)
            )
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="1884" endline="1899" pcid="3492">
        )

    def test_wrong_argument_order(self):
        param = iap.Uniform(1.0, -1.0)

        sample = param.draw_sample()
        samples = param.draw_samples((10, 5))

        assert sample.shape == tuple()
        assert samples.shape == (10, 5)
        assert -1.0 - _eps(sample) < sample < 1.0 + _eps(sample)
        assert np.all(
            np.logical_and(
                -1.0 - _eps(samples) < samples,
                samples < 1.0 + _eps(samples)
            )
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="1868" endline="1883" pcid="3491">
            )

    def test_negative_value(self):
        param = iap.Uniform(-1.0, 1.0)

        sample = param.draw_sample()
        samples = param.draw_samples((10, 5))

        assert sample.shape == tuple()
        assert samples.shape == (10, 5)
        assert -1.0 - _eps(sample) < sample < 1.0 + _eps(sample)
        assert np.all(
            np.logical_and(
                -1.0 - _eps(samples) < samples,
                samples < 1.0 + _eps(samples)
            )
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="2504" endline="2519" pcid="3538">
        assert np.all(samples == -1)

    def test_value_is_within_bounds_and_float(self):
        param = iap.Clip(iap.Deterministic(0.5), -1, 1)

        sample = param.draw_sample()
        samples = param.draw_samples((10, 5))

        assert sample.shape == tuple()
        assert samples.shape == (10, 5)
        assert 0.5 - _eps(sample) < sample < 0.5 + _eps(sample)
        assert np.all(
            np.logical_and(
                0.5 - _eps(sample) <= samples,
                samples <= 0.5 + _eps(sample)
            )
</source>
</class>

<class classid="219" nclones="2" nlines="11" similarity="90">
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="1029" endline="1042" pcid="3423">
        )

    def test_sampled_values_match_expected_counts(self):
        param = iap.Choice([0, 1, 2])

        samples = param.draw_samples((10000,))
        expected = 10000/3
        expected_tolerance = expected * 0.05
        for v in [0, 1, 2]:
            count = np.sum(samples == v)
            assert (
                expected - expected_tolerance
                < count <
                expected + expected_tolerance
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="1205" endline="1218" pcid="3437">
        )

    def test_samples_match_expected_counts(self):
        param = iap.DiscreteUniform(0, 2)

        samples = param.draw_samples((10000,))
        expected = 10000/3
        expected_tolerance = expected * 0.05
        for v in [0, 1, 2]:
            count = np.sum(samples == v)
            assert (
                expected - expected_tolerance
                < count <
                expected + expected_tolerance
</source>
</class>

<class classid="220" nclones="2" nlines="12" similarity="83">
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="1117" endline="1131" pcid="3428">
        assert all([count in [0, 1] for count in seen])

    def test_non_uniform_probabilities_over_elements(self):
        param = iap.Choice([0, 1], p=[0.25, 0.75])

        samples = param.draw_samples((10000,))
        unique, counts = np.unique(samples, return_counts=True)

        assert len(unique) == 2
        for val, count in zip(unique, counts):
            if val == 0:
                assert 2500 - 500 < count < 2500 + 500
            elif val == 1:
                assert 7500 - 500 < count < 7500 + 500
            else:
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="1132" endline="1146" pcid="3429">
                assert False

    def test_list_contains_stochastic_parameter(self):
        param = iap.Choice([iap.Choice([0, 1]), 2])

        samples = param.draw_samples((10000,))
        unique, counts = np.unique(samples, return_counts=True)

        assert len(unique) == 3
        for val, count in zip(unique, counts):
            if val in [0, 1]:
                assert 2500 - 500 < count < 2500 + 500
            elif val == 2:
                assert 5000 - 500 < count < 5000 + 500
            else:
</source>
</class>

<class classid="221" nclones="2" nlines="21" similarity="95">
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="1355" endline="1377" pcid="3451">
        assert sample.shape == tuple()

    def test_via_comparison_to_np_normal(self):
        param = iap.Normal(0, 1)

        samples = param.draw_samples((100, 1000))
        samples_direct = iarandom.RNG(1234).normal(loc=0, scale=1,
                                                            size=(100, 1000))
        samples = np.clip(samples, -1, 1)
        samples_direct = np.clip(samples_direct, -1, 1)
        nb_bins = 10
        hist, _ = np.histogram(samples, bins=nb_bins, range=(-1.0, 1.0),
                               density=False)
        hist_direct, _ = np.histogram(samples_direct, bins=nb_bins,
                                      range=(-1.0, 1.0), density=False)
        tolerance = 0.05
        for nb_samples, nb_samples_direct in zip(hist, hist_direct):
            density = nb_samples / samples.size
            density_direct = nb_samples_direct / samples_direct.size
            assert (
                density_direct - tolerance
                < density <
                density_direct + tolerance
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="1539" endline="1564" pcid="3467">
        assert sample.shape == tuple()

    def test_via_comparison_to_np_laplace(self):
        param = iap.Laplace(0, 1)

        samples = param.draw_samples((100, 1000))
        samples_direct = iarandom.RNG(1234).laplace(loc=0, scale=1,
                                                             size=(100, 1000))

        assert samples.shape == (100, 1000)

        samples = np.clip(samples, -1, 1)
        samples_direct = np.clip(samples_direct, -1, 1)
        nb_bins = 10
        hist, _ = np.histogram(samples, bins=nb_bins, range=(-1.0, 1.0),
                               density=False)
        hist_direct, _ = np.histogram(samples_direct, bins=nb_bins,
                                      range=(-1.0, 1.0), density=False)
        tolerance = 0.05
        for nb_samples, nb_samples_direct in zip(hist, hist_direct):
            density = nb_samples / samples.size
            density_direct = nb_samples_direct / samples_direct.size
            assert (
                density_direct - tolerance
                < density <
                density_direct + tolerance
</source>
</class>

<class classid="222" nclones="3" nlines="14" similarity="78">
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="1378" endline="1394" pcid="3452">
            )

    def test_loc_is_stochastic_parameter(self):
        param = iap.Normal(iap.Choice([-100, 100]), 1)

        seen = [0, 0]
        for _ in sm.xrange(1000):
            samples = param.draw_samples((100,))
            exp = np.mean(samples)

            if -100 - 10 < exp < -100 + 10:
                seen[0] += 1
            elif 100 - 10 < exp < 100 + 10:
                seen[1] += 1
            else:
                assert False
        assert 500 - 100 < seen[0] < 500 + 100
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="1565" endline="1582" pcid="3468">
            )

    def test_loc_is_stochastic_parameter(self):
        param = iap.Laplace(iap.Choice([-100, 100]), 1)

        seen = [0, 0]
        for _ in sm.xrange(1000):
            samples = param.draw_samples((100,))
            exp = np.mean(samples)

            if -100 - 10 < exp < -100 + 10:
                seen[0] += 1
            elif 100 - 10 < exp < 100 + 10:
                seen[1] += 1
            else:
                assert False

        assert 500 - 100 < seen[0] < 500 + 100
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="1661" endline="1678" pcid="3476">
            )

    def test_df_is_stochastic_parameter(self):
        param = iap.ChiSquare(iap.Choice([1, 10]))

        seen = [0, 0]
        for _ in sm.xrange(1000):
            samples = param.draw_samples((100,))
            exp = np.mean(samples)

            if 1 - 1.0 < exp < 1 + 1.0:
                seen[0] += 1
            elif 10 - 4.0 < exp < 10 + 4.0:
                seen[1] += 1
            else:
                assert False

        assert 500 - 100 < seen[0] < 500 + 100
</source>
</class>

<class classid="223" nclones="2" nlines="22" similarity="100">
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="1634" endline="1660" pcid="3475">
        assert 0 <= sample

    def test_via_comparison_to_np_chisquare(self):
        param = iap.ChiSquare(1)

        samples = param.draw_samples((100, 1000))
        samples_direct = iarandom.RNG(1234).chisquare(df=1,
                                                               size=(100, 1000))

        assert samples.shape == (100, 1000)
        assert np.all(0 <= samples)

        samples = np.clip(samples, 0, 3)
        samples_direct = np.clip(samples_direct, 0, 3)
        nb_bins = 10
        hist, _ = np.histogram(samples, bins=nb_bins, range=(0, 3.0),
                               density=False)
        hist_direct, _ = np.histogram(samples_direct, bins=nb_bins,
                                      range=(0, 3.0), density=False)
        tolerance = 0.05
        for nb_samples, nb_samples_direct in zip(hist, hist_direct):
            density = nb_samples / samples.size
            density_direct = nb_samples_direct / samples_direct.size
            assert (
                density_direct - tolerance
                < density <
                density_direct + tolerance
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="1722" endline="1748" pcid="3482">
        assert 0 <= sample

    def test_via_comparison_to_np_weibull(self):
        param = iap.Weibull(1)

        samples = param.draw_samples((100, 1000))
        samples_direct = iarandom.RNG(1234).weibull(a=1,
                                                             size=(100, 1000))

        assert samples.shape == (100, 1000)
        assert np.all(0 <= samples)

        samples = np.clip(samples, 0, 2)
        samples_direct = np.clip(samples_direct, 0, 2)
        nb_bins = 10
        hist, _ = np.histogram(samples, bins=nb_bins, range=(0, 2.0),
                               density=False)
        hist_direct, _ = np.histogram(samples_direct, bins=nb_bins,
                                      range=(0, 2.0), density=False)
        tolerance = 0.05
        for nb_samples, nb_samples_direct in zip(hist, hist_direct):
            density = nb_samples / samples.size
            density_direct = nb_samples_direct / samples_direct.size
            assert (
                density_direct - tolerance
                < density <
                density_direct + tolerance
</source>
</class>

<class classid="224" nclones="2" nlines="12" similarity="83">
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="2123" endline="2138" pcid="3511">
                    sample1, sample2, rtol=0, atol=_eps(sample1))

    def test_draw_samples_int(self):
        values = [-100, -54, -1, 0, 1, 54, 100]
        shapes = [10, 10, (5, 3), (5, 3), (4, 5, 3), (4, 5, 3)]
        for value, shape in itertools.product(values, shapes):
            with self.subTest(value=value, shape=shape):
                param = iap.Deterministic(value)

                samples = param.draw_samples(shape)
                shape_expected = (
                    shape
                    if isinstance(shape, tuple)
                    else tuple([shape]))

                assert samples.shape == shape_expected
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="2139" endline="2154" pcid="3512">
                assert np.all(samples == value)

    def test_draw_samples_float(self):
        values = [-100.0, -54.3, -1.0, 0.1, 0.0, 0.1, 1.0, 54.4, 100.0]
        shapes = [10, 10, (5, 3), (5, 3), (4, 5, 3), (4, 5, 3)]
        for value, shape in itertools.product(values, shapes):
            with self.subTest(value=value, shape=shape):
                param = iap.Deterministic(value)

                samples = param.draw_samples(shape)
                shape_expected = (
                    shape
                    if isinstance(shape, tuple)
                    else tuple([shape]))

                assert samples.shape == shape_expected
</source>
</class>

<class classid="225" nclones="6" nlines="20" similarity="81">
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="2251" endline="2275" pcid="3522">
        assert 1 in uq

    def test_different_size_px_arguments(self):
        # different sizes in px
        param1 = iap.FromLowerResolution(iap.Binomial(0.5), size_px=2)
        param2 = iap.FromLowerResolution(iap.Binomial(0.5), size_px=16)

        seen_components = [0, 0]
        seen_pixels = [0, 0]
        for _ in sm.xrange(100):
            samples1 = param1.draw_samples((16, 16, 1))
            samples2 = param2.draw_samples((16, 16, 1))
            _, num1 = skimage.morphology.label(samples1, neighbors=4,
                                               background=0, return_num=True)
            _, num2 = skimage.morphology.label(samples2, neighbors=4,
                                               background=0, return_num=True)
            seen_components[0] += num1
            seen_components[1] += num2
            seen_pixels[0] += np.sum(samples1 == 1)
            seen_pixels[1] += np.sum(samples2 == 1)

        assert seen_components[0] < seen_components[1]
        assert (
            seen_pixels[0] / seen_components[0]
            > seen_pixels[1] / seen_components[1]
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="2335" endline="2360" pcid="3526">
        self.assertTrue("Expected " in str(context.exception))

    def test_min_size(self):
        # min_size
        param1 = iap.FromLowerResolution(iap.Binomial(0.5), size_px=2)
        param2 = iap.FromLowerResolution(iap.Binomial(0.5), size_px=1,
                                         min_size=16)

        seen_components = [0, 0]
        seen_pixels = [0, 0]
        for _ in sm.xrange(100):
            samples1 = param1.draw_samples((16, 16, 1))
            samples2 = param2.draw_samples((16, 16, 1))
            _, num1 = skimage.morphology.label(samples1, neighbors=4,
                                               background=0, return_num=True)
            _, num2 = skimage.morphology.label(samples2, neighbors=4,
                                               background=0, return_num=True)
            seen_components[0] += num1
            seen_components[1] += num2
            seen_pixels[0] += np.sum(samples1 == 1)
            seen_pixels[1] += np.sum(samples2 == 1)

        assert seen_components[0] < seen_components[1]
        assert (
            seen_pixels[0] / seen_components[0]
            > seen_pixels[1] / seen_components[1]
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="2386" endline="2412" pcid="3528">
        )

    def test_size_percent_as_stochastic_parameters(self):
        # different sizes in percent, given as StochasticParameter
        param1 = iap.FromLowerResolution(iap.Binomial(0.5),
                                         size_percent=iap.Deterministic(0.01))
        param2 = iap.FromLowerResolution(iap.Binomial(0.5),
                                         size_percent=iap.Choice([0.4, 0.8]))

        seen_components = [0, 0]
        seen_pixels = [0, 0]
        for _ in sm.xrange(100):
            samples1 = param1.draw_samples((16, 16, 1))
            samples2 = param2.draw_samples((16, 16, 1))
            _, num1 = skimage.morphology.label(samples1, neighbors=4,
                                               background=0, return_num=True)
            _, num2 = skimage.morphology.label(samples2, neighbors=4,
                                               background=0, return_num=True)
            seen_components[0] += num1
            seen_components[1] += num2
            seen_pixels[0] += np.sum(samples1 == 1)
            seen_pixels[1] += np.sum(samples2 == 1)

        assert seen_components[0] < seen_components[1]
        assert (
            seen_pixels[0] / seen_components[0]
            > seen_pixels[1] / seen_components[1]
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="2361" endline="2385" pcid="3527">
        )

    def test_size_percent(self):
        # different sizes in percent
        param1 = iap.FromLowerResolution(iap.Binomial(0.5), size_percent=0.01)
        param2 = iap.FromLowerResolution(iap.Binomial(0.5), size_percent=0.8)

        seen_components = [0, 0]
        seen_pixels = [0, 0]
        for _ in sm.xrange(100):
            samples1 = param1.draw_samples((16, 16, 1))
            samples2 = param2.draw_samples((16, 16, 1))
            _, num1 = skimage.morphology.label(samples1, neighbors=4,
                                               background=0, return_num=True)
            _, num2 = skimage.morphology.label(samples2, neighbors=4,
                                               background=0, return_num=True)
            seen_components[0] += num1
            seen_components[1] += num2
            seen_pixels[0] += np.sum(samples1 == 1)
            seen_pixels[1] += np.sum(samples2 == 1)

        assert seen_components[0] < seen_components[1]
        assert (
            seen_pixels[0] / seen_components[0]
            > seen_pixels[1] / seen_components[1]
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="2301" endline="2327" pcid="3524">
        )

    def test_different_size_px_argument_with_stochastic_parameters(self):
        # different sizes in px, given as StochasticParameter
        param1 = iap.FromLowerResolution(iap.Binomial(0.5),
                                         size_px=iap.Deterministic(1))
        param2 = iap.FromLowerResolution(iap.Binomial(0.5),
                                         size_px=iap.Choice([8, 16]))

        seen_components = [0, 0]
        seen_pixels = [0, 0]
        for _ in sm.xrange(100):
            samples1 = param1.draw_samples((16, 16, 1))
            samples2 = param2.draw_samples((16, 16, 1))
            _, num1 = skimage.morphology.label(samples1, neighbors=4,
                                               background=0, return_num=True)
            _, num2 = skimage.morphology.label(samples2, neighbors=4,
                                               background=0, return_num=True)
            seen_components[0] += num1
            seen_components[1] += num2
            seen_pixels[0] += np.sum(samples1 == 1)
            seen_pixels[1] += np.sum(samples2 == 1)

        assert seen_components[0] < seen_components[1]
        assert (
            seen_pixels[0] / seen_components[0]
            > seen_pixels[1] / seen_components[1]
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="2276" endline="2300" pcid="3523">
        )

    def test_different_size_px_arguments_with_tuple(self):
        # different sizes in px, one given as tuple (a, b)
        param1 = iap.FromLowerResolution(iap.Binomial(0.5), size_px=2)
        param2 = iap.FromLowerResolution(iap.Binomial(0.5), size_px=(2, 16))

        seen_components = [0, 0]
        seen_pixels = [0, 0]
        for _ in sm.xrange(400):
            samples1 = param1.draw_samples((16, 16, 1))
            samples2 = param2.draw_samples((16, 16, 1))
            _, num1 = skimage.morphology.label(samples1, neighbors=4,
                                               background=0, return_num=True)
            _, num2 = skimage.morphology.label(samples2, neighbors=4,
                                               background=0, return_num=True)
            seen_components[0] += num1
            seen_components[1] += num2
            seen_pixels[0] += np.sum(samples1 == 1)
            seen_pixels[1] += np.sum(samples2 == 1)

        assert seen_components[0] < seen_components[1]
        assert (
            seen_pixels[0] / seen_components[0]
            > seen_pixels[1] / seen_components[1]
</source>
</class>

<class classid="226" nclones="16" nlines="12" similarity="70">
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="2678" endline="2693" pcid="3554">
        )

    def test_multiply_example_integer_values(self):
        values_int = [-100, -54, -1, 0, 1, 54, 100]

        for v1, v2 in itertools.product(values_int, values_int):
            with self.subTest(left=v1, right=v2):
                p = iap.Multiply(iap.Deterministic(v1), v2)

                samples = p.draw_samples((2, 3))

                assert p.draw_sample() == v1 * v2
                assert samples.dtype.kind == "i"
                assert np.array_equal(
                    samples,
                    np.zeros((2, 3), dtype=np.int64) + v1 * v2
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="3147" endline="3163" pcid="3586">
        )

    def test_subtract_integers(self):
        values_int = [-100, -54, -1, 0, 1, 54, 100]

        for v1, v2 in itertools.product(values_int, values_int):
            with self.subTest(left=v1, right=v2):
                p = iap.Subtract(iap.Deterministic(v1), v2)

                sample = p.draw_sample()
                samples = p.draw_samples((2, 3))

                assert sample == v1 - v2
                assert samples.dtype.kind == "i"
                assert np.array_equal(
                    samples,
                    np.zeros((2, 3), dtype=np.int64) + v1 - v2
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="2710" endline="2725" pcid="3556">
                )

    def test_multiply_example_float_values(self):
        values_float = [-100.0, -54.3, -1.0, 0.1, 0.0, 0.1, 1.0, 54.4, 100.0]
        for v1, v2 in itertools.product(values_float, values_float):
            with self.subTest(left=v1, right=v2):
                p = iap.Multiply(iap.Deterministic(v1), v2)

                sample = p.draw_sample()
                samples = p.draw_samples((2, 3))

                assert np.isclose(sample, v1 * v2, atol=1e-3, rtol=0)
                assert samples.dtype.kind == "f"
                assert np.allclose(
                    samples,
                    np.zeros((2, 3), dtype=np.float32) + v1 * v2
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="2694" endline="2709" pcid="3555">
                )

    def test_multiply_example_integer_values_both_deterministic(self):
        values_int = [-100, -54, -1, 0, 1, 54, 100]

        for v1, v2 in itertools.product(values_int, values_int):
            with self.subTest(left=v1, right=v2):
                p = iap.Multiply(iap.Deterministic(v1), iap.Deterministic(v2))

                samples = p.draw_samples((2, 3))

                assert p.draw_sample() == v1 * v2
                assert samples.dtype.name == "int32"
                assert np.array_equal(
                    samples,
                    np.zeros((2, 3), dtype=np.int32) + v1 * v2
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="3008" endline="3024" pcid="3576">
        )

    def test_add_integers(self):
        values_int = [-100, -54, -1, 0, 1, 54, 100]

        for v1, v2 in itertools.product(values_int, values_int):
            with self.subTest(left=v1, right=v2):
                p = iap.Add(iap.Deterministic(v1), v2)

                sample = p.draw_sample()
                samples = p.draw_samples((2, 3))

                assert sample == v1 + v2
                assert samples.dtype.kind == "i"
                assert np.array_equal(
                    samples,
                    np.zeros((2, 3), dtype=np.int32) + v1 + v2
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="3164" endline="3180" pcid="3587">
                )

    def test_subtract_integers_both_deterministic(self):
        values_int = [-100, -54, -1, 0, 1, 54, 100]

        for v1, v2 in itertools.product(values_int, values_int):
            with self.subTest(left=v1, right=v2):
                p = iap.Subtract(iap.Deterministic(v1), iap.Deterministic(v2))

                sample = p.draw_sample()
                samples = p.draw_samples((2, 3))

                assert sample == v1 - v2
                assert samples.dtype.kind == "i"
                assert np.array_equal(
                    samples,
                    np.zeros((2, 3), dtype=np.int64) + v1 - v2
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="3181" endline="3196" pcid="3588">
                )

    def test_subtract_floats(self):
        values_float = [-100.0, -54.3, -1.0, 0.1, 0.0, 0.1, 1.0, 54.4, 100.0]
        for v1, v2 in itertools.product(values_float, values_float):
            with self.subTest(left=v1, right=v2):
                p = iap.Subtract(iap.Deterministic(v1), v2)

                sample = p.draw_sample()
                samples = p.draw_samples((2, 3))

                assert v1 - v2 - _eps(sample) < sample < v1 - v2 + _eps(sample)
                assert samples.dtype.kind == "f"
                assert np.allclose(
                    samples,
                    np.zeros((2, 3), dtype=np.float64) + v1 - v2
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="3197" endline="3212" pcid="3589">
                )

    def test_subtract_floats_both_deterministic(self):
        values_float = [-100.0, -54.3, -1.0, 0.1, 0.0, 0.1, 1.0, 54.4, 100.0]
        for v1, v2 in itertools.product(values_float, values_float):
            with self.subTest(left=v1, right=v2):
                p = iap.Subtract(iap.Deterministic(v1), iap.Deterministic(v2))

                sample = p.draw_sample()
                samples = p.draw_samples((2, 3))

                assert v1 - v2 - _eps(sample) < sample < v1 - v2 + _eps(sample)
                assert samples.dtype.kind == "f"
                assert np.allclose(
                    samples,
                    np.zeros((2, 3), dtype=np.float64) + v1 - v2
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="2820" endline="2839" pcid="3564">
        )

    def test_divide_integers(self):
        values_int = [-100, -54, -1, 0, 1, 54, 100]

        for v1, v2 in itertools.product(values_int, values_int):
            if v2 == 0:
                v2 = 1

            with self.subTest(left=v1, right=v2):
                p = iap.Divide(iap.Deterministic(v1), v2)

                sample = p.draw_sample()
                samples = p.draw_samples((2, 3))

                assert sample == (v1 / v2)
                assert samples.dtype.kind == "f"
                assert np.array_equal(
                    samples,
                    np.zeros((2, 3), dtype=np.float64) + (v1 / v2)
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="3025" endline="3041" pcid="3577">
                )

    def test_add_integers_both_deterministic(self):
        values_int = [-100, -54, -1, 0, 1, 54, 100]

        for v1, v2 in itertools.product(values_int, values_int):
            with self.subTest(left=v1, right=v2):
                p = iap.Add(iap.Deterministic(v1), iap.Deterministic(v2))

                sample = p.draw_sample()
                samples = p.draw_samples((2, 3))

                assert sample == v1 + v2
                assert samples.dtype.kind == "i"
                assert np.array_equal(
                    samples,
                    np.zeros((2, 3), dtype=np.int32) + v1 + v2
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="3042" endline="3057" pcid="3578">
                )

    def test_add_floats(self):
        values_float = [-100.0, -54.3, -1.0, 0.1, 0.0, 0.1, 1.0, 54.4, 100.0]
        for v1, v2 in itertools.product(values_float, values_float):
            with self.subTest(left=v1, right=v2):
                p = iap.Add(iap.Deterministic(v1), v2)

                sample = p.draw_sample()
                samples = p.draw_samples((2, 3))

                assert np.isclose(sample, v1 + v2, atol=1e-3, rtol=0)
                assert samples.dtype.kind == "f"
                assert np.allclose(
                    samples,
                    np.zeros((2, 3), dtype=np.float32) + v1 + v2
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="3058" endline="3073" pcid="3579">
                )

    def test_add_floats_both_deterministic(self):
        values_float = [-100.0, -54.3, -1.0, 0.1, 0.0, 0.1, 1.0, 54.4, 100.0]
        for v1, v2 in itertools.product(values_float, values_float):
            with self.subTest(left=v1, right=v2):
                p = iap.Add(iap.Deterministic(v1), iap.Deterministic(v2))

                sample = p.draw_sample()
                samples = p.draw_samples((2, 3))

                assert np.isclose(sample, v1 + v2, atol=1e-3, rtol=0)
                assert samples.dtype.kind == "f"
                assert np.allclose(
                    samples,
                    np.zeros((2, 3), dtype=np.float32) + v1 + v2
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="2726" endline="2741" pcid="3557">
                )

    def test_multiply_example_float_values_both_deterministic(self):
        values_float = [-100.0, -54.3, -1.0, 0.1, 0.0, 0.1, 1.0, 54.4, 100.0]
        for v1, v2 in itertools.product(values_float, values_float):
            with self.subTest(left=v1, right=v2):
                p = iap.Multiply(iap.Deterministic(v1), iap.Deterministic(v2))

                sample = p.draw_sample()
                samples = p.draw_samples((2, 3))

                assert np.isclose(sample, v1 * v2, atol=1e-3, rtol=0)
                assert samples.dtype.kind == "f"
                assert np.allclose(
                    samples,
                    np.zeros((2, 3), dtype=np.float32) + v1 * v2
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="2840" endline="2859" pcid="3565">
                )

    def test_divide_integers_both_deterministic(self):
        values_int = [-100, -54, -1, 0, 1, 54, 100]

        for v1, v2 in itertools.product(values_int, values_int):
            if v2 == 0:
                v2 = 1

            with self.subTest(left=v1, right=v2):
                p = iap.Divide(iap.Deterministic(v1), iap.Deterministic(v2))

                sample = p.draw_sample()
                samples = p.draw_samples((2, 3))

                assert sample == (v1 / v2)
                assert samples.dtype.kind == "f"
                assert np.array_equal(
                    samples,
                    np.zeros((2, 3), dtype=np.float64) + (v1 / v2)
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="2860" endline="2883" pcid="3566">
                )

    def test_divide_floats(self):
        values_float = [-100.0, -54.3, -1.0, 0.1, 0.0, 0.1, 1.0, 54.4, 100.0]

        for v1, v2 in itertools.product(values_float, values_float):
            if v2 == 0:
                v2 = 1

            with self.subTest(left=v1, right=v2):
                p = iap.Divide(iap.Deterministic(v1), v2)

                sample = p.draw_sample()
                samples = p.draw_samples((2, 3))

                assert (
                    (v1 / v2) - _eps(sample)
                    <= sample <=
                    (v1 / v2) + _eps(sample)
                )
                assert samples.dtype.kind == "f"
                assert np.allclose(
                    samples,
                    np.zeros((2, 3), dtype=np.float64) + (v1 / v2)
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="2884" endline="2907" pcid="3567">
                )

    def test_divide_floats_both_deterministic(self):
        values_float = [-100.0, -54.3, -1.0, 0.1, 0.0, 0.1, 1.0, 54.4, 100.0]

        for v1, v2 in itertools.product(values_float, values_float):
            if v2 == 0:
                v2 = 1

            with self.subTest(left=v1, right=v2):
                p = iap.Divide(iap.Deterministic(v1), iap.Deterministic(v2))

                sample = p.draw_sample()
                samples = p.draw_samples((2, 3))

                assert (
                    (v1 / v2) - _eps(sample)
                    <= sample <=
                    (v1 / v2) + _eps(sample)
                )
                assert samples.dtype.kind == "f"
                assert np.allclose(
                    samples,
                    np.zeros((2, 3), dtype=np.float64) + (v1 / v2)
</source>
</class>

<class classid="227" nclones="12" nlines="12" similarity="76">
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="2742" endline="2758" pcid="3558">
                )

    def test_multiply_by_stochastic_parameter(self):
        param = iap.Multiply(iap.Deterministic(1.0),
                             (1.0, 2.0),
                             elementwise=False)

        samples = param.draw_samples((10, 20))
        samples_sorted = np.sort(samples.flatten())

        assert samples.shape == (10, 20)
        assert np.all(samples > 1.0 * 1.0 - _eps(samples))
        assert np.all(samples < 1.0 * 2.0 + _eps(samples))
        assert (
            samples_sorted[0] - _eps(samples_sorted[0])
            < samples_sorted[-1] <
            samples_sorted[0] + _eps(samples_sorted[0])
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="3230" endline="3246" pcid="3591">
        )

    def test_subtract_stochastic_parameter_elementwise(self):
        param = iap.Subtract(iap.Deterministic(1.0),
                             (1.0, 2.0),
                             elementwise=True)

        samples = param.draw_samples((10, 20))
        samples_sorted = np.sort(samples.flatten())

        assert samples.shape == (10, 20)
        assert np.all(samples > 1.0 - 2.0 - _eps(samples))
        assert np.all(samples < 1.0 - 1.0 + _eps(samples))
        assert not (
            samples_sorted[0] - _eps(samples_sorted[0])
            < samples_sorted[-1] <
            samples_sorted[0] + _eps(samples_sorted[0])
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="3213" endline="3229" pcid="3590">
                )

    def test_subtract_stochastic_parameter(self):
        param = iap.Subtract(iap.Deterministic(1.0),
                             (1.0, 2.0),
                             elementwise=False)

        samples = param.draw_samples((10, 20))
        samples_sorted = np.sort(samples.flatten())

        assert samples.shape == (10, 20)
        assert np.all(samples > 1.0 - 2.0 - _eps(samples))
        assert np.all(samples < 1.0 - 1.0 + _eps(samples))
        assert (
            samples_sorted[0] - _eps(samples_sorted[0])
            < samples_sorted[-1] <
            samples_sorted[0] + _eps(samples_sorted[0])
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="3367" endline="3383" pcid="3599">
        )

    def test_exponent_is_stochastic_parameter_elementwise(self):
        param = iap.Power(iap.Deterministic(1.5),
                          (1.0, 2.0),
                          elementwise=True)

        samples = param.draw_samples((10, 20))
        samples_sorted = np.sort(samples.flatten())

        assert samples.shape == (10, 20)
        assert np.all(samples > 1.5 ** 1.0 - 2 * _eps(samples))
        assert np.all(samples < 1.5 ** 2.0 + 2 * _eps(samples))
        assert not (
            samples_sorted[0] - _eps(samples_sorted[0])
            < samples_sorted[-1] <
            samples_sorted[0] + _eps(samples_sorted[0])
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="2776" endline="2791" pcid="3560">
        )

    def test_multiply_stochastic_parameter_by_fixed_value(self):
        param = iap.Multiply(iap.Uniform(1.0, 2.0),
                             1.0,
                             elementwise=False)
        samples = param.draw_samples((10, 20))
        samples_sorted = np.sort(samples.flatten())

        assert samples.shape == (10, 20)
        assert np.all(samples > 1.0 * 1.0 - _eps(samples))
        assert np.all(samples < 2.0 * 1.0 + _eps(samples))
        assert not (
            samples_sorted[0] - _eps(samples_sorted[0])
            < samples_sorted[-1] <
            samples_sorted[0] + _eps(samples_sorted[0])
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="3350" endline="3366" pcid="3598">
                )

    def test_exponent_is_stochastic_parameter(self):
        param = iap.Power(iap.Deterministic(1.5),
                          (1.0, 2.0),
                          elementwise=False)

        samples = param.draw_samples((10, 20))
        samples_sorted = np.sort(samples.flatten())

        assert samples.shape == (10, 20)
        assert np.all(samples > 1.5 ** 1.0 - 2 * _eps(samples))
        assert np.all(samples < 1.5 ** 2.0 + 2 * _eps(samples))
        assert (
            samples_sorted[0] - _eps(samples_sorted[0])
            < samples_sorted[-1] <
            samples_sorted[0] + _eps(samples_sorted[0])
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="2759" endline="2775" pcid="3559">
        )

    def test_multiply_by_stochastic_parameter_elementwise(self):
        param = iap.Multiply(iap.Deterministic(1.0),
                             (1.0, 2.0),
                             elementwise=True)

        samples = param.draw_samples((10, 20))
        samples_sorted = np.sort(samples.flatten())

        assert samples.shape == (10, 20)
        assert np.all(samples > 1.0 * 1.0 - _eps(samples))
        assert np.all(samples < 1.0 * 2.0 + _eps(samples))
        assert not (
            samples_sorted[0] - _eps(samples_sorted[0])
            < samples_sorted[-1] <
            samples_sorted[0] + _eps(samples_sorted[0])
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="3262" endline="3277" pcid="3593">
        )

    def test_subtract_from_stochastic_parameter_elementwise(self):
        param = iap.Subtract(iap.Uniform(1.0, 2.0), 1.0, elementwise=True)

        samples = param.draw_samples((10, 20))
        samples_sorted = np.sort(samples.flatten())

        assert samples.shape == (10, 20)
        assert np.all(samples > 1.0 - 1.0 - _eps(samples))
        assert np.all(samples < 2.0 - 1.0 + _eps(samples))
        assert not (
            samples_sorted[0] - _eps(samples_sorted[0])
            < samples_sorted[-1] <
            samples_sorted[0] + _eps(samples_sorted[0])
        )
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="3247" endline="3261" pcid="3592">
        )

    def test_subtract_from_stochastic_parameter(self):
        param = iap.Subtract(iap.Uniform(1.0, 2.0), 1.0, elementwise=False)

        samples = param.draw_samples((10, 20))
        samples_sorted = np.sort(samples.flatten())

        assert samples.shape == (10, 20)
        assert np.all(samples > 1.0 - 1.0 - _eps(samples))
        assert np.all(samples < 2.0 - 1.0 + _eps(samples))
        assert not (
            samples_sorted[0] - _eps(samples_sorted[0])
            < samples_sorted[-1] <
            samples_sorted[0] + _eps(samples_sorted[0])
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="3384" endline="3398" pcid="3600">
        )

    def test_value_is_uniform(self):
        param = iap.Power(iap.Uniform(1.0, 2.0), 1.0, elementwise=False)

        samples = param.draw_samples((10, 20))
        samples_sorted = np.sort(samples.flatten())

        assert samples.shape == (10, 20)
        assert np.all(samples > 1.0 ** 1.0 - 2 * _eps(samples))
        assert np.all(samples < 2.0 ** 1.0 + 2 * _eps(samples))
        assert not (
            samples_sorted[0] - _eps(samples_sorted[0])
            < samples_sorted[-1] <
            samples_sorted[0] + _eps(samples_sorted[0])
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="3399" endline="3414" pcid="3601">
        )

    def test_value_is_uniform_elementwise(self):
        param = iap.Power(iap.Uniform(1.0, 2.0), 1.0, elementwise=True)

        samples = param.draw_samples((10, 20))
        samples_sorted = np.sort(samples.flatten())

        assert samples.shape == (10, 20)
        assert np.all(samples > 1.0 ** 1.0 - 2 * _eps(samples))
        assert np.all(samples < 2.0 ** 1.0 + 2 * _eps(samples))
        assert not (
            samples_sorted[0] - _eps(samples_sorted[0])
            < samples_sorted[-1] <
            samples_sorted[0] + _eps(samples_sorted[0])
        )
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="2792" endline="2807" pcid="3561">
        )

    def test_multiply_stochastic_parameter_by_fixed_value_elementwise(self):
        param = iap.Multiply(iap.Uniform(1.0, 2.0), 1.0, elementwise=True)

        samples = param.draw_samples((10, 20))
        samples_sorted = np.sort(samples.flatten())

        assert samples.shape == (10, 20)
        assert np.all(samples > 1.0 * 1.0 - _eps(samples))
        assert np.all(samples < 2.0 * 1.0 + _eps(samples))
        assert not (
            samples_sorted[0] - _eps(samples_sorted[0])
            < samples_sorted[-1] <
            samples_sorted[0] + _eps(samples_sorted[0])
        )
</source>
</class>

<class classid="228" nclones="4" nlines="13" similarity="76">
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="2908" endline="2924" pcid="3568">
                )

    def test_divide_by_stochastic_parameter(self):
        param = iap.Divide(iap.Deterministic(1.0),
                           (1.0, 2.0),
                           elementwise=False)

        samples = param.draw_samples((10, 20))
        samples_sorted = np.sort(samples.flatten())

        assert samples.shape == (10, 20)
        assert np.all(samples > (1.0 / 2.0) - _eps(samples))
        assert np.all(samples < (1.0 / 1.0) + _eps(samples))
        assert (
            samples_sorted[0] - _eps(samples)
            < samples_sorted[-1] <
            samples_sorted[0] + _eps(samples)
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="2925" endline="2941" pcid="3569">
        )

    def test_divide_by_stochastic_parameter_elementwise(self):
        param = iap.Divide(iap.Deterministic(1.0),
                           (1.0, 2.0),
                           elementwise=True)

        samples = param.draw_samples((10, 20))
        samples_sorted = np.sort(samples.flatten())

        assert samples.shape == (10, 20)
        assert np.all(samples > (1.0 / 2.0) - _eps(samples))
        assert np.all(samples < (1.0 / 1.0) + _eps(samples))
        assert not (
            samples_sorted[0] - _eps(samples)
            < samples_sorted[-1] <
            samples_sorted[0] + _eps(samples)
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="2942" endline="2958" pcid="3570">
        )

    def test_divide_stochastic_parameter_by_float(self):
        param = iap.Divide(iap.Uniform(1.0, 2.0),
                           1.0,
                           elementwise=False)

        samples = param.draw_samples((10, 20))
        samples_sorted = np.sort(samples.flatten())

        assert samples.shape == (10, 20)
        assert np.all(samples > (1.0 / 1.0) - _eps(samples))
        assert np.all(samples < (2.0 / 1.0) + _eps(samples))
        assert not (
            samples_sorted[0] - _eps(samples)
            < samples_sorted[-1] <
            samples_sorted[0] + _eps(samples)
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="2959" endline="2976" pcid="3571">
        )

    def test_divide_stochastic_parameter_by_float_elementwise(self):
        param = iap.Divide(iap.Uniform(1.0, 2.0),
                           1.0,
                           elementwise=True)

        samples = param.draw_samples((10, 20))
        samples_sorted = np.sort(samples.flatten())

        assert samples.shape == (10, 20)
        assert np.all(samples > (1.0 / 1.0) - _eps(samples))
        assert np.all(samples < (2.0 / 1.0) + _eps(samples))
        assert not (
            samples_sorted[0] - _eps(samples_sorted)
            < samples_sorted[-1]
            < samples_sorted[-1]
            < samples_sorted[0] + _eps(samples_sorted)
</source>
</class>

<class classid="229" nclones="4" nlines="11" similarity="81">
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="3074" endline="3088" pcid="3580">
                )

    def test_add_stochastic_parameter(self):
        param = iap.Add(iap.Deterministic(1.0), (1.0, 2.0), elementwise=False)

        samples = param.draw_samples((10, 20))
        samples_sorted = np.sort(samples.flatten())

        assert samples.shape == (10, 20)
        assert np.all(samples >= 1.0 + 1.0 - _eps(samples))
        assert np.all(samples <= 1.0 + 2.0 + _eps(samples))
        assert (
            samples_sorted[0] - _eps(samples_sorted[0])
            < samples_sorted[-1]
            < samples_sorted[0] + _eps(samples_sorted[0])
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="3119" endline="3134" pcid="3583">
        )

    def test_add_to_stochastic_parameter_elementwise(self):
        param = iap.Add(iap.Uniform(1.0, 2.0), 1.0, elementwise=True)

        samples = param.draw_samples((10, 20))
        samples_sorted = np.sort(samples.flatten())

        assert samples.shape == (10, 20)
        assert np.all(samples >= 1.0 + 1.0 - _eps(samples))
        assert np.all(samples <= 2.0 + 1.0 + _eps(samples))
        assert not (
            samples_sorted[0] - _eps(samples_sorted[0])
            < samples_sorted[-1]
            < samples_sorted[0] + _eps(samples_sorted[0])
        )
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="3104" endline="3118" pcid="3582">
        )

    def test_add_to_stochastic_parameter(self):
        param = iap.Add(iap.Uniform(1.0, 2.0), 1.0, elementwise=False)

        samples = param.draw_samples((10, 20))
        samples_sorted = np.sort(samples.flatten())

        assert samples.shape == (10, 20)
        assert np.all(samples >= 1.0 + 1.0 - _eps(samples))
        assert np.all(samples <= 2.0 + 1.0 + _eps(samples))
        assert not (
            samples_sorted[0] - _eps(samples_sorted[0])
            < samples_sorted[-1]
            < samples_sorted[0] + _eps(samples_sorted[0])
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="3089" endline="3103" pcid="3581">
        )

    def test_add_stochastic_parameter_elementwise(self):
        param = iap.Add(iap.Deterministic(1.0), (1.0, 2.0), elementwise=True)

        samples = param.draw_samples((10, 20))
        samples_sorted = np.sort(samples.flatten())

        assert samples.shape == (10, 20)
        assert np.all(samples >= 1.0 + 1.0 - _eps(samples))
        assert np.all(samples <= 1.0 + 2.0 + _eps(samples))
        assert not (
            samples_sorted[0] - _eps(samples_sorted[0])
            < samples_sorted[-1]
            < samples_sorted[0] + _eps(samples_sorted[0])
</source>
</class>

<class classid="230" nclones="2" nlines="22" similarity="95">
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="3290" endline="3319" pcid="3596">
        )

    def test_pairs(self):
        values = [
            -100, -54, -1, 0, 1, 54, 100,
            -100.0, -54.0, -1.0, 0.0, 1.0, 54.0, 100.0
        ]
        exponents = [-2, -1.5, -1, -0.5, 0, 0.5, 1, 1.5, 2]

        for base, exponent in itertools.product(values, exponents):
            if base < 0 and ia.is_single_float(exponent):
                continue
            if base == 0 and exponent < 0:
                continue

            with self.subTest(base=base, exponent=exponent):
                p = iap.Power(iap.Deterministic(base), exponent)

                sample = p.draw_sample()
                samples = p.draw_samples((2, 3))

                assert (
                    base ** exponent - _eps(sample)
                    < sample <
                    base ** exponent + _eps(sample)
                )
                assert samples.dtype.kind == "f"
                assert np.allclose(
                    samples,
                    np.zeros((2, 3), dtype=np.float64) + base ** exponent
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="3320" endline="3349" pcid="3597">
                )

    def test_pairs_both_deterministic(self):
        values = [
            -100, -54, -1, 0, 1, 54, 100,
            -100.0, -54.0, -1.0, 0.0, 1.0, 54.0, 100.0
        ]
        exponents = [-2, -1.5, -1, -0.5, 0, 0.5, 1, 1.5, 2]

        for base, exponent in itertools.product(values, exponents):
            if base < 0 and ia.is_single_float(exponent):
                continue
            if base == 0 and exponent < 0:
                continue

            with self.subTest(base=base, exponent=exponent):
                p = iap.Power(iap.Deterministic(base), iap.Deterministic(exponent))

                sample = p.draw_sample()
                samples = p.draw_samples((2, 3))

                assert (
                    base ** exponent - _eps(sample)
                    < sample <
                    base ** exponent + _eps(sample)
                )
                assert samples.dtype.kind == "f"
                assert np.allclose(
                    samples,
                    np.zeros((2, 3), dtype=np.float64) + base ** exponent
</source>
</class>

<class classid="231" nclones="2" nlines="10" similarity="80">
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="3600" endline="3612" pcid="3620">
        assert np.all(samples == -1)

    def test_many_samples_stochastic_value_to_positive(self):
        param = iap.ForceSign(iap.Choice([-2, 1]), positive=True,
                              mode="invert")

        samples = param.draw_samples(1000)
        n_twos = np.sum(samples == 2)
        n_ones = np.sum(samples == 1)

        assert samples.shape == (1000,)
        assert n_twos + n_ones == 1000
        assert 200 < n_twos < 700
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="3613" endline="3625" pcid="3621">
        assert 200 < n_ones < 700

    def test_many_samples_stochastic_value_to_positive_reroll(self):
        param = iap.ForceSign(iap.Choice([-2, 1]), positive=True,
                              mode="reroll")

        samples = param.draw_samples(1000)
        n_twos = np.sum(samples == 2)
        n_ones = np.sum(samples == 1)

        assert samples.shape == (1000,)
        assert n_twos + n_ones == 1000
        assert n_twos > 0
</source>
</class>

<class classid="232" nclones="2" nlines="11" similarity="72">
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="3638" endline="3652" pcid="3623">
        assert n_twos < 5

    def test_samples_same_values_for_same_seeds(self):
        param = iap.ForceSign(iap.Choice([-2, 1]),
                              positive=True,
                              mode="invert")

        samples1 = param.draw_samples((100, 10),
                                      random_state=iarandom.RNG(1234))
        samples2 = param.draw_samples((100, 10),
                                      random_state=iarandom.RNG(1234))

        assert samples1.shape == (100, 10)
        assert samples2.shape == (100, 10)
        assert np.array_equal(samples1, samples2)
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="3845" endline="3857" pcid="3639">
        assert 0.25 - 0.05 < nb_0 / (2 * 1000) < 0.25 + 0.05

    def test_samples_same_values_for_same_seeds(self):
        param = iap.IterativeNoiseAggregator(
            iap.Choice([0, 50]), iterations=5, aggregation_method="avg")

        samples1 = param.draw_samples((100, 10),
                                      random_state=iarandom.RNG(1234))
        samples2 = param.draw_samples((100, 10),
                                      random_state=iarandom.RNG(1234))

        assert samples1.shape == (100, 10)
        assert samples2.shape == (100, 10)
</source>
</class>

<class classid="233" nclones="4" nlines="10" similarity="70">
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="3705" endline="3717" pcid="3630">
        )

    def test_value_is_deterministic_max_1_iter(self):
        param = iap.IterativeNoiseAggregator(iap.Deterministic(1),
                                             iterations=1,
                                             aggregation_method="max")

        sample = param.draw_sample()
        samples = param.draw_samples((2, 4))

        assert sample.shape == tuple()
        assert samples.shape == (2, 4)
        assert sample == 1
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="3744" endline="3756" pcid="3633">
        assert np.all(samples == 50)

    def test_value_is_stochastic_min_100_iter(self):
        param = iap.IterativeNoiseAggregator(iap.Choice([0, 50]),
                                             iterations=100,
                                             aggregation_method="min")

        sample = param.draw_sample()
        samples = param.draw_samples((2, 4))

        assert sample.shape == tuple()
        assert samples.shape == (2, 4)
        assert sample == 0
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="3731" endline="3743" pcid="3632">
        assert np.all(np.logical_and(25 - 10 < samples, samples < 25 + 10))

    def test_value_is_stochastic_max_100_iter(self):
        param = iap.IterativeNoiseAggregator(iap.Choice([0, 50]),
                                             iterations=100,
                                             aggregation_method="max")

        sample = param.draw_sample()
        samples = param.draw_samples((2, 4))

        assert sample.shape == tuple()
        assert samples.shape == (2, 4)
        assert sample == 50
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="3718" endline="3730" pcid="3631">
        assert np.all(samples == 1)

    def test_value_is_stochastic_avg_200_iter(self):
        param = iap.IterativeNoiseAggregator(iap.Choice([0, 50]),
                                             iterations=200,
                                             aggregation_method="avg")

        sample = param.draw_sample()
        samples = param.draw_samples((2, 4))

        assert sample.shape == tuple()
        assert samples.shape == (2, 4)
        assert 25 - 10 < sample < 25 + 10
</source>
</class>

<class classid="234" nclones="2" nlines="17" similarity="94">
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="3912" endline="3933" pcid="3645">
        )

    def test_activated_is_true(self):
        param = iap.Sigmoid(
            iap.Deterministic(5),
            add=0,
            mul=1,
            threshold=0.5,
            activated=True)

        expected = 1 / (1 + np.exp(-(5 * 1 + 0 - 0.5)))
        sample = param.draw_sample()
        samples = param.draw_samples((5, 10))

        assert sample.shape == tuple()
        assert samples.shape == (5, 10)
        assert expected - _eps(sample) < sample < expected + _eps(sample)
        assert np.all(
            np.logical_and(
                expected - _eps(samples) < samples,
                samples < expected + _eps(samples)
            )
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="3934" endline="3955" pcid="3646">
        )

    def test_activated_is_false(self):
        param = iap.Sigmoid(
            iap.Deterministic(5),
            add=0,
            mul=1,
            threshold=0.5,
            activated=False)

        expected = 5
        sample = param.draw_sample()
        samples = param.draw_samples((5, 10))

        assert sample.shape == tuple()
        assert samples.shape == (5, 10)
        assert expected - _eps(sample) < sample < expected + _eps(sample)
        assert np.all(
            np.logical_and(
                expected - _eps(sample) < samples,
                samples < expected + _eps(sample)
            )
</source>
</class>

<class classid="235" nclones="2" nlines="22" similarity="86">
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="3956" endline="3980" pcid="3647">
        )

    def test_activated_is_probabilistic(self):
        param = iap.Sigmoid(
            iap.Deterministic(5),
            add=0,
            mul=1,
            threshold=0.5,
            activated=0.5)

        expected_first = 5
        expected_second = 1 / (1 + np.exp(-(5 * 1 + 0 - 0.5)))
        seen = [0, 0]
        for _ in sm.xrange(1000):
            sample = param.draw_sample()
            diff_first = abs(sample - expected_first)
            diff_second = abs(sample - expected_second)
            if diff_first < _eps(sample):
                seen[0] += 1
            elif diff_second < _eps(sample):
                seen[1] += 1
            else:
                assert False

        assert 500 - 150 < seen[0] < 500 + 150
</source>
<source file="systems/imgaug-0.3.0/test/test_parameters.py" startline="3981" endline="4005" pcid="3648">
        assert 500 - 150 < seen[1] < 500 + 150

    def test_value_is_stochastic_param(self):
        param = iap.Sigmoid(
            iap.Choice([1, 10]),
            add=0,
            mul=1,
            threshold=0.5,
            activated=True)

        expected_first = 1 / (1 + np.exp(-(1 * 1 + 0 - 0.5)))
        expected_second = 1 / (1 + np.exp(-(10 * 1 + 0 - 0.5)))
        seen = [0, 0]
        for _ in sm.xrange(1000):
            sample = param.draw_sample()
            diff_first = abs(sample - expected_first)
            diff_second = abs(sample - expected_second)
            if diff_first < _eps(sample):
                seen[0] += 1
            elif diff_second < _eps(sample):
                seen[1] += 1
            else:
                assert False

        assert 500 - 150 < seen[0] < 500 + 150
</source>
</class>

</clones>
