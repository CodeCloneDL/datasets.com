<html>
<head>
    <title>NiCad6 Clone Report</title>
    <style type="text/css">
        body {font-family:sans-serif;}
        table {background-color:white; border:0px; padding:0px; border-spacing:4px; width:auto; margin-left:30px; margin-right:auto;}
        td {background-color:rgba(192,212,238,0.8); border:0px; padding:8px; width:auto; vertical-align:top; border-radius:8px}
        pre {background-color:white; padding:4px;}
        a {color:darkblue;}
    </style>
</head>
<body>
<h2>NiCad6 Clone Report</h2>
<table>
<tr style="font-size:14pt">
<td><b>System:</b> &nbsp; imgaug-0.2.7</td>
<td><b>Clone pairs:</b> &nbsp; 95</td>
<td><b>Clone classes:</b> &nbsp; 50</td>
</tr>
<tr style="font-size:12pt">
<td style="background-color:white">Clone type: &nbsp; 3-2</td>
<td style="background-color:white">Granularity: &nbsp; functions-blind</td>
<td style="background-color:white">Max diff threshold: &nbsp; 30%</td>
<td style="background-color:white">Clone size: &nbsp; 10 - 2500 lines</td>
<td style="background-color:white">Total functions-blind: &nbsp; 1025</td>
</tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 1:</b> &nbsp; 2 fragments, nominal size 37 lines, similarity 87%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag36')" href="javascript:;">
imgaug-0.2.7/imgaug/augmenters/geometric.py: 584-626
</a>
<div class="mid" id="frag36" style="display:none"><pre>
            heatmaps_i.shape = output_shape_i
        return heatmaps

    def _augment_keypoints(self, keypoints_on_images, random_state, parents, hooks):
        result = []
        nb_images = len(keypoints_on_images)
        scale_samples, translate_samples, rotate_samples, shear_samples, \
            _cval_samples, _mode_samples, _order_samples = self._draw_samples(nb_images, random_state)

        for i, keypoints_on_image in enumerate(keypoints_on_images):
            height, width = keypoints_on_image.height, keypoints_on_image.width
            shift_x = width / 2.0 - 0.5
            shift_y = height / 2.0 - 0.5
            scale_x, scale_y = scale_samples[0][i], scale_samples[1][i]
            translate_x, translate_y = translate_samples[0][i], translate_samples[1][i]
            if ia.is_single_float(translate_y):
                translate_y_px = int(np.round(translate_y * keypoints_on_image.shape[0]))
            else:
                translate_y_px = translate_y
            if ia.is_single_float(translate_x):
                translate_x_px = int(np.round(translate_x * keypoints_on_image.shape[1]))
            else:
                translate_x_px = translate_x
            rotate = rotate_samples[i]
            shear = shear_samples[i]
            if scale_x != 1.0 or scale_y != 1.0 or translate_x_px != 0 or translate_y_px != 0 or rotate != 0 \
                    or shear != 0:
                matrix_to_topleft = tf.SimilarityTransform(translation=[-shift_x, -shift_y])
                matrix_transforms = tf.AffineTransform(
                    scale=(scale_x, scale_y),
                    translation=(translate_x_px, translate_y_px),
                    rotation=math.radians(rotate),
                    shear=math.radians(shear)
                )
                matrix_to_center = tf.SimilarityTransform(translation=[shift_x, shift_y])
                matrix = (matrix_to_topleft + matrix_transforms + matrix_to_center)
                if self.fit_output:
                    matrix, output_shape = self._tf_to_fit_output(keypoints_on_image.shape, matrix)
                else:
                    output_shape = keypoints_on_image.shape

                coords = keypoints_on_image.get_coords_array()
                coords_aug = tf.matrix_transform(coords, matrix.params)
</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag46')" href="javascript:;">
imgaug-0.2.7/imgaug/augmenters/geometric.py: 1245-1283
</a>
<div class="mid" id="frag46" style="display:none"><pre>
        cval_samples = np.zeros((cval_samples.shape[0], 1), dtype=np.float32)
        mode_samples = ["constant"] * len(mode_samples)
        arrs = [heatmap_i.arr_0to1 for heatmap_i in heatmaps]
        arrs_aug = self._augment_images_by_samples(arrs, scale_samples, translate_samples, rotate_samples,
                                                   shear_samples, cval_samples, mode_samples, order_samples)
        for heatmap_i, arr_aug in zip(heatmaps, arrs_aug):
            heatmap_i.arr_0to1 = arr_aug
        return heatmaps

    def _augment_keypoints(self, keypoints_on_images, random_state, parents, hooks):
        result = []
        nb_images = len(keypoints_on_images)
        scale_samples, translate_samples, rotate_samples, shear_samples, \
            _cval_samples, _mode_samples, _order_samples = self._draw_samples(nb_images, random_state)

        for i, keypoints_on_image in enumerate(keypoints_on_images):
            height, width = keypoints_on_image.height, keypoints_on_image.width
            shift_x = width / 2.0 - 0.5
            shift_y = height / 2.0 - 0.5
            scale_x, scale_y = scale_samples[0][i], scale_samples[1][i]
            translate_x, translate_y = translate_samples[0][i], translate_samples[1][i]
            if ia.is_single_float(translate_y):
                translate_y_px = int(np.round(translate_y * keypoints_on_image.shape[0]))
            else:
                translate_y_px = translate_y
            if ia.is_single_float(translate_x):
                translate_x_px = int(np.round(translate_x * keypoints_on_image.shape[1]))
            else:
                translate_x_px = translate_x
            rotate = rotate_samples[i]
            shear = shear_samples[i]
            if scale_x != 1.0 or scale_y != 1.0 or translate_x_px != 0 or translate_y_px != 0 or rotate != 0 \
                    or shear != 0:
                matrix_to_topleft = tf.SimilarityTransform(translation=[-shift_x, -shift_y])
                matrix_transforms = tf.AffineTransform(
                    scale=(scale_x, scale_y),
                    translation=(translate_x_px, translate_y_px),
                    rotation=math.radians(rotate),
                    shear=math.radians(shear)
</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 2:</b> &nbsp; 2 fragments, nominal size 26 lines, similarity 100%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag38')" href="javascript:;">
imgaug-0.2.7/imgaug/augmenters/geometric.py: 631-663
</a>
<div class="mid" id="frag38" style="display:none"><pre>

    def get_parameters(self):
        return [self.scale, self.translate, self.rotate, self.shear, self.order, self.cval, self.mode, self.backend,
                self.fit_output]

    def _draw_samples(self, nb_samples, random_state):
        seed = random_state.randint(0, 10**6, 1)[0]

        if isinstance(self.scale, tuple):
            scale_samples = (
                self.scale[0].draw_samples((nb_samples,), random_state=ia.new_random_state(seed + 10)),
                self.scale[1].draw_samples((nb_samples,), random_state=ia.new_random_state(seed + 20)),
            )
        else:
            scale_samples = self.scale.draw_samples((nb_samples,), random_state=ia.new_random_state(seed + 30))
            scale_samples = (scale_samples, scale_samples)

        if isinstance(self.translate, tuple):
            translate_samples = (
                self.translate[0].draw_samples((nb_samples,), random_state=ia.new_random_state(seed + 40)),
                self.translate[1].draw_samples((nb_samples,), random_state=ia.new_random_state(seed + 50)),
            )
        else:
            translate_samples = self.translate.draw_samples((nb_samples,), random_state=ia.new_random_state(seed + 60))
            translate_samples = (translate_samples, translate_samples)

        ia.do_assert(translate_samples[0].dtype in [np.int32, np.int64, np.float32, np.float64])
        ia.do_assert(translate_samples[1].dtype in [np.int32, np.int64, np.float32, np.float64])

        rotate_samples = self.rotate.draw_samples((nb_samples,), random_state=ia.new_random_state(seed + 70))
        shear_samples = self.shear.draw_samples((nb_samples,), random_state=ia.new_random_state(seed + 80))

        cval_samples = self.cval.draw_samples((nb_samples, 3), random_state=ia.new_random_state(seed + 90))
</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag48')" href="javascript:;">
imgaug-0.2.7/imgaug/augmenters/geometric.py: 1287-1320
</a>
<div class="mid" id="frag48" style="display:none"><pre>

                coords = keypoints_on_image.get_coords_array()
                coords_aug = tf.matrix_transform(coords, matrix.params)
                result.append(ia.KeypointsOnImage.from_coords_array(coords_aug, shape=keypoints_on_image.shape))
            else:
                result.append(keypoints_on_image)
        return result

    def get_parameters(self):
        return [self.scale, self.translate, self.rotate, self.shear, self.order, self.cval, self.mode]

    def _draw_samples(self, nb_samples, random_state):
        seed = random_state.randint(0, 10**6, 1)[0]

        if isinstance(self.scale, tuple):
            scale_samples = (
                self.scale[0].draw_samples((nb_samples,), random_state=ia.new_random_state(seed + 10)),
                self.scale[1].draw_samples((nb_samples,), random_state=ia.new_random_state(seed + 20)),
            )
        else:
            scale_samples = self.scale.draw_samples((nb_samples,), random_state=ia.new_random_state(seed + 30))
            scale_samples = (scale_samples, scale_samples)

        if isinstance(self.translate, tuple):
            translate_samples = (
                self.translate[0].draw_samples((nb_samples,), random_state=ia.new_random_state(seed + 40)),
                self.translate[1].draw_samples((nb_samples,), random_state=ia.new_random_state(seed + 50)),
            )
        else:
            translate_samples = self.translate.draw_samples((nb_samples,), random_state=ia.new_random_state(seed + 60))
            translate_samples = (translate_samples, translate_samples)

        ia.do_assert(translate_samples[0].dtype in [np.int32, np.int64, np.float32, np.float64])
        ia.do_assert(translate_samples[1].dtype in [np.int32, np.int64, np.float32, np.float64])
</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 3:</b> &nbsp; 2 fragments, nominal size 30 lines, similarity 76%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag40')" href="javascript:;">
imgaug-0.2.7/imgaug/augmenters/geometric.py: 692-728
</a>
<div class="mid" id="frag40" style="display:none"><pre>
        # fit output image in new shape
        translation = (-minc, -minr)
        matrix_to_fit = tf.SimilarityTransform(translation=translation)
        matrix = matrix + matrix_to_fit
        return matrix, output_shape

    def _warp_skimage(self, image, scale_x, scale_y, translate_x_px, translate_y_px, rotate, shear, cval, mode, order,
                      fit_output, return_matrix=False):
        height, width = image.shape[0], image.shape[1]
        shift_x = width / 2.0 - 0.5
        shift_y = height / 2.0 - 0.5

        matrix_to_topleft = tf.SimilarityTransform(translation=[-shift_x, -shift_y])
        matrix_transforms = tf.AffineTransform(
            scale=(scale_x, scale_y),
            translation=(translate_x_px, translate_y_px),
            rotation=math.radians(rotate),
            shear=math.radians(shear)
        )
        matrix_to_center = tf.SimilarityTransform(translation=[shift_x, shift_y])
        matrix = (matrix_to_topleft + matrix_transforms + matrix_to_center)

        output_shape = None
        if fit_output:
            matrix, output_shape = self._tf_to_fit_output(image.shape, matrix)

        image_warped = tf.warp(
            image,
            matrix.inverse,
            order=order,
            mode=mode,
            cval=cval,
            preserve_range=True,
            output_shape=output_shape,
        )
        # warp changes uint8 to float64, making this necessary
        if image_warped.dtype != image.dtype:
</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag41')" href="javascript:;">
imgaug-0.2.7/imgaug/augmenters/geometric.py: 729-767
</a>
<div class="mid" id="frag41" style="display:none"><pre>
            image_warped = image_warped.astype(image.dtype, copy=False)

        if return_matrix:
            return image_warped, matrix
        return image_warped

    def _warp_cv2(self, image, scale_x, scale_y, translate_x_px, translate_y_px, rotate, shear, cval, mode, order,
                  fit_output, return_matrix=False):
        height, width = image.shape[0], image.shape[1]
        shift_x = width / 2.0 - 0.5
        shift_y = height / 2.0 - 0.5

        matrix_to_topleft = tf.SimilarityTransform(translation=[-shift_x, -shift_y])
        matrix_transforms = tf.AffineTransform(
            scale=(scale_x, scale_y),
            translation=(translate_x_px, translate_y_px),
            rotation=math.radians(rotate),
            shear=math.radians(shear)
        )
        matrix_to_center = tf.SimilarityTransform(translation=[shift_x, shift_y])
        matrix = (matrix_to_topleft + matrix_transforms + matrix_to_center)

        dsize = (width, height)
        if fit_output:
            matrix, output_shape = self._tf_to_fit_output(image.shape, matrix)
            dsize = (int(np.round(output_shape[1])), int(np.round(output_shape[0])))

        image_warped = cv2.warpAffine(
            image,
            matrix.params[:2],
            dsize=dsize,
            flags=order,
            borderMode=mode,
            borderValue=cval
        )

        # cv2 warp drops last axis if shape is (H, W, 1)
        if image_warped.ndim == 2:
            image_warped = image_warped[..., np.newaxis]
</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 4:</b> &nbsp; 2 fragments, nominal size 22 lines, similarity 86%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag120')" href="javascript:;">
imgaug-0.2.7/imgaug/augmenters/convolutional.py: 171-252
</a>
<div class="mid" id="frag120" style="display:none"><pre>
def Sharpen(alpha=0, lightness=1, name=None, deterministic=False, random_state=None):
    """
    Augmenter that sharpens images and overlays the result with the original image.

    Parameters
    ----------
    alpha : number or tuple of number or list of number or imgaug.parameters.StochasticParameter, optional
        Visibility of the sharpened image. At 0, only the original image is
        visible, at 1.0 only its sharpened version is visible.

            * If an int or float, exactly that value will be used.
            * If a tuple ``(a, b)``, a random value from the range ``a &lt;= x &lt;= b`` will
              be sampled per image.
            * If a list, then a random value will be sampled from that list
              per image.
            * If a StochasticParameter, a value will be sampled from the
              parameter per image.

    lightness : number or tuple of number or list of number or imgaug.parameters.StochasticParameter, optional
        Parameter that controls the lightness/brightness of the sharped image.
        Sane values are somewhere in the range ``(0.5, 2)``.
        The value 0 results in an edge map. Values higher than 1 create bright
        images. Default value is 1.

            * If an int or float, exactly that value will be used.
            * If a tuple ``(a, b)``, a random value from the range ``a &lt;= x &lt;= b`` will
              be sampled per image.
            * If a list, then a random value will be sampled from that list
              per image.
            * If a StochasticParameter, a value will be sampled from the
              parameter per image.

    name : None or str, optional
        See :func:`imgaug.augmenters.meta.Augmenter.__init__`.

    deterministic : bool, optional
        See :func:`imgaug.augmenters.meta.Augmenter.__init__`.

    random_state : None or int or numpy.random.RandomState, optional
        See :func:`imgaug.augmenters.meta.Augmenter.__init__`.

    Examples
    --------
    &gt;&gt;&gt; aug = Sharpen(alpha=(0.0, 1.0))

    sharpens input images and overlays the sharpened image by a variable
    amount over the old image.

    &gt;&gt;&gt; aug = Sharpen(alpha=(0.0, 1.0), lightness=(0.75, 2.0))

    sharpens input images with a variable lightness in the range
    ``0.75 &lt;= x &lt;= 2.0`` and with a variable alpha.

    """
    alpha_param = iap.handle_continuous_param(alpha, "alpha", value_range=(0, 1.0), tuple_to_uniform=True,
                                              list_to_choice=True)
    lightness_param = iap.handle_continuous_param(lightness, "lightness", value_range=(0, None), tuple_to_uniform=True,
                                                  list_to_choice=True)

    def create_matrices(image, nb_channels, random_state_func):
        alpha_sample = alpha_param.draw_sample(random_state=random_state_func)
        ia.do_assert(0 &lt;= alpha_sample &lt;= 1.0)
        lightness_sample = lightness_param.draw_sample(random_state=random_state_func)
        matrix_nochange = np.array([
            [0, 0, 0],
            [0, 1, 0],
            [0, 0, 0]
        ], dtype=np.float32)
        matrix_effect = np.array([
            [-1, -1, -1],
            [-1, 8+lightness_sample, -1],
            [-1, -1, -1]
        ], dtype=np.float32)
        matrix = (1-alpha_sample) * matrix_nochange + alpha_sample * matrix_effect
        return [matrix] * nb_channels

    if name is None:
        name = "Unnamed%s" % (ia.caller_name(),)

    return Convolve(create_matrices, name=name, deterministic=deterministic, random_state=random_state)


</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag122')" href="javascript:;">
imgaug-0.2.7/imgaug/augmenters/convolutional.py: 253-334
</a>
<div class="mid" id="frag122" style="display:none"><pre>
def Emboss(alpha=0, strength=1, name=None, deterministic=False, random_state=None):
    """
    Augmenter that embosses images and overlays the result with the original
    image.

    The embossed version pronounces highlights and shadows,
    letting the image look as if it was recreated on a metal plate ("embossed").

    Parameters
    ----------
    alpha : number or tuple of number or list of number or imgaug.parameters.StochasticParameter, optional
        Visibility of the sharpened image. At 0, only the original image is
        visible, at 1.0 only its sharpened version is visible.

            * If an int or float, exactly that value will be used.
            * If a tuple ``(a, b)``, a random value from the range ``a &lt;= x &lt;= b`` will
              be sampled per image.
            * If a list, then a random value will be sampled from that list
              per image.
            * If a StochasticParameter, a value will be sampled from the
              parameter per image.

    strength : number or tuple of number or list of number or imgaug.parameters.StochasticParameter, optional
        Parameter that controls the strength of the embossing.
        Sane values are somewhere in the range ``(0, 2)`` with 1 being the standard
        embossing effect. Default value is 1.

            * If an int or float, exactly that value will be used.
            * If a tuple ``(a, b)``, a random value from the range ``a &lt;= x &lt;= b`` will
              be sampled per image.
            * If a list, then a random value will be sampled from that list
              per image.
            * If a StochasticParameter, a value will be sampled from the
              parameter per image.

    name : None or str, optional
        See :func:`imgaug.augmenters.meta.Augmenter.__init__`.

    deterministic : bool, optional
        See :func:`imgaug.augmenters.meta.Augmenter.__init__`.

    random_state : None or int or numpy.random.RandomState, optional
        See :func:`imgaug.augmenters.meta.Augmenter.__init__`.

    Examples
    --------
    &gt;&gt;&gt; aug = Emboss(alpha=(0.0, 1.0), strength=(0.5, 1.5))

    embosses an image with a variable strength in the range ``0.5 &lt;= x &lt;= 1.5``
    and overlays the result with a variable alpha in the range ``0.0 &lt;= a &lt;= 1.0``
    over the old image.

    """
    alpha_param = iap.handle_continuous_param(alpha, "alpha", value_range=(0, 1.0), tuple_to_uniform=True,
                                              list_to_choice=True)
    strength_param = iap.handle_continuous_param(strength, "strength", value_range=(0, None), tuple_to_uniform=True,
                                                 list_to_choice=True)

    def create_matrices(image, nb_channels, random_state_func):
        alpha_sample = alpha_param.draw_sample(random_state=random_state_func)
        ia.do_assert(0 &lt;= alpha_sample &lt;= 1.0)
        strength_sample = strength_param.draw_sample(random_state=random_state_func)
        matrix_nochange = np.array([
            [0, 0, 0],
            [0, 1, 0],
            [0, 0, 0]
        ], dtype=np.float32)
        matrix_effect = np.array([
            [-1-strength_sample, 0-strength_sample, 0],
            [0-strength_sample, 1, 0+strength_sample],
            [0, 0+strength_sample, 1+strength_sample]
        ], dtype=np.float32)
        matrix = (1-alpha_sample) * matrix_nochange + alpha_sample * matrix_effect
        return [matrix] * nb_channels

    if name is None:
        name = "Unnamed%s" % (ia.caller_name(),)

    return Convolve(create_matrices, name=name, deterministic=deterministic, random_state=random_state)


# TODO tests
</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 5:</b> &nbsp; 3 fragments, nominal size 14 lines, similarity 71%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag121')" href="javascript:;">
imgaug-0.2.7/imgaug/augmenters/convolutional.py: 230-246
</a>
<div class="mid" id="frag121" style="display:none"><pre>
    def create_matrices(image, nb_channels, random_state_func):
        alpha_sample = alpha_param.draw_sample(random_state=random_state_func)
        ia.do_assert(0 &lt;= alpha_sample &lt;= 1.0)
        lightness_sample = lightness_param.draw_sample(random_state=random_state_func)
        matrix_nochange = np.array([
            [0, 0, 0],
            [0, 1, 0],
            [0, 0, 0]
        ], dtype=np.float32)
        matrix_effect = np.array([
            [-1, -1, -1],
            [-1, 8+lightness_sample, -1],
            [-1, -1, -1]
        ], dtype=np.float32)
        matrix = (1-alpha_sample) * matrix_nochange + alpha_sample * matrix_effect
        return [matrix] * nb_channels

</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag125')" href="javascript:;">
imgaug-0.2.7/imgaug/augmenters/convolutional.py: 375-390
</a>
<div class="mid" id="frag125" style="display:none"><pre>
    def create_matrices(_image, nb_channels, random_state_func):
        alpha_sample = alpha_param.draw_sample(random_state=random_state_func)
        ia.do_assert(0 &lt;= alpha_sample &lt;= 1.0)
        matrix_nochange = np.array([
            [0, 0, 0],
            [0, 1, 0],
            [0, 0, 0]
        ], dtype=np.float32)
        matrix_effect = np.array([
            [0, 1, 0],
            [1, -4, 1],
            [0, 1, 0]
        ], dtype=np.float32)
        matrix = (1-alpha_sample) * matrix_nochange + alpha_sample * matrix_effect
        return [matrix] * nb_channels

</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag123')" href="javascript:;">
imgaug-0.2.7/imgaug/augmenters/convolutional.py: 311-327
</a>
<div class="mid" id="frag123" style="display:none"><pre>
    def create_matrices(image, nb_channels, random_state_func):
        alpha_sample = alpha_param.draw_sample(random_state=random_state_func)
        ia.do_assert(0 &lt;= alpha_sample &lt;= 1.0)
        strength_sample = strength_param.draw_sample(random_state=random_state_func)
        matrix_nochange = np.array([
            [0, 0, 0],
            [0, 1, 0],
            [0, 0, 0]
        ], dtype=np.float32)
        matrix_effect = np.array([
            [-1-strength_sample, 0-strength_sample, 0],
            [0-strength_sample, 1, 0+strength_sample],
            [0, 0+strength_sample, 1+strength_sample]
        ], dtype=np.float32)
        matrix = (1-alpha_sample) * matrix_nochange + alpha_sample * matrix_effect
        return [matrix] * nb_channels

</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 6:</b> &nbsp; 4 fragments, nominal size 41 lines, similarity 71%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag130')" href="javascript:;">
imgaug-0.2.7/imgaug/augmenters/overlay.py: 222-270
</a>
<div class="mid" id="frag130" style="display:none"><pre>
    def _augment_heatmaps(self, heatmaps, random_state, parents, hooks):
        result = heatmaps
        nb_heatmaps = len(heatmaps)
        seeds = random_state.randint(0, 10**6, (nb_heatmaps,))

        if hooks.is_propagating(heatmaps, augmenter=self, parents=parents, default=True):
            if self.first is None:
                heatmaps_first = heatmaps
            else:
                heatmaps_first = self.first.augment_heatmaps(
                    heatmaps,
                    parents=parents + [self],
                    hooks=hooks
                )

            if self.second is None:
                heatmaps_second = heatmaps
            else:
                heatmaps_second = self.second.augment_heatmaps(
                    heatmaps,
                    parents=parents + [self],
                    hooks=hooks
                )
        else:
            heatmaps_first = heatmaps
            heatmaps_second = heatmaps

        for i in sm.xrange(nb_heatmaps):
            heatmaps_first_i = heatmaps_first[i]
            heatmaps_second_i = heatmaps_second[i]
            rs_image = ia.new_random_state(seeds[i])
            # sample alphas channelwise if necessary and try to use the image's channel number
            # values properly synchronized with the image augmentation
            per_channel = self.per_channel.draw_sample(random_state=rs_image)
            if per_channel == 1:
                nb_channels = heatmaps[i].shape[2] if len(heatmaps[i].shape) &gt;= 3 else 1
                samples = self.factor.draw_samples((nb_channels,), random_state=rs_image)
                sample = np.average(samples)
            else:
                sample = self.factor.draw_sample(random_state=rs_image)
                ia.do_assert(0 &lt;= sample &lt;= 1.0)

            mask = sample &gt;= 0.5
            heatmaps_arr_aug = mask * heatmaps_first_i.arr_0to1 + (~mask) * heatmaps_second_i.arr_0to1

            result[i].arr_0to1 = heatmaps_arr_aug

        return result

</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag131')" href="javascript:;">
imgaug-0.2.7/imgaug/augmenters/overlay.py: 271-325
</a>
<div class="mid" id="frag131" style="display:none"><pre>
    def _augment_keypoints(self, keypoints_on_images, random_state, parents, hooks):
        result = keypoints_on_images
        nb_images = len(keypoints_on_images)
        seeds = random_state.randint(0, 10**6, (nb_images,))

        if hooks.is_propagating(keypoints_on_images, augmenter=self, parents=parents, default=True):
            if self.first is None:
                kps_ois_first = keypoints_on_images
            else:
                kps_ois_first = self.first.augment_keypoints(
                    keypoints_on_images=keypoints_on_images,
                    parents=parents + [self],
                    hooks=hooks
                )

            if self.second is None:
                kps_ois_second = keypoints_on_images
            else:
                kps_ois_second = self.second.augment_keypoints(
                    keypoints_on_images=keypoints_on_images,
                    parents=parents + [self],
                    hooks=hooks
                )
        else:
            kps_ois_first = keypoints_on_images
            kps_ois_second = keypoints_on_images

        for i in sm.xrange(nb_images):
            kps_oi_first = kps_ois_first[i]
            kps_oi_second = kps_ois_second[i]
            rs_image = ia.new_random_state(seeds[i])
            # keypoint augmentation also works channel-wise, even though
            # keypoints do not have channels, in order to keep the random
            # values properly synchronized with the image augmentation
            per_channel = self.per_channel.draw_sample(random_state=rs_image)
            if per_channel == 1:
                nb_channels = keypoints_on_images[i].shape[2]
                samples = self.factor.draw_samples((nb_channels,), random_state=rs_image)
                sample = np.average(samples)
            else:
                sample = self.factor.draw_sample(random_state=rs_image)
                ia.do_assert(0 &lt;= sample &lt;= 1.0)

            # We cant choose "just a bit" of one keypoint augmentation result
            # without messing up the positions (interpolation doesn't make much
            # sense here),
            # so if the alpha is &gt;= 0.5 (branch A is more visible than
            # branch B), the result of branch A, otherwise branch B.
            if sample &gt;= 0.5:
                result[i] = kps_oi_first
            else:
                result[i] = kps_oi_second

        return result

</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag139')" href="javascript:;">
imgaug-0.2.7/imgaug/augmenters/overlay.py: 577-643
</a>
<div class="mid" id="frag139" style="display:none"><pre>
    def _augment_keypoints(self, keypoints_on_images, random_state, parents, hooks):
        result = keypoints_on_images
        nb_images = len(keypoints_on_images)
        seeds = random_state.randint(0, 10**6, (nb_images,))

        if hooks.is_propagating(keypoints_on_images, augmenter=self, parents=parents, default=True):
            if self.first is None:
                kps_ois_first = keypoints_on_images
            else:
                kps_ois_first = self.first.augment_keypoints(
                    keypoints_on_images=keypoints_on_images,
                    parents=parents + [self],
                    hooks=hooks
                )

            if self.second is None:
                kps_ois_second = keypoints_on_images
            else:
                kps_ois_second = self.second.augment_keypoints(
                    keypoints_on_images=keypoints_on_images,
                    parents=parents + [self],
                    hooks=hooks
                )
        else:
            kps_ois_first = keypoints_on_images
            kps_ois_second = keypoints_on_images

        # FIXME this is essentially the same behaviour as Alpha, requires inclusion of (x, y) coordinates to estimate
        # new keypoint coordinates
        for i in sm.xrange(nb_images):
            kps_oi_first = kps_ois_first[i]
            kps_oi_second = kps_ois_second[i]
            ia.do_assert(
                len(kps_oi_first.shape) == 3,
                ("Keypoint augmentation in AlphaElementwise requires KeypointsOnImage.shape to have channel "
                 + "information (i.e. tuple with 3 entries), which you did not provide (input shape: %s). The"
                   "channels must match the corresponding image channels.") % (kps_oi_first.shape,)
            )
            h, w, nb_channels = kps_oi_first.shape[0:3]

            # keypoint augmentation also works channel-wise, even though
            # keypoints do not have channels, in order to keep the random
            # values properly synchronized with the image augmentation
            per_channel = self.per_channel.draw_sample(random_state=ia.new_random_state(seeds[i]))
            if per_channel == 1:
                samples = np.zeros((h, w, nb_channels), dtype=np.float32)
                for c in sm.xrange(nb_channels):
                    samples_c = self.factor.draw_samples((h, w), random_state=ia.new_random_state(seeds[i]+1+c))
                    samples[:, :, c] = samples_c
            else:
                samples = self.factor.draw_samples((h, w), random_state=ia.new_random_state(seeds[i]))
            ia.do_assert(0.0 &lt;= samples.item(0) &lt;= 1.0)
            sample = np.average(samples)

            # We cant choose "just a bit" of one keypoint augmentation result
            # without messing up the positions (interpolation doesn't make much
            # sense here),
            # so if the alpha is &gt;= 0.5 (branch A is more visible than
            # branch B), the result of branch A, otherwise branch B.
            if sample &gt;= 0.5:
                result[i] = kps_oi_first
            else:
                result[i] = kps_oi_second

        return result


</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag136')" href="javascript:;">
imgaug-0.2.7/imgaug/augmenters/overlay.py: 455-507
</a>
<div class="mid" id="frag136" style="display:none"><pre>
    def _augment_images(self, images, random_state, parents, hooks):
        result = images
        nb_images = len(images)
        seeds = random_state.randint(0, 10**6, (nb_images,))

        if hooks.is_propagating(images, augmenter=self, parents=parents, default=True):
            if self.first is None:
                images_first = images
            else:
                images_first = self.first.augment_images(
                    images=images,
                    parents=parents + [self],
                    hooks=hooks
                )

            if self.second is None:
                images_second = images
            else:
                images_second = self.second.augment_images(
                    images=images,
                    parents=parents + [self],
                    hooks=hooks
                )
        else:
            images_first = images
            images_second = images

        for i in sm.xrange(nb_images):
            image = images[i]
            h, w, nb_channels = image.shape[0:3]
            image_first = images_first[i]
            image_second = images_second[i]
            per_channel = self.per_channel.draw_sample(random_state=ia.new_random_state(seeds[i]))
            input_dtype = image.dtype
            if per_channel == 1:
                for c in sm.xrange(nb_channels):
                    samples_c = self.factor.draw_samples((h, w), random_state=ia.new_random_state(seeds[i]+1+c))
                    ia.do_assert(0 &lt;= samples_c.item(0) &lt;= 1.0) # validate only first value
                    image[..., c] = samples_c * image_first[..., c] + (1.0 - samples_c) * image_second[..., c]
                # TODO change this to meta.clip_* and meta.restore_*
                np.clip(image, 0, 255, out=image)
                result[i] = image.astype(input_dtype)
            else:
                samples = self.factor.draw_samples((h, w), random_state=ia.new_random_state(seeds[i]))
                samples = np.tile(samples[..., np.newaxis], (1, 1, nb_channels))
                ia.do_assert(0.0 &lt;= samples.item(0) &lt;= 1.0)

                image = samples * image_first + (1.0 - samples) * image_second
                # TODO change this to meta.clip_* and meta.restore_*
                np.clip(image, 0, 255, out=image)
                result[i] = image.astype(input_dtype)
        return result

</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 7:</b> &nbsp; 2 fragments, nominal size 25 lines, similarity 80%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag140')" href="javascript:;">
imgaug-0.2.7/imgaug/augmenters/overlay.py: 644-825
</a>
<div class="mid" id="frag140" style="display:none"><pre>
def SimplexNoiseAlpha(first=None, second=None, per_channel=False, size_px_max=(2, 16), upscale_method=None,
                      iterations=(1, 3), aggregation_method="max", sigmoid=True, sigmoid_thresh=None,
                      name=None, deterministic=False, random_state=None):
    """
    Augmenter to overlay two image sources with each other using alpha values
    that follow noisy patterns.

    The alpha masks are sampled using a simplex noise method, roughly creating
    connected blobs of 1s surrounded by 0s. If nearest neighbour upsampling
    is used, these blobs can be rectangular with sharp edges.

    Parameters
    ----------
    first : None or imgaug.augmenters.meta.Augmenter or iterable of imgaug.augmenters.meta.Augmenter, optional
        Augmenter(s) that make up the first of the two branches.

            * If None, then the input images will be reused as the output
              of the first branch.
            * If Augmenter, then that augmenter will be used as the branch.
            * If iterable of Augmenter, then that iterable will be converted
              into a Sequential and used as the augmenter.

    second : None or imgaug.augmenters.meta.Augmenter or iterable of imgaug.augmenters.meta.Augmenter, optional
        Augmenter(s) that make up the second of the two branches.

            * If None, then the input images will be reused as the output
              of the second branch.
            * If Augmenter, then that augmenter will be used as the branch.
            * If iterable of Augmenter, then that iterable will be converted
              into a Sequential and used as the augmenter.

    per_channel : bool or float, optional
        Whether to use the same factor for all channels (False)
        or to sample a new value for each channel (True).
        If this value is a float ``p``, then for ``p`` percent of all images
        `per_channel` will be treated as True, otherwise as False.

    size_px_max : int or tuple of int or list of int or imgaug.parameters.StochasticParameter, optional
        The simplex noise is always generated in a low resolution environment.
        This parameter defines the maximum size of that environment (in
        pixels). The environment is initialized at the same size as the input
        image and then downscaled, so that no side exceeds `size_px_max`
        (aspect ratio is kept).

            * If int, then that number will be used as the size for all
              iterations.
            * If tuple of two ints ``(a, b)``, then a value will be sampled
              per iteration from the discrete range ``[a..b]``.
            * If a list of ints, then a value will be picked per iteration at
              random from that list.
            * If a StochasticParameter, then a value will be sampled from
              that parameter per iteration.

    upscale_method : None or imgaug.ALL or str or list of str or imgaug.parameters.StochasticParameter, optional
        After generating the noise maps in low resolution environments, they
        have to be upscaled to the input image size. This parameter controls
        the upscaling method.

            * If None, then either ``nearest`` or ``linear`` or ``cubic`` is picked.
              Most weight is put on linear, followed by cubic.
            * If ia.ALL, then either ``nearest`` or ``linear`` or ``area`` or ``cubic``
              is picked per iteration (all same probability).
            * If string, then that value will be used as the method (must be
              'nearest' or ``linear`` or ``area`` or ``cubic``).
            * If list of string, then a random value will be picked from that
              list per iteration.
            * If StochasticParameter, then a random value will be sampled
              from that parameter per iteration.

    iterations : int or tuple of int or list of int or imgaug.parameters.StochasticParameter, optional
        How often to repeat the simplex noise generation process per image.

            * If int, then that number will be used as the iterations for all
              images.
            * If tuple of two ints ``(a, b)``, then a value will be sampled
              per image from the discrete range ``[a..b]``.
            * If a list of ints, then a value will be picked per image at
              random from that list.
            * If a StochasticParameter, then a value will be sampled from
              that parameter per image.

    aggregation_method : imgaug.ALL or str or list of str or imgaug.parameters.StochasticParameter, optional
        The noise maps (from each iteration) are combined to one noise map
        using an aggregation process. This parameter defines the method used
        for that process. Valid methods are ``min``, ``max`` or ``avg``,
        where ``min`` combines the noise maps by taking the (elementwise) minimum
        over all iteration's results, ``max`` the (elementwise) maximum and
        ``avg`` the (elementwise) average.

            * If imgaug.ALL, then a random value will be picked per image from the
              valid ones.
            * If a string, then that value will always be used as the method.
            * If a list of string, then a random value will be picked from
              that list per image.
            * If a StochasticParameter, then a random value will be sampled
              from that paramter per image.

    sigmoid : bool or number, optional
        Whether to apply a sigmoid function to the final noise maps, resulting
        in maps that have more extreme values (close to 0.0 or 1.0).

            * If bool, then a sigmoid will always (True) or never (False) be
              applied.
            * If a number ``p`` with ``0&lt;=p&lt;=1``, then a sigmoid will be applied to
              ``p`` percent of all final noise maps.

    sigmoid_thresh : None or number or tuple of number or imgaug.parameters.StochasticParameter, optional
        Threshold of the sigmoid, when applied. Thresholds above zero
        (e.g. 5.0) will move the saddle point towards the right, leading to
        more values close to 0.0.

            * If None, then ``Normal(0, 5.0)`` will be used.
            * If number, then that threshold will be used for all images.
            * If tuple of two numbers ``(a, b)``, then a random value will
              be sampled per image from the range ``[a, b]``.
            * If StochasticParameter, then a random value will be sampled from
              that parameter per image.

    name : None or str, optional
        See :func:`imgaug.augmenters.meta.Augmenter.__init__`.

    deterministic : bool, optional
        See :func:`imgaug.augmenters.meta.Augmenter.__init__`.

    random_state : None or int or numpy.random.RandomState, optional
        See :func:`imgaug.augmenters.meta.Augmenter.__init__`.

    Examples
    --------
    &gt;&gt;&gt; aug = iaa.SimplexNoiseAlpha(iaa.EdgeDetect(1.0))

    Detects per image all edges, marks them in a black and white image and
    then overlays the result with the original image using simplex noise masks.

    &gt;&gt;&gt; aug = iaa.SimplexNoiseAlpha(iaa.EdgeDetect(1.0), upscale_method="linear")

    Same as the first example, but uses only (smooth) linear upscaling to
    scale the simplex noise masks to the final image sizes, i.e. no nearest
    neighbour upsampling is used, which would result in rectangles with hard
    edges.

    &gt;&gt;&gt; aug = iaa.SimplexNoiseAlpha(iaa.EdgeDetect(1.0), sigmoid_thresh=iap.Normal(10.0, 5.0))

    Same as the first example, but uses a threshold for the sigmoid function
    that is further to the right. This is more conservative, i.e. the generated
    noise masks will be mostly black (values around 0.0), which means that
    most of the original images (parameter/branch `second`) will be kept,
    rather than using the results of the augmentation (parameter/branch
    `first`).

    """
    upscale_method_default = iap.Choice(["nearest", "linear", "cubic"], p=[0.05, 0.6, 0.35])
    sigmoid_thresh_default = iap.Normal(0.0, 5.0)

    noise = iap.SimplexNoise(
        size_px_max=size_px_max,
        upscale_method=upscale_method if upscale_method is not None else upscale_method_default
    )

    if iterations != 1:
        noise = iap.IterativeNoiseAggregator(
            noise,
            iterations=iterations,
            aggregation_method=aggregation_method
        )

    if sigmoid is False or (ia.is_single_number(sigmoid) and sigmoid &lt;= 0.01):
        noise = iap.Sigmoid.create_for_noise(
            noise,
            threshold=sigmoid_thresh if sigmoid_thresh is not None else sigmoid_thresh_default,
            activated=sigmoid
        )

    if name is None:
        name = "Unnamed%s" % (ia.caller_name(),)

    return AlphaElementwise(
        factor=noise, first=first, second=second, per_channel=per_channel,
        name=name, deterministic=deterministic, random_state=random_state
    )


</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag141')" href="javascript:;">
imgaug-0.2.7/imgaug/augmenters/overlay.py: 826-1032
</a>
<div class="mid" id="frag141" style="display:none"><pre>
def FrequencyNoiseAlpha(exponent=(-4, 4), first=None, second=None, per_channel=False,
                        size_px_max=(4, 16), upscale_method=None,
                        iterations=(1, 3), aggregation_method=["avg", "max"],
                        sigmoid=0.5, sigmoid_thresh=None,
                        name=None, deterministic=False, random_state=None):
    """
    Augmenter to overlay two image sources with each other using alpha values
    that follow noisy patterns.

    The alpha masks are sampled using frequency noise of varying scales,
    which can sometimes create large connected blobs of 1s surrounded by 0s
    and other times results in smaller patterns. If nearest neighbour
    upsampling is used, these blobs can be rectangular with sharp edges.

    Parameters
    ----------
    exponent : number or tuple of number of list of number or imgaug.parameters.StochasticParameter, optional
        Exponent to use when scaling in the frequency domain.
        Sane values are in the range -4 (large blobs) to 4 (small patterns).
        To generate cloud-like structures, use roughly -2.

            * If number, then that number will be used as the exponent for all
              iterations.
            * If tuple of two numbers ``(a, b)``, then a value will be sampled
              per iteration from the range ``[a, b]``.
            * If a list of numbers, then a value will be picked per iteration
              at random from that list.
            * If a StochasticParameter, then a value will be sampled from
              that parameter per iteration.

    first : None or imgaug.augmenters.meta.Augmenter or iterable of imgaug.augmenters.meta.Augmenter, optional
        Augmenter(s) that make up the first of the two branches.

            * If None, then the input images will be reused as the output
              of the first branch.
            * If Augmenter, then that augmenter will be used as the branch.
            * If iterable of Augmenter, then that iterable will be converted
              into a Sequential and used as the augmenter.

    second : None or imgaug.augmenters.meta.Augmenter or iterable of imgaug.augmenters.meta.Augmenter, optional
        Augmenter(s) that make up the second of the two branches.

            * If None, then the input images will be reused as the output
              of the second branch.
            * If Augmenter, then that augmenter will be used as the branch.
            * If iterable of Augmenter, then that iterable will be converted
              into a Sequential and used as the augmenter.

    per_channel : bool or float, optional
        Whether to use the same factor for all channels (False)
        or to sample a new value for each channel (True).
        If this value is a float ``p``, then for ``p`` percent of all images
        `per_channel` will be treated as True, otherwise as False.

    size_px_max : int or tuple of int or list of int or imgaug.parameters.StochasticParameter, optional
        The noise is generated in a low resolution environment.
        This parameter defines the maximum size of that environment (in
        pixels). The environment is initialized at the same size as the input
        image and then downscaled, so that no side exceeds `size_px_max`
        (aspect ratio is kept).

            * If int, then that number will be used as the size for all
              iterations.
            * If tuple of two ints ``(a, b)``, then a value will be sampled
              per iteration from the discrete range ``[a..b]``.
            * If a list of ints, then a value will be picked per iteration at
              random from that list.
            * If a StochasticParameter, then a value will be sampled from
              that parameter per iteration.

    upscale_method : None or imgaug.ALL or str or list of str or imgaug.parameters.StochasticParameter, optional
        After generating the noise maps in low resolution environments, they
        have to be upscaled to the input image size. This parameter controls
        the upscaling method.

            * If None, then either ``nearest`` or ``linear`` or ``cubic`` is picked.
              Most weight is put on linear, followed by cubic.
            * If imgaug.ALL, then either ``nearest`` or ``linear`` or ``area`` or ``cubic``
              is picked per iteration (all same probability).
            * If string, then that value will be used as the method (must be
              ``nearest`` or ``linear`` or ``area`` or ``cubic``).
            * If list of string, then a random value will be picked from that
              list per iteration.
            * If StochasticParameter, then a random value will be sampled
              from that parameter per iteration.

    iterations : int or tuple of int or list of int or imgaug.parameters.StochasticParameter, optional
        How often to repeat the simplex noise generation process per
        image.

            * If int, then that number will be used as the iterations for all
              images.
            * If tuple of two ints ``(a, b)``, then a value will be sampled
              per image from the discrete range ``[a..b]``.
            * If a list of ints, then a value will be picked per image at
              random from that list.
            * If a StochasticParameter, then a value will be sampled from
              that parameter per image.

    aggregation_method : imgaug.ALL or str or list of str or imgaug.parameters.StochasticParameter, optional
        The noise maps (from each iteration) are combined to one noise map
        using an aggregation process. This parameter defines the method used
        for that process. Valid methods are ``min``, ``max`` or ``avg``,
        where 'min' combines the noise maps by taking the (elementwise) minimum
        over all iteration's results, ``max`` the (elementwise) maximum and
        ``avg`` the (elementwise) average.

            * If imgaug.ALL, then a random value will be picked per image from the
              valid ones.
            * If a string, then that value will always be used as the method.
            * If a list of string, then a random value will be picked from
              that list per image.
            * If a StochasticParameter, then a random value will be sampled
              from that parameter per image.

    sigmoid : bool or number, optional
        Whether to apply a sigmoid function to the final noise maps, resulting
        in maps that have more extreme values (close to 0.0 or 1.0).

            * If bool, then a sigmoid will always (True) or never (False) be
              applied.
            * If a number ``p`` with ``0&lt;=p&lt;=1``, then a sigmoid will be applied to
              ``p`` percent of all final noise maps.

    sigmoid_thresh : None or number or tuple of number or imgaug.parameters.StochasticParameter, optional
        Threshold of the sigmoid, when applied. Thresholds above zero
        (e.g. 5.0) will move the saddle point towards the right, leading to
        more values close to 0.0.

            * If None, then ``Normal(0, 5.0)`` will be used.
            * If number, then that threshold will be used for all images.
            * If tuple of two numbers ``(a, b)``, then a random value will
              be sampled per image from the range ``[a, b]``.
            * If StochasticParameter, then a random value will be sampled from
              that parameter per image.

    name : None or str, optional
        See :func:`imgaug.augmenters.meta.Augmenter.__init__`.

    deterministic : bool, optional
        See :func:`imgaug.augmenters.meta.Augmenter.__init__`.

    random_state : None or int or numpy.random.RandomState, optional
        See :func:`imgaug.augmenters.meta.Augmenter.__init__`.

    Examples
    --------
    &gt;&gt;&gt; aug = iaa.FrequencyNoiseAlpha(first=iaa.EdgeDetect(1.0))

    Detects per image all edges, marks them in a black and white image and
    then overlays the result with the original image using frequency noise
    masks.

    &gt;&gt;&gt; aug = iaa.FrequencyNoiseAlpha(first=iaa.EdgeDetect(1.0), upscale_method="linear")

    Same as the first example, but uses only (smooth) linear upscaling to
    scale the frequency noise masks to the final image sizes, i.e. no nearest
    neighbour upsampling is used, which would result in rectangles with hard
    edges.

    &gt;&gt;&gt; aug = iaa.FrequencyNoiseAlpha(first=iaa.EdgeDetect(1.0), upscale_method="linear", exponent=-2, sigmoid=False)

    Same as the previous example, but also limits the exponent to -2 and
    deactivates the sigmoid, resulting in cloud-like patterns without sharp
    edges.

    &gt;&gt;&gt; aug = iaa.FrequencyNoiseAlpha(first=iaa.EdgeDetect(1.0), sigmoid_thresh=iap.Normal(10.0, 5.0))

    Same as the first example, but uses a threshold for the sigmoid function
    that is further to the right. This is more conservative, i.e. the generated
    noise masks will be mostly black (values around 0.0), which means that
    most of the original images (parameter/branch `second`) will be kept,
    rather than using the results of the augmentation (parameter/branch
    `first`).

    """
    # pylint: disable=dangerous-default-value
    upscale_method_default = iap.Choice(["nearest", "linear", "cubic"], p=[0.05, 0.6, 0.35])
    sigmoid_thresh_default = iap.Normal(0.0, 5.0)

    noise = iap.FrequencyNoise(
        exponent=exponent,
        size_px_max=size_px_max,
        upscale_method=upscale_method if upscale_method is not None else upscale_method_default
    )

    if iterations != 1:
        noise = iap.IterativeNoiseAggregator(
            noise,
            iterations=iterations,
            aggregation_method=aggregation_method
        )

    if sigmoid is False or (ia.is_single_number(sigmoid) and sigmoid &lt;= 0.01):
        noise = iap.Sigmoid.create_for_noise(
            noise,
            threshold=sigmoid_thresh if sigmoid_thresh is not None else sigmoid_thresh_default,
            activated=sigmoid
        )

    if name is None:
        name = "Unnamed%s" % (ia.caller_name(),)

    return AlphaElementwise(
        factor=noise, first=first, second=second, per_channel=per_channel,
        name=name, deterministic=deterministic, random_state=random_state
    )
</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 8:</b> &nbsp; 3 fragments, nominal size 22 lines, similarity 73%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag143')" href="javascript:;">
imgaug-0.2.7/imgaug/augmenters/arithmetic.py: 114-142
</a>
<div class="mid" id="frag143" style="display:none"><pre>
    def _augment_images(self, images, random_state, parents, hooks):
        input_dtypes = meta.copy_dtypes_for_restore(images, force_list=True)

        result = images
        nb_images = len(images)
        seeds = random_state.randint(0, 10**6, (nb_images,))
        for i in sm.xrange(nb_images):
            image = images[i].astype(np.int32)
            rs_image = ia.new_random_state(seeds[i])
            per_channel = self.per_channel.draw_sample(random_state=rs_image)
            if per_channel == 1:
                nb_channels = image.shape[2]
                samples = self.value.draw_samples((nb_channels,), random_state=rs_image).astype(image.dtype)
                for c, sample in enumerate(samples):
                    # TODO make value range more flexible
                    ia.do_assert(-255 &lt;= sample &lt;= 255)
                    image[..., c] += sample
            else:
                sample = self.value.draw_sample(random_state=rs_image).astype(image.dtype)
                ia.do_assert(-255 &lt;= sample &lt;= 255)  # TODO make value range more flexible
                image += sample

            image = meta.clip_augmented_image_(image, 0, 255)  # TODO make value range more flexible
            image = meta.restore_augmented_image_dtype_(image, input_dtypes[i])

            result[i] = image

        return result

</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag156')" href="javascript:;">
imgaug-0.2.7/imgaug/augmenters/arithmetic.py: 556-583
</a>
<div class="mid" id="frag156" style="display:none"><pre>
        self.per_channel = iap.handle_probability_param(per_channel, "per_channel")

    def _augment_images(self, images, random_state, parents, hooks):
        input_dtypes = meta.copy_dtypes_for_restore(images, force_list=True)

        result = images
        nb_images = len(images)
        seeds = random_state.randint(0, 10**6, (nb_images,))
        for i in sm.xrange(nb_images):
            image = images[i].astype(np.float32)
            rs_image = ia.new_random_state(seeds[i])
            per_channel = self.per_channel.draw_sample(random_state=rs_image)
            if per_channel == 1:
                nb_channels = image.shape[2]
                samples = self.mul.draw_samples((nb_channels,), random_state=rs_image)
                for c, sample in enumerate(samples):
                    ia.do_assert(sample &gt;= 0)
                    image[..., c] *= sample
            else:
                sample = self.mul.draw_sample(random_state=rs_image)
                ia.do_assert(sample &gt;= 0)
                image *= sample

            image = meta.clip_augmented_image_(image, 0, 255)  # TODO make value range more flexible
            image = meta.restore_augmented_image_dtype_(image, input_dtypes[i])

            result[i] = image

</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag185')" href="javascript:;">
imgaug-0.2.7/imgaug/augmenters/arithmetic.py: 1703-1728
</a>
<div class="mid" id="frag185" style="display:none"><pre>
        self.per_channel = iap.handle_probability_param(per_channel, "per_channel")

    def _augment_images(self, images, random_state, parents, hooks):
        input_dtypes = meta.copy_dtypes_for_restore(images, force_list=True)

        result = images
        nb_images = len(images)
        seeds = random_state.randint(0, 10**6, (nb_images,))
        for i in sm.xrange(nb_images):
            image = images[i].astype(np.float32)
            rs_image = ia.new_random_state(seeds[i])
            per_channel = self.per_channel.draw_sample(random_state=rs_image)
            if per_channel:
                nb_channels = images[i].shape[2]
                alphas = self.alpha.draw_samples((nb_channels,), random_state=rs_image)
                for c, alpha in enumerate(alphas):
                    image[..., c] = alpha * (image[..., c] - 128) + 128
            else:
                alpha = self.alpha.draw_sample(random_state=rs_image)
                image = alpha * (image - 128) + 128

            image = meta.clip_augmented_image_(image, 0, 255) # TODO make value range more flexible
            image = meta.restore_augmented_image_dtype_(image, input_dtypes[i])

            result[i] = image

</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 9:</b> &nbsp; 2 fragments, nominal size 21 lines, similarity 85%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag148')" href="javascript:;">
imgaug-0.2.7/imgaug/augmenters/arithmetic.py: 219-244
</a>
<div class="mid" id="frag148" style="display:none"><pre>
    def _augment_images(self, images, random_state, parents, hooks):
        input_dtypes = meta.copy_dtypes_for_restore(images, force_list=True)

        result = images
        nb_images = len(images)
        seeds = random_state.randint(0, 10**6, (nb_images,))
        for i in sm.xrange(nb_images):
            seed = seeds[i]
            image = images[i].astype(np.int32)
            height, width, nb_channels = image.shape
            rs_image = ia.new_random_state(seed)
            per_channel = self.per_channel.draw_sample(random_state=rs_image)
            if per_channel == 1:
                samples = self.value\
                    .draw_samples((height, width, nb_channels), random_state=rs_image)\
                    .astype(image.dtype)
            else:
                samples = self.value.draw_samples((height, width, 1), random_state=rs_image).astype(image.dtype)
                samples = np.tile(samples, (1, 1, nb_channels))
            after_add = image + samples

            after_add = meta.clip_augmented_image_(after_add, 0, 255) # TODO make value range more flexible
            after_add = meta.restore_augmented_image_dtype_(after_add, input_dtypes[i])

            result[i] = after_add

</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag161')" href="javascript:;">
imgaug-0.2.7/imgaug/augmenters/arithmetic.py: 661-686
</a>
<div class="mid" id="frag161" style="display:none"><pre>
        self.per_channel = iap.handle_probability_param(per_channel, "per_channel")

    def _augment_images(self, images, random_state, parents, hooks):
        input_dtypes = meta.copy_dtypes_for_restore(images, force_list=True)

        result = images
        nb_images = len(images)
        seeds = random_state.randint(0, 10**6, (nb_images,))
        for i in sm.xrange(nb_images):
            seed = seeds[i]
            image = images[i].astype(np.float32)
            height, width, nb_channels = image.shape
            rs_image = ia.new_random_state(seed)
            per_channel = self.per_channel.draw_sample(random_state=rs_image)
            if per_channel == 1:
                samples = self.mul.draw_samples((height, width, nb_channels), random_state=rs_image)
            else:
                samples = self.mul.draw_samples((height, width, 1), random_state=rs_image)
                samples = np.tile(samples, (1, 1, nb_channels))
            image = image * samples

            image = meta.clip_augmented_image_(image, 0, 255) # TODO make value range more flexible
            image = meta.restore_augmented_image_dtype_(image, input_dtypes[i])

            result[i] = image

</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 10:</b> &nbsp; 2 fragments, nominal size 23 lines, similarity 76%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag237')" href="javascript:;">
imgaug-0.2.7/imgaug/imgaug.py: 705-747
</a>
<div class="mid" id="frag237" style="display:none"><pre>
def quokka_keypoints(size=None, extract=None):
    """
    Returns example keypoints on the standard example quokke image.

    The keypoints cover the eyes, ears, nose and paws.

    Parameters
    ----------
    size : None or float or tuple of int or tuple of float, optional
        Size of the output image on which the keypoints are placed. If None, then the keypoints
        are not projected to any new size (positions on the original image are used).
        Floats lead to relative size changes, ints to absolute sizes in pixels.

    extract : None or 'square' or tuple of number or imgaug.BoundingBox or imgaug.BoundingBoxesOnImage
        Subarea to extract from the image. See :func:`imgaug.quokka`.

    Returns
    -------
    kpsoi : imgaug.KeypointsOnImage
        Example keypoints on the quokka image.

    """
    left, top = 0, 0
    if extract is not None:
        bb_extract = _quokka_normalize_extract(extract)
        left = bb_extract.x1
        top = bb_extract.y1
    with open(QUOKKA_ANNOTATIONS_FP, "r") as f:
        json_dict = json.load(f)
    keypoints = []
    for kp_dict in json_dict["keypoints"]:
        keypoints.append(Keypoint(x=kp_dict["x"] - left, y=kp_dict["y"] - top))
    if extract is not None:
        shape = (bb_extract.height, bb_extract.width, 3)
    else:
        shape = (643, 960, 3)
    kpsoi = KeypointsOnImage(keypoints, shape=shape)
    if size is not None:
        shape_resized = _compute_resized_shape(shape, size)
        kpsoi = kpsoi.on(shape_resized)
    return kpsoi


</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag238')" href="javascript:;">
imgaug-0.2.7/imgaug/imgaug.py: 748-796
</a>
<div class="mid" id="frag238" style="display:none"><pre>
def quokka_bounding_boxes(size=None, extract=None):
    """
    Returns example bounding boxes on the standard example quokke image.

    Currently only a single bounding box is returned that covers the quokka.

    Parameters
    ----------
    size : None or float or tuple of int or tuple of float, optional
        Size of the output image on which the BBs are placed. If None, then the BBs
        are not projected to any new size (positions on the original image are used).
        Floats lead to relative size changes, ints to absolute sizes in pixels.

    extract : None or 'square' or tuple of number or imgaug.BoundingBox or imgaug.BoundingBoxesOnImage
        Subarea to extract from the image. See :func:`imgaug.quokka`.

    Returns
    -------
    bbsoi : imgaug.BoundingBoxesOnImage
        Example BBs on the quokka image.
    """
    left, top = 0, 0
    if extract is not None:
        bb_extract = _quokka_normalize_extract(extract)
        left = bb_extract.x1
        top = bb_extract.y1
    with open(QUOKKA_ANNOTATIONS_FP, "r") as f:
        json_dict = json.load(f)
    bbs = []
    for bb_dict in json_dict["bounding_boxes"]:
        bbs.append(
            BoundingBox(
                x1=bb_dict["x1"] - left,
                y1=bb_dict["y1"] - top,
                x2=bb_dict["x2"] - left,
                y2=bb_dict["y2"] - top
            )
        )
    if extract is not None:
        shape = (bb_extract.height, bb_extract.width, 3)
    else:
        shape = (643, 960, 3)
    bbsoi = BoundingBoxesOnImage(bbs, shape=shape)
    if size is not None:
        shape_resized = _compute_resized_shape(shape, size)
        bbsoi = bbsoi.on(shape_resized)
    return bbsoi


</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 11:</b> &nbsp; 2 fragments, nominal size 10 lines, similarity 100%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag273')" href="javascript:;">
imgaug-0.2.7/imgaug/imgaug.py: 1955-1981
</a>
<div class="mid" id="frag273" style="display:none"><pre>

    def on(self, image):
        """
        Project keypoints from one image to a new one.

        Parameters
        ----------
        image : ndarray or tuple of int
            New image onto which the keypoints are to be projected.
            May also simply be that new image's shape tuple.

        Returns
        -------
        keypoints : imgaug.KeypointsOnImage
            Object containing all projected keypoints.

        """
        if is_np_array(image):
            shape = image.shape
        else:
            shape = image

        if shape[0:2] == self.shape[0:2]:
            return self.deepcopy()
        else:
            keypoints = [kp.project(self.shape, shape) for kp in self.keypoints]
            return KeypointsOnImage(keypoints, shape)
</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag318')" href="javascript:;">
imgaug-0.2.7/imgaug/imgaug.py: 3188-3214
</a>
<div class="mid" id="frag318" style="display:none"><pre>

    def on(self, image):
        """
        Project bounding boxes from one image to a new one.

        Parameters
        ----------
        image : ndarray or tuple of int
            New image onto which the bounding boxes are to be projected.
            May also simply be that new image's shape tuple.

        Returns
        -------
        bounding_boxes : imgaug.BoundingBoxesOnImage
            Object containing all projected bounding boxes.

        """
        if is_np_array(image):
            shape = image.shape
        else:
            shape = image

        if shape[0:2] == self.shape[0:2]:
            return self.deepcopy()
        else:
            bounding_boxes = [bb.project(self.shape, shape) for bb in self.bounding_boxes]
            return BoundingBoxesOnImage(bounding_boxes, shape)
</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 12:</b> &nbsp; 2 fragments, nominal size 39 lines, similarity 76%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag279')" href="javascript:;">
imgaug-0.2.7/imgaug/imgaug.py: 2137-2207
</a>
<div class="mid" id="frag279" style="display:none"><pre>
    @staticmethod
    def from_keypoint_image(image, if_not_found_coords={"x": -1, "y": -1}, threshold=1, nb_channels=None): # pylint: disable=locally-disabled, dangerous-default-value, line-too-long
        """
        Converts an image generated by ``to_keypoint_image()`` back to a KeypointsOnImage object.

        Parameters
        ----------
        image : (H,W,N) ndarray
            The keypoints image. N is the number of keypoints.

        if_not_found_coords : tuple or list or dict or None, optional
            Coordinates to use for keypoints that cannot be found in `image`.
            If this is a list/tuple, it must have two integer values.
            If it is a dictionary, it must have the keys ``x`` and ``y`` with
            each containing one integer value.
            If this is None, then the keypoint will not be added to the final
            KeypointsOnImage object.

        threshold : int, optional
            The search for keypoints works by searching for the argmax in
            each channel. This parameters contains the minimum value that
            the max must have in order to be viewed as a keypoint.

        nb_channels : None or int, optional
            Number of channels of the image on which the keypoints are placed.
            Some keypoint augmenters require that information.
            If set to None, the keypoint's shape will be set
            to ``(height, width)``, otherwise ``(height, width, nb_channels)``.

        Returns
        -------
        out : KeypointsOnImage
            The extracted keypoints.

        """
        do_assert(len(image.shape) == 3)
        height, width, nb_keypoints = image.shape

        drop_if_not_found = False
        if if_not_found_coords is None:
            drop_if_not_found = True
            if_not_found_x = -1
            if_not_found_y = -1
        elif isinstance(if_not_found_coords, (tuple, list)):
            do_assert(len(if_not_found_coords) == 2)
            if_not_found_x = if_not_found_coords[0]
            if_not_found_y = if_not_found_coords[1]
        elif isinstance(if_not_found_coords, dict):
            if_not_found_x = if_not_found_coords["x"]
            if_not_found_y = if_not_found_coords["y"]
        else:
            raise Exception("Expected if_not_found_coords to be None or tuple or list or dict, got %s." % (
                type(if_not_found_coords),))

        keypoints = []
        for i in sm.xrange(nb_keypoints):
            maxidx_flat = np.argmax(image[..., i])
            maxidx_ndim = np.unravel_index(maxidx_flat, (height, width))
            found = (image[maxidx_ndim[0], maxidx_ndim[1], i] &gt;= threshold)
            if found:
                keypoints.append(Keypoint(x=maxidx_ndim[1], y=maxidx_ndim[0]))
            else:
                if drop_if_not_found:
                    pass  # dont add the keypoint to the result list, i.e. drop it
                else:
                    keypoints.append(Keypoint(x=if_not_found_x, y=if_not_found_y))

        out_shape = (height, width)
        if nb_channels is not None:
            out_shape += (nb_channels,)
        return KeypointsOnImage(keypoints, shape=out_shape)
</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag281')" href="javascript:;">
imgaug-0.2.7/imgaug/imgaug.py: 2251-2335
</a>
<div class="mid" id="frag281" style="display:none"><pre>
    @staticmethod
    def from_distance_maps(distance_maps, inverted=False, if_not_found_coords={"x": -1, "y": -1}, threshold=None, # pylint: disable=locally-disabled, dangerous-default-value, line-too-long
                           nb_channels=None):
        """
        Converts maps generated by ``to_distance_maps()`` back to a KeypointsOnImage object.

        Parameters
        ----------
        distance_maps : (H,W,N) ndarray
            The distance maps. N is the number of keypoints.

        inverted : bool, optional
            Whether the given distance maps were generated in inverted or normal mode.

        if_not_found_coords : tuple or list or dict or None, optional
            Coordinates to use for keypoints that cannot be found in ``distance_maps``.
            If this is a list/tuple, it must have two integer values.
            If it is a dictionary, it must have the keys ``x`` and ``y``, with each
            containing one integer value.
            If this is None, then the keypoint will not be added to the final
            KeypointsOnImage object.

        threshold : float, optional
            The search for keypoints works by searching for the argmin (non-inverted) or
            argmax (inverted) in each channel. This parameters contains the maximum (non-inverted)
            or minimum (inverted) value to accept in order to view a hit as a keypoint.
            Use None to use no min/max.

        nb_channels : None or int, optional
            Number of channels of the image on which the keypoints are placed.
            Some keypoint augmenters require that information.
            If set to None, the keypoint's shape will be set
            to ``(height, width)``, otherwise ``(height, width, nb_channels)``.

        Returns
        -------
        imgaug.KeypointsOnImage
            The extracted keypoints.

        """
        do_assert(len(distance_maps.shape) == 3)
        height, width, nb_keypoints = distance_maps.shape

        drop_if_not_found = False
        if if_not_found_coords is None:
            drop_if_not_found = True
            if_not_found_x = -1
            if_not_found_y = -1
        elif isinstance(if_not_found_coords, (tuple, list)):
            do_assert(len(if_not_found_coords) == 2)
            if_not_found_x = if_not_found_coords[0]
            if_not_found_y = if_not_found_coords[1]
        elif isinstance(if_not_found_coords, dict):
            if_not_found_x = if_not_found_coords["x"]
            if_not_found_y = if_not_found_coords["y"]
        else:
            raise Exception("Expected if_not_found_coords to be None or tuple or list or dict, got %s." % (
                type(if_not_found_coords),))

        keypoints = []
        for i in sm.xrange(nb_keypoints):
            # TODO introduce voting here among all distance values that have min/max values
            if inverted:
                hitidx_flat = np.argmax(distance_maps[..., i])
            else:
                hitidx_flat = np.argmin(distance_maps[..., i])
            hitidx_ndim = np.unravel_index(hitidx_flat, (height, width))
            if not inverted and threshold is not None:
                found = (distance_maps[hitidx_ndim[0], hitidx_ndim[1], i] &lt; threshold)
            elif inverted and threshold is not None:
                found = (distance_maps[hitidx_ndim[0], hitidx_ndim[1], i] &gt;= threshold)
            else:
                found = True
            if found:
                keypoints.append(Keypoint(x=hitidx_ndim[1], y=hitidx_ndim[0]))
            else:
                if drop_if_not_found:
                    pass  # dont add the keypoint to the result list, i.e. drop it
                else:
                    keypoints.append(Keypoint(x=if_not_found_x, y=if_not_found_y))

        out_shape = (height, width)
        if nb_channels is not None:
            out_shape += (nb_channels,)
        return KeypointsOnImage(keypoints, shape=out_shape)
</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 13:</b> &nbsp; 2 fragments, nominal size 13 lines, similarity 78%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag361')" href="javascript:;">
imgaug-0.2.7/imgaug/imgaug.py: 4272-4285
</a>
<div class="mid" id="frag361" style="display:none"><pre>
    return [(x1 + (i + 1) * step_size[0], y1 + (i + 1) * step_size[1]) for i in sm.xrange(nb_steps)]


def _interpolate_points(points, nb_steps, closed=True):
    if len(points) &lt;= 1:
        return points
    if closed:
        points = list(points) + [points[0]]
    points_interp = []
    for point_a, point_b in zip(points[:-1], points[1:]):
        points_interp.extend([point_a] + _interpolate_point_pair(point_a, point_b, nb_steps))
    if not closed:
        points_interp.append(points[-1])
    # close does not have to be reverted here, as last point is not included in the extend()
</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag362')" href="javascript:;">
imgaug-0.2.7/imgaug/imgaug.py: 4286-4301
</a>
<div class="mid" id="frag362" style="display:none"><pre>
    return points_interp


def _interpolate_points_by_max_distance(points, max_distance, closed=True):
    do_assert(max_distance &gt; 0, "max_distance must have value greater than 0, got %.8f" % (max_distance,))
    if len(points) &lt;= 1:
        return points
    if closed:
        points = list(points) + [points[0]]
    points_interp = []
    for point_a, point_b in zip(points[:-1], points[1:]):
        dist = np.sqrt((point_a[0] - point_b[0]) ** 2 + (point_a[1] - point_b[1]) ** 2)
        nb_steps = int((dist / max_distance) - 1)
        points_interp.extend([point_a] + _interpolate_point_pair(point_a, point_b, nb_steps))
    if not closed:
        points_interp.append(points[-1])
</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 14:</b> &nbsp; 2 fragments, nominal size 58 lines, similarity 75%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag418')" href="javascript:;">
imgaug-0.2.7/imgaug/parameters.py: 17-77
</a>
<div class="mid" id="frag418" style="display:none"><pre>
def handle_continuous_param(param, name, value_range=None, tuple_to_uniform=True, list_to_choice=True):
    def check_value_range(v):
        if value_range is None:
            return True
        elif isinstance(value_range, tuple):
            ia.do_assert(len(value_range) == 2)
            if value_range[0] is None and value_range[1] is None:
                return True
            elif value_range[0] is None:
                ia.do_assert(
                    v &lt;= value_range[1],
                    "Parameter '%s' is outside of the expected value range (x &lt;= %.4f)" % (name, value_range[1]))
                return True
            elif value_range[1] is None:
                ia.do_assert(
                    value_range[0] &lt;= v,
                    "Parameter '%s' is outside of the expected value range (%.4f &lt;= x)" % (name, value_range[0]))
                return True
            else:
                ia.do_assert(
                    value_range[0] &lt;= v &lt;= value_range[1],
                    "Parameter '%s' is outside of the expected value range (%.4f &lt;= x &lt;= %.4f)" % (
                        name, value_range[0], value_range[1]))
                return True
        elif ia.is_callable(value_range):
            value_range(v)
            return True
        else:
            raise Exception("Unexpected input for value_range, got %s." % (str(value_range),))

    if ia.is_single_number(param):
        check_value_range(param)
        return Deterministic(param)
    elif tuple_to_uniform and isinstance(param, tuple):
        ia.do_assert(
            len(param) == 2,
            "Expected parameter '%s' with type tuple to have exactly two entries, but got %d." % (name, len(param)))
        ia.do_assert(
            all([ia.is_single_number(v) for v in param]),
            "Expected parameter '%s' with type tuple to only contain numbers, got %s." % (
                name, [type(v) for v in param],))
        check_value_range(param[0])
        check_value_range(param[1])
        return Uniform(param[0], param[1])
    elif list_to_choice and ia.is_iterable(param) and not isinstance(param, tuple):
        ia.do_assert(
            all([ia.is_single_number(v) for v in param]),
            "Expected iterable parameter '%s' to only contain numbers, got %s." % (
                name, [type(v) for v in param],))
        for param_i in param:
            check_value_range(param_i)
        return Choice(param)
    elif isinstance(param, StochasticParameter):
        return param
    else:
        allowed_type = "number"
        list_str = ", list of %s" % (allowed_type,) if list_to_choice else ""
        raise Exception("Expected %s, tuple of two %s%s or StochasticParameter for %s, got %s." % (
            allowed_type, allowed_type, list_str, name, type(param),))


</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag420')" href="javascript:;">
imgaug-0.2.7/imgaug/parameters.py: 78-138
</a>
<div class="mid" id="frag420" style="display:none"><pre>
def handle_discrete_param(param, name, value_range=None, tuple_to_uniform=True, list_to_choice=True, allow_floats=True):
    def check_value_range(v):
        if value_range is None:
            return True
        elif isinstance(value_range, tuple):
            ia.do_assert(len(value_range) == 2)
            if value_range[0] is None and value_range[1] is None:
                return True
            elif value_range[0] is None:
                ia.do_assert(
                    v &lt;= value_range[1],
                    "Parameter '%s' is outside of the expected value range (x &lt;= %.4f)" % (name, value_range[1]))
                return True
            elif value_range[1] is None:
                ia.do_assert(
                    value_range[0] &lt;= v,
                    "Parameter '%s' is outside of the expected value range (%.4f &lt;= x)" % (name, value_range[0]))
                return True
            else:
                ia.do_assert(
                    value_range[0] &lt;= v &lt;= value_range[1],
                    "Parameter '%s' is outside of the expected value range (%.4f &lt;= x &lt;= %.4f)" % (
                        name, value_range[0], value_range[1]))
                return True
        elif ia.is_callable(value_range):
            value_range(v)
            return True
        else:
            raise Exception("Unexpected input for value_range, got %s." % (str(value_range),))

    if ia.is_single_integer(param) or (allow_floats and ia.is_single_float(param)):
        check_value_range(param)
        return Deterministic(int(param))
    elif tuple_to_uniform and isinstance(param, tuple):
        ia.do_assert(len(param) == 2)
        ia.do_assert(
            all([ia.is_single_number(v) if allow_floats else ia.is_single_integer(v) for v in param]),
            "Expected parameter '%s' of type tuple to only contain %s, got %s." % (
                name, "number" if allow_floats else "integer", [type(v) for v in param],))
        check_value_range(param[0])
        check_value_range(param[1])
        return DiscreteUniform(int(param[0]), int(param[1]))
    elif list_to_choice and ia.is_iterable(param) and not isinstance(param, tuple):
        ia.do_assert(
            all([ia.is_single_number(v) if allow_floats else ia.is_single_integer(v) for v in param]),
            "Expected iterable parameter '%s' to only contain %s, got %s." % (
                name, "number" if allow_floats else "integer", [type(v) for v in param],))

        for param_i in param:
            check_value_range(param_i)
        return Choice([int(param_i) for param_i in param])
    elif isinstance(param, StochasticParameter):
        return param
    else:
        allowed_type = "number" if allow_floats else "int"
        list_str = ", list of %s" % (allowed_type,) if list_to_choice else ""
        raise Exception(
            "Expected %s, tuple of two %s%s or StochasticParameter for %s, got %s." % (
                allowed_type, allowed_type, list_str, name, type(param),))


</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 15:</b> &nbsp; 3 fragments, nominal size 12 lines, similarity 91%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag505')" href="javascript:;">
imgaug-0.2.7/imgaug/parameters.py: 1344-1359
</a>
<div class="mid" id="frag505" style="display:none"><pre>
    def _draw_samples(self, size, random_state):
        seed = random_state.randint(0, 10**6, 1)[0]
        samples = self.other_param.draw_samples(size, random_state=ia.new_random_state(seed))

        elementwise = self.elementwise and not isinstance(self.val, Deterministic)

        if elementwise:
            val_samples = self.val.draw_samples(size, random_state=ia.new_random_state(seed+1))
        else:
            val_samples = self.val.draw_sample(random_state=ia.new_random_state(seed+1))

        if elementwise:
            return np.multiply(samples, val_samples)
        else:
            return samples * val_samples

</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag517')" href="javascript:;">
imgaug-0.2.7/imgaug/parameters.py: 1536-1551
</a>
<div class="mid" id="frag517" style="display:none"><pre>
    def _draw_samples(self, size, random_state):
        seed = random_state.randint(0, 10**6, 1)[0]
        samples = self.other_param.draw_samples(size, random_state=ia.new_random_state(seed))

        elementwise = self.elementwise and not isinstance(self.val, Deterministic)

        if elementwise:
            val_samples = self.val.draw_samples(size, random_state=ia.new_random_state(seed+1))
        else:
            val_samples = self.val.draw_sample(random_state=ia.new_random_state(seed+1))

        if elementwise:
            return np.subtract(samples, val_samples)
        else:
            return samples - val_samples

</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag513')" href="javascript:;">
imgaug-0.2.7/imgaug/parameters.py: 1478-1493
</a>
<div class="mid" id="frag513" style="display:none"><pre>
    def _draw_samples(self, size, random_state):
        seed = random_state.randint(0, 10**6, 1)[0]
        samples = self.other_param.draw_samples(size, random_state=ia.new_random_state(seed))

        elementwise = self.elementwise and not isinstance(self.val, Deterministic)

        if elementwise:
            val_samples = self.val.draw_samples(size, random_state=ia.new_random_state(seed+1))
        else:
            val_samples = self.val.draw_sample(random_state=ia.new_random_state(seed+1))

        if elementwise:
            return np.add(samples, val_samples)
        else:
            return samples + val_samples

</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 16:</b> &nbsp; 2 fragments, nominal size 24 lines, similarity 72%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag539')" href="javascript:;">
imgaug-0.2.7/imgaug/parameters.py: 1974-2000
</a>
<div class="mid" id="frag539" style="display:none"><pre>
    def _draw_samples(self, size, random_state):
        seed = random_state.randint(0, 10**6)
        aggregation_method = self.aggregation_method.draw_sample(random_state=ia.new_random_state(seed))
        iterations = self.iterations.draw_sample(random_state=ia.new_random_state(seed+1))
        ia.do_assert(iterations &gt; 0)

        result = np.zeros(size, dtype=np.float32)
        for i in sm.xrange(iterations):
            noise_iter = self.other_param.draw_samples(size, random_state=ia.new_random_state(seed+2+i))
            if aggregation_method == "avg":
                result += noise_iter
            elif aggregation_method == "min":
                if i == 0:
                    result = noise_iter
                else:
                    result = np.minimum(result, noise_iter)
            else: # self.aggregation_method == "max"
                if i == 0:
                    result = noise_iter
                else:
                    result = np.maximum(result, noise_iter)

        if aggregation_method == "avg":
            result = result / iterations

        return result

</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag548')" href="javascript:;">
imgaug-0.2.7/imgaug/parameters.py: 2184-2211
</a>
<div class="mid" id="frag548" style="display:none"><pre>
    def _draw_samples(self, size, random_state):
        ia.do_assert(len(size) == 2, "Expected requested noise to have shape (H, W), got shape %s." % (size,))
        h, w = size
        seed = random_state.randint(0, 10**6)
        iterations = 1
        aggregation_method = "max"
        upscale_methods = self.upscale_method.draw_samples((iterations,), random_state=ia.new_random_state(seed))
        result = np.zeros((h, w), dtype=np.float32)
        for i in sm.xrange(iterations):
            noise_iter = self._draw_samples_iteration(h, w, seed + 10 + i, upscale_methods[i])
            if aggregation_method == "avg":
                result += noise_iter
            elif aggregation_method == "min":
                if i == 0:
                    result = noise_iter
                else:
                    result = np.minimum(result, noise_iter)
            else:  # self.aggregation_method == "max"
                if i == 0:
                    result = noise_iter
                else:
                    result = np.maximum(result, noise_iter)

        if aggregation_method == "avg":
            result = result / iterations

        return result

</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 17:</b> &nbsp; 2 fragments, nominal size 17 lines, similarity 88%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag547')" href="javascript:;">
imgaug-0.2.7/imgaug/parameters.py: 2166-2183
</a>
<div class="mid" id="frag547" style="display:none"><pre>
    def __init__(self, size_px_max=(2, 16), upscale_method=["linear", "nearest"]): # pylint: disable=locally-disabled, dangerous-default-value, line-too-long
        super(SimplexNoise, self).__init__()
        self.size_px_max = handle_discrete_param(size_px_max, "size_px_max", value_range=(1, 10000))

        if upscale_method == ia.ALL:
            self.upscale_method = Choice(["nearest", "linear", "area", "cubic"])
        elif ia.is_string(upscale_method):
            self.upscale_method = Deterministic(upscale_method)
        elif isinstance(upscale_method, list):
            ia.do_assert(len(upscale_method) &gt;= 1)
            ia.do_assert(all([ia.is_string(val) for val in upscale_method]))
            self.upscale_method = Choice(upscale_method)
        elif isinstance(upscale_method, StochasticParameter):
            self.upscale_method = upscale_method
        else:
            raise Exception("Expected upscale_method to be string or list of strings or StochasticParameter, "
                            + "got %s." % (type(upscale_method),))

</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag552')" href="javascript:;">
imgaug-0.2.7/imgaug/parameters.py: 2325-2343
</a>
<div class="mid" id="frag552" style="display:none"><pre>
    def __init__(self, exponent=(-4, 4), size_px_max=(4, 32), upscale_method=["linear", "nearest"]): # pylint: disable=locally-disabled, dangerous-default-value, line-too-long
        super(FrequencyNoise, self).__init__()
        self.exponent = handle_continuous_param(exponent, "exponent")
        self.size_px_max = handle_discrete_param(size_px_max, "size_px_max", value_range=(1, 10000))

        if upscale_method == ia.ALL:
            self.upscale_method = Choice(["nearest", "linear", "area", "cubic"])
        elif ia.is_string(upscale_method):
            self.upscale_method = Deterministic(upscale_method)
        elif isinstance(upscale_method, list):
            ia.do_assert(len(upscale_method) &gt;= 1)
            ia.do_assert(all([ia.is_string(val) for val in upscale_method]))
            self.upscale_method = Choice(upscale_method)
        elif isinstance(upscale_method, StochasticParameter):
            self.upscale_method = upscale_method
        else:
            raise Exception("Expected upscale_method to be string or list of strings or StochasticParameter, "
                            + "got %s." % (type(upscale_method),))

</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 18:</b> &nbsp; 2 fragments, nominal size 120 lines, similarity 71%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag560')" href="javascript:;">
imgaug-0.2.7/checks/check_segmentation_maps.py: 6-160
</a>
<div class="mid" id="frag560" style="display:none"><pre>
def main():
    quokka = ia.quokka(size=0.5)
    h, w = quokka.shape[0:2]
    c = 4
    segmap = np.zeros((h, w, c), dtype=np.float32)
    segmap[70:120, 90:150, 0] = 1.0
    segmap[30:70, 50:65, 1] = 1.0
    segmap[20:50, 55:85, 2] = 1.0
    segmap[120:140, 0:20, 3] = 1.0

    segmap = ia.SegmentationMapOnImage(segmap, quokka.shape)

    print("Affine...")
    aug = iaa.Affine(translate_px={"x": 20}, mode="constant", cval=128)
    quokka_aug = aug.augment_image(quokka)
    segmaps_aug = aug.augment_segmentation_maps([segmap])[0]
    segmaps_drawn = segmap.draw_on_image(quokka)
    segmaps_aug_drawn = segmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(
        np.hstack([
            segmaps_drawn,
            segmaps_aug_drawn
        ])
    )

    print("Affine with mode=edge...")
    aug = iaa.Affine(translate_px={"x": 20}, mode="edge")
    quokka_aug = aug.augment_image(quokka)
    segmaps_aug = aug.augment_segmentation_maps([segmap])[0]
    segmaps_drawn = segmap.draw_on_image(quokka)
    segmaps_aug_drawn = segmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(
        np.hstack([
            segmaps_drawn,
            segmaps_aug_drawn
        ])
    )

    print("PiecewiseAffine...")
    aug = iaa.PiecewiseAffine(scale=0.04)
    aug_det = aug.to_deterministic()
    quokka_aug = aug_det.augment_image(quokka)
    segmaps_aug = aug_det.augment_segmentation_maps([segmap])[0]
    segmaps_drawn = segmap.draw_on_image(quokka)
    segmaps_aug_drawn = segmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(
        np.hstack([
            segmaps_drawn,
            segmaps_aug_drawn
        ])
    )

    print("PerspectiveTransform...")
    aug = iaa.PerspectiveTransform(scale=0.04)
    aug_det = aug.to_deterministic()
    quokka_aug = aug_det.augment_image(quokka)
    segmaps_aug = aug_det.augment_segmentation_maps([segmap])[0]
    segmaps_drawn = segmap.draw_on_image(quokka)
    segmaps_aug_drawn = segmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(
        np.hstack([
            segmaps_drawn,
            segmaps_aug_drawn
        ])
    )

    print("ElasticTransformation alpha=3, sig=0.5...")
    aug = iaa.ElasticTransformation(alpha=3.0, sigma=0.5)
    aug_det = aug.to_deterministic()
    quokka_aug = aug_det.augment_image(quokka)
    segmaps_aug = aug_det.augment_segmentation_maps([segmap])[0]
    segmaps_drawn = segmap.draw_on_image(quokka)
    segmaps_aug_drawn = segmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(
        np.hstack([
            segmaps_drawn,
            segmaps_aug_drawn
        ])
    )

    print("ElasticTransformation alpha=10, sig=3...")
    aug = iaa.ElasticTransformation(alpha=10.0, sigma=3.0)
    aug_det = aug.to_deterministic()
    quokka_aug = aug_det.augment_image(quokka)
    segmaps_aug = aug_det.augment_segmentation_maps([segmap])[0]
    segmaps_drawn = segmap.draw_on_image(quokka)
    segmaps_aug_drawn = segmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(
        np.hstack([
            segmaps_drawn,
            segmaps_aug_drawn
        ])
    )

    print("CopAndPad mode=constant...")
    aug = iaa.CropAndPad(px=(-10, 10, 15, -15), pad_mode="constant", pad_cval=128)
    aug_det = aug.to_deterministic()
    quokka_aug = aug_det.augment_image(quokka)
    segmaps_aug = aug_det.augment_segmentation_maps([segmap])[0]
    segmaps_drawn = segmap.draw_on_image(quokka)
    segmaps_aug_drawn = segmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(
        np.hstack([
            segmaps_drawn,
            segmaps_aug_drawn
        ])
    )

    print("CropAndPad mode=edge...")
    aug = iaa.CropAndPad(px=(-10, 10, 15, -15), pad_mode="edge")
    aug_det = aug.to_deterministic()
    quokka_aug = aug_det.augment_image(quokka)
    segmaps_aug = aug_det.augment_segmentation_maps([segmap])[0]
    segmaps_drawn = segmap.draw_on_image(quokka)
    segmaps_aug_drawn = segmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(
        np.hstack([
            segmaps_drawn,
            segmaps_aug_drawn
        ])
    )

    print("Scale...")
    aug = iaa.Scale(0.5, interpolation="nearest")
    aug_det = aug.to_deterministic()
    quokka_aug = aug_det.augment_image(quokka)
    segmaps_aug = aug_det.augment_segmentation_maps([segmap])[0]
    segmaps_drawn = segmap.draw_on_image(quokka)
    segmaps_aug_drawn = segmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(ia.draw_grid([segmaps_drawn, segmaps_aug_drawn], cols=2))

    print("Alpha...")
    aug = iaa.Alpha(0.7, iaa.Affine(rotate=20))
    aug_det = aug.to_deterministic()
    quokka_aug = aug_det.augment_image(quokka)
    segmaps_aug = aug_det.augment_segmentation_maps([segmap])[0]
    segmaps_drawn = segmap.draw_on_image(quokka)
    segmaps_aug_drawn = segmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(
        np.hstack([
            segmaps_drawn,
            segmaps_aug_drawn
        ])
    )

</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag568')" href="javascript:;">
imgaug-0.2.7/checks/check_heatmaps.py: 6-174
</a>
<div class="mid" id="frag568" style="display:none"><pre>
def main():
    quokka = ia.quokka(size=0.5)
    h, w = quokka.shape[0:2]
    heatmap = np.zeros((h, w), dtype=np.float32)
    heatmap[70:120, 90:150] = 0.1
    heatmap[30:70, 50:65] = 0.5
    heatmap[20:50, 55:85] = 1.0
    heatmap[120:140, 0:20] = 0.75

    heatmaps = ia.HeatmapsOnImage(heatmap[..., np.newaxis], quokka.shape)

    print("Affine...")
    aug = iaa.Affine(translate_px={"x": 20}, mode="constant", cval=128)
    quokka_aug = aug.augment_image(quokka)
    heatmaps_aug = aug.augment_heatmaps([heatmaps])[0]
    heatmaps_drawn = heatmaps.draw_on_image(quokka)
    heatmaps_aug_drawn = heatmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(
        np.hstack([
            heatmaps_drawn[0],
            heatmaps_aug_drawn[0]
        ])
    )

    print("Affine with mode=edge...")
    aug = iaa.Affine(translate_px={"x": 20}, mode="edge")
    quokka_aug = aug.augment_image(quokka)
    heatmaps_aug = aug.augment_heatmaps([heatmaps])[0]
    heatmaps_drawn = heatmaps.draw_on_image(quokka)
    heatmaps_aug_drawn = heatmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(
        np.hstack([
            heatmaps_drawn[0],
            heatmaps_aug_drawn[0]
        ])
    )

    print("PiecewiseAffine...")
    aug = iaa.PiecewiseAffine(scale=0.04)
    aug_det = aug.to_deterministic()
    quokka_aug = aug_det.augment_image(quokka)
    heatmaps_aug = aug_det.augment_heatmaps([heatmaps])[0]
    heatmaps_drawn = heatmaps.draw_on_image(quokka)
    heatmaps_aug_drawn = heatmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(
        np.hstack([
            heatmaps_drawn[0],
            heatmaps_aug_drawn[0]
        ])
    )

    print("PerspectiveTransform...")
    aug = iaa.PerspectiveTransform(scale=0.04)
    aug_det = aug.to_deterministic()
    quokka_aug = aug_det.augment_image(quokka)
    heatmaps_aug = aug_det.augment_heatmaps([heatmaps])[0]
    heatmaps_drawn = heatmaps.draw_on_image(quokka)
    heatmaps_aug_drawn = heatmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(
        np.hstack([
            heatmaps_drawn[0],
            heatmaps_aug_drawn[0]
        ])
    )

    print("ElasticTransformation alpha=3, sig=0.5...")
    aug = iaa.ElasticTransformation(alpha=3.0, sigma=0.5)
    aug_det = aug.to_deterministic()
    quokka_aug = aug_det.augment_image(quokka)
    heatmaps_aug = aug_det.augment_heatmaps([heatmaps])[0]
    heatmaps_drawn = heatmaps.draw_on_image(quokka)
    heatmaps_aug_drawn = heatmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(
        np.hstack([
            heatmaps_drawn[0],
            heatmaps_aug_drawn[0]
        ])
    )

    print("ElasticTransformation alpha=10, sig=3...")
    aug = iaa.ElasticTransformation(alpha=10.0, sigma=3.0)
    aug_det = aug.to_deterministic()
    quokka_aug = aug_det.augment_image(quokka)
    heatmaps_aug = aug_det.augment_heatmaps([heatmaps])[0]
    heatmaps_drawn = heatmaps.draw_on_image(quokka)
    heatmaps_aug_drawn = heatmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(
        np.hstack([
            heatmaps_drawn[0],
            heatmaps_aug_drawn[0]
        ])
    )

    print("CopAndPad mode=constant...")
    aug = iaa.CropAndPad(px=(-10, 10, 15, -15), pad_mode="constant", pad_cval=128)
    aug_det = aug.to_deterministic()
    quokka_aug = aug_det.augment_image(quokka)
    heatmaps_aug = aug_det.augment_heatmaps([heatmaps])[0]
    heatmaps_drawn = heatmaps.draw_on_image(quokka)
    heatmaps_aug_drawn = heatmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(
        np.hstack([
            heatmaps_drawn[0],
            heatmaps_aug_drawn[0]
        ])
    )

    print("CopAndPad mode=constant + percent...")
    aug = iaa.CropAndPad(percent=(-0.05, 0.05, 0.1, -0.1), pad_mode="constant", pad_cval=128)
    aug_det = aug.to_deterministic()
    quokka_aug = aug_det.augment_image(quokka)
    heatmaps_aug = aug_det.augment_heatmaps([heatmaps])[0]
    heatmaps_drawn = heatmaps.draw_on_image(quokka)
    heatmaps_aug_drawn = heatmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(
        np.hstack([
            heatmaps_drawn[0],
            heatmaps_aug_drawn[0]
        ])
    )

    print("CropAndPad mode=edge...")
    aug = iaa.CropAndPad(px=(-10, 10, 15, -15), pad_mode="edge")
    aug_det = aug.to_deterministic()
    quokka_aug = aug_det.augment_image(quokka)
    heatmaps_aug = aug_det.augment_heatmaps([heatmaps])[0]
    heatmaps_drawn = heatmaps.draw_on_image(quokka)
    heatmaps_aug_drawn = heatmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(
        np.hstack([
            heatmaps_drawn[0],
            heatmaps_aug_drawn[0]
        ])
    )

    print("Scale...")
    aug = iaa.Scale(0.5, interpolation="nearest")
    aug_det = aug.to_deterministic()
    quokka_aug = aug_det.augment_image(quokka)
    heatmaps_aug = aug_det.augment_heatmaps([heatmaps])[0]
    heatmaps_drawn = heatmaps.draw_on_image(quokka)
    heatmaps_aug_drawn = heatmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(ia.draw_grid([heatmaps_drawn[0], heatmaps_aug_drawn[0]], cols=2))

    print("Alpha...")
    aug = iaa.Alpha(0.7, iaa.Affine(rotate=20))
    aug_det = aug.to_deterministic()
    quokka_aug = aug_det.augment_image(quokka)
    heatmaps_aug = aug_det.augment_heatmaps([heatmaps])[0]
    heatmaps_drawn = heatmaps.draw_on_image(quokka)
    heatmaps_aug_drawn = heatmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(
        np.hstack([
            heatmaps_drawn[0],
            heatmaps_aug_drawn[0]
        ])
    )

</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 19:</b> &nbsp; 3 fragments, nominal size 12 lines, similarity 100%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag563')" href="javascript:;">
imgaug-0.2.7/checks/check_clouds.py: 9-24
</a>
<div class="mid" id="frag563" style="display:none"><pre>
def main():
    for size in [0.1, 0.2, 1.0]:
        image = imageio.imread("https://upload.wikimedia.org/wikipedia/commons/8/89/Kukle%2CCzech_Republic..jpg",
                               format="jpg")
        image = ia.imresize_single_image(image, size, "cubic")
        print(image.shape)
        augs = [
            ("iaa.Clouds()", iaa.Clouds())
        ]

        for descr, aug in augs:
            print(descr)
            images_aug = aug.augment_images([image] * 64)
            ia.imshow(ia.draw_grid(images_aug))


</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag584')" href="javascript:;">
imgaug-0.2.7/checks/check_fog.py: 9-24
</a>
<div class="mid" id="frag584" style="display:none"><pre>
def main():
    for size in [0.1, 0.2, 1.0]:
        image = imageio.imread("https://upload.wikimedia.org/wikipedia/commons/8/89/Kukle%2CCzech_Republic..jpg",
                               format="jpg")
        image = ia.imresize_single_image(image, size, "cubic")
        print(image.shape)
        augs = [
            ("iaa.Fog()", iaa.Fog())
        ]

        for descr, aug in augs:
            print(descr)
            images_aug = aug.augment_images([image] * 64)
            ia.imshow(ia.draw_grid(images_aug))


</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag567')" href="javascript:;">
imgaug-0.2.7/checks/check_snowflakes.py: 9-24
</a>
<div class="mid" id="frag567" style="display:none"><pre>
def main():
    for size in [0.1, 0.2, 1.0]:
        image = imageio.imread("https://upload.wikimedia.org/wikipedia/commons/8/89/Kukle%2CCzech_Republic..jpg",
                               format="jpg")
        image = ia.imresize_single_image(image, size, "cubic")
        print(image.shape)
        augs = [
            ("iaa.Snowflakes()", iaa.Snowflakes())
        ]

        for descr, aug in augs:
            print(descr)
            images_aug = aug.augment_images([image] * 64)
            ia.imshow(ia.draw_grid(images_aug))


</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 20:</b> &nbsp; 2 fragments, nominal size 25 lines, similarity 81%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag573')" href="javascript:;">
imgaug-0.2.7/checks/check_median_blur.py: 11-43
</a>
<div class="mid" id="frag573" style="display:none"><pre>
def main():
    image = data.astronaut()
    image = ia.imresize_single_image(image, (64, 64))
    print("image shape:", image.shape)
    print("Press any key or wait %d ms to proceed to the next image." % (TIME_PER_STEP,))

    k = [
        1,
        3,
        5,
        7,
        (3, 3),
        (1, 11)
    ]

    cv2.namedWindow("aug", cv2.WINDOW_NORMAL)
    cv2.resizeWindow("aug", 64*NB_AUGS_PER_IMAGE, 64)
    #cv2.imshow("aug", image[..., ::-1])
    #cv2.waitKey(TIME_PER_STEP)

    for ki in k:
        aug = iaa.MedianBlur(k=ki)
        img_aug = [aug.augment_image(image) for _ in range(NB_AUGS_PER_IMAGE)]
        img_aug = np.hstack(img_aug)
        print("dtype", img_aug.dtype, "averages", np.average(img_aug, axis=tuple(range(0, img_aug.ndim-1))))
        #print("dtype", img_aug.dtype, "averages", img_aug.mean(axis=range(1, img_aug.ndim)))

        title = "k=%s" % (str(ki),)
        img_aug = ia.draw_text(img_aug, x=5, y=5, text=title)

        cv2.imshow("aug", img_aug[..., ::-1]) # here with rgb2bgr
        cv2.waitKey(TIME_PER_STEP)

</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag599')" href="javascript:;">
imgaug-0.2.7/checks/check_average_blur.py: 11-47
</a>
<div class="mid" id="frag599" style="display:none"><pre>
def main():
    image = data.astronaut()
    image = ia.imresize_single_image(image, (64, 64))
    print("image shape:", image.shape)
    print("Press any key or wait %d ms to proceed to the next image." % (TIME_PER_STEP,))

    k = [
        1,
        2,
        4,
        8,
        16,
        (8, 8),
        (1, 8),
        ((1, 1), (8, 8)),
        ((1, 16), (1, 16)),
        ((1, 16), 1)
    ]

    cv2.namedWindow("aug", cv2.WINDOW_NORMAL)
    cv2.resizeWindow("aug", 64*NB_AUGS_PER_IMAGE, 64)
    #cv2.imshow("aug", image[..., ::-1])
    #cv2.waitKey(TIME_PER_STEP)

    for ki in k:
        aug = iaa.AverageBlur(k=ki)
        img_aug = [aug.augment_image(image) for _ in range(NB_AUGS_PER_IMAGE)]
        img_aug = np.hstack(img_aug)
        print("dtype", img_aug.dtype, "averages", np.average(img_aug, axis=tuple(range(0, img_aug.ndim-1))))
        #print("dtype", img_aug.dtype, "averages", img_aug.mean(axis=range(1, img_aug.ndim)))

        title = "k=%s" % (str(ki),)
        img_aug = ia.draw_text(img_aug, x=5, y=5, text=title)

        cv2.imshow("aug", img_aug[..., ::-1]) # here with rgb2bgr
        cv2.waitKey(TIME_PER_STEP)

</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 21:</b> &nbsp; 2 fragments, nominal size 10 lines, similarity 100%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag613')" href="javascript:;">
imgaug-0.2.7/test/test_imgaug.py: 163-174
</a>
<div class="mid" id="frag613" style="display:none"><pre>
def test_is_single_integer():
    assert ia.is_single_integer("A") is False
    assert ia.is_single_integer(None) is False
    assert ia.is_single_integer(1.2) is False
    assert ia.is_single_integer(1.0) is False
    assert ia.is_single_integer(np.ones((1,), dtype=np.float32)[0]) is False
    assert ia.is_single_integer(1) is True
    assert ia.is_single_integer(1234) is True
    assert ia.is_single_integer(np.ones((1,), dtype=np.uint8)[0]) is True
    assert ia.is_single_integer(np.ones((1,), dtype=np.int32)[0]) is True


</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag614')" href="javascript:;">
imgaug-0.2.7/test/test_imgaug.py: 175-186
</a>
<div class="mid" id="frag614" style="display:none"><pre>
def test_is_single_float():
    assert ia.is_single_float("A") is False
    assert ia.is_single_float(None) is False
    assert ia.is_single_float(1.2) is True
    assert ia.is_single_float(1.0) is True
    assert ia.is_single_float(np.ones((1,), dtype=np.float32)[0]) is True
    assert ia.is_single_float(1) is False
    assert ia.is_single_float(1234) is False
    assert ia.is_single_float(np.ones((1,), dtype=np.uint8)[0]) is False
    assert ia.is_single_float(np.ones((1,), dtype=np.int32)[0]) is False


</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 22:</b> &nbsp; 2 fragments, nominal size 10 lines, similarity 70%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag618')" href="javascript:;">
imgaug-0.2.7/test/test_imgaug.py: 225-236
</a>
<div class="mid" id="frag618" style="display:none"><pre>
def test_is_string():
    class _Dummy(object):
        pass
    values_true = ["A", "BC", "1", ""]
    values_false = [-100, 1, 0, 1, 100, -1.2, -0.001, 0.0, 0.001, 1.2, 1e-4, True, False, (1.0, 2.0), [1.0, 2.0],
                    _Dummy(), np.zeros((1, 2), dtype=np.uint8)]
    for value in values_true:
        assert ia.is_string(value) is True
    for value in values_false:
        assert ia.is_string(value) is False


</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag619')" href="javascript:;">
imgaug-0.2.7/test/test_imgaug.py: 237-248
</a>
<div class="mid" id="frag619" style="display:none"><pre>
def test_is_single_bool():
    class _Dummy(object):
        pass
    values_true = [False, True]
    values_false = [-100, 1, 0, 1, 100, -1.2, -0.001, 0.0, 0.001, 1.2, 1e-4, (1.0, 2.0), [1.0, 2.0], _Dummy(),
                    np.zeros((1, 2), dtype=np.uint8), np.zeros((1,), dtype=bool)]
    for value in values_true:
        assert ia.is_single_bool(value) is True
    for value in values_false:
        assert ia.is_single_bool(value) is False


</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 23:</b> &nbsp; 2 fragments, nominal size 20 lines, similarity 90%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag620')" href="javascript:;">
imgaug-0.2.7/test/test_imgaug.py: 249-272
</a>
<div class="mid" id="frag620" style="display:none"><pre>
def test_is_integer_array():
    class _Dummy(object):
        pass
    values_true = [
        np.zeros((1, 2), dtype=np.uint8),
        np.zeros((100,), dtype=np.uint8),
        np.zeros((1, 2), dtype=np.uint16),
        np.zeros((1, 2), dtype=np.int32),
        np.zeros((1, 2), dtype=np.int64)
    ]
    values_false = [
        "A", "BC", "1", "", -100, 1, 0, 1, 100, -1.2, -0.001, 0.0, 0.001, 1.2, 1e-4, True, False,
        (1.0, 2.0), [1.0, 2.0], _Dummy(),
        np.zeros((1, 2), dtype=np.float16),
        np.zeros((100,), dtype=np.float32),
        np.zeros((1, 2), dtype=np.float64),
        np.zeros((1, 2), dtype=np.bool)
    ]
    for value in values_true:
        assert ia.is_integer_array(value) is True
    for value in values_false:
        assert ia.is_integer_array(value) is False


</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag621')" href="javascript:;">
imgaug-0.2.7/test/test_imgaug.py: 273-297
</a>
<div class="mid" id="frag621" style="display:none"><pre>
def test_is_float_array():
    class _Dummy(object):
        pass

    values_true = [
        np.zeros((1, 2), dtype=np.float16),
        np.zeros((100,), dtype=np.float32),
        np.zeros((1, 2), dtype=np.float64)
    ]
    values_false = [
        "A", "BC", "1", "", -100, 1, 0, 1, 100, -1.2, -0.001, 0.0, 0.001, 1.2, 1e-4, True, False,
        (1.0, 2.0), [1.0, 2.0], _Dummy(),
        np.zeros((1, 2), dtype=np.uint8),
        np.zeros((100,), dtype=np.uint8),
        np.zeros((1, 2), dtype=np.uint16),
        np.zeros((1, 2), dtype=np.int32),
        np.zeros((1, 2), dtype=np.int64),
        np.zeros((1, 2), dtype=np.bool)
    ]
    for value in values_true:
        assert ia.is_float_array(value) is True
    for value in values_false:
        assert ia.is_float_array(value) is False


</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 24:</b> &nbsp; 2 fragments, nominal size 13 lines, similarity 92%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag637')" href="javascript:;">
imgaug-0.2.7/test/test_imgaug.py: 544-561
</a>
<div class="mid" id="frag637" style="display:none"><pre>
def test_quokka_heatmap():
    hm = ia.quokka_heatmap()
    assert hm.shape == (643, 960, 3)
    assert hm.arr_0to1.shape == (643, 960, 1)
    assert np.allclose(np.average(hm.arr_0to1), 0.57618505)

    hm = ia.quokka_heatmap(extract="square")
    assert hm.shape == (643, 643, 3)
    assert hm.arr_0to1.shape == (643, 643, 1)
    # TODO this value is 0.48026073 in python 2.7, while 0.48026952 in 3.7 -- why?
    assert np.allclose(np.average(hm.arr_0to1), 0.48026952, atol=1e-4)

    hm = ia.quokka_heatmap(size=(642, 959))
    assert hm.shape == (642, 959, 3)
    assert hm.arr_0to1.shape == (642, 959, 1)
    assert np.allclose(np.average(hm.arr_0to1), 0.5762454)


</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag638')" href="javascript:;">
imgaug-0.2.7/test/test_imgaug.py: 562-578
</a>
<div class="mid" id="frag638" style="display:none"><pre>
def test_quokka_segmentation_map():
    segmap = ia.quokka_segmentation_map()
    assert segmap.shape == (643, 960, 3)
    assert segmap.arr.shape == (643, 960, 1)
    assert np.allclose(np.average(segmap.arr), 0.3016427)

    segmap = ia.quokka_segmentation_map(extract="square")
    assert segmap.shape == (643, 643, 3)
    assert segmap.arr.shape == (643, 643, 1)
    assert np.allclose(np.average(segmap.arr), 0.450353)

    segmap = ia.quokka_segmentation_map(size=(642, 959))
    assert segmap.shape == (642, 959, 3)
    assert segmap.arr.shape == (642, 959, 1)
    assert np.allclose(np.average(segmap.arr), 0.30160266)


</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 25:</b> &nbsp; 2 fragments, nominal size 26 lines, similarity 80%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag639')" href="javascript:;">
imgaug-0.2.7/test/test_imgaug.py: 579-609
</a>
<div class="mid" id="frag639" style="display:none"><pre>
def test_quokka_keypoints():
    kpsoi = ia.quokka_keypoints()
    assert len(kpsoi.keypoints) &gt; 0
    assert np.allclose(kpsoi.keypoints[0].x, 163.0)
    assert np.allclose(kpsoi.keypoints[0].y, 78.0)
    assert kpsoi.shape == (643, 960, 3)

    img = ia.quokka()
    patches = []
    for kp in kpsoi.keypoints:
        bb = ia.BoundingBox(x1=kp.x-1, x2=kp.x+2, y1=kp.y-1, y2=kp.y+2)
        patches.append(bb.extract_from_image(img))

    img_square = ia.quokka(extract="square")
    kpsoi_square = ia.quokka_keypoints(extract="square")
    assert len(kpsoi.keypoints) == len(kpsoi_square.keypoints)
    assert kpsoi_square.shape == (643, 643, 3)

    for kp, patch in zip(kpsoi_square.keypoints, patches):
        bb = ia.BoundingBox(x1=kp.x-1, x2=kp.x+2, y1=kp.y-1, y2=kp.y+2)
        patch_square = bb.extract_from_image(img_square)
        assert np.average(np.abs(patch.astype(np.float32) - patch_square.astype(np.float32))) &lt; 1.0

    kpsoi_resized = ia.quokka_keypoints(size=(642, 959))
    assert kpsoi_resized.shape == (642, 959, 3)
    assert len(kpsoi.keypoints) == len(kpsoi_resized.keypoints)
    for kp, kp_resized in zip(kpsoi.keypoints, kpsoi_resized.keypoints):
        d = np.sqrt((kp.x - kp_resized.x) ** 2 + (kp.y - kp_resized.y) ** 2)
        assert d &lt; 1.0


</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag640')" href="javascript:;">
imgaug-0.2.7/test/test_imgaug.py: 610-641
</a>
<div class="mid" id="frag640" style="display:none"><pre>
def test_quokka_bounding_boxes():
    bbsoi = ia.quokka_bounding_boxes()
    assert len(bbsoi.bounding_boxes) &gt; 0
    bb0 = bbsoi.bounding_boxes[0]
    assert np.allclose(bb0.x1, 148.0)
    assert np.allclose(bb0.y1, 50.0)
    assert np.allclose(bb0.x2, 550.0)
    assert np.allclose(bb0.y2, 642.0)
    assert bbsoi.shape == (643, 960, 3)

    img = ia.quokka()
    patches = []
    for bb in bbsoi.bounding_boxes:
        patches.append(bb.extract_from_image(img))

    img_square = ia.quokka(extract="square")
    bbsoi_square = ia.quokka_bounding_boxes(extract="square")
    assert len(bbsoi.bounding_boxes) == len(bbsoi_square.bounding_boxes)
    assert bbsoi_square.shape == (643, 643, 3)

    for bb, patch in zip(bbsoi_square.bounding_boxes, patches):
        patch_square = bb.extract_from_image(img_square)
        assert np.average(np.abs(patch.astype(np.float32) - patch_square.astype(np.float32))) &lt; 1.0

    bbsoi_resized = ia.quokka_bounding_boxes(size=(642, 959))
    assert bbsoi_resized.shape == (642, 959, 3)
    assert len(bbsoi.bounding_boxes) == len(bbsoi_resized.bounding_boxes)
    for bb, bb_resized in zip(bbsoi.bounding_boxes, bbsoi_resized.bounding_boxes):
        d = np.sqrt((bb.center_x - bb_resized.center_x) ** 2 + (bb.center_y - bb_resized.center_y) ** 2)
        assert d &lt; 1.0


</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 26:</b> &nbsp; 2 fragments, nominal size 13 lines, similarity 100%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag649')" href="javascript:;">
imgaug-0.2.7/test/test_imgaug.py: 1479-1495
</a>
<div class="mid" id="frag649" style="display:none"><pre>
    arr_pooled = ia.pool(arr, 2, np.average, cval=22)
    assert arr_pooled.shape == (2, 2)
    assert arr_pooled.dtype == arr.dtype.type
    assert arr_pooled[0, 0] == int(np.average([0, 1, 4, 5]))
    assert arr_pooled[0, 1] == int(np.average([2, 22, 6, 22]))
    assert arr_pooled[1, 0] == int(np.average([8, 9, 22, 22]))
    assert arr_pooled[1, 1] == int(np.average([10, 22, 22, 22]))


def test_avg_pool():
    # very basic test, as avg_pool() just calls pool(), which is tested in test_pool()
    arr = np.uint8([
        [0, 1, 2, 3],
        [4, 5, 6, 7],
        [8, 9, 10, 11],
        [12, 13, 14, 15]
    ])
</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag650')" href="javascript:;">
imgaug-0.2.7/test/test_imgaug.py: 1496-1512
</a>
<div class="mid" id="frag650" style="display:none"><pre>
    arr_pooled = ia.avg_pool(arr, 2)
    assert arr_pooled.shape == (2, 2)
    assert arr_pooled.dtype == arr.dtype.type
    assert arr_pooled[0, 0] == int(np.average([0, 1, 4, 5]))
    assert arr_pooled[0, 1] == int(np.average([2, 3, 6, 7]))
    assert arr_pooled[1, 0] == int(np.average([8, 9, 12, 13]))
    assert arr_pooled[1, 1] == int(np.average([10, 11, 14, 15]))


def test_max_pool():
    # very basic test, as avg_pool() just calls pool(), which is tested in test_pool()
    arr = np.uint8([
        [0, 1, 2, 3],
        [4, 5, 6, 7],
        [8, 9, 10, 11],
        [12, 13, 14, 15]
    ])
</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 27:</b> &nbsp; 2 fragments, nominal size 13 lines, similarity 100%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag661')" href="javascript:;">
imgaug-0.2.7/test/test_imgaug.py: 2929-2946
</a>
<div class="mid" id="frag661" style="display:none"><pre>
            [0.0, 0.0, 1.0],
            [0.1, 0.1, 0.1],
            [0.1, 0.1, 0.1],
            [0.1, 0.1, 0.1],
            [0.1, 0.1, 0.1],
            [0.1, 0.1, 0.1]
        ])
    )


def test_HeatmapsOnImage_avg_pool():
    heatmaps_arr = np.float32([
        [0.0, 0.0, 0.5, 1.0],
        [0.0, 0.0, 0.5, 1.0],
        [0.0, 0.0, 0.5, 1.0],
        [0.0, 0.0, 0.5, 1.0]
    ])
    heatmaps = ia.HeatmapsOnImage(heatmaps_arr, shape=(4, 4, 3))
</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag662')" href="javascript:;">
imgaug-0.2.7/test/test_imgaug.py: 2947-2964
</a>
<div class="mid" id="frag662" style="display:none"><pre>

    heatmaps_pooled = heatmaps.avg_pool(2)
    assert heatmaps_pooled.arr_0to1.shape == (2, 2, 1)
    assert np.allclose(
        heatmaps_pooled.arr_0to1[:, :, 0],
        np.float32([[0.0, 0.75],
                    [0.0, 0.75]])
    )


def test_HeatmapsOnImage_max_pool():
    heatmaps_arr = np.float32([
        [0.0, 0.0, 0.5, 1.0],
        [0.0, 0.0, 0.5, 1.0],
        [0.0, 0.0, 0.5, 1.0],
        [0.0, 0.0, 0.5, 1.0]
    ])
    heatmaps = ia.HeatmapsOnImage(heatmaps_arr, shape=(4, 4, 3))
</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 28:</b> &nbsp; 2 fragments, nominal size 26 lines, similarity 78%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag675')" href="javascript:;">
imgaug-0.2.7/test/test_imgaug.py: 3633-3661
</a>
<div class="mid" id="frag675" style="display:none"><pre>
    expected_c3 = np.zeros(arr_c0.shape)
    expected = np.concatenate([
        expected_c0[..., np.newaxis],
        expected_c1[..., np.newaxis],
        expected_c2[..., np.newaxis],
        expected_c3[..., np.newaxis]
    ], axis=2)
    assert np.allclose(segmap.arr, expected)


def test_SegmentationMapOnImage_copy():
    arr_c0 = np.float32([
        [1.0, 0.0],
        [1.0, 0.0]
    ])
    arr_c1 = np.float32([
        [0.0, 1.0],
        [0.0, 1.0]
    ])
    arr = np.concatenate([arr_c0[..., np.newaxis], arr_c1[..., np.newaxis]], axis=2)
    segmap = ia.SegmentationMapOnImage(arr, shape=(2, 2))
    observed = segmap.copy()
    assert np.allclose(observed.arr, segmap.arr)
    assert observed.shape == (2, 2)
    assert observed.nb_classes == segmap.nb_classes
    assert observed.input_was == segmap.input_was

    arr = np.int32([
        [0, 1],
</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag676')" href="javascript:;">
imgaug-0.2.7/test/test_imgaug.py: 3662-3695
</a>
<div class="mid" id="frag676" style="display:none"><pre>
        [2, 3]
    ])
    segmap = ia.SegmentationMapOnImage(arr, shape=(2, 2), nb_classes=10)
    observed = segmap.copy()
    assert np.array_equal(observed.get_arr_int(), arr)
    assert observed.shape == (2, 2)
    assert observed.nb_classes == 10
    assert observed.input_was == segmap.input_was


def test_SegmentationMapOnImage_deepcopy():
    arr_c0 = np.float32([
        [1.0, 0.0],
        [1.0, 0.0]
    ])
    arr_c1 = np.float32([
        [0.0, 1.0],
        [0.0, 1.0]
    ])
    arr = np.concatenate([arr_c0[..., np.newaxis], arr_c1[..., np.newaxis]], axis=2)
    segmap = ia.SegmentationMapOnImage(arr, shape=(2, 2))
    observed = segmap.deepcopy()
    assert np.allclose(observed.arr, segmap.arr)
    assert observed.shape == (2, 2)
    assert observed.nb_classes == segmap.nb_classes
    assert observed.input_was == segmap.input_was
    segmap.arr[0, 0, 0] = 0.0
    assert not np.allclose(observed.arr, segmap.arr)

    arr = np.int32([
        [0, 1],
        [2, 3]
    ])
    segmap = ia.SegmentationMapOnImage(arr, shape=(2, 2), nb_classes=10)
</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 29:</b> &nbsp; 3 fragments, nominal size 37 lines, similarity 77%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag722')" href="javascript:;">
imgaug-0.2.7/test/augmenters/test_meta.py: 18-55
</a>
<div class="mid" id="frag722" style="display:none"><pre>
def main():
    time_start = time.time()

    test_copy_dtypes_for_restore()
    test_restore_augmented_image_dtype_()
    test_restore_augmented_image_dtype()
    test_restore_augmented_images_dtypes_()
    test_restore_augmented_images_dtypes()
    test_clip_augmented_image_()
    test_clip_augmented_image()
    test_clip_augmented_images_()
    test_clip_augmented_images()
    test_reduce_to_nonempty()
    test_invert_reduce_to_nonempty()
    test_Augmenter()
    test_Augmenter_augment_keypoints()
    test_Augmenter_augment_segmentation_maps()
    test_Augmenter_find()
    test_Augmenter_remove()
    test_Augmenter_hooks()
    test_Augmenter_copy_random_state()
    test_Augmenter_augment_batches()
    test_Sequential()
    test_SomeOf()
    test_OneOf()
    test_Sometimes()
    test_WithChannels()
    test_Noop()
    test_Lambda()
    test_AssertLambda()
    test_AssertShape()
    test_ChannelShuffle()
    test_2d_inputs()

    time_end = time.time()
    print("&lt;%s&gt; Finished without errors in %.4fs." % (__file__, time_end - time_start,))


</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag967')" href="javascript:;">
imgaug-0.2.7/generate_documentation_images.py: 1338-1378
</a>
<div class="mid" id="frag967" style="display:none"><pre>
        "overview_of_augmenters",
        filename,
        grid(images_aug, cols=cols, rows=rows),
        quality=quality
    )

def chapter_augmenters():
    chapter_augmenters_sequential()
    chapter_augmenters_someof()
    chapter_augmenters_oneof()
    chapter_augmenters_sometimes()
    chapter_augmenters_withcolorspace()
    chapter_augmenters_withchannels()
    chapter_augmenters_noop()
    chapter_augmenters_lambda()
    chapter_augmenters_assertlambda()
    chapter_augmenters_assertshape()
    chapter_augmenters_scale()
    chapter_augmenters_cropandpad()
    chapter_augmenters_pad()
    chapter_augmenters_crop()
    chapter_augmenters_fliplr()
    chapter_augmenters_flipud()
    chapter_augmenters_superpixels()
    chapter_augmenters_changecolorspace()
    chapter_augmenters_grayscale()
    chapter_augmenters_gaussianblur()
    chapter_augmenters_averageblur()
    chapter_augmenters_medianblur()
    chapter_augmenters_convolve()
    chapter_augmenters_sharpen()
    chapter_augmenters_emboss()
    chapter_augmenters_edgedetect()
    chapter_augmenters_directededgedetect()
    chapter_augmenters_add()
    chapter_augmenters_addelementwise()
    chapter_augmenters_additivegaussiannoise()
    chapter_augmenters_multiply()
    chapter_augmenters_multiplyelementwise()
    chapter_augmenters_dropout()
    chapter_augmenters_coarsedropout()
</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag891')" href="javascript:;">
imgaug-0.2.7/test/test_parameters.py: 18-62
</a>
<div class="mid" id="frag891" style="display:none"><pre>
def main():
    time_start = time.time()

    test_parameters_handle_continuous_param()
    test_parameters_handle_discrete_param()
    test_parameters_handle_probability_param()
    test_parameters_force_np_float_dtype()
    test_parameters_both_np_float_if_one_is_float()
    test_parameters_draw_distribution_grid()
    test_parameters_draw_distribution_graph()
    test_parameters_Biomial()
    test_parameters_Choice()
    test_parameters_DiscreteUniform()
    test_parameters_Poisson()
    test_parameters_Normal()
    test_parameters_Laplace()
    test_parameters_ChiSquare()
    test_parameters_Weibull()
    test_parameters_Uniform()
    test_parameters_Beta()
    test_parameters_Deterministic()
    test_parameters_FromLowerResolution()
    test_parameters_Clip()
    test_parameters_Discretize()
    test_parameters_Multiply()
    test_parameters_Divide()
    test_parameters_Add()
    test_parameters_Subtract()
    test_parameters_Power()
    test_parameters_Absolute()
    test_parameters_RandomSign()
    test_parameters_ForceSign()
    test_parameters_Positive()
    test_parameters_Negative()
    test_parameters_IterativeNoiseAggregator()
    test_parameters_Sigmoid()
    # test_parameters_SimplexNoise()
    # test_parameters_FrequencyNoise()
    test_parameters_operators()
    test_parameters_copy()

    time_end = time.time()
    print("&lt;%s&gt; Finished without errors in %.4fs." % (__file__, time_end - time_start,))


</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 30:</b> &nbsp; 2 fragments, nominal size 13 lines, similarity 100%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag739')" href="javascript:;">
imgaug-0.2.7/test/augmenters/test_meta.py: 608-623
</a>
<div class="mid" id="frag739" style="display:none"><pre>
def test_restore_augmented_images_dtypes_():
    images = np.zeros((10, 16, 32, 3), dtype=np.int32)
    dtypes = iaa.copy_dtypes_for_restore(images)
    images = images.astype(np.uint8)
    assert images.dtype.type == np.uint8
    images_result = iaa.restore_augmented_images_dtypes_(images, dtypes)
    assert images_result.dtype.type == np.int32

    images = [np.zeros((16, 32, 3), dtype=np.int32) for _ in sm.xrange(10)]
    dtypes = iaa.copy_dtypes_for_restore(images)
    images = [image.astype(np.uint8) for image in images]
    assert all([image.dtype.type == np.uint8 for image in images])
    images_result = iaa.restore_augmented_images_dtypes_(images, dtypes)
    assert all([image_result.dtype.type == np.int32 for image_result in images_result])


</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag740')" href="javascript:;">
imgaug-0.2.7/test/augmenters/test_meta.py: 624-639
</a>
<div class="mid" id="frag740" style="display:none"><pre>
def test_restore_augmented_images_dtypes():
    images = np.zeros((10, 16, 32, 3), dtype=np.int32)
    dtypes = iaa.copy_dtypes_for_restore(images)
    images = images.astype(np.uint8)
    assert images.dtype.type == np.uint8
    images_restored = iaa.restore_augmented_images_dtypes(images, dtypes)
    assert images_restored.dtype.type == np.int32

    images = [np.zeros((16, 32, 3), dtype=np.int32) for _ in sm.xrange(10)]
    dtypes = iaa.copy_dtypes_for_restore(images)
    images = [image.astype(np.uint8) for image in images]
    assert all([image.dtype.type == np.uint8 for image in images])
    images_restored = iaa.restore_augmented_images_dtypes(images, dtypes)
    assert all([image_restored.dtype.type == np.int32 for image_restored in images_restored])


</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 31:</b> &nbsp; 2 fragments, nominal size 19 lines, similarity 100%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag743')" href="javascript:;">
imgaug-0.2.7/test/augmenters/test_meta.py: 662-683
</a>
<div class="mid" id="frag743" style="display:none"><pre>
def test_clip_augmented_images_():
    images = np.zeros((2, 1, 3), dtype=np.uint8)
    images[:, 0, 0] = 10
    images[:, 0, 1] = 20
    images[:, 0, 2] = 30
    images_clipped = iaa.clip_augmented_images_(images, min_value=15, max_value=25)
    assert np.all(images_clipped[:, 0, 0] == 15)
    assert np.all(images_clipped[:, 0, 1] == 20)
    assert np.all(images_clipped[:, 0, 2] == 25)

    images = [np.zeros((1, 3), dtype=np.uint8) for _ in sm.xrange(2)]
    for i in sm.xrange(len(images)):
        images[i][0, 0] = 10
        images[i][0, 1] = 20
        images[i][0, 2] = 30
    images_clipped = iaa.clip_augmented_images_(images, min_value=15, max_value=25)
    assert isinstance(images_clipped, list)
    assert all([images_clipped[i][0, 0] == 15 for i in sm.xrange(len(images))])
    assert all([images_clipped[i][0, 1] == 20 for i in sm.xrange(len(images))])
    assert all([images_clipped[i][0, 2] == 25 for i in sm.xrange(len(images))])


</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag744')" href="javascript:;">
imgaug-0.2.7/test/augmenters/test_meta.py: 684-705
</a>
<div class="mid" id="frag744" style="display:none"><pre>
def test_clip_augmented_images():
    images = np.zeros((2, 1, 3), dtype=np.uint8)
    images[:, 0, 0] = 10
    images[:, 0, 1] = 20
    images[:, 0, 2] = 30
    images_clipped = iaa.clip_augmented_images(images, min_value=15, max_value=25)
    assert np.all(images_clipped[:, 0, 0] == 15)
    assert np.all(images_clipped[:, 0, 1] == 20)
    assert np.all(images_clipped[:, 0, 2] == 25)

    images = [np.zeros((1, 3), dtype=np.uint8) for _ in sm.xrange(2)]
    for i in sm.xrange(len(images)):
        images[i][0, 0] = 10
        images[i][0, 1] = 20
        images[i][0, 2] = 30
    images_clipped = iaa.clip_augmented_images(images, min_value=15, max_value=25)
    assert isinstance(images_clipped, list)
    assert all([images_clipped[i][0, 0] == 15 for i in sm.xrange(len(images))])
    assert all([images_clipped[i][0, 1] == 20 for i in sm.xrange(len(images))])
    assert all([images_clipped[i][0, 2] == 25 for i in sm.xrange(len(images))])


</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 32:</b> &nbsp; 2 fragments, nominal size 10 lines, similarity 100%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag795')" href="javascript:;">
imgaug-0.2.7/test/augmenters/test_weather.py: 128-143
</a>
<div class="mid" id="frag795" style="display:none"><pre>
def test_Clouds():
    # rough test as fairly hard to test more detailed
    reseed()

    img = np.zeros((100, 100, 3), dtype=np.uint8)
    img_aug = iaa.Clouds().augment_image(img)
    assert 50 &lt; np.average(img_aug) &lt; 240
    assert np.max(img_aug) &gt; 200

    grad_x = img_aug[:, 1:].astype(np.float32) - img_aug[:, :-1].astype(np.float32)
    grad_y = img_aug[1:, :].astype(np.float32) - img_aug[:-1, :].astype(np.float32)

    assert np.sum(np.abs(grad_x)) &gt; 5 * img.shape[1]
    assert np.sum(np.abs(grad_y)) &gt; 5 * img.shape[0]


</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag796')" href="javascript:;">
imgaug-0.2.7/test/augmenters/test_weather.py: 144-159
</a>
<div class="mid" id="frag796" style="display:none"><pre>
def test_Fog():
    # rough test as fairly hard to test more detailed
    reseed()

    img = np.zeros((100, 100, 3), dtype=np.uint8)
    img_aug = iaa.Clouds().augment_image(img)
    assert 100 &lt; np.average(img_aug) &lt; 255
    assert np.max(img_aug) &gt; 100

    grad_x = img_aug[:, 1:].astype(np.float32) - img_aug[:, :-1].astype(np.float32)
    grad_y = img_aug[1:, :].astype(np.float32) - img_aug[:-1, :].astype(np.float32)

    assert np.sum(np.abs(grad_x)) &gt; 1 * img.shape[1]
    assert np.sum(np.abs(grad_y)) &gt; 1 * img.shape[0]


</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 33:</b> &nbsp; 2 fragments, nominal size 11 lines, similarity 90%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag799')" href="javascript:;">
imgaug-0.2.7/test/augmenters/test_geometric.py: 17-30
</a>
<div class="mid" id="frag799" style="display:none"><pre>
def main():
    time_start = time.time()

    test_Affine()
    test_AffineCv2()
    test_PiecewiseAffine()
    test_PerspectiveTransform()
    test_ElasticTransformation()
    test_Rot90()

    time_end = time.time()
    print("&lt;%s&gt; Finished without errors in %.4fs." % (__file__, time_end - time_start,))


</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag861')" href="javascript:;">
imgaug-0.2.7/test/augmenters/test_size.py: 18-34
</a>
<div class="mid" id="frag861" style="display:none"><pre>
def main():
    time_start = time.time()

    test__handle_position_parameter()

    test_Scale()
    # TODO test_CropAndPad()
    test_Pad()
    test_Crop()
    test_PadToFixedSize()
    test_CropToFixedSize()
    test_KeepSizeByResize()

    time_end = time.time()
    print("&lt;%s&gt; Finished without errors in %.4fs." % (__file__, time_end - time_start,))


</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 34:</b> &nbsp; 2 fragments, nominal size 654 lines, similarity 87%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag800')" href="javascript:;">
imgaug-0.2.7/test/augmenters/test_geometric.py: 31-944
</a>
<div class="mid" id="frag800" style="display:none"><pre>
def test_Affine():
    reseed()

    base_img = np.array([[0, 0, 0],
                         [0, 255, 0],
                         [0, 0, 0]], dtype=np.uint8)
    base_img = base_img[:, :, np.newaxis]

    images = np.array([base_img])
    images_list = [base_img]
    outer_pixels = ([], [])
    for i in sm.xrange(base_img.shape[0]):
        for j in sm.xrange(base_img.shape[1]):
            if i != j:
                outer_pixels[0].append(i)
                outer_pixels[1].append(j)

    keypoints = [ia.KeypointsOnImage([ia.Keypoint(x=0, y=0), ia.Keypoint(x=1, y=1),
                                      ia.Keypoint(x=2, y=2)], shape=base_img.shape)]

    # no translation/scale/rotate/shear, shouldnt change nothing
    aug = iaa.Affine(scale=1.0, translate_px=0, rotate=0, shear=0)
    aug_det = aug.to_deterministic()

    observed = aug.augment_images(images)
    expected = images
    assert np.array_equal(observed, expected)

    observed = aug_det.augment_images(images)
    expected = images
    assert np.array_equal(observed, expected)

    observed = aug.augment_images(images_list)
    expected = images_list
    assert array_equal_lists(observed, expected)

    observed = aug_det.augment_images(images_list)
    expected = images_list
    assert array_equal_lists(observed, expected)

    observed = aug.augment_keypoints(keypoints)
    expected = keypoints
    assert keypoints_equal(observed, expected)

    observed = aug_det.augment_keypoints(keypoints)
    expected = keypoints
    assert keypoints_equal(observed, expected)

    # ---------------------
    # scale
    # ---------------------
    # zoom in
    aug = iaa.Affine(scale=1.75, translate_px=0, rotate=0, shear=0)
    aug_det = aug.to_deterministic()

    observed = aug.augment_images(images)
    assert observed[0][1, 1] &gt; 250
    assert (observed[0][outer_pixels[0], outer_pixels[1]] &gt; 20).all()
    assert (observed[0][outer_pixels[0], outer_pixels[1]] &lt; 150).all()

    observed = aug_det.augment_images(images)
    assert observed[0][1, 1] &gt; 250
    assert (observed[0][outer_pixels[0], outer_pixels[1]] &gt; 20).all()
    assert (observed[0][outer_pixels[0], outer_pixels[1]] &lt; 150).all()

    observed = aug.augment_images(images_list)
    assert observed[0][1, 1] &gt; 250
    assert (observed[0][outer_pixels[0], outer_pixels[1]] &gt; 20).all()
    assert (observed[0][outer_pixels[0], outer_pixels[1]] &lt; 150).all()

    observed = aug_det.augment_images(images_list)
    assert observed[0][1, 1] &gt; 250
    assert (observed[0][outer_pixels[0], outer_pixels[1]] &gt; 20).all()
    assert (observed[0][outer_pixels[0], outer_pixels[1]] &lt; 150).all()

    observed = aug.augment_keypoints(keypoints)
    assert observed[0].keypoints[0].x &lt; 0
    assert observed[0].keypoints[0].y &lt; 0
    assert observed[0].keypoints[1].x == 1
    assert observed[0].keypoints[1].y == 1
    assert observed[0].keypoints[2].x &gt; 2
    assert observed[0].keypoints[2].y &gt; 2

    observed = aug_det.augment_keypoints(keypoints)
    assert observed[0].keypoints[0].x &lt; 0
    assert observed[0].keypoints[0].y &lt; 0
    assert observed[0].keypoints[1].x == 1
    assert observed[0].keypoints[1].y == 1
    assert observed[0].keypoints[2].x &gt; 2
    assert observed[0].keypoints[2].y &gt; 2

    # zoom in only on x axis
    aug = iaa.Affine(scale={"x": 1.75, "y": 1.0}, translate_px=0, rotate=0, shear=0)
    aug_det = aug.to_deterministic()

    observed = aug.augment_images(images)
    assert observed[0][1, 1] &gt; 250
    assert (observed[0][[1, 1], [0, 2]] &gt; 20).all()
    assert (observed[0][[1, 1], [0, 2]] &lt; 150).all()
    assert (observed[0][0, :] &lt; 5).all()
    assert (observed[0][2, :] &lt; 5).all()

    observed = aug_det.augment_images(images)
    assert observed[0][1, 1] &gt; 250
    assert (observed[0][[1, 1], [0, 2]] &gt; 20).all()
    assert (observed[0][[1, 1], [0, 2]] &lt; 150).all()
    assert (observed[0][0, :] &lt; 5).all()
    assert (observed[0][2, :] &lt; 5).all()

    observed = aug.augment_images(images_list)
    assert observed[0][1, 1] &gt; 250
    assert (observed[0][[1, 1], [0, 2]] &gt; 20).all()
    assert (observed[0][[1, 1], [0, 2]] &lt; 150).all()
    assert (observed[0][0, :] &lt; 5).all()
    assert (observed[0][2, :] &lt; 5).all()

    observed = aug_det.augment_images(images_list)
    assert observed[0][1, 1] &gt; 250
    assert (observed[0][[1, 1], [0, 2]] &gt; 20).all()
    assert (observed[0][[1, 1], [0, 2]] &lt; 150).all()
    assert (observed[0][0, :] &lt; 5).all()
    assert (observed[0][2, :] &lt; 5).all()

    observed = aug.augment_keypoints(keypoints)
    assert observed[0].keypoints[0].x &lt; 0
    assert observed[0].keypoints[0].y == 0
    assert observed[0].keypoints[1].x == 1
    assert observed[0].keypoints[1].y == 1
    assert observed[0].keypoints[2].x &gt; 2
    assert observed[0].keypoints[2].y == 2

    observed = aug_det.augment_keypoints(keypoints)
    assert observed[0].keypoints[0].x &lt; 0
    assert observed[0].keypoints[0].y == 0
    assert observed[0].keypoints[1].x == 1
    assert observed[0].keypoints[1].y == 1
    assert observed[0].keypoints[2].x &gt; 2
    assert observed[0].keypoints[2].y == 2

    # zoom in only on y axis
    aug = iaa.Affine(scale={"x": 1.0, "y": 1.75}, translate_px=0, rotate=0, shear=0)
    aug_det = aug.to_deterministic()

    observed = aug.augment_images(images)
    assert observed[0][1, 1] &gt; 250
    assert (observed[0][[0, 2], [1, 1]] &gt; 20).all()
    assert (observed[0][[0, 2], [1, 1]] &lt; 150).all()
    assert (observed[0][:, 0] &lt; 5).all()
    assert (observed[0][:, 2] &lt; 5).all()

    observed = aug_det.augment_images(images)
    assert observed[0][1, 1] &gt; 250
    assert (observed[0][[0, 2], [1, 1]] &gt; 20).all()
    assert (observed[0][[0, 2], [1, 1]] &lt; 150).all()
    assert (observed[0][:, 0] &lt; 5).all()
    assert (observed[0][:, 2] &lt; 5).all()

    observed = aug.augment_images(images_list)
    assert observed[0][1, 1] &gt; 250
    assert (observed[0][[0, 2], [1, 1]] &gt; 20).all()
    assert (observed[0][[0, 2], [1, 1]] &lt; 150).all()
    assert (observed[0][:, 0] &lt; 5).all()
    assert (observed[0][:, 2] &lt; 5).all()

    observed = aug_det.augment_images(images_list)
    assert observed[0][1, 1] &gt; 250
    assert (observed[0][[0, 2], [1, 1]] &gt; 20).all()
    assert (observed[0][[0, 2], [1, 1]] &lt; 150).all()
    assert (observed[0][:, 0] &lt; 5).all()
    assert (observed[0][:, 2] &lt; 5).all()

    observed = aug.augment_keypoints(keypoints)
    assert observed[0].keypoints[0].x == 0
    assert observed[0].keypoints[0].y &lt; 0
    assert observed[0].keypoints[1].x == 1
    assert observed[0].keypoints[1].y == 1
    assert observed[0].keypoints[2].x == 2
    assert observed[0].keypoints[2].y &gt; 2

    observed = aug_det.augment_keypoints(keypoints)
    assert observed[0].keypoints[0].x == 0
    assert observed[0].keypoints[0].y &lt; 0
    assert observed[0].keypoints[1].x == 1
    assert observed[0].keypoints[1].y == 1
    assert observed[0].keypoints[2].x == 2
    assert observed[0].keypoints[2].y &gt; 2

    # zoom out
    # this one uses a 4x4 area of all 255, which is zoomed out to a 4x4 area
    # in which the center 2x2 area is 255
    # zoom in should probably be adapted to this style
    # no separate tests here for x/y axis, should work fine if zoom in works with that
    aug = iaa.Affine(scale=0.49, translate_px=0, rotate=0, shear=0)
    aug_det = aug.to_deterministic()

    image = np.ones((4, 4, 1), dtype=np.uint8) * 255
    images = np.array([image])
    images_list = [image]
    outer_pixels = ([], [])
    for y in sm.xrange(4):
        xs = sm.xrange(4) if y in [0, 3] else [0, 3]
        for x in xs:
            outer_pixels[0].append(y)
            outer_pixels[1].append(x)
    inner_pixels = ([1, 1, 2, 2], [1, 2, 1, 2])
    keypoints = [ia.KeypointsOnImage([ia.Keypoint(x=0, y=0), ia.Keypoint(x=3, y=0),
                                      ia.Keypoint(x=0, y=3), ia.Keypoint(x=3, y=3)],
                                     shape=image.shape)]
    keypoints_aug = [ia.KeypointsOnImage([ia.Keypoint(x=0.765, y=0.765), ia.Keypoint(x=2.235, y=0.765),
                                          ia.Keypoint(x=0.765, y=2.235), ia.Keypoint(x=2.235, y=2.235)],
                                         shape=image.shape)]

    observed = aug.augment_images(images)
    assert (observed[0][outer_pixels] &lt; 25).all()
    assert (observed[0][inner_pixels] &gt; 200).all()

    observed = aug_det.augment_images(images)
    assert (observed[0][outer_pixels] &lt; 25).all()
    assert (observed[0][inner_pixels] &gt; 200).all()

    observed = aug.augment_images(images_list)
    assert (observed[0][outer_pixels] &lt; 25).all()
    assert (observed[0][inner_pixels] &gt; 200).all()

    observed = aug_det.augment_images(images_list)
    assert (observed[0][outer_pixels] &lt; 25).all()
    assert (observed[0][inner_pixels] &gt; 200).all()

    observed = aug.augment_keypoints(keypoints)
    assert keypoints_equal(observed, keypoints_aug)

    observed = aug_det.augment_keypoints(keypoints)
    assert keypoints_equal(observed, keypoints_aug)

    # varying scales
    aug = iaa.Affine(scale={"x": (0.5, 1.5), "y": (0.5, 1.5)}, translate_px=0,
                     rotate=0, shear=0)
    aug_det = aug.to_deterministic()

    image = np.array([[0, 0, 0, 0, 0],
                      [0, 1, 1, 1, 0],
                      [0, 1, 2, 1, 0],
                      [0, 1, 1, 1, 0],
                      [0, 0, 0, 0, 0]], dtype=np.uint8) * 100
    image = image[:, :, np.newaxis]
    images = np.array([image])

    last_aug = None
    last_aug_det = None
    nb_changed_aug = 0
    nb_changed_aug_det = 0
    nb_iterations = 1000
    for i in sm.xrange(nb_iterations):
        observed_aug = aug.augment_images(images)
        observed_aug_det = aug_det.augment_images(images)
        if i == 0:
            last_aug = observed_aug
            last_aug_det = observed_aug_det
        else:
            if not np.array_equal(observed_aug, last_aug):
                nb_changed_aug += 1
            if not np.array_equal(observed_aug_det, last_aug_det):
                nb_changed_aug_det += 1
            last_aug = observed_aug
            last_aug_det = observed_aug_det
    assert nb_changed_aug &gt;= int(nb_iterations * 0.8)
    assert nb_changed_aug_det == 0

    aug = iaa.Affine(scale=iap.Uniform(0.7, 0.9))
    assert isinstance(aug.scale, iap.Uniform)
    assert isinstance(aug.scale.a, iap.Deterministic)
    assert isinstance(aug.scale.b, iap.Deterministic)
    assert 0.7 - 1e-8 &lt; aug.scale.a.value &lt; 0.7 + 1e-8
    assert 0.9 - 1e-8 &lt; aug.scale.b.value &lt; 0.9 + 1e-8

    # ---------------------
    # translate
    # ---------------------
    # move one pixel to the right
    aug = iaa.Affine(scale=1.0, translate_px={"x": 1, "y": 0}, rotate=0, shear=0)
    aug_det = aug.to_deterministic()

    image = np.zeros((3, 3, 1), dtype=np.uint8)
    image_aug = np.copy(image)
    image[1, 1] = 255
    image_aug[1, 2] = 255
    images = np.array([image])
    images_aug = np.array([image_aug])
    images_list = [image]
    images_aug_list = [image_aug]
    keypoints = [ia.KeypointsOnImage([ia.Keypoint(x=1, y=1)], shape=base_img.shape)]
    keypoints_aug = [ia.KeypointsOnImage([ia.Keypoint(x=2, y=1)], shape=base_img.shape)]

    observed = aug.augment_images(images)
    assert np.array_equal(observed, images_aug)

    observed = aug_det.augment_images(images)
    assert np.array_equal(observed, images_aug)

    observed = aug.augment_images(images_list)
    assert array_equal_lists(observed, images_aug_list)

    observed = aug_det.augment_images(images_list)
    assert array_equal_lists(observed, images_aug_list)

    observed = aug.augment_keypoints(keypoints)
    assert keypoints_equal(observed, keypoints_aug)

    observed = aug_det.augment_keypoints(keypoints)
    assert keypoints_equal(observed, keypoints_aug)

    # move one pixel to the right
    # with backend = skimage
    aug = iaa.Affine(scale=1.0, translate_px={"x": 1, "y": 0}, rotate=0, shear=0, backend="skimage")
    observed = aug.augment_images(images)
    assert np.array_equal(observed, images_aug)

    # move one pixel to the right
    # with backend = skimage
    aug = iaa.Affine(scale=1.0, translate_px={"x": 1, "y": 0}, rotate=0, shear=0, backend="skimage")
    observed = aug.augment_images(images)
    assert np.array_equal(observed, images_aug)

    # move one pixel to the right
    # with backend = skimage, order=ALL
    aug = iaa.Affine(scale=1.0, translate_px={"x": 1, "y": 0}, rotate=0, shear=0, backend="skimage", order=ia.ALL)
    observed = aug.augment_images(images)
    assert np.array_equal(observed, images_aug)

    # move one pixel to the right
    # with backend = skimage, order=list
    aug = iaa.Affine(scale=1.0, translate_px={"x": 1, "y": 0}, rotate=0, shear=0, backend="skimage", order=[0, 1, 3])
    observed = aug.augment_images(images)
    assert np.array_equal(observed, images_aug)

    # move one pixel to the right
    # with backend = cv2, order=list
    aug = iaa.Affine(scale=1.0, translate_px={"x": 1, "y": 0}, rotate=0, shear=0, backend="cv2", order=[0, 1, 3])
    observed = aug.augment_images(images)
    assert np.array_equal(observed, images_aug)

    # move one pixel to the right
    # with backend = cv2, order=StochasticParameter
    aug = iaa.Affine(scale=1.0, translate_px={"x": 1, "y": 0}, rotate=0, shear=0, backend="cv2", order=iap.Choice([0, 1, 3]))
    observed = aug.augment_images(images)
    assert np.array_equal(observed, images_aug)

    # move one pixel to the bottom
    aug = iaa.Affine(scale=1.0, translate_px={"x": 0, "y": 1}, rotate=0, shear=0)
    aug_det = aug.to_deterministic()

    image = np.zeros((3, 3, 1), dtype=np.uint8)
    image_aug = np.copy(image)
    image[1, 1] = 255
    image_aug[2, 1] = 255
    images = np.array([image])
    images_aug = np.array([image_aug])
    images_list = [image]
    images_aug_list = [image_aug]
    keypoints = [ia.KeypointsOnImage([ia.Keypoint(x=1, y=1)], shape=base_img.shape)]
    keypoints_aug = [ia.KeypointsOnImage([ia.Keypoint(x=1, y=2)], shape=base_img.shape)]

    observed = aug.augment_images(images)
    assert np.array_equal(observed, images_aug)

    observed = aug_det.augment_images(images)
    assert np.array_equal(observed, images_aug)

    observed = aug.augment_images(images_list)
    assert array_equal_lists(observed, images_aug_list)

    observed = aug_det.augment_images(images_list)
    assert array_equal_lists(observed, images_aug_list)

    observed = aug.augment_keypoints(keypoints)
    assert keypoints_equal(observed, keypoints_aug)

    observed = aug_det.augment_keypoints(keypoints)
    assert keypoints_equal(observed, keypoints_aug)

    # move 33% (one pixel) to the right
    aug = iaa.Affine(scale=1.0, translate_percent={"x": 0.3333, "y": 0}, rotate=0, shear=0)
    aug_det = aug.to_deterministic()

    image = np.zeros((3, 3, 1), dtype=np.uint8)
    image_aug = np.copy(image)
    image[1, 1] = 255
    image_aug[1, 2] = 255
    images = np.array([image])
    images_aug = np.array([image_aug])
    images_list = [image]
    images_aug_list = [image_aug]
    keypoints = [ia.KeypointsOnImage([ia.Keypoint(x=1, y=1)], shape=base_img.shape)]
    keypoints_aug = [ia.KeypointsOnImage([ia.Keypoint(x=2, y=1)], shape=base_img.shape)]

    observed = aug.augment_images(images)
    assert np.array_equal(observed, images_aug)

    observed = aug_det.augment_images(images)
    assert np.array_equal(observed, images_aug)

    observed = aug.augment_images(images_list)
    assert array_equal_lists(observed, images_aug_list)

    observed = aug_det.augment_images(images_list)
    assert array_equal_lists(observed, images_aug_list)

    observed = aug.augment_keypoints(keypoints)
    assert keypoints_equal(observed, keypoints_aug)

    observed = aug_det.augment_keypoints(keypoints)
    assert keypoints_equal(observed, keypoints_aug)

    # move 33% (one pixel) to the bottom
    aug = iaa.Affine(scale=1.0, translate_percent={"x": 0, "y": 0.3333}, rotate=0, shear=0)
    aug_det = aug.to_deterministic()

    image = np.zeros((3, 3, 1), dtype=np.uint8)
    image_aug = np.copy(image)
    image[1, 1] = 255
    image_aug[2, 1] = 255
    images = np.array([image])
    images_aug = np.array([image_aug])
    images_list = [image]
    images_aug_list = [image_aug]
    keypoints = [ia.KeypointsOnImage([ia.Keypoint(x=1, y=1)], shape=base_img.shape)]
    keypoints_aug = [ia.KeypointsOnImage([ia.Keypoint(x=1, y=2)], shape=base_img.shape)]

    observed = aug.augment_images(images)
    assert np.array_equal(observed, images_aug)

    observed = aug_det.augment_images(images)
    assert np.array_equal(observed, images_aug)

    observed = aug.augment_images(images_list)
    assert array_equal_lists(observed, images_aug_list)

    observed = aug_det.augment_images(images_list)
    assert array_equal_lists(observed, images_aug_list)

    observed = aug.augment_keypoints(keypoints)
    assert keypoints_equal(observed, keypoints_aug)

    observed = aug_det.augment_keypoints(keypoints)
    assert keypoints_equal(observed, keypoints_aug)

    # 0-1px to left/right and 0-1px to top/bottom
    aug = iaa.Affine(scale=1.0, translate_px={"x": (-1, 1), "y": (-1, 1)}, rotate=0, shear=0)
    aug_det = aug.to_deterministic()
    last_aug = None
    last_aug_det = None
    nb_changed_aug = 0
    nb_changed_aug_det = 0
    nb_iterations = 1000
    centers_aug = np.copy(image).astype(np.int32) * 0
    centers_aug_det = np.copy(image).astype(np.int32) * 0
    for i in sm.xrange(nb_iterations):
        observed_aug = aug.augment_images(images)
        observed_aug_det = aug_det.augment_images(images)
        if i == 0:
            last_aug = observed_aug
            last_aug_det = observed_aug_det
        else:
            if not np.array_equal(observed_aug, last_aug):
                nb_changed_aug += 1
            if not np.array_equal(observed_aug_det, last_aug_det):
                nb_changed_aug_det += 1
            last_aug = observed_aug
            last_aug_det = observed_aug_det

        assert len(observed_aug[0].nonzero()[0]) == 1
        assert len(observed_aug_det[0].nonzero()[0]) == 1
        centers_aug += (observed_aug[0] &gt; 0)
        centers_aug_det += (observed_aug_det[0] &gt; 0)

    assert nb_changed_aug &gt;= int(nb_iterations * 0.7)
    assert nb_changed_aug_det == 0
    assert (centers_aug &gt; int(nb_iterations * (1/9 * 0.6))).all()
    assert (centers_aug &lt; int(nb_iterations * (1/9 * 1.4))).all()

    aug = iaa.Affine(translate_percent=iap.Uniform(0.7, 0.9))
    assert isinstance(aug.translate, iap.Uniform)
    assert isinstance(aug.translate.a, iap.Deterministic)
    assert isinstance(aug.translate.b, iap.Deterministic)
    assert 0.7 - 1e-8 &lt; aug.translate.a.value &lt; 0.7 + 1e-8
    assert 0.9 - 1e-8 &lt; aug.translate.b.value &lt; 0.9 + 1e-8

    aug = iaa.Affine(translate_px=iap.DiscreteUniform(1, 10))
    assert isinstance(aug.translate, iap.DiscreteUniform)
    assert isinstance(aug.translate.a, iap.Deterministic)
    assert isinstance(aug.translate.b, iap.Deterministic)
    assert aug.translate.a.value == 1
    assert aug.translate.b.value == 10

    # ---------------------
    # translate heatmaps
    # ---------------------
    heatmaps = ia.HeatmapsOnImage(
        np.float32([
            [0.0, 0.5, 0.75],
            [0.0, 0.5, 0.75],
            [0.75, 0.75, 0.75],
        ]),
        shape=(3, 3, 3)
    )
    arr_expected_1px_right = np.float32([
        [0.0, 0.0, 0.5],
        [0.0, 0.0, 0.5],
        [0.0, 0.75, 0.75],
    ])
    aug = iaa.Affine(translate_px={"x": 1})
    observed = aug.augment_heatmaps([heatmaps])[0]
    assert observed.shape == heatmaps.shape
    assert heatmaps.min_value - 1e-6 &lt; observed.min_value &lt; heatmaps.min_value + 1e-6
    assert heatmaps.max_value - 1e-6 &lt; observed.max_value &lt; heatmaps.max_value + 1e-6
    assert np.array_equal(observed.get_arr(), arr_expected_1px_right)

    # should still use mode=constant cval=0 even when other settings chosen
    aug = iaa.Affine(translate_px={"x": 1}, cval=255)
    observed = aug.augment_heatmaps([heatmaps])[0]
    assert observed.shape == heatmaps.shape
    assert heatmaps.min_value - 1e-6 &lt; observed.min_value &lt; heatmaps.min_value + 1e-6
    assert heatmaps.max_value - 1e-6 &lt; observed.max_value &lt; heatmaps.max_value + 1e-6
    assert np.array_equal(observed.get_arr(), arr_expected_1px_right)

    aug = iaa.Affine(translate_px={"x": 1}, mode="edge", cval=255)
    observed = aug.augment_heatmaps([heatmaps])[0]
    assert observed.shape == heatmaps.shape
    assert heatmaps.min_value - 1e-6 &lt; observed.min_value &lt; heatmaps.min_value + 1e-6
    assert heatmaps.max_value - 1e-6 &lt; observed.max_value &lt; heatmaps.max_value + 1e-6
    assert np.array_equal(observed.get_arr(), arr_expected_1px_right)

    # ---------------------
    # rotate
    # ---------------------
    # rotate by 45 degrees
    aug = iaa.Affine(scale=1.0, translate_px=0, rotate=90, shear=0)
    aug_det = aug.to_deterministic()

    image = np.zeros((3, 3, 1), dtype=np.uint8)
    image_aug = np.copy(image)
    image[1, :] = 255
    image_aug[0, 1] = 255
    image_aug[1, 1] = 255
    image_aug[2, 1] = 255
    images = np.array([image])
    images_aug = np.array([image_aug])
    images_list = [image]
    images_aug_list = [image_aug]
    keypoints = [ia.KeypointsOnImage([ia.Keypoint(x=0, y=1), ia.Keypoint(x=1, y=1),
                                      ia.Keypoint(x=2, y=1)], shape=base_img.shape)]
    keypoints_aug = [ia.KeypointsOnImage([ia.Keypoint(x=1, y=0), ia.Keypoint(x=1, y=1),
                                          ia.Keypoint(x=1, y=2)], shape=base_img.shape)]

    observed = aug.augment_images(images)
    observed[observed &gt;= 100] = 255
    observed[observed &lt; 100] = 0
    assert np.array_equal(observed, images_aug)

    observed = aug_det.augment_images(images)
    observed[observed &gt;= 100] = 255
    observed[observed &lt; 100] = 0
    assert np.array_equal(observed, images_aug)

    observed = aug.augment_images(images_list)
    observed[0][observed[0] &gt;= 100] = 255
    observed[0][observed[0] &lt; 100] = 0
    assert array_equal_lists(observed, images_aug_list)

    observed = aug_det.augment_images(images_list)
    observed[0][observed[0] &gt;= 100] = 255
    observed[0][observed[0] &lt; 100] = 0
    assert array_equal_lists(observed, images_aug_list)

    observed = aug.augment_keypoints(keypoints)
    assert keypoints_equal(observed, keypoints_aug)

    observed = aug_det.augment_keypoints(keypoints)
    assert keypoints_equal(observed, keypoints_aug)

    # rotate by StochasticParameter
    aug = iaa.Affine(scale=1.0, translate_px=0, rotate=iap.Uniform(10, 20), shear=0)
    assert isinstance(aug.rotate, iap.Uniform)
    assert isinstance(aug.rotate.a, iap.Deterministic)
    assert aug.rotate.a.value == 10
    assert isinstance(aug.rotate.b, iap.Deterministic)
    assert aug.rotate.b.value == 20

    # random rotation 0-364 degrees
    aug = iaa.Affine(scale=1.0, translate_px=0, rotate=(0, 364), shear=0)
    aug_det = aug.to_deterministic()
    last_aug = None
    last_aug_det = None
    nb_changed_aug = 0
    nb_changed_aug_det = 0
    nb_iterations = 1000
    pixels_sums_aug = np.copy(image).astype(np.int32) * 0
    pixels_sums_aug_det = np.copy(image).astype(np.int32) * 0
    for i in sm.xrange(nb_iterations):
        observed_aug = aug.augment_images(images)
        observed_aug_det = aug_det.augment_images(images)
        if i == 0:
            last_aug = observed_aug
            last_aug_det = observed_aug_det
        else:
            if not np.array_equal(observed_aug, last_aug):
                nb_changed_aug += 1
            if not np.array_equal(observed_aug_det, last_aug_det):
                nb_changed_aug_det += 1
            last_aug = observed_aug
            last_aug_det = observed_aug_det

        pixels_sums_aug += (observed_aug[0] &gt; 100)
        pixels_sums_aug_det += (observed_aug_det[0] &gt; 100)

    assert nb_changed_aug &gt;= int(nb_iterations * 0.9)
    assert nb_changed_aug_det == 0
    # center pixel, should always be white when rotating line around center
    assert pixels_sums_aug[1, 1] &gt; (nb_iterations * 0.98)
    assert pixels_sums_aug[1, 1] &lt; (nb_iterations * 1.02)

    # outer pixels, should sometimes be white
    # the values here had to be set quite tolerant, the middle pixels at top/left/bottom/right get more activation
    # than expected
    outer_pixels = ([0, 0, 0, 1, 1, 2, 2, 2], [0, 1, 2, 0, 2, 0, 1, 2])
    assert (pixels_sums_aug[outer_pixels] &gt; int(nb_iterations * (2/8 * 0.4))).all()
    assert (pixels_sums_aug[outer_pixels] &lt; int(nb_iterations * (2/8 * 2.0))).all()

    for backend in ["auto", "cv2", "skimage"]:
        # measure alignment between images and heatmaps when rotating
        aug = iaa.Affine(rotate=45, backend=backend)
        image = np.zeros((7, 6), dtype=np.uint8)
        image[:, 2:3+1] = 255
        hm = ia.HeatmapsOnImage(image.astype(np.float32)/255, shape=(7, 6))
        img_aug = aug.augment_image(image)
        hm_aug = aug.augment_heatmaps([hm])[0]
        assert hm_aug.shape == (7, 6)
        assert hm_aug.arr_0to1.shape == (7, 6, 1)
        img_aug_mask = img_aug &gt; 255*0.1
        hm_aug_mask = hm_aug.arr_0to1 &gt; 0.1
        same = np.sum(img_aug_mask == hm_aug_mask[:, :, 0])
        assert (same / img_aug_mask.size) &gt;= 0.99

        # measure alignment between images and heatmaps when rotating
        # here with smaller heatmaps
        aug = iaa.Affine(rotate=45, backend=backend)
        image = np.zeros((56, 48), dtype=np.uint8)
        image[:, 16:24+1] = 255
        hm = ia.HeatmapsOnImage(
            ia.imresize_single_image(image, (28, 24), interpolation="cubic").astype(np.float32)/255,
            shape=(56, 48)
        )
        img_aug = aug.augment_image(image)
        hm_aug = aug.augment_heatmaps([hm])[0]
        assert hm_aug.shape == (56, 48)
        assert hm_aug.arr_0to1.shape == (28, 24, 1)
        img_aug_mask = img_aug &gt; 255*0.1
        hm_aug_mask = ia.imresize_single_image(hm_aug.arr_0to1, img_aug.shape[0:2], interpolation="cubic") &gt; 0.1
        same = np.sum(img_aug_mask == hm_aug_mask[:, :, 0])
        assert (same / img_aug_mask.size) &gt;= 0.9

    # ---------------------
    # shear
    # ---------------------
    # TODO

    # shear by StochasticParameter
    aug = iaa.Affine(scale=1.0, translate_px=0, rotate=0, shear=iap.Uniform(10, 20))
    assert isinstance(aug.shear, iap.Uniform)
    assert isinstance(aug.shear.a, iap.Deterministic)
    assert aug.shear.a.value == 10
    assert isinstance(aug.shear.b, iap.Deterministic)
    assert aug.shear.b.value == 20

    # ---------------------
    # cval
    # ---------------------
    aug = iaa.Affine(scale=1.0, translate_px=100, rotate=0, shear=0, cval=128)
    aug_det = aug.to_deterministic()

    image = np.ones((3, 3, 1), dtype=np.uint8) * 255
    images = np.array([image])
    images_list = [image]

    observed = aug.augment_images(images)
    assert (observed[0] &gt; 128 - 30).all()
    assert (observed[0] &lt; 128 + 30).all()

    observed = aug_det.augment_images(images)
    assert (observed[0] &gt; 128 - 30).all()
    assert (observed[0] &lt; 128 + 30).all()

    observed = aug.augment_images(images_list)
    assert (observed[0] &gt; 128 - 30).all()
    assert (observed[0] &lt; 128 + 30).all()

    observed = aug_det.augment_images(images_list)
    assert (observed[0] &gt; 128 - 30).all()
    assert (observed[0] &lt; 128 + 30).all()

    # random cvals
    aug = iaa.Affine(scale=1.0, translate_px=100, rotate=0, shear=0, cval=(0, 255))
    aug_det = aug.to_deterministic()
    last_aug = None
    last_aug_det = None
    nb_changed_aug = 0
    nb_changed_aug_det = 0
    nb_iterations = 1000
    averages = []
    for i in sm.xrange(nb_iterations):
        observed_aug = aug.augment_images(images)
        observed_aug_det = aug_det.augment_images(images)
        if i == 0:
            last_aug = observed_aug
            last_aug_det = observed_aug_det
        else:
            if not np.array_equal(observed_aug, last_aug):
                nb_changed_aug += 1
            if not np.array_equal(observed_aug_det, last_aug_det):
                nb_changed_aug_det += 1
            last_aug = observed_aug
            last_aug_det = observed_aug_det

        averages.append(int(np.average(observed_aug)))

    assert nb_changed_aug &gt;= int(nb_iterations * 0.9)
    assert nb_changed_aug_det == 0
    # center pixel, should always be white when rotating line around center
    assert pixels_sums_aug[1, 1] &gt; (nb_iterations * 0.98)
    assert pixels_sums_aug[1, 1] &lt; (nb_iterations * 1.02)
    assert len(set(averages)) &gt; 200

    aug = iaa.Affine(scale=1.0, translate_px=100, rotate=0, shear=0, cval=ia.ALL)
    assert isinstance(aug.cval, iap.Uniform)
    assert isinstance(aug.cval.a, iap.Deterministic)
    assert isinstance(aug.cval.b, iap.Deterministic)
    assert aug.cval.a.value == 0
    assert aug.cval.b.value == 255

    aug = iaa.Affine(scale=1.0, translate_px=100, rotate=0, shear=0, cval=iap.DiscreteUniform(1, 5))
    assert isinstance(aug.cval, iap.DiscreteUniform)
    assert isinstance(aug.cval.a, iap.Deterministic)
    assert isinstance(aug.cval.b, iap.Deterministic)
    assert aug.cval.a.value == 1
    assert aug.cval.b.value == 5

    # ------------
    # mode
    # ------------
    aug = iaa.Affine(scale=1.0, translate_px=100, rotate=0, shear=0, cval=0, mode=ia.ALL)
    assert isinstance(aug.mode, iap.Choice)
    aug = iaa.Affine(scale=1.0, translate_px=100, rotate=0, shear=0, cval=0, mode="edge")
    assert isinstance(aug.mode, iap.Deterministic)
    assert aug.mode.value == "edge"
    aug = iaa.Affine(scale=1.0, translate_px=100, rotate=0, shear=0, cval=0, mode=["constant", "edge"])
    assert isinstance(aug.mode, iap.Choice)
    assert len(aug.mode.a) == 2 and "constant" in aug.mode.a and "edge" in aug.mode.a
    aug = iaa.Affine(scale=1.0, translate_px=100, rotate=0, shear=0, cval=0, mode=iap.Choice(["constant", "edge"]))
    assert isinstance(aug.mode, iap.Choice)
    assert len(aug.mode.a) == 2 and "constant" in aug.mode.a and "edge" in aug.mode.a

    # ------------
    # fit_output
    # ------------
    for backend in ["auto", "cv2", "skimage"]:
        aug = iaa.Affine(scale=1.0, translate_px=100, fit_output=True, backend=backend)
        assert aug.fit_output is True
        observed = aug.augment_images(images)
        expected = images
        assert np.array_equal(observed, expected)
        observed = aug.augment_keypoints(keypoints)
        expected = keypoints
        assert keypoints_equal(observed, expected)
        observed = aug.augment_heatmaps([heatmaps])[0]
        expected = heatmaps
        assert np.allclose(observed.arr_0to1, expected.arr_0to1)

        # fit_output with rotation
        aug = iaa.Affine(rotate=45, fit_output=True, backend=backend)
        img = np.zeros((10, 10), dtype=np.uint8)
        img[0:2, 0:2] = 255
        img[-2:, 0:2] = 255
        img[0:2, -2:] = 255
        img[-2:, -2:] = 255
        hm = ia.HeatmapsOnImage(img.astype(np.float32)/255, shape=(10, 10))
        img_aug = aug.augment_image(img)
        hm_aug = aug.augment_heatmaps([hm])[0]
        _labels, nb_labels = skimage.morphology.label(img_aug &gt; 240, return_num=True, connectivity=2)
        assert nb_labels == 4
        _labels, nb_labels = skimage.morphology.label(hm_aug.arr_0to1 &gt; 240/255, return_num=True, connectivity=2)
        assert nb_labels == 4

        # fit_output with differently sized heatmaps
        aug = iaa.Affine(rotate=45, fit_output=True, backend=backend)
        img = np.zeros((80, 80), dtype=np.uint8)
        img[0:5, 0:5] = 255
        img[-5:, 0:5] = 255
        img[0:5, -5:] = 255
        img[-5:, -5:] = 255
        hm = ia.HeatmapsOnImage(
            ia.imresize_single_image(img, (40, 40), interpolation="cubic").astype(np.float32)/255,
            shape=(80, 80)
        )
        img_aug = aug.augment_image(img)
        hm_aug = aug.augment_heatmaps([hm])[0]
        # these asserts are deactivated because the image size can change under fit_output=True
        # assert hm_aug.shape == (80, 80)
        # assert hm_aug.arr_0to1.shape == (40, 40, 1)
        _labels, nb_labels = skimage.morphology.label(img_aug &gt; 240, return_num=True, connectivity=2)
        assert nb_labels == 4
        _labels, nb_labels = skimage.morphology.label(hm_aug.arr_0to1 &gt; 200/255, return_num=True, connectivity=2)
        assert nb_labels == 4

        img_aug_mask = img_aug &gt; 255*0.1
        hm_aug_mask = ia.imresize_single_image(hm_aug.arr_0to1, img_aug.shape[0:2], interpolation="cubic") &gt; 0.1
        same = np.sum(img_aug_mask == hm_aug_mask[:, :, 0])
        assert (same / img_aug_mask.size) &gt;= 0.95

    # ------------
    # exceptions for bad inputs
    # ------------
    # scale
    got_exception = False
    try:
        _ = iaa.Affine(scale=False)
    except Exception:
        got_exception = True
    assert got_exception

    # translate_px
    got_exception = False
    try:
        _ = iaa.Affine(translate_px=False)
    except Exception:
        got_exception = True
    assert got_exception

    # translate_percent
    got_exception = False
    try:
        _ = iaa.Affine(translate_percent=False)
    except Exception:
        got_exception = True
    assert got_exception

    # rotate
    got_exception = False
    try:
        _ = iaa.Affine(scale=1.0, translate_px=0, rotate=False, shear=0, cval=0)
    except Exception:
        got_exception = True
    assert got_exception

    # shear
    got_exception = False
    try:
        _ = iaa.Affine(scale=1.0, translate_px=0, rotate=0, shear=False, cval=0)
    except Exception:
        got_exception = True
    assert got_exception

    # cval
    got_exception = False
    try:
        _ = iaa.Affine(scale=1.0, translate_px=100, rotate=0, shear=0, cval=None)
    except Exception:
        got_exception = True
    assert got_exception

    # mode
    got_exception = False
    try:
        _ = iaa.Affine(scale=1.0, translate_px=100, rotate=0, shear=0, cval=0, mode=False)
    except Exception:
        got_exception = True
    assert got_exception

    # non-existent order in case of backend=cv2
    got_exception = False
    try:
        _ = iaa.Affine(backend="cv2", order=-1)
    except Exception:
        got_exception = True
    assert got_exception

    # bad order datatype in case of backend=cv2
    got_exception = False
    try:
        _ = iaa.Affine(backend="cv2", order="test")
    except Exception:
        got_exception = True
    assert got_exception

    # ----------
    # get_parameters
    # ----------
    aug = iaa.Affine(scale=1, translate_px=2, rotate=3, shear=4, order=1, cval=0, mode="constant", backend="cv2",
                     fit_output=True)
    params = aug.get_parameters()
    assert isinstance(params[0], iap.Deterministic)  # scale
    assert isinstance(params[1], iap.Deterministic)  # translate
    assert isinstance(params[2], iap.Deterministic)  # rotate
    assert isinstance(params[3], iap.Deterministic)  # shear
    assert params[0].value == 1  # scale
    assert params[1].value == 2  # translate
    assert params[2].value == 3  # rotate
    assert params[3].value == 4  # shear
    assert params[4].value == 1  # order
    assert params[5].value == 0  # cval
    assert params[6].value == "constant"  # mode
    assert params[7] == "cv2"  # backend
    assert params[8] is True  # fit_output


</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag801')" href="javascript:;">
imgaug-0.2.7/test/augmenters/test_geometric.py: 945-1759
</a>
<div class="mid" id="frag801" style="display:none"><pre>
def test_AffineCv2():
    reseed()

    base_img = np.array([[0, 0, 0],
                         [0, 255, 0],
                         [0, 0, 0]], dtype=np.uint8)
    base_img = base_img[:, :, np.newaxis]

    images = np.array([base_img])
    images_list = [base_img]
    outer_pixels = ([], [])
    for i in sm.xrange(base_img.shape[0]):
        for j in sm.xrange(base_img.shape[1]):
            if i != j:
                outer_pixels[0].append(i)
                outer_pixels[1].append(j)

    keypoints = [ia.KeypointsOnImage([ia.Keypoint(x=0, y=0), ia.Keypoint(x=1, y=1),
                                      ia.Keypoint(x=2, y=2)], shape=base_img.shape)]

    # no translation/scale/rotate/shear, shouldnt change nothing
    aug = iaa.AffineCv2(scale=1.0, translate_px=0, rotate=0, shear=0)
    aug_det = aug.to_deterministic()

    observed = aug.augment_images(images)
    expected = images
    assert np.array_equal(observed, expected)

    observed = aug_det.augment_images(images)
    expected = images
    assert np.array_equal(observed, expected)

    observed = aug.augment_images(images_list)
    expected = images_list
    assert array_equal_lists(observed, expected)

    observed = aug_det.augment_images(images_list)
    expected = images_list
    assert array_equal_lists(observed, expected)

    observed = aug.augment_keypoints(keypoints)
    expected = keypoints
    assert keypoints_equal(observed, expected)

    observed = aug_det.augment_keypoints(keypoints)
    expected = keypoints
    assert keypoints_equal(observed, expected)

    # ---------------------
    # scale
    # ---------------------
    # zoom in
    aug = iaa.AffineCv2(scale=1.75, translate_px=0, rotate=0, shear=0)
    aug_det = aug.to_deterministic()

    observed = aug.augment_images(images)
    assert observed[0][1, 1] &gt; 250
    assert (observed[0][outer_pixels[0], outer_pixels[1]] &gt; 20).all()
    assert (observed[0][outer_pixels[0], outer_pixels[1]] &lt; 150).all()

    observed = aug_det.augment_images(images)
    assert observed[0][1, 1] &gt; 250
    assert (observed[0][outer_pixels[0], outer_pixels[1]] &gt; 20).all()
    assert (observed[0][outer_pixels[0], outer_pixels[1]] &lt; 150).all()

    observed = aug.augment_images(images_list)
    assert observed[0][1, 1] &gt; 250
    assert (observed[0][outer_pixels[0], outer_pixels[1]] &gt; 20).all()
    assert (observed[0][outer_pixels[0], outer_pixels[1]] &lt; 150).all()

    observed = aug_det.augment_images(images_list)
    assert observed[0][1, 1] &gt; 250
    assert (observed[0][outer_pixels[0], outer_pixels[1]] &gt; 20).all()
    assert (observed[0][outer_pixels[0], outer_pixels[1]] &lt; 150).all()

    observed = aug.augment_keypoints(keypoints)
    assert observed[0].keypoints[0].x &lt; 0
    assert observed[0].keypoints[0].y &lt; 0
    assert observed[0].keypoints[1].x == 1
    assert observed[0].keypoints[1].y == 1
    assert observed[0].keypoints[2].x &gt; 2
    assert observed[0].keypoints[2].y &gt; 2

    observed = aug_det.augment_keypoints(keypoints)
    assert observed[0].keypoints[0].x &lt; 0
    assert observed[0].keypoints[0].y &lt; 0
    assert observed[0].keypoints[1].x == 1
    assert observed[0].keypoints[1].y == 1
    assert observed[0].keypoints[2].x &gt; 2
    assert observed[0].keypoints[2].y &gt; 2

    # zoom in only on x axis
    aug = iaa.AffineCv2(scale={"x": 1.75, "y": 1.0}, translate_px=0, rotate=0, shear=0)
    aug_det = aug.to_deterministic()

    observed = aug.augment_images(images)
    assert observed[0][1, 1] &gt; 250
    assert (observed[0][[1, 1], [0, 2]] &gt; 20).all()
    assert (observed[0][[1, 1], [0, 2]] &lt; 150).all()
    assert (observed[0][0, :] &lt; 5).all()
    assert (observed[0][2, :] &lt; 5).all()

    observed = aug_det.augment_images(images)
    assert observed[0][1, 1] &gt; 250
    assert (observed[0][[1, 1], [0, 2]] &gt; 20).all()
    assert (observed[0][[1, 1], [0, 2]] &lt; 150).all()
    assert (observed[0][0, :] &lt; 5).all()
    assert (observed[0][2, :] &lt; 5).all()

    observed = aug.augment_images(images_list)
    assert observed[0][1, 1] &gt; 250
    assert (observed[0][[1, 1], [0, 2]] &gt; 20).all()
    assert (observed[0][[1, 1], [0, 2]] &lt; 150).all()
    assert (observed[0][0, :] &lt; 5).all()
    assert (observed[0][2, :] &lt; 5).all()

    observed = aug_det.augment_images(images_list)
    assert observed[0][1, 1] &gt; 250
    assert (observed[0][[1, 1], [0, 2]] &gt; 20).all()
    assert (observed[0][[1, 1], [0, 2]] &lt; 150).all()
    assert (observed[0][0, :] &lt; 5).all()
    assert (observed[0][2, :] &lt; 5).all()

    observed = aug.augment_keypoints(keypoints)
    assert observed[0].keypoints[0].x &lt; 0
    assert observed[0].keypoints[0].y == 0
    assert observed[0].keypoints[1].x == 1
    assert observed[0].keypoints[1].y == 1
    assert observed[0].keypoints[2].x &gt; 2
    assert observed[0].keypoints[2].y == 2

    observed = aug_det.augment_keypoints(keypoints)
    assert observed[0].keypoints[0].x &lt; 0
    assert observed[0].keypoints[0].y == 0
    assert observed[0].keypoints[1].x == 1
    assert observed[0].keypoints[1].y == 1
    assert observed[0].keypoints[2].x &gt; 2
    assert observed[0].keypoints[2].y == 2

    # zoom in only on y axis
    aug = iaa.AffineCv2(scale={"x": 1.0, "y": 1.75}, translate_px=0, rotate=0, shear=0)
    aug_det = aug.to_deterministic()

    observed = aug.augment_images(images)
    assert observed[0][1, 1] &gt; 250
    assert (observed[0][[0, 2], [1, 1]] &gt; 20).all()
    assert (observed[0][[0, 2], [1, 1]] &lt; 150).all()
    assert (observed[0][:, 0] &lt; 5).all()
    assert (observed[0][:, 2] &lt; 5).all()

    observed = aug_det.augment_images(images)
    assert observed[0][1, 1] &gt; 250
    assert (observed[0][[0, 2], [1, 1]] &gt; 20).all()
    assert (observed[0][[0, 2], [1, 1]] &lt; 150).all()
    assert (observed[0][:, 0] &lt; 5).all()
    assert (observed[0][:, 2] &lt; 5).all()

    observed = aug.augment_images(images_list)
    assert observed[0][1, 1] &gt; 250
    assert (observed[0][[0, 2], [1, 1]] &gt; 20).all()
    assert (observed[0][[0, 2], [1, 1]] &lt; 150).all()
    assert (observed[0][:, 0] &lt; 5).all()
    assert (observed[0][:, 2] &lt; 5).all()

    observed = aug_det.augment_images(images_list)
    assert observed[0][1, 1] &gt; 250
    assert (observed[0][[0, 2], [1, 1]] &gt; 20).all()
    assert (observed[0][[0, 2], [1, 1]] &lt; 150).all()
    assert (observed[0][:, 0] &lt; 5).all()
    assert (observed[0][:, 2] &lt; 5).all()

    observed = aug.augment_keypoints(keypoints)
    assert observed[0].keypoints[0].x == 0
    assert observed[0].keypoints[0].y &lt; 0
    assert observed[0].keypoints[1].x == 1
    assert observed[0].keypoints[1].y == 1
    assert observed[0].keypoints[2].x == 2
    assert observed[0].keypoints[2].y &gt; 2

    observed = aug_det.augment_keypoints(keypoints)
    assert observed[0].keypoints[0].x == 0
    assert observed[0].keypoints[0].y &lt; 0
    assert observed[0].keypoints[1].x == 1
    assert observed[0].keypoints[1].y == 1
    assert observed[0].keypoints[2].x == 2
    assert observed[0].keypoints[2].y &gt; 2

    # zoom out
    # this one uses a 4x4 area of all 255, which is zoomed out to a 4x4 area
    # in which the center 2x2 area is 255
    # zoom in should probably be adapted to this style
    # no separate tests here for x/y axis, should work fine if zoom in works with that
    aug = iaa.AffineCv2(scale=0.49, translate_px=0, rotate=0, shear=0)
    aug_det = aug.to_deterministic()

    image = np.ones((4, 4, 1), dtype=np.uint8) * 255
    images = np.array([image])
    images_list = [image]
    outer_pixels = ([], [])
    for y in sm.xrange(4):
        xs = sm.xrange(4) if y in [0, 3] else [0, 3]
        for x in xs:
            outer_pixels[0].append(y)
            outer_pixels[1].append(x)
    inner_pixels = ([1, 1, 2, 2], [1, 2, 1, 2])
    keypoints = [ia.KeypointsOnImage([ia.Keypoint(x=0, y=0), ia.Keypoint(x=3, y=0),
                                      ia.Keypoint(x=0, y=3), ia.Keypoint(x=3, y=3)],
                                     shape=image.shape)]
    keypoints_aug = [ia.KeypointsOnImage([ia.Keypoint(x=0.765, y=0.765), ia.Keypoint(x=2.235, y=0.765),
                                          ia.Keypoint(x=0.765, y=2.235), ia.Keypoint(x=2.235, y=2.235)],
                                         shape=image.shape)]

    observed = aug.augment_images(images)
    assert (observed[0][outer_pixels] &lt; 25).all()
    assert (observed[0][inner_pixels] &gt; 200).all()

    observed = aug_det.augment_images(images)
    assert (observed[0][outer_pixels] &lt; 25).all()
    assert (observed[0][inner_pixels] &gt; 200).all()

    observed = aug.augment_images(images_list)
    assert (observed[0][outer_pixels] &lt; 25).all()
    assert (observed[0][inner_pixels] &gt; 200).all()

    observed = aug_det.augment_images(images_list)
    assert (observed[0][outer_pixels] &lt; 25).all()
    assert (observed[0][inner_pixels] &gt; 200).all()

    observed = aug.augment_keypoints(keypoints)
    assert keypoints_equal(observed, keypoints_aug)

    observed = aug_det.augment_keypoints(keypoints)
    assert keypoints_equal(observed, keypoints_aug)

    # varying scales
    aug = iaa.AffineCv2(scale={"x": (0.5, 1.5), "y": (0.5, 1.5)}, translate_px=0,
                        rotate=0, shear=0)
    aug_det = aug.to_deterministic()

    image = np.array([[0, 0, 0, 0, 0],
                      [0, 1, 1, 1, 0],
                      [0, 1, 2, 1, 0],
                      [0, 1, 1, 1, 0],
                      [0, 0, 0, 0, 0]], dtype=np.uint8) * 100
    image = image[:, :, np.newaxis]
    images = np.array([image])

    last_aug = None
    last_aug_det = None
    nb_changed_aug = 0
    nb_changed_aug_det = 0
    nb_iterations = 1000
    for i in sm.xrange(nb_iterations):
        observed_aug = aug.augment_images(images)
        observed_aug_det = aug_det.augment_images(images)
        if i == 0:
            last_aug = observed_aug
            last_aug_det = observed_aug_det
        else:
            if not np.array_equal(observed_aug, last_aug):
                nb_changed_aug += 1
            if not np.array_equal(observed_aug_det, last_aug_det):
                nb_changed_aug_det += 1
            last_aug = observed_aug
            last_aug_det = observed_aug_det
    assert nb_changed_aug &gt;= int(nb_iterations * 0.8)
    assert nb_changed_aug_det == 0

    aug = iaa.AffineCv2(scale=iap.Uniform(0.7, 0.9))
    assert isinstance(aug.scale, iap.Uniform)
    assert isinstance(aug.scale.a, iap.Deterministic)
    assert isinstance(aug.scale.b, iap.Deterministic)
    assert 0.7 - 1e-8 &lt; aug.scale.a.value &lt; 0.7 + 1e-8
    assert 0.9 - 1e-8 &lt; aug.scale.b.value &lt; 0.9 + 1e-8

    # ---------------------
    # translate
    # ---------------------
    # move one pixel to the right
    aug = iaa.AffineCv2(scale=1.0, translate_px={"x": 1, "y": 0}, rotate=0, shear=0)
    aug_det = aug.to_deterministic()

    image = np.zeros((3, 3, 1), dtype=np.uint8)
    image_aug = np.copy(image)
    image[1, 1] = 255
    image_aug[1, 2] = 255
    images = np.array([image])
    images_aug = np.array([image_aug])
    images_list = [image]
    images_aug_list = [image_aug]
    keypoints = [ia.KeypointsOnImage([ia.Keypoint(x=1, y=1)], shape=base_img.shape)]
    keypoints_aug = [ia.KeypointsOnImage([ia.Keypoint(x=2, y=1)], shape=base_img.shape)]

    observed = aug.augment_images(images)
    assert np.array_equal(observed, images_aug)

    observed = aug_det.augment_images(images)
    assert np.array_equal(observed, images_aug)

    observed = aug.augment_images(images_list)
    assert array_equal_lists(observed, images_aug_list)

    observed = aug_det.augment_images(images_list)
    assert array_equal_lists(observed, images_aug_list)

    observed = aug.augment_keypoints(keypoints)
    assert keypoints_equal(observed, keypoints_aug)

    observed = aug_det.augment_keypoints(keypoints)
    assert keypoints_equal(observed, keypoints_aug)

    # move one pixel to the right
    aug = iaa.AffineCv2(scale=1.0, translate_px={"x": 1, "y": 0}, rotate=0, shear=0)
    observed = aug.augment_images(images)
    assert np.array_equal(observed, images_aug)

    # move one pixel to the right
    aug = iaa.AffineCv2(scale=1.0, translate_px={"x": 1, "y": 0}, rotate=0, shear=0)
    observed = aug.augment_images(images)
    assert np.array_equal(observed, images_aug)

    # move one pixel to the right
    # with order=ALL
    aug = iaa.AffineCv2(scale=1.0, translate_px={"x": 1, "y": 0}, rotate=0, shear=0, order=ia.ALL)
    observed = aug.augment_images(images)
    assert np.array_equal(observed, images_aug)

    # move one pixel to the right
    # with order=list
    aug = iaa.AffineCv2(scale=1.0, translate_px={"x": 1, "y": 0}, rotate=0, shear=0, order=[0, 1, 2])
    observed = aug.augment_images(images)
    assert np.array_equal(observed, images_aug)

    # move one pixel to the right
    # with order=StochasticParameter
    aug = iaa.AffineCv2(scale=1.0, translate_px={"x": 1, "y": 0}, rotate=0, shear=0, order=iap.Choice([0, 1, 2]))
    observed = aug.augment_images(images)
    assert np.array_equal(observed, images_aug)

    # move one pixel to the bottom
    aug = iaa.AffineCv2(scale=1.0, translate_px={"x": 0, "y": 1}, rotate=0, shear=0)
    aug_det = aug.to_deterministic()

    image = np.zeros((3, 3, 1), dtype=np.uint8)
    image_aug = np.copy(image)
    image[1, 1] = 255
    image_aug[2, 1] = 255
    images = np.array([image])
    images_aug = np.array([image_aug])
    images_list = [image]
    images_aug_list = [image_aug]
    keypoints = [ia.KeypointsOnImage([ia.Keypoint(x=1, y=1)], shape=base_img.shape)]
    keypoints_aug = [ia.KeypointsOnImage([ia.Keypoint(x=1, y=2)], shape=base_img.shape)]

    observed = aug.augment_images(images)
    assert np.array_equal(observed, images_aug)

    observed = aug_det.augment_images(images)
    assert np.array_equal(observed, images_aug)

    observed = aug.augment_images(images_list)
    assert array_equal_lists(observed, images_aug_list)

    observed = aug_det.augment_images(images_list)
    assert array_equal_lists(observed, images_aug_list)

    observed = aug.augment_keypoints(keypoints)
    assert keypoints_equal(observed, keypoints_aug)

    observed = aug_det.augment_keypoints(keypoints)
    assert keypoints_equal(observed, keypoints_aug)

    # move 33% (one pixel) to the right
    aug = iaa.AffineCv2(scale=1.0, translate_percent={"x": 0.3333, "y": 0}, rotate=0, shear=0)
    aug_det = aug.to_deterministic()

    image = np.zeros((3, 3, 1), dtype=np.uint8)
    image_aug = np.copy(image)
    image[1, 1] = 255
    image_aug[1, 2] = 255
    images = np.array([image])
    images_aug = np.array([image_aug])
    images_list = [image]
    images_aug_list = [image_aug]
    keypoints = [ia.KeypointsOnImage([ia.Keypoint(x=1, y=1)], shape=base_img.shape)]
    keypoints_aug = [ia.KeypointsOnImage([ia.Keypoint(x=2, y=1)], shape=base_img.shape)]

    observed = aug.augment_images(images)
    assert np.array_equal(observed, images_aug)

    observed = aug_det.augment_images(images)
    assert np.array_equal(observed, images_aug)

    observed = aug.augment_images(images_list)
    assert array_equal_lists(observed, images_aug_list)

    observed = aug_det.augment_images(images_list)
    assert array_equal_lists(observed, images_aug_list)

    observed = aug.augment_keypoints(keypoints)
    assert keypoints_equal(observed, keypoints_aug)

    observed = aug_det.augment_keypoints(keypoints)
    assert keypoints_equal(observed, keypoints_aug)

    # move 33% (one pixel) to the bottom
    aug = iaa.AffineCv2(scale=1.0, translate_percent={"x": 0, "y": 0.3333}, rotate=0, shear=0)
    aug_det = aug.to_deterministic()

    image = np.zeros((3, 3, 1), dtype=np.uint8)
    image_aug = np.copy(image)
    image[1, 1] = 255
    image_aug[2, 1] = 255
    images = np.array([image])
    images_aug = np.array([image_aug])
    images_list = [image]
    images_aug_list = [image_aug]
    keypoints = [ia.KeypointsOnImage([ia.Keypoint(x=1, y=1)], shape=base_img.shape)]
    keypoints_aug = [ia.KeypointsOnImage([ia.Keypoint(x=1, y=2)], shape=base_img.shape)]

    observed = aug.augment_images(images)
    assert np.array_equal(observed, images_aug)

    observed = aug_det.augment_images(images)
    assert np.array_equal(observed, images_aug)

    observed = aug.augment_images(images_list)
    assert array_equal_lists(observed, images_aug_list)

    observed = aug_det.augment_images(images_list)
    assert array_equal_lists(observed, images_aug_list)

    observed = aug.augment_keypoints(keypoints)
    assert keypoints_equal(observed, keypoints_aug)

    observed = aug_det.augment_keypoints(keypoints)
    assert keypoints_equal(observed, keypoints_aug)

    # 0-1px to left/right and 0-1px to top/bottom
    aug = iaa.AffineCv2(scale=1.0, translate_px={"x": (-1, 1), "y": (-1, 1)}, rotate=0, shear=0)
    aug_det = aug.to_deterministic()
    last_aug = None
    last_aug_det = None
    nb_changed_aug = 0
    nb_changed_aug_det = 0
    nb_iterations = 1000
    centers_aug = np.copy(image).astype(np.int32) * 0
    centers_aug_det = np.copy(image).astype(np.int32) * 0
    for i in sm.xrange(nb_iterations):
        observed_aug = aug.augment_images(images)
        observed_aug_det = aug_det.augment_images(images)
        if i == 0:
            last_aug = observed_aug
            last_aug_det = observed_aug_det
        else:
            if not np.array_equal(observed_aug, last_aug):
                nb_changed_aug += 1
            if not np.array_equal(observed_aug_det, last_aug_det):
                nb_changed_aug_det += 1
            last_aug = observed_aug
            last_aug_det = observed_aug_det

        assert len(observed_aug[0].nonzero()[0]) == 1
        assert len(observed_aug_det[0].nonzero()[0]) == 1
        centers_aug += (observed_aug[0] &gt; 0)
        centers_aug_det += (observed_aug_det[0] &gt; 0)

    assert nb_changed_aug &gt;= int(nb_iterations * 0.7)
    assert nb_changed_aug_det == 0
    assert (centers_aug &gt; int(nb_iterations * (1/9 * 0.6))).all()
    assert (centers_aug &lt; int(nb_iterations * (1/9 * 1.4))).all()

    aug = iaa.AffineCv2(translate_percent=iap.Uniform(0.7, 0.9))
    assert isinstance(aug.translate, iap.Uniform)
    assert isinstance(aug.translate.a, iap.Deterministic)
    assert isinstance(aug.translate.b, iap.Deterministic)
    assert 0.7 - 1e-8 &lt; aug.translate.a.value &lt; 0.7 + 1e-8
    assert 0.9 - 1e-8 &lt; aug.translate.b.value &lt; 0.9 + 1e-8

    aug = iaa.AffineCv2(translate_px=iap.DiscreteUniform(1, 10))
    assert isinstance(aug.translate, iap.DiscreteUniform)
    assert isinstance(aug.translate.a, iap.Deterministic)
    assert isinstance(aug.translate.b, iap.Deterministic)
    assert aug.translate.a.value == 1
    assert aug.translate.b.value == 10

    # ---------------------
    # translate heatmaps
    # ---------------------
    heatmaps = ia.HeatmapsOnImage(
        np.float32([
            [0.0, 0.5, 0.75],
            [0.0, 0.5, 0.75],
            [0.75, 0.75, 0.75],
        ]),
        shape=(3, 3, 3)
    )
    arr_expected_1px_right = np.float32([
        [0.0, 0.0, 0.5],
        [0.0, 0.0, 0.5],
        [0.0, 0.75, 0.75],
    ])
    aug = iaa.AffineCv2(translate_px={"x": 1})
    observed = aug.augment_heatmaps([heatmaps])[0]
    assert observed.shape == heatmaps.shape
    assert heatmaps.min_value - 1e-6 &lt; observed.min_value &lt; heatmaps.min_value + 1e-6
    assert heatmaps.max_value - 1e-6 &lt; observed.max_value &lt; heatmaps.max_value + 1e-6
    assert np.array_equal(observed.get_arr(), arr_expected_1px_right)

    # should still use mode=constant cval=0 even when other settings chosen
    aug = iaa.AffineCv2(translate_px={"x": 1}, cval=255)
    observed = aug.augment_heatmaps([heatmaps])[0]
    assert observed.shape == heatmaps.shape
    assert heatmaps.min_value - 1e-6 &lt; observed.min_value &lt; heatmaps.min_value + 1e-6
    assert heatmaps.max_value - 1e-6 &lt; observed.max_value &lt; heatmaps.max_value + 1e-6
    assert np.array_equal(observed.get_arr(), arr_expected_1px_right)

    aug = iaa.AffineCv2(translate_px={"x": 1}, mode="replicate", cval=255)
    observed = aug.augment_heatmaps([heatmaps])[0]
    assert observed.shape == heatmaps.shape
    assert heatmaps.min_value - 1e-6 &lt; observed.min_value &lt; heatmaps.min_value + 1e-6
    assert heatmaps.max_value - 1e-6 &lt; observed.max_value &lt; heatmaps.max_value + 1e-6
    assert np.array_equal(observed.get_arr(), arr_expected_1px_right)

    # ---------------------
    # rotate
    # ---------------------
    # rotate by 45 degrees
    aug = iaa.AffineCv2(scale=1.0, translate_px=0, rotate=90, shear=0)
    aug_det = aug.to_deterministic()

    image = np.zeros((3, 3, 1), dtype=np.uint8)
    image_aug = np.copy(image)
    image[1, :] = 255
    image_aug[0, 1] = 255
    image_aug[1, 1] = 255
    image_aug[2, 1] = 255
    images = np.array([image])
    images_aug = np.array([image_aug])
    images_list = [image]
    images_aug_list = [image_aug]
    keypoints = [ia.KeypointsOnImage([ia.Keypoint(x=0, y=1), ia.Keypoint(x=1, y=1),
                                      ia.Keypoint(x=2, y=1)], shape=base_img.shape)]
    keypoints_aug = [ia.KeypointsOnImage([ia.Keypoint(x=1, y=0), ia.Keypoint(x=1, y=1),
                                          ia.Keypoint(x=1, y=2)], shape=base_img.shape)]

    observed = aug.augment_images(images)
    observed[observed &gt;= 100] = 255
    observed[observed &lt; 100] = 0
    assert np.array_equal(observed, images_aug)

    observed = aug_det.augment_images(images)
    observed[observed &gt;= 100] = 255
    observed[observed &lt; 100] = 0
    assert np.array_equal(observed, images_aug)

    observed = aug.augment_images(images_list)
    observed[0][observed[0] &gt;= 100] = 255
    observed[0][observed[0] &lt; 100] = 0
    assert array_equal_lists(observed, images_aug_list)

    observed = aug_det.augment_images(images_list)
    observed[0][observed[0] &gt;= 100] = 255
    observed[0][observed[0] &lt; 100] = 0
    assert array_equal_lists(observed, images_aug_list)

    observed = aug.augment_keypoints(keypoints)
    assert keypoints_equal(observed, keypoints_aug)

    observed = aug_det.augment_keypoints(keypoints)
    assert keypoints_equal(observed, keypoints_aug)

    # rotate by StochasticParameter
    aug = iaa.AffineCv2(scale=1.0, translate_px=0, rotate=iap.Uniform(10, 20), shear=0)
    assert isinstance(aug.rotate, iap.Uniform)
    assert isinstance(aug.rotate.a, iap.Deterministic)
    assert aug.rotate.a.value == 10
    assert isinstance(aug.rotate.b, iap.Deterministic)
    assert aug.rotate.b.value == 20

    # random rotation 0-364 degrees
    aug = iaa.AffineCv2(scale=1.0, translate_px=0, rotate=(0, 364), shear=0)
    aug_det = aug.to_deterministic()
    last_aug = None
    last_aug_det = None
    nb_changed_aug = 0
    nb_changed_aug_det = 0
    nb_iterations = 1000
    pixels_sums_aug = np.copy(image).astype(np.int32) * 0
    pixels_sums_aug_det = np.copy(image).astype(np.int32) * 0
    for i in sm.xrange(nb_iterations):
        observed_aug = aug.augment_images(images)
        observed_aug_det = aug_det.augment_images(images)
        if i == 0:
            last_aug = observed_aug
            last_aug_det = observed_aug_det
        else:
            if not np.array_equal(observed_aug, last_aug):
                nb_changed_aug += 1
            if not np.array_equal(observed_aug_det, last_aug_det):
                nb_changed_aug_det += 1
            last_aug = observed_aug
            last_aug_det = observed_aug_det

        pixels_sums_aug += (observed_aug[0] &gt; 100)
        pixels_sums_aug_det += (observed_aug_det[0] &gt; 100)

    assert nb_changed_aug &gt;= int(nb_iterations * 0.9)
    assert nb_changed_aug_det == 0
    # center pixel, should always be white when rotating line around center
    assert pixels_sums_aug[1, 1] &gt; (nb_iterations * 0.98)
    assert pixels_sums_aug[1, 1] &lt; (nb_iterations * 1.02)

    # outer pixels, should sometimes be white
    # the values here had to be set quite tolerant, the middle pixels at top/left/bottom/right get more activation
    # than expected
    outer_pixels = ([0, 0, 0, 1, 1, 2, 2, 2], [0, 1, 2, 0, 2, 0, 1, 2])
    assert (pixels_sums_aug[outer_pixels] &gt; int(nb_iterations * (2/8 * 0.4))).all()
    assert (pixels_sums_aug[outer_pixels] &lt; int(nb_iterations * (2/8 * 2.0))).all()

    # ---------------------
    # shear
    # ---------------------
    # TODO

    # shear by StochasticParameter
    aug = iaa.AffineCv2(scale=1.0, translate_px=0, rotate=0, shear=iap.Uniform(10, 20))
    assert isinstance(aug.shear, iap.Uniform)
    assert isinstance(aug.shear.a, iap.Deterministic)
    assert aug.shear.a.value == 10
    assert isinstance(aug.shear.b, iap.Deterministic)
    assert aug.shear.b.value == 20

    # ---------------------
    # cval
    # ---------------------
    aug = iaa.AffineCv2(scale=1.0, translate_px=100, rotate=0, shear=0, cval=128)
    aug_det = aug.to_deterministic()

    image = np.ones((3, 3, 1), dtype=np.uint8) * 255
    image_aug = np.copy(image)
    images = np.array([image])
    images_list = [image]

    observed = aug.augment_images(images)
    assert (observed[0] &gt; 128 - 30).all()
    assert (observed[0] &lt; 128 + 30).all()

    observed = aug_det.augment_images(images)
    assert (observed[0] &gt; 128 - 30).all()
    assert (observed[0] &lt; 128 + 30).all()

    observed = aug.augment_images(images_list)
    assert (observed[0] &gt; 128 - 30).all()
    assert (observed[0] &lt; 128 + 30).all()

    observed = aug_det.augment_images(images_list)
    assert (observed[0] &gt; 128 - 30).all()
    assert (observed[0] &lt; 128 + 30).all()

    # random cvals
    aug = iaa.AffineCv2(scale=1.0, translate_px=100, rotate=0, shear=0, cval=(0, 255))
    aug_det = aug.to_deterministic()
    last_aug = None
    last_aug_det = None
    nb_changed_aug = 0
    nb_changed_aug_det = 0
    nb_iterations = 1000
    averages = []
    for i in sm.xrange(nb_iterations):
        observed_aug = aug.augment_images(images)
        observed_aug_det = aug_det.augment_images(images)
        if i == 0:
            last_aug = observed_aug
            last_aug_det = observed_aug_det
        else:
            if not np.array_equal(observed_aug, last_aug):
                nb_changed_aug += 1
            if not np.array_equal(observed_aug_det, last_aug_det):
                nb_changed_aug_det += 1
            last_aug = observed_aug
            last_aug_det = observed_aug_det

        averages.append(int(np.average(observed_aug)))

    assert nb_changed_aug &gt;= int(nb_iterations * 0.9)
    assert nb_changed_aug_det == 0
    # center pixel, should always be white when rotating line around center
    assert pixels_sums_aug[1, 1] &gt; (nb_iterations * 0.98)
    assert pixels_sums_aug[1, 1] &lt; (nb_iterations * 1.02)
    assert len(set(averages)) &gt; 200

    aug = iaa.AffineCv2(scale=1.0, translate_px=100, rotate=0, shear=0, cval=ia.ALL)
    assert isinstance(aug.cval, iap.DiscreteUniform)
    assert isinstance(aug.cval.a, iap.Deterministic)
    assert isinstance(aug.cval.b, iap.Deterministic)
    assert aug.cval.a.value == 0
    assert aug.cval.b.value == 255

    aug = iaa.AffineCv2(scale=1.0, translate_px=100, rotate=0, shear=0, cval=iap.DiscreteUniform(1, 5))
    assert isinstance(aug.cval, iap.DiscreteUniform)
    assert isinstance(aug.cval.a, iap.Deterministic)
    assert isinstance(aug.cval.b, iap.Deterministic)
    assert aug.cval.a.value == 1
    assert aug.cval.b.value == 5

    # ------------
    # mode
    # ------------
    aug = iaa.AffineCv2(scale=1.0, translate_px=100, rotate=0, shear=0, cval=0, mode=ia.ALL)
    assert isinstance(aug.mode, iap.Choice)
    aug = iaa.AffineCv2(scale=1.0, translate_px=100, rotate=0, shear=0, cval=0, mode="replicate")
    assert isinstance(aug.mode, iap.Deterministic)
    assert aug.mode.value == "replicate"
    aug = iaa.AffineCv2(scale=1.0, translate_px=100, rotate=0, shear=0, cval=0, mode=["replicate", "reflect"])
    assert isinstance(aug.mode, iap.Choice)
    assert len(aug.mode.a) == 2 and "replicate" in aug.mode.a and "reflect" in aug.mode.a
    aug = iaa.AffineCv2(scale=1.0, translate_px=100, rotate=0, shear=0, cval=0,
                        mode=iap.Choice(["replicate", "reflect"]))
    assert isinstance(aug.mode, iap.Choice)
    assert len(aug.mode.a) == 2 and "replicate" in aug.mode.a and "reflect" in aug.mode.a

    # ------------
    # exceptions for bad inputs
    # ------------
    # scale
    got_exception = False
    try:
        _ = iaa.AffineCv2(scale=False)
    except Exception:
        got_exception = True
    assert got_exception

    # translate_px
    got_exception = False
    try:
        _ = iaa.AffineCv2(translate_px=False)
    except Exception:
        got_exception = True
    assert got_exception

    # translate_percent
    got_exception = False
    try:
        _ = iaa.AffineCv2(translate_percent=False)
    except Exception:
        got_exception = True
    assert got_exception

    # rotate
    got_exception = False
    try:
        _ = iaa.AffineCv2(scale=1.0, translate_px=0, rotate=False, shear=0, cval=0)
    except Exception:
        got_exception = True
    assert got_exception

    # shear
    got_exception = False
    try:
        _ = iaa.AffineCv2(scale=1.0, translate_px=0, rotate=0, shear=False, cval=0)
    except Exception:
        got_exception = True
    assert got_exception

    # cval
    got_exception = False
    try:
        _ = iaa.AffineCv2(scale=1.0, translate_px=100, rotate=0, shear=0, cval=None)
    except Exception:
        got_exception = True
    assert got_exception

    # mode
    got_exception = False
    try:
        _ = iaa.AffineCv2(scale=1.0, translate_px=100, rotate=0, shear=0, cval=0, mode=False)
    except Exception:
        got_exception = True
    assert got_exception

    # non-existent order
    got_exception = False
    try:
        _ = iaa.AffineCv2(order=-1)
    except Exception:
        got_exception = True
    assert got_exception

    # bad order datatype
    got_exception = False
    try:
        _ = iaa.AffineCv2(order="test")
    except Exception:
        got_exception = True
    assert got_exception

    # ----------
    # get_parameters
    # ----------
    aug = iaa.AffineCv2(scale=1, translate_px=2, rotate=3, shear=4, order=1, cval=0, mode="constant")
    params = aug.get_parameters()
    assert isinstance(params[0], iap.Deterministic)  # scale
    assert isinstance(params[1], iap.Deterministic)  # translate
    assert isinstance(params[2], iap.Deterministic)  # rotate
    assert isinstance(params[3], iap.Deterministic)  # shear
    assert params[0].value == 1  # scale
    assert params[1].value == 2  # translate
    assert params[2].value == 3  # rotate
    assert params[3].value == 4  # shear
    assert params[4].value == 1  # order
    assert params[5].value == 0  # cval
    assert params[6].value == "constant"  # mode


</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 35:</b> &nbsp; 3 fragments, nominal size 46 lines, similarity 93%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag814')" href="javascript:;">
imgaug-0.2.7/test/augmenters/test_contrast.py: 33-95
</a>
<div class="mid" id="frag814" style="display:none"><pre>
def test_GammaContrast():
    reseed()

    img = [
        [1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]
    ]
    img = np.uint8(img)
    img3d = np.tile(img[:, :, np.newaxis], (1, 1, 3))

    # check basic functionality with gamma=1 or 2 (deterministic) and per_chanenl on/off (makes
    # no difference due to deterministic gamma)
    for per_channel in [False, 0, 0.0, True, 1, 1.0]:
        for gamma in [1, 2]:
            aug = iaa.GammaContrast(gamma=iap.Deterministic(gamma), per_channel=per_channel)
            img_aug = aug.augment_image(img)
            img3d_aug = aug.augment_image(img3d)
            assert img_aug.dtype.type == np.uint8
            assert img3d_aug.dtype.type == np.uint8
            assert np.array_equal(img_aug, skimage.exposure.adjust_gamma(img, gamma=gamma))
            assert np.array_equal(img3d_aug, skimage.exposure.adjust_gamma(img3d, gamma=gamma))

    # check that tuple to uniform works
    aug = iaa.GammaContrast((1, 2))
    assert isinstance(aug.params1d[0], iap.Uniform)
    assert isinstance(aug.params1d[0].a, iap.Deterministic)
    assert isinstance(aug.params1d[0].b, iap.Deterministic)
    assert aug.params1d[0].a.value == 1
    assert aug.params1d[0].b.value == 2

    # check that list to choice works
    aug = iaa.GammaContrast([1, 2])
    assert isinstance(aug.params1d[0], iap.Choice)
    assert all([val in aug.params1d[0].a for val in [1, 2]])

    # check that per_channel at 50% prob works
    aug = iaa.GammaContrast((0.5, 2.0), per_channel=0.5)
    seen = [False, False]
    img1000d = np.zeros((1, 1, 1000), dtype=np.uint8) + 128
    for _ in sm.xrange(100):
        img_aug = aug.augment_image(img1000d)
        assert img_aug.dtype.type == np.uint8
        l = len(set(img_aug.flatten().tolist()))
        if l == 1:
            seen[0] = True
        else:
            seen[1] = True
        if all(seen):
            break
    assert all(seen)

    # check that keypoints are not changed
    kpsoi = ia.KeypointsOnImage([ia.Keypoint(1, 1)], shape=(3, 3, 3))
    kpsoi_aug = iaa.GammaContrast(gamma=2).augment_keypoints([kpsoi])
    assert keypoints_equal([kpsoi], kpsoi_aug)

    # check that heatmaps are not changed
    heatmaps = ia.HeatmapsOnImage(np.zeros((3, 3, 1), dtype=np.float32) + 0.5, shape=(3, 3, 3))
    heatmaps_aug = iaa.GammaContrast(gamma=2).augment_heatmaps([heatmaps])[0]
    assert np.allclose(heatmaps.arr_0to1, heatmaps_aug.arr_0to1)


</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag816')" href="javascript:;">
imgaug-0.2.7/test/augmenters/test_contrast.py: 170-232
</a>
<div class="mid" id="frag816" style="display:none"><pre>
def test_LogContrast():
    reseed()

    img = [
        [1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]
    ]
    img = np.uint8(img)
    img3d = np.tile(img[:, :, np.newaxis], (1, 1, 3))

    # check basic functionality with gain=1 or 2 (deterministic) and per_chanenl on/off (makes
    # no difference due to deterministic gain)
    for per_channel in [False, 0, 0.0, True, 1, 1.0]:
        for gain in [1, 2]:
            aug = iaa.LogContrast(gain=iap.Deterministic(gain), per_channel=per_channel)
            img_aug = aug.augment_image(img)
            img3d_aug = aug.augment_image(img3d)
            assert img_aug.dtype.type == np.uint8
            assert img3d_aug.dtype.type == np.uint8
            assert np.array_equal(img_aug, skimage.exposure.adjust_log(img, gain=gain))
            assert np.array_equal(img3d_aug, skimage.exposure.adjust_log(img3d, gain=gain))

    # check that tuple to uniform works
    aug = iaa.LogContrast((1, 2))
    assert isinstance(aug.params1d[0], iap.Uniform)
    assert isinstance(aug.params1d[0].a, iap.Deterministic)
    assert isinstance(aug.params1d[0].b, iap.Deterministic)
    assert aug.params1d[0].a.value == 1
    assert aug.params1d[0].b.value == 2

    # check that list to choice works
    aug = iaa.LogContrast([1, 2])
    assert isinstance(aug.params1d[0], iap.Choice)
    assert all([val in aug.params1d[0].a for val in [1, 2]])

    # check that per_channel at 50% prob works
    aug = iaa.LogContrast((0.5, 2.0), per_channel=0.5)
    seen = [False, False]
    img1000d = np.zeros((1, 1, 1000), dtype=np.uint8) + 128
    for _ in sm.xrange(100):
        img_aug = aug.augment_image(img1000d)
        assert img_aug.dtype.type == np.uint8
        l = len(set(img_aug.flatten().tolist()))
        if l == 1:
            seen[0] = True
        else:
            seen[1] = True
        if all(seen):
            break
    assert all(seen)

    # check that keypoints are not changed
    kpsoi = ia.KeypointsOnImage([ia.Keypoint(1, 1)], shape=(3, 3, 3))
    kpsoi_aug = iaa.LogContrast(gain=2).augment_keypoints([kpsoi])
    assert keypoints_equal([kpsoi], kpsoi_aug)

    # check that heatmaps are not changed
    heatmaps = ia.HeatmapsOnImage(np.zeros((3, 3, 1), dtype=np.float32) + 0.5, shape=(3, 3, 3))
    heatmaps_aug = iaa.LogContrast(gain=2).augment_heatmaps([heatmaps])[0]
    assert np.allclose(heatmaps.arr_0to1, heatmaps_aug.arr_0to1)


</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag817')" href="javascript:;">
imgaug-0.2.7/test/augmenters/test_contrast.py: 233-297
</a>
<div class="mid" id="frag817" style="display:none"><pre>
def test_LinearContrast():
    reseed()

    img = [
        [1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]
    ]
    img = np.uint8(img)
    img3d = np.tile(img[:, :, np.newaxis], (1, 1, 3))

    # check basic functionality with alpha=1 or 2 (deterministic) and per_chanenl on/off (makes
    # no difference due to deterministic alpha)
    for per_channel in [False, 0, 0.0, True, 1, 1.0]:
        for alpha in [1, 2]:
            aug = iaa.LinearContrast(alpha=iap.Deterministic(alpha), per_channel=per_channel)
            img_aug = aug.augment_image(img)
            img3d_aug = aug.augment_image(img3d)
            assert img_aug.dtype.type == np.uint8
            assert img3d_aug.dtype.type == np.uint8
            assert np.array_equal(img_aug, contrast_lib._adjust_linear(img, alpha=alpha))
            assert np.array_equal(img3d_aug, contrast_lib._adjust_linear(img3d, alpha=alpha))

    # check that tuple to uniform works
    aug = iaa.LinearContrast((1, 2))
    assert isinstance(aug.params1d[0], iap.Uniform)
    assert isinstance(aug.params1d[0].a, iap.Deterministic)
    assert isinstance(aug.params1d[0].b, iap.Deterministic)
    assert aug.params1d[0].a.value == 1
    assert aug.params1d[0].b.value == 2

    # check that list to choice works
    aug = iaa.LinearContrast([1, 2])
    assert isinstance(aug.params1d[0], iap.Choice)
    assert all([val in aug.params1d[0].a for val in [1, 2]])

    # check that per_channel at 50% prob works
    aug = iaa.LinearContrast((0.5, 2.0), per_channel=0.5)
    seen = [False, False]
    # must not use just value 128 here, otherwise nothing will change as all values would have
    # distance 0 to 128
    img1000d = np.zeros((1, 1, 1000), dtype=np.uint8) + 128 + 20
    for _ in sm.xrange(100):
        img_aug = aug.augment_image(img1000d)
        assert img_aug.dtype.type == np.uint8
        l = len(set(img_aug.flatten().tolist()))
        if l == 1:
            seen[0] = True
        else:
            seen[1] = True
        if all(seen):
            break
    assert all(seen)

    # check that keypoints are not changed
    kpsoi = ia.KeypointsOnImage([ia.Keypoint(1, 1)], shape=(3, 3, 3))
    kpsoi_aug = iaa.LinearContrast(alpha=2).augment_keypoints([kpsoi])
    assert keypoints_equal([kpsoi], kpsoi_aug)

    # check that heatmaps are not changed
    heatmaps = ia.HeatmapsOnImage(np.zeros((3, 3, 1), dtype=np.float32) + 0.5, shape=(3, 3, 3))
    heatmaps_aug = iaa.LinearContrast(alpha=2).augment_heatmaps([heatmaps])[0]
    assert np.allclose(heatmaps.arr_0to1, heatmaps_aug.arr_0to1)


</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 36:</b> &nbsp; 2 fragments, nominal size 140 lines, similarity 100%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag836')" href="javascript:;">
imgaug-0.2.7/test/augmenters/test_flip.py: 26-207
</a>
<div class="mid" id="frag836" style="display:none"><pre>
def test_Fliplr():
    reseed()

    base_img = np.array([[0, 0, 1],
                         [0, 0, 1],
                         [0, 1, 1]], dtype=np.uint8)
    base_img = base_img[:, :, np.newaxis]

    base_img_flipped = np.array([[1, 0, 0],
                                 [1, 0, 0],
                                 [1, 1, 0]], dtype=np.uint8)
    base_img_flipped = base_img_flipped[:, :, np.newaxis]

    images = np.array([base_img])
    images_flipped = np.array([base_img_flipped])

    keypoints = [ia.KeypointsOnImage([ia.Keypoint(x=0, y=0), ia.Keypoint(x=1, y=1),
                                      ia.Keypoint(x=2, y=2)], shape=base_img.shape)]
    keypoints_flipped = [ia.KeypointsOnImage([ia.Keypoint(x=2, y=0), ia.Keypoint(x=1, y=1),
                                              ia.Keypoint(x=0, y=2)], shape=base_img.shape)]

    # 0% chance of flip
    aug = iaa.Fliplr(0)
    aug_det = aug.to_deterministic()

    for _ in sm.xrange(10):
        observed = aug.augment_images(images)
        expected = images
        assert np.array_equal(observed, expected)

        observed = aug_det.augment_images(images)
        expected = images
        assert np.array_equal(observed, expected)

        observed = aug.augment_keypoints(keypoints)
        expected = keypoints
        assert keypoints_equal(observed, expected)

        observed = aug_det.augment_keypoints(keypoints)
        expected = keypoints
        assert keypoints_equal(observed, expected)

    # 0% chance of flip, heatmaps
    aug = iaa.Fliplr(0)
    heatmaps = ia.HeatmapsOnImage(
        np.float32([
            [0, 0.5, 0.75],
            [0, 0.5, 0.75],
            [0.75, 0.75, 0.75],
        ]),
        shape=(3, 3, 3)
    )
    observed = aug.augment_heatmaps([heatmaps])[0]
    expected = heatmaps.get_arr()
    assert observed.shape == heatmaps.shape
    assert heatmaps.min_value - 1e-6 &lt; observed.min_value &lt; heatmaps.min_value + 1e-6
    assert heatmaps.max_value - 1e-6 &lt; observed.max_value &lt; heatmaps.max_value + 1e-6
    assert np.array_equal(observed.get_arr(), expected)

    # 100% chance of flip
    aug = iaa.Fliplr(1.0)
    aug_det = aug.to_deterministic()

    for _ in sm.xrange(10):
        observed = aug.augment_images(images)
        expected = images_flipped
        assert np.array_equal(observed, expected)

        observed = aug_det.augment_images(images)
        expected = images_flipped
        assert np.array_equal(observed, expected)

        observed = aug.augment_keypoints(keypoints)
        expected = keypoints_flipped
        assert keypoints_equal(observed, expected)

        observed = aug_det.augment_keypoints(keypoints)
        expected = keypoints_flipped
        assert keypoints_equal(observed, expected)

    # 100% chance of flip, heatmaps
    aug = iaa.Fliplr(1.0)
    heatmaps = ia.HeatmapsOnImage(
        np.float32([
            [0, 0.5, 0.75],
            [0, 0.5, 0.75],
            [0.75, 0.75, 0.75],
        ]),
        shape=(3, 3, 3)
    )
    observed = aug.augment_heatmaps([heatmaps])[0]
    expected = np.fliplr(heatmaps.get_arr())
    assert observed.shape == heatmaps.shape
    assert heatmaps.min_value - 1e-6 &lt; observed.min_value &lt; heatmaps.min_value + 1e-6
    assert heatmaps.max_value - 1e-6 &lt; observed.max_value &lt; heatmaps.max_value + 1e-6
    assert np.array_equal(observed.get_arr(), expected)

    # 50% chance of flip
    aug = iaa.Fliplr(0.5)
    aug_det = aug.to_deterministic()

    nb_iterations = 1000
    nb_images_flipped = 0
    nb_images_flipped_det = 0
    nb_keypoints_flipped = 0
    nb_keypoints_flipped_det = 0
    for _ in sm.xrange(nb_iterations):
        observed = aug.augment_images(images)
        if np.array_equal(observed, images_flipped):
            nb_images_flipped += 1

        observed = aug_det.augment_images(images)
        if np.array_equal(observed, images_flipped):
            nb_images_flipped_det += 1

        observed = aug.augment_keypoints(keypoints)
        if keypoints_equal(observed, keypoints_flipped):
            nb_keypoints_flipped += 1

        observed = aug_det.augment_keypoints(keypoints)
        if keypoints_equal(observed, keypoints_flipped):
            nb_keypoints_flipped_det += 1

    assert int(nb_iterations * 0.3) &lt;= nb_images_flipped &lt;= int(nb_iterations * 0.7)
    assert int(nb_iterations * 0.3) &lt;= nb_keypoints_flipped &lt;= int(nb_iterations * 0.7)
    assert nb_images_flipped_det in [0, nb_iterations]
    assert nb_keypoints_flipped_det in [0, nb_iterations]

    # 50% chance of flipped, multiple images, list as input
    images_multi = [base_img, base_img]
    aug = iaa.Fliplr(0.5)
    aug_det = aug.to_deterministic()
    nb_iterations = 1000
    nb_flipped_by_pos = [0] * len(images_multi)
    nb_flipped_by_pos_det = [0] * len(images_multi)
    for _ in sm.xrange(nb_iterations):
        observed = aug.augment_images(images_multi)
        for i in sm.xrange(len(images_multi)):
            if np.array_equal(observed[i], base_img_flipped):
                nb_flipped_by_pos[i] += 1

        observed = aug_det.augment_images(images_multi)
        for i in sm.xrange(len(images_multi)):
            if np.array_equal(observed[i], base_img_flipped):
                nb_flipped_by_pos_det[i] += 1

    for val in nb_flipped_by_pos:
        assert int(nb_iterations * 0.3) &lt;= val &lt;= int(nb_iterations * 0.7)

    for val in nb_flipped_by_pos_det:
        assert val in [0, nb_iterations]

    # test StochasticParameter as p
    aug = iaa.Fliplr(p=iap.Choice([0, 1], p=[0.7, 0.3]))
    seen = [0, 0]
    for _ in sm.xrange(1000):
        observed = aug.augment_image(base_img)
        if np.array_equal(observed, base_img):
            seen[0] += 1
        elif np.array_equal(observed, base_img_flipped):
            seen[1] += 1
        else:
            assert False
    assert 700 - 75 &lt; seen[0] &lt; 700 + 75
    assert 300 - 75 &lt; seen[1] &lt; 300 + 75

    # test exceptions for wrong parameter types
    got_exception = False
    try:
        _ = iaa.Fliplr(p="test")
    except Exception:
        got_exception = True
    assert got_exception

    # test get_parameters()
    aug = iaa.Fliplr(p=0.5)
    params = aug.get_parameters()
    assert isinstance(params[0], iap.Binomial)
    assert isinstance(params[0].p, iap.Deterministic)
    assert 0.5 - 1e-4 &lt; params[0].p.value &lt; 0.5 + 1e-4


</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag837')" href="javascript:;">
imgaug-0.2.7/test/augmenters/test_flip.py: 208-389
</a>
<div class="mid" id="frag837" style="display:none"><pre>
def test_Flipud():
    reseed()

    base_img = np.array([[0, 0, 1],
                         [0, 0, 1],
                         [0, 1, 1]], dtype=np.uint8)
    base_img = base_img[:, :, np.newaxis]

    base_img_flipped = np.array([[0, 1, 1],
                                 [0, 0, 1],
                                 [0, 0, 1]], dtype=np.uint8)
    base_img_flipped = base_img_flipped[:, :, np.newaxis]

    images = np.array([base_img])
    images_flipped = np.array([base_img_flipped])

    keypoints = [ia.KeypointsOnImage([ia.Keypoint(x=0, y=0), ia.Keypoint(x=1, y=1),
                                      ia.Keypoint(x=2, y=2)], shape=base_img.shape)]
    keypoints_flipped = [ia.KeypointsOnImage([ia.Keypoint(x=0, y=2), ia.Keypoint(x=1, y=1),
                                              ia.Keypoint(x=2, y=0)], shape=base_img.shape)]

    # 0% chance of flip
    aug = iaa.Flipud(0)
    aug_det = aug.to_deterministic()

    for _ in sm.xrange(10):
        observed = aug.augment_images(images)
        expected = images
        assert np.array_equal(observed, expected)

        observed = aug_det.augment_images(images)
        expected = images
        assert np.array_equal(observed, expected)

        observed = aug.augment_keypoints(keypoints)
        expected = keypoints
        assert keypoints_equal(observed, expected)

        observed = aug_det.augment_keypoints(keypoints)
        expected = keypoints
        assert keypoints_equal(observed, expected)

    # 0% chance of flip, heatmaps
    aug = iaa.Flipud(0)
    heatmaps = ia.HeatmapsOnImage(
        np.float32([
            [0, 0.5, 0.75],
            [0, 0.5, 0.75],
            [0.75, 0.75, 0.75],
        ]),
        shape=(3, 3, 3)
    )
    observed = aug.augment_heatmaps([heatmaps])[0]
    expected = heatmaps.get_arr()
    assert observed.shape == heatmaps.shape
    assert heatmaps.min_value - 1e-6 &lt; observed.min_value &lt; heatmaps.min_value + 1e-6
    assert heatmaps.max_value - 1e-6 &lt; observed.max_value &lt; heatmaps.max_value + 1e-6
    assert np.array_equal(observed.get_arr(), expected)

    # 100% chance of flip
    aug = iaa.Flipud(1.0)
    aug_det = aug.to_deterministic()

    for _ in sm.xrange(10):
        observed = aug.augment_images(images)
        expected = images_flipped
        assert np.array_equal(observed, expected)

        observed = aug_det.augment_images(images)
        expected = images_flipped
        assert np.array_equal(observed, expected)

        observed = aug.augment_keypoints(keypoints)
        expected = keypoints_flipped
        assert keypoints_equal(observed, expected)

        observed = aug_det.augment_keypoints(keypoints)
        expected = keypoints_flipped
        assert keypoints_equal(observed, expected)

    # 100% chance of flip, heatmaps
    aug = iaa.Flipud(1.0)
    heatmaps = ia.HeatmapsOnImage(
        np.float32([
            [0, 0.5, 0.75],
            [0, 0.5, 0.75],
            [0.75, 0.75, 0.75],
        ]),
        shape=(3, 3, 3)
    )
    observed = aug.augment_heatmaps([heatmaps])[0]
    expected = np.flipud(heatmaps.get_arr())
    assert observed.shape == heatmaps.shape
    assert heatmaps.min_value - 1e-6 &lt; observed.min_value &lt; heatmaps.min_value + 1e-6
    assert heatmaps.max_value - 1e-6 &lt; observed.max_value &lt; heatmaps.max_value + 1e-6
    assert np.array_equal(observed.get_arr(), expected)

    # 50% chance of flip
    aug = iaa.Flipud(0.5)
    aug_det = aug.to_deterministic()

    nb_iterations = 1000
    nb_images_flipped = 0
    nb_images_flipped_det = 0
    nb_keypoints_flipped = 0
    nb_keypoints_flipped_det = 0
    for _ in sm.xrange(nb_iterations):
        observed = aug.augment_images(images)
        if np.array_equal(observed, images_flipped):
            nb_images_flipped += 1

        observed = aug_det.augment_images(images)
        if np.array_equal(observed, images_flipped):
            nb_images_flipped_det += 1

        observed = aug.augment_keypoints(keypoints)
        if keypoints_equal(observed, keypoints_flipped):
            nb_keypoints_flipped += 1

        observed = aug_det.augment_keypoints(keypoints)
        if keypoints_equal(observed, keypoints_flipped):
            nb_keypoints_flipped_det += 1

    assert int(nb_iterations * 0.3) &lt;= nb_images_flipped &lt;= int(nb_iterations * 0.7)
    assert int(nb_iterations * 0.3) &lt;= nb_keypoints_flipped &lt;= int(nb_iterations * 0.7)
    assert nb_images_flipped_det in [0, nb_iterations]
    assert nb_keypoints_flipped_det in [0, nb_iterations]

    # 50% chance of flipped, multiple images, list as input
    images_multi = [base_img, base_img]
    aug = iaa.Flipud(0.5)
    aug_det = aug.to_deterministic()
    nb_iterations = 1000
    nb_flipped_by_pos = [0] * len(images_multi)
    nb_flipped_by_pos_det = [0] * len(images_multi)
    for _ in sm.xrange(nb_iterations):
        observed = aug.augment_images(images_multi)
        for i in sm.xrange(len(images_multi)):
            if np.array_equal(observed[i], base_img_flipped):
                nb_flipped_by_pos[i] += 1

        observed = aug_det.augment_images(images_multi)
        for i in sm.xrange(len(images_multi)):
            if np.array_equal(observed[i], base_img_flipped):
                nb_flipped_by_pos_det[i] += 1

    for val in nb_flipped_by_pos:
        assert int(nb_iterations * 0.3) &lt;= val &lt;= int(nb_iterations * 0.7)

    for val in nb_flipped_by_pos_det:
        assert val in [0, nb_iterations]

    # test StochasticParameter as p
    aug = iaa.Flipud(p=iap.Choice([0, 1], p=[0.7, 0.3]))
    seen = [0, 0]
    for _ in sm.xrange(1000):
        observed = aug.augment_image(base_img)
        if np.array_equal(observed, base_img):
            seen[0] += 1
        elif np.array_equal(observed, base_img_flipped):
            seen[1] += 1
        else:
            assert False
    assert 700 - 75 &lt; seen[0] &lt; 700 + 75
    assert 300 - 75 &lt; seen[1] &lt; 300 + 75

    # test exceptions for wrong parameter types
    got_exception = False
    try:
        _ = iaa.Flipud(p="test")
    except Exception:
        got_exception = True
    assert got_exception

    # test get_parameters()
    aug = iaa.Flipud(p=0.5)
    params = aug.get_parameters()
    assert isinstance(params[0], iap.Binomial)
    assert isinstance(params[0].p, iap.Deterministic)
    assert 0.5 - 1e-4 &lt; params[0].p.value &lt; 0.5 + 1e-4


</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 37:</b> &nbsp; 4 fragments, nominal size 130 lines, similarity 80%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag845')" href="javascript:;">
imgaug-0.2.7/test/augmenters/test_arithmetic.py: 412-568
</a>
<div class="mid" id="frag845" style="display:none"><pre>
    hm_aug = aug.augment_heatmaps([hm])[0]
    assert np.allclose(hm.arr_0to1, hm_aug.arr_0to1)


def test_Multiply():
    reseed()

    base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
    images = np.array([base_img])
    images_list = [base_img]
    keypoints = [ia.KeypointsOnImage([ia.Keypoint(x=0, y=0), ia.Keypoint(x=1, y=1),
                                      ia.Keypoint(x=2, y=2)], shape=base_img.shape)]

    # no multiply, shouldnt change anything
    aug = iaa.Multiply(mul=1.0)
    aug_det = aug.to_deterministic()

    observed = aug.augment_images(images)
    expected = images
    assert np.array_equal(observed, expected)

    observed = aug.augment_images(images_list)
    expected = images_list
    assert array_equal_lists(observed, expected)

    observed = aug_det.augment_images(images)
    expected = images
    assert np.array_equal(observed, expected)

    observed = aug_det.augment_images(images_list)
    expected = images_list
    assert array_equal_lists(observed, expected)

    # multiply &gt;1.0
    aug = iaa.Multiply(mul=1.2)
    aug_det = aug.to_deterministic()

    observed = aug.augment_images(images)
    expected = np.ones((1, 3, 3, 1), dtype=np.uint8) * 120
    assert np.array_equal(observed, expected)

    observed = aug.augment_images(images_list)
    expected = [np.ones((3, 3, 1), dtype=np.uint8) * 120]
    assert array_equal_lists(observed, expected)

    observed = aug_det.augment_images(images)
    expected = np.ones((1, 3, 3, 1), dtype=np.uint8) * 120
    assert np.array_equal(observed, expected)

    observed = aug_det.augment_images(images_list)
    expected = [np.ones((3, 3, 1), dtype=np.uint8) * 120]
    assert array_equal_lists(observed, expected)

    # multiply &lt;1.0
    aug = iaa.Multiply(mul=0.8)
    aug_det = aug.to_deterministic()

    observed = aug.augment_images(images)
    expected = np.ones((1, 3, 3, 1), dtype=np.uint8) * 80
    assert np.array_equal(observed, expected)

    observed = aug.augment_images(images_list)
    expected = [np.ones((3, 3, 1), dtype=np.uint8) * 80]
    assert array_equal_lists(observed, expected)

    observed = aug_det.augment_images(images)
    expected = np.ones((1, 3, 3, 1), dtype=np.uint8) * 80
    assert np.array_equal(observed, expected)

    observed = aug_det.augment_images(images_list)
    expected = [np.ones((3, 3, 1), dtype=np.uint8) * 80]
    assert array_equal_lists(observed, expected)

    # keypoints shouldnt be changed
    aug = iaa.Multiply(mul=1.2)
    aug_det = iaa.Multiply(mul=1.2).to_deterministic()
    observed = aug.augment_keypoints(keypoints)
    expected = keypoints
    assert keypoints_equal(observed, expected)

    observed = aug_det.augment_keypoints(keypoints)
    expected = keypoints
    assert keypoints_equal(observed, expected)

    # varying multiply factors
    aug = iaa.Multiply(mul=(0, 2.0))
    aug_det = aug.to_deterministic()

    last_aug = None
    last_aug_det = None
    nb_changed_aug = 0
    nb_changed_aug_det = 0
    nb_iterations = 1000
    for i in sm.xrange(nb_iterations):
        observed_aug = aug.augment_images(images)
        observed_aug_det = aug_det.augment_images(images)
        if i == 0:
            last_aug = observed_aug
            last_aug_det = observed_aug_det
        else:
            if not np.array_equal(observed_aug, last_aug):
                nb_changed_aug += 1
            if not np.array_equal(observed_aug_det, last_aug_det):
                nb_changed_aug_det += 1
            last_aug = observed_aug
            last_aug_det = observed_aug_det
    assert nb_changed_aug &gt;= int(nb_iterations * 0.95)
    assert nb_changed_aug_det == 0

    # test channelwise
    aug = iaa.Multiply(mul=iap.Choice([0, 2]), per_channel=True)
    observed = aug.augment_image(np.ones((1, 1, 100), dtype=np.uint8))
    uq = np.unique(observed)
    assert 0 in uq
    assert 2 in uq
    assert len(uq) == 2

    # test channelwise with probability
    aug = iaa.Multiply(mul=iap.Choice([0, 2]), per_channel=0.5)
    seen = [0, 0]
    for _ in sm.xrange(400):
        observed = aug.augment_image(np.ones((1, 1, 20), dtype=np.uint8))
        uq = np.unique(observed)
        per_channel = (len(uq) == 2)
        if per_channel:
            seen[0] += 1
        else:
            seen[1] += 1
    assert 150 &lt; seen[0] &lt; 250
    assert 150 &lt; seen[1] &lt; 250

    # test exceptions for wrong parameter types
    got_exception = False
    try:
        _ = iaa.Multiply(mul="test")
    except Exception:
        got_exception = True
    assert got_exception

    got_exception = False
    try:
        _ = iaa.Multiply(mul=1, per_channel="test")
    except Exception:
        got_exception = True
    assert got_exception

    # test get_parameters()
    aug = iaa.Multiply(mul=1, per_channel=False)
    params = aug.get_parameters()
    assert isinstance(params[0], iap.Deterministic)
    assert isinstance(params[1], iap.Deterministic)
    assert params[0].value == 1
    assert params[1].value == 0

    # test heatmaps (not affected by augmenter)
    aug = iaa.Multiply(mul=2)
    hm = ia.quokka_heatmap()
</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag854')" href="javascript:;">
imgaug-0.2.7/test/augmenters/test_arithmetic.py: 1222-1395
</a>
<div class="mid" id="frag854" style="display:none"><pre>
    hm_aug = aug.augment_heatmaps([hm])[0]
    assert np.allclose(hm.arr_0to1, hm_aug.arr_0to1)


def test_Add():
    reseed()

    base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
    images = np.array([base_img])
    images_list = [base_img]
    keypoints = [ia.KeypointsOnImage([ia.Keypoint(x=0, y=0), ia.Keypoint(x=1, y=1),
                                      ia.Keypoint(x=2, y=2)], shape=base_img.shape)]

    # no add, shouldnt change anything
    aug = iaa.Add(value=0)
    aug_det = aug.to_deterministic()

    observed = aug.augment_images(images)
    expected = images
    assert np.array_equal(observed, expected)

    observed = aug.augment_images(images_list)
    expected = images_list
    assert array_equal_lists(observed, expected)

    observed = aug_det.augment_images(images)
    expected = images
    assert np.array_equal(observed, expected)

    observed = aug_det.augment_images(images_list)
    expected = images_list
    assert array_equal_lists(observed, expected)

    # add &gt; 0
    aug = iaa.Add(value=1)
    aug_det = aug.to_deterministic()

    observed = aug.augment_images(images)
    expected = images + 1
    assert np.array_equal(observed, expected)

    observed = aug.augment_images(images_list)
    expected = [images_list[0] + 1]
    assert array_equal_lists(observed, expected)

    observed = aug_det.augment_images(images)
    expected = images + 1
    assert np.array_equal(observed, expected)

    observed = aug_det.augment_images(images_list)
    expected = [images_list[0] + 1]
    assert array_equal_lists(observed, expected)

    # add &lt; 0
    aug = iaa.Add(value=-1)
    aug_det = aug.to_deterministic()

    observed = aug.augment_images(images)
    expected = images - 1
    assert np.array_equal(observed, expected)

    observed = aug.augment_images(images_list)
    expected = [images_list[0] - 1]
    assert array_equal_lists(observed, expected)

    observed = aug_det.augment_images(images)
    expected = images - 1
    assert np.array_equal(observed, expected)

    observed = aug_det.augment_images(images_list)
    expected = [images_list[0] - 1]
    assert array_equal_lists(observed, expected)

    # test other parameters
    aug = iaa.Add(value=iap.DiscreteUniform(1, 10))
    observed = aug.augment_images(images)
    assert 100 + 1 &lt;= np.average(observed) &lt;= 100 + 10

    aug = iaa.Add(value=iap.Uniform(1, 10))
    observed = aug.augment_images(images)
    assert 100 + 1 &lt;= np.average(observed) &lt;= 100 + 10

    aug = iaa.Add(value=iap.Clip(iap.Normal(1, 1), -3, 3))
    observed = aug.augment_images(images)
    assert 100 - 3 &lt;= np.average(observed) &lt;= 100 + 3

    aug = iaa.Add(value=iap.Discretize(iap.Clip(iap.Normal(1, 1), -3, 3)))
    observed = aug.augment_images(images)
    assert 100 - 3 &lt;= np.average(observed) &lt;= 100 + 3

    # keypoints shouldnt be changed
    aug = iaa.Add(value=1)
    aug_det = iaa.Add(value=1).to_deterministic()
    observed = aug.augment_keypoints(keypoints)
    expected = keypoints
    assert keypoints_equal(observed, expected)

    observed = aug_det.augment_keypoints(keypoints)
    expected = keypoints
    assert keypoints_equal(observed, expected)

    # varying values
    aug = iaa.Add(value=(0, 10))
    aug_det = aug.to_deterministic()

    last_aug = None
    last_aug_det = None
    nb_changed_aug = 0
    nb_changed_aug_det = 0
    nb_iterations = 1000
    for i in sm.xrange(nb_iterations):
        observed_aug = aug.augment_images(images)
        observed_aug_det = aug_det.augment_images(images)
        if i == 0:
            last_aug = observed_aug
            last_aug_det = observed_aug_det
        else:
            if not np.array_equal(observed_aug, last_aug):
                nb_changed_aug += 1
            if not np.array_equal(observed_aug_det, last_aug_det):
                nb_changed_aug_det += 1
            last_aug = observed_aug
            last_aug_det = observed_aug_det
    assert nb_changed_aug &gt;= int(nb_iterations * 0.7)
    assert nb_changed_aug_det == 0

    # test channelwise
    aug = iaa.Add(value=iap.Choice([0, 1]), per_channel=True)
    observed = aug.augment_image(np.zeros((1, 1, 100), dtype=np.uint8))
    uq = np.unique(observed)
    assert 0 in uq
    assert 1 in uq
    assert len(uq) == 2

    # test channelwise with probability
    aug = iaa.Add(value=iap.Choice([0, 1]), per_channel=0.5)
    seen = [0, 0]
    for _ in sm.xrange(400):
        observed = aug.augment_image(np.zeros((1, 1, 20), dtype=np.uint8))
        uq = np.unique(observed)
        per_channel = (len(uq) == 2)
        if per_channel:
            seen[0] += 1
        else:
            seen[1] += 1
    assert 150 &lt; seen[0] &lt; 250
    assert 150 &lt; seen[1] &lt; 250

    # test exceptions for wrong parameter types
    got_exception = False
    try:
        _ = iaa.Add(value="test")
    except Exception:
        got_exception = True
    assert got_exception

    got_exception = False
    try:
        _ = iaa.Add(value=1, per_channel="test")
    except Exception:
        got_exception = True
    assert got_exception

    # test get_parameters()
    aug = iaa.Add(value=1, per_channel=False)
    params = aug.get_parameters()
    assert isinstance(params[0], iap.Deterministic)
    assert isinstance(params[1], iap.Deterministic)
    assert params[0].value == 1
    assert params[1].value == 0

    # test heatmaps (not affected by augmenter)
    aug = iaa.Add(value=10)
    hm = ia.quokka_heatmap()
</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag846')" href="javascript:;">
imgaug-0.2.7/test/augmenters/test_arithmetic.py: 569-745
</a>
<div class="mid" id="frag846" style="display:none"><pre>
    hm_aug = aug.augment_heatmaps([hm])[0]
    assert np.allclose(hm.arr_0to1, hm_aug.arr_0to1)


def test_MultiplyElementwise():
    reseed()

    base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
    images = np.array([base_img])
    images_list = [base_img]
    keypoints = [ia.KeypointsOnImage([ia.Keypoint(x=0, y=0), ia.Keypoint(x=1, y=1),
                                      ia.Keypoint(x=2, y=2)], shape=base_img.shape)]

    # no multiply, shouldnt change anything
    aug = iaa.MultiplyElementwise(mul=1.0)
    aug_det = aug.to_deterministic()

    observed = aug.augment_images(images)
    expected = images
    assert np.array_equal(observed, expected)

    observed = aug.augment_images(images_list)
    expected = images_list
    assert array_equal_lists(observed, expected)

    observed = aug_det.augment_images(images)
    expected = images
    assert np.array_equal(observed, expected)

    observed = aug_det.augment_images(images_list)
    expected = images_list
    assert array_equal_lists(observed, expected)

    # multiply &gt;1.0
    aug = iaa.MultiplyElementwise(mul=1.2)
    aug_det = aug.to_deterministic()

    observed = aug.augment_images(images)
    expected = np.ones((1, 3, 3, 1), dtype=np.uint8) * 120
    assert np.array_equal(observed, expected)

    observed = aug.augment_images(images_list)
    expected = [np.ones((3, 3, 1), dtype=np.uint8) * 120]
    assert array_equal_lists(observed, expected)

    observed = aug_det.augment_images(images)
    expected = np.ones((1, 3, 3, 1), dtype=np.uint8) * 120
    assert np.array_equal(observed, expected)

    observed = aug_det.augment_images(images_list)
    expected = [np.ones((3, 3, 1), dtype=np.uint8) * 120]
    assert array_equal_lists(observed, expected)

    # multiply &lt;1.0
    aug = iaa.MultiplyElementwise(mul=0.8)
    aug_det = aug.to_deterministic()

    observed = aug.augment_images(images)
    expected = np.ones((1, 3, 3, 1), dtype=np.uint8) * 80
    assert np.array_equal(observed, expected)

    observed = aug.augment_images(images_list)
    expected = [np.ones((3, 3, 1), dtype=np.uint8) * 80]
    assert array_equal_lists(observed, expected)

    observed = aug_det.augment_images(images)
    expected = np.ones((1, 3, 3, 1), dtype=np.uint8) * 80
    assert np.array_equal(observed, expected)

    observed = aug_det.augment_images(images_list)
    expected = [np.ones((3, 3, 1), dtype=np.uint8) * 80]
    assert array_equal_lists(observed, expected)

    # keypoints shouldnt be changed
    aug = iaa.MultiplyElementwise(mul=1.2)
    aug_det = iaa.Multiply(mul=1.2).to_deterministic()
    observed = aug.augment_keypoints(keypoints)
    expected = keypoints
    assert keypoints_equal(observed, expected)

    observed = aug_det.augment_keypoints(keypoints)
    expected = keypoints
    assert keypoints_equal(observed, expected)

    # varying multiply factors
    aug = iaa.MultiplyElementwise(mul=(0, 2.0))
    aug_det = aug.to_deterministic()

    last_aug = None
    last_aug_det = None
    nb_changed_aug = 0
    nb_changed_aug_det = 0
    nb_iterations = 1000
    for i in sm.xrange(nb_iterations):
        observed_aug = aug.augment_images(images)
        observed_aug_det = aug_det.augment_images(images)
        if i == 0:
            last_aug = observed_aug
            last_aug_det = observed_aug_det
        else:
            if not np.array_equal(observed_aug, last_aug):
                nb_changed_aug += 1
            if not np.array_equal(observed_aug_det, last_aug_det):
                nb_changed_aug_det += 1
            last_aug = observed_aug
            last_aug_det = observed_aug_det
    assert nb_changed_aug &gt;= int(nb_iterations * 0.95)
    assert nb_changed_aug_det == 0

    # values should change between pixels
    aug = iaa.MultiplyElementwise(mul=(0.5, 1.5))

    nb_same = 0
    nb_different = 0
    nb_iterations = 1000
    for i in sm.xrange(nb_iterations):
        observed_aug = aug.augment_images(images)
        observed_aug_flat = observed_aug.flatten()
        last = None
        for j in sm.xrange(observed_aug_flat.size):
            if last is not None:
                v = observed_aug_flat[j]
                if v - 0.0001 &lt;= last &lt;= v + 0.0001:
                    nb_same += 1
                else:
                    nb_different += 1
            last = observed_aug_flat[j]
    assert nb_different &gt; 0.95 * (nb_different + nb_same)

    # test channelwise
    aug = iaa.MultiplyElementwise(mul=iap.Choice([0, 1]), per_channel=True)
    observed = aug.augment_image(np.ones((100, 100, 3), dtype=np.uint8))
    sums = np.sum(observed, axis=2)
    values = np.unique(sums)
    assert all([(value in values) for value in [0, 1, 2, 3]])

    # test channelwise with probability
    aug = iaa.MultiplyElementwise(mul=iap.Choice([0, 1]), per_channel=0.5)
    seen = [0, 0]
    for _ in sm.xrange(400):
        observed = aug.augment_image(np.ones((20, 20, 3), dtype=np.uint8))
        sums = np.sum(observed, axis=2)
        values = np.unique(sums)
        all_values_found = all([(value in values) for value in [0, 1, 2, 3]])
        if all_values_found:
            seen[0] += 1
        else:
            seen[1] += 1
    assert 150 &lt; seen[0] &lt; 250
    assert 150 &lt; seen[1] &lt; 250

    # test exceptions for wrong parameter types
    got_exception = False
    try:
        aug = iaa.MultiplyElementwise(mul="test")
    except Exception:
        got_exception = True
    assert got_exception

    got_exception = False
    try:
        aug = iaa.MultiplyElementwise(mul=1, per_channel="test")
    except Exception:
        got_exception = True
    assert got_exception

    # test get_parameters()
    aug = iaa.MultiplyElementwise(mul=1, per_channel=False)
    params = aug.get_parameters()
    assert isinstance(params[0], iap.Deterministic)
    assert isinstance(params[1], iap.Deterministic)
    assert params[0].value == 1
    assert params[1].value == 0

    # test heatmaps (not affected by augmenter)
    aug = iaa.MultiplyElementwise(mul=2)
    hm = ia.quokka_heatmap()
</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag855')" href="javascript:;">
imgaug-0.2.7/test/augmenters/test_arithmetic.py: 1396-1593
</a>
<div class="mid" id="frag855" style="display:none"><pre>
    hm_aug = aug.augment_heatmaps([hm])[0]
    assert np.allclose(hm.arr_0to1, hm_aug.arr_0to1)


def test_AddElementwise():
    reseed()

    base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
    images = np.array([base_img])
    images_list = [base_img]
    keypoints = [ia.KeypointsOnImage([ia.Keypoint(x=0, y=0), ia.Keypoint(x=1, y=1),
                                      ia.Keypoint(x=2, y=2)], shape=base_img.shape)]

    # no add, shouldnt change anything
    aug = iaa.AddElementwise(value=0)
    aug_det = aug.to_deterministic()

    observed = aug.augment_images(images)
    expected = images
    assert np.array_equal(observed, expected)

    observed = aug.augment_images(images_list)
    expected = images_list
    assert array_equal_lists(observed, expected)

    observed = aug_det.augment_images(images)
    expected = images
    assert np.array_equal(observed, expected)

    observed = aug_det.augment_images(images_list)
    expected = images_list
    assert array_equal_lists(observed, expected)

    # add &gt; 0
    aug = iaa.AddElementwise(value=1)
    aug_det = aug.to_deterministic()

    observed = aug.augment_images(images)
    expected = images + 1
    assert np.array_equal(observed, expected)

    observed = aug.augment_images(images_list)
    expected = [images_list[0] + 1]
    assert array_equal_lists(observed, expected)

    observed = aug_det.augment_images(images)
    expected = images + 1
    assert np.array_equal(observed, expected)

    observed = aug_det.augment_images(images_list)
    expected = [images_list[0] + 1]
    assert array_equal_lists(observed, expected)

    # add &lt; 0
    aug = iaa.AddElementwise(value=-1)
    aug_det = aug.to_deterministic()

    observed = aug.augment_images(images)
    expected = images - 1
    assert np.array_equal(observed, expected)

    observed = aug.augment_images(images_list)
    expected = [images_list[0] - 1]
    assert array_equal_lists(observed, expected)

    observed = aug_det.augment_images(images)
    expected = images - 1
    assert np.array_equal(observed, expected)

    observed = aug_det.augment_images(images_list)
    expected = [images_list[0] - 1]
    assert array_equal_lists(observed, expected)

    # test other parameters
    aug = iaa.AddElementwise(value=iap.DiscreteUniform(1, 10))
    observed = aug.augment_images(images)
    assert np.min(observed) &gt;= 100 + 1
    assert np.max(observed) &lt;= 100 + 10

    aug = iaa.AddElementwise(value=iap.Uniform(1, 10))
    observed = aug.augment_images(images)
    assert np.min(observed) &gt;= 100 + 1
    assert np.max(observed) &lt;= 100 + 10

    aug = iaa.AddElementwise(value=iap.Clip(iap.Normal(1, 1), -3, 3))
    observed = aug.augment_images(images)
    assert np.min(observed) &gt;= 100 - 3
    assert np.max(observed) &lt;= 100 + 3

    aug = iaa.AddElementwise(value=iap.Discretize(iap.Clip(iap.Normal(1, 1), -3, 3)))
    observed = aug.augment_images(images)
    assert np.min(observed) &gt;= 100 - 3
    assert np.max(observed) &lt;= 100 + 3

    # keypoints shouldnt be changed
    aug = iaa.AddElementwise(value=1)
    aug_det = iaa.AddElementwise(value=1).to_deterministic()
    observed = aug.augment_keypoints(keypoints)
    expected = keypoints
    assert keypoints_equal(observed, expected)

    observed = aug_det.augment_keypoints(keypoints)
    expected = keypoints
    assert keypoints_equal(observed, expected)

    # varying values
    aug = iaa.AddElementwise(value=(0, 10))
    aug_det = aug.to_deterministic()

    last_aug = None
    last_aug_det = None
    nb_changed_aug = 0
    nb_changed_aug_det = 0
    nb_iterations = 1000
    for i in sm.xrange(nb_iterations):
        observed_aug = aug.augment_images(images)
        observed_aug_det = aug_det.augment_images(images)
        if i == 0:
            last_aug = observed_aug
            last_aug_det = observed_aug_det
        else:
            if not np.array_equal(observed_aug, last_aug):
                nb_changed_aug += 1
            if not np.array_equal(observed_aug_det, last_aug_det):
                nb_changed_aug_det += 1
            last_aug = observed_aug
            last_aug_det = observed_aug_det
    assert nb_changed_aug &gt;= int(nb_iterations * 0.7)
    assert nb_changed_aug_det == 0

    # values should change between pixels
    aug = iaa.AddElementwise(value=(-50, 50))

    nb_same = 0
    nb_different = 0
    nb_iterations = 1000
    for i in sm.xrange(nb_iterations):
        observed_aug = aug.augment_images(images)
        observed_aug_flat = observed_aug.flatten()
        last = None
        for j in sm.xrange(observed_aug_flat.size):
            if last is not None:
                v = observed_aug_flat[j]
                if v - 0.0001 &lt;= last &lt;= v + 0.0001:
                    nb_same += 1
                else:
                    nb_different += 1
            last = observed_aug_flat[j]
    assert nb_different &gt; 0.9 * (nb_different + nb_same)

    # test channelwise
    aug = iaa.AddElementwise(value=iap.Choice([0, 1]), per_channel=True)
    observed = aug.augment_image(np.zeros((100, 100, 3), dtype=np.uint8))
    sums = np.sum(observed, axis=2)
    values = np.unique(sums)
    assert all([(value in values) for value in [0, 1, 2, 3]])

    # test channelwise with probability
    aug = iaa.AddElementwise(value=iap.Choice([0, 1]), per_channel=0.5)
    seen = [0, 0]
    for _ in sm.xrange(400):
        observed = aug.augment_image(np.zeros((20, 20, 3), dtype=np.uint8))
        sums = np.sum(observed, axis=2)
        values = np.unique(sums)
        all_values_found = all([(value in values) for value in [0, 1, 2, 3]])
        if all_values_found:
            seen[0] += 1
        else:
            seen[1] += 1
    assert 150 &lt; seen[0] &lt; 250
    assert 150 &lt; seen[1] &lt; 250

    # test exceptions for wrong parameter types
    got_exception = False
    try:
        aug = iaa.AddElementwise(value="test")
    except Exception:
        got_exception = True
    assert got_exception

    got_exception = False
    try:
        aug = iaa.AddElementwise(value=1, per_channel="test")
    except Exception:
        got_exception = True
    assert got_exception

    # test get_parameters()
    aug = iaa.AddElementwise(value=1, per_channel=False)
    params = aug.get_parameters()
    assert isinstance(params[0], iap.Deterministic)
    assert isinstance(params[1], iap.Deterministic)
    assert params[0].value == 1
    assert params[1].value == 0

    # test heatmaps (not affected by augmenter)
    aug = iaa.AddElementwise(value=10)
    hm = ia.quokka_heatmap()
</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 38:</b> &nbsp; 3 fragments, nominal size 14 lines, similarity 85%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag848')" href="javascript:;">
imgaug-0.2.7/test/augmenters/test_arithmetic.py: 922-938
</a>
<div class="mid" id="frag848" style="display:none"><pre>
    hm_aug = aug.augment_heatmaps([hm])[0]
    assert np.allclose(hm.arr_0to1, hm_aug.arr_0to1)


def test_SaltAndPepper():
    reseed()

    base_img = np.zeros((100, 100, 1), dtype=np.uint8) + 128
    aug = iaa.SaltAndPepper(p=0.5)
    observed = aug.augment_image(base_img)
    p = np.mean(observed != 128)
    assert 0.4 &lt; p &lt; 0.6

    aug = iaa.SaltAndPepper(p=1.0)
    observed = aug.augment_image(base_img)
    nb_pepper = np.sum(observed &lt; 40)
    nb_salt = np.sum(observed &gt; 255 - 40)
</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag850')" href="javascript:;">
imgaug-0.2.7/test/augmenters/test_arithmetic.py: 1021-1039
</a>
<div class="mid" id="frag850" style="display:none"><pre>
    hm_aug = aug.augment_heatmaps([hm])[0]
    assert np.allclose(hm.arr_0to1, hm_aug.arr_0to1)


def test_Salt():
    reseed()

    base_img = np.zeros((100, 100, 1), dtype=np.uint8) + 128
    aug = iaa.Salt(p=0.5)
    observed = aug.augment_image(base_img)
    p = np.mean(observed != 128)
    assert 0.4 &lt; p &lt; 0.6
    # Salt() occasionally replaces with 127, which probably should be the center-point here anyways
    assert np.all(observed &gt;= 127)

    aug = iaa.Salt(p=1.0)
    observed = aug.augment_image(base_img)
    nb_pepper = np.sum(observed &lt; 40)
    nb_salt = np.sum(observed &gt; 255 - 40)
</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag852')" href="javascript:;">
imgaug-0.2.7/test/augmenters/test_arithmetic.py: 1122-1139
</a>
<div class="mid" id="frag852" style="display:none"><pre>
    hm_aug = aug.augment_heatmaps([hm])[0]
    assert np.allclose(hm.arr_0to1, hm_aug.arr_0to1)


def test_Pepper():
    reseed()

    base_img = np.zeros((100, 100, 1), dtype=np.uint8) + 128
    aug = iaa.Pepper(p=0.5)
    observed = aug.augment_image(base_img)
    p = np.mean(observed != 128)
    assert 0.4 &lt; p &lt; 0.6
    assert np.all(observed &lt;= 128)

    aug = iaa.Pepper(p=1.0)
    observed = aug.augment_image(base_img)
    nb_pepper = np.sum(observed &lt; 40)
    nb_salt = np.sum(observed &gt; 255 - 40)
</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 39:</b> &nbsp; 3 fragments, nominal size 67 lines, similarity 100%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag849')" href="javascript:;">
imgaug-0.2.7/test/augmenters/test_arithmetic.py: 942-1020
</a>
<div class="mid" id="frag849" style="display:none"><pre>
    # not more tests necessary here as SaltAndPepper is just a tiny wrapper around
    # ReplaceElementwise


def test_CoarseSaltAndPepper():
    reseed()

    base_img = np.zeros((100, 100, 1), dtype=np.uint8) + 128
    aug = iaa.CoarseSaltAndPepper(p=0.5, size_px=100)
    observed = aug.augment_image(base_img)
    p = np.mean(observed != 128)
    assert 0.4 &lt; p &lt; 0.6

    aug1 = iaa.CoarseSaltAndPepper(p=0.5, size_px=100)
    aug2 = iaa.CoarseSaltAndPepper(p=0.5, size_px=10)
    base_img = np.zeros((100, 100, 1), dtype=np.uint8) + 128
    ps1 = []
    ps2 = []
    for _ in sm.xrange(100):
        observed1 = aug1.augment_image(base_img)
        observed2 = aug2.augment_image(base_img)
        p1 = np.mean(observed1 != 128)
        p2 = np.mean(observed2 != 128)
        ps1.append(p1)
        ps2.append(p2)
    assert 0.4 &lt; np.mean(ps2) &lt; 0.6
    assert np.std(ps1)*1.5 &lt; np.std(ps2)

    aug = iaa.CoarseSaltAndPepper(p=[0.2, 0.5], size_px=100)
    base_img = np.zeros((100, 100, 1), dtype=np.uint8) + 128
    seen = [0, 0, 0]
    for _ in sm.xrange(200):
        observed = aug.augment_image(base_img)
        p = np.mean(observed != 128)
        diff_020 = abs(0.2 - p)
        diff_050 = abs(0.5 - p)
        if diff_020 &lt; 0.025:
            seen[0] += 1
        elif diff_050 &lt; 0.025:
            seen[1] += 1
        else:
            seen[2] += 1
    assert seen[2] &lt; 10
    assert 75 &lt; seen[0] &lt; 125
    assert 75 &lt; seen[1] &lt; 125

    aug = iaa.CoarseSaltAndPepper(p=(0.0, 1.0), size_px=50)
    base_img = np.zeros((50, 50, 1), dtype=np.uint8) + 128
    ps = []
    for _ in sm.xrange(200):
        observed = aug.augment_image(base_img)
        p = np.mean(observed != 128)
        ps.append(p)

    nb_bins = 5
    hist, _ = np.histogram(ps, bins=nb_bins, range=(0.0, 1.0), density=False)
    tolerance = 0.05
    for nb_seen in hist:
        density = nb_seen / len(ps)
        assert density - tolerance &lt; density &lt; density + tolerance

    # test exceptions for wrong parameter types
    got_exception = False
    try:
        _ = iaa.CoarseSaltAndPepper(p="test", size_px=100)
    except Exception:
        got_exception = True
    assert got_exception

    got_exception = False
    try:
        _ = iaa.CoarseSaltAndPepper(p=0.5, size_px=None, size_percent=None)
    except Exception:
        got_exception = True
    assert got_exception

    # test heatmaps (not affected by augmenter)
    aug = iaa.CoarseSaltAndPepper(p=1.0, size_px=2)
    hm = ia.quokka_heatmap()
</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag853')" href="javascript:;">
imgaug-0.2.7/test/augmenters/test_arithmetic.py: 1143-1221
</a>
<div class="mid" id="frag853" style="display:none"><pre>
    # not more tests necessary here as Salt is just a tiny wrapper around
    # ReplaceElementwise


def test_CoarsePepper():
    reseed()

    base_img = np.zeros((100, 100, 1), dtype=np.uint8) + 128
    aug = iaa.CoarsePepper(p=0.5, size_px=100)
    observed = aug.augment_image(base_img)
    p = np.mean(observed != 128)
    assert 0.4 &lt; p &lt; 0.6

    aug1 = iaa.CoarsePepper(p=0.5, size_px=100)
    aug2 = iaa.CoarsePepper(p=0.5, size_px=10)
    base_img = np.zeros((100, 100, 1), dtype=np.uint8) + 128
    ps1 = []
    ps2 = []
    for _ in sm.xrange(100):
        observed1 = aug1.augment_image(base_img)
        observed2 = aug2.augment_image(base_img)
        p1 = np.mean(observed1 != 128)
        p2 = np.mean(observed2 != 128)
        ps1.append(p1)
        ps2.append(p2)
    assert 0.4 &lt; np.mean(ps2) &lt; 0.6
    assert np.std(ps1)*1.5 &lt; np.std(ps2)

    aug = iaa.CoarsePepper(p=[0.2, 0.5], size_px=100)
    base_img = np.zeros((100, 100, 1), dtype=np.uint8) + 128
    seen = [0, 0, 0]
    for _ in sm.xrange(200):
        observed = aug.augment_image(base_img)
        p = np.mean(observed != 128)
        diff_020 = abs(0.2 - p)
        diff_050 = abs(0.5 - p)
        if diff_020 &lt; 0.025:
            seen[0] += 1
        elif diff_050 &lt; 0.025:
            seen[1] += 1
        else:
            seen[2] += 1
    assert seen[2] &lt; 10
    assert 75 &lt; seen[0] &lt; 125
    assert 75 &lt; seen[1] &lt; 125

    aug = iaa.CoarsePepper(p=(0.0, 1.0), size_px=50)
    base_img = np.zeros((50, 50, 1), dtype=np.uint8) + 128
    ps = []
    for _ in sm.xrange(200):
        observed = aug.augment_image(base_img)
        p = np.mean(observed != 128)
        ps.append(p)

    nb_bins = 5
    hist, _ = np.histogram(ps, bins=nb_bins, range=(0.0, 1.0), density=False)
    tolerance = 0.05
    for nb_seen in hist:
        density = nb_seen / len(ps)
        assert density - tolerance &lt; density &lt; density + tolerance

    # test exceptions for wrong parameter types
    got_exception = False
    try:
        _ = iaa.CoarsePepper(p="test", size_px=100)
    except Exception:
        got_exception = True
    assert got_exception

    got_exception = False
    try:
        _ = iaa.CoarsePepper(p=0.5, size_px=None, size_percent=None)
    except Exception:
        got_exception = True
    assert got_exception

    # test heatmaps (not affected by augmenter)
    aug = iaa.CoarsePepper(p=1.0, size_px=2)
    hm = ia.quokka_heatmap()
</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag851')" href="javascript:;">
imgaug-0.2.7/test/augmenters/test_arithmetic.py: 1043-1121
</a>
<div class="mid" id="frag851" style="display:none"><pre>
    # not more tests necessary here as Salt is just a tiny wrapper around
    # ReplaceElementwise


def test_CoarseSalt():
    reseed()

    base_img = np.zeros((100, 100, 1), dtype=np.uint8) + 128
    aug = iaa.CoarseSalt(p=0.5, size_px=100)
    observed = aug.augment_image(base_img)
    p = np.mean(observed != 128)
    assert 0.4 &lt; p &lt; 0.6

    aug1 = iaa.CoarseSalt(p=0.5, size_px=100)
    aug2 = iaa.CoarseSalt(p=0.5, size_px=10)
    base_img = np.zeros((100, 100, 1), dtype=np.uint8) + 128
    ps1 = []
    ps2 = []
    for _ in sm.xrange(100):
        observed1 = aug1.augment_image(base_img)
        observed2 = aug2.augment_image(base_img)
        p1 = np.mean(observed1 != 128)
        p2 = np.mean(observed2 != 128)
        ps1.append(p1)
        ps2.append(p2)
    assert 0.4 &lt; np.mean(ps2) &lt; 0.6
    assert np.std(ps1)*1.5 &lt; np.std(ps2)

    aug = iaa.CoarseSalt(p=[0.2, 0.5], size_px=100)
    base_img = np.zeros((100, 100, 1), dtype=np.uint8) + 128
    seen = [0, 0, 0]
    for _ in sm.xrange(200):
        observed = aug.augment_image(base_img)
        p = np.mean(observed != 128)
        diff_020 = abs(0.2 - p)
        diff_050 = abs(0.5 - p)
        if diff_020 &lt; 0.025:
            seen[0] += 1
        elif diff_050 &lt; 0.025:
            seen[1] += 1
        else:
            seen[2] += 1
    assert seen[2] &lt; 10
    assert 75 &lt; seen[0] &lt; 125
    assert 75 &lt; seen[1] &lt; 125

    aug = iaa.CoarseSalt(p=(0.0, 1.0), size_px=50)
    base_img = np.zeros((50, 50, 1), dtype=np.uint8) + 128
    ps = []
    for _ in sm.xrange(200):
        observed = aug.augment_image(base_img)
        p = np.mean(observed != 128)
        ps.append(p)

    nb_bins = 5
    hist, _ = np.histogram(ps, bins=nb_bins, range=(0.0, 1.0), density=False)
    tolerance = 0.05
    for nb_seen in hist:
        density = nb_seen / len(ps)
        assert density - tolerance &lt; density &lt; density + tolerance

    # test exceptions for wrong parameter types
    got_exception = False
    try:
        _ = iaa.CoarseSalt(p="test", size_px=100)
    except Exception:
        got_exception = True
    assert got_exception

    got_exception = False
    try:
        _ = iaa.CoarseSalt(p=0.5, size_px=None, size_percent=None)
    except Exception:
        got_exception = True
    assert got_exception

    # test heatmaps (not affected by augmenter)
    aug = iaa.CoarseSalt(p=1.0, size_px=2)
    hm = ia.quokka_heatmap()
</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 40:</b> &nbsp; 2 fragments, nominal size 188 lines, similarity 80%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag892')" href="javascript:;">
imgaug-0.2.7/test/test_parameters.py: 63-281
</a>
<div class="mid" id="frag892" style="display:none"><pre>
def test_parameters_handle_continuous_param():
    # value without value range
    got_exception = False
    try:
        result = iap.handle_continuous_param(1, "[test1]", value_range=None, tuple_to_uniform=True, list_to_choice=True)
        assert isinstance(result, iap.Deterministic)
    except Exception as e:
        got_exception = True
        assert "[test1]" in str(e)
    assert got_exception == False

    # value without value range as (None, None)
    got_exception = False
    try:
        result = iap.handle_continuous_param(1, "[test1b]", value_range=(None, None), tuple_to_uniform=True,
                                             list_to_choice=True)
        assert isinstance(result, iap.Deterministic)
    except Exception as e:
        got_exception = True
        assert "[test1b]" in str(e)
    assert got_exception == False

    # stochastic parameter
    got_exception = False
    try:
        result = iap.handle_continuous_param(iap.Deterministic(1), "[test2]", value_range=None, tuple_to_uniform=True,
                                             list_to_choice=True)
        assert isinstance(result, iap.Deterministic)
    except Exception as e:
        got_exception = True
        assert "[test2]" in str(e)
    assert got_exception == False

    # value within value range
    got_exception = False
    try:
        result = iap.handle_continuous_param(1, "[test3]", value_range=(0, 10), tuple_to_uniform=True,
                                             list_to_choice=True)
        assert isinstance(result, iap.Deterministic)
    except Exception as e:
        got_exception = True
        assert "[test3]" in str(e)
    assert got_exception == False

    # value outside of value range
    got_exception = False
    try:
        result = iap.handle_continuous_param(1, "[test4]", value_range=(2, 12), tuple_to_uniform=True,
                                             list_to_choice=True)
        assert isinstance(result, iap.Deterministic)
    except Exception as e:
        got_exception = True
        assert "[test4]" in str(e)
    assert got_exception == True

    # value within value range (without lower bound)
    got_exception = False
    try:
        result = iap.handle_continuous_param(1, "[test5]", value_range=(None, 12), tuple_to_uniform=True,
                                             list_to_choice=True)
        assert isinstance(result, iap.Deterministic)
    except Exception as e:
        got_exception = True
        assert "[test5]" in str(e)
    assert got_exception == False

    # value outside of value range (without lower bound)
    got_exception = False
    try:
        result = iap.handle_continuous_param(1, "[test6]", value_range=(None, 0), tuple_to_uniform=True,
                                             list_to_choice=True)
        assert isinstance(result, iap.Deterministic)
    except Exception as e:
        got_exception = True
        assert "[test6]" in str(e)
    assert got_exception == True

    # value within value range (without upper bound)
    got_exception = False
    try:
        result = iap.handle_continuous_param(1, "[test7]", value_range=(-1, None), tuple_to_uniform=True,
                                             list_to_choice=True)
        assert isinstance(result, iap.Deterministic)
    except Exception as e:
        got_exception = True
        assert "[test7]" in str(e)
    assert got_exception == False

    # value outside of value range (without upper bound)
    got_exception = False
    try:
        result = iap.handle_continuous_param(1, "[test8]", value_range=(2, None), tuple_to_uniform=True,
                                             list_to_choice=True)
        assert isinstance(result, iap.Deterministic)
    except Exception as e:
        got_exception = True
        assert "[test8]" in str(e)
    assert got_exception == True

    # tuple as value, but no tuples allowed
    got_exception = False
    try:
        result = iap.handle_continuous_param((1, 2), "[test9]", value_range=None, tuple_to_uniform=False,
                                             list_to_choice=True)
        assert isinstance(result, iap.Uniform)
    except Exception as e:
        got_exception = True
        assert "[test9]" in str(e)
    assert got_exception == True

    # tuple as value and tuple allowed
    got_exception = False
    try:
        result = iap.handle_continuous_param((1, 2), "[test10]", value_range=None, tuple_to_uniform=True,
                                             list_to_choice=True)
        assert isinstance(result, iap.Uniform)
    except Exception as e:
        got_exception = True
        assert "[test10]" in str(e)
    assert got_exception == False

    # tuple as value and tuple allowed and tuple within value range
    got_exception = False
    try:
        result = iap.handle_continuous_param((1, 2), "[test11]", value_range=(0, 10), tuple_to_uniform=True,
                                             list_to_choice=True)
        assert isinstance(result, iap.Uniform)
    except Exception as e:
        got_exception = True
        assert "[test11]" in str(e)
    assert got_exception == False

    # tuple as value and tuple allowed and tuple partially outside of value range
    got_exception = False
    try:
        result = iap.handle_continuous_param((1, 2), "[test12]", value_range=(1.5, 13), tuple_to_uniform=True,
                                             list_to_choice=True)
        assert isinstance(result, iap.Uniform)
    except Exception as e:
        got_exception = True
        assert "[test12]" in str(e)
    assert got_exception == True

    # tuple as value and tuple allowed and tuple fully outside of value range
    got_exception = False
    try:
        result = iap.handle_continuous_param((1, 2), "[test13]", value_range=(3, 13), tuple_to_uniform=True,
                                             list_to_choice=True)
        assert isinstance(result, iap.Uniform)
    except Exception as e:
        got_exception = True
        assert "[test13]" in str(e)
    assert got_exception == True

    # list as value, but no list allowed
    got_exception = False
    try:
        result = iap.handle_continuous_param([1, 2, 3], "[test14]", value_range=None, tuple_to_uniform=True,
                                             list_to_choice=False)
        assert isinstance(result, iap.Choice)
    except Exception as e:
        got_exception = True
        assert "[test14]" in str(e)
    assert got_exception == True

    # list as value and list allowed
    got_exception = False
    try:
        result = iap.handle_continuous_param([1, 2, 3], "[test15]", value_range=None, tuple_to_uniform=True,
                                             list_to_choice=True)
        assert isinstance(result, iap.Choice)
    except Exception as e:
        got_exception = True
        assert "[test15]" in str(e)
    assert got_exception == False

    # list as value and list allowed and list partially outside of value range
    got_exception = False
    try:
        result = iap.handle_continuous_param([1, 2], "[test16]", value_range=(1.5, 13), tuple_to_uniform=True,
                                             list_to_choice=True)
        assert isinstance(result, iap.Choice)
    except Exception as e:
        got_exception = True
        assert "[test16]" in str(e)
    assert got_exception == True

    # list as value and list allowed and list fully outside of value range
    got_exception = False
    try:
        result = iap.handle_continuous_param([1, 2], "[test17]", value_range=(3, 13), tuple_to_uniform=True,
                                             list_to_choice=True)
        assert isinstance(result, iap.Choice)
    except Exception as e:
        got_exception = True
        assert "[test17]" in str(e)
    assert got_exception == True

    # single value within value range given as callable
    got_exception = False
    try:
        result = iap.handle_continuous_param(1, "[test18]", value_range=lambda x: -1 &lt; x &lt; 1, tuple_to_uniform=True,
                                             list_to_choice=True)
    except Exception as e:
        got_exception = True
        assert "[test18]" in str(e)
    assert got_exception == False

    # bad datatype for value range
    got_exception = False
    try:
        result = iap.handle_continuous_param(1, "[test19]", value_range=False, tuple_to_uniform=True,
                                             list_to_choice=True)
    except Exception as e:
        got_exception = True
        assert "Unexpected input for value_range" in str(e)
    assert got_exception == True


</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag893')" href="javascript:;">
imgaug-0.2.7/test/test_parameters.py: 282-523
</a>
<div class="mid" id="frag893" style="display:none"><pre>
def test_parameters_handle_discrete_param():
    # float value without value range when no float value is allowed
    got_exception = False
    try:
        result = iap.handle_discrete_param(1.5, "[test0]", value_range=None, tuple_to_uniform=True,
                                           list_to_choice=True, allow_floats=False)
        assert isinstance(result, iap.Deterministic)
    except Exception as e:
        got_exception = True
        assert "[test0]" in str(e)
    assert got_exception == True

    # value without value range
    got_exception = False
    try:
        result = iap.handle_discrete_param(1, "[test1]", value_range=None, tuple_to_uniform=True, list_to_choice=True,
                                           allow_floats=True)
        assert isinstance(result, iap.Deterministic)
    except Exception as e:
        got_exception = True
        assert "[test1]" in str(e)
    assert got_exception == False

    # value without value range as (None, None)
    got_exception = False
    try:
        result = iap.handle_discrete_param(1, "[test1b]", value_range=(None, None), tuple_to_uniform=True,
                                           list_to_choice=True, allow_floats=True)
        assert isinstance(result, iap.Deterministic)
    except Exception as e:
        got_exception = True
        assert "[test1b]" in str(e)
    assert got_exception == False

    # stochastic parameter
    got_exception = False
    try:
        result = iap.handle_discrete_param(iap.Deterministic(1), "[test2]", value_range=None, tuple_to_uniform=True,
                                           list_to_choice=True, allow_floats=True)
        assert isinstance(result, iap.Deterministic)
    except Exception as e:
        got_exception = True
        assert "[test2]" in str(e)
    assert got_exception == False

    # value within value range
    got_exception = False
    try:
        result = iap.handle_discrete_param(1, "[test3]", value_range=(0, 10), tuple_to_uniform=True,
                                           list_to_choice=True, allow_floats=True)
        assert isinstance(result, iap.Deterministic)
    except Exception as e:
        got_exception = True
        assert "[test3]" in str(e)
    assert got_exception == False

    # value outside of value range
    got_exception = False
    try:
        result = iap.handle_discrete_param(1, "[test4]", value_range=(2, 12), tuple_to_uniform=True,
                                           list_to_choice=True, allow_floats=True)
        assert isinstance(result, iap.Deterministic)
    except Exception as e:
        got_exception = True
        assert "[test4]" in str(e)
    assert got_exception == True

    # value within value range (without lower bound)
    got_exception = False
    try:
        result = iap.handle_discrete_param(1, "[test5]", value_range=(None, 12), tuple_to_uniform=True,
                                           list_to_choice=True, allow_floats=True)
        assert isinstance(result, iap.Deterministic)
    except Exception as e:
        got_exception = True
        assert "[test5]" in str(e)
    assert got_exception == False

    # value outside of value range (without lower bound)
    got_exception = False
    try:
        result = iap.handle_discrete_param(1, "[test6]", value_range=(None, 0), tuple_to_uniform=True,
                                           list_to_choice=True, allow_floats=True)
        assert isinstance(result, iap.Deterministic)
    except Exception as e:
        got_exception = True
        assert "[test6]" in str(e)
    assert got_exception == True

    # value within value range (without upper bound)
    got_exception = False
    try:
        result = iap.handle_discrete_param(1, "[test7]", value_range=(-1, None), tuple_to_uniform=True,
                                           list_to_choice=True, allow_floats=True)
        assert isinstance(result, iap.Deterministic)
    except Exception as e:
        got_exception = True
        assert "[test7]" in str(e)
    assert got_exception == False

    # value outside of value range (without upper bound)
    got_exception = False
    try:
        result = iap.handle_discrete_param(1, "[test8]", value_range=(2, None), tuple_to_uniform=True,
                                           list_to_choice=True, allow_floats=True)
        assert isinstance(result, iap.Deterministic)
    except Exception as e:
        got_exception = True
        assert "[test8]" in str(e)
    assert got_exception == True

    # tuple as value, but no tuples allowed
    got_exception = False
    try:
        result = iap.handle_discrete_param((1, 2), "[test9]", value_range=None, tuple_to_uniform=False,
                                           list_to_choice=True, allow_floats=True)
        assert isinstance(result, iap.DiscreteUniform)
    except Exception as e:
        got_exception = True
        assert "[test9]" in str(e)
    assert got_exception == True

    # tuple as value and tuple allowed
    got_exception = False
    try:
        result = iap.handle_discrete_param((1, 2), "[test10]", value_range=None, tuple_to_uniform=True,
                                           list_to_choice=True, allow_floats=True)
        assert isinstance(result, iap.DiscreteUniform)
    except Exception as e:
        got_exception = True
        assert "[test10]" in str(e)
    assert got_exception == False

    # tuple as value and tuple allowed and tuple within value range
    got_exception = False
    try:
        result = iap.handle_discrete_param((1, 2), "[test11]", value_range=(0, 10), tuple_to_uniform=True,
                                           list_to_choice=True, allow_floats=True)
        assert isinstance(result, iap.DiscreteUniform)
    except Exception as e:
        got_exception = True
        assert "[test11]" in str(e)
    assert got_exception == False

    # tuple as value and tuple allowed and tuple within value range with allow_floats=False
    got_exception = False
    try:
        result = iap.handle_discrete_param((1, 2), "[test11b]", value_range=(0, 10), tuple_to_uniform=True,
                                           list_to_choice=True, allow_floats=False)
        assert isinstance(result, iap.DiscreteUniform)
    except Exception as e:
        got_exception = True
        assert "[test11b]" in str(e)
    assert got_exception == False

    # tuple as value and tuple allowed and tuple partially outside of value range
    got_exception = False
    try:
        result = iap.handle_discrete_param((1, 3), "[test12]", value_range=(2, 13), tuple_to_uniform=True,
                                           list_to_choice=True, allow_floats=True)
        assert isinstance(result, iap.DiscreteUniform)
    except Exception as e:
        got_exception = True
        assert "[test12]" in str(e)
    assert got_exception == True

    # tuple as value and tuple allowed and tuple fully outside of value range
    got_exception = False
    try:
        result = iap.handle_discrete_param((1, 2), "[test13]", value_range=(3, 13), tuple_to_uniform=True,
                                           list_to_choice=True, allow_floats=True)
        assert isinstance(result, iap.DiscreteUniform)
    except Exception as e:
        got_exception = True
        assert "[test13]" in str(e)
    assert got_exception == True

    # list as value, but no list allowed
    got_exception = False
    try:
        result = iap.handle_discrete_param([1, 2, 3], "[test14]", value_range=None, tuple_to_uniform=True,
                                           list_to_choice=False, allow_floats=True)
        assert isinstance(result, iap.Choice)
    except Exception as e:
        got_exception = True
        assert "[test14]" in str(e)
    assert got_exception == True

    # list as value and list allowed
    got_exception = False
    try:
        result = iap.handle_discrete_param([1, 2, 3], "[test15]", value_range=None, tuple_to_uniform=True,
                                           list_to_choice=True, allow_floats=True)
        assert isinstance(result, iap.Choice)
    except Exception as e:
        got_exception = True
        assert "[test15]" in str(e)
    assert got_exception == False

    # list as value and list allowed and list partially outside of value range
    got_exception = False
    try:
        result = iap.handle_discrete_param([1, 3], "[test16]", value_range=(2, 13), tuple_to_uniform=True,
                                           list_to_choice=True, allow_floats=True)
        assert isinstance(result, iap.Choice)
    except Exception as e:
        got_exception = True
        assert "[test16]" in str(e)
    assert got_exception == True

    # list as value and list allowed and list fully outside of value range
    got_exception = False
    try:
        result = iap.handle_discrete_param([1, 2], "[test17]", value_range=(3, 13), tuple_to_uniform=True,
                                           list_to_choice=True, allow_floats=True)
        assert isinstance(result, iap.Choice)
    except Exception as e:
        got_exception = True
        assert "[test17]" in str(e)
    assert got_exception == True

    # single value within value range given as callable
    got_exception = False
    try:
        _ = iap.handle_discrete_param(1, "[test18]", value_range=lambda x: -1 &lt; x &lt; 1, tuple_to_uniform=True,
                                           list_to_choice=True)
    except Exception as e:
        got_exception = True
        assert "[test18]" in str(e)
    assert got_exception == False

    # bad datatype for value range
    got_exception = False
    try:
        _ = iap.handle_discrete_param(1, "[test19]", value_range=False, tuple_to_uniform=True,
                                           list_to_choice=True)
    except Exception as e:
        got_exception = True
        assert "Unexpected input for value_range" in str(e)
    assert got_exception == True


</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 41:</b> &nbsp; 2 fragments, nominal size 45 lines, similarity 87%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag903')" href="javascript:;">
imgaug-0.2.7/test/test_parameters.py: 898-948
</a>
<div class="mid" id="frag903" style="display:none"><pre>

def test_parameters_Normal():
    reseed()

    param = iap.Normal(0, 1)
    sample = param.draw_sample()
    samples = param.draw_samples((100, 1000))
    samples_direct = np.random.RandomState(1234).normal(loc=0, scale=1, size=(100, 1000))
    assert sample.shape == tuple()
    assert samples.shape == (100, 1000)
    assert param.__str__() == param.__repr__() == "Normal(loc=Deterministic(int 0), scale=Deterministic(int 1))"

    samples = np.clip(samples, -1, 1)
    samples_direct = np.clip(samples_direct, -1, 1)
    nb_bins = 10
    hist, _ = np.histogram(samples, bins=nb_bins, range=(-1.0, 1.0), density=False)
    hist_direct, _ = np.histogram(samples_direct, bins=nb_bins, range=(-1.0, 1.0), density=False)
    tolerance = 0.05
    for nb_samples, nb_samples_direct in zip(hist, hist_direct):
        density = nb_samples / samples.size
        density_direct = nb_samples_direct / samples_direct.size
        assert density_direct - tolerance &lt; density &lt; density_direct + tolerance

    param = iap.Normal(iap.Choice([-100, 100]), 1)
    seen = [0, 0]
    for _ in sm.xrange(1000):
        samples = param.draw_samples((100,))
        exp = np.mean(samples)

        if -100 - 10 &lt; exp &lt; -100 + 10:
            seen[0] += 1
        elif 100 - 10 &lt; exp &lt; 100 + 10:
            seen[1] += 1
        else:
            assert False

    assert 500 - 100 &lt; seen[0] &lt; 500 + 100
    assert 500 - 100 &lt; seen[1] &lt; 500 + 100

    param1 = iap.Normal(0, 1)
    param2 = iap.Normal(0, 100)
    samples1 = param1.draw_samples((1000,))
    samples2 = param2.draw_samples((1000,))
    assert np.std(samples1) &lt; np.std(samples2)
    assert 100 - 10 &lt; np.std(samples2) &lt; 100 + 10

    param = iap.Normal(0, 1)
    samples1 = param.draw_samples((10, 5), random_state=np.random.RandomState(1234))
    samples2 = param.draw_samples((10, 5), random_state=np.random.RandomState(1234))
    assert np.allclose(samples1, samples2)

</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag904')" href="javascript:;">
imgaug-0.2.7/test/test_parameters.py: 949-1006
</a>
<div class="mid" id="frag904" style="display:none"><pre>

def test_parameters_Laplace():
    reseed()
    eps = np.finfo(np.float32).eps

    param = iap.Laplace(0, 1)
    sample = param.draw_sample()
    samples = param.draw_samples((100, 1000))
    samples_direct = np.random.RandomState(1234).laplace(loc=0, scale=1, size=(100, 1000))
    assert sample.shape == tuple()
    assert samples.shape == (100, 1000)
    assert param.__str__() == param.__repr__() == "Laplace(loc=Deterministic(int 0), scale=Deterministic(int 1))"

    samples = np.clip(samples, -1, 1)
    samples_direct = np.clip(samples_direct, -1, 1)
    nb_bins = 10
    hist, _ = np.histogram(samples, bins=nb_bins, range=(-1.0, 1.0), density=False)
    hist_direct, _ = np.histogram(samples_direct, bins=nb_bins, range=(-1.0, 1.0), density=False)
    tolerance = 0.05
    for nb_samples, nb_samples_direct in zip(hist, hist_direct):
        density = nb_samples / samples.size
        density_direct = nb_samples_direct / samples_direct.size
        assert density_direct - tolerance &lt; density &lt; density_direct + tolerance

    param = iap.Laplace(iap.Choice([-100, 100]), 1)
    seen = [0, 0]
    for _ in sm.xrange(1000):
        samples = param.draw_samples((100,))
        exp = np.mean(samples)

        if -100 - 10 &lt; exp &lt; -100 + 10:
            seen[0] += 1
        elif 100 - 10 &lt; exp &lt; 100 + 10:
            seen[1] += 1
        else:
            assert False

    assert 500 - 100 &lt; seen[0] &lt; 500 + 100
    assert 500 - 100 &lt; seen[1] &lt; 500 + 100

    param1 = iap.Laplace(0, 1)
    param2 = iap.Laplace(0, 100)
    samples1 = param1.draw_samples((1000,))
    samples2 = param2.draw_samples((1000,))
    assert np.var(samples1) &lt; np.var(samples2)

    param1 = iap.Laplace(1, 0)
    samples = param1.draw_samples((100,))
    assert np.all(np.logical_and(
        samples &gt; 1 - eps,
        samples &lt; 1 + eps
    ))

    param = iap.Laplace(0, 1)
    samples1 = param.draw_samples((10, 5), random_state=np.random.RandomState(1234))
    samples2 = param.draw_samples((10, 5), random_state=np.random.RandomState(1234))
    assert np.allclose(samples1, samples2)

</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 42:</b> &nbsp; 2 fragments, nominal size 47 lines, similarity 79%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag905')" href="javascript:;">
imgaug-0.2.7/test/test_parameters.py: 1007-1060
</a>
<div class="mid" id="frag905" style="display:none"><pre>

def test_parameters_ChiSquare():
    reseed()

    param = iap.ChiSquare(1)
    sample = param.draw_sample()
    samples = param.draw_samples((100, 1000))
    samples_direct = np.random.RandomState(1234).chisquare(df=1, size=(100, 1000))
    assert sample.shape == tuple()
    assert samples.shape == (100, 1000)
    assert 0 &lt;= sample
    assert np.all(0 &lt;= samples)
    assert param.__str__() == param.__repr__() == "ChiSquare(df=Deterministic(int 1))"

    samples = np.clip(samples, 0, 3)
    samples_direct = np.clip(samples_direct, 0, 3)
    nb_bins = 10
    hist, _ = np.histogram(samples, bins=nb_bins, range=(0, 3.0), density=False)
    hist_direct, _ = np.histogram(samples_direct, bins=nb_bins, range=(0, 3.0), density=False)
    tolerance = 0.05
    for nb_samples, nb_samples_direct in zip(hist, hist_direct):
        density = nb_samples / samples.size
        density_direct = nb_samples_direct / samples_direct.size
        assert density_direct - tolerance &lt; density &lt; density_direct + tolerance

    param = iap.ChiSquare(iap.Choice([1, 10]))
    seen = [0, 0]
    for _ in sm.xrange(1000):
        samples = param.draw_samples((100,))
        exp = np.mean(samples)

        if 1 - 1.0 &lt; exp &lt; 1 + 1.0:
            seen[0] += 1
        elif 10 - 4.0 &lt; exp &lt; 10 + 4.0:
            seen[1] += 1
        else:
            assert False

    assert 500 - 100 &lt; seen[0] &lt; 500 + 100
    assert 500 - 100 &lt; seen[1] &lt; 500 + 100

    param1 = iap.ChiSquare(1)
    param2 = iap.ChiSquare(10)
    samples1 = param1.draw_samples((1000,))
    samples2 = param2.draw_samples((1000,))
    assert np.var(samples1) &lt; np.var(samples2)
    assert 2*1 - 1.0 &lt; np.var(samples1) &lt; 2*1 + 1.0
    assert 2*10 - 5.0 &lt; np.var(samples2) &lt; 2*10 + 5.0

    param = iap.ChiSquare(1)
    samples1 = param.draw_samples((10, 5), random_state=np.random.RandomState(1234))
    samples2 = param.draw_samples((10, 5), random_state=np.random.RandomState(1234))
    assert np.allclose(samples1, samples2)

</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag906')" href="javascript:;">
imgaug-0.2.7/test/test_parameters.py: 1061-1118
</a>
<div class="mid" id="frag906" style="display:none"><pre>

def test_parameters_Weibull():
    reseed()

    param = iap.Weibull(1)
    sample = param.draw_sample()
    samples = param.draw_samples((100, 1000))
    samples_direct = np.random.RandomState(1234).weibull(a=1, size=(100, 1000))
    assert sample.shape == tuple()
    assert samples.shape == (100, 1000)
    assert 0 &lt;= sample
    assert np.all(0 &lt;= samples)
    assert param.__str__() == param.__repr__() == "Weibull(a=Deterministic(int 1))"

    samples = np.clip(samples, 0, 2)
    samples_direct = np.clip(samples_direct, 0, 2)
    nb_bins = 10
    hist, _ = np.histogram(samples, bins=nb_bins, range=(0, 2.0), density=False)
    hist_direct, _ = np.histogram(samples_direct, bins=nb_bins, range=(0, 2.0), density=False)
    tolerance = 0.05
    for nb_samples, nb_samples_direct in zip(hist, hist_direct):
        density = nb_samples / samples.size
        density_direct = nb_samples_direct / samples_direct.size
        assert density_direct - tolerance &lt; density &lt; density_direct + tolerance

    param = iap.Weibull(iap.Choice([1, 0.5]))
    expected_first = scipy.special.gamma(1 + 1/1)
    expected_second = scipy.special.gamma(1 + 1/0.5)
    seen = [0, 0]
    for _ in sm.xrange(100):
        samples = param.draw_samples((50000,))
        observed = np.mean(samples)

        if expected_first - 0.2 * expected_first &lt; observed &lt; expected_first + 0.2 * expected_first:
            seen[0] += 1
        elif expected_second - 0.2 * expected_second &lt; observed &lt; expected_second + 0.2 * expected_second:
            seen[1] += 1
        else:
            assert False

    assert 50 - 25 &lt; seen[0] &lt; 50 + 25
    assert 50 - 25 &lt; seen[1] &lt; 50 + 25

    param1 = iap.Weibull(1)
    param2 = iap.Weibull(0.5)
    samples1 = param1.draw_samples((10000,))
    samples2 = param2.draw_samples((10000,))
    assert np.var(samples1) &lt; np.var(samples2)
    expected_first = scipy.special.gamma(1 + 2/1) - (scipy.special.gamma(1 + 1/1))**2
    expected_second = scipy.special.gamma(1 + 2/0.5) - (scipy.special.gamma(1 + 1/0.5))**2
    assert expected_first - 0.2 * expected_first &lt; np.var(samples1) &lt; expected_first + 0.2 * expected_first
    assert expected_second - 0.2 * expected_second &lt; np.var(samples2) &lt; expected_second + 0.2 * expected_second

    param = iap.Weibull(1)
    samples1 = param.draw_samples((10, 5), random_state=np.random.RandomState(1234))
    samples2 = param.draw_samples((10, 5), random_state=np.random.RandomState(1234))
    assert np.allclose(samples1, samples2)

</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 43:</b> &nbsp; 3 fragments, nominal size 59 lines, similarity 72%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag915')" href="javascript:;">
imgaug-0.2.7/test/test_parameters.py: 1669-1739
</a>
<div class="mid" id="frag915" style="display:none"><pre>


def test_parameters_Multiply():
    reseed()
    eps = np.finfo(np.float32).eps

    values_int = [-100, -54, -1, 0, 1, 54, 100]
    values_float = [-100.0, -54.3, -1.0, 0.1, 0.0, 0.1, 1.0, 54.4, 100.0]

    for v1 in values_int:
        for v2 in values_int:
            p = iap.Multiply(iap.Deterministic(v1), v2)
            assert p.draw_sample() == v1 * v2
            samples = p.draw_samples((2, 3))
            assert samples.dtype == np.int64
            assert np.array_equal(samples, np.zeros((2, 3), dtype=np.int64) + v1 * v2)

            p = iap.Multiply(iap.Deterministic(v1), iap.Deterministic(v2))
            assert p.draw_sample() == v1 * v2
            samples = p.draw_samples((2, 3))
            assert samples.dtype == np.int64
            assert np.array_equal(samples, np.zeros((2, 3), dtype=np.int64) + v1 * v2)

    for v1 in values_float:
        for v2 in values_float:
            p = iap.Multiply(iap.Deterministic(v1), v2)
            assert v1 * v2 - eps &lt; p.draw_sample() &lt; v1 * v2 + eps
            samples = p.draw_samples((2, 3))
            assert samples.dtype == np.float64
            assert np.allclose(samples, np.zeros((2, 3), dtype=np.float64) + v1 * v2)

            p = iap.Multiply(iap.Deterministic(v1), iap.Deterministic(v2))
            assert v1 * v2 - eps &lt; p.draw_sample() &lt; v1 * v2 + eps
            samples = p.draw_samples((2, 3))
            assert samples.dtype == np.float64
            assert np.allclose(samples, np.zeros((2, 3), dtype=np.float64) + v1 * v2)

    param = iap.Multiply(iap.Deterministic(1.0), (1.0, 2.0), elementwise=False)
    samples = param.draw_samples((10, 20))
    assert samples.shape == (10, 20)
    assert np.all(samples &gt; 1.0 * 1.0 - eps)
    assert np.all(samples &lt; 1.0 * 2.0 + eps)
    samples_sorted = np.sort(samples.flatten())
    assert samples_sorted[0] - eps &lt; samples_sorted[-1] &lt; samples_sorted[0] + eps

    param = iap.Multiply(iap.Deterministic(1.0), (1.0, 2.0), elementwise=True)
    samples = param.draw_samples((10, 20))
    assert samples.shape == (10, 20)
    assert np.all(samples &gt; 1.0 * 1.0 - eps)
    assert np.all(samples &lt; 1.0 * 2.0 + eps)
    samples_sorted = np.sort(samples.flatten())
    assert not (samples_sorted[0] - eps &lt; samples_sorted[-1] &lt; samples_sorted[0] + eps)

    param = iap.Multiply(iap.Uniform(1.0, 2.0), 1.0, elementwise=False)
    samples = param.draw_samples((10, 20))
    assert samples.shape == (10, 20)
    assert np.all(samples &gt; 1.0 * 1.0 - eps)
    assert np.all(samples &lt; 2.0 * 1.0 + eps)
    samples_sorted = np.sort(samples.flatten())
    assert not (samples_sorted[0] - eps &lt; samples_sorted[-1] &lt; samples_sorted[0] + eps)

    param = iap.Multiply(iap.Uniform(1.0, 2.0), 1.0, elementwise=True)
    samples = param.draw_samples((10, 20))
    assert samples.shape == (10, 20)
    assert np.all(samples &gt; 1.0 * 1.0 - eps)
    assert np.all(samples &lt; 2.0 * 1.0 + eps)
    samples_sorted = np.sort(samples.flatten())
    assert not (samples_sorted[0] - eps &lt; samples_sorted[-1] &lt; samples_sorted[0] + eps)

    param = iap.Multiply(iap.Deterministic(0), 1, elementwise=False)
    assert param.__str__() == param.__repr__() == "Multiply(Deterministic(int 0), Deterministic(int 1), False)"
</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag917')" href="javascript:;">
imgaug-0.2.7/test/test_parameters.py: 1827-1897
</a>
<div class="mid" id="frag917" style="display:none"><pre>


def test_parameters_Add():
    reseed()
    eps = np.finfo(np.float32).eps

    values_int = [-100, -54, -1, 0, 1, 54, 100]
    values_float = [-100.0, -54.3, -1.0, 0.1, 0.0, 0.1, 1.0, 54.4, 100.0]

    for v1 in values_int:
        for v2 in values_int:
            p = iap.Add(iap.Deterministic(v1), v2)
            assert p.draw_sample() == v1 + v2
            samples = p.draw_samples((2, 3))
            assert samples.dtype == np.int64
            assert np.array_equal(samples, np.zeros((2, 3), dtype=np.int64) + v1 + v2)

            p = iap.Add(iap.Deterministic(v1), iap.Deterministic(v2))
            assert p.draw_sample() == v1 + v2
            samples = p.draw_samples((2, 3))
            assert samples.dtype == np.int64
            assert np.array_equal(samples, np.zeros((2, 3), dtype=np.int64) + v1 + v2)

    for v1 in values_float:
        for v2 in values_float:
            p = iap.Add(iap.Deterministic(v1), v2)
            assert v1 + v2 - eps &lt; p.draw_sample() &lt; v1 + v2 + eps
            samples = p.draw_samples((2, 3))
            assert samples.dtype == np.float64
            assert np.allclose(samples, np.zeros((2, 3), dtype=np.float64) + v1 + v2)

            p = iap.Add(iap.Deterministic(v1), iap.Deterministic(v2))
            assert v1 + v2 - eps &lt; p.draw_sample() &lt; v1 + v2 + eps
            samples = p.draw_samples((2, 3))
            assert samples.dtype == np.float64
            assert np.allclose(samples, np.zeros((2, 3), dtype=np.float64) + v1 + v2)

    param = iap.Add(iap.Deterministic(1.0), (1.0, 2.0), elementwise=False)
    samples = param.draw_samples((10, 20))
    assert samples.shape == (10, 20)
    assert np.all(samples &gt; 1.0 + 1.0 - eps)
    assert np.all(samples &lt; 1.0 + 2.0 + eps)
    samples_sorted = np.sort(samples.flatten())
    assert samples_sorted[0] - eps &lt; samples_sorted[-1] &lt; samples_sorted[0] + eps

    param = iap.Add(iap.Deterministic(1.0), (1.0, 2.0), elementwise=True)
    samples = param.draw_samples((10, 20))
    assert samples.shape == (10, 20)
    assert np.all(samples &gt; 1.0 + 1.0 - eps)
    assert np.all(samples &lt; 1.0 + 2.0 + eps)
    samples_sorted = np.sort(samples.flatten())
    assert not (samples_sorted[0] - eps &lt; samples_sorted[-1] &lt; samples_sorted[0] + eps)

    param = iap.Add(iap.Uniform(1.0, 2.0), 1.0, elementwise=False)
    samples = param.draw_samples((10, 20))
    assert samples.shape == (10, 20)
    assert np.all(samples &gt; 1.0 + 1.0 - eps)
    assert np.all(samples &lt; 2.0 + 1.0 + eps)
    samples_sorted = np.sort(samples.flatten())
    assert not (samples_sorted[0] - eps &lt; samples_sorted[-1] &lt; samples_sorted[0] + eps)

    param = iap.Add(iap.Uniform(1.0, 2.0), 1.0, elementwise=True)
    samples = param.draw_samples((10, 20))
    assert samples.shape == (10, 20)
    assert np.all(samples &gt; 1.0 + 1.0 - eps)
    assert np.all(samples &lt; 2.0 + 1.0 + eps)
    samples_sorted = np.sort(samples.flatten())
    assert not (samples_sorted[0] - eps &lt; samples_sorted[-1] &lt; samples_sorted[0] + eps)

    param = iap.Add(iap.Deterministic(0), 1, elementwise=False)
    assert param.__str__() == param.__repr__() == "Add(Deterministic(int 0), Deterministic(int 1), False)"
</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag918')" href="javascript:;">
imgaug-0.2.7/test/test_parameters.py: 1898-1968
</a>
<div class="mid" id="frag918" style="display:none"><pre>


def test_parameters_Subtract():
    reseed()
    eps = np.finfo(np.float32).eps

    values_int = [-100, -54, -1, 0, 1, 54, 100]
    values_float = [-100.0, -54.3, -1.0, 0.1, 0.0, 0.1, 1.0, 54.4, 100.0]

    for v1 in values_int:
        for v2 in values_int:
            p = iap.Subtract(iap.Deterministic(v1), v2)
            assert p.draw_sample() == v1 - v2
            samples = p.draw_samples((2, 3))
            assert samples.dtype == np.int64
            assert np.array_equal(samples, np.zeros((2, 3), dtype=np.int64) + v1 - v2)

            p = iap.Subtract(iap.Deterministic(v1), iap.Deterministic(v2))
            assert p.draw_sample() == v1 - v2
            samples = p.draw_samples((2, 3))
            assert samples.dtype == np.int64
            assert np.array_equal(samples, np.zeros((2, 3), dtype=np.int64) + v1 - v2)

    for v1 in values_float:
        for v2 in values_float:
            p = iap.Subtract(iap.Deterministic(v1), v2)
            assert v1 - v2 - eps &lt; p.draw_sample() &lt; v1 - v2 + eps
            samples = p.draw_samples((2, 3))
            assert samples.dtype == np.float64
            assert np.allclose(samples, np.zeros((2, 3), dtype=np.float64) + v1 - v2)

            p = iap.Subtract(iap.Deterministic(v1), iap.Deterministic(v2))
            assert v1 - v2 - eps &lt; p.draw_sample() &lt; v1 - v2 + eps
            samples = p.draw_samples((2, 3))
            assert samples.dtype == np.float64
            assert np.allclose(samples, np.zeros((2, 3), dtype=np.float64) + v1 - v2)

    param = iap.Subtract(iap.Deterministic(1.0), (1.0, 2.0), elementwise=False)
    samples = param.draw_samples((10, 20))
    assert samples.shape == (10, 20)
    assert np.all(samples &gt; 1.0 - 2.0 - eps)
    assert np.all(samples &lt; 1.0 - 1.0 + eps)
    samples_sorted = np.sort(samples.flatten())
    assert samples_sorted[0] - eps &lt; samples_sorted[-1] &lt; samples_sorted[0] + eps

    param = iap.Subtract(iap.Deterministic(1.0), (1.0, 2.0), elementwise=True)
    samples = param.draw_samples((10, 20))
    assert samples.shape == (10, 20)
    assert np.all(samples &gt; 1.0 - 2.0 - eps)
    assert np.all(samples &lt; 1.0 - 1.0 + eps)
    samples_sorted = np.sort(samples.flatten())
    assert not (samples_sorted[0] - eps &lt; samples_sorted[-1] &lt; samples_sorted[0] + eps)

    param = iap.Subtract(iap.Uniform(1.0, 2.0), 1.0, elementwise=False)
    samples = param.draw_samples((10, 20))
    assert samples.shape == (10, 20)
    assert np.all(samples &gt; 1.0 - 1.0 - eps)
    assert np.all(samples &lt; 2.0 - 1.0 + eps)
    samples_sorted = np.sort(samples.flatten())
    assert not (samples_sorted[0] - eps &lt; samples_sorted[-1] &lt; samples_sorted[0] + eps)

    param = iap.Subtract(iap.Uniform(1.0, 2.0), 1.0, elementwise=True)
    samples = param.draw_samples((10, 20))
    assert samples.shape == (10, 20)
    assert np.all(samples &gt; 1.0 - 1.0 - eps)
    assert np.all(samples &lt; 2.0 - 1.0 + eps)
    samples_sorted = np.sort(samples.flatten())
    assert not (samples_sorted[0] - eps &lt; samples_sorted[-1] &lt; samples_sorted[0] + eps)

    param = iap.Subtract(iap.Deterministic(0), 1, elementwise=False)
    assert param.__str__() == param.__repr__() == "Subtract(Deterministic(int 0), Deterministic(int 1), False)"
</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 44:</b> &nbsp; 3 fragments, nominal size 30 lines, similarity 76%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag941')" href="javascript:;">
imgaug-0.2.7/generate_documentation_images.py: 374-431
</a>
<div class="mid" id="frag941" style="display:none"><pre>
def chapter_examples_keypoints_simple():
    import imgaug as ia
    from imgaug import augmenters as iaa

    ia.seed(1)

    image = ia.quokka(size=(256, 256))
    keypoints = ia.KeypointsOnImage([
        ia.Keypoint(x=65, y=100),
        ia.Keypoint(x=75, y=200),
        ia.Keypoint(x=100, y=100),
        ia.Keypoint(x=200, y=80)
    ], shape=image.shape)

    seq = iaa.Sequential([
        iaa.Multiply((1.2, 1.5)), # change brightness, doesn't affect keypoints
        iaa.Affine(
            rotate=10,
            scale=(0.5, 0.7)
        ) # rotate by exactly 10deg and scale to 50-70%, affects keypoints
    ])

    # Make our sequence deterministic.
    # We can now apply it to the image and then to the keypoints and it will
    # lead to the same augmentations.
    # IMPORTANT: Call this once PER BATCH, otherwise you will always get the
    # exactly same augmentations for every batch!
    seq_det = seq.to_deterministic()

    # augment keypoints and images
    image_aug = seq_det.augment_images([image])[0]
    keypoints_aug = seq_det.augment_keypoints([keypoints])[0]

    # print coordinates before/after augmentation (see below)
    for i in range(len(keypoints.keypoints)):
        before = keypoints.keypoints[i]
        after = keypoints_aug.keypoints[i]
        print("Keypoint %d: (%d, %d) -&gt; (%d, %d)" % (
            i, before.x, before.y, after.x, after.y)
        )

    # image with keypoints before/after augmentation (shown below)
    image_before = keypoints.draw_on_image(image, size=7)
    image_after = keypoints_aug.draw_on_image(image_aug, size=7)

    # ------------

    save(
        "examples_keypoints",
        "simple.jpg",
        grid([image_before, image_after], cols=2, rows=1),
        quality=90
    )

###############################
# Examples: Bounding Boxes
###############################

</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag943')" href="javascript:;">
imgaug-0.2.7/generate_documentation_images.py: 442-499
</a>
<div class="mid" id="frag943" style="display:none"><pre>
def chapter_examples_bounding_boxes_simple():
    import imgaug as ia
    from imgaug import augmenters as iaa

    ia.seed(1)

    image = ia.quokka(size=(256, 256))
    bbs = ia.BoundingBoxesOnImage([
        ia.BoundingBox(x1=65, y1=100, x2=200, y2=150),
        ia.BoundingBox(x1=150, y1=80, x2=200, y2=130)
    ], shape=image.shape)

    seq = iaa.Sequential([
        iaa.Multiply((1.2, 1.5)), # change brightness, doesn't affect BBs
        iaa.Affine(
            translate_px={"x": 40, "y": 60},
            scale=(0.5, 0.7)
        ) # translate by 40/60px on x/y axis, and scale to 50-70%, affects BBs
    ])

    # Make our sequence deterministic.
    # We can now apply it to the image and then to the BBs and it will
    # lead to the same augmentations.
    # IMPORTANT: Call this once PER BATCH, otherwise you will always get the
    # exactly same augmentations for every batch!
    seq_det = seq.to_deterministic()

    # Augment BBs and images.
    # As we only have one image and list of BBs, we use
    # [image] and [bbs] to turn both into lists (batches) for the
    # functions and then [0] to reverse that. In a real experiment, your
    # variables would likely already be lists.
    image_aug = seq_det.augment_images([image])[0]
    bbs_aug = seq_det.augment_bounding_boxes([bbs])[0]

    # print coordinates before/after augmentation (see below)
    for i in range(len(bbs.bounding_boxes)):
        before = bbs.bounding_boxes[i]
        after = bbs_aug.bounding_boxes[i]
        print("BB %d: (%d, %d, %d, %d) -&gt; (%d, %d, %d, %d)" % (
            i,
            before.x1, before.y1, before.x2, before.y2,
            after.x1, after.y1, after.x2, after.y2)
        )

    # image with BBs before/after augmentation (shown below)
    image_before = bbs.draw_on_image(image, thickness=2)
    image_after = bbs_aug.draw_on_image(image_aug, thickness=2, color=[0, 0, 255])

    # ------------

    save(
        "examples_bounding_boxes",
        "simple.jpg",
        grid([image_before, image_after], cols=2, rows=1),
        quality=75
    )

</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag944')" href="javascript:;">
imgaug-0.2.7/generate_documentation_images.py: 500-556
</a>
<div class="mid" id="frag944" style="display:none"><pre>
def chapter_examples_bounding_boxes_rotation():
    import imgaug as ia
    from imgaug import augmenters as iaa

    ia.seed(1)

    image = ia.quokka(size=(256, 256))
    bbs = ia.BoundingBoxesOnImage([
        ia.BoundingBox(x1=65, y1=100, x2=200, y2=150),
        ia.BoundingBox(x1=150, y1=80, x2=200, y2=130)
    ], shape=image.shape)

    seq = iaa.Sequential([
        iaa.Multiply((1.2, 1.5)), # change brightness, doesn't affect BBs
        iaa.Affine(
            rotate=45,
        )
    ])

    # Make our sequence deterministic.
    # We can now apply it to the image and then to the BBs and it will
    # lead to the same augmentations.
    # IMPORTANT: Call this once PER BATCH, otherwise you will always get the
    # exactly same augmentations for every batch!
    seq_det = seq.to_deterministic()

    # Augment BBs and images.
    # As we only have one image and list of BBs, we use
    # [image] and [bbs] to turn both into lists (batches) for the
    # functions and then [0] to reverse that. In a real experiment, your
    # variables would likely already be lists.
    image_aug = seq_det.augment_images([image])[0]
    bbs_aug = seq_det.augment_bounding_boxes([bbs])[0]

    # print coordinates before/after augmentation (see below)
    for i in range(len(bbs.bounding_boxes)):
        before = bbs.bounding_boxes[i]
        after = bbs_aug.bounding_boxes[i]
        print("BB %d: (%d, %d, %d, %d) -&gt; (%d, %d, %d, %d)" % (
            i,
            before.x1, before.y1, before.x2, before.y2,
            after.x1, after.y1, after.x2, after.y2)
        )

    # image with BBs before/after augmentation (shown below)
    image_before = bbs.draw_on_image(image, thickness=2)
    image_after = bbs_aug.draw_on_image(image_aug, thickness=2, color=[0, 0, 255])

    # ------------

    save(
        "examples_bounding_boxes",
        "rotation.jpg",
        grid([image_before, image_after], cols=2, rows=1),
        quality=75
    )

</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 45:</b> &nbsp; 2 fragments, nominal size 17 lines, similarity 70%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag948')" href="javascript:;">
imgaug-0.2.7/generate_documentation_images.py: 634-663
</a>
<div class="mid" id="frag948" style="display:none"><pre>

def chapter_examples_bounding_boxes_shift():
    import imgaug as ia
    from imgaug import augmenters as iaa

    ia.seed(1)

    # Define image and two bounding boxes
    image = ia.quokka(size=(256, 256))
    bbs = ia.BoundingBoxesOnImage([
        ia.BoundingBox(x1=25, x2=75, y1=25, y2=75),
        ia.BoundingBox(x1=100, x2=150, y1=25, y2=75)
    ], shape=image.shape)

    # Move both BBs 25px to the right and the second BB 25px down
    bbs_shifted = bbs.shift(left=25)
    bbs_shifted.bounding_boxes[1] = bbs_shifted.bounding_boxes[1].shift(top=25)

    # Draw images before/after moving BBs
    image = bbs.draw_on_image(image, color=[0, 255, 0], thickness=2, alpha=0.75)
    image = bbs_shifted.draw_on_image(image, color=[0, 0, 255], thickness=2, alpha=0.75)

    # ------------

    save(
        "examples_bounding_boxes",
        "shift.jpg",
        grid([image], cols=1, rows=1),
        quality=75
    )
</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag949')" href="javascript:;">
imgaug-0.2.7/generate_documentation_images.py: 664-693
</a>
<div class="mid" id="frag949" style="display:none"><pre>

def chapter_examples_bounding_boxes_projection():
    import imgaug as ia
    from imgaug import augmenters as iaa

    ia.seed(1)

    # Define image with two bounding boxes
    image = ia.quokka(size=(256, 256))
    bbs = ia.BoundingBoxesOnImage([
        ia.BoundingBox(x1=25, x2=75, y1=25, y2=75),
        ia.BoundingBox(x1=100, x2=150, y1=25, y2=75)
    ], shape=image.shape)

    # Rescale image and bounding boxes
    image_rescaled = ia.imresize_single_image(image, (512, 512))
    bbs_rescaled = bbs.on(image_rescaled)

    # Draw image before/after rescaling and with rescaled bounding boxes
    image_bbs = bbs.draw_on_image(image, thickness=2)
    image_rescaled_bbs = bbs_rescaled.draw_on_image(image_rescaled, thickness=2)

    # ------------

    save(
        "examples_bounding_boxes",
        "projection.jpg",
        grid([image_bbs, image_rescaled_bbs], cols=2, rows=1),
        quality=75
    )
</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 46:</b> &nbsp; 5 fragments, nominal size 37 lines, similarity 73%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag952')" href="javascript:;">
imgaug-0.2.7/generate_documentation_images.py: 747-824
</a>
<div class="mid" id="frag952" style="display:none"><pre>

def chapter_examples_heatmaps_simple():
    import imgaug as ia
    from imgaug import augmenters as iaa
    import imageio
    import numpy as np

    ia.seed(1)

    # Load an example image (uint8, 128x128x3).
    image = ia.quokka(size=(128, 128), extract="square")

    # Create an example depth map (float32, 128x128).
    # Here, we use a simple gradient that has low values (around 0.0) towards the left of the image
    # and high values (around 50.0) towards the right. This is obviously a very unrealistic depth
    # map, but makes the example easier.
    heatmap = np.linspace(0, 50, 128).astype(np.float32)  # 128 values from 0.0 to 50.0
    heatmap = np.tile(heatmap.reshape(1, 128), (128, 1))  # change to a horizontal gradient

    # We add a cross to the center of the depth map, so that we can more easily see the
    # effects of augmentations.
    heatmap[64-2:64+2, 16:128-16] = 0.75 * 50.0  # line from left to right
    heatmap[16:128-16, 64-2:64+2] = 1.0 * 50.0   # line from top to bottom

    # Convert our numpy array depth map to a heatmap object.
    # We have to add the shape of the underlying image, as that is necessary for some
    # augmentations.
    heatmap = ia.HeatmapsOnImage(heatmap, shape=image.shape, min_value=0.0, max_value=50.0)

    # To save some computation time, we want our models to perform downscaling and
    # hence need the ground truth depth maps to be at a resolution of 64x64 instead of
    # the 128x128 of the input image.
    # Here, we use simple average pooling to perform the downscaling.
    heatmap = heatmap.avg_pool(2)

    # Define our augmentation pipeline.
    seq = iaa.Sequential([
        iaa.Dropout([0.05, 0.2]),      # drop 5% or 20% of all pixels
        iaa.Sharpen((0.0, 1.0)),       # sharpen the image
        iaa.Affine(rotate=(-45, 45)),  # rotate by -45 to 45 degrees (affects heatmaps)
        iaa.ElasticTransformation(alpha=50, sigma=5)  # apply water effect (affects heatmaps)
    ], random_order=True)

    # Augment images and heatmaps.
    images_aug = []
    heatmaps_aug = []
    for _ in range(5):
        seq_det = seq.to_deterministic()
        images_aug.append(seq_det.augment_image(image))
        heatmaps_aug.append(seq_det.augment_heatmaps([heatmap])[0])

    # We want to generate an image of original input images and heatmaps before/after augmentation.
    # It is supposed to have five columns: (1) original image, (2) augmented image,
    # (3) augmented heatmap on top of augmented image, (4) augmented heatmap on its own in jet
    # color map, (5) augmented heatmap on its own in intensity colormap,
    # We now generate the cells of these columns.
    #
    # Note that we add a [0] after each heatmap draw command. That's because the heatmaps object
    # can contain many sub-heatmaps and hence we draw command returns a list of drawn sub-heatmaps.
    # We only used one sub-heatmap, so our lists always have one entry.
    cells = []
    for image_aug, heatmap_aug in zip(images_aug, heatmaps_aug):
        cells.append(image)                                                    # column 1
        cells.append(image_aug)                                                # column 2
        cells.append(heatmap_aug.draw_on_image(image_aug)[0])                  # column 3
        cells.append(heatmap_aug.draw(size=image_aug.shape[:2])[0])            # column 4
        cells.append(heatmap_aug.draw(size=image_aug.shape[:2], cmap=None)[0]) # column 5

    # Convert cells to grid image and save.
    grid_image = ia.draw_grid(cells, cols=5)
    #imageio.imwrite("example_heatmaps.jpg", grid_image)

    save(
        "examples_heatmaps",
        "simple.jpg",
        grid_image,
        quality=75
    )
</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag962')" href="javascript:;">
imgaug-0.2.7/generate_documentation_images.py: 1111-1176
</a>
<div class="mid" id="frag962" style="display:none"><pre>
    in the documentation."""
    chapter_examples_segmentation_maps_simple()
    # chapter_examples_segmentation_maps_bool_full()
    chapter_examples_segmentation_maps_bool_small()
    chapter_examples_segmentation_maps_array()

def chapter_examples_segmentation_maps_simple():
    import imgaug as ia
    from imgaug import augmenters as iaa
    import imageio
    import numpy as np

    ia.seed(1)

    # Load an example image (uint8, 128x128x3).
    image = ia.quokka(size=(128, 128), extract="square")

    # Create an example segmentation map (int32, 128x128).
    # Here, we just randomly place some squares on the image.
    # Class 0 is the background class.
    segmap = np.zeros((128, 128), dtype=np.int32)
    segmap[28:71, 35:85] = 1
    segmap[10:25, 30:45] = 2
    segmap[10:25, 70:85] = 3
    segmap[10:110, 5:10] = 4
    segmap[118:123, 10:110] = 5
    segmap = ia.SegmentationMapOnImage(segmap, shape=image.shape, nb_classes=1+5)

    # Define our augmentation pipeline.
    seq = iaa.Sequential([
        iaa.Dropout([0.05, 0.2]),      # drop 5% or 20% of all pixels
        iaa.Sharpen((0.0, 1.0)),       # sharpen the image
        iaa.Affine(rotate=(-45, 45)),  # rotate by -45 to 45 degrees (affects heatmaps)
        iaa.ElasticTransformation(alpha=50, sigma=5)  # apply water effect (affects heatmaps)
    ], random_order=True)

    # Augment images and heatmaps.
    images_aug = []
    segmaps_aug = []
    for _ in range(5):
        seq_det = seq.to_deterministic()
        images_aug.append(seq_det.augment_image(image))
        segmaps_aug.append(seq_det.augment_segmentation_maps([segmap])[0])

    # We want to generate an image of original input images and heatmaps before/after augmentation.
    # It is supposed to have five columns: (1) original image, (2) augmented image,
    # (3) augmented heatmap on top of augmented image, (4) augmented heatmap on its own in jet
    # color map, (5) augmented heatmap on its own in intensity colormap,
    # We now generate the cells of these columns.
    #
    # Note that we add a [0] after each heatmap draw command. That's because the heatmaps object
    # can contain many sub-heatmaps and hence we draw command returns a list of drawn sub-heatmaps.
    # We only used one sub-heatmap, so our lists always have one entry.
    cells = []
    for image_aug, segmap_aug in zip(images_aug, segmaps_aug):
        cells.append(image)                                      # column 1
        cells.append(segmap.draw_on_image(image))                # column 2
        cells.append(image_aug)                                  # column 3
        cells.append(segmap_aug.draw_on_image(image_aug))        # column 4
        cells.append(segmap_aug.draw(size=image_aug.shape[:2]))  # column 5

    # Convert cells to grid image and save.
    grid_image = ia.draw_grid(cells, cols=5)
    #imageio.imwrite("example_segmaps.jpg", grid_image)

    save(
</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag963')" href="javascript:;">
imgaug-0.2.7/generate_documentation_images.py: 1177-1237
</a>
<div class="mid" id="frag963" style="display:none"><pre>
        "examples_segmentation_maps",
        "simple.jpg",
        grid_image,
        quality=90
    )

def chapter_examples_segmentation_maps_bool_full():
    import imgaug as ia
    from imgaug import augmenters as iaa
    import imageio
    import numpy as np

    ia.seed(1)

    # Load an example image (uint8, 128x128x3).
    image = ia.quokka(size=(128, 128), extract="square")

    # Create an example mask (bool, 128x128).
    # Here, we just randomly place a square on the image.
    segmap = np.zeros((128, 128), dtype=bool)
    segmap[28:71, 35:85] = True
    segmap = ia.SegmentationMapOnImage(segmap, shape=image.shape)

    # Define our augmentation pipeline.
    seq = iaa.Sequential([
        iaa.Dropout([0.05, 0.2]),      # drop 5% or 20% of all pixels
        iaa.Sharpen((0.0, 1.0)),       # sharpen the image
        iaa.Affine(rotate=(-45, 45)),  # rotate by -45 to 45 degrees (affects heatmaps)
        iaa.ElasticTransformation(alpha=50, sigma=5)  # apply water effect (affects heatmaps)
    ], random_order=True)

    # Augment images and heatmaps.
    images_aug = []
    segmaps_aug = []
    for _ in range(5):
        seq_det = seq.to_deterministic()
        images_aug.append(seq_det.augment_image(image))
        segmaps_aug.append(seq_det.augment_segmentation_maps([segmap])[0])

    # We want to generate an image of original input images and heatmaps before/after augmentation.
    # It is supposed to have five columns: (1) original image, (2) augmented image,
    # (3) augmented heatmap on top of augmented image, (4) augmented heatmap on its own in jet
    # color map, (5) augmented heatmap on its own in intensity colormap,
    # We now generate the cells of these columns.
    #
    # Note that we add a [0] after each heatmap draw command. That's because the heatmaps object
    # can contain many sub-heatmaps and hence we draw command returns a list of drawn sub-heatmaps.
    # We only used one sub-heatmap, so our lists always have one entry.
    cells = []
    for image_aug, segmap_aug in zip(images_aug, segmaps_aug):
        cells.append(image)                                      # column 1
        cells.append(segmap.draw_on_image(image))                # column 2
        cells.append(image_aug)                                  # column 3
        cells.append(segmap_aug.draw_on_image(image_aug))        # column 4
        cells.append(segmap_aug.draw(size=image_aug.shape[:2]))  # column 5

    # Convert cells to grid image and save.
    grid_image = ia.draw_grid(cells, cols=5)
    #imageio.imwrite("example_segmaps_bool.jpg", grid_image)

    save(
</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag953')" href="javascript:;">
imgaug-0.2.7/generate_documentation_images.py: 825-886
</a>
<div class="mid" id="frag953" style="display:none"><pre>

def chapter_examples_heatmaps_multiple_full():
    import imgaug as ia
    from imgaug import augmenters as iaa
    import imageio
    import numpy as np

    ia.seed(1)

    # Load an image and generate a heatmap array with three sub-heatmaps.
    # Each sub-heatmap contains just three horizontal lines, with one of them having a higher
    # value (1.0) than the other two (0.2).
    image = ia.quokka(size=(128, 128), extract="square")
    heatmap = np.zeros((128, 128, 3), dtype=np.float32)
    for i in range(3):
        heatmap[1*30-5:1*30+5, 10:-10, i] = 1.0 if i == 0 else 0.5
        heatmap[2*30-5:2*30+5, 10:-10, i] = 1.0 if i == 1 else 0.5
        heatmap[3*30-5:3*30+5, 10:-10, i] = 1.0 if i == 2 else 0.5

    # Convert heatmap array to heatmap object.
    heatmap = ia.HeatmapsOnImage(heatmap, shape=image.shape)

    # Define our augmentation pipeline.
    seq = iaa.Sequential([
        iaa.Dropout([0.05, 0.2]),      # drop 5% or 20% of all pixels
        iaa.Sharpen((0.0, 1.0)),       # sharpen the image
        iaa.Affine(rotate=(-45, 45)),  # rotate by -45 to 45 degrees (affects heatmaps)
        iaa.ElasticTransformation(alpha=50, sigma=5)  # apply water effect (affects heatmaps)
    ], random_order=True)

    # Augment images and heatmaps.
    images_aug = []
    heatmaps_aug = []
    for _ in range(5):
        seq_det = seq.to_deterministic()
        images_aug.append(seq_det.augment_image(image))
        heatmaps_aug.append(seq_det.augment_heatmaps([heatmap])[0])

    # We want to generate an image of inputs before/after augmentation.
    # It is supposed to have five columns: (1) original image, (2) augmented image,
    # (3) augmented heatmap on top of augmented image, (4) augmented heatmap on its own in jet
    # color map, (5) augmented heatmap on its own in intensity colormap,
    # We now generate the cells of these columns.
    cells = []
    for image_aug, heatmap_aug in zip(images_aug, heatmaps_aug):
        subheatmaps_drawn = heatmap_aug.draw_on_image(image_aug)
        cells.append(image)                 # column 1
        cells.append(image_aug)             # column 2
        cells.append(subheatmaps_drawn[0])  # column 3
        cells.append(subheatmaps_drawn[1])  # column 4
        cells.append(subheatmaps_drawn[2])  # column 5

    # Convert cells to grid image and save.
    grid_image = ia.draw_grid(cells, cols=5)
    #imageio.imwrite("example_multiple_heatmaps.jpg", grid_image)

    save(
        "examples_heatmaps",
        "multiple_full.jpg",
        grid_image,
        quality=75
    )
</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag955')" href="javascript:;">
imgaug-0.2.7/generate_documentation_images.py: 917-977
</a>
<div class="mid" id="frag955" style="display:none"><pre>

def chapter_examples_heatmaps_arr_full():
    import imgaug as ia
    from imgaug import augmenters as iaa
    import imageio
    import numpy as np

    ia.seed(1)

    # Load an image and generate a heatmap array with three sub-heatmaps.
    # Each sub-heatmap contains just three horizontal lines, with one of them having a higher
    # value (1.0) than the other two (0.2).
    image = ia.quokka(size=(128, 128), extract="square")
    heatmap = np.zeros((128, 128, 1), dtype=np.float32)
    heatmap[64-4:64+4, 10:-10, 0] = 1.0

    # Convert heatmap array to heatmap object.
    heatmap = ia.HeatmapsOnImage(heatmap, shape=image.shape)

    # Define our augmentation pipeline.
    seq = iaa.Sequential([
        iaa.Dropout([0.05, 0.2]),      # drop 5% or 20% of all pixels
        iaa.Sharpen((0.0, 1.0)),       # sharpen the image
        iaa.Affine(rotate=(-45, 45)),  # rotate by -45 to 45 degrees (affects heatmaps)
        iaa.ElasticTransformation(alpha=50, sigma=5)  # apply water effect (affects heatmaps)
    ], random_order=True)

    # Augment images and heatmaps.
    images_aug = []
    heatmaps_aug = []
    for _ in range(5):
        seq_det = seq.to_deterministic()
        images_aug.append(seq_det.augment_image(image))
        heatmaps_aug.append(seq_det.augment_heatmaps([heatmap])[0])

    # We want to generate an image of inputs before/after augmentation.
    # It is supposed to have five columns: (1) original image, (2) augmented image,
    # (3) augmented heatmap on top of augmented image, (4) augmented heatmap on top of augmented
    # image with a vertical line added to the heatmap *after* augmentation.
    # We now generate the cells of these columns.
    cells = []
    for image_aug, heatmap_aug in zip(images_aug, heatmaps_aug):
        arr = heatmap_aug.get_arr()  # float32, shape (128, 128, 1)
        arr[10:-10, 64-4:64+4] = 0.5
        arr_heatmap = ia.HeatmapsOnImage(arr, shape=image_aug.shape)

        cells.append(image)                                    # column 1
        cells.append(image_aug)                                # column 2
        cells.append(heatmap_aug.draw_on_image(image_aug)[0])  # column 3
        cells.append(arr_heatmap.draw_on_image(image_aug)[0])  # column 4

    # Convert cells to grid image and save.
    grid_image = ia.draw_grid(cells, cols=4)
    #imageio.imwrite("example_heatmaps_arr.jpg", grid_image)

    save(
        "examples_heatmaps",
        "arr_full.jpg",
        grid_image,
        quality=75
    )
</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 47:</b> &nbsp; 2 fragments, nominal size 11 lines, similarity 81%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag988')" href="javascript:;">
imgaug-0.2.7/generate_documentation_images.py: 1636-1651
</a>
<div class="mid" id="frag988" style="display:none"><pre>
    ])
    run_and_save_augseq(
        "changecolorspace.jpg", aug,
        [ia.quokka(size=(128, 128)) for _ in range(8)], cols=4, rows=2
    )

def chapter_augmenters_grayscale():
    aug = iaa.Grayscale(alpha=(0.0, 1.0))
    run_and_save_augseq(
        "grayscale.jpg", aug,
        [ia.quokka(size=(128, 128)) for _ in range(8)], cols=4, rows=2
    )

    #alphas = [1/8*i for i in range(8)]
    alphas = np.linspace(0, 1.0, num=8)
    run_and_save_augseq(
</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag996')" href="javascript:;">
imgaug-0.2.7/generate_documentation_images.py: 1767-1781
</a>
<div class="mid" id="frag996" style="display:none"><pre>
    run_and_save_augseq(
        "emboss_vary_strength.jpg",
        [iaa.Emboss(alpha=1.0, strength=strength) for strength in strengths],
        [ia.quokka(size=(64, 64)) for _ in range(8)], cols=8, rows=1
    )

def chapter_augmenters_edgedetect():
    aug = iaa.EdgeDetect(alpha=(0.0, 1.0))
    run_and_save_augseq(
        "edgedetect.jpg", aug,
        [ia.quokka(size=(64, 64)) for _ in range(16)], cols=8, rows=2
    )

    #alphas = [1/8*i for i in range(8)]
    alphas = np.linspace(0, 1.0, num=8)
</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 48:</b> &nbsp; 5 fragments, nominal size 11 lines, similarity 81%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag990')" href="javascript:;">
imgaug-0.2.7/generate_documentation_images.py: 1660-1674
</a>
<div class="mid" id="frag990" style="display:none"><pre>
    run_and_save_augseq(
        "gaussianblur.jpg", aug,
        [ia.quokka(size=(128, 128)) for _ in range(16)], cols=4, rows=4,
        quality=75
    )

def chapter_augmenters_averageblur():
    aug = iaa.AverageBlur(k=(2, 11))
    run_and_save_augseq(
        "averageblur.jpg", aug,
        [ia.quokka(size=(128, 128)) for _ in range(16)], cols=4, rows=4,
        quality=75
    )

    aug = iaa.AverageBlur(k=((5, 11), (1, 3)))
</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag1002')" href="javascript:;">
imgaug-0.2.7/generate_documentation_images.py: 1870-1884
</a>
<div class="mid" id="frag1002" style="display:none"><pre>
    aug = iaa.Multiply((0.5, 1.5), per_channel=0.5)
    run_and_save_augseq(
        "multiply_per_channel.jpg", aug,
        [ia.quokka(size=(64, 64)) for _ in range(16)], cols=8, rows=2
    )

def chapter_augmenters_multiplyelementwise():
    aug = iaa.MultiplyElementwise((0.5, 1.5))
    run_and_save_augseq(
        "multiplyelementwise.jpg", aug,
        [ia.quokka(size=(512, 512)) for _ in range(1)], cols=1, rows=1,
        quality=90
    )

    aug = iaa.MultiplyElementwise((0.5, 1.5), per_channel=True)
</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag998')" href="javascript:;">
imgaug-0.2.7/generate_documentation_images.py: 1805-1819
</a>
<div class="mid" id="frag998" style="display:none"><pre>
    run_and_save_augseq(
        "directededgedetect_vary_direction.jpg",
        [iaa.DirectedEdgeDetect(alpha=1.0, direction=direction) for direction in directions],
        [ia.quokka(size=(64, 64)) for _ in range(8)], cols=8, rows=1
    )

def chapter_augmenters_add():
    aug = iaa.Add((-40, 40))
    run_and_save_augseq(
        "add.jpg", aug,
        [ia.quokka(size=(128, 128)) for _ in range(8)], cols=4, rows=2,
        quality=75
    )

    aug = iaa.Add((-40, 40), per_channel=0.5)
</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag1003')" href="javascript:;">
imgaug-0.2.7/generate_documentation_images.py: 1885-1899
</a>
<div class="mid" id="frag1003" style="display:none"><pre>
    run_and_save_augseq(
        "multiplyelementwise_per_channel.jpg", aug,
        [ia.quokka(size=(512, 512)) for _ in range(1)], cols=1, rows=1,
        quality=90
    )

def chapter_augmenters_dropout():
    aug = iaa.Dropout(p=(0, 0.2))
    run_and_save_augseq(
        "dropout.jpg", aug,
        [ia.quokka(size=(128, 128)) for _ in range(8)], cols=4, rows=2,
        quality=75
    )

    aug = iaa.Dropout(p=(0, 0.2), per_channel=0.5)
</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag999')" href="javascript:;">
imgaug-0.2.7/generate_documentation_images.py: 1820-1834
</a>
<div class="mid" id="frag999" style="display:none"><pre>
    run_and_save_augseq(
        "add_per_channel.jpg", aug,
        [ia.quokka(size=(128, 128)) for _ in range(8)], cols=4, rows=2,
        quality=75
    )

def chapter_augmenters_addelementwise():
    aug = iaa.AddElementwise((-40, 40))
    run_and_save_augseq(
        "addelementwise.jpg", aug,
        [ia.quokka(size=(512, 512)) for _ in range(1)], cols=1, rows=1,
        quality=90
    )

    aug = iaa.AddElementwise((-40, 40), per_channel=0.5)
</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 49:</b> &nbsp; 4 fragments, nominal size 16 lines, similarity 70%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag994')" href="javascript:;">
imgaug-0.2.7/generate_documentation_images.py: 1719-1743
</a>
<div class="mid" id="frag994" style="display:none"><pre>
    aug = iaa.Convolve(matrix=gen_matrix)
    run_and_save_augseq(
        "convolve_callable.jpg", aug,
        [ia.quokka(size=(128, 128)) for _ in range(8)], cols=4, rows=2
    )

def chapter_augmenters_sharpen():
    aug = iaa.Sharpen(alpha=(0.0, 1.0), lightness=(0.75, 2.0))
    run_and_save_augseq(
        "sharpen.jpg", aug,
        [ia.quokka(size=(64, 64)) for _ in range(16)], cols=8, rows=2
    )

    #alphas = [1/8*i for i in range(8)]
    alphas = np.linspace(0, 1.0, num=8)
    run_and_save_augseq(
        "sharpen_vary_alpha.jpg",
        [iaa.Sharpen(alpha=alpha, lightness=1.0) for alpha in alphas],
        [ia.quokka(size=(64, 64)) for _ in range(8)], cols=8, rows=1,
        quality=90
    )

    #lightnesses = [1/8*i for i in range(8)]
    lightnesses = np.linspace(0.75, 1.5, num=8)
    run_and_save_augseq(
</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag995')" href="javascript:;">
imgaug-0.2.7/generate_documentation_images.py: 1744-1766
</a>
<div class="mid" id="frag995" style="display:none"><pre>
        "sharpen_vary_lightness.jpg",
        [iaa.Sharpen(alpha=1.0, lightness=lightness) for lightness in lightnesses],
        [ia.quokka(size=(64, 64)) for _ in range(8)], cols=8, rows=1,
        quality=90
    )

def chapter_augmenters_emboss():
    aug = iaa.Emboss(alpha=(0.0, 1.0), strength=(0.5, 1.5))
    run_and_save_augseq(
        "emboss.jpg", aug,
        [ia.quokka(size=(64, 64)) for _ in range(16)], cols=8, rows=2
    )

    #alphas = [1/8*i for i in range(8)]
    alphas = np.linspace(0, 1.0, num=8)
    run_and_save_augseq(
        "emboss_vary_alpha.jpg",
        [iaa.Emboss(alpha=alpha, strength=1.0) for alpha in alphas],
        [ia.quokka(size=(64, 64)) for _ in range(8)], cols=8, rows=1
    )

    #strengths = [0.5+(0.5/8)*i for i in range(8)]
    strengths = np.linspace(0.5, 1.5, num=8)
</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag997')" href="javascript:;">
imgaug-0.2.7/generate_documentation_images.py: 1782-1804
</a>
<div class="mid" id="frag997" style="display:none"><pre>
    run_and_save_augseq(
        "edgedetect_vary_alpha.jpg",
        [iaa.EdgeDetect(alpha=alpha) for alpha in alphas],
        [ia.quokka(size=(64, 64)) for _ in range(8)], cols=8, rows=1
    )

def chapter_augmenters_directededgedetect():
    aug = iaa.DirectedEdgeDetect(alpha=(0.0, 1.0), direction=(0.0, 1.0))
    run_and_save_augseq(
        "directededgedetect.jpg", aug,
        [ia.quokka(size=(64, 64)) for _ in range(16)], cols=8, rows=2
    )

    #alphas = [1/8*i for i in range(8)]
    alphas = np.linspace(0, 1.0, num=8)
    run_and_save_augseq(
        "directededgedetect_vary_alpha.jpg",
        [iaa.DirectedEdgeDetect(alpha=alpha, direction=0) for alpha in alphas],
        [ia.quokka(size=(64, 64)) for _ in range(8)], cols=8, rows=1
    )

    #strength = [0.5+(0.5/8)*i for i in range(8)]
    directions = np.linspace(0.0, 1.0, num=8)
</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag1009')" href="javascript:;">
imgaug-0.2.7/generate_documentation_images.py: 2024-2051
</a>
<div class="mid" id="frag1009" style="display:none"><pre>
        "piecewiseaffine_vary_grid.jpg",
        [iaa.PiecewiseAffine(scale=0.05, nb_rows=g, nb_cols=g) for g in gridvals],
        [checkerboard(size=(128, 128)) for _ in range(8)], cols=8, rows=1,
        quality=75
    )

def chapter_augmenters_elastictransformation():
    aug = iaa.ElasticTransformation(alpha=(0, 5.0), sigma=0.25)
    run_and_save_augseq(
        "elastictransformations.jpg", aug,
        [ia.quokka(size=(128, 128)) for _ in range(8)], cols=4, rows=2,
        quality=75
    )

    alphas = np.linspace(0.0, 5.0, num=8)
    run_and_save_augseq(
        "elastictransformations_vary_alpha.jpg",
        [iaa.ElasticTransformation(alpha=alpha, sigma=0.25) for alpha in alphas],
        [ia.quokka(size=(128, 128)) for _ in range(8)], cols=8, rows=1,
        quality=75
    )

    sigmas = np.linspace(0.01, 1.0, num=8)
    run_and_save_augseq(
        "elastictransformations_vary_sigmas.jpg",
        [iaa.ElasticTransformation(alpha=2.5, sigma=sigma) for sigma in sigmas],
        [ia.quokka(size=(128, 128)) for _ in range(8)], cols=8, rows=1,
        quality=75
</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<br>
<table style="width:1000px; border:2px solid lightgrey; border-radius:8px;">
<tr><td style="background-color:white">
<p style="font-size:14pt"><b>Class 50:</b> &nbsp; 2 fragments, nominal size 17 lines, similarity 72%</p>
<table cellpadding=4 border=2>
<tr>
<td width="auto">
<a onclick="javascript:ShowHide('frag1000')" href="javascript:;">
imgaug-0.2.7/generate_documentation_images.py: 1835-1856
</a>
<div class="mid" id="frag1000" style="display:none"><pre>
    run_and_save_augseq(
        "addelementwise_per_channel.jpg", aug,
        [ia.quokka(size=(512, 512)) for _ in range(1)], cols=1, rows=1,
        quality=90
    )

def chapter_augmenters_additivegaussiannoise():
    aug = iaa.AdditiveGaussianNoise(scale=(0, 0.2*255))
    run_and_save_augseq(
        "additivegaussiannoise.jpg", aug,
        [ia.quokka(size=(128, 128)) for _ in range(8)], cols=4, rows=2,
        quality=90
    )

    aug = iaa.AdditiveGaussianNoise(scale=0.2*255)
    run_and_save_augseq(
        "additivegaussiannoise_large.jpg", aug,
        [ia.quokka(size=(512, 512)) for _ in range(1)], cols=1, rows=1,
        quality=90
    )

    aug = iaa.AdditiveGaussianNoise(scale=0.2*255, per_channel=True)
</pre></div>
</td>
<td width="auto">
<a onclick="javascript:ShowHide('frag1004')" href="javascript:;">
imgaug-0.2.7/generate_documentation_images.py: 1900-1923
</a>
<div class="mid" id="frag1004" style="display:none"><pre>
    run_and_save_augseq(
        "dropout_per_channel.jpg", aug,
        [ia.quokka(size=(128, 128)) for _ in range(8)], cols=4, rows=2,
        quality=75
    )

def chapter_augmenters_coarsedropout():
    aug = iaa.CoarseDropout(0.02, size_percent=0.5)
    run_and_save_augseq(
        "coarsedropout.jpg", aug,
        [ia.quokka(size=(128, 128)) for _ in range(8)], cols=4, rows=2,
        quality=75
    )

    aug = iaa.CoarseDropout((0.0, 0.05), size_percent=(0.02, 0.25))
    run_and_save_augseq(
        "coarsedropout_both_uniform.jpg", aug,
        [ia.quokka(size=(128, 128)) for _ in range(8)], cols=4, rows=2,
        quality=75,
        seed=2
    )

    aug = iaa.CoarseDropout(0.02, size_percent=0.15, per_channel=0.5)
    run_and_save_augseq(
</pre></div>
</td>
</tr><tr>
</tr>
</table>
</td></tr>
</table>
<script language="JavaScript">
function ShowHide(divId) { 
    if(document.getElementById(divId).style.display == 'none') {
        document.getElementById(divId).style.display='block';
    } else { 
        document.getElementById(divId).style.display = 'none';
    } 
}
</script>
</body>
</html>
