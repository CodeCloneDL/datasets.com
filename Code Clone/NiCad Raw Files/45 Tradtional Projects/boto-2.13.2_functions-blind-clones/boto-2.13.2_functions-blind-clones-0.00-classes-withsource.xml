<clones>
<systeminfo processor="nicad6" system="boto-2.13.2" granularity="functions-blind" threshold="0%" minlines="10" maxlines="2500"/>
<cloneinfo npcs="5532" npairs="147"/>
<runinfo ncompares="79527" cputime="80551"/>
<classinfo nclasses="62"/>

<class classid="1" nclones="2" nlines="10" similarity="100">
<source file="systems/boto-2.13.2/boto/elasticache/layer1.py" startline="50" endline="61" pcid="3">
    def __init__(self, **kwargs):
        region = kwargs.get('region')
        if not region:
            region = RegionInfo(self, self.DefaultRegionName,
                                self.DefaultRegionEndpoint)
        else:
            del kwargs['region']
        kwargs['host'] = region.endpoint
        AWSQueryConnection.__init__(self, **kwargs)
        self.region = region


</source>
<source file="systems/boto-2.13.2/boto/elastictranscoder/layer1.py" startline="50" endline="60" pcid="3076">
    def __init__(self, **kwargs):
        region = kwargs.get('region')
        if not region:
            region = RegionInfo(self, self.DefaultRegionName,
                                self.DefaultRegionEndpoint)
        else:
            del kwargs['region']
        kwargs['host'] = region.endpoint
        AWSAuthConnection.__init__(self, **kwargs)
        self.region = region

</source>
</class>

<class classid="2" nclones="3" nlines="12" similarity="100">
<source file="systems/boto-2.13.2/boto/elasticache/layer1.py" startline="287" endline="319" pcid="7">
    def create_cache_parameter_group(self, cache_parameter_group_name,
                                     cache_parameter_group_family,
                                     description):
        """
        The CreateCacheParameterGroup operation creates a new cache
        parameter group. A cache parameter group is a collection of
        parameters that you apply to all of the nodes in a cache
        cluster.

        :type cache_parameter_group_name: string
        :param cache_parameter_group_name: A user-specified name for the cache
            parameter group.

        :type cache_parameter_group_family: string
        :param cache_parameter_group_family: The name of the cache parameter
            group family the cache parameter group can be used with.
        Valid values are: `memcached1.4` | `redis2.6`

        :type description: string
        :param description: A user-specified description for the cache
            parameter group.

        """
        params = {
            'CacheParameterGroupName': cache_parameter_group_name,
            'CacheParameterGroupFamily': cache_parameter_group_family,
            'Description': description,
        }
        return self._make_request(
            action='CreateCacheParameterGroup',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/elasticache/layer1.py" startline="391" endline="438" pcid="10">
    def create_replication_group(self, replication_group_id,
                                 primary_cluster_id,
                                 replication_group_description):
        """
        The CreateReplicationGroup operation creates a replication
        group. A replication group is a collection of cache clusters,
        where one of the clusters is a read/write primary and the
        other clusters are read-only replicas. Writes to the primary
        are automatically propagated to the replicas.

        When you create a replication group, you must specify an
        existing cache cluster that is in the primary role. When the
        replication group has been successfully created, you can add
        one or more read replica replicas to it, up to a total of five
        read replicas.

        :type replication_group_id: string
        :param replication_group_id:
        The replication group identifier. This parameter is stored as a
            lowercase string.

        Constraints:


        + Must contain from 1 to 20 alphanumeric characters or hyphens.
        + First character must be a letter.
        + Cannot end with a hyphen or contain two consecutive hyphens.

        :type primary_cluster_id: string
        :param primary_cluster_id: The identifier of the cache cluster that
            will serve as the primary for this replication group. This cache
            cluster must already exist and have a status of available .

        :type replication_group_description: string
        :param replication_group_description: A user-specified description for
            the replication group.

        """
        params = {
            'ReplicationGroupId': replication_group_id,
            'PrimaryClusterId': primary_cluster_id,
            'ReplicationGroupDescription': replication_group_description,
        }
        return self._make_request(
            action='CreateReplicationGroup',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/elasticache/layer1.py" startline="1619" endline="1652" pcid="34">
    def revoke_cache_security_group_ingress(self, cache_security_group_name,
                                            ec2_security_group_name,
                                            ec2_security_group_owner_id):
        """
        The RevokeCacheSecurityGroupIngress operation revokes ingress
        from a cache security group. Use this operation to disallow
        access from an Amazon EC2 security group that had been
        previously authorized.

        :type cache_security_group_name: string
        :param cache_security_group_name: The name of the cache security group
            to revoke ingress from.

        :type ec2_security_group_name: string
        :param ec2_security_group_name: The name of the Amazon EC2 security
            group to revoke access from.

        :type ec2_security_group_owner_id: string
        :param ec2_security_group_owner_id: The AWS account number of the
            Amazon EC2 security group owner. Note that this is not the same
            thing as an AWS access key ID - you must provide a valid AWS
            account number for this parameter.

        """
        params = {
            'CacheSecurityGroupName': cache_security_group_name,
            'EC2SecurityGroupName': ec2_security_group_name,
            'EC2SecurityGroupOwnerId': ec2_security_group_owner_id,
        }
        return self._make_request(
            action='RevokeCacheSecurityGroupIngress',
            verb='POST',
            path='/', params=params)

</source>
</class>

<class classid="3" nclones="3" nlines="10" similarity="100">
<source file="systems/boto-2.13.2/boto/elasticache/layer1.py" startline="320" endline="353" pcid="8">
    def create_cache_security_group(self, cache_security_group_name,
                                    description):
        """
        The CreateCacheSecurityGroup operation creates a new cache
        security group. Use a cache security group to control access
        to one or more cache clusters.

        Cache security groups are only used when you are creating a
        cluster outside of an Amazon Virtual Private Cloud (VPC). If
        you are creating a cluster inside of a VPC, use a cache subnet
        group instead. For more information, see
        CreateCacheSubnetGroup .

        :type cache_security_group_name: string
        :param cache_security_group_name: A name for the cache security group.
            This value is stored as a lowercase string.
        Constraints: Must contain no more than 255 alphanumeric characters.
            Must not be the word "Default".

        Example: `mysecuritygroup`

        :type description: string
        :param description: A description for the cache security group.

        """
        params = {
            'CacheSecurityGroupName': cache_security_group_name,
            'Description': description,
        }
        return self._make_request(
            action='CreateCacheSecurityGroup',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/redshift/layer1.py" startline="637" endline="673" pcid="2997">
    def create_cluster_security_group(self, cluster_security_group_name,
                                      description):
        """
        Creates a new Amazon Redshift security group. You use security
        groups to control access to non-VPC clusters.

        For information about managing security groups, go to`Amazon
        Redshift Cluster Security Groups`_ in the Amazon Redshift
        Management Guide .

        :type cluster_security_group_name: string
        :param cluster_security_group_name: The name for the security group.
            Amazon Redshift stores the value as a lowercase string.
        Constraints:


        + Must contain no more than 255 alphanumeric characters or hyphens.
        + Must not be "Default".
        + Must be unique for all security groups that are created by your AWS
              account.


        Example: `examplesecuritygroup`

        :type description: string
        :param description: A description for the security group.

        """
        params = {
            'ClusterSecurityGroupName': cluster_security_group_name,
            'Description': description,
        }
        return self._make_request(
            action='CreateClusterSecurityGroup',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/redshift/layer1.py" startline="674" endline="712" pcid="2998">
    def create_cluster_snapshot(self, snapshot_identifier,
                                cluster_identifier):
        """
        Creates a manual snapshot of the specified cluster. The
        cluster must be in the "available" state.

        For more information about working with snapshots, go to
        `Amazon Redshift Snapshots`_ in the Amazon Redshift Management
        Guide .

        :type snapshot_identifier: string
        :param snapshot_identifier: A unique identifier for the snapshot that
            you are requesting. This identifier must be unique for all
            snapshots within the AWS account.
        Constraints:


        + Cannot be null, empty, or blank
        + Must contain from 1 to 255 alphanumeric characters or hyphens
        + First character must be a letter
        + Cannot end with a hyphen or contain two consecutive hyphens


        Example: `my-snapshot-id`

        :type cluster_identifier: string
        :param cluster_identifier: The cluster identifier for which you want a
            snapshot.

        """
        params = {
            'SnapshotIdentifier': snapshot_identifier,
            'ClusterIdentifier': cluster_identifier,
        }
        return self._make_request(
            action='CreateClusterSnapshot',
            verb='POST',
            path='/', params=params)

</source>
</class>

<class classid="4" nclones="2" nlines="13" similarity="100">
<source file="systems/boto-2.13.2/boto/elasticache/layer1.py" startline="354" endline="390" pcid="9">
    def create_cache_subnet_group(self, cache_subnet_group_name,
                                  cache_subnet_group_description, subnet_ids):
        """
        The CreateCacheSubnetGroup operation creates a new cache
        subnet group.

        Use this parameter only when you are creating a cluster in an
        Amazon Virtual Private Cloud (VPC).

        :type cache_subnet_group_name: string
        :param cache_subnet_group_name: A name for the cache subnet group. This
            value is stored as a lowercase string.
        Constraints: Must contain no more than 255 alphanumeric characters or
            hyphens.

        Example: `mysubnetgroup`

        :type cache_subnet_group_description: string
        :param cache_subnet_group_description: A description for the cache
            subnet group.

        :type subnet_ids: list
        :param subnet_ids: A list of VPC subnet IDs for the cache subnet group.

        """
        params = {
            'CacheSubnetGroupName': cache_subnet_group_name,
            'CacheSubnetGroupDescription': cache_subnet_group_description,
        }
        self.build_list_params(params,
                               subnet_ids,
                               'SubnetIds.member')
        return self._make_request(
            action='CreateCacheSubnetGroup',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/redshift/layer1.py" startline="713" endline="758" pcid="2999">
    def create_cluster_subnet_group(self, cluster_subnet_group_name,
                                    description, subnet_ids):
        """
        Creates a new Amazon Redshift subnet group. You must provide a
        list of one or more subnets in your existing Amazon Virtual
        Private Cloud (Amazon VPC) when creating Amazon Redshift
        subnet group.

        For information about subnet groups, go to`Amazon Redshift
        Cluster Subnet Groups`_ in the Amazon Redshift Management
        Guide .

        :type cluster_subnet_group_name: string
        :param cluster_subnet_group_name: The name for the subnet group. Amazon
            Redshift stores the value as a lowercase string.
        Constraints:


        + Must contain no more than 255 alphanumeric characters or hyphens.
        + Must not be "Default".
        + Must be unique for all subnet groups that are created by your AWS
              account.


        Example: `examplesubnetgroup`

        :type description: string
        :param description: A description for the subnet group.

        :type subnet_ids: list
        :param subnet_ids: An array of VPC subnet IDs. A maximum of 20 subnets
            can be modified in a single request.

        """
        params = {
            'ClusterSubnetGroupName': cluster_subnet_group_name,
            'Description': description,
        }
        self.build_list_params(params,
                               subnet_ids,
                               'SubnetIds.member')
        return self._make_request(
            action='CreateClusterSubnetGroup',
            verb='POST',
            path='/', params=params)

</source>
</class>

<class classid="5" nclones="3" nlines="14" similarity="100">
<source file="systems/boto-2.13.2/boto/elasticache/layer1.py" startline="686" endline="726" pcid="18">
    def describe_cache_parameter_groups(self,
                                        cache_parameter_group_name=None,
                                        max_records=None, marker=None):
        """
        The DescribeCacheParameterGroups operation returns a list of
        cache parameter group descriptions. If a cache parameter group
        name is specified, the list will contain only the descriptions
        for that group.

        :type cache_parameter_group_name: string
        :param cache_parameter_group_name: The name of a specific cache
            parameter group to return details for.

        :type max_records: integer
        :param max_records: The maximum number of records to include in the
            response. If more records exist than the specified `MaxRecords`
            value, a marker is included in the response so that the remaining
            results can be retrieved.
        Default: 100

        Constraints: minimum 20; maximum 100.

        :type marker: string
        :param marker: An optional marker returned from a prior request. Use
            this marker for pagination of results from this operation. If this
            parameter is specified, the response includes only records beyond
            the marker, up to the value specified by MaxRecords .

        """
        params = {}
        if cache_parameter_group_name is not None:
            params['CacheParameterGroupName'] = cache_parameter_group_name
        if max_records is not None:
            params['MaxRecords'] = max_records
        if marker is not None:
            params['Marker'] = marker
        return self._make_request(
            action='DescribeCacheParameterGroups',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/redshift/layer1.py" startline="1023" endline="1070" pcid="3007">
    def describe_cluster_security_groups(self,
                                         cluster_security_group_name=None,
                                         max_records=None, marker=None):
        """
        Returns information about Amazon Redshift security groups. If
        the name of a security group is specified, the response will
        contain only information about only that security group.

        For information about managing security groups, go to`Amazon
        Redshift Cluster Security Groups`_ in the Amazon Redshift
        Management Guide .

        :type cluster_security_group_name: string
        :param cluster_security_group_name: The name of a cluster security
            group for which you are requesting details. You can specify either
            the **Marker** parameter or a **ClusterSecurityGroupName**
            parameter, but not both.
        Example: `securitygroup1`

        :type max_records: integer
        :param max_records: The maximum number of records to be included in the
            response. If more records exist than the specified `MaxRecords`
            value, a marker is included in the response, which you can use in a
            subsequent DescribeClusterSecurityGroups request.
        Default: `100`

        Constraints: Value must be at least 20 and no more than 100.

        :type marker: string
        :param marker: An optional marker returned by a previous
            DescribeClusterSecurityGroups request to indicate the first
            security group that the current request will return. You can
            specify either the **Marker** parameter or a
            **ClusterSecurityGroupName** parameter, but not both.

        """
        params = {}
        if cluster_security_group_name is not None:
            params['ClusterSecurityGroupName'] = cluster_security_group_name
        if max_records is not None:
            params['MaxRecords'] = max_records
        if marker is not None:
            params['Marker'] = marker
        return self._make_request(
            action='DescribeClusterSecurityGroups',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/redshift/layer1.py" startline="1497" endline="1547" pcid="3015">
    def describe_reserved_node_offerings(self,
                                         reserved_node_offering_id=None,
                                         max_records=None, marker=None):
        """
        Returns a list of the available reserved node offerings by
        Amazon Redshift with their descriptions including the node
        type, the fixed and recurring costs of reserving the node and
        duration the node will be reserved for you. These descriptions
        help you determine which reserve node offering you want to
        purchase. You then use the unique offering ID in you call to
        PurchaseReservedNodeOffering to reserve one or more nodes for
        your Amazon Redshift cluster.

        For more information about managing parameter groups, go to
        `Purchasing Reserved Nodes`_ in the Amazon Redshift Management
        Guide .

        :type reserved_node_offering_id: string
        :param reserved_node_offering_id: The unique identifier for the
            offering.

        :type max_records: integer
        :param max_records: The maximum number of records to include in the
            response. If more records exist than the specified `MaxRecords`
            value, a marker is included in the response so that the remaining
            results may be retrieved.
        Default: `100`

        Constraints: minimum 20, maximum 100.

        :type marker: string
        :param marker: An optional marker returned by a previous
            DescribeReservedNodeOfferings request to indicate the first
            offering that the request will return.
        You can specify either a **Marker** parameter or a
            **ClusterIdentifier** parameter in a DescribeClusters request, but
            not both.

        """
        params = {}
        if reserved_node_offering_id is not None:
            params['ReservedNodeOfferingId'] = reserved_node_offering_id
        if max_records is not None:
            params['MaxRecords'] = max_records
        if marker is not None:
            params['Marker'] = marker
        return self._make_request(
            action='DescribeReservedNodeOfferings',
            verb='POST',
            path='/', params=params)

</source>
</class>

<class classid="6" nclones="6" nlines="13" similarity="100">
<source file="systems/boto-2.13.2/boto/elasticache/layer1.py" startline="771" endline="810" pcid="20">
    def describe_cache_security_groups(self, cache_security_group_name=None,
                                       max_records=None, marker=None):
        """
        The DescribeCacheSecurityGroups operation returns a list of
        cache security group descriptions. If a cache security group
        name is specified, the list will contain only the description
        of that group.

        :type cache_security_group_name: string
        :param cache_security_group_name: The name of the cache security group
            to return details for.

        :type max_records: integer
        :param max_records: The maximum number of records to include in the
            response. If more records exist than the specified `MaxRecords`
            value, a marker is included in the response so that the remaining
            results can be retrieved.
        Default: 100

        Constraints: minimum 20; maximum 100.

        :type marker: string
        :param marker: An optional marker returned from a prior request. Use
            this marker for pagination of results from this operation. If this
            parameter is specified, the response includes only records beyond
            the marker, up to the value specified by MaxRecords .

        """
        params = {}
        if cache_security_group_name is not None:
            params['CacheSecurityGroupName'] = cache_security_group_name
        if max_records is not None:
            params['MaxRecords'] = max_records
        if marker is not None:
            params['Marker'] = marker
        return self._make_request(
            action='DescribeCacheSecurityGroups',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/redshift/layer1.py" startline="1548" endline="1582" pcid="3016">
    def describe_reserved_nodes(self, reserved_node_id=None,
                                max_records=None, marker=None):
        """
        Returns the descriptions of the reserved nodes.

        :type reserved_node_id: string
        :param reserved_node_id: Identifier for the node reservation.

        :type max_records: integer
        :param max_records: The maximum number of records to include in the
            response. If more records exist than the specified `MaxRecords`
            value, a marker is included in the response so that the remaining
            results may be retrieved.
        Default: `100`

        Constraints: minimum 20, maximum 100.

        :type marker: string
        :param marker: An optional marker returned by a previous
            DescribeReservedNodes request to indicate the first parameter group
            that the current request will return.

        """
        params = {}
        if reserved_node_id is not None:
            params['ReservedNodeId'] = reserved_node_id
        if max_records is not None:
            params['MaxRecords'] = max_records
        if marker is not None:
            params['Marker'] = marker
        return self._make_request(
            action='DescribeReservedNodes',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/elasticache/layer1.py" startline="963" endline="1004" pcid="24">
    def describe_replication_groups(self, replication_group_id=None,
                                    max_records=None, marker=None):
        """
        The DescribeReplicationGroups operation returns information
        about a particular replication group. If no identifier is
        specified, DescribeReplicationGroups returns information about
        all replication groups.

        :type replication_group_id: string
        :param replication_group_id: The identifier for the replication group
            to be described. This parameter is not case sensitive.
        If you do not specify this parameter, information about all replication
            groups is returned.

        :type max_records: integer
        :param max_records: The maximum number of records to include in the
            response. If more records exist than the specified `MaxRecords`
            value, a marker is included in the response so that the remaining
            results can be retrieved.
        Default: 100

        Constraints: minimum 20; maximum 100.

        :type marker: string
        :param marker: An optional marker returned from a prior request. Use
            this marker for pagination of results from this operation. If this
            parameter is specified, the response includes only records beyond
            the marker, up to the value specified by MaxRecords .

        """
        params = {}
        if replication_group_id is not None:
            params['ReplicationGroupId'] = replication_group_id
        if max_records is not None:
            params['MaxRecords'] = max_records
        if marker is not None:
            params['Marker'] = marker
        return self._make_request(
            action='DescribeReplicationGroups',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/redshift/layer1.py" startline="916" endline="962" pcid="3005">
    def describe_cluster_parameter_groups(self, parameter_group_name=None,
                                          max_records=None, marker=None):
        """
        Returns a list of Amazon Redshift parameter groups, including
        parameter groups you created and the default parameter group.
        For each parameter group, the response includes the parameter
        group name, description, and parameter group family name. You
        can optionally specify a name to retrieve the description of a
        specific parameter group.

        For more information about managing parameter groups, go to
        `Amazon Redshift Parameter Groups`_ in the Amazon Redshift
        Management Guide .

        :type parameter_group_name: string
        :param parameter_group_name: The name of a specific parameter group for
            which to return details. By default, details about all parameter
            groups and the default parameter group are returned.

        :type max_records: integer
        :param max_records: The maximum number of parameter group records to
            include in the response. If more records exist than the specified
            `MaxRecords` value, the response includes a marker that you can use
            in a subsequent DescribeClusterParameterGroups request to retrieve
            the next set of records.
        Default: `100`

        Constraints: Value must be at least 20 and no more than 100.

        :type marker: string
        :param marker: An optional marker returned by a previous
            DescribeClusterParameterGroups request to indicate the first
            parameter group that the current request will return.

        """
        params = {}
        if parameter_group_name is not None:
            params['ParameterGroupName'] = parameter_group_name
        if max_records is not None:
            params['MaxRecords'] = max_records
        if marker is not None:
            params['Marker'] = marker
        return self._make_request(
            action='DescribeClusterParameterGroups',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/redshift/layer1.py" startline="1157" endline="1196" pcid="3009">
    def describe_cluster_subnet_groups(self, cluster_subnet_group_name=None,
                                       max_records=None, marker=None):
        """
        Returns one or more cluster subnet group objects, which
        contain metadata about your cluster subnet groups. By default,
        this operation returns information about all cluster subnet
        groups that are defined in you AWS account.

        :type cluster_subnet_group_name: string
        :param cluster_subnet_group_name: The name of the cluster subnet group
            for which information is requested.

        :type max_records: integer
        :param max_records: The maximum number of cluster subnet group records
            to include in the response. If more records exist than the
            specified `MaxRecords` value, the response returns a marker that
            you can use in a subsequent DescribeClusterSubnetGroups request in
            order to retrieve the next set of cluster subnet group records.
        Default: 100

        Constraints: Must be at least 20 and no more than 100.

        :type marker: string
        :param marker: An optional marker returned by a previous
            DescribeClusterSubnetGroups request to indicate the first cluster
            subnet group that the current request will return.

        """
        params = {}
        if cluster_subnet_group_name is not None:
            params['ClusterSubnetGroupName'] = cluster_subnet_group_name
        if max_records is not None:
            params['MaxRecords'] = max_records
        if marker is not None:
            params['Marker'] = marker
        return self._make_request(
            action='DescribeClusterSubnetGroups',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/elasticache/layer1.py" startline="811" endline="850" pcid="21">
    def describe_cache_subnet_groups(self, cache_subnet_group_name=None,
                                     max_records=None, marker=None):
        """
        The DescribeCacheSubnetGroups operation returns a list of
        cache subnet group descriptions. If a subnet group name is
        specified, the list will contain only the description of that
        group.

        :type cache_subnet_group_name: string
        :param cache_subnet_group_name: The name of the cache subnet group to
            return details for.

        :type max_records: integer
        :param max_records: The maximum number of records to include in the
            response. If more records exist than the specified `MaxRecords`
            value, a marker is included in the response so that the remaining
            results can be retrieved.
        Default: 100

        Constraints: minimum 20; maximum 100.

        :type marker: string
        :param marker: An optional marker returned from a prior request. Use
            this marker for pagination of results from this operation. If this
            parameter is specified, the response includes only records beyond
            the marker, up to the value specified by MaxRecords .

        """
        params = {}
        if cache_subnet_group_name is not None:
            params['CacheSubnetGroupName'] = cache_subnet_group_name
        if max_records is not None:
            params['MaxRecords'] = max_records
        if marker is not None:
            params['Marker'] = marker
        return self._make_request(
            action='DescribeCacheSubnetGroups',
            verb='POST',
            path='/', params=params)

</source>
</class>

<class classid="7" nclones="2" nlines="22" similarity="100">
<source file="systems/boto-2.13.2/boto/elasticache/layer1.py" startline="891" endline="962" pcid="23">
    def describe_events(self, source_identifier=None, source_type=None,
                        start_time=None, end_time=None, duration=None,
                        max_records=None, marker=None):
        """
        The DescribeEvents operation returns events related to cache
        clusters, cache security groups, and cache parameter groups.
        You can obtain events specific to a particular cache cluster,
        cache security group, or cache parameter group by providing
        the name as a parameter.

        By default, only the events occurring within the last hour are
        returned; however, you can retrieve up to 14 days' worth of
        events if necessary.

        :type source_identifier: string
        :param source_identifier: The identifier of the event source for which
            events will be returned. If not specified, then all sources are
            included in the response.

        :type source_type: string
        :param source_type: The event source to retrieve events for. If no
            value is specified, all events are returned.
        Valid values are: `cache-cluster` | `cache-parameter-group` | `cache-
            security-group` | `cache-subnet-group`

        :type start_time: timestamp
        :param start_time: The beginning of the time interval to retrieve
            events for, specified in ISO 8601 format.

        :type end_time: timestamp
        :param end_time: The end of the time interval for which to retrieve
            events, specified in ISO 8601 format.

        :type duration: integer
        :param duration: The number of minutes' worth of events to retrieve.

        :type max_records: integer
        :param max_records: The maximum number of records to include in the
            response. If more records exist than the specified `MaxRecords`
            value, a marker is included in the response so that the remaining
            results can be retrieved.
        Default: 100

        Constraints: minimum 20; maximum 100.

        :type marker: string
        :param marker: An optional marker returned from a prior request. Use
            this marker for pagination of results from this operation. If this
            parameter is specified, the response includes only records beyond
            the marker, up to the value specified by MaxRecords .

        """
        params = {}
        if source_identifier is not None:
            params['SourceIdentifier'] = source_identifier
        if source_type is not None:
            params['SourceType'] = source_type
        if start_time is not None:
            params['StartTime'] = start_time
        if end_time is not None:
            params['EndTime'] = end_time
        if duration is not None:
            params['Duration'] = duration
        if max_records is not None:
            params['MaxRecords'] = max_records
        if marker is not None:
            params['Marker'] = marker
        return self._make_request(
            action='DescribeEvents',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/redshift/layer1.py" startline="1337" endline="1438" pcid="3013">
    def describe_events(self, source_identifier=None, source_type=None,
                        start_time=None, end_time=None, duration=None,
                        max_records=None, marker=None):
        """
        Returns events related to clusters, security groups,
        snapshots, and parameter groups for the past 14 days. Events
        specific to a particular cluster, security group, snapshot or
        parameter group can be obtained by providing the name as a
        parameter. By default, the past hour of events are returned.

        :type source_identifier: string
        :param source_identifier:
        The identifier of the event source for which events will be returned.
            If this parameter is not specified, then all sources are included
            in the response.

        Constraints:

        If SourceIdentifier is supplied, SourceType must also be provided.


        + Specify a cluster identifier when SourceType is `cluster`.
        + Specify a cluster security group name when SourceType is `cluster-
              security-group`.
        + Specify a cluster parameter group name when SourceType is `cluster-
              parameter-group`.
        + Specify a cluster snapshot identifier when SourceType is `cluster-
              snapshot`.

        :type source_type: string
        :param source_type:
        The event source to retrieve events for. If no value is specified, all
            events are returned.

        Constraints:

        If SourceType is supplied, SourceIdentifier must also be provided.


        + Specify `cluster` when SourceIdentifier is a cluster identifier.
        + Specify `cluster-security-group` when SourceIdentifier is a cluster
              security group name.
        + Specify `cluster-parameter-group` when SourceIdentifier is a cluster
              parameter group name.
        + Specify `cluster-snapshot` when SourceIdentifier is a cluster
              snapshot identifier.

        :type start_time: timestamp
        :param start_time: The beginning of the time interval to retrieve
            events for, specified in ISO 8601 format. For more information
            about ISO 8601, go to the `ISO8601 Wikipedia page.`_
        Example: `2009-07-08T18:00Z`

        :type end_time: timestamp
        :param end_time: The end of the time interval for which to retrieve
            events, specified in ISO 8601 format. For more information about
            ISO 8601, go to the `ISO8601 Wikipedia page.`_
        Example: `2009-07-08T18:00Z`

        :type duration: integer
        :param duration: The number of minutes prior to the time of the request
            for which to retrieve events. For example, if the request is sent
            at 18:00 and you specify a duration of 60, then only events which
            have occurred after 17:00 will be returned.
        Default: `60`

        :type max_records: integer
        :param max_records: The maximum number of records to include in the
            response. If more records exist than the specified `MaxRecords`
            value, a marker is included in the response so that the remaining
            results may be retrieved.
        Default: `100`

        Constraints: Value must be at least 20 and no more than 100.

        :type marker: string
        :param marker: An optional marker returned from a previous
            **DescribeEvents** request. If this parameter is specified, the
            response includes only records beyond the marker, up to the value
            specified by `MaxRecords`.

        """
        params = {}
        if source_identifier is not None:
            params['SourceIdentifier'] = source_identifier
        if source_type is not None:
            params['SourceType'] = source_type
        if start_time is not None:
            params['StartTime'] = start_time
        if end_time is not None:
            params['EndTime'] = end_time
        if duration is not None:
            params['Duration'] = duration
        if max_records is not None:
            params['MaxRecords'] = max_records
        if marker is not None:
            params['Marker'] = marker
        return self._make_request(
            action='DescribeEvents',
            verb='POST',
            path='/', params=params)

</source>
</class>

<class classid="8" nclones="3" nlines="15" similarity="100">
<source file="systems/boto-2.13.2/boto/ec2/reservedinstance.py" startline="176" endline="192" pcid="56">
    def endElement(self, name, value, connection):
        if name == 'reservedInstancesListingId':
            self.listing_id = value
        elif name == 'reservedInstancesId':
            self.id = value
        elif name == 'createDate':
            self.create_date = value
        elif name == 'updateDate':
            self.update_date = value
        elif name == 'status':
            self.status = value
        elif name == 'statusMessage':
            self.status_message = value
        else:
            setattr(self, name, value)


</source>
<source file="systems/boto-2.13.2/boto/vpc/vpnconnection.py" startline="184" endline="199" pcid="3144">
    def endElement(self, name, value, connection):
        if name == 'vpnConnectionId':
            self.id = value
        elif name == 'state':
            self.state = value
        elif name == 'customerGatewayConfiguration':
            self.customer_gateway_configuration = value
        elif name == 'type':
            self.type = value
        elif name == 'customerGatewayId':
            self.customer_gateway_id = value
        elif name == 'vpnGatewayId':
            self.vpn_gateway_id = value
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/ec2/autoscale/instance.py" startline="45" endline="60" pcid="180">
    def endElement(self, name, value, connection):
        if name == 'InstanceId':
            self.instance_id = value
        elif name == 'HealthStatus':
            self.health_status = value
        elif name == 'LaunchConfigurationName':
            self.launch_config_name = value
        elif name == 'LifecycleState':
            self.lifecycle_state = value
        elif name == 'AvailabilityZone':
            self.availability_zone = value
        elif name == 'AutoScalingGroupName':
            self.group_name = value
        else:
            setattr(self, name, value)

</source>
</class>

<class classid="9" nclones="9" nlines="11" similarity="100">
<source file="systems/boto-2.13.2/boto/ec2/instancestatus.py" startline="69" endline="81" pcid="80">
    def endElement(self, name, value, connection):
        if name == 'code':
            self.code = value
        elif name == 'description':
            self.description = value
        elif name == 'notBefore':
            self.not_before = value
        elif name == 'notAfter':
            self.not_after = value
        else:
            setattr(self, name, value)


</source>
<source file="systems/boto-2.13.2/boto/s3/multidelete.py" startline="97" endline="108" pcid="3493">
    def endElement(self, name, value, connection):
        if name == 'Key':
            self.key = value
        elif name == 'VersionId':
            self.version_id = value
        elif name == 'Code':
            self.code = value
        elif name == 'Message':
            self.message = value
        else:
            setattr(self, name, value)
            
</source>
<source file="systems/boto-2.13.2/boto/ec2/spotdatafeedsubscription.py" startline="49" endline="60" pcid="451">
    def endElement(self, name, value, connection):
        if name == 'ownerId':
            self.owner_id = value
        elif name == 'bucket':
            self.bucket = value
        elif name == 'prefix':
            self.prefix = value
        elif name == 'state':
            self.state = value
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/ec2/tag.py" startline="74" endline="84" pcid="462">
    def endElement(self, name, value, connection):
        if name == 'resourceId':
            self.res_id = value
        elif name == 'resourceType':
            self.res_type = value
        elif name == 'key':
            self.name = value
        elif name == 'value':
            self.value = value
        else:
            setattr(self, name, value)
</source>
<source file="systems/boto-2.13.2/boto/ec2/elb/instancestate.py" startline="52" endline="62" pcid="713">
    def endElement(self, name, value, connection):
        if name == 'Description':
            self.description = value
        elif name == 'State':
            self.state = value
        elif name == 'InstanceId':
            self.instance_id = value
        elif name == 'ReasonCode':
            self.reason_code = value
        else:
            setattr(self, name, value)
</source>
<source file="systems/boto-2.13.2/boto/s3/multipart.py" startline="61" endline="73" pcid="3469">
    def endElement(self, name, value, connection):
        if name == 'Location':
            self.location = value
        elif name == 'Bucket':
            self.bucket_name = value
        elif name == 'Key':
            self.key_name = value
        elif name == 'ETag':
            self.etag = value
        else:
            setattr(self, name, value)


</source>
<source file="systems/boto-2.13.2/boto/rds/event.py" startline="38" endline="49" pcid="2237">
    def endElement(self, name, value, connection):
        if name == 'SourceIdentifier':
            self.source_identifier = value
        elif name == 'SourceType':
            self.source_type = value
        elif name == 'Message':
            self.message = value
        elif name == 'Date':
            self.date = value
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/ec2/volumestatus.py" startline="105" endline="117" pcid="250">
    def endElement(self, name, value, connection):
        if name == 'eventType':
            self.type = value
        elif name == 'eventId':
            self.id = value
        elif name == 'description':
            self.description = value
        elif name == 'code':
            self.code = value
        else:
            setattr(self, name, value)


</source>
<source file="systems/boto-2.13.2/boto/ec2/vmtype.py" startline="49" endline="59" pcid="455">
    def endElement(self, name, value, connection):
        if name == 'euca:name':
            self.name = value
        elif name == 'euca:cpu':
            self.cores = value
        elif name == 'euca:disk':
            self.disk = value
        elif name == 'euca:memory':
            self.memory = value
        else:
            setattr(self, name, value)
</source>
</class>

<class classid="10" nclones="2" nlines="11" similarity="100">
<source file="systems/boto-2.13.2/boto/ec2/instancestatus.py" startline="170" endline="182" pcid="90">
    def endElement(self, name, value, connection):
        if name == 'instanceId':
            self.id = value
        elif name == 'availabilityZone':
            self.zone = value
        elif name == 'code':
            self.state_code = int(value)
        elif name == 'name':
            self.state_name = value
        else:
            setattr(self, name, value)


</source>
<source file="systems/boto-2.13.2/boto/cloudformation/template.py" startline="33" endline="43" pcid="985">
    def endElement(self, name, value, connection):
        if name == "DefaultValue":
            self.default_value = value
        elif name == "Description":
            self.description = value
        elif name == "NoEcho":
            self.no_echo = bool(value)
        elif name == "ParameterKey":
            self.parameter_key = value
        else:
            setattr(self, name, value)
</source>
</class>

<class classid="11" nclones="2" nlines="11" similarity="100">
<source file="systems/boto-2.13.2/boto/ec2/autoscale/activity.py" startline="26" endline="37" pcid="167">
    def __init__(self, connection=None):
        self.connection = connection
        self.start_time = None
        self.end_time = None
        self.activity_id = None
        self.progress = None
        self.status_code = None
        self.cause = None
        self.description = None
        self.status_message = None
        self.group_name = None

</source>
<source file="systems/boto-2.13.2/boto/cloudformation/stack.py" startline="250" endline="261" pcid="952">
    def __init__(self, connection=None):
        self.connection = connection
        self.description = None
        self.logical_resource_id = None
        self.physical_resource_id = None
        self.resource_status = None
        self.resource_status_reason = None
        self.resource_type = None
        self.stack_id = None
        self.stack_name = None
        self.timestamp = None

</source>
</class>

<class classid="12" nclones="2" nlines="12" similarity="100">
<source file="systems/boto-2.13.2/boto/ec2/autoscale/scheduled.py" startline="27" endline="39" pcid="181">
    def __init__(self, connection=None):
        self.connection = connection
        self.name = None
        self.action_arn = None
        self.as_group = None
        self.time = None
        self.start_time = None
        self.end_time = None
        self.recurrence = None
        self.desired_capacity = None
        self.max_size = None
        self.min_size = None

</source>
<source file="systems/boto-2.13.2/boto/cloudformation/stack.py" startline="341" endline="353" pcid="960">
    def __init__(self, connection=None):
        self.connection = connection
        self.event_id = None
        self.logical_resource_id = None
        self.physical_resource_id = None
        self.resource_properties = None
        self.resource_status = None
        self.resource_status_reason = None
        self.resource_type = None
        self.stack_id = None
        self.stack_name = None
        self.timestamp = None

</source>
</class>

<class classid="13" nclones="4" nlines="13" similarity="100">
<source file="systems/boto-2.13.2/boto/ec2/volumestatus.py" startline="54" endline="68" pcid="244">
    def endElement(self, name, value, connection):
        if name == 'eventType':
            self.type = value
        elif name == 'eventId':
            self.id = value
        elif name == 'description':
            self.description = value
        elif name == 'notBefore':
            self.not_before = value
        elif name == 'notAfter':
            self.not_after = value
        else:
            setattr(self, name, value)


</source>
<source file="systems/boto-2.13.2/boto/ec2/volume.py" startline="277" endline="291" pcid="495">
    def endElement(self, name, value, connection):
        if name == 'volumeId':
            self.id = value
        elif name == 'instanceId':
            self.instance_id = value
        elif name == 'status':
            self.status = value
        elif name == 'attachTime':
            self.attach_time = value
        elif name == 'device':
            self.device = value
        else:
            setattr(self, name, value)


</source>
<source file="systems/boto-2.13.2/boto/vpc/customergateway.py" startline="41" endline="54" pcid="3128">
    def endElement(self, name, value, connection):
        if name == 'customerGatewayId':
            self.id = value
        elif name == 'ipAddress':
            self.ip_address = value
        elif name == 'type':
            self.type = value
        elif name == 'state':
            self.state = value
        elif name == 'bgpAsn':
            self.bgp_asn = value
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/route53/hostedzone.py" startline="43" endline="56" pcid="3940">
    def endElement(self, name, value, connection):
        if name == 'Id':
            self.id = value
        elif name == 'Name':
            self.name = value
        elif name == 'Owner':
            self.owner = value
        elif name == 'Version':
            self.version = value
        elif name == 'CallerReference':
            self.caller_reference = value
        else:
            setattr(self, name, value)
        
</source>
</class>

<class classid="14" nclones="2" nlines="12" similarity="100">
<source file="systems/boto-2.13.2/boto/ec2/connection.py" startline="184" endline="212" pcid="265">
    def get_all_kernels(self, kernel_ids=None, owners=None, dry_run=False):
        """
        Retrieve all the EC2 kernels available on your account.
        Constructs a filter to allow the processing to happen server side.

        :type kernel_ids: list
        :param kernel_ids: A list of strings with the image IDs wanted

        :type owners: list
        :param owners: A list of owner IDs

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: list
        :return: A list of :class:`boto.ec2.image.Image`
        """
        params = {}
        if kernel_ids:
            self.build_list_params(params, kernel_ids, 'ImageId')
        if owners:
            self.build_list_params(params, owners, 'Owner')
        filter = {'image-type': 'kernel'}
        self.build_filter_params(params, filter)
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_list('DescribeImages', params,
                             [('item', Image)], verb='POST')

</source>
<source file="systems/boto-2.13.2/boto/ec2/connection.py" startline="213" endline="241" pcid="266">
    def get_all_ramdisks(self, ramdisk_ids=None, owners=None, dry_run=False):
        """
        Retrieve all the EC2 ramdisks available on your account.
        Constructs a filter to allow the processing to happen server side.

        :type ramdisk_ids: list
        :param ramdisk_ids: A list of strings with the image IDs wanted

        :type owners: list
        :param owners: A list of owner IDs

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: list
        :return: A list of :class:`boto.ec2.image.Image`
        """
        params = {}
        if ramdisk_ids:
            self.build_list_params(params, ramdisk_ids, 'ImageId')
        if owners:
            self.build_list_params(params, owners, 'Owner')
        filter = {'image-type': 'ramdisk'}
        self.build_filter_params(params, filter)
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_list('DescribeImages', params,
                             [('item', Image)], verb='POST')

</source>
</class>

<class classid="15" nclones="2" nlines="16" similarity="100">
<source file="systems/boto-2.13.2/boto/ec2/connection.py" startline="602" endline="648" pcid="277">
    def get_all_instance_status(self, instance_ids=None,
                                max_results=None, next_token=None,
                                filters=None, dry_run=False):
        """
        Retrieve all the instances in your account scheduled for maintenance.

        :type instance_ids: list
        :param instance_ids: A list of strings of instance IDs

        :type max_results: int
        :param max_results: The maximum number of paginated instance
            items per response.

        :type next_token: str
        :param next_token: A string specifying the next paginated set
            of results to return.

        :type filters: dict
        :param filters: Optional filters that can be used to limit
            the results returned.  Filters are provided
            in the form of a dictionary consisting of
            filter names as the key and filter values
            as the value.  The set of allowable filter
            names/values is dependent on the request
            being performed.  Check the EC2 API guide
            for details.

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: list
        :return: A list of instances that have maintenance scheduled.
        """
        params = {}
        if instance_ids:
            self.build_list_params(params, instance_ids, 'InstanceId')
        if max_results:
            params['MaxResults'] = max_results
        if next_token:
            params['NextToken'] = next_token
        if filters:
            self.build_filter_params(params, filters)
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_object('DescribeInstanceStatus', params,
                               InstanceStatusSet, verb='POST')

</source>
<source file="systems/boto-2.13.2/boto/ec2/connection.py" startline="1928" endline="1974" pcid="305">

    def get_all_volume_status(self, volume_ids=None,
                              max_results=None, next_token=None,
                              filters=None, dry_run=False):
        """
        Retrieve the status of one or more volumes.

        :type volume_ids: list
        :param volume_ids: A list of strings of volume IDs

        :type max_results: int
        :param max_results: The maximum number of paginated instance
            items per response.

        :type next_token: str
        :param next_token: A string specifying the next paginated set
            of results to return.

        :type filters: dict
        :param filters: Optional filters that can be used to limit
            the results returned.  Filters are provided
            in the form of a dictionary consisting of
            filter names as the key and filter values
            as the value.  The set of allowable filter
            names/values is dependent on the request
            being performed.  Check the EC2 API guide
            for details.

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: list
        :return: A list of volume status.
        """
        params = {}
        if volume_ids:
            self.build_list_params(params, volume_ids, 'VolumeId')
        if max_results:
            params['MaxResults'] = max_results
        if next_token:
            params['NextToken'] = next_token
        if filters:
            self.build_filter_params(params, filters)
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_object('DescribeVolumeStatus', params,
                               VolumeStatusSet, verb='POST')
</source>
</class>

<class classid="16" nclones="3" nlines="10" similarity="100">
<source file="systems/boto-2.13.2/boto/ec2/connection.py" startline="1569" endline="1605" pcid="296">
    def get_all_zones(self, zones=None, filters=None, dry_run=False):
        """
        Get all Availability Zones associated with the current region.

        :type zones: list
        :param zones: Optional list of zones.  If this list is present,
                      only the Zones associated with these zone names
                      will be returned.

        :type filters: dict
        :param filters: Optional filters that can be used to limit
                        the results returned.  Filters are provided
                        in the form of a dictionary consisting of
                        filter names as the key and filter values
                        as the value.  The set of allowable filter
                        names/values is dependent on the request
                        being performed.  Check the EC2 API guide
                        for details.

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: list of :class:`boto.ec2.zone.Zone`
        :return: The requested Zone objects
        """
        params = {}
        if zones:
            self.build_list_params(params, zones, 'ZoneName')
        if filters:
            self.build_filter_params(params, filters)
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_list('DescribeAvailabilityZones', params,
                             [('item', Zone)], verb='POST')

    # Address methods

</source>
<source file="systems/boto-2.13.2/boto/ec2/connection.py" startline="1893" endline="1927" pcid="304">

    def get_all_volumes(self, volume_ids=None, filters=None, dry_run=False):
        """
        Get all Volumes associated with the current credentials.

        :type volume_ids: list
        :param volume_ids: Optional list of volume ids.  If this list
                           is present, only the volumes associated with
                           these volume ids will be returned.

        :type filters: dict
        :param filters: Optional filters that can be used to limit
                        the results returned.  Filters are provided
                        in the form of a dictionary consisting of
                        filter names as the key and filter values
                        as the value.  The set of allowable filter
                        names/values is dependent on the request
                        being performed.  Check the EC2 API guide
                        for details.

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: list of :class:`boto.ec2.volume.Volume`
        :return: The requested Volume objects
        """
        params = {}
        if volume_ids:
            self.build_list_params(params, volume_ids, 'VolumeId')
        if filters:
            self.build_filter_params(params, filters)
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_list('DescribeVolumes', params,
                             [('item', Volume)], verb='POST')
</source>
<source file="systems/boto-2.13.2/boto/ec2/connection.py" startline="2561" endline="2592" pcid="321">

    def get_all_key_pairs(self, keynames=None, filters=None, dry_run=False):
        """
        Get all key pairs associated with your account.

        :type keynames: list
        :param keynames: A list of the names of keypairs to retrieve.
            If not provided, all key pairs will be returned.

        :type filters: dict
        :param filters: Optional filters that can be used to limit the
            results returned.  Filters are provided in the form of a
            dictionary consisting of filter names as the key and
            filter values as the value.  The set of allowable filter
            names/values is dependent on the request being performed.
            Check the EC2 API guide for details.

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: list
        :return: A list of :class:`boto.ec2.keypair.KeyPair`
        """
        params = {}
        if keynames:
            self.build_list_params(params, keynames, 'KeyName')
        if filters:
            self.build_filter_params(params, filters)
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_list('DescribeKeyPairs', params,
                             [('item', KeyPair)], verb='POST')
</source>
</class>

<class classid="17" nclones="2" nlines="10" similarity="100">
<source file="systems/boto-2.13.2/boto/ec2/connection.py" startline="1788" endline="1816" pcid="301">

    def disassociate_address(self, public_ip=None, association_id=None,
                             dry_run=False):
        """
        Disassociate an Elastic IP address from a currently running instance.

        :type public_ip: string
        :param public_ip: The public IP address for EC2 elastic IPs.

        :type association_id: string
        :param association_id: The association ID for a VPC based elastic ip.

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: bool
        :return: True if successful
        """
        params = {}

        if public_ip is not None:
            params['PublicIp'] = public_ip
        elif association_id is not None:
            params['AssociationId'] = association_id

        if dry_run:
            params['DryRun'] = 'true'

        return self.get_status('DisassociateAddress', params, verb='POST')
</source>
<source file="systems/boto-2.13.2/boto/ec2/connection.py" startline="1817" endline="1855" pcid="302">

    def release_address(self, public_ip=None, allocation_id=None,
                        dry_run=False):
        """
        Free up an Elastic IP address.  Pass a public IP address to
        release an EC2 Elastic IP address and an AllocationId to
        release a VPC Elastic IP address.  You should only pass
        one value.

        This requires one of ``public_ip`` or ``allocation_id`` depending
        on if you're associating a VPC address or a plain EC2 address.

        When using an Allocation ID, make sure to pass ``None`` for ``public_ip``
        as EC2 expects a single parameter and if ``public_ip`` is passed boto
        will preference that instead of ``allocation_id``.

        :type public_ip: string
        :param public_ip: The public IP address for EC2 elastic IPs.

        :type allocation_id: string
        :param allocation_id: The Allocation ID for VPC elastic IPs.

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: bool
        :return: True if successful
        """
        params = {}

        if public_ip is not None:
            params['PublicIp'] = public_ip
        elif allocation_id is not None:
            params['AllocationId'] = allocation_id

        if dry_run:
            params['DryRun'] = 'true'

        return self.get_status('ReleaseAddress', params, verb='POST')
</source>
</class>

<class classid="18" nclones="2" nlines="22" similarity="100">
<source file="systems/boto-2.13.2/boto/ec2/connection.py" startline="2810" endline="2868" pcid="329">

    def authorize_security_group_deprecated(self, group_name,
                                            src_security_group_name=None,
                                            src_security_group_owner_id=None,
                                            ip_protocol=None,
                                            from_port=None, to_port=None,
                                            cidr_ip=None, dry_run=False):
        """
        NOTE: This method uses the old-style request parameters
              that did not allow a port to be specified when
              authorizing a group.

        :type group_name: string
        :param group_name: The name of the security group you are adding
            the rule to.

        :type src_security_group_name: string
        :param src_security_group_name: The name of the security group you are
            granting access to.

        :type src_security_group_owner_id: string
        :param src_security_group_owner_id: The ID of the owner of the security
            group you are granting access to.

        :type ip_protocol: string
        :param ip_protocol: Either tcp | udp | icmp

        :type from_port: int
        :param from_port: The beginning port number you are enabling

        :type to_port: int
        :param to_port: The ending port number you are enabling

        :type to_port: string
        :param to_port: The CIDR block you are providing access to.
            See http://goo.gl/Yj5QC

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: bool
        :return: True if successful.
        """
        params = {'GroupName':group_name}
        if src_security_group_name:
            params['SourceSecurityGroupName'] = src_security_group_name
        if src_security_group_owner_id:
            params['SourceSecurityGroupOwnerId'] = src_security_group_owner_id
        if ip_protocol:
            params['IpProtocol'] = ip_protocol
        if from_port:
            params['FromPort'] = from_port
        if to_port:
            params['ToPort'] = to_port
        if cidr_ip:
            params['CidrIp'] = cidr_ip
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_status('AuthorizeSecurityGroupIngress', params)
</source>
<source file="systems/boto-2.13.2/boto/ec2/connection.py" startline="3001" endline="3065" pcid="332">
                               params, verb='POST')

    def revoke_security_group_deprecated(self, group_name,
                                         src_security_group_name=None,
                                         src_security_group_owner_id=None,
                                         ip_protocol=None,
                                         from_port=None, to_port=None,
                                         cidr_ip=None, dry_run=False):
        """
        NOTE: This method uses the old-style request parameters
              that did not allow a port to be specified when
              authorizing a group.

        Remove an existing rule from an existing security group.
        You need to pass in either src_security_group_name and
        src_security_group_owner_id OR ip_protocol, from_port, to_port,
        and cidr_ip.  In other words, either you are revoking another
        group or you are revoking some ip-based rule.

        :type group_name: string
        :param group_name: The name of the security group you are removing
                           the rule from.

        :type src_security_group_name: string
        :param src_security_group_name: The name of the security group you are
                                        revoking access to.

        :type src_security_group_owner_id: string
        :param src_security_group_owner_id: The ID of the owner of the security
                                            group you are revoking access to.

        :type ip_protocol: string
        :param ip_protocol: Either tcp | udp | icmp

        :type from_port: int
        :param from_port: The beginning port number you are disabling

        :type to_port: int
        :param to_port: The ending port number you are disabling

        :type to_port: string
        :param to_port: The CIDR block you are revoking access to.
                        http://goo.gl/Yj5QC

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: bool
        :return: True if successful.
        """
        params = {'GroupName':group_name}
        if src_security_group_name:
            params['SourceSecurityGroupName'] = src_security_group_name
        if src_security_group_owner_id:
            params['SourceSecurityGroupOwnerId'] = src_security_group_owner_id
        if ip_protocol:
            params['IpProtocol'] = ip_protocol
        if from_port:
            params['FromPort'] = from_port
        if to_port:
            params['ToPort'] = to_port
        if cidr_ip:
            params['CidrIp'] = cidr_ip
        if dry_run:
            params['DryRun'] = 'true'
</source>
</class>

<class classid="19" nclones="2" nlines="11" similarity="100">
<source file="systems/boto-2.13.2/boto/ec2/connection.py" startline="3753" endline="3786" pcid="349">
                               BundleInstanceTask, verb='POST')

    def get_all_bundle_tasks(self, bundle_ids=None, filters=None,
                             dry_run=False):
        """
        Retrieve current bundling tasks. If no bundle id is specified, all
        tasks are retrieved.

        :type bundle_ids: list
        :param bundle_ids: A list of strings containing identifiers for
                           previously created bundling tasks.

        :type filters: dict
        :param filters: Optional filters that can be used to limit
                        the results returned.  Filters are provided
                        in the form of a dictionary consisting of
                        filter names as the key and filter values
                        as the value.  The set of allowable filter
                        names/values is dependent on the request
                        being performed.  Check the EC2 API guide
                        for details.

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        """
        params = {}
        if bundle_ids:
            self.build_list_params(params, bundle_ids, 'BundleId')
        if filters:
            self.build_filter_params(params, filters)
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_list('DescribeBundleTasks', params,
</source>
<source file="systems/boto-2.13.2/boto/ec2/connection.py" startline="3826" endline="3861" pcid="352">
    #

    def get_all_placement_groups(self, groupnames=None, filters=None,
                                 dry_run=False):
        """
        Get all placement groups associated with your account in a region.

        :type groupnames: list
        :param groupnames: A list of the names of placement groups to retrieve.
                           If not provided, all placement groups will be
                           returned.

        :type filters: dict
        :param filters: Optional filters that can be used to limit
                        the results returned.  Filters are provided
                        in the form of a dictionary consisting of
                        filter names as the key and filter values
                        as the value.  The set of allowable filter
                        names/values is dependent on the request
                        being performed.  Check the EC2 API guide
                        for details.

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: list
        :return: A list of :class:`boto.ec2.placementgroup.PlacementGroup`
        """
        params = {}
        if groupnames:
            self.build_list_params(params, groupnames, 'GroupName')
        if filters:
            self.build_filter_params(params, filters)
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_list('DescribePlacementGroups', params,
</source>
</class>

<class classid="20" nclones="2" nlines="11" similarity="100">
<source file="systems/boto-2.13.2/boto/ec2/volume.py" startline="49" endline="60" pcid="479">
    def __init__(self, connection=None):
        TaggedEC2Object.__init__(self, connection)
        self.id = None
        self.create_time = None
        self.status = None
        self.size = None
        self.snapshot_id = None
        self.attach_data = None
        self.zone = None
        self.type = None
        self.iops = None

</source>
<source file="systems/boto-2.13.2/boto/ec2/snapshot.py" startline="33" endline="44" pcid="551">
    def __init__(self, connection=None):
        TaggedEC2Object.__init__(self, connection)
        self.id = None
        self.volume_id = None
        self.status = None
        self.progress = None
        self.start_time = None
        self.owner_id = None
        self.owner_alias = None
        self.volume_size = None
        self.description = None

</source>
</class>

<class classid="21" nclones="2" nlines="10" similarity="100">
<source file="systems/boto-2.13.2/boto/ec2/address.py" startline="74" endline="89" pcid="530">
    def release(self, dry_run=False):
        """
        Free up this Elastic IP address.
        :see: :meth:`boto.ec2.connection.EC2Connection.release_address`
        """
        if self.allocation_id:
            return self.connection.release_address(
                None,
                self.allocation_id,
                dry_run=dry_run)
        else:
            return self.connection.release_address(
                self.public_ip,
                dry_run=dry_run
            )

</source>
<source file="systems/boto-2.13.2/boto/ec2/address.py" startline="103" endline="120" pcid="532">
    def disassociate(self, dry_run=False):
        """
        Disassociate this Elastic IP address from a currently running instance.
        :see: :meth:`boto.ec2.connection.EC2Connection.disassociate_address`
        """
        if self.association_id:
            return self.connection.disassociate_address(
                None,
                self.association_id,
                dry_run=dry_run
            )
        else:
            return self.connection.disassociate_address(
                self.public_ip,
                dry_run=dry_run
            )


</source>
</class>

<class classid="22" nclones="3" nlines="17" similarity="100">
<source file="systems/boto-2.13.2/boto/ec2/elb/__init__.py" startline="90" endline="113" pcid="718">
    def __init__(self, aws_access_key_id=None, aws_secret_access_key=None,
                 is_secure=True, port=None, proxy=None, proxy_port=None,
                 proxy_user=None, proxy_pass=None, debug=0,
                 https_connection_factory=None, region=None, path='/',
                 security_token=None, validate_certs=True):
        """
        Init method to create a new connection to EC2 Load Balancing Service.

        .. note:: The region argument is overridden by the region specified in
            the boto configuration file.
        """
        if not region:
            region = RegionInfo(self, self.DefaultRegionName,
                                self.DefaultRegionEndpoint)
        self.region = region
        AWSQueryConnection.__init__(self, aws_access_key_id,
                                    aws_secret_access_key,
                                    is_secure, port, proxy, proxy_port,
                                    proxy_user, proxy_pass,
                                    self.region.endpoint, debug,
                                    https_connection_factory, path,
                                    security_token,
                                    validate_certs=validate_certs)

</source>
<source file="systems/boto-2.13.2/boto/emr/connection.py" startline="51" endline="68" pcid="2007">
    def __init__(self, aws_access_key_id=None, aws_secret_access_key=None,
                 is_secure=True, port=None, proxy=None, proxy_port=None,
                 proxy_user=None, proxy_pass=None, debug=0,
                 https_connection_factory=None, region=None, path='/',
                 security_token=None, validate_certs=True):
        if not region:
            region = RegionInfo(self, self.DefaultRegionName,
                                self.DefaultRegionEndpoint)
        self.region = region
        AWSQueryConnection.__init__(self, aws_access_key_id,
                                    aws_secret_access_key,
                                    is_secure, port, proxy, proxy_port,
                                    proxy_user, proxy_pass,
                                    self.region.endpoint, debug,
                                    https_connection_factory, path,
                                    security_token,
                                    validate_certs=validate_certs)

</source>
<source file="systems/boto-2.13.2/boto/rds/__init__.py" startline="91" endline="108" pcid="2312">
    def __init__(self, aws_access_key_id=None, aws_secret_access_key=None,
                 is_secure=True, port=None, proxy=None, proxy_port=None,
                 proxy_user=None, proxy_pass=None, debug=0,
                 https_connection_factory=None, region=None, path='/',
                 security_token=None, validate_certs=True):
        if not region:
            region = RDSRegionInfo(self, self.DefaultRegionName,
                                   self.DefaultRegionEndpoint)
        self.region = region
        AWSQueryConnection.__init__(self, aws_access_key_id,
                                    aws_secret_access_key,
                                    is_secure, port, proxy, proxy_port,
                                    proxy_user, proxy_pass,
                                    self.region.endpoint, debug,
                                    https_connection_factory, path,
                                    security_token,
                                    validate_certs=validate_certs)

</source>
</class>

<class classid="23" nclones="2" nlines="17" similarity="100">
<source file="systems/boto-2.13.2/boto/beanstalk/response.py" startline="370" endline="389" pcid="782">
    def __init__(self, response):
        response = response['CreateConfigurationTemplateResponse']
        super(CreateConfigurationTemplateResponse, self).__init__(response)

        response = response['CreateConfigurationTemplateResult']
        self.application_name = str(response['ApplicationName'])
        self.date_created = datetime.fromtimestamp(response['DateCreated'])
        self.date_updated = datetime.fromtimestamp(response['DateUpdated'])
        self.deployment_status = str(response['DeploymentStatus'])
        self.description = str(response['Description'])
        self.environment_name = str(response['EnvironmentName'])
        self.option_settings = []
        if response['OptionSettings']:
            for member in response['OptionSettings']:
                option_setting = ConfigurationOptionSetting(member)
                self.option_settings.append(option_setting)
        self.solution_stack_name = str(response['SolutionStackName'])
        self.template_name = str(response['TemplateName'])


</source>
<source file="systems/boto-2.13.2/boto/beanstalk/response.py" startline="648" endline="667" pcid="805">
    def __init__(self, response):
        response = response['UpdateConfigurationTemplateResponse']
        super(UpdateConfigurationTemplateResponse, self).__init__(response)

        response = response['UpdateConfigurationTemplateResult']
        self.application_name = str(response['ApplicationName'])
        self.date_created = datetime.fromtimestamp(response['DateCreated'])
        self.date_updated = datetime.fromtimestamp(response['DateUpdated'])
        self.deployment_status = str(response['DeploymentStatus'])
        self.description = str(response['Description'])
        self.environment_name = str(response['EnvironmentName'])
        self.option_settings = []
        if response['OptionSettings']:
            for member in response['OptionSettings']:
                option_setting = ConfigurationOptionSetting(member)
                self.option_settings.append(option_setting)
        self.solution_stack_name = str(response['SolutionStackName'])
        self.template_name = str(response['TemplateName'])


</source>
</class>

<class classid="24" nclones="3" nlines="21" similarity="100">
<source file="systems/boto-2.13.2/boto/beanstalk/response.py" startline="391" endline="414" pcid="783">
    def __init__(self, response):
        response = response['CreateEnvironmentResponse']
        super(CreateEnvironmentResponse, self).__init__(response)

        response = response['CreateEnvironmentResult']
        self.application_name = str(response['ApplicationName'])
        self.cname = str(response['CNAME'])
        self.date_created = datetime.fromtimestamp(response['DateCreated'])
        self.date_updated = datetime.fromtimestamp(response['DateUpdated'])
        self.description = str(response['Description'])
        self.endpoint_url = str(response['EndpointURL'])
        self.environment_id = str(response['EnvironmentId'])
        self.environment_name = str(response['EnvironmentName'])
        self.health = str(response['Health'])
        if response['Resources']:
            self.resources = EnvironmentResourcesDescription(response['Resources'])
        else:
            self.resources = None
        self.solution_stack_name = str(response['SolutionStackName'])
        self.status = str(response['Status'])
        self.template_name = str(response['TemplateName'])
        self.version_label = str(response['VersionLabel'])


</source>
<source file="systems/boto-2.13.2/boto/beanstalk/response.py" startline="669" endline="692" pcid="806">
    def __init__(self, response):
        response = response['UpdateEnvironmentResponse']
        super(UpdateEnvironmentResponse, self).__init__(response)

        response = response['UpdateEnvironmentResult']
        self.application_name = str(response['ApplicationName'])
        self.cname = str(response['CNAME'])
        self.date_created = datetime.fromtimestamp(response['DateCreated'])
        self.date_updated = datetime.fromtimestamp(response['DateUpdated'])
        self.description = str(response['Description'])
        self.endpoint_url = str(response['EndpointURL'])
        self.environment_id = str(response['EnvironmentId'])
        self.environment_name = str(response['EnvironmentName'])
        self.health = str(response['Health'])
        if response['Resources']:
            self.resources = EnvironmentResourcesDescription(response['Resources'])
        else:
            self.resources = None
        self.solution_stack_name = str(response['SolutionStackName'])
        self.status = str(response['Status'])
        self.template_name = str(response['TemplateName'])
        self.version_label = str(response['VersionLabel'])


</source>
<source file="systems/boto-2.13.2/boto/beanstalk/response.py" startline="599" endline="622" pcid="802">
    def __init__(self, response):
        response = response['TerminateEnvironmentResponse']
        super(TerminateEnvironmentResponse, self).__init__(response)

        response = response['TerminateEnvironmentResult']
        self.application_name = str(response['ApplicationName'])
        self.cname = str(response['CNAME'])
        self.date_created = datetime.fromtimestamp(response['DateCreated'])
        self.date_updated = datetime.fromtimestamp(response['DateUpdated'])
        self.description = str(response['Description'])
        self.endpoint_url = str(response['EndpointURL'])
        self.environment_id = str(response['EnvironmentId'])
        self.environment_name = str(response['EnvironmentName'])
        self.health = str(response['Health'])
        if response['Resources']:
            self.resources = EnvironmentResourcesDescription(response['Resources'])
        else:
            self.resources = None
        self.solution_stack_name = str(response['SolutionStackName'])
        self.status = str(response['Status'])
        self.template_name = str(response['TemplateName'])
        self.version_label = str(response['VersionLabel'])


</source>
</class>

<class classid="25" nclones="2" nlines="10" similarity="100">
<source file="systems/boto-2.13.2/boto/beanstalk/response.py" startline="475" endline="487" pcid="791">
    def __init__(self, response):
        response = response['DescribeConfigurationOptionsResponse']
        super(DescribeConfigurationOptionsResponse, self).__init__(response)

        response = response['DescribeConfigurationOptionsResult']
        self.options = []
        if response['Options']:
            for member in response['Options']:
                option = ConfigurationOptionDescription(member)
                self.options.append(option)
        self.solution_stack_name = str(response['SolutionStackName'])


</source>
<source file="systems/boto-2.13.2/boto/beanstalk/response.py" startline="527" endline="539" pcid="795">
    def __init__(self, response):
        response = response['DescribeEventsResponse']
        super(DescribeEventsResponse, self).__init__(response)

        response = response['DescribeEventsResult']
        self.events = []
        if response['Events']:
            for member in response['Events']:
                event = EventDescription(member)
                self.events.append(event)
        self.next_tokent = str(response['NextToken'])


</source>
</class>

<class classid="26" nclones="2" nlines="15" similarity="100">
<source file="systems/boto-2.13.2/boto/cloudformation/connection.py" startline="152" endline="211" pcid="968">
    def create_stack(self, stack_name, template_body=None, template_url=None,
            parameters=[], notification_arns=[], disable_rollback=False,
            timeout_in_minutes=None, capabilities=None, tags=None):
        """
        Creates a CloudFormation Stack as specified by the template.

        :type stack_name: string
        :param stack_name: The name of the Stack, must be unique amoung running
                            Stacks

        :type template_body: string
        :param template_body: The template body (JSON string)

        :type template_url: string
        :param template_url: An S3 URL of a stored template JSON document. If
            both the template_body and template_url are
            specified, the template_body takes precedence

        :type parameters: list of tuples
        :param parameters: A list of (key, value) pairs for template input
            parameters.

        :type notification_arns: list of strings
        :param notification_arns: A list of SNS topics to send Stack event
            notifications to.

        :type disable_rollback: bool
        :param disable_rollback: Indicates whether or not to rollback on
            failure.

        :type timeout_in_minutes: int
        :param timeout_in_minutes: Maximum amount of time to let the Stack
            spend creating itself. If this timeout is exceeded,
            the Stack will enter the CREATE_FAILED state.

        :type capabilities: list
        :param capabilities: The list of capabilities you want to allow in
            the stack.  Currently, the only valid capability is
            'CAPABILITY_IAM'.

        :type tags: dict
        :param tags: A dictionary of (key, value) pairs of tags to
            associate with this stack.

        :rtype: string
        :return: The unique Stack ID.
        """
        params = self._build_create_or_update_params(stack_name,
            template_body, template_url, parameters, notification_arns,
            disable_rollback, timeout_in_minutes, capabilities, tags)
        response = self.make_request('CreateStack', params, '/', 'POST')
        body = response.read()
        if response.status == 200:
            body = json.loads(body)
            return body['CreateStackResponse']['CreateStackResult']['StackId']
        else:
            boto.log.error('%s %s' % (response.status, response.reason))
            boto.log.error('%s' % body)
            raise self.ResponseError(response.status, response.reason, body)

</source>
<source file="systems/boto-2.13.2/boto/cloudformation/connection.py" startline="212" endline="271" pcid="969">
    def update_stack(self, stack_name, template_body=None, template_url=None,
            parameters=[], notification_arns=[], disable_rollback=False,
            timeout_in_minutes=None, capabilities=None, tags=None):
        """
        Updates a CloudFormation Stack as specified by the template.

        :type stack_name: string
        :param stack_name: The name of the Stack, must be unique amoung running
            Stacks.

        :type template_body: string
        :param template_body: The template body (JSON string)

        :type template_url: string
        :param template_url: An S3 URL of a stored template JSON document. If
            both the template_body and template_url are
            specified, the template_body takes precedence.

        :type parameters: list of tuples
        :param parameters: A list of (key, value) pairs for template input
            parameters.

        :type notification_arns: list of strings
        :param notification_arns: A list of SNS topics to send Stack event
            notifications to.

        :type disable_rollback: bool
        :param disable_rollback: Indicates whether or not to rollback on
            failure.

        :type timeout_in_minutes: int
        :param timeout_in_minutes: Maximum amount of time to let the Stack
                            spend creating itself. If this timeout is exceeded,
                            the Stack will enter the CREATE_FAILED state

        :type capabilities: list
        :param capabilities: The list of capabilities you want to allow in
            the stack.  Currently, the only valid capability is
            'CAPABILITY_IAM'.

        :type tags: dict
        :param tags: A dictionary of (key, value) pairs of tags to
            associate with this stack.

        :rtype: string
        :return: The unique Stack ID.
        """
        params = self._build_create_or_update_params(stack_name,
            template_body, template_url, parameters, notification_arns,
            disable_rollback, timeout_in_minutes, capabilities, tags)
        response = self.make_request('UpdateStack', params, '/', 'POST')
        body = response.read()
        if response.status == 200:
            body = json.loads(body)
            return body['UpdateStackResponse']['UpdateStackResult']['StackId']
        else:
            boto.log.error('%s %s' % (response.status, response.reason))
            boto.log.error('%s' % body)
            raise self.ResponseError(response.status, response.reason, body)

</source>
</class>

<class classid="27" nclones="2" nlines="10" similarity="100">
<source file="systems/boto-2.13.2/boto/cloudformation/connection.py" startline="272" endline="283" pcid="970">
    def delete_stack(self, stack_name_or_id):
        params = {'ContentType': "JSON", 'StackName': stack_name_or_id}
        # TODO: change this to get_status ?
        response = self.make_request('DeleteStack', params, '/', 'GET')
        body = response.read()
        if response.status == 200:
            return json.loads(body)
        else:
            boto.log.error('%s %s' % (response.status, response.reason))
            boto.log.error('%s' % body)
            raise self.ResponseError(response.status, response.reason, body)

</source>
<source file="systems/boto-2.13.2/boto/cloudformation/connection.py" startline="325" endline="335" pcid="975">
    def get_template(self, stack_name_or_id):
        params = {'ContentType': "JSON", 'StackName': stack_name_or_id}
        response = self.make_request('GetTemplate', params, '/', 'GET')
        body = response.read()
        if response.status == 200:
            return json.loads(body)
        else:
            boto.log.error('%s %s' % (response.status, response.reason))
            boto.log.error('%s' % body)
            raise self.ResponseError(response.status, response.reason, body)

</source>
</class>

<class classid="28" nclones="2" nlines="19" similarity="100">
<source file="systems/boto-2.13.2/boto/connection.py" startline="1052" endline="1071" pcid="1224">
        :type names: tuple of strings
        :param names: The names associated with each tuple element.

        """
        for i, item in enumerate(items, 1):
            current_prefix = '%s.%s' % (label, i)
            for key, value in zip(names, item):
                full_key = '%s.%s' % (current_prefix, key)
                params[full_key] = value

    # generics

    def get_list(self, action, params, markers, path='/',
                 parent=None, verb='GET'):
        if not parent:
            parent = self
        response = self.make_request(action, params, path, verb)
        body = response.read()
        boto.log.debug(body)
        if not body:
</source>
<source file="systems/boto-2.13.2/boto/connection.py" startline="1072" endline="1091" pcid="1225">
            boto.log.error('Null body %s' % body)
            raise self.ResponseError(response.status, response.reason, body)
        elif response.status == 200:
            rs = ResultSet(markers)
            h = boto.handler.XmlHandler(rs, parent)
            xml.sax.parseString(body, h)
            return rs
        else:
            boto.log.error('%s %s' % (response.status, response.reason))
            boto.log.error('%s' % body)
            raise self.ResponseError(response.status, response.reason, body)

    def get_object(self, action, params, cls, path='/',
                   parent=None, verb='GET'):
        if not parent:
            parent = self
        response = self.make_request(action, params, path, verb)
        body = response.read()
        boto.log.debug(body)
        if not body:
</source>
</class>

<class classid="29" nclones="3" nlines="23" similarity="100">
<source file="systems/boto-2.13.2/boto/support/layer1.py" startline="506" endline="529" pcid="1776">
    def make_request(self, action, body):
        headers = {
            'X-Amz-Target': '%s.%s' % (self.TargetPrefix, action),
            'Host': self.region.endpoint,
            'Content-Type': 'application/x-amz-json-1.1',
            'Content-Length': str(len(body)),
        }
        http_request = self.build_base_http_request(
            method='POST', path='/', auth_path='/', params={},
            headers=headers, data=body)
        response = self._mexe(http_request, sender=None,
                              override_num_retries=10)
        response_body = response.read()
        boto.log.debug(response_body)
        if response.status == 200:
            if response_body:
                return json.loads(response_body)
        else:
            json_body = json.loads(response_body)
            fault_name = json_body.get('__type', None)
            exception_class = self._faults.get(fault_name, self.ResponseError)
            raise exception_class(response.status, response.reason,
                                  body=json_body)

</source>
<source file="systems/boto-2.13.2/boto/opsworks/layer1.py" startline="1937" endline="1960" pcid="3073">
    def make_request(self, action, body):
        headers = {
            'X-Amz-Target': '%s.%s' % (self.TargetPrefix, action),
            'Host': self.region.endpoint,
            'Content-Type': 'application/x-amz-json-1.1',
            'Content-Length': str(len(body)),
        }
        http_request = self.build_base_http_request(
            method='POST', path='/', auth_path='/', params={},
            headers=headers, data=body)
        response = self._mexe(http_request, sender=None,
                              override_num_retries=10)
        response_body = response.read()
        boto.log.debug(response_body)
        if response.status == 200:
            if response_body:
                return json.loads(response_body)
        else:
            json_body = json.loads(response_body)
            fault_name = json_body.get('__type', None)
            exception_class = self._faults.get(fault_name, self.ResponseError)
            raise exception_class(response.status, response.reason,
                                  body=json_body)

</source>
<source file="systems/boto-2.13.2/boto/datapipeline/layer1.py" startline="618" endline="641" pcid="2987">
    def make_request(self, action, body):
        headers = {
            'X-Amz-Target': '%s.%s' % (self.TargetPrefix, action),
            'Host': self.region.endpoint,
            'Content-Type': 'application/x-amz-json-1.1',
            'Content-Length': str(len(body)),
        }
        http_request = self.build_base_http_request(
            method='POST', path='/', auth_path='/', params={},
            headers=headers, data=body)
        response = self._mexe(http_request, sender=None,
                              override_num_retries=10)
        response_body = response.read()
        boto.log.debug(response_body)
        if response.status == 200:
            if response_body:
                return json.loads(response_body)
        else:
            json_body = json.loads(response_body)
            fault_name = json_body.get('__type', None)
            exception_class = self._faults.get(fault_name, self.ResponseError)
            raise exception_class(response.status, response.reason,
                                  body=json_body)

</source>
</class>

<class classid="30" nclones="2" nlines="14" similarity="100">
<source file="systems/boto-2.13.2/boto/dynamodb2/layer1.py" startline="370" endline="474" pcid="1858">
    def delete_item(self, table_name, key, expected=None, return_values=None,
                    return_consumed_capacity=None,
                    return_item_collection_metrics=None):
        """
        Deletes a single item in a table by primary key. You can
        perform a conditional delete operation that deletes the item
        if it exists, or if it has an expected attribute value.

        In addition to deleting an item, you can also return the
        item's attribute values in the same operation, using the
        ReturnValues parameter.

        Unless you specify conditions, the DeleteItem is an idempotent
        operation; running it multiple times on the same item or
        attribute does not result in an error response.

        Conditional deletes are useful for only deleting items if
        specific conditions are met. If those conditions are met,
        Amazon DynamoDB performs the delete. Otherwise, the item is
        not deleted.

        :type table_name: string
        :param table_name: The name of the table from which to delete the item.

        :type key: map
        :param key: A map of attribute names to AttributeValue objects,
            representing the primary key of the item to delete.

        :type expected: map
        :param expected: A map of attribute/condition pairs. This is the
            conditional block for the DeleteItem operation. All the conditions
            must be met for the operation to succeed.
        Expected allows you to provide an attribute name, and whether or not
            Amazon DynamoDB should check to see if the attribute value already
            exists; or if the attribute value exists and has a particular value
            before changing it.

        Each item in Expected represents an attribute name for Amazon DynamoDB
            to check, along with the following:


        + Value - The attribute value for Amazon DynamoDB to check.
        + Exists - Causes Amazon DynamoDB to evaluate the value before
              attempting a conditional operation:

            + If Exists is `True`, Amazon DynamoDB will check to see if that
                  attribute value already exists in the table. If it is found, then
                  the operation succeeds. If it is not found, the operation fails
                  with a ConditionalCheckFailedException .
            + If Exists is `False`, Amazon DynamoDB assumes that the attribute
                  value does not exist in the table. If in fact the value does not
                  exist, then the assumption is valid and the operation succeeds. If
                  the value is found, despite the assumption that it does not exist,
                  the operation fails with a ConditionalCheckFailedException .
          The default setting for Exists is `True`. If you supply a Value all by
              itself, Amazon DynamoDB assumes the attribute exists: You don't
              have to set Exists to `True`, because it is implied. Amazon
              DynamoDB returns a ValidationException if:

            + Exists is `True` but there is no Value to check. (You expect a value
                  to exist, but don't specify what that value is.)
            + Exists is `False` but you also specify a Value . (You cannot expect
                  an attribute to have a value, while also expecting it not to
                  exist.)



        If you specify more than one condition for Exists , then all of the
            conditions must evaluate to true. (In other words, the conditions
            are ANDed together.) Otherwise, the conditional operation will
            fail.

        :type return_values: string
        :param return_values:
        Use ReturnValues if you want to get the item attributes as they
            appeared before they were deleted. For DeleteItem , the valid
            values are:


        + `NONE` - If ReturnValues is not specified, or if its value is `NONE`,
              then nothing is returned. (This is the default for ReturnValues .)
        + `ALL_OLD` - The content of the old item is returned.

        :type return_consumed_capacity: string
        :param return_consumed_capacity:

        :type return_item_collection_metrics: string
        :param return_item_collection_metrics: If set to `SIZE`, statistics
            about item collections, if any, that were modified during the
            operation are returned in the response. If set to `NONE` (the
            default), no statistics are returned..

        """
        params = {'TableName': table_name, 'Key': key, }
        if expected is not None:
            params['Expected'] = expected
        if return_values is not None:
            params['ReturnValues'] = return_values
        if return_consumed_capacity is not None:
            params['ReturnConsumedCapacity'] = return_consumed_capacity
        if return_item_collection_metrics is not None:
            params['ReturnItemCollectionMetrics'] = return_item_collection_metrics
        return self.make_request(action='DeleteItem',
                                 body=json.dumps(params))

</source>
<source file="systems/boto-2.13.2/boto/dynamodb2/layer1.py" startline="603" endline="729" pcid="1863">
    def put_item(self, table_name, item, expected=None, return_values=None,
                 return_consumed_capacity=None,
                 return_item_collection_metrics=None):
        """
        Creates a new item, or replaces an old item with a new item.
        If an item already exists in the specified table with the same
        primary key, the new item completely replaces the existing
        item. You can perform a conditional put (insert a new item if
        one with the specified primary key doesn't exist), or replace
        an existing item if it has certain attribute values.

        In addition to putting an item, you can also return the item's
        attribute values in the same operation, using the ReturnValues
        parameter.

        When you add an item, the primary key attribute(s) are the
        only required attributes. Attribute values cannot be null.
        String and binary type attributes must have lengths greater
        than zero. Set type attributes cannot be empty. Requests with
        empty values will be rejected with a ValidationException .

        You can request that PutItem return either a copy of the old
        item (before the update) or a copy of the new item (after the
        update). For more information, see the ReturnValues
        description.

        To prevent a new item from replacing an existing item, use a
        conditional put operation with Exists set to `False` for the
        primary key attribute, or attributes.

        For more information about using this API, see `Working with
        Items`_ in the Amazon DynamoDB Developer Guide .

        :type table_name: string
        :param table_name: The name of the table to contain the item.

        :type item: map
        :param item: A map of attribute name/value pairs, one for each
            attribute. Only the primary key attributes are required; you can
            optionally provide other attribute name-value pairs for the item.
        If you specify any attributes that are part of an index key, then the
            data types for those attributes must match those of the schema in
            the table's attribute definition.

        For more information about primary keys, see `Primary Key`_ in the
            Amazon DynamoDB Developer Guide .

        Each element in the Item map is an AttributeValue object.

        :type expected: map
        :param expected: A map of attribute/condition pairs. This is the
            conditional block for the PutItem operation. All the conditions
            must be met for the operation to succeed.
        Expected allows you to provide an attribute name, and whether or not
            Amazon DynamoDB should check to see if the attribute value already
            exists; or if the attribute value exists and has a particular value
            before changing it.

        Each item in Expected represents an attribute name for Amazon DynamoDB
            to check, along with the following:


        + Value - The attribute value for Amazon DynamoDB to check.
        + Exists - Causes Amazon DynamoDB to evaluate the value before
              attempting a conditional operation:

            + If Exists is `True`, Amazon DynamoDB will check to see if that
                  attribute value already exists in the table. If it is found, then
                  the operation succeeds. If it is not found, the operation fails
                  with a ConditionalCheckFailedException .
            + If Exists is `False`, Amazon DynamoDB assumes that the attribute
                  value does not exist in the table. If in fact the value does not
                  exist, then the assumption is valid and the operation succeeds. If
                  the value is found, despite the assumption that it does not exist,
                  the operation fails with a ConditionalCheckFailedException .
          The default setting for Exists is `True`. If you supply a Value all by
              itself, Amazon DynamoDB assumes the attribute exists: You don't
              have to set Exists to `True`, because it is implied. Amazon
              DynamoDB returns a ValidationException if:

            + Exists is `True` but there is no Value to check. (You expect a value
                  to exist, but don't specify what that value is.)
            + Exists is `False` but you also specify a Value . (You cannot expect
                  an attribute to have a value, while also expecting it not to
                  exist.)



        If you specify more than one condition for Exists , then all of the
            conditions must evaluate to true. (In other words, the conditions
            are ANDed together.) Otherwise, the conditional operation will
            fail.

        :type return_values: string
        :param return_values:
        Use ReturnValues if you want to get the item attributes as they
            appeared before they were updated with the PutItem request. For
            PutItem , the valid values are:


        + `NONE` - If ReturnValues is not specified, or if its value is `NONE`,
              then nothing is returned. (This is the default for ReturnValues .)
        + `ALL_OLD` - If PutItem overwrote an attribute name-value pair, then
              the content of the old item is returned.

        :type return_consumed_capacity: string
        :param return_consumed_capacity:

        :type return_item_collection_metrics: string
        :param return_item_collection_metrics: If set to `SIZE`, statistics
            about item collections, if any, that were modified during the
            operation are returned in the response. If set to `NONE` (the
            default), no statistics are returned..

        """
        params = {'TableName': table_name, 'Item': item, }
        if expected is not None:
            params['Expected'] = expected
        if return_values is not None:
            params['ReturnValues'] = return_values
        if return_consumed_capacity is not None:
            params['ReturnConsumedCapacity'] = return_consumed_capacity
        if return_item_collection_metrics is not None:
            params['ReturnItemCollectionMetrics'] = return_item_collection_metrics
        return self.make_request(action='PutItem',
                                 body=json.dumps(params))

</source>
</class>

<class classid="31" nclones="2" nlines="11" similarity="100">
<source file="systems/boto-2.13.2/boto/dynamodb2/layer1.py" startline="527" endline="571" pcid="1861">
    def get_item(self, table_name, key, attributes_to_get=None,
                 consistent_read=None, return_consumed_capacity=None):
        """
        The GetItem operation returns a set of attributes for the item
        with the given primary key. If there is no matching item,
        GetItem does not return any data.

        GetItem provides an eventually consistent read by default. If
        your application requires a strongly consistent read, set
        ConsistentRead to `True`. Although a strongly consistent read
        might take more time than an eventually consistent read, it
        always returns the last updated value.

        :type table_name: string
        :param table_name: The name of the table containing the requested item.

        :type key: map
        :param key: A map of attribute names to AttributeValue objects,
            representing the primary key of the item to retrieve.

        :type attributes_to_get: list
        :param attributes_to_get: The names of one or more attributes to
            retrieve. If no attribute names are specified, then all attributes
            will be returned. If any of the requested attributes are not found,
            they will not appear in the result.

        :type consistent_read: boolean
        :param consistent_read: If set to `True`, then the operation uses
            strongly consistent reads; otherwise, eventually consistent reads
            are used.

        :type return_consumed_capacity: string
        :param return_consumed_capacity:

        """
        params = {'TableName': table_name, 'Key': key, }
        if attributes_to_get is not None:
            params['AttributesToGet'] = attributes_to_get
        if consistent_read is not None:
            params['ConsistentRead'] = consistent_read
        if return_consumed_capacity is not None:
            params['ReturnConsumedCapacity'] = return_consumed_capacity
        return self.make_request(action='GetItem',
                                 body=json.dumps(params))

</source>
<source file="systems/boto-2.13.2/boto/datapipeline/layer1.py" startline="546" endline="596" pcid="2985">
    def set_task_status(self, task_id, task_status, error_id=None,
                        error_message=None, error_stack_trace=None):
        """
        Notifies AWS Data Pipeline that a task is completed and
        provides information about the final status. The task runner
        calls this action regardless of whether the task was
        sucessful. The task runner does not need to call SetTaskStatus
        for tasks that are canceled by the web service during a call
        to ReportTaskProgress.

        :type task_id: string
        :param task_id: Identifies the task assigned to the task runner. This
            value is set in the TaskObject that is returned by the PollForTask
            action.

        :type task_status: string
        :param task_status: If `FINISHED`, the task successfully completed. If
            `FAILED` the task ended unsuccessfully. The `FALSE` value is used
            by preconditions.

        :type error_id: string
        :param error_id: If an error occurred during the task, this value
            specifies an id value that represents the error. This value is set
            on the physical attempt object. It is used to display error
            information to the user. It should not start with string "Service_"
            which is reserved by the system.

        :type error_message: string
        :param error_message: If an error occurred during the task, this value
            specifies a text description of the error. This value is set on the
            physical attempt object. It is used to display error information to
            the user. The web service does not parse this value.

        :type error_stack_trace: string
        :param error_stack_trace: If an error occurred during the task, this
            value specifies the stack trace associated with the error. This
            value is set on the physical attempt object. It is used to display
            error information to the user. The web service does not parse this
            value.

        """
        params = {'taskId': task_id, 'taskStatus': task_status, }
        if error_id is not None:
            params['errorId'] = error_id
        if error_message is not None:
            params['errorMessage'] = error_message
        if error_stack_trace is not None:
            params['errorStackTrace'] = error_stack_trace
        return self.make_request(action='SetTaskStatus',
                                 body=json.dumps(params))

</source>
</class>

<class classid="32" nclones="3" nlines="11" similarity="100">
<source file="systems/boto-2.13.2/boto/rds/__init__.py" startline="114" endline="146" pcid="2314">
    def get_all_dbinstances(self, instance_id=None, max_records=None,
                            marker=None):
        """
        Retrieve all the DBInstances in your account.

        :type instance_id: str
        :param instance_id: DB Instance identifier.  If supplied, only
                            information this instance will be returned.
                            Otherwise, info about all DB Instances will
                            be returned.

        :type max_records: int
        :param max_records: The maximum number of records to be returned.
                            If more results are available, a MoreToken will
                            be returned in the response that can be used to
                            retrieve additional records.  Default is 100.

        :type marker: str
        :param marker: The marker provided by a previous request.

        :rtype: list
        :return: A list of :class:`boto.rds.dbinstance.DBInstance`
        """
        params = {}
        if instance_id:
            params['DBInstanceIdentifier'] = instance_id
        if max_records:
            params['MaxRecords'] = max_records
        if marker:
            params['Marker'] = marker
        return self.get_list('DescribeDBInstances', params,
                             [('DBInstance', DBInstance)])

</source>
<source file="systems/boto-2.13.2/boto/rds/__init__.py" startline="842" endline="873" pcid="2326">
    def get_all_dbsecurity_groups(self, groupname=None, max_records=None,
                                  marker=None):
        """
        Get all security groups associated with your account in a region.

        :type groupnames: list
        :param groupnames: A list of the names of security groups to retrieve.
                           If not provided, all security groups will
                           be returned.

        :type max_records: int
        :param max_records: The maximum number of records to be returned.
                            If more results are available, a MoreToken will
                            be returned in the response that can be used to
                            retrieve additional records.  Default is 100.

        :type marker: str
        :param marker: The marker provided by a previous request.

        :rtype: list
        :return: A list of :class:`boto.rds.dbsecuritygroup.DBSecurityGroup`
        """
        params = {}
        if groupname:
            params['DBSecurityGroupName'] = groupname
        if max_records:
            params['MaxRecords'] = max_records
        if marker:
            params['Marker'] = marker
        return self.get_list('DescribeDBSecurityGroups', params,
                             [('DBSecurityGroup', DBSecurityGroup)])

</source>
<source file="systems/boto-2.13.2/boto/rds/__init__.py" startline="699" endline="729" pcid="2320">
    def get_all_dbparameter_groups(self, groupname=None, max_records=None,
                                  marker=None):
        """
        Get all parameter groups associated with your account in a region.

        :type groupname: str
        :param groupname: The name of the DBParameter group to retrieve.
                          If not provided, all DBParameter groups will be returned.

        :type max_records: int
        :param max_records: The maximum number of records to be returned.
                            If more results are available, a MoreToken will
                            be returned in the response that can be used to
                            retrieve additional records.  Default is 100.

        :type marker: str
        :param marker: The marker provided by a previous request.

        :rtype: list
        :return: A list of :class:`boto.ec2.parametergroup.ParameterGroup`
        """
        params = {}
        if groupname:
            params['DBParameterGroupName'] = groupname
        if max_records:
            params['MaxRecords'] = max_records
        if marker:
            params['Marker'] = marker
        return self.get_list('DescribeDBParameterGroups', params,
                             [('DBParameterGroup', ParameterGroup)])

</source>
</class>

<class classid="33" nclones="2" nlines="11" similarity="100">
<source file="systems/boto-2.13.2/boto/cloudsearch/layer1.py" startline="418" endline="447" pcid="2443">
    def describe_index_fields(self, domain_name, field_names=None):
        """
        Describes index fields in the search domain, optionally
        limited to a single ``IndexField``.

        :type domain_name: string
        :param domain_name: A string that represents the name of a
            domain. Domain names must be unique across the domains
            owned by an account within an AWS region. Domain names
            must start with a letter or number and can contain the
            following characters: a-z (lowercase), 0-9, and -
            (hyphen). Uppercase letters and underscores are not
            allowed.

        :type field_names: list
        :param field_names: Limits the response to the specified fields.

        :raises: BaseException, InternalException, ResourceNotFoundException
        """
        doc_path = ('describe_index_fields_response',
                    'describe_index_fields_result',
                    'index_fields')
        params = {'DomainName': domain_name}
        if field_names:
            for i, field_name in enumerate(field_names, 1):
                params['FieldNames.member.%d' % i] = field_name
        return self.get_response(doc_path, 'DescribeIndexFields',
                                 params, verb='POST',
                                 list_marker='IndexFields')

</source>
<source file="systems/boto-2.13.2/boto/cloudsearch/layer1.py" startline="448" endline="477" pcid="2444">
    def describe_rank_expressions(self, domain_name, rank_names=None):
        """
        Describes RankExpressions in the search domain, optionally
        limited to a single expression.

        :type domain_name: string
        :param domain_name: A string that represents the name of a
            domain. Domain names must be unique across the domains
            owned by an account within an AWS region. Domain names
            must start with a letter or number and can contain the
            following characters: a-z (lowercase), 0-9, and -
            (hyphen). Uppercase letters and underscores are not
            allowed.

        :type rank_names: list
        :param rank_names: Limit response to the specified rank names.

        :raises: BaseException, InternalException, ResourceNotFoundException
        """
        doc_path = ('describe_rank_expressions_response',
                    'describe_rank_expressions_result',
                    'rank_expressions')
        params = {'DomainName': domain_name}
        if rank_names:
            for i, rank_name in enumerate(rank_names, 1):
                params['RankNames.member.%d' % i] = rank_name
        return self.get_response(doc_path, 'DescribeRankExpressions',
                                 params, verb='POST',
                                 list_marker='RankExpressions')

</source>
</class>

<class classid="34" nclones="2" nlines="11" similarity="100">
<source file="systems/boto-2.13.2/boto/jsonresponse.py" startline="72" endline="83" pcid="2961">
    def __getattr__(self, key):
        if key in self:
            return self[key]
        for k in self:
            e = self[k]
            if isinstance(e, Element):
                try:
                    return getattr(e, key)
                except AttributeError:
                    pass
        raise AttributeError

</source>
<source file="systems/boto-2.13.2/boto/core/dictresponse.py" startline="86" endline="97" pcid="3612">
    def __getattr__(self, key):
        if key in self:
            return self[key]
        for k in self:
            e = self[k]
            if isinstance(e, Element):
                try:
                    return getattr(e, key)
                except AttributeError:
                    pass
        raise AttributeError

</source>
</class>

<class classid="35" nclones="2" nlines="17" similarity="100">
<source file="systems/boto-2.13.2/boto/jsonresponse.py" startline="89" endline="106" pcid="2963">
    def startElement(self, name, attrs, connection):
        self.stack.append(name)
        for lm in self.list_marker:
            if name.endswith(lm):
                l = ListElement(self.connection, name, self.list_marker,
                                self.item_marker, self.pythonize_name)
                self[self.get_name(name)] = l
                return l
        if len(self.stack) > 0:
            element_name = self.stack[-1]
            e = Element(self.connection, element_name, self.stack, self,
                        self.list_marker, self.item_marker,
                        self.pythonize_name)
            self[self.get_name(element_name)] = e
            return (element_name, e)
        else:
            return None

</source>
<source file="systems/boto-2.13.2/boto/core/dictresponse.py" startline="103" endline="120" pcid="3614">
    def startElement(self, name, attrs, connection):
        self.stack.append(name)
        for lm in self.list_marker:
            if name.endswith(lm):
                l = ListElement(self.connection, name, self.list_marker,
                                self.item_marker, self.pythonize_name)
                self[self.get_name(name)] = l
                return l
        if len(self.stack) > 0:
            element_name = self.stack[-1]
            e = Element(self.connection, element_name, self.stack, self,
                        self.list_marker, self.item_marker,
                        self.pythonize_name)
            self[self.get_name(element_name)] = e
            return (element_name, e)
        else:
            return None

</source>
</class>

<class classid="36" nclones="2" nlines="17" similarity="100">
<source file="systems/boto-2.13.2/boto/jsonresponse.py" startline="134" endline="151" pcid="2967">
    def startElement(self, name, attrs, connection):
        for lm in self.list_marker:
            if name.endswith(lm):
                l = ListElement(self.connection, name,
                                self.list_marker, self.item_marker,
                                self.pythonize_name)
                setattr(self, self.get_name(name), l)
                return l
        if name in self.item_marker:
            e = Element(self.connection, name, parent=self,
                        list_marker=self.list_marker,
                        item_marker=self.item_marker,
                        pythonize_name=self.pythonize_name)
            self.append(e)
            return e
        else:
            return None

</source>
<source file="systems/boto-2.13.2/boto/core/dictresponse.py" startline="149" endline="166" pcid="3618">
    def startElement(self, name, attrs, connection):
        for lm in self.list_marker:
            if name.endswith(lm):
                l = ListElement(self.connection, name,
                                self.list_marker, self.item_marker,
                                self.pythonize_name)
                setattr(self, self.get_name(name), l)
                return l
        if name in self.item_marker:
            e = Element(self.connection, name, parent=self,
                        list_marker=self.list_marker,
                        item_marker=self.item_marker,
                        pythonize_name=self.pythonize_name)
            self.append(e)
            return e
        else:
            return None

</source>
</class>

<class classid="37" nclones="2" nlines="12" similarity="100">
<source file="systems/boto-2.13.2/boto/jsonresponse.py" startline="152" endline="163" pcid="2968">
    def endElement(self, name, value, connection):
        if name == self.element_name:
            if len(self) > 0:
                empty = []
                for e in self:
                    if isinstance(e, Element):
                        if len(e) == 0:
                            empty.append(e)
                for e in empty:
                    self.remove(e)
        else:
            setattr(self, self.get_name(name), value)
</source>
<source file="systems/boto-2.13.2/boto/core/dictresponse.py" startline="167" endline="178" pcid="3619">
    def endElement(self, name, value, connection):
        if name == self.element_name:
            if len(self) > 0:
                empty = []
                for e in self:
                    if isinstance(e, Element):
                        if len(e) == 0:
                            empty.append(e)
                for e in empty:
                    self.remove(e)
        else:
            setattr(self, self.get_name(name), value)
</source>
</class>

<class classid="38" nclones="2" nlines="18" similarity="100">
<source file="systems/boto-2.13.2/boto/redshift/layer1.py" startline="148" endline="204" pcid="2992">
    def authorize_cluster_security_group_ingress(self,
                                                 cluster_security_group_name,
                                                 cidrip=None,
                                                 ec2_security_group_name=None,
                                                 ec2_security_group_owner_id=None):
        """
        Adds an inbound (ingress) rule to an Amazon Redshift security
        group. Depending on whether the application accessing your
        cluster is running on the Internet or an EC2 instance, you can
        authorize inbound access to either a Classless Interdomain
        Routing (CIDR) IP address range or an EC2 security group. You
        can add as many as 20 ingress rules to an Amazon Redshift
        security group.
        The EC2 security group must be defined in the AWS region where
        the cluster resides.
        For an overview of CIDR blocks, see the Wikipedia article on
        `Classless Inter-Domain Routing`_.

        You must also associate the security group with a cluster so
        that clients running on these IP addresses or the EC2 instance
        are authorized to connect to the cluster. For information
        about managing security groups, go to `Working with Security
        Groups`_ in the Amazon Redshift Management Guide .

        :type cluster_security_group_name: string
        :param cluster_security_group_name: The name of the security group to
            which the ingress rule is added.

        :type cidrip: string
        :param cidrip: The IP range to be added the Amazon Redshift security
            group.

        :type ec2_security_group_name: string
        :param ec2_security_group_name: The EC2 security group to be added the
            Amazon Redshift security group.

        :type ec2_security_group_owner_id: string
        :param ec2_security_group_owner_id: The AWS account number of the owner
            of the security group specified by the EC2SecurityGroupName
            parameter. The AWS Access Key ID is not an acceptable value.
        Example: `111122223333`

        """
        params = {
            'ClusterSecurityGroupName': cluster_security_group_name,
        }
        if cidrip is not None:
            params['CIDRIP'] = cidrip
        if ec2_security_group_name is not None:
            params['EC2SecurityGroupName'] = ec2_security_group_name
        if ec2_security_group_owner_id is not None:
            params['EC2SecurityGroupOwnerId'] = ec2_security_group_owner_id
        return self._make_request(
            action='AuthorizeClusterSecurityGroupIngress',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/redshift/layer1.py" startline="2089" endline="2140" pcid="3025">
    def revoke_cluster_security_group_ingress(self,
                                              cluster_security_group_name,
                                              cidrip=None,
                                              ec2_security_group_name=None,
                                              ec2_security_group_owner_id=None):
        """
        Revokes an ingress rule in an Amazon Redshift security group
        for a previously authorized IP range or Amazon EC2 security
        group. To add an ingress rule, see
        AuthorizeClusterSecurityGroupIngress. For information about
        managing security groups, go to`Amazon Redshift Cluster
        Security Groups`_ in the Amazon Redshift Management Guide .

        :type cluster_security_group_name: string
        :param cluster_security_group_name: The name of the security Group from
            which to revoke the ingress rule.

        :type cidrip: string
        :param cidrip: The IP range for which to revoke access. This range must
            be a valid Classless Inter-Domain Routing (CIDR) block of IP
            addresses. If `CIDRIP` is specified, `EC2SecurityGroupName` and
            `EC2SecurityGroupOwnerId` cannot be provided.

        :type ec2_security_group_name: string
        :param ec2_security_group_name: The name of the EC2 Security Group
            whose access is to be revoked. If `EC2SecurityGroupName` is
            specified, `EC2SecurityGroupOwnerId` must also be provided and
            `CIDRIP` cannot be provided.

        :type ec2_security_group_owner_id: string
        :param ec2_security_group_owner_id: The AWS account number of the owner
            of the security group specified in the `EC2SecurityGroupName`
            parameter. The AWS access key ID is not an acceptable value. If
            `EC2SecurityGroupOwnerId` is specified, `EC2SecurityGroupName` must
            also be provided. and `CIDRIP` cannot be provided.
        Example: `111122223333`

        """
        params = {
            'ClusterSecurityGroupName': cluster_security_group_name,
        }
        if cidrip is not None:
            params['CIDRIP'] = cidrip
        if ec2_security_group_name is not None:
            params['EC2SecurityGroupName'] = ec2_security_group_name
        if ec2_security_group_owner_id is not None:
            params['EC2SecurityGroupOwnerId'] = ec2_security_group_owner_id
        return self._make_request(
            action='RevokeClusterSecurityGroupIngress',
            verb='POST',
            path='/', params=params)

</source>
</class>

<class classid="39" nclones="3" nlines="13" similarity="100">
<source file="systems/boto-2.13.2/boto/redshift/layer1.py" startline="205" endline="238" pcid="2993">
    def authorize_snapshot_access(self, snapshot_identifier,
                                  account_with_restore_access,
                                  snapshot_cluster_identifier=None):
        """
        Authorizes the specified AWS customer account to restore the
        specified snapshot.

        For more information about working with snapshots, go to
        `Amazon Redshift Snapshots`_ in the Amazon Redshift Management
        Guide .

        :type snapshot_identifier: string
        :param snapshot_identifier: The identifier of the snapshot the account
            is authorized to restore.

        :type snapshot_cluster_identifier: string
        :param snapshot_cluster_identifier:

        :type account_with_restore_access: string
        :param account_with_restore_access: The identifier of the AWS customer
            account authorized to restore the specified snapshot.

        """
        params = {
            'SnapshotIdentifier': snapshot_identifier,
            'AccountWithRestoreAccess': account_with_restore_access,
        }
        if snapshot_cluster_identifier is not None:
            params['SnapshotClusterIdentifier'] = snapshot_cluster_identifier
        return self._make_request(
            action='AuthorizeSnapshotAccess',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/redshift/layer1.py" startline="2141" endline="2175" pcid="3026">
    def revoke_snapshot_access(self, snapshot_identifier,
                               account_with_restore_access,
                               snapshot_cluster_identifier=None):
        """
        Removes the ability of the specified AWS customer account to
        restore the specified snapshot. If the account is currently
        restoring the snapshot, the restore will run to completion.

        For more information about working with snapshots, go to
        `Amazon Redshift Snapshots`_ in the Amazon Redshift Management
        Guide .

        :type snapshot_identifier: string
        :param snapshot_identifier: The identifier of the snapshot that the
            account can no longer access.

        :type snapshot_cluster_identifier: string
        :param snapshot_cluster_identifier:

        :type account_with_restore_access: string
        :param account_with_restore_access: The identifier of the AWS customer
            account that can no longer restore the specified snapshot.

        """
        params = {
            'SnapshotIdentifier': snapshot_identifier,
            'AccountWithRestoreAccess': account_with_restore_access,
        }
        if snapshot_cluster_identifier is not None:
            params['SnapshotClusterIdentifier'] = snapshot_cluster_identifier
        return self._make_request(
            action='RevokeSnapshotAccess',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/redshift/layer1.py" startline="239" endline="295" pcid="2994">
    def copy_cluster_snapshot(self, source_snapshot_identifier,
                              target_snapshot_identifier,
                              source_snapshot_cluster_identifier=None):
        """
        Copies the specified automated cluster snapshot to a new
        manual cluster snapshot. The source must be an automated
        snapshot and it must be in the available state.

        When you delete a cluster, Amazon Redshift deletes any
        automated snapshots of the cluster. Also, when the retention
        period of the snapshot expires, Amazon Redshift automatically
        deletes it. If you want to keep an automated snapshot for a
        longer period, you can make a manual copy of the snapshot.
        Manual snapshots are retained until you delete them.

        For more information about working with snapshots, go to
        `Amazon Redshift Snapshots`_ in the Amazon Redshift Management
        Guide .

        :type source_snapshot_identifier: string
        :param source_snapshot_identifier:
        The identifier for the source snapshot.

        Constraints:


        + Must be the identifier for a valid automated snapshot whose state is
              "available".

        :type source_snapshot_cluster_identifier: string
        :param source_snapshot_cluster_identifier:

        :type target_snapshot_identifier: string
        :param target_snapshot_identifier:
        The identifier given to the new manual snapshot.

        Constraints:


        + Cannot be null, empty, or blank.
        + Must contain from 1 to 255 alphanumeric characters or hyphens.
        + First character must be a letter.
        + Cannot end with a hyphen or contain two consecutive hyphens.
        + Must be unique for the AWS account that is making the request.

        """
        params = {
            'SourceSnapshotIdentifier': source_snapshot_identifier,
            'TargetSnapshotIdentifier': target_snapshot_identifier,
        }
        if source_snapshot_cluster_identifier is not None:
            params['SourceSnapshotClusterIdentifier'] = source_snapshot_cluster_identifier
        return self._make_request(
            action='CopyClusterSnapshot',
            verb='POST',
            path='/', params=params)

</source>
</class>

<class classid="40" nclones="5" nlines="11" similarity="100">
<source file="systems/boto-2.13.2/boto/opsworks/layer1.py" startline="982" endline="1015" pcid="3044">
    def describe_commands(self, deployment_id=None, instance_id=None,
                          command_ids=None):
        """
        Describes the results of specified commands.

        You must specify at least one of the parameters.

        :type deployment_id: string
        :param deployment_id: The deployment ID. If you include this parameter,
            `DescribeCommands` returns a description of the commands associated
            with the specified deployment.

        :type instance_id: string
        :param instance_id: The instance ID. If you include this parameter,
            `DescribeCommands` returns a description of the commands associated
            with the specified instance.

        :type command_ids: list
        :param command_ids: An array of command IDs. If you include this
            parameter, `DescribeCommands` returns a description of the
            specified commands. Otherwise, it returns a description of every
            command.

        """
        params = {}
        if deployment_id is not None:
            params['DeploymentId'] = deployment_id
        if instance_id is not None:
            params['InstanceId'] = instance_id
        if command_ids is not None:
            params['CommandIds'] = command_ids
        return self.make_request(action='DescribeCommands',
                                 body=json.dumps(params))

</source>
<source file="systems/boto-2.13.2/boto/opsworks/layer1.py" startline="1016" endline="1049" pcid="3045">
    def describe_deployments(self, stack_id=None, app_id=None,
                             deployment_ids=None):
        """
        Requests a description of a specified set of deployments.

        You must specify at least one of the parameters.

        :type stack_id: string
        :param stack_id: The stack ID. If you include this parameter,
            `DescribeDeployments` returns a description of the commands
            associated with the specified stack.

        :type app_id: string
        :param app_id: The app ID. If you include this parameter,
            `DescribeDeployments` returns a description of the commands
            associated with the specified app.

        :type deployment_ids: list
        :param deployment_ids: An array of deployment IDs to be described. If
            you include this parameter, `DescribeDeployments` returns a
            description of the specified deployments. Otherwise, it returns a
            description of every deployment.

        """
        params = {}
        if stack_id is not None:
            params['StackId'] = stack_id
        if app_id is not None:
            params['AppId'] = app_id
        if deployment_ids is not None:
            params['DeploymentIds'] = deployment_ids
        return self.make_request(action='DescribeDeployments',
                                 body=json.dumps(params))

</source>
<source file="systems/boto-2.13.2/boto/opsworks/layer1.py" startline="1212" endline="1243" pcid="3053">
    def describe_service_errors(self, stack_id=None, instance_id=None,
                                service_error_ids=None):
        """
        Describes AWS OpsWorks service errors.

        :type stack_id: string
        :param stack_id: The stack ID. If you use this parameter,
            `DescribeServiceErrors` returns descriptions of the errors
            associated with the specified stack.

        :type instance_id: string
        :param instance_id: The instance ID. If you use this parameter,
            `DescribeServiceErrors` returns descriptions of the errors
            associated with the specified instance.

        :type service_error_ids: list
        :param service_error_ids: An array of service error IDs. If you use
            this parameter, `DescribeServiceErrors` returns descriptions of the
            specified errors. Otherwise, it returns a description of every
            error.

        """
        params = {}
        if stack_id is not None:
            params['StackId'] = stack_id
        if instance_id is not None:
            params['InstanceId'] = instance_id
        if service_error_ids is not None:
            params['ServiceErrorIds'] = service_error_ids
        return self.make_request(action='DescribeServiceErrors',
                                 body=json.dumps(params))

</source>
<source file="systems/boto-2.13.2/boto/opsworks/layer1.py" startline="1288" endline="1320" pcid="3057">
    def describe_volumes(self, instance_id=None, raid_array_id=None,
                         volume_ids=None):
        """
        Describes an instance's Amazon EBS volumes.

        You must specify at least one of the parameters.

        :type instance_id: string
        :param instance_id: The instance ID. If you use this parameter,
            `DescribeVolumes` returns descriptions of the volumes associated
            with the specified instance.

        :type raid_array_id: string
        :param raid_array_id: The RAID array ID. If you use this parameter,
            `DescribeVolumes` returns descriptions of the volumes associated
            with the specified RAID array.

        :type volume_ids: list
        :param volume_ids: Am array of volume IDs. If you use this parameter,
            `DescribeVolumes` returns descriptions of the specified volumes.
            Otherwise, it returns a description of every volume.

        """
        params = {}
        if instance_id is not None:
            params['InstanceId'] = instance_id
        if raid_array_id is not None:
            params['RaidArrayId'] = raid_array_id
        if volume_ids is not None:
            params['VolumeIds'] = volume_ids
        return self.make_request(action='DescribeVolumes',
                                 body=json.dumps(params))

</source>
<source file="systems/boto-2.13.2/boto/opsworks/layer1.py" startline="1099" endline="1132" pcid="3048">
    def describe_instances(self, stack_id=None, layer_id=None,
                           instance_ids=None):
        """
        Requests a description of a set of instances.

        You must specify at least one of the parameters.

        :type stack_id: string
        :param stack_id: A stack ID. If you use this parameter,
            `DescribeInstances` returns descriptions of the instances
            associated with the specified stack.

        :type layer_id: string
        :param layer_id: A layer ID. If you use this parameter,
            `DescribeInstances` returns descriptions of the instances
            associated with the specified layer.

        :type instance_ids: list
        :param instance_ids: An array of instance IDs to be described. If you
            use this parameter, `DescribeInstances` returns a description of
            the specified instances. Otherwise, it returns a description of
            every instance.

        """
        params = {}
        if stack_id is not None:
            params['StackId'] = stack_id
        if layer_id is not None:
            params['LayerId'] = layer_id
        if instance_ids is not None:
            params['InstanceIds'] = instance_ids
        return self.make_request(action='DescribeInstances',
                                 body=json.dumps(params))

</source>
</class>

<class classid="41" nclones="2" nlines="18" similarity="100">
<source file="systems/boto-2.13.2/boto/elastictranscoder/layer1.py" startline="81" endline="143" pcid="3079">
    def create_job(self, pipeline_id=None, input_name=None, output=None,
                   outputs=None, output_key_prefix=None, playlists=None):
        """
        When you create a job, Elastic Transcoder returns JSON data
        that includes the values that you specified plus information
        about the job that is created.

        If you have specified more than one output for your jobs (for
        example, one output for the Kindle Fire and another output for
        the Apple iPhone 4s), you currently must use the Elastic
        Transcoder API to list the jobs (as opposed to the AWS
        Console).

        :type pipeline_id: string
        :param pipeline_id: The `Id` of the pipeline that you want Elastic
            Transcoder to use for transcoding. The pipeline determines several
            settings, including the Amazon S3 bucket from which Elastic
            Transcoder gets the files to transcode and the bucket into which
            Elastic Transcoder puts the transcoded files.

        :type input_name: dict
        :param input_name: A section of the request body that provides
            information about the file that is being transcoded.

        :type output: dict
        :param output: The `CreateJobOutput` structure.

        :type outputs: list
        :param outputs: A section of the request body that provides information
            about the transcoded (target) files. We recommend that you use the
            `Outputs` syntax instead of the `Output` syntax.

        :type output_key_prefix: string
        :param output_key_prefix: The value, if any, that you want Elastic
            Transcoder to prepend to the names of all files that this job
            creates, including output files, thumbnails, and playlists.

        :type playlists: list
        :param playlists: If you specify a preset in `PresetId` for which the
            value of `Container` is ts (MPEG-TS), Playlists contains
            information about the master playlists that you want Elastic
            Transcoder to create.
        We recommend that you create only one master playlist. The maximum
            number of master playlists in a job is 30.

        """
        uri = '/2012-09-25/jobs'
        params = {}
        if pipeline_id is not None:
            params['PipelineId'] = pipeline_id
        if input_name is not None:
            params['Input'] = input_name
        if output is not None:
            params['Output'] = output
        if outputs is not None:
            params['Outputs'] = outputs
        if output_key_prefix is not None:
            params['OutputKeyPrefix'] = output_key_prefix
        if playlists is not None:
            params['Playlists'] = playlists
        return self.make_request('POST', uri, expected_status=201,
                                 data=json.dumps(params))

</source>
<source file="systems/boto-2.13.2/boto/elastictranscoder/layer1.py" startline="360" endline="422" pcid="3081">
    def create_preset(self, name=None, description=None, container=None,
                      video=None, audio=None, thumbnails=None):
        """
        The CreatePreset operation creates a preset with settings that
        you specify.
        Elastic Transcoder checks the CreatePreset settings to ensure
        that they meet Elastic Transcoder requirements and to
        determine whether they comply with H.264 standards. If your
        settings are not valid for Elastic Transcoder, Elastic
        Transcoder returns an HTTP 400 response (
        `ValidationException`) and does not create the preset. If the
        settings are valid for Elastic Transcoder but aren't strictly
        compliant with the H.264 standard, Elastic Transcoder creates
        the preset and returns a warning message in the response. This
        helps you determine whether your settings comply with the
        H.264 standard while giving you greater flexibility with
        respect to the video that Elastic Transcoder produces.
        Elastic Transcoder uses the H.264 video-compression format.
        For more information, see the International Telecommunication
        Union publication Recommendation ITU-T H.264: Advanced video
        coding for generic audiovisual services .

        :type name: string
        :param name: The name of the preset. We recommend that the name be
            unique within the AWS account, but uniqueness is not enforced.

        :type description: string
        :param description: A description of the preset.

        :type container: string
        :param container: The container type for the output file. This value
            must be `mp4`.

        :type video: dict
        :param video: A section of the request body that specifies the video
            parameters.

        :type audio: dict
        :param audio: A section of the request body that specifies the audio
            parameters.

        :type thumbnails: dict
        :param thumbnails: A section of the request body that specifies the
            thumbnail parameters, if any.

        """
        uri = '/2012-09-25/presets'
        params = {}
        if name is not None:
            params['Name'] = name
        if description is not None:
            params['Description'] = description
        if container is not None:
            params['Container'] = container
        if video is not None:
            params['Video'] = video
        if audio is not None:
            params['Audio'] = audio
        if thumbnails is not None:
            params['Thumbnails'] = thumbnails
        return self.make_request('POST', uri, expected_status=201,
                                 data=json.dumps(params))

</source>
</class>

<class classid="42" nclones="2" nlines="12" similarity="100">
<source file="systems/boto-2.13.2/boto/elastictranscoder/layer1.py" startline="455" endline="490" pcid="3084">
    def list_jobs_by_pipeline(self, pipeline_id=None, ascending=None,
                              page_token=None):
        """
        The ListJobsByPipeline operation gets a list of the jobs
        currently in a pipeline.

        Elastic Transcoder returns all of the jobs currently in the
        specified pipeline. The response body contains one element for
        each job that satisfies the search criteria.

        :type pipeline_id: string
        :param pipeline_id: The ID of the pipeline for which you want to get
            job information.

        :type ascending: string
        :param ascending: To list jobs in chronological order by the date and
            time that they were submitted, enter `True`. To list jobs in
            reverse chronological order, enter `False`.

        :type page_token: string
        :param page_token: When Elastic Transcoder returns more than one page
            of results, use `pageToken` in subsequent `GET` requests to get
            each successive page of results.

        """
        uri = '/2012-09-25/jobsByPipeline/{0}'.format(pipeline_id)
        params = {}
        if pipeline_id is not None:
            params['PipelineId'] = pipeline_id
        if ascending is not None:
            params['Ascending'] = ascending
        if page_token is not None:
            params['PageToken'] = page_token
        return self.make_request('GET', uri, expected_status=200,
                                 params=params)

</source>
<source file="systems/boto-2.13.2/boto/elastictranscoder/layer1.py" startline="491" endline="525" pcid="3085">
    def list_jobs_by_status(self, status=None, ascending=None,
                            page_token=None):
        """
        The ListJobsByStatus operation gets a list of jobs that have a
        specified status. The response body contains one element for
        each job that satisfies the search criteria.

        :type status: string
        :param status: To get information about all of the jobs associated with
            the current AWS account that have a given status, specify the
            following status: `Submitted`, `Progressing`, `Complete`,
            `Canceled`, or `Error`.

        :type ascending: string
        :param ascending: To list jobs in chronological order by the date and
            time that they were submitted, enter `True`. To list jobs in
            reverse chronological order, enter `False`.

        :type page_token: string
        :param page_token: When Elastic Transcoder returns more than one page
            of results, use `pageToken` in subsequent `GET` requests to get
            each successive page of results.

        """
        uri = '/2012-09-25/jobsByStatus/{0}'.format(status)
        params = {}
        if status is not None:
            params['Status'] = status
        if ascending is not None:
            params['Ascending'] = ascending
        if page_token is not None:
            params['PageToken'] = page_token
        return self.make_request('GET', uri, expected_status=200,
                                 params=params)

</source>
</class>

<class classid="43" nclones="2" nlines="11" similarity="100">
<source file="systems/boto-2.13.2/boto/vpc/__init__.py" startline="197" endline="228" pcid="3182">
    def get_all_route_tables(self, route_table_ids=None, filters=None,
                             dry_run=False):
        """
        Retrieve information about your routing tables. You can filter results
        to return information only about those route tables that match your
        search parameters. Otherwise, all route tables associated with your
        account are returned.

        :type route_table_ids: list
        :param route_table_ids: A list of strings with the desired route table
                                IDs.

        :type filters: list of tuples
        :param filters: A list of tuples containing filters. Each tuple
                        consists of a filter key and a filter value.

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: list
        :return: A list of :class:`boto.vpc.routetable.RouteTable`
        """
        params = {}
        if route_table_ids:
            self.build_list_params(params, route_table_ids, "RouteTableId")
        if filters:
            self.build_filter_params(params, dict(filters))
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_list('DescribeRouteTables', params,
                             [('item', RouteTable)])

</source>
<source file="systems/boto-2.13.2/boto/vpc/__init__.py" startline="626" endline="663" pcid="3198">
    def get_all_vpn_gateways(self, vpn_gateway_ids=None, filters=None,
                             dry_run=False):
        """
        Retrieve information about your VpnGateways.  You can filter results to
        return information only about those VpnGateways that match your search
        parameters.  Otherwise, all VpnGateways associated with your account
        are returned.

        :type vpn_gateway_ids: list
        :param vpn_gateway_ids: A list of strings with the desired VpnGateway ID's

        :type filters: list of tuples
        :param filters: A list of tuples containing filters.  Each tuple
                        consists of a filter key and a filter value.
                        Possible filter keys are:

                        - *state*, a list of states of the VpnGateway
                          (pending,available,deleting,deleted)
                        - *type*, a list types of customer gateway (ipsec.1)
                        - *availabilityZone*, a list of  Availability zones the
                          VPN gateway is in.

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: list
        :return: A list of :class:`boto.vpc.customergateway.VpnGateway`
        """
        params = {}
        if vpn_gateway_ids:
            self.build_list_params(params, vpn_gateway_ids, 'VpnGatewayId')
        if filters:
            self.build_filter_params(params, dict(filters))
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_list('DescribeVpnGateways', params,
                             [('item', VpnGateway)])

</source>
</class>

<class classid="44" nclones="2" nlines="12" similarity="100">
<source file="systems/boto-2.13.2/boto/vpc/__init__.py" startline="422" endline="450" pcid="3190">
    def get_all_internet_gateways(self, internet_gateway_ids=None,
                                  filters=None, dry_run=False):
        """
        Get a list of internet gateways. You can filter results to return information
        about only those gateways that you're interested in.

        :type internet_gateway_ids: list
        :param internet_gateway_ids: A list of strings with the desired gateway IDs.

        :type filters: list of tuples
        :param filters: A list of tuples containing filters.  Each tuple
                        consists of a filter key and a filter value.

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        """
        params = {}

        if internet_gateway_ids:
            self.build_list_params(params, internet_gateway_ids,
                                   'InternetGatewayId')
        if filters:
            self.build_filter_params(params, dict(filters))
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_list('DescribeInternetGateways', params,
                             [('item', InternetGateway)])

</source>
<source file="systems/boto-2.13.2/boto/vpc/__init__.py" startline="536" endline="577" pcid="3195">
    def get_all_customer_gateways(self, customer_gateway_ids=None,
                                  filters=None, dry_run=False):
        """
        Retrieve information about your CustomerGateways.  You can filter
        results to return information only about those CustomerGateways that
        match your search parameters.  Otherwise, all CustomerGateways
        associated with your account are returned.

        :type customer_gateway_ids: list
        :param customer_gateway_ids: A list of strings with the desired
            CustomerGateway ID's.

        :type filters: list of tuples
        :param filters: A list of tuples containing filters.  Each tuple
                        consists of a filter key and a filter value.
                        Possible filter keys are:

                         - *state*, the state of the CustomerGateway
                           (pending,available,deleting,deleted)
                         - *type*, the type of customer gateway (ipsec.1)
                         - *ipAddress* the IP address of customer gateway's
                           internet-routable external inteface

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: list
        :return: A list of :class:`boto.vpc.customergateway.CustomerGateway`
        """
        params = {}
        if customer_gateway_ids:
            self.build_list_params(params, customer_gateway_ids,
                                   'CustomerGatewayId')
        if filters:
            self.build_filter_params(params, dict(filters))

        if dry_run:
            params['DryRun'] = 'true'

        return self.get_list('DescribeCustomerGateways', params,
                             [('item', CustomerGateway)])

</source>
</class>

<class classid="45" nclones="2" nlines="12" similarity="100">
<source file="systems/boto-2.13.2/boto/s3/bucket.py" startline="959" endline="978" pcid="3377">
    def get_location(self):
        """
        Returns the LocationConstraint for the bucket.

        :rtype: str
        :return: The LocationConstraint for the bucket or the empty
            string if no constraint was specified when bucket was created.
        """
        response = self.connection.make_request('GET', self.name,
                                                query_args='location')
        body = response.read()
        if response.status == 200:
            rs = ResultSet(self)
            h = handler.XmlHandler(rs, self)
            xml.sax.parseString(body, h)
            return rs.LocationConstraint
        else:
            raise self.connection.provider.storage_response_error(
                response.status, response.reason, body)

</source>
<source file="systems/boto-2.13.2/boto/gs/bucket.py" startline="567" endline="588" pcid="3772">
    def get_storage_class(self):
        """
        Returns the StorageClass for the bucket.

        :rtype: str
        :return: The StorageClass for the bucket.
        """
        response = self.connection.make_request('GET', self.name,
                                                query_args='storageClass')
        body = response.read()
        if response.status == 200:
            rs = ResultSet(self)
            h = handler.XmlHandler(rs, self)
            xml.sax.parseString(body, h)
            return rs.StorageClass
        else:
            raise self.connection.provider.storage_response_error(
                response.status, response.reason, body)


    # Method with same signature as boto.s3.bucket.Bucket.add_email_grant(),
    # to allow polymorphic treatment at application layer.
</source>
</class>

<class classid="46" nclones="3" nlines="11" similarity="100">
<source file="systems/boto-2.13.2/boto/s3/bucket.py" startline="1214" endline="1228" pcid="3389">
    def delete_lifecycle_configuration(self, headers=None):
        """
        Removes all lifecycle configuration from the bucket.
        """
        response = self.connection.make_request('DELETE', self.name,
                                                query_args='lifecycle',
                                                headers=headers)
        body = response.read()
        boto.log.debug(body)
        if response.status == 204:
            return True
        else:
            raise self.connection.provider.storage_response_error(
                response.status, response.reason, body)

</source>
<source file="systems/boto-2.13.2/boto/s3/bucket.py" startline="1487" endline="1501" pcid="3406">
    def delete_cors(self, headers=None):
        """
        Removes all CORS configuration from the bucket.
        """
        response = self.connection.make_request('DELETE', self.name,
                                                query_args='cors',
                                                headers=headers)
        body = response.read()
        boto.log.debug(body)
        if response.status == 204:
            return True
        else:
            raise self.connection.provider.storage_response_error(
                response.status, response.reason, body)

</source>
<source file="systems/boto-2.13.2/boto/s3/bucket.py" startline="1659" endline="1669" pcid="3415">
    def delete_tags(self, headers=None):
        response = self.connection.make_request('DELETE', self.name,
                                                query_args='tagging',
                                                headers=headers)
        body = response.read()
        boto.log.debug(body)
        if response.status == 204:
            return True
        else:
            raise self.connection.provider.storage_response_error(
                response.status, response.reason, body)
</source>
</class>

<class classid="47" nclones="2" nlines="10" similarity="100">
<source file="systems/boto-2.13.2/boto/s3/bucket.py" startline="1352" endline="1365" pcid="3397">
    def delete_website_configuration(self, headers=None):
        """
        Removes all website configuration from the bucket.
        """
        response = self.connection.make_request('DELETE', self.name,
                query_args='website', headers=headers)
        body = response.read()
        boto.log.debug(body)
        if response.status == 204:
            return True
        else:
            raise self.connection.provider.storage_response_error(
                response.status, response.reason, body)

</source>
<source file="systems/boto-2.13.2/boto/s3/bucket.py" startline="1458" endline="1472" pcid="3404">
    def get_cors_xml(self, headers=None):
        """
        Returns the current CORS configuration on the bucket as an
        XML document.
        """
        response = self.connection.make_request('GET', self.name,
                query_args='cors', headers=headers)
        body = response.read()
        boto.log.debug(body)
        if response.status == 200:
            return body
        else:
            raise self.connection.provider.storage_response_error(
                response.status, response.reason, body)

</source>
</class>

<class classid="48" nclones="2" nlines="14" similarity="100">
<source file="systems/boto-2.13.2/boto/s3/bucketlistresultset.py" startline="58" endline="75" pcid="3452">
def versioned_bucket_lister(bucket, prefix='', delimiter='',
                            key_marker='', version_id_marker='', headers=None):
    """
    A generator function for listing versions in a bucket.
    """
    more_results = True
    k = None
    while more_results:
        rs = bucket.get_all_versions(prefix=prefix, key_marker=key_marker,
                                     version_id_marker=version_id_marker,
                                     delimiter=delimiter, headers=headers,
                                     max_keys=999)
        for k in rs:
            yield k
        key_marker = rs.next_key_marker
        version_id_marker = rs.next_version_id_marker
        more_results= rs.is_truncated
        
</source>
<source file="systems/boto-2.13.2/boto/gs/bucketlistresultset.py" startline="23" endline="40" pcid="3814">
def versioned_bucket_lister(bucket, prefix='', delimiter='',
                            marker='', generation_marker='', headers=None):
    """
    A generator function for listing versioned objects.
    """
    more_results = True
    k = None
    while more_results:
        rs = bucket.get_all_versions(prefix=prefix, marker=marker,
                                     generation_marker=generation_marker,
                                     delimiter=delimiter, headers=headers,
                                     max_keys=999)
        for k in rs:
            yield k
        marker = rs.next_marker
        generation_marker = rs.next_generation_marker
        more_results= rs.is_truncated

</source>
</class>

<class classid="49" nclones="2" nlines="10" similarity="100">
<source file="systems/boto-2.13.2/boto/route53/zone.py" startline="303" endline="320" pcid="3929">
    def update_cname(self, name, value, ttl=None, identifier=None, comment=""):
        """
        Update the given CNAME record in this Zone to a new value, ttl,
        and identifier.  Returns a Status object.

        Will throw TooManyRecordsException is name, value does not match
        a single record.
        """
        name = self.route53connection._make_qualified(name)
        value = self.route53connection._make_qualified(value)
        old_record = self.get_cname(name)
        ttl = ttl or old_record.ttl
        return self.update_record(old_record,
                                  new_value=value,
                                  new_ttl=ttl,
                                  new_identifier=identifier,
                                  comment=comment)

</source>
<source file="systems/boto-2.13.2/boto/route53/zone.py" startline="338" endline="355" pcid="3931">
    def update_mx(self, name, value, ttl=None, identifier=None, comment=""):
        """
        Update the given MX record in this Zone to a new value, ttl,
        and identifier.  Returns a Status object.

        Will throw TooManyRecordsException is name, value does not match
        a single record.
        """
        name = self.route53connection._make_qualified(name)
        value = self.route53connection._make_qualified(value)
        old_record = self.get_mx(name)
        ttl = ttl or old_record.ttl
        return self.update_record(old_record,
                                  new_value=value,
                                  new_ttl=ttl,
                                  new_identifier=identifier,
                                  comment=comment)

</source>
</class>

<class classid="50" nclones="2" nlines="12" similarity="100">
<source file="systems/boto-2.13.2/boto/dynamodb/layer1.py" startline="345" endline="383" pcid="4103">
    def put_item(self, table_name, item,
                 expected=None, return_values=None,
                 object_hook=None):
        """
        Create a new item or replace an old item with a new
        item (including all attributes).  If an item already
        exists in the specified table with the same primary
        key, the new item will completely replace the old item.
        You can perform a conditional put by specifying an
        expected rule.

        :type table_name: str
        :param table_name: The name of the table in which to put the item.

        :type item: dict
        :param item: A Python version of the Item data structure
            defined by DynamoDB.

        :type expected: dict
        :param expected: A Python version of the Expected
            data structure defined by DynamoDB.

        :type return_values: str
        :param return_values: Controls the return of attribute
            name-value pairs before then were changed.  Possible
            values are: None or 'ALL_OLD'. If 'ALL_OLD' is
            specified and the item is overwritten, the content
            of the old item is returned.
        """
        data = {'TableName': table_name,
                'Item': item}
        if expected:
            data['Expected'] = expected
        if return_values:
            data['ReturnValues'] = return_values
        json_input = json.dumps(data)
        return self.make_request('PutItem', json_input,
                                 object_hook=object_hook)

</source>
<source file="systems/boto-2.13.2/boto/dynamodb/layer1.py" startline="426" endline="461" pcid="4105">
    def delete_item(self, table_name, key,
                    expected=None, return_values=None,
                    object_hook=None):
        """
        Delete an item and all of it's attributes by primary key.
        You can perform a conditional delete by specifying an
        expected rule.

        :type table_name: str
        :param table_name: The name of the table containing the item.

        :type key: dict
        :param key: A Python version of the Key data structure
            defined by DynamoDB.

        :type expected: dict
        :param expected: A Python version of the Expected
            data structure defined by DynamoDB.

        :type return_values: str
        :param return_values: Controls the return of attribute
            name-value pairs before then were changed.  Possible
            values are: None or 'ALL_OLD'. If 'ALL_OLD' is
            specified and the item is overwritten, the content
            of the old item is returned.
        """
        data = {'TableName': table_name,
                'Key': key}
        if expected:
            data['Expected'] = expected
        if return_values:
            data['ReturnValues'] = return_values
        json_input = json.dumps(data)
        return self.make_request('DeleteItem', json_input,
                                 object_hook=object_hook)

</source>
</class>

<class classid="51" nclones="2" nlines="14" similarity="100">
<source file="systems/boto-2.13.2/boto/swf/layer2.py" startline="68" endline="83" pcid="4184">
    def activities(self, status='REGISTERED', **kwargs):
        """ListActivityTypes."""
        act_types = self._swf.list_activity_types(self.name, status, **kwargs)
        act_objects = []
        for act_args in act_types['typeInfos']:
            act_ident = act_args['activityType']
            del act_args['activityType']
            act_args.update(act_ident)
            act_args.update({
                'aws_access_key_id': self.aws_access_key_id,
                'aws_secret_access_key': self.aws_secret_access_key,
                'domain': self.name,
            })
            act_objects.append(ActivityType(**act_args))
        return act_objects

</source>
<source file="systems/boto-2.13.2/boto/swf/layer2.py" startline="85" endline="101" pcid="4185">
    def workflows(self, status='REGISTERED', **kwargs):
        """ListWorkflowTypes."""
        wf_types = self._swf.list_workflow_types(self.name, status, **kwargs)
        wf_objects = []
        for wf_args in wf_types['typeInfos']:
            wf_ident = wf_args['workflowType']
            del wf_args['workflowType']
            wf_args.update(wf_ident)
            wf_args.update({
                'aws_access_key_id': self.aws_access_key_id,
                'aws_secret_access_key': self.aws_secret_access_key,
                'domain': self.name,
            })
            
            wf_objects.append(WorkflowType(**wf_args))
        return wf_objects

</source>
</class>

<class classid="52" nclones="2" nlines="11" similarity="100">
<source file="systems/boto-2.13.2/boto/swf/layer1.py" startline="519" endline="581" pcid="4226">
    def terminate_workflow_execution(self, domain, workflow_id,
                                     child_policy=None, details=None,
                                     reason=None, run_id=None):
        """
        Records a WorkflowExecutionTerminated event and forces closure
        of the workflow execution identified by the given domain,
        runId, and workflowId. The child policy, registered with the
        workflow type or specified when starting this execution, is
        applied to any open child workflow executions of this workflow
        execution.

        :type domain: string
        :param domain: The domain of the workflow execution to terminate.

        :type workflow_id: string
        :param workflow_id: The workflowId of the workflow execution
            to terminate.

        :type child_policy: string
        :param child_policy: If set, specifies the policy to use for
            the child workflow executions of the workflow execution being
            terminated. This policy overrides the child policy specified
            for the workflow execution at registration time or when
            starting the execution. The supported child policies are:

            * TERMINATE: the child executions will be terminated.

            * REQUEST_CANCEL: a request to cancel will be attempted
              for each child execution by recording a
              WorkflowExecutionCancelRequested event in its
              history. It is up to the decider to take appropriate
              actions when it receives an execution history with this
              event.

            * ABANDON: no action will be taken. The child executions
              will continue to run.

        :type details: string
        :param details: Optional details for terminating the
            workflow execution.

        :type reason: string
        :param reason: An optional descriptive reason for terminating
            the workflow execution.

        :type run_id: string
        :param run_id: The runId of the workflow execution to terminate.

        :raises: UnknownResourceFault, SWFOperationNotPermittedError
        """
        return self.json_request('TerminateWorkflowExecution', {
            'domain': domain,
            'workflowId': workflow_id,
            'childPolicy': child_policy,
            'details': details,
            'reason': reason,
            'runId': run_id,
        })

# Actions related to Administration

## Activity Management

</source>
<source file="systems/boto-2.13.2/boto/swf/layer1.py" startline="935" endline="985" pcid="4235">
    def list_workflow_types(self, domain, registration_status,
                            maximum_page_size=None, name=None,
                            next_page_token=None, reverse_order=None):
        """
        Returns information about workflow types in the specified
        domain. The results may be split into multiple pages that can
        be retrieved by making the call repeatedly.

        :type domain: string
        :param domain: The name of the domain in which the workflow
            types have been registered.

        :type registration_status: string
        :param registration_status: Specifies the registration status
            of the activity types to list.  Valid values are:

            * REGISTERED
            * DEPRECATED

        :type name: string
        :param name: If specified, lists the workflow type with this name.

        :type maximum_page_size: integer
        :param maximum_page_size: The maximum number of results
            returned in each page. The default is 100, but the caller can
            override this value to a page size smaller than the
            default. You cannot specify a page size greater than 100.

        :type next_page_token: string
        :param next_page_token: If on a previous call to this method a
            NextPageToken was returned, the results are being
            paginated. To get the next page of results, repeat the call
            with the returned token and all other arguments unchanged.

        :type reverse_order: boolean
        :param reverse_order: When set to true, returns the results in
            reverse order. By default the results are returned in
            ascending alphabetical order of the name of the workflow
            types.

        :raises: SWFOperationNotPermittedError, UnknownResourceFault
        """
        return self.json_request('ListWorkflowTypes', {
            'domain': domain,
            'name': name,
            'registrationStatus': registration_status,
            'maximumPageSize': maximum_page_size,
            'nextPageToken': next_page_token,
            'reverseOrder': reverse_order,
        })

</source>
</class>

<class classid="53" nclones="2" nlines="31" similarity="100">
<source file="systems/boto-2.13.2/tests/integration/gs/test_versioning.py" startline="116" endline="152" pcid="4698">
    def testVersionedBucketCannedAcl(self):
        b = self._MakeVersionedBucket()
        k = b.new_key("foo")
        s1 = "test1"
        k.set_contents_from_string(s1)

        k = b.get_key("foo")
        g1 = k.generation

        s2 = "test2"
        k.set_contents_from_string(s2)
        k = b.get_key("foo")
        g2 = k.generation

        acl1g1 = b.get_acl("foo", generation=g1)
        acl1g2 = b.get_acl("foo", generation=g2)
        owner1g1 = acl1g1.owner.id
        owner1g2 = acl1g2.owner.id
        self.assertEqual(owner1g1, owner1g2)
        entries1g1 = acl1g1.entries.entry_list
        entries1g2 = acl1g2.entries.entry_list
        self.assertEqual(len(entries1g1), len(entries1g2))

        b.set_acl("public-read", key_name="foo", generation=g1)

        acl2g1 = b.get_acl("foo", generation=g1)
        acl2g2 = b.get_acl("foo", generation=g2)
        entries2g1 = acl2g1.entries.entry_list
        entries2g2 = acl2g2.entries.entry_list
        self.assertEqual(len(entries2g2), len(entries1g2))
        public_read_entries1 = [e for e in entries2g1 if e.permission == "READ"
                                and e.scope.type == acl.ALL_USERS]
        public_read_entries2 = [e for e in entries2g2 if e.permission == "READ"
                                and e.scope.type == acl.ALL_USERS]
        self.assertEqual(len(public_read_entries1), 1)
        self.assertEqual(len(public_read_entries2), 0)

</source>
<source file="systems/boto-2.13.2/tests/integration/gs/test_versioning.py" startline="198" endline="234" pcid="4700">
    def testVersionedObjectCannedAcl(self):
        b = self._MakeVersionedBucket()
        k = b.new_key("foo")
        s1 = "test1"
        k.set_contents_from_string(s1)

        k = b.get_key("foo")
        g1 = k.generation

        s2 = "test2"
        k.set_contents_from_string(s2)
        k = b.get_key("foo")
        g2 = k.generation

        acl1g1 = b.get_acl("foo", generation=g1)
        acl1g2 = b.get_acl("foo", generation=g2)
        owner1g1 = acl1g1.owner.id
        owner1g2 = acl1g2.owner.id
        self.assertEqual(owner1g1, owner1g2)
        entries1g1 = acl1g1.entries.entry_list
        entries1g2 = acl1g2.entries.entry_list
        self.assertEqual(len(entries1g1), len(entries1g2))

        b.set_acl("public-read", key_name="foo", generation=g1)

        acl2g1 = b.get_acl("foo", generation=g1)
        acl2g2 = b.get_acl("foo", generation=g2)
        entries2g1 = acl2g1.entries.entry_list
        entries2g2 = acl2g2.entries.entry_list
        self.assertEqual(len(entries2g2), len(entries1g2))
        public_read_entries1 = [e for e in entries2g1 if e.permission == "READ"
                                and e.scope.type == acl.ALL_USERS]
        public_read_entries2 = [e for e in entries2g2 if e.permission == "READ"
                                and e.scope.type == acl.ALL_USERS]
        self.assertEqual(len(public_read_entries1), 1)
        self.assertEqual(len(public_read_entries2), 0)

</source>
</class>

<class classid="54" nclones="2" nlines="13" similarity="100">
<source file="systems/boto-2.13.2/tests/unit/cloudformation/test_stack.py" startline="165" endline="181" pcid="5003">
    def test_resource_time_with_millis(self):
        rs = boto.resultset.ResultSet([
          ('member', boto.cloudformation.stack.StackResource)
        ])
        h = boto.handler.XmlHandler(rs, None)
        xml.sax.parseString(DESCRIBE_STACK_RESOURCE_XML, h)
        timestamp_1 = rs[0].timestamp
        self.assertEqual(
          timestamp_1,
          datetime.datetime(2010, 7, 27, 22, 27, 28)
        )
        timestamp_2 = rs[1].timestamp
        self.assertEqual(
          timestamp_2,
          datetime.datetime(2010, 7, 27, 22, 28, 28, 123456)
        )

</source>
<source file="systems/boto-2.13.2/tests/unit/cloudformation/test_stack.py" startline="204" endline="220" pcid="5005">
    def test_list_stacks_time_with_millis(self):
        rs = boto.resultset.ResultSet([
            ('member', boto.cloudformation.stack.StackResourceSummary)
        ])
        h = boto.handler.XmlHandler(rs, None)
        xml.sax.parseString(LIST_STACK_RESOURCES_XML, h)
        timestamp_1 = rs[0].last_updated_time
        self.assertEqual(
            timestamp_1,
            datetime.datetime(2011, 6, 21, 20, 15, 58)
        )
        timestamp_2 = rs[1].last_updated_time
        self.assertEqual(
            timestamp_2,
            datetime.datetime(2011, 6, 21, 20, 25, 57, 875643)
        )

</source>
</class>

<class classid="55" nclones="2" nlines="11" similarity="100">
<source file="systems/boto-2.13.2/tests/unit/cloudformation/test_connection.py" startline="96" endline="108" pcid="5013">
    def test_create_stack_with_minimum_args(self):
        # This will fail in practice, but the API docs only require stack_name.
        self.set_http_response(status_code=200)
        api_response = self.service_connection.create_stack('stack_name')
        self.assertEqual(api_response, self.stack_id)
        self.assert_request_parameters({
            'Action': 'CreateStack',
            'ContentType': 'JSON',
            'DisableRollback': 'false',
            'StackName': 'stack_name',
            'Version': '2010-05-15',
        })

</source>
<source file="systems/boto-2.13.2/tests/unit/cloudformation/test_connection.py" startline="153" endline="164" pcid="5017">
    def test_update_stack_with_minimum_args(self):
        self.set_http_response(status_code=200)
        api_response = self.service_connection.update_stack('stack_name')
        self.assertEqual(api_response, self.stack_id)
        self.assert_request_parameters({
            'Action': 'UpdateStack',
            'ContentType': 'JSON',
            'DisableRollback': 'false',
            'StackName': 'stack_name',
            'Version': '2010-05-15',
        })

</source>
</class>

<class classid="56" nclones="2" nlines="11" similarity="100">
<source file="systems/boto-2.13.2/tests/unit/sns/test_connection.py" startline="104" endline="116" pcid="5047">
    def test_publish_with_kwargs(self):
        self.set_http_response(status_code=200)

        self.service_connection.publish(topic='topic',
                                        message='message',
                                        subject='subject')
        self.assert_request_parameters({
            'Action': 'Publish',
            'TopicArn': 'topic',
            'Subject': 'subject',
            'Message': 'message',
        }, ignore_params_values=['Version', 'ContentType'])

</source>
<source file="systems/boto-2.13.2/tests/unit/sns/test_connection.py" startline="117" endline="129" pcid="5048">
    def test_publish_with_target_arn(self):
        self.set_http_response(status_code=200)

        self.service_connection.publish(target_arn='target_arn',
                                        message='message',
                                        subject='subject')
        self.assert_request_parameters({
            'Action': 'Publish',
            'TargetArn': 'target_arn',
            'Subject': 'subject',
            'Message': 'message',
        }, ignore_params_values=['Version', 'ContentType'])

</source>
</class>

<class classid="57" nclones="2" nlines="11" similarity="100">
<source file="systems/boto-2.13.2/tests/unit/dynamodb2/test_table.py" startline="19" endline="33" pcid="5089">
    def test_hash_key(self):
        hash_key = HashKey('hello')
        self.assertEqual(hash_key.name, 'hello')
        self.assertEqual(hash_key.data_type, STRING)
        self.assertEqual(hash_key.attr_type, 'HASH')

        self.assertEqual(hash_key.definition(), {
            'AttributeName': 'hello',
            'AttributeType': 'S'
        })
        self.assertEqual(hash_key.schema(), {
            'AttributeName': 'hello',
            'KeyType': 'HASH'
        })

</source>
<source file="systems/boto-2.13.2/tests/unit/dynamodb2/test_table.py" startline="34" endline="48" pcid="5090">
    def test_range_key(self):
        range_key = RangeKey('hello')
        self.assertEqual(range_key.name, 'hello')
        self.assertEqual(range_key.data_type, STRING)
        self.assertEqual(range_key.attr_type, 'RANGE')

        self.assertEqual(range_key.definition(), {
            'AttributeName': 'hello',
            'AttributeType': 'S'
        })
        self.assertEqual(range_key.schema(), {
            'AttributeName': 'hello',
            'KeyType': 'RANGE'
        })

</source>
</class>

<class classid="58" nclones="2" nlines="23" similarity="100">
<source file="systems/boto-2.13.2/tests/unit/dynamodb2/test_table.py" startline="66" endline="98" pcid="5092">
    def test_all_index(self):
        all_index = AllIndex('AllKeys', parts=[
            HashKey('username'),
            RangeKey('date_joined')
        ])
        self.assertEqual(all_index.name, 'AllKeys')
        self.assertEqual([part.attr_type for part in all_index.parts], [
            'HASH',
            'RANGE'
        ])
        self.assertEqual(all_index.projection_type, 'ALL')

        self.assertEqual(all_index.definition(), [
            {'AttributeName': 'username', 'AttributeType': 'S'},
            {'AttributeName': 'date_joined', 'AttributeType': 'S'}
        ])
        self.assertEqual(all_index.schema(), {
            'IndexName': 'AllKeys',
            'KeySchema': [
                {
                    'AttributeName': 'username',
                    'KeyType': 'HASH'
                },
                {
                    'AttributeName': 'date_joined',
                    'KeyType': 'RANGE'
                }
            ],
            'Projection': {
                'ProjectionType': 'ALL'
            }
        })

</source>
<source file="systems/boto-2.13.2/tests/unit/dynamodb2/test_table.py" startline="99" endline="131" pcid="5093">
    def test_keys_only_index(self):
        keys_only = KeysOnlyIndex('KeysOnly', parts=[
            HashKey('username'),
            RangeKey('date_joined')
        ])
        self.assertEqual(keys_only.name, 'KeysOnly')
        self.assertEqual([part.attr_type for part in keys_only.parts], [
            'HASH',
            'RANGE'
        ])
        self.assertEqual(keys_only.projection_type, 'KEYS_ONLY')

        self.assertEqual(keys_only.definition(), [
            {'AttributeName': 'username', 'AttributeType': 'S'},
            {'AttributeName': 'date_joined', 'AttributeType': 'S'}
        ])
        self.assertEqual(keys_only.schema(), {
            'IndexName': 'KeysOnly',
            'KeySchema': [
                {
                    'AttributeName': 'username',
                    'KeyType': 'HASH'
                },
                {
                    'AttributeName': 'date_joined',
                    'KeyType': 'RANGE'
                }
            ],
            'Projection': {
                'ProjectionType': 'KEYS_ONLY'
            }
        })

</source>
</class>

<class classid="59" nclones="2" nlines="48" similarity="100">
<source file="systems/boto-2.13.2/tests/unit/dynamodb2/test_table.py" startline="1926" endline="1983" pcid="5163">
                'username': {
                    'S': 'adam',
                },
            },
            segment=None,
            total_segments=None
        )

    def test_query(self):
        items_1 = {
            'results': [
                Item(self.users, data={
                    'username': 'johndoe',
                    'first_name': 'John',
                    'last_name': 'Doe',
                }),
                Item(self.users, data={
                    'username': 'jane',
                    'first_name': 'Jane',
                    'last_name': 'Doe',
                }),
            ],
            'last_key': 'jane',
        }

        results = self.users.query(last_name__eq='Doe')
        self.assertTrue(isinstance(results, ResultSet))
        self.assertEqual(len(results._results), 0)
        self.assertEqual(results.the_callable, self.users._query)

        with mock.patch.object(
                results,
                'the_callable',
                return_value=items_1) as mock_query:
            res_1 = results.next()
            # Now it should be populated.
            self.assertEqual(len(results._results), 2)
            self.assertEqual(res_1['username'], 'johndoe')
            res_2 = results.next()
            self.assertEqual(res_2['username'], 'jane')

        self.assertEqual(mock_query.call_count, 1)

        items_2 = {
            'results': [
                Item(self.users, data={
                    'username': 'foodoe',
                    'first_name': 'Foo',
                    'last_name': 'Doe',
                }),
            ],
        }

        with mock.patch.object(
                results,
                'the_callable',
                return_value=items_2) as mock_query_2:
            res_3 = results.next()
</source>
<source file="systems/boto-2.13.2/tests/unit/dynamodb2/test_table.py" startline="2017" endline="2074" pcid="5165">
            self.assertEqual(len(results._results), 2)
            self.assertEqual(res_1['username'], 'johndoe')
            self.assertEqual(res_1.keys(), ['username'])
            res_2 = results.next()
            self.assertEqual(res_2['username'], 'jane')

        self.assertEqual(mock_query.call_count, 1)

    def test_scan(self):
        items_1 = {
            'results': [
                Item(self.users, data={
                    'username': 'johndoe',
                    'first_name': 'John',
                    'last_name': 'Doe',
                }),
                Item(self.users, data={
                    'username': 'jane',
                    'first_name': 'Jane',
                    'last_name': 'Doe',
                }),
            ],
            'last_key': 'jane',
        }

        results = self.users.scan(last_name__eq='Doe')
        self.assertTrue(isinstance(results, ResultSet))
        self.assertEqual(len(results._results), 0)
        self.assertEqual(results.the_callable, self.users._scan)

        with mock.patch.object(
                results,
                'the_callable',
                return_value=items_1) as mock_scan:
            res_1 = results.next()
            # Now it should be populated.
            self.assertEqual(len(results._results), 2)
            self.assertEqual(res_1['username'], 'johndoe')
            res_2 = results.next()
            self.assertEqual(res_2['username'], 'jane')

        self.assertEqual(mock_scan.call_count, 1)

        items_2 = {
            'results': [
                Item(self.users, data={
                    'username': 'zoeydoe',
                    'first_name': 'Zoey',
                    'last_name': 'Doe',
                }),
            ],
        }

        with mock.patch.object(
                results,
                'the_callable',
                return_value=items_2) as mock_scan_2:
            res_3 = results.next()
</source>
</class>

<class classid="60" nclones="2" nlines="10" similarity="100">
<source file="systems/boto-2.13.2/tests/unit/s3/test_website.py" startline="82" endline="110" pcid="5417">
    def test_routing_rules_key_prefix(self):
        x = pretty_print_xml
        # This rule redirects requests for docs/* to documentation/*
        rules = RoutingRules()
        condition = Condition(key_prefix='docs/')
        redirect = Redirect(replace_key_prefix='documents/')
        rules.add_rule(RoutingRule(condition, redirect))
        config = WebsiteConfiguration(suffix='index.html', routing_rules=rules)
        xml = config.to_xml()

        expected_xml = """<?xml version="1.0" encoding="UTF-8"?>
            <WebsiteConfiguration xmlns='http://s3.amazonaws.com/doc/2006-03-01/'>
              <IndexDocument>
                <Suffix>index.html</Suffix>
              </IndexDocument>
              <RoutingRules>
                <RoutingRule>
                <Condition>
                  <KeyPrefixEquals>docs/</KeyPrefixEquals>
                </Condition>
                <Redirect>
                  <ReplaceKeyPrefixWith>documents/</ReplaceKeyPrefixWith>
                </Redirect>
                </RoutingRule>
              </RoutingRules>
            </WebsiteConfiguration>
        """
        self.assertEqual(x(expected_xml), x(xml))

</source>
<source file="systems/boto-2.13.2/tests/unit/s3/test_website.py" startline="146" endline="173" pcid="5419">
    def test_key_prefix(self):
        x = pretty_print_xml
        rules = RoutingRules()
        condition = Condition(key_prefix="images/")
        redirect = Redirect(replace_key='folderdeleted.html')
        rules.add_rule(RoutingRule(condition, redirect))
        config = WebsiteConfiguration(suffix='index.html', routing_rules=rules)
        xml = config.to_xml()

        expected_xml = """<?xml version="1.0" encoding="UTF-8"?>
            <WebsiteConfiguration xmlns='http://s3.amazonaws.com/doc/2006-03-01/'>
              <IndexDocument>
                <Suffix>index.html</Suffix>
              </IndexDocument>
              <RoutingRules>
                <RoutingRule>
                <Condition>
                  <KeyPrefixEquals>images/</KeyPrefixEquals>
                </Condition>
                <Redirect>
                  <ReplaceKeyWith>folderdeleted.html</ReplaceKeyWith>
                </Redirect>
                </RoutingRule>
              </RoutingRules>
            </WebsiteConfiguration>
        """
        self.assertEqual(x(expected_xml), x(xml))

</source>
</class>

<class classid="61" nclones="2" nlines="20" similarity="100">
<source file="systems/boto-2.13.2/tests/unit/s3/test_uri.py" startline="31" endline="51" pcid="5425">
    def test_provider_uri(self):
        for prov in ('gs', 's3'):
            uri_str = '%s://' % prov
            uri = boto.storage_uri(uri_str, validate=False,
                suppress_consec_slashes=False)
            self.assertEqual(prov, uri.scheme)
            self.assertEqual(uri_str, uri.uri)
            self.assertFalse(hasattr(uri, 'versionless_uri'))
            self.assertEqual('', uri.bucket_name)
            self.assertEqual('', uri.object_name)
            self.assertEqual(None, uri.version_id)
            self.assertEqual(None, uri.generation)
            self.assertEqual(uri.names_provider(), True)
            self.assertEqual(uri.names_container(), True)
            self.assertEqual(uri.names_bucket(), False)
            self.assertEqual(uri.names_object(), False)
            self.assertEqual(uri.names_directory(), False)
            self.assertEqual(uri.names_file(), False)
            self.assertEqual(uri.is_stream(), False)
            self.assertEqual(uri.is_version_specific, False)

</source>
<source file="systems/boto-2.13.2/tests/unit/s3/test_uri.py" startline="73" endline="93" pcid="5427">
    def test_bucket_uri_with_trailing_slash(self):
        for prov in ('gs', 's3'):
            uri_str = '%s://bucket/' % prov
            uri = boto.storage_uri(uri_str, validate=False,
                suppress_consec_slashes=False)
            self.assertEqual(prov, uri.scheme)
            self.assertEqual(uri_str, uri.uri)
            self.assertFalse(hasattr(uri, 'versionless_uri'))
            self.assertEqual('bucket', uri.bucket_name)
            self.assertEqual('', uri.object_name)
            self.assertEqual(None, uri.version_id)
            self.assertEqual(None, uri.generation)
            self.assertEqual(uri.names_provider(), False)
            self.assertEqual(uri.names_container(), True)
            self.assertEqual(uri.names_bucket(), True)
            self.assertEqual(uri.names_object(), False)
            self.assertEqual(uri.names_directory(), False)
            self.assertEqual(uri.names_file(), False)
            self.assertEqual(uri.is_stream(), False)
            self.assertEqual(uri.is_version_specific, False)

</source>
</class>

<class classid="62" nclones="2" nlines="19" similarity="100">
<source file="systems/boto-2.13.2/tests/unit/s3/test_uri.py" startline="115" endline="134" pcid="5429">
    def test_versioned_gs_object_uri(self):
        uri_str = 'gs://bucket/obj/a/b#1359908801674000'
        uri = boto.storage_uri(uri_str, validate=False,
            suppress_consec_slashes=False)
        self.assertEqual('gs', uri.scheme)
        self.assertEqual(uri_str, uri.uri)
        self.assertEqual('gs://bucket/obj/a/b', uri.versionless_uri)
        self.assertEqual('bucket', uri.bucket_name)
        self.assertEqual('obj/a/b', uri.object_name)
        self.assertEqual(None, uri.version_id)
        self.assertEqual(1359908801674000, uri.generation)
        self.assertEqual(uri.names_provider(), False)
        self.assertEqual(uri.names_container(), False)
        self.assertEqual(uri.names_bucket(), False)
        self.assertEqual(uri.names_object(), True)
        self.assertEqual(uri.names_directory(), False)
        self.assertEqual(uri.names_file(), False)
        self.assertEqual(uri.is_stream(), False)
        self.assertEqual(uri.is_version_specific, True)

</source>
<source file="systems/boto-2.13.2/tests/unit/s3/test_uri.py" startline="135" endline="154" pcid="5430">
    def test_versioned_gs_object_uri_with_legacy_generation_value(self):
        uri_str = 'gs://bucket/obj/a/b#1'
        uri = boto.storage_uri(uri_str, validate=False,
            suppress_consec_slashes=False)
        self.assertEqual('gs', uri.scheme)
        self.assertEqual(uri_str, uri.uri)
        self.assertEqual('gs://bucket/obj/a/b', uri.versionless_uri)
        self.assertEqual('bucket', uri.bucket_name)
        self.assertEqual('obj/a/b', uri.object_name)
        self.assertEqual(None, uri.version_id)
        self.assertEqual(1, uri.generation)
        self.assertEqual(uri.names_provider(), False)
        self.assertEqual(uri.names_container(), False)
        self.assertEqual(uri.names_bucket(), False)
        self.assertEqual(uri.names_object(), True)
        self.assertEqual(uri.names_directory(), False)
        self.assertEqual(uri.names_file(), False)
        self.assertEqual(uri.is_stream(), False)
        self.assertEqual(uri.is_version_specific, True)

</source>
</class>

</clones>
