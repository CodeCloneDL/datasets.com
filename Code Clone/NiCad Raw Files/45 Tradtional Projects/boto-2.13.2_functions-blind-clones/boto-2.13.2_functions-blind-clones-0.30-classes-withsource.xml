<clones>
<systeminfo processor="nicad6" system="boto-2.13.2" granularity="functions-blind" threshold="30%" minlines="10" maxlines="2500"/>
<cloneinfo npcs="5532" npairs="1957"/>
<runinfo ncompares="629664" cputime="254477"/>
<classinfo nclasses="125"/>

<class classid="1" nclones="8" nlines="25" similarity="73">
<source file="systems/boto-2.13.2/boto/elasticache/__init__.py" startline="26" endline="60" pcid="1">
def regions():
    """
    Get all available regions for the AWS ElastiCache service.

    :rtype: list
    :return: A list of :class:`boto.regioninfo.RegionInfo`
    """
    from boto.elasticache.layer1 import ElastiCacheConnection
    return [RegionInfo(name='us-east-1',
                       endpoint='elasticache.us-east-1.amazonaws.com',
                       connection_cls=ElastiCacheConnection),
            RegionInfo(name='us-west-1',
                       endpoint='elasticache.us-west-1.amazonaws.com',
                       connection_cls=ElastiCacheConnection),
            RegionInfo(name='us-west-2',
                       endpoint='elasticache.us-west-2.amazonaws.com',
                       connection_cls=ElastiCacheConnection),
            RegionInfo(name='eu-west-1',
                       endpoint='elasticache.eu-west-1.amazonaws.com',
                       connection_cls=ElastiCacheConnection),
            RegionInfo(name='ap-northeast-1',
                       endpoint='elasticache.ap-northeast-1.amazonaws.com',
                       connection_cls=ElastiCacheConnection),
            RegionInfo(name='ap-southeast-1',
                       endpoint='elasticache.ap-southeast-1.amazonaws.com',
                       connection_cls=ElastiCacheConnection),
            RegionInfo(name='ap-southeast-2',
                       endpoint='elasticache.ap-southeast-2.amazonaws.com',
                       connection_cls=ElastiCacheConnection),
            RegionInfo(name='sa-east-1',
                       endpoint='elasticache.sa-east-1.amazonaws.com',
                       connection_cls=ElastiCacheConnection),
            ]


</source>
<source file="systems/boto-2.13.2/boto/sns/__init__.py" startline="29" endline="65" pcid="1116">
def regions():
    """
    Get all available regions for the SNS service.

    :rtype: list
    :return: A list of :class:`boto.regioninfo.RegionInfo` instances
    """
    return [RegionInfo(name='us-east-1',
                       endpoint='sns.us-east-1.amazonaws.com',
                       connection_cls=SNSConnection),
            RegionInfo(name='eu-west-1',
                       endpoint='sns.eu-west-1.amazonaws.com',
                       connection_cls=SNSConnection),
            RegionInfo(name='us-gov-west-1',
                       endpoint='sns.us-gov-west-1.amazonaws.com',
                       connection_cls=SNSConnection),
            RegionInfo(name='us-west-1',
                       endpoint='sns.us-west-1.amazonaws.com',
                       connection_cls=SNSConnection),
            RegionInfo(name='sa-east-1',
                       endpoint='sns.sa-east-1.amazonaws.com',
                       connection_cls=SNSConnection),
            RegionInfo(name='us-west-2',
                       endpoint='sns.us-west-2.amazonaws.com',
                       connection_cls=SNSConnection),
            RegionInfo(name='ap-northeast-1',
                       endpoint='sns.ap-northeast-1.amazonaws.com',
                       connection_cls=SNSConnection),
            RegionInfo(name='ap-southeast-1',
                       endpoint='sns.ap-southeast-1.amazonaws.com',
                       connection_cls=SNSConnection),
            RegionInfo(name='ap-southeast-2',
                       endpoint='sns.ap-southeast-2.amazonaws.com',
                       connection_cls=SNSConnection),
            ]


</source>
<source file="systems/boto-2.13.2/boto/emr/__init__.py" startline="35" endline="68" pcid="2057">
def regions():
    """
    Get all available regions for the Amazon Elastic MapReduce service.

    :rtype: list
    :return: A list of :class:`boto.regioninfo.RegionInfo`
    """
    return [RegionInfo(name='us-east-1',
                       endpoint='elasticmapreduce.us-east-1.amazonaws.com',
                       connection_cls=EmrConnection),
            RegionInfo(name='us-west-1',
                       endpoint='elasticmapreduce.us-west-1.amazonaws.com',
                       connection_cls=EmrConnection),
            RegionInfo(name='us-west-2',
                       endpoint='elasticmapreduce.us-west-2.amazonaws.com',
                       connection_cls=EmrConnection),
            RegionInfo(name='ap-northeast-1',
                       endpoint='elasticmapreduce.ap-northeast-1.amazonaws.com',
                       connection_cls=EmrConnection),
            RegionInfo(name='ap-southeast-1',
                       endpoint='elasticmapreduce.ap-southeast-1.amazonaws.com',
                       connection_cls=EmrConnection),
            RegionInfo(name='ap-southeast-2',
                       endpoint='elasticmapreduce.ap-southeast-2.amazonaws.com',
                       connection_cls=EmrConnection),
            RegionInfo(name='eu-west-1',
                       endpoint='elasticmapreduce.eu-west-1.amazonaws.com',
                       connection_cls=EmrConnection),
            RegionInfo(name='sa-east-1',
                       endpoint='elasticmapreduce.sa-east-1.amazonaws.com',
                       connection_cls=EmrConnection),
            ]


</source>
<source file="systems/boto-2.13.2/boto/dynamodb2/__init__.py" startline="27" endline="64" pcid="1851">
def regions():
    """
    Get all available regions for the Amazon DynamoDB service.

    :rtype: list
    :return: A list of :class:`boto.regioninfo.RegionInfo`
    """
    from boto.dynamodb2.layer1 import DynamoDBConnection
    return [RegionInfo(name='us-east-1',
                       endpoint='dynamodb.us-east-1.amazonaws.com',
                       connection_cls=DynamoDBConnection),
            RegionInfo(name='us-gov-west-1',
                       endpoint='dynamodb.us-gov-west-1.amazonaws.com',
                       connection_cls=DynamoDBConnection),
            RegionInfo(name='us-west-1',
                       endpoint='dynamodb.us-west-1.amazonaws.com',
                       connection_cls=DynamoDBConnection),
            RegionInfo(name='us-west-2',
                       endpoint='dynamodb.us-west-2.amazonaws.com',
                       connection_cls=DynamoDBConnection),
            RegionInfo(name='eu-west-1',
                       endpoint='dynamodb.eu-west-1.amazonaws.com',
                       connection_cls=DynamoDBConnection),
            RegionInfo(name='ap-northeast-1',
                       endpoint='dynamodb.ap-northeast-1.amazonaws.com',
                       connection_cls=DynamoDBConnection),
            RegionInfo(name='ap-southeast-1',
                       endpoint='dynamodb.ap-southeast-1.amazonaws.com',
                       connection_cls=DynamoDBConnection),
            RegionInfo(name='ap-southeast-2',
                       endpoint='dynamodb.ap-southeast-2.amazonaws.com',
                       connection_cls=DynamoDBConnection),
            RegionInfo(name='sa-east-1',
                       endpoint='dynamodb.sa-east-1.amazonaws.com',
                       connection_cls=DynamoDBConnection),
            ]


</source>
<source file="systems/boto-2.13.2/boto/elastictranscoder/__init__.py" startline="26" endline="56" pcid="3074">
def regions():
    """
    Get all available regions for the AWS Elastic Transcoder service.

    :rtype: list
    :return: A list of :class:`boto.regioninfo.RegionInfo`
    """
    from boto.elastictranscoder.layer1 import ElasticTranscoderConnection
    cls = ElasticTranscoderConnection
    return [
        RegionInfo(name='us-east-1',
                   endpoint='elastictranscoder.us-east-1.amazonaws.com',
                   connection_cls=cls),
        RegionInfo(name='us-west-1',
                    endpoint='elastictranscoder.us-west-1.amazonaws.com',
                    connection_cls=cls),
        RegionInfo(name='us-west-2',
                    endpoint='elastictranscoder.us-west-2.amazonaws.com',
                    connection_cls=cls),
        RegionInfo(name='ap-northeast-1',
                    endpoint='elastictranscoder.ap-northeast-1.amazonaws.com',
                    connection_cls=cls),
        RegionInfo(name='ap-southeast-1',
                    endpoint='elastictranscoder.ap-southeast-1.amazonaws.com',
                    connection_cls=cls),
        RegionInfo(name='eu-west-1',
                    endpoint='elastictranscoder.eu-west-1.amazonaws.com',
                    connection_cls=cls),
    ]


</source>
<source file="systems/boto-2.13.2/boto/s3/__init__.py" startline="45" endline="82" pcid="3584">
def regions():
    """
    Get all available regions for the Amazon S3 service.

    :rtype: list
    :return: A list of :class:`boto.regioninfo.RegionInfo`
    """
    from .connection import S3Connection
    return [S3RegionInfo(name='us-east-1',
                         endpoint='s3.amazonaws.com',
                         connection_cls=S3Connection),
            S3RegionInfo(name='us-gov-west-1',
                         endpoint='s3-us-gov-west-1.amazonaws.com',
                       connection_cls=S3Connection),
            S3RegionInfo(name='us-west-1',
                         endpoint='s3-us-west-1.amazonaws.com',
                       connection_cls=S3Connection),
            S3RegionInfo(name='us-west-2',
                         endpoint='s3-us-west-2.amazonaws.com',
                         connection_cls=S3Connection),
            S3RegionInfo(name='ap-northeast-1',
                         endpoint='s3-ap-northeast-1.amazonaws.com',
                         connection_cls=S3Connection),
            S3RegionInfo(name='ap-southeast-1',
                         endpoint='s3-ap-southeast-1.amazonaws.com',
                         connection_cls=S3Connection),
            S3RegionInfo(name='ap-southeast-2',
                         endpoint='s3-ap-southeast-2.amazonaws.com',
                         connection_cls=S3Connection),
            S3RegionInfo(name='eu-west-1',
                         endpoint='s3-eu-west-1.amazonaws.com',
                         connection_cls=S3Connection),
            S3RegionInfo(name='sa-east-1',
                         endpoint='s3-sa-east-1.amazonaws.com',
                         connection_cls=S3Connection),
            ]


</source>
<source file="systems/boto-2.13.2/boto/redshift/__init__.py" startline="26" endline="50" pcid="2988">
def regions():
    """
    Get all available regions for the AWS Redshift service.

    :rtype: list
    :return: A list of :class:`boto.regioninfo.RegionInfo`
    """
    from boto.redshift.layer1 import RedshiftConnection
    cls = RedshiftConnection
    return [
        RegionInfo(name='us-east-1',
                   endpoint='redshift.us-east-1.amazonaws.com',
                   connection_cls=cls),
        RegionInfo(name='us-west-2',
                   endpoint='redshift.us-west-2.amazonaws.com',
                   connection_cls=cls),
        RegionInfo(name='eu-west-1',
                   endpoint='redshift.eu-west-1.amazonaws.com',
                   connection_cls=cls),
        RegionInfo(name='ap-northeast-1',
                   endpoint='redshift.ap-northeast-1.amazonaws.com',
                   connection_cls=cls),
    ]


</source>
<source file="systems/boto-2.13.2/boto/glacier/__init__.py" startline="27" endline="52" pcid="2929">
def regions():
    """
    Get all available regions for the Amazon Glacier service.

    :rtype: list
    :return: A list of :class:`boto.regioninfo.RegionInfo`
    """
    from boto.glacier.layer2 import Layer2
    return [RegionInfo(name='us-east-1',
                       endpoint='glacier.us-east-1.amazonaws.com',
                       connection_cls=Layer2),
            RegionInfo(name='us-west-1',
                       endpoint='glacier.us-west-1.amazonaws.com',
                       connection_cls=Layer2),
            RegionInfo(name='us-west-2',
                       endpoint='glacier.us-west-2.amazonaws.com',
                       connection_cls=Layer2),
            RegionInfo(name='ap-northeast-1',
                       endpoint='glacier.ap-northeast-1.amazonaws.com',
                       connection_cls=Layer2),
            RegionInfo(name='eu-west-1',
                       endpoint='glacier.eu-west-1.amazonaws.com',
                       connection_cls=Layer2),
            ]


</source>
</class>

<class classid="2" nclones="2" nlines="10" similarity="100">
<source file="systems/boto-2.13.2/boto/elasticache/layer1.py" startline="50" endline="61" pcid="3">
    def __init__(self, **kwargs):
        region = kwargs.get('region')
        if not region:
            region = RegionInfo(self, self.DefaultRegionName,
                                self.DefaultRegionEndpoint)
        else:
            del kwargs['region']
        kwargs['host'] = region.endpoint
        AWSQueryConnection.__init__(self, **kwargs)
        self.region = region


</source>
<source file="systems/boto-2.13.2/boto/elastictranscoder/layer1.py" startline="50" endline="60" pcid="3076">
    def __init__(self, **kwargs):
        region = kwargs.get('region')
        if not region:
            region = RegionInfo(self, self.DefaultRegionName,
                                self.DefaultRegionEndpoint)
        else:
            del kwargs['region']
        kwargs['host'] = region.endpoint
        AWSAuthConnection.__init__(self, **kwargs)
        self.region = region

</source>
</class>

<class classid="3" nclones="82" nlines="17" similarity="70">
<source file="systems/boto-2.13.2/boto/elasticache/layer1.py" startline="65" endline="101" pcid="5">
    def authorize_cache_security_group_ingress(self,
                                               cache_security_group_name,
                                               ec2_security_group_name,
                                               ec2_security_group_owner_id):
        """
        The AuthorizeCacheSecurityGroupIngress operation allows
        network ingress to a cache security group. Applications using
        ElastiCache must be running on Amazon EC2, and Amazon EC2
        security groups are used as the authorization mechanism.
        You cannot authorize ingress from an Amazon EC2 security group
        in one Region to an ElastiCache cluster in another Region.

        :type cache_security_group_name: string
        :param cache_security_group_name: The cache security group which will
            allow network ingress.

        :type ec2_security_group_name: string
        :param ec2_security_group_name: The Amazon EC2 security group to be
            authorized for ingress to the cache security group.

        :type ec2_security_group_owner_id: string
        :param ec2_security_group_owner_id: The AWS account number of the
            Amazon EC2 security group owner. Note that this is not the same
            thing as an AWS access key ID - you must provide a valid AWS
            account number for this parameter.

        """
        params = {
            'CacheSecurityGroupName': cache_security_group_name,
            'EC2SecurityGroupName': ec2_security_group_name,
            'EC2SecurityGroupOwnerId': ec2_security_group_owner_id,
        }
        return self._make_request(
            action='AuthorizeCacheSecurityGroupIngress',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/elasticache/layer1.py" startline="1619" endline="1652" pcid="34">
    def revoke_cache_security_group_ingress(self, cache_security_group_name,
                                            ec2_security_group_name,
                                            ec2_security_group_owner_id):
        """
        The RevokeCacheSecurityGroupIngress operation revokes ingress
        from a cache security group. Use this operation to disallow
        access from an Amazon EC2 security group that had been
        previously authorized.

        :type cache_security_group_name: string
        :param cache_security_group_name: The name of the cache security group
            to revoke ingress from.

        :type ec2_security_group_name: string
        :param ec2_security_group_name: The name of the Amazon EC2 security
            group to revoke access from.

        :type ec2_security_group_owner_id: string
        :param ec2_security_group_owner_id: The AWS account number of the
            Amazon EC2 security group owner. Note that this is not the same
            thing as an AWS access key ID - you must provide a valid AWS
            account number for this parameter.

        """
        params = {
            'CacheSecurityGroupName': cache_security_group_name,
            'EC2SecurityGroupName': ec2_security_group_name,
            'EC2SecurityGroupOwnerId': ec2_security_group_owner_id,
        }
        return self._make_request(
            action='RevokeCacheSecurityGroupIngress',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/elasticache/layer1.py" startline="391" endline="438" pcid="10">
    def create_replication_group(self, replication_group_id,
                                 primary_cluster_id,
                                 replication_group_description):
        """
        The CreateReplicationGroup operation creates a replication
        group. A replication group is a collection of cache clusters,
        where one of the clusters is a read/write primary and the
        other clusters are read-only replicas. Writes to the primary
        are automatically propagated to the replicas.

        When you create a replication group, you must specify an
        existing cache cluster that is in the primary role. When the
        replication group has been successfully created, you can add
        one or more read replica replicas to it, up to a total of five
        read replicas.

        :type replication_group_id: string
        :param replication_group_id:
        The replication group identifier. This parameter is stored as a
            lowercase string.

        Constraints:


        + Must contain from 1 to 20 alphanumeric characters or hyphens.
        + First character must be a letter.
        + Cannot end with a hyphen or contain two consecutive hyphens.

        :type primary_cluster_id: string
        :param primary_cluster_id: The identifier of the cache cluster that
            will serve as the primary for this replication group. This cache
            cluster must already exist and have a status of available .

        :type replication_group_description: string
        :param replication_group_description: A user-specified description for
            the replication group.

        """
        params = {
            'ReplicationGroupId': replication_group_id,
            'PrimaryClusterId': primary_cluster_id,
            'ReplicationGroupDescription': replication_group_description,
        }
        return self._make_request(
            action='CreateReplicationGroup',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/elasticache/layer1.py" startline="287" endline="319" pcid="7">
    def create_cache_parameter_group(self, cache_parameter_group_name,
                                     cache_parameter_group_family,
                                     description):
        """
        The CreateCacheParameterGroup operation creates a new cache
        parameter group. A cache parameter group is a collection of
        parameters that you apply to all of the nodes in a cache
        cluster.

        :type cache_parameter_group_name: string
        :param cache_parameter_group_name: A user-specified name for the cache
            parameter group.

        :type cache_parameter_group_family: string
        :param cache_parameter_group_family: The name of the cache parameter
            group family the cache parameter group can be used with.
        Valid values are: `memcached1.4` | `redis2.6`

        :type description: string
        :param description: A user-specified description for the cache
            parameter group.

        """
        params = {
            'CacheParameterGroupName': cache_parameter_group_name,
            'CacheParameterGroupFamily': cache_parameter_group_family,
            'Description': description,
        }
        return self._make_request(
            action='CreateCacheParameterGroup',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/redshift/layer1.py" startline="205" endline="238" pcid="2993">
    def authorize_snapshot_access(self, snapshot_identifier,
                                  account_with_restore_access,
                                  snapshot_cluster_identifier=None):
        """
        Authorizes the specified AWS customer account to restore the
        specified snapshot.

        For more information about working with snapshots, go to
        `Amazon Redshift Snapshots`_ in the Amazon Redshift Management
        Guide .

        :type snapshot_identifier: string
        :param snapshot_identifier: The identifier of the snapshot the account
            is authorized to restore.

        :type snapshot_cluster_identifier: string
        :param snapshot_cluster_identifier:

        :type account_with_restore_access: string
        :param account_with_restore_access: The identifier of the AWS customer
            account authorized to restore the specified snapshot.

        """
        params = {
            'SnapshotIdentifier': snapshot_identifier,
            'AccountWithRestoreAccess': account_with_restore_access,
        }
        if snapshot_cluster_identifier is not None:
            params['SnapshotClusterIdentifier'] = snapshot_cluster_identifier
        return self._make_request(
            action='AuthorizeSnapshotAccess',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/redshift/layer1.py" startline="674" endline="712" pcid="2998">
    def create_cluster_snapshot(self, snapshot_identifier,
                                cluster_identifier):
        """
        Creates a manual snapshot of the specified cluster. The
        cluster must be in the "available" state.

        For more information about working with snapshots, go to
        `Amazon Redshift Snapshots`_ in the Amazon Redshift Management
        Guide .

        :type snapshot_identifier: string
        :param snapshot_identifier: A unique identifier for the snapshot that
            you are requesting. This identifier must be unique for all
            snapshots within the AWS account.
        Constraints:


        + Cannot be null, empty, or blank
        + Must contain from 1 to 255 alphanumeric characters or hyphens
        + First character must be a letter
        + Cannot end with a hyphen or contain two consecutive hyphens


        Example: `my-snapshot-id`

        :type cluster_identifier: string
        :param cluster_identifier: The cluster identifier for which you want a
            snapshot.

        """
        params = {
            'SnapshotIdentifier': snapshot_identifier,
            'ClusterIdentifier': cluster_identifier,
        }
        return self._make_request(
            action='CreateClusterSnapshot',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/redshift/layer1.py" startline="579" endline="636" pcid="2996">
    def create_cluster_parameter_group(self, parameter_group_name,
                                       parameter_group_family, description):
        """
        Creates an Amazon Redshift parameter group.

        Creating parameter groups is independent of creating clusters.
        You can associate a cluster with a parameter group when you
        create the cluster. You can also associate an existing cluster
        with a parameter group after the cluster is created by using
        ModifyCluster.

        Parameters in the parameter group define specific behavior
        that applies to the databases you create on the cluster. For
        more information about managing parameter groups, go to
        `Amazon Redshift Parameter Groups`_ in the Amazon Redshift
        Management Guide .

        :type parameter_group_name: string
        :param parameter_group_name:
        The name of the cluster parameter group.

        Constraints:


        + Must be 1 to 255 alphanumeric characters or hyphens
        + First character must be a letter.
        + Cannot end with a hyphen or contain two consecutive hyphens.
        + Must be unique withing your AWS account.


        This value is stored as a lower-case string.

        :type parameter_group_family: string
        :param parameter_group_family: The Amazon Redshift engine version to
            which the cluster parameter group applies. The cluster engine
            version determines the set of parameters.
        To get a list of valid parameter group family names, you can call
            DescribeClusterParameterGroups. By default, Amazon Redshift returns
            a list of all the parameter groups that are owned by your AWS
            account, including the default parameter groups for each Amazon
            Redshift engine version. The parameter group family names
            associated with the default parameter groups provide you the valid
            values. For example, a valid family name is "redshift-1.0".

        :type description: string
        :param description: A description of the parameter group.

        """
        params = {
            'ParameterGroupName': parameter_group_name,
            'ParameterGroupFamily': parameter_group_family,
            'Description': description,
        }
        return self._make_request(
            action='CreateClusterParameterGroup',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/elasticache/layer1.py" startline="320" endline="353" pcid="8">
    def create_cache_security_group(self, cache_security_group_name,
                                    description):
        """
        The CreateCacheSecurityGroup operation creates a new cache
        security group. Use a cache security group to control access
        to one or more cache clusters.

        Cache security groups are only used when you are creating a
        cluster outside of an Amazon Virtual Private Cloud (VPC). If
        you are creating a cluster inside of a VPC, use a cache subnet
        group instead. For more information, see
        CreateCacheSubnetGroup .

        :type cache_security_group_name: string
        :param cache_security_group_name: A name for the cache security group.
            This value is stored as a lowercase string.
        Constraints: Must contain no more than 255 alphanumeric characters.
            Must not be the word "Default".

        Example: `mysecuritygroup`

        :type description: string
        :param description: A description for the cache security group.

        """
        params = {
            'CacheSecurityGroupName': cache_security_group_name,
            'Description': description,
        }
        return self._make_request(
            action='CreateCacheSecurityGroup',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/redshift/layer1.py" startline="2141" endline="2175" pcid="3026">
    def revoke_snapshot_access(self, snapshot_identifier,
                               account_with_restore_access,
                               snapshot_cluster_identifier=None):
        """
        Removes the ability of the specified AWS customer account to
        restore the specified snapshot. If the account is currently
        restoring the snapshot, the restore will run to completion.

        For more information about working with snapshots, go to
        `Amazon Redshift Snapshots`_ in the Amazon Redshift Management
        Guide .

        :type snapshot_identifier: string
        :param snapshot_identifier: The identifier of the snapshot that the
            account can no longer access.

        :type snapshot_cluster_identifier: string
        :param snapshot_cluster_identifier:

        :type account_with_restore_access: string
        :param account_with_restore_access: The identifier of the AWS customer
            account that can no longer restore the specified snapshot.

        """
        params = {
            'SnapshotIdentifier': snapshot_identifier,
            'AccountWithRestoreAccess': account_with_restore_access,
        }
        if snapshot_cluster_identifier is not None:
            params['SnapshotClusterIdentifier'] = snapshot_cluster_identifier
        return self._make_request(
            action='RevokeSnapshotAccess',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/redshift/layer1.py" startline="637" endline="673" pcid="2997">
    def create_cluster_security_group(self, cluster_security_group_name,
                                      description):
        """
        Creates a new Amazon Redshift security group. You use security
        groups to control access to non-VPC clusters.

        For information about managing security groups, go to`Amazon
        Redshift Cluster Security Groups`_ in the Amazon Redshift
        Management Guide .

        :type cluster_security_group_name: string
        :param cluster_security_group_name: The name for the security group.
            Amazon Redshift stores the value as a lowercase string.
        Constraints:


        + Must contain no more than 255 alphanumeric characters or hyphens.
        + Must not be "Default".
        + Must be unique for all security groups that are created by your AWS
              account.


        Example: `examplesecuritygroup`

        :type description: string
        :param description: A description for the security group.

        """
        params = {
            'ClusterSecurityGroupName': cluster_security_group_name,
            'Description': description,
        }
        return self._make_request(
            action='CreateClusterSecurityGroup',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/redshift/layer1.py" startline="239" endline="295" pcid="2994">
    def copy_cluster_snapshot(self, source_snapshot_identifier,
                              target_snapshot_identifier,
                              source_snapshot_cluster_identifier=None):
        """
        Copies the specified automated cluster snapshot to a new
        manual cluster snapshot. The source must be an automated
        snapshot and it must be in the available state.

        When you delete a cluster, Amazon Redshift deletes any
        automated snapshots of the cluster. Also, when the retention
        period of the snapshot expires, Amazon Redshift automatically
        deletes it. If you want to keep an automated snapshot for a
        longer period, you can make a manual copy of the snapshot.
        Manual snapshots are retained until you delete them.

        For more information about working with snapshots, go to
        `Amazon Redshift Snapshots`_ in the Amazon Redshift Management
        Guide .

        :type source_snapshot_identifier: string
        :param source_snapshot_identifier:
        The identifier for the source snapshot.

        Constraints:


        + Must be the identifier for a valid automated snapshot whose state is
              "available".

        :type source_snapshot_cluster_identifier: string
        :param source_snapshot_cluster_identifier:

        :type target_snapshot_identifier: string
        :param target_snapshot_identifier:
        The identifier given to the new manual snapshot.

        Constraints:


        + Cannot be null, empty, or blank.
        + Must contain from 1 to 255 alphanumeric characters or hyphens.
        + First character must be a letter.
        + Cannot end with a hyphen or contain two consecutive hyphens.
        + Must be unique for the AWS account that is making the request.

        """
        params = {
            'SourceSnapshotIdentifier': source_snapshot_identifier,
            'TargetSnapshotIdentifier': target_snapshot_identifier,
        }
        if source_snapshot_cluster_identifier is not None:
            params['SourceSnapshotClusterIdentifier'] = source_snapshot_cluster_identifier
        return self._make_request(
            action='CopyClusterSnapshot',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/elasticache/layer1.py" startline="1506" endline="1540" pcid="31">
    def purchase_reserved_cache_nodes_offering(self,
                                               reserved_cache_nodes_offering_id,
                                               reserved_cache_node_id=None,
                                               cache_node_count=None):
        """
        The PurchaseReservedCacheNodesOffering operation allows you to
        purchase a reserved cache node offering.

        :type reserved_cache_nodes_offering_id: string
        :param reserved_cache_nodes_offering_id: The ID of the reserved cache
            node offering to purchase.
        Example: 438012d3-4052-4cc7-b2e3-8d3372e0e706

        :type reserved_cache_node_id: string
        :param reserved_cache_node_id: A customer-specified identifier to track
            this reservation.
        Example: myreservationID

        :type cache_node_count: integer
        :param cache_node_count: The number of cache node instances to reserve.
        Default: `1`

        """
        params = {
            'ReservedCacheNodesOfferingId': reserved_cache_nodes_offering_id,
        }
        if reserved_cache_node_id is not None:
            params['ReservedCacheNodeId'] = reserved_cache_node_id
        if cache_node_count is not None:
            params['CacheNodeCount'] = cache_node_count
        return self._make_request(
            action='PurchaseReservedCacheNodesOffering',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/redshift/layer1.py" startline="1883" endline="1916" pcid="3021">
    def purchase_reserved_node_offering(self, reserved_node_offering_id,
                                        node_count=None):
        """
        Allows you to purchase reserved nodes. Amazon Redshift offers
        a predefined set of reserved node offerings. You can purchase
        one of the offerings. You can call the
        DescribeReservedNodeOfferings API to obtain the available
        reserved node offerings. You can call this API by providing a
        specific reserved node offering and the number of nodes you
        want to reserve.

        For more information about managing parameter groups, go to
        `Purchasing Reserved Nodes`_ in the Amazon Redshift Management
        Guide .

        :type reserved_node_offering_id: string
        :param reserved_node_offering_id: The unique identifier of the reserved
            node offering you want to purchase.

        :type node_count: integer
        :param node_count: The number of reserved nodes you want to purchase.
        Default: `1`

        """
        params = {
            'ReservedNodeOfferingId': reserved_node_offering_id,
        }
        if node_count is not None:
            params['NodeCount'] = node_count
        return self._make_request(
            action='PurchaseReservedNodeOffering',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/redshift/layer1.py" startline="713" endline="758" pcid="2999">
    def create_cluster_subnet_group(self, cluster_subnet_group_name,
                                    description, subnet_ids):
        """
        Creates a new Amazon Redshift subnet group. You must provide a
        list of one or more subnets in your existing Amazon Virtual
        Private Cloud (Amazon VPC) when creating Amazon Redshift
        subnet group.

        For information about subnet groups, go to`Amazon Redshift
        Cluster Subnet Groups`_ in the Amazon Redshift Management
        Guide .

        :type cluster_subnet_group_name: string
        :param cluster_subnet_group_name: The name for the subnet group. Amazon
            Redshift stores the value as a lowercase string.
        Constraints:


        + Must contain no more than 255 alphanumeric characters or hyphens.
        + Must not be "Default".
        + Must be unique for all subnet groups that are created by your AWS
              account.


        Example: `examplesubnetgroup`

        :type description: string
        :param description: A description for the subnet group.

        :type subnet_ids: list
        :param subnet_ids: An array of VPC subnet IDs. A maximum of 20 subnets
            can be modified in a single request.

        """
        params = {
            'ClusterSubnetGroupName': cluster_subnet_group_name,
            'Description': description,
        }
        self.build_list_params(params,
                               subnet_ids,
                               'SubnetIds.member')
        return self._make_request(
            action='CreateClusterSubnetGroup',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/elasticache/layer1.py" startline="354" endline="390" pcid="9">
    def create_cache_subnet_group(self, cache_subnet_group_name,
                                  cache_subnet_group_description, subnet_ids):
        """
        The CreateCacheSubnetGroup operation creates a new cache
        subnet group.

        Use this parameter only when you are creating a cluster in an
        Amazon Virtual Private Cloud (VPC).

        :type cache_subnet_group_name: string
        :param cache_subnet_group_name: A name for the cache subnet group. This
            value is stored as a lowercase string.
        Constraints: Must contain no more than 255 alphanumeric characters or
            hyphens.

        Example: `mysubnetgroup`

        :type cache_subnet_group_description: string
        :param cache_subnet_group_description: A description for the cache
            subnet group.

        :type subnet_ids: list
        :param subnet_ids: A list of VPC subnet IDs for the cache subnet group.

        """
        params = {
            'CacheSubnetGroupName': cache_subnet_group_name,
            'CacheSubnetGroupDescription': cache_subnet_group_description,
        }
        self.build_list_params(params,
                               subnet_ids,
                               'SubnetIds.member')
        return self._make_request(
            action='CreateCacheSubnetGroup',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/elasticache/layer1.py" startline="851" endline="890" pcid="22">
    def describe_engine_default_parameters(self,
                                           cache_parameter_group_family,
                                           max_records=None, marker=None):
        """
        The DescribeEngineDefaultParameters operation returns the
        default engine and system parameter information for the
        specified cache engine.

        :type cache_parameter_group_family: string
        :param cache_parameter_group_family: The name of the cache parameter
            group family. Valid values are: `memcached1.4` | `redis2.6`

        :type max_records: integer
        :param max_records: The maximum number of records to include in the
            response. If more records exist than the specified `MaxRecords`
            value, a marker is included in the response so that the remaining
            results can be retrieved.
        Default: 100

        Constraints: minimum 20; maximum 100.

        :type marker: string
        :param marker: An optional marker returned from a prior request. Use
            this marker for pagination of results from this operation. If this
            parameter is specified, the response includes only records beyond
            the marker, up to the value specified by MaxRecords .

        """
        params = {
            'CacheParameterGroupFamily': cache_parameter_group_family,
        }
        if max_records is not None:
            params['MaxRecords'] = max_records
        if marker is not None:
            params['Marker'] = marker
        return self._make_request(
            action='DescribeEngineDefaultParameters',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/elasticache/layer1.py" startline="727" endline="770" pcid="19">
    def describe_cache_parameters(self, cache_parameter_group_name,
                                  source=None, max_records=None, marker=None):
        """
        The DescribeCacheParameters operation returns the detailed
        parameter list for a particular cache parameter group.

        :type cache_parameter_group_name: string
        :param cache_parameter_group_name: The name of a specific cache
            parameter group to return details for.

        :type source: string
        :param source: The parameter types to return.
        Valid values: `user` | `system` | `engine-default`

        :type max_records: integer
        :param max_records: The maximum number of records to include in the
            response. If more records exist than the specified `MaxRecords`
            value, a marker is included in the response so that the remaining
            results can be retrieved.
        Default: 100

        Constraints: minimum 20; maximum 100.

        :type marker: string
        :param marker: An optional marker returned from a prior request. Use
            this marker for pagination of results from this operation. If this
            parameter is specified, the response includes only records beyond
            the marker, up to the value specified by MaxRecords .

        """
        params = {
            'CacheParameterGroupName': cache_parameter_group_name,
        }
        if source is not None:
            params['Source'] = source
        if max_records is not None:
            params['MaxRecords'] = max_records
        if marker is not None:
            params['Marker'] = marker
        return self._make_request(
            action='DescribeCacheParameters',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/redshift/layer1.py" startline="148" endline="204" pcid="2992">
    def authorize_cluster_security_group_ingress(self,
                                                 cluster_security_group_name,
                                                 cidrip=None,
                                                 ec2_security_group_name=None,
                                                 ec2_security_group_owner_id=None):
        """
        Adds an inbound (ingress) rule to an Amazon Redshift security
        group. Depending on whether the application accessing your
        cluster is running on the Internet or an EC2 instance, you can
        authorize inbound access to either a Classless Interdomain
        Routing (CIDR) IP address range or an EC2 security group. You
        can add as many as 20 ingress rules to an Amazon Redshift
        security group.
        The EC2 security group must be defined in the AWS region where
        the cluster resides.
        For an overview of CIDR blocks, see the Wikipedia article on
        `Classless Inter-Domain Routing`_.

        You must also associate the security group with a cluster so
        that clients running on these IP addresses or the EC2 instance
        are authorized to connect to the cluster. For information
        about managing security groups, go to `Working with Security
        Groups`_ in the Amazon Redshift Management Guide .

        :type cluster_security_group_name: string
        :param cluster_security_group_name: The name of the security group to
            which the ingress rule is added.

        :type cidrip: string
        :param cidrip: The IP range to be added the Amazon Redshift security
            group.

        :type ec2_security_group_name: string
        :param ec2_security_group_name: The EC2 security group to be added the
            Amazon Redshift security group.

        :type ec2_security_group_owner_id: string
        :param ec2_security_group_owner_id: The AWS account number of the owner
            of the security group specified by the EC2SecurityGroupName
            parameter. The AWS Access Key ID is not an acceptable value.
        Example: `111122223333`

        """
        params = {
            'ClusterSecurityGroupName': cluster_security_group_name,
        }
        if cidrip is not None:
            params['CIDRIP'] = cidrip
        if ec2_security_group_name is not None:
            params['EC2SecurityGroupName'] = ec2_security_group_name
        if ec2_security_group_owner_id is not None:
            params['EC2SecurityGroupOwnerId'] = ec2_security_group_owner_id
        return self._make_request(
            action='AuthorizeClusterSecurityGroupIngress',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/redshift/layer1.py" startline="1497" endline="1547" pcid="3015">
    def describe_reserved_node_offerings(self,
                                         reserved_node_offering_id=None,
                                         max_records=None, marker=None):
        """
        Returns a list of the available reserved node offerings by
        Amazon Redshift with their descriptions including the node
        type, the fixed and recurring costs of reserving the node and
        duration the node will be reserved for you. These descriptions
        help you determine which reserve node offering you want to
        purchase. You then use the unique offering ID in you call to
        PurchaseReservedNodeOffering to reserve one or more nodes for
        your Amazon Redshift cluster.

        For more information about managing parameter groups, go to
        `Purchasing Reserved Nodes`_ in the Amazon Redshift Management
        Guide .

        :type reserved_node_offering_id: string
        :param reserved_node_offering_id: The unique identifier for the
            offering.

        :type max_records: integer
        :param max_records: The maximum number of records to include in the
            response. If more records exist than the specified `MaxRecords`
            value, a marker is included in the response so that the remaining
            results may be retrieved.
        Default: `100`

        Constraints: minimum 20, maximum 100.

        :type marker: string
        :param marker: An optional marker returned by a previous
            DescribeReservedNodeOfferings request to indicate the first
            offering that the request will return.
        You can specify either a **Marker** parameter or a
            **ClusterIdentifier** parameter in a DescribeClusters request, but
            not both.

        """
        params = {}
        if reserved_node_offering_id is not None:
            params['ReservedNodeOfferingId'] = reserved_node_offering_id
        if max_records is not None:
            params['MaxRecords'] = max_records
        if marker is not None:
            params['Marker'] = marker
        return self._make_request(
            action='DescribeReservedNodeOfferings',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/redshift/layer1.py" startline="2089" endline="2140" pcid="3025">
    def revoke_cluster_security_group_ingress(self,
                                              cluster_security_group_name,
                                              cidrip=None,
                                              ec2_security_group_name=None,
                                              ec2_security_group_owner_id=None):
        """
        Revokes an ingress rule in an Amazon Redshift security group
        for a previously authorized IP range or Amazon EC2 security
        group. To add an ingress rule, see
        AuthorizeClusterSecurityGroupIngress. For information about
        managing security groups, go to`Amazon Redshift Cluster
        Security Groups`_ in the Amazon Redshift Management Guide .

        :type cluster_security_group_name: string
        :param cluster_security_group_name: The name of the security Group from
            which to revoke the ingress rule.

        :type cidrip: string
        :param cidrip: The IP range for which to revoke access. This range must
            be a valid Classless Inter-Domain Routing (CIDR) block of IP
            addresses. If `CIDRIP` is specified, `EC2SecurityGroupName` and
            `EC2SecurityGroupOwnerId` cannot be provided.

        :type ec2_security_group_name: string
        :param ec2_security_group_name: The name of the EC2 Security Group
            whose access is to be revoked. If `EC2SecurityGroupName` is
            specified, `EC2SecurityGroupOwnerId` must also be provided and
            `CIDRIP` cannot be provided.

        :type ec2_security_group_owner_id: string
        :param ec2_security_group_owner_id: The AWS account number of the owner
            of the security group specified in the `EC2SecurityGroupName`
            parameter. The AWS access key ID is not an acceptable value. If
            `EC2SecurityGroupOwnerId` is specified, `EC2SecurityGroupName` must
            also be provided. and `CIDRIP` cannot be provided.
        Example: `111122223333`

        """
        params = {
            'ClusterSecurityGroupName': cluster_security_group_name,
        }
        if cidrip is not None:
            params['CIDRIP'] = cidrip
        if ec2_security_group_name is not None:
            params['EC2SecurityGroupName'] = ec2_security_group_name
        if ec2_security_group_owner_id is not None:
            params['EC2SecurityGroupOwnerId'] = ec2_security_group_owner_id
        return self._make_request(
            action='RevokeClusterSecurityGroupIngress',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/redshift/layer1.py" startline="1023" endline="1070" pcid="3007">
    def describe_cluster_security_groups(self,
                                         cluster_security_group_name=None,
                                         max_records=None, marker=None):
        """
        Returns information about Amazon Redshift security groups. If
        the name of a security group is specified, the response will
        contain only information about only that security group.

        For information about managing security groups, go to`Amazon
        Redshift Cluster Security Groups`_ in the Amazon Redshift
        Management Guide .

        :type cluster_security_group_name: string
        :param cluster_security_group_name: The name of a cluster security
            group for which you are requesting details. You can specify either
            the **Marker** parameter or a **ClusterSecurityGroupName**
            parameter, but not both.
        Example: `securitygroup1`

        :type max_records: integer
        :param max_records: The maximum number of records to be included in the
            response. If more records exist than the specified `MaxRecords`
            value, a marker is included in the response, which you can use in a
            subsequent DescribeClusterSecurityGroups request.
        Default: `100`

        Constraints: Value must be at least 20 and no more than 100.

        :type marker: string
        :param marker: An optional marker returned by a previous
            DescribeClusterSecurityGroups request to indicate the first
            security group that the current request will return. You can
            specify either the **Marker** parameter or a
            **ClusterSecurityGroupName** parameter, but not both.

        """
        params = {}
        if cluster_security_group_name is not None:
            params['ClusterSecurityGroupName'] = cluster_security_group_name
        if max_records is not None:
            params['MaxRecords'] = max_records
        if marker is not None:
            params['Marker'] = marker
        return self._make_request(
            action='DescribeClusterSecurityGroups',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/elasticache/layer1.py" startline="686" endline="726" pcid="18">
    def describe_cache_parameter_groups(self,
                                        cache_parameter_group_name=None,
                                        max_records=None, marker=None):
        """
        The DescribeCacheParameterGroups operation returns a list of
        cache parameter group descriptions. If a cache parameter group
        name is specified, the list will contain only the descriptions
        for that group.

        :type cache_parameter_group_name: string
        :param cache_parameter_group_name: The name of a specific cache
            parameter group to return details for.

        :type max_records: integer
        :param max_records: The maximum number of records to include in the
            response. If more records exist than the specified `MaxRecords`
            value, a marker is included in the response so that the remaining
            results can be retrieved.
        Default: 100

        Constraints: minimum 20; maximum 100.

        :type marker: string
        :param marker: An optional marker returned from a prior request. Use
            this marker for pagination of results from this operation. If this
            parameter is specified, the response includes only records beyond
            the marker, up to the value specified by MaxRecords .

        """
        params = {}
        if cache_parameter_group_name is not None:
            params['CacheParameterGroupName'] = cache_parameter_group_name
        if max_records is not None:
            params['MaxRecords'] = max_records
        if marker is not None:
            params['Marker'] = marker
        return self._make_request(
            action='DescribeCacheParameterGroups',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/redshift/layer1.py" startline="1850" endline="1882" pcid="3020">
    def modify_cluster_subnet_group(self, cluster_subnet_group_name,
                                    subnet_ids, description=None):
        """
        Modifies a cluster subnet group to include the specified list
        of VPC subnets. The operation replaces the existing list of
        subnets with the new list of subnets.

        :type cluster_subnet_group_name: string
        :param cluster_subnet_group_name: The name of the subnet group to be
            modified.

        :type description: string
        :param description: A text description of the subnet group to be
            modified.

        :type subnet_ids: list
        :param subnet_ids: An array of VPC subnet IDs. A maximum of 20 subnets
            can be modified in a single request.

        """
        params = {
            'ClusterSubnetGroupName': cluster_subnet_group_name,
        }
        self.build_list_params(params,
                               subnet_ids,
                               'SubnetIds.member')
        if description is not None:
            params['Description'] = description
        return self._make_request(
            action='ModifyClusterSubnetGroup',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/elasticache/layer1.py" startline="963" endline="1004" pcid="24">
    def describe_replication_groups(self, replication_group_id=None,
                                    max_records=None, marker=None):
        """
        The DescribeReplicationGroups operation returns information
        about a particular replication group. If no identifier is
        specified, DescribeReplicationGroups returns information about
        all replication groups.

        :type replication_group_id: string
        :param replication_group_id: The identifier for the replication group
            to be described. This parameter is not case sensitive.
        If you do not specify this parameter, information about all replication
            groups is returned.

        :type max_records: integer
        :param max_records: The maximum number of records to include in the
            response. If more records exist than the specified `MaxRecords`
            value, a marker is included in the response so that the remaining
            results can be retrieved.
        Default: 100

        Constraints: minimum 20; maximum 100.

        :type marker: string
        :param marker: An optional marker returned from a prior request. Use
            this marker for pagination of results from this operation. If this
            parameter is specified, the response includes only records beyond
            the marker, up to the value specified by MaxRecords .

        """
        params = {}
        if replication_group_id is not None:
            params['ReplicationGroupId'] = replication_group_id
        if max_records is not None:
            params['MaxRecords'] = max_records
        if marker is not None:
            params['Marker'] = marker
        return self._make_request(
            action='DescribeReplicationGroups',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/redshift/layer1.py" startline="1548" endline="1582" pcid="3016">
    def describe_reserved_nodes(self, reserved_node_id=None,
                                max_records=None, marker=None):
        """
        Returns the descriptions of the reserved nodes.

        :type reserved_node_id: string
        :param reserved_node_id: Identifier for the node reservation.

        :type max_records: integer
        :param max_records: The maximum number of records to include in the
            response. If more records exist than the specified `MaxRecords`
            value, a marker is included in the response so that the remaining
            results may be retrieved.
        Default: `100`

        Constraints: minimum 20, maximum 100.

        :type marker: string
        :param marker: An optional marker returned by a previous
            DescribeReservedNodes request to indicate the first parameter group
            that the current request will return.

        """
        params = {}
        if reserved_node_id is not None:
            params['ReservedNodeId'] = reserved_node_id
        if max_records is not None:
            params['MaxRecords'] = max_records
        if marker is not None:
            params['Marker'] = marker
        return self._make_request(
            action='DescribeReservedNodes',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/redshift/layer1.py" startline="1252" endline="1296" pcid="3011">
    def describe_clusters(self, cluster_identifier=None, max_records=None,
                          marker=None):
        """
        Returns properties of provisioned clusters including general
        cluster properties, cluster database properties, maintenance
        and backup properties, and security and access properties.
        This operation supports pagination. For more information about
        managing clusters, go to `Amazon Redshift Clusters`_ in the
        Amazon Redshift Management Guide .

        :type cluster_identifier: string
        :param cluster_identifier: The unique identifier of a cluster whose
            properties you are requesting. This parameter isn't case sensitive.
        The default is that all clusters defined for an account are returned.

        :type max_records: integer
        :param max_records: The maximum number of records that the response can
            include. If more records exist than the specified `MaxRecords`
            value, a `marker` is included in the response that can be used in a
            new **DescribeClusters** request to continue listing results.
        Default: `100`

        Constraints: Value must be at least 20 and no more than 100.

        :type marker: string
        :param marker: An optional marker returned by a previous
            **DescribeClusters** request to indicate the first cluster that the
            current **DescribeClusters** request will return.
        You can specify either a **Marker** parameter or a
            **ClusterIdentifier** parameter in a **DescribeClusters** request,
            but not both.

        """
        params = {}
        if cluster_identifier is not None:
            params['ClusterIdentifier'] = cluster_identifier
        if max_records is not None:
            params['MaxRecords'] = max_records
        if marker is not None:
            params['Marker'] = marker
        return self._make_request(
            action='DescribeClusters',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/redshift/layer1.py" startline="1157" endline="1196" pcid="3009">
    def describe_cluster_subnet_groups(self, cluster_subnet_group_name=None,
                                       max_records=None, marker=None):
        """
        Returns one or more cluster subnet group objects, which
        contain metadata about your cluster subnet groups. By default,
        this operation returns information about all cluster subnet
        groups that are defined in you AWS account.

        :type cluster_subnet_group_name: string
        :param cluster_subnet_group_name: The name of the cluster subnet group
            for which information is requested.

        :type max_records: integer
        :param max_records: The maximum number of cluster subnet group records
            to include in the response. If more records exist than the
            specified `MaxRecords` value, the response returns a marker that
            you can use in a subsequent DescribeClusterSubnetGroups request in
            order to retrieve the next set of cluster subnet group records.
        Default: 100

        Constraints: Must be at least 20 and no more than 100.

        :type marker: string
        :param marker: An optional marker returned by a previous
            DescribeClusterSubnetGroups request to indicate the first cluster
            subnet group that the current request will return.

        """
        params = {}
        if cluster_subnet_group_name is not None:
            params['ClusterSubnetGroupName'] = cluster_subnet_group_name
        if max_records is not None:
            params['MaxRecords'] = max_records
        if marker is not None:
            params['Marker'] = marker
        return self._make_request(
            action='DescribeClusterSubnetGroups',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/redshift/layer1.py" startline="963" endline="1022" pcid="3006">
    def describe_cluster_parameters(self, parameter_group_name, source=None,
                                    max_records=None, marker=None):
        """
        Returns a detailed list of parameters contained within the
        specified Amazon Redshift parameter group. For each parameter
        the response includes information such as parameter name,
        description, data type, value, whether the parameter value is
        modifiable, and so on.

        You can specify source filter to retrieve parameters of only
        specific type. For example, to retrieve parameters that were
        modified by a user action such as from
        ModifyClusterParameterGroup, you can specify source equal to
        user .

        For more information about managing parameter groups, go to
        `Amazon Redshift Parameter Groups`_ in the Amazon Redshift
        Management Guide .

        :type parameter_group_name: string
        :param parameter_group_name: The name of a cluster parameter group for
            which to return details.

        :type source: string
        :param source: The parameter types to return. Specify `user` to show
            parameters that are different form the default. Similarly, specify
            `engine-default` to show parameters that are the same as the
            default parameter group.
        Default: All parameter types returned.

        Valid Values: `user` | `engine-default`

        :type max_records: integer
        :param max_records: The maximum number of records to include in the
            response. If more records exist than the specified `MaxRecords`
            value, response includes a marker that you can specify in your
            subsequent request to retrieve remaining result.
        Default: `100`

        Constraints: Value must be at least 20 and no more than 100.

        :type marker: string
        :param marker: An optional marker returned from a previous
            **DescribeClusterParameters** request. If this parameter is
            specified, the response includes only records beyond the specified
            marker, up to the value specified by `MaxRecords`.

        """
        params = {'ParameterGroupName': parameter_group_name, }
        if source is not None:
            params['Source'] = source
        if max_records is not None:
            params['MaxRecords'] = max_records
        if marker is not None:
            params['Marker'] = marker
        return self._make_request(
            action='DescribeClusterParameters',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/redshift/layer1.py" startline="916" endline="962" pcid="3005">
    def describe_cluster_parameter_groups(self, parameter_group_name=None,
                                          max_records=None, marker=None):
        """
        Returns a list of Amazon Redshift parameter groups, including
        parameter groups you created and the default parameter group.
        For each parameter group, the response includes the parameter
        group name, description, and parameter group family name. You
        can optionally specify a name to retrieve the description of a
        specific parameter group.

        For more information about managing parameter groups, go to
        `Amazon Redshift Parameter Groups`_ in the Amazon Redshift
        Management Guide .

        :type parameter_group_name: string
        :param parameter_group_name: The name of a specific parameter group for
            which to return details. By default, details about all parameter
            groups and the default parameter group are returned.

        :type max_records: integer
        :param max_records: The maximum number of parameter group records to
            include in the response. If more records exist than the specified
            `MaxRecords` value, the response includes a marker that you can use
            in a subsequent DescribeClusterParameterGroups request to retrieve
            the next set of records.
        Default: `100`

        Constraints: Value must be at least 20 and no more than 100.

        :type marker: string
        :param marker: An optional marker returned by a previous
            DescribeClusterParameterGroups request to indicate the first
            parameter group that the current request will return.

        """
        params = {}
        if parameter_group_name is not None:
            params['ParameterGroupName'] = parameter_group_name
        if max_records is not None:
            params['MaxRecords'] = max_records
        if marker is not None:
            params['Marker'] = marker
        return self._make_request(
            action='DescribeClusterParameterGroups',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/elasticache/layer1.py" startline="771" endline="810" pcid="20">
    def describe_cache_security_groups(self, cache_security_group_name=None,
                                       max_records=None, marker=None):
        """
        The DescribeCacheSecurityGroups operation returns a list of
        cache security group descriptions. If a cache security group
        name is specified, the list will contain only the description
        of that group.

        :type cache_security_group_name: string
        :param cache_security_group_name: The name of the cache security group
            to return details for.

        :type max_records: integer
        :param max_records: The maximum number of records to include in the
            response. If more records exist than the specified `MaxRecords`
            value, a marker is included in the response so that the remaining
            results can be retrieved.
        Default: 100

        Constraints: minimum 20; maximum 100.

        :type marker: string
        :param marker: An optional marker returned from a prior request. Use
            this marker for pagination of results from this operation. If this
            parameter is specified, the response includes only records beyond
            the marker, up to the value specified by MaxRecords .

        """
        params = {}
        if cache_security_group_name is not None:
            params['CacheSecurityGroupName'] = cache_security_group_name
        if max_records is not None:
            params['MaxRecords'] = max_records
        if marker is not None:
            params['Marker'] = marker
        return self._make_request(
            action='DescribeCacheSecurityGroups',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/elasticache/layer1.py" startline="811" endline="850" pcid="21">
    def describe_cache_subnet_groups(self, cache_subnet_group_name=None,
                                     max_records=None, marker=None):
        """
        The DescribeCacheSubnetGroups operation returns a list of
        cache subnet group descriptions. If a subnet group name is
        specified, the list will contain only the description of that
        group.

        :type cache_subnet_group_name: string
        :param cache_subnet_group_name: The name of the cache subnet group to
            return details for.

        :type max_records: integer
        :param max_records: The maximum number of records to include in the
            response. If more records exist than the specified `MaxRecords`
            value, a marker is included in the response so that the remaining
            results can be retrieved.
        Default: 100

        Constraints: minimum 20; maximum 100.

        :type marker: string
        :param marker: An optional marker returned from a prior request. Use
            this marker for pagination of results from this operation. If this
            parameter is specified, the response includes only records beyond
            the marker, up to the value specified by MaxRecords .

        """
        params = {}
        if cache_subnet_group_name is not None:
            params['CacheSubnetGroupName'] = cache_subnet_group_name
        if max_records is not None:
            params['MaxRecords'] = max_records
        if marker is not None:
            params['Marker'] = marker
        return self._make_request(
            action='DescribeCacheSubnetGroups',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/redshift/layer1.py" startline="1197" endline="1251" pcid="3010">
    def describe_cluster_versions(self, cluster_version=None,
                                  cluster_parameter_group_family=None,
                                  max_records=None, marker=None):
        """
        Returns descriptions of the available Amazon Redshift cluster
        versions. You can call this operation even before creating any
        clusters to learn more about the Amazon Redshift versions. For
        more information about managing clusters, go to `Amazon
        Redshift Clusters`_ in the Amazon Redshift Management Guide

        :type cluster_version: string
        :param cluster_version: The specific cluster version to return.
        Example: `1.0`

        :type cluster_parameter_group_family: string
        :param cluster_parameter_group_family:
        The name of a specific cluster parameter group family to return details
            for.

        Constraints:


        + Must be 1 to 255 alphanumeric characters
        + First character must be a letter
        + Cannot end with a hyphen or contain two consecutive hyphens

        :type max_records: integer
        :param max_records: The maximum number of records to include in the
            response. If more than the `MaxRecords` value is available, a
            marker is included in the response so that the following results
            can be retrieved.
        Default: `100`

        Constraints: Value must be at least 20 and no more than 100.

        :type marker: string
        :param marker: The marker returned from a previous request. If this
            parameter is specified, the response includes records beyond the
            marker only, up to `MaxRecords`.

        """
        params = {}
        if cluster_version is not None:
            params['ClusterVersion'] = cluster_version
        if cluster_parameter_group_family is not None:
            params['ClusterParameterGroupFamily'] = cluster_parameter_group_family
        if max_records is not None:
            params['MaxRecords'] = max_records
        if marker is not None:
            params['Marker'] = marker
        return self._make_request(
            action='DescribeClusterVersions',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/elasticache/layer1.py" startline="544" endline="616" pcid="16">
    def describe_cache_clusters(self, cache_cluster_id=None,
                                max_records=None, marker=None,
                                show_cache_node_info=None):
        """
        The DescribeCacheClusters operation returns information about
        all provisioned cache clusters if no cache cluster identifier
        is specified, or about a specific cache cluster if a cache
        cluster identifier is supplied.

        By default, abbreviated information about the cache
        clusters(s) will be returned. You can use the optional
        ShowDetails flag to retrieve detailed information about the
        cache nodes associated with the cache clusters. These details
        include the DNS address and port for the cache node endpoint.

        If the cluster is in the CREATING state, only cluster level
        information will be displayed until all of the nodes are
        successfully provisioned.

        If the cluster is in the DELETING state, only cluster level
        information will be displayed.

        If cache nodes are currently being added to the cache cluster,
        node endpoint information and creation time for the additional
        nodes will not be displayed until they are completely
        provisioned. When the cache cluster state is available , the
        cluster is ready for use.

        If cache nodes are currently being removed from the cache
        cluster, no endpoint information for the removed nodes is
        displayed.

        :type cache_cluster_id: string
        :param cache_cluster_id: The user-supplied cluster identifier. If this
            parameter is specified, only information about that specific cache
            cluster is returned. This parameter isn't case sensitive.

        :type max_records: integer
        :param max_records: The maximum number of records to include in the
            response. If more records exist than the specified `MaxRecords`
            value, a marker is included in the response so that the remaining
            results can be retrieved.
        Default: 100

        Constraints: minimum 20; maximum 100.

        :type marker: string
        :param marker: An optional marker returned from a prior request. Use
            this marker for pagination of results from this operation. If this
            parameter is specified, the response includes only records beyond
            the marker, up to the value specified by MaxRecords .

        :type show_cache_node_info: boolean
        :param show_cache_node_info: An optional flag that can be included in
            the DescribeCacheCluster request to retrieve information about the
            individual cache nodes.

        """
        params = {}
        if cache_cluster_id is not None:
            params['CacheClusterId'] = cache_cluster_id
        if max_records is not None:
            params['MaxRecords'] = max_records
        if marker is not None:
            params['Marker'] = marker
        if show_cache_node_info is not None:
            params['ShowCacheNodeInfo'] = str(
                show_cache_node_info).lower()
        return self._make_request(
            action='DescribeCacheClusters',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/redshift/layer1.py" startline="1439" endline="1496" pcid="3014">
    def describe_orderable_cluster_options(self, cluster_version=None,
                                           node_type=None, max_records=None,
                                           marker=None):
        """
        Returns a list of orderable cluster options. Before you create
        a new cluster you can use this operation to find what options
        are available, such as the EC2 Availability Zones (AZ) in the
        specific AWS region that you can specify, and the node types
        you can request. The node types differ by available storage,
        memory, CPU and price. With the cost involved you might want
        to obtain a list of cluster options in the specific region and
        specify values when creating a cluster. For more information
        about managing clusters, go to `Amazon Redshift Clusters`_ in
        the Amazon Redshift Management Guide

        :type cluster_version: string
        :param cluster_version: The version filter value. Specify this
            parameter to show only the available offerings matching the
            specified version.
        Default: All versions.

        Constraints: Must be one of the version returned from
            DescribeClusterVersions.

        :type node_type: string
        :param node_type: The node type filter value. Specify this parameter to
            show only the available offerings matching the specified node type.

        :type max_records: integer
        :param max_records: The maximum number of records to include in the
            response. If more records exist than the specified `MaxRecords`
            value, a marker is included in the response so that the remaining
            results may be retrieved.
        Default: `100`

        Constraints: minimum 20, maximum 100.

        :type marker: string
        :param marker: An optional marker returned from a previous
            **DescribeOrderableClusterOptions** request. If this parameter is
            specified, the response includes only records beyond the marker, up
            to the value specified by `MaxRecords`.

        """
        params = {}
        if cluster_version is not None:
            params['ClusterVersion'] = cluster_version
        if node_type is not None:
            params['NodeType'] = node_type
        if max_records is not None:
            params['MaxRecords'] = max_records
        if marker is not None:
            params['Marker'] = marker
        return self._make_request(
            action='DescribeOrderableClusterOptions',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/redshift/layer1.py" startline="1297" endline="1336" pcid="3012">
    def describe_default_cluster_parameters(self, parameter_group_family,
                                            max_records=None, marker=None):
        """
        Returns a list of parameter settings for the specified
        parameter group family.

        For more information about managing parameter groups, go to
        `Amazon Redshift Parameter Groups`_ in the Amazon Redshift
        Management Guide .

        :type parameter_group_family: string
        :param parameter_group_family: The name of the cluster parameter group
            family.

        :type max_records: integer
        :param max_records: The maximum number of records to include in the
            response. If more records exist than the specified `MaxRecords`
            value, a marker is included in the response so that the remaining
            results may be retrieved.
        Default: `100`

        Constraints: Value must be at least 20 and no more than 100.

        :type marker: string
        :param marker: An optional marker returned from a previous
            **DescribeDefaultClusterParameters** request. If this parameter is
            specified, the response includes only records beyond the marker, up
            to the value specified by `MaxRecords`.

        """
        params = {'ParameterGroupFamily': parameter_group_family, }
        if max_records is not None:
            params['MaxRecords'] = max_records
        if marker is not None:
            params['Marker'] = marker
        return self._make_request(
            action='DescribeDefaultClusterParameters',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/elasticache/layer1.py" startline="617" endline="685" pcid="17">
    def describe_cache_engine_versions(self, engine=None,
                                       engine_version=None,
                                       cache_parameter_group_family=None,
                                       max_records=None, marker=None,
                                       default_only=None):
        """
        The DescribeCacheEngineVersions operation returns a list of
        the available cache engines and their versions.

        :type engine: string
        :param engine: The cache engine to return. Valid values: `memcached` |
            `redis`

        :type engine_version: string
        :param engine_version: The cache engine version to return.
        Example: `1.4.14`

        :type cache_parameter_group_family: string
        :param cache_parameter_group_family:
        The name of a specific cache parameter group family to return details
            for.

        Constraints:


        + Must be 1 to 255 alphanumeric characters
        + First character must be a letter
        + Cannot end with a hyphen or contain two consecutive hyphens

        :type max_records: integer
        :param max_records: The maximum number of records to include in the
            response. If more records exist than the specified `MaxRecords`
            value, a marker is included in the response so that the remaining
            results can be retrieved.
        Default: 100

        Constraints: minimum 20; maximum 100.

        :type marker: string
        :param marker: An optional marker returned from a prior request. Use
            this marker for pagination of results from this operation. If this
            parameter is specified, the response includes only records beyond
            the marker, up to the value specified by MaxRecords .

        :type default_only: boolean
        :param default_only: If true , specifies that only the default version
            of the specified engine or engine and major version combination is
            to be returned.

        """
        params = {}
        if engine is not None:
            params['Engine'] = engine
        if engine_version is not None:
            params['EngineVersion'] = engine_version
        if cache_parameter_group_family is not None:
            params['CacheParameterGroupFamily'] = cache_parameter_group_family
        if max_records is not None:
            params['MaxRecords'] = max_records
        if marker is not None:
            params['Marker'] = marker
        if default_only is not None:
            params['DefaultOnly'] = str(
                default_only).lower()
        return self._make_request(
            action='DescribeCacheEngineVersions',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/elasticache/layer1.py" startline="1087" endline="1162" pcid="26">
    def describe_reserved_cache_nodes_offerings(self,
                                                reserved_cache_nodes_offering_id=None,
                                                cache_node_type=None,
                                                duration=None,
                                                product_description=None,
                                                offering_type=None,
                                                max_records=None,
                                                marker=None):
        """
        The DescribeReservedCacheNodesOfferings operation lists
        available reserved cache node offerings.

        :type reserved_cache_nodes_offering_id: string
        :param reserved_cache_nodes_offering_id: The offering identifier filter
            value. Use this parameter to show only the available offering that
            matches the specified reservation identifier.
        Example: `438012d3-4052-4cc7-b2e3-8d3372e0e706`

        :type cache_node_type: string
        :param cache_node_type: The cache node type filter value. Use this
            parameter to show only the available offerings matching the
            specified cache node type.

        :type duration: string
        :param duration: Duration filter value, specified in years or seconds.
            Use this parameter to show only reservations for a given duration.
        Valid Values: `1 | 3 | 31536000 | 94608000`

        :type product_description: string
        :param product_description: The product description filter value. Use
            this parameter to show only the available offerings matching the
            specified product description.

        :type offering_type: string
        :param offering_type: The offering type filter value. Use this
            parameter to show only the available offerings matching the
            specified offering type.
        Valid Values: `"Light Utilization" | "Medium Utilization" | "Heavy
            Utilization" `

        :type max_records: integer
        :param max_records: The maximum number of records to include in the
            response. If more records exist than the specified `MaxRecords`
            value, a marker is included in the response so that the remaining
            results can be retrieved.
        Default: 100

        Constraints: minimum 20; maximum 100.

        :type marker: string
        :param marker: An optional marker returned from a prior request. Use
            this marker for pagination of results from this operation. If this
            parameter is specified, the response includes only records beyond
            the marker, up to the value specified by MaxRecords .

        """
        params = {}
        if reserved_cache_nodes_offering_id is not None:
            params['ReservedCacheNodesOfferingId'] = reserved_cache_nodes_offering_id
        if cache_node_type is not None:
            params['CacheNodeType'] = cache_node_type
        if duration is not None:
            params['Duration'] = duration
        if product_description is not None:
            params['ProductDescription'] = product_description
        if offering_type is not None:
            params['OfferingType'] = offering_type
        if max_records is not None:
            params['MaxRecords'] = max_records
        if marker is not None:
            params['Marker'] = marker
        return self._make_request(
            action='DescribeReservedCacheNodesOfferings',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/elasticache/layer1.py" startline="1005" endline="1086" pcid="25">
    def describe_reserved_cache_nodes(self, reserved_cache_node_id=None,
                                      reserved_cache_nodes_offering_id=None,
                                      cache_node_type=None, duration=None,
                                      product_description=None,
                                      offering_type=None, max_records=None,
                                      marker=None):
        """
        The DescribeReservedCacheNodes operation returns information
        about reserved cache nodes for this account, or about a
        specified reserved cache node.

        :type reserved_cache_node_id: string
        :param reserved_cache_node_id: The reserved cache node identifier
            filter value. Use this parameter to show only the reservation that
            matches the specified reservation ID.

        :type reserved_cache_nodes_offering_id: string
        :param reserved_cache_nodes_offering_id: The offering identifier filter
            value. Use this parameter to show only purchased reservations
            matching the specified offering identifier.

        :type cache_node_type: string
        :param cache_node_type: The cache node type filter value. Use this
            parameter to show only those reservations matching the specified
            cache node type.

        :type duration: string
        :param duration: The duration filter value, specified in years or
            seconds. Use this parameter to show only reservations for this
            duration.
        Valid Values: `1 | 3 | 31536000 | 94608000`

        :type product_description: string
        :param product_description: The product description filter value. Use
            this parameter to show only those reservations matching the
            specified product description.

        :type offering_type: string
        :param offering_type: The offering type filter value. Use this
            parameter to show only the available offerings matching the
            specified offering type.
        Valid values: `"Light Utilization" | "Medium Utilization" | "Heavy
            Utilization" `

        :type max_records: integer
        :param max_records: The maximum number of records to include in the
            response. If more records exist than the specified `MaxRecords`
            value, a marker is included in the response so that the remaining
            results can be retrieved.
        Default: 100

        Constraints: minimum 20; maximum 100.

        :type marker: string
        :param marker: An optional marker returned from a prior request. Use
            this marker for pagination of results from this operation. If this
            parameter is specified, the response includes only records beyond
            the marker, up to the value specified by MaxRecords .

        """
        params = {}
        if reserved_cache_node_id is not None:
            params['ReservedCacheNodeId'] = reserved_cache_node_id
        if reserved_cache_nodes_offering_id is not None:
            params['ReservedCacheNodesOfferingId'] = reserved_cache_nodes_offering_id
        if cache_node_type is not None:
            params['CacheNodeType'] = cache_node_type
        if duration is not None:
            params['Duration'] = duration
        if product_description is not None:
            params['ProductDescription'] = product_description
        if offering_type is not None:
            params['OfferingType'] = offering_type
        if max_records is not None:
            params['MaxRecords'] = max_records
        if marker is not None:
            params['Marker'] = marker
        return self._make_request(
            action='DescribeReservedCacheNodes',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/redshift/layer1.py" startline="1071" endline="1156" pcid="3008">
    def describe_cluster_snapshots(self, cluster_identifier=None,
                                   snapshot_identifier=None,
                                   snapshot_type=None, start_time=None,
                                   end_time=None, max_records=None,
                                   marker=None, owner_account=None):
        """
        Returns one or more snapshot objects, which contain metadata
        about your cluster snapshots. By default, this operation
        returns information about all snapshots of all clusters that
        are owned by you AWS customer account. No information is
        returned for snapshots owned by inactive AWS customer
        accounts.

        :type cluster_identifier: string
        :param cluster_identifier: The identifier of the cluster for which
            information about snapshots is requested.

        :type snapshot_identifier: string
        :param snapshot_identifier: The snapshot identifier of the snapshot
            about which to return information.

        :type snapshot_type: string
        :param snapshot_type: The type of snapshots for which you are
            requesting information. By default, snapshots of all types are
            returned.
        Valid Values: `automated` | `manual`

        :type start_time: timestamp
        :param start_time: A value that requests only snapshots created at or
            after the specified time. The time value is specified in ISO 8601
            format. For more information about ISO 8601, go to the `ISO8601
            Wikipedia page.`_
        Example: `2012-07-16T18:00:00Z`

        :type end_time: timestamp
        :param end_time: A time value that requests only snapshots created at
            or before the specified time. The time value is specified in ISO
            8601 format. For more information about ISO 8601, go to the
            `ISO8601 Wikipedia page.`_
        Example: `2012-07-16T18:00:00Z`

        :type max_records: integer
        :param max_records: The maximum number of snapshot records to include
            in the response. If more records exist than the specified
            `MaxRecords` value, the response returns a marker that you can use
            in a subsequent DescribeClusterSnapshots request in order to
            retrieve the next set of snapshot records.
        Default: `100`

        Constraints: Must be at least 20 and no more than 100.

        :type marker: string
        :param marker: An optional marker returned by a previous
            DescribeClusterSnapshots request to indicate the first snapshot
            that the request will return.

        :type owner_account: string
        :param owner_account: The AWS customer account used to create or copy
            the snapshot. Use this field to filter the results to snapshots
            owned by a particular account. To describe snapshots you own,
            either specify your AWS customer account, or do not specify the
            parameter.

        """
        params = {}
        if cluster_identifier is not None:
            params['ClusterIdentifier'] = cluster_identifier
        if snapshot_identifier is not None:
            params['SnapshotIdentifier'] = snapshot_identifier
        if snapshot_type is not None:
            params['SnapshotType'] = snapshot_type
        if start_time is not None:
            params['StartTime'] = start_time
        if end_time is not None:
            params['EndTime'] = end_time
        if max_records is not None:
            params['MaxRecords'] = max_records
        if marker is not None:
            params['Marker'] = marker
        if owner_account is not None:
            params['OwnerAccount'] = owner_account
        return self._make_request(
            action='DescribeClusterSnapshots',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/swf/layer1_decisions.py" startline="143" endline="174" pcid="4172">
    def continue_as_new_workflow_execution(self,
                                           child_policy=None,
                                           execution_start_to_close_timeout=None,
                                           input=None,
                                           tag_list=None,
                                           task_list=None,
                                           start_to_close_timeout=None,
                                           workflow_type_version=None):
        """
        Closes the workflow execution and starts a new workflow execution of
        the same type using the same workflow id and a unique run Id. A
        WorkflowExecutionContinuedAsNew event is recorded in the history.
        """
        o = {}
        o['decisionType'] = 'ContinueAsNewWorkflowExecution'
        attrs = o['continueAsNewWorkflowExecutionDecisionAttributes'] = {}
        if child_policy is not None:
            attrs['childPolicy'] = child_policy
        if execution_start_to_close_timeout is not None:
            attrs['executionStartToCloseTimeout'] = execution_start_to_close_timeout
        if input is not None:
            attrs['input'] = input
        if tag_list is not None:
            attrs['tagList'] = tag_list
        if task_list is not None:
            attrs['taskList'] = {'name': task_list}
        if start_to_close_timeout is not None:
            attrs['startToCloseTimeout'] = start_to_close_timeout
        if workflow_type_version is not None:
            attrs['workflowTypeVersion'] = workflow_type_version
        self._data.append(o)

</source>
<source file="systems/boto-2.13.2/boto/elasticache/layer1.py" startline="891" endline="962" pcid="23">
    def describe_events(self, source_identifier=None, source_type=None,
                        start_time=None, end_time=None, duration=None,
                        max_records=None, marker=None):
        """
        The DescribeEvents operation returns events related to cache
        clusters, cache security groups, and cache parameter groups.
        You can obtain events specific to a particular cache cluster,
        cache security group, or cache parameter group by providing
        the name as a parameter.

        By default, only the events occurring within the last hour are
        returned; however, you can retrieve up to 14 days' worth of
        events if necessary.

        :type source_identifier: string
        :param source_identifier: The identifier of the event source for which
            events will be returned. If not specified, then all sources are
            included in the response.

        :type source_type: string
        :param source_type: The event source to retrieve events for. If no
            value is specified, all events are returned.
        Valid values are: `cache-cluster` | `cache-parameter-group` | `cache-
            security-group` | `cache-subnet-group`

        :type start_time: timestamp
        :param start_time: The beginning of the time interval to retrieve
            events for, specified in ISO 8601 format.

        :type end_time: timestamp
        :param end_time: The end of the time interval for which to retrieve
            events, specified in ISO 8601 format.

        :type duration: integer
        :param duration: The number of minutes' worth of events to retrieve.

        :type max_records: integer
        :param max_records: The maximum number of records to include in the
            response. If more records exist than the specified `MaxRecords`
            value, a marker is included in the response so that the remaining
            results can be retrieved.
        Default: 100

        Constraints: minimum 20; maximum 100.

        :type marker: string
        :param marker: An optional marker returned from a prior request. Use
            this marker for pagination of results from this operation. If this
            parameter is specified, the response includes only records beyond
            the marker, up to the value specified by MaxRecords .

        """
        params = {}
        if source_identifier is not None:
            params['SourceIdentifier'] = source_identifier
        if source_type is not None:
            params['SourceType'] = source_type
        if start_time is not None:
            params['StartTime'] = start_time
        if end_time is not None:
            params['EndTime'] = end_time
        if duration is not None:
            params['Duration'] = duration
        if max_records is not None:
            params['MaxRecords'] = max_records
        if marker is not None:
            params['Marker'] = marker
        return self._make_request(
            action='DescribeEvents',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/redshift/layer1.py" startline="1337" endline="1438" pcid="3013">
    def describe_events(self, source_identifier=None, source_type=None,
                        start_time=None, end_time=None, duration=None,
                        max_records=None, marker=None):
        """
        Returns events related to clusters, security groups,
        snapshots, and parameter groups for the past 14 days. Events
        specific to a particular cluster, security group, snapshot or
        parameter group can be obtained by providing the name as a
        parameter. By default, the past hour of events are returned.

        :type source_identifier: string
        :param source_identifier:
        The identifier of the event source for which events will be returned.
            If this parameter is not specified, then all sources are included
            in the response.

        Constraints:

        If SourceIdentifier is supplied, SourceType must also be provided.


        + Specify a cluster identifier when SourceType is `cluster`.
        + Specify a cluster security group name when SourceType is `cluster-
              security-group`.
        + Specify a cluster parameter group name when SourceType is `cluster-
              parameter-group`.
        + Specify a cluster snapshot identifier when SourceType is `cluster-
              snapshot`.

        :type source_type: string
        :param source_type:
        The event source to retrieve events for. If no value is specified, all
            events are returned.

        Constraints:

        If SourceType is supplied, SourceIdentifier must also be provided.


        + Specify `cluster` when SourceIdentifier is a cluster identifier.
        + Specify `cluster-security-group` when SourceIdentifier is a cluster
              security group name.
        + Specify `cluster-parameter-group` when SourceIdentifier is a cluster
              parameter group name.
        + Specify `cluster-snapshot` when SourceIdentifier is a cluster
              snapshot identifier.

        :type start_time: timestamp
        :param start_time: The beginning of the time interval to retrieve
            events for, specified in ISO 8601 format. For more information
            about ISO 8601, go to the `ISO8601 Wikipedia page.`_
        Example: `2009-07-08T18:00Z`

        :type end_time: timestamp
        :param end_time: The end of the time interval for which to retrieve
            events, specified in ISO 8601 format. For more information about
            ISO 8601, go to the `ISO8601 Wikipedia page.`_
        Example: `2009-07-08T18:00Z`

        :type duration: integer
        :param duration: The number of minutes prior to the time of the request
            for which to retrieve events. For example, if the request is sent
            at 18:00 and you specify a duration of 60, then only events which
            have occurred after 17:00 will be returned.
        Default: `60`

        :type max_records: integer
        :param max_records: The maximum number of records to include in the
            response. If more records exist than the specified `MaxRecords`
            value, a marker is included in the response so that the remaining
            results may be retrieved.
        Default: `100`

        Constraints: Value must be at least 20 and no more than 100.

        :type marker: string
        :param marker: An optional marker returned from a previous
            **DescribeEvents** request. If this parameter is specified, the
            response includes only records beyond the marker, up to the value
            specified by `MaxRecords`.

        """
        params = {}
        if source_identifier is not None:
            params['SourceIdentifier'] = source_identifier
        if source_type is not None:
            params['SourceType'] = source_type
        if start_time is not None:
            params['StartTime'] = start_time
        if end_time is not None:
            params['EndTime'] = end_time
        if duration is not None:
            params['Duration'] = duration
        if max_records is not None:
            params['MaxRecords'] = max_records
        if marker is not None:
            params['Marker'] = marker
        return self._make_request(
            action='DescribeEvents',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/opsworks/layer1.py" startline="1571" endline="1671" pcid="3069">
    def update_instance(self, instance_id, layer_ids=None,
                        instance_type=None, auto_scaling_type=None,
                        hostname=None, os=None, ami_id=None,
                        ssh_key_name=None, architecture=None,
                        install_updates_on_boot=None):
        """
        Updates a specified instance.

        :type instance_id: string
        :param instance_id: The instance ID.

        :type layer_ids: list
        :param layer_ids: The instance's layer IDs.

        :type instance_type: string
        :param instance_type: The instance type. AWS OpsWorks supports all
            instance types except Cluster Compute, Cluster GPU, and High Memory
            Cluster. For more information, see `Instance Families and Types`_.
            The parameter values that you use to specify the various types are
            in the API Name column of the Available Instance Types table.

        :type auto_scaling_type: string
        :param auto_scaling_type:
        The instance's auto scaling type, which has three possible values:


        + **AlwaysRunning**: A 24/7 instance, which is not affected by auto
              scaling.
        + **TimeBasedAutoScaling**: A time-based auto scaling instance, which
              is started and stopped based on a specified schedule.
        + **LoadBasedAutoScaling**: A load-based auto scaling instance, which
              is started and stopped based on load metrics.

        :type hostname: string
        :param hostname: The instance host name.

        :type os: string
        :param os: The instance operating system, which must be set to one of
            the following.

        + Standard operating systems: `Amazon Linux` or `Ubuntu 12.04 LTS`
        + Custom AMIs: `Custom`


        The default option is `Amazon Linux`. If you set this parameter to
            `Custom`, you must use the CreateInstance action's AmiId parameter
            to specify the custom AMI that you want to use. For more
            information on the standard operating systems, see `Operating
            Systems`_For more information on how to use custom AMIs with
            OpsWorks, see `Using Custom AMIs`_.

        :type ami_id: string
        :param ami_id: A custom AMI ID to be used to create the instance. The
            AMI should be based on one of the standard AWS OpsWorks APIs:
            Amazon Linux or Ubuntu 12.04 LTS. For more information, see
            `Instances`_

        :type ssh_key_name: string
        :param ssh_key_name: The instance SSH key name.

        :type architecture: string
        :param architecture: The instance architecture. Instance types do not
            necessarily support both architectures. For a list of the
            architectures that are supported by the different instance types,
            see `Instance Families and Types`_.

        :type install_updates_on_boot: boolean
        :param install_updates_on_boot:
        Whether to install operating system and package updates when the
            instance boots. The default value is `True`. To control when
            updates are installed, set this value to `False`. You must then
            update your instances manually by using CreateDeployment to run the
            `update_dependencies` stack command or manually running `yum`
            (Amazon Linux) or `apt-get` (Ubuntu) on the instances.

        We strongly recommend using the default value of `True`, to ensure that
            your instances have the latest security updates.

        """
        params = {'InstanceId': instance_id, }
        if layer_ids is not None:
            params['LayerIds'] = layer_ids
        if instance_type is not None:
            params['InstanceType'] = instance_type
        if auto_scaling_type is not None:
            params['AutoScalingType'] = auto_scaling_type
        if hostname is not None:
            params['Hostname'] = hostname
        if os is not None:
            params['Os'] = os
        if ami_id is not None:
            params['AmiId'] = ami_id
        if ssh_key_name is not None:
            params['SshKeyName'] = ssh_key_name
        if architecture is not None:
            params['Architecture'] = architecture
        if install_updates_on_boot is not None:
            params['InstallUpdatesOnBoot'] = install_updates_on_boot
        return self.make_request(action='UpdateInstance',
                                 body=json.dumps(params))

</source>
<source file="systems/boto-2.13.2/boto/support/layer1.py" startline="234" endline="293" pcid="1766">
    def describe_cases(self, case_id_list=None, display_id=None,
                       after_time=None, before_time=None,
                       include_resolved_cases=None, next_token=None,
                       max_results=None, language=None):
        """
        This action returns a list of cases that you specify by
        passing one or more CaseIds. In addition, you can filter the
        cases by date by setting values for the AfterTime and
        BeforeTime request parameters.
        The response returns the following in JSON format:

        #. One or more `CaseDetails`_ data types.
        #. One or more NextToken objects, strings that specifies where
           to paginate the returned records represented by CaseDetails .

        :type case_id_list: list
        :param case_id_list:

        :type display_id: string
        :param display_id:

        :type after_time: string
        :param after_time:

        :type before_time: string
        :param before_time:

        :type include_resolved_cases: boolean
        :param include_resolved_cases:

        :type next_token: string
        :param next_token:

        :type max_results: integer
        :param max_results:

        :type language: string
        :param language:

        """
        params = {}
        if case_id_list is not None:
            params['caseIdList'] = case_id_list
        if display_id is not None:
            params['displayId'] = display_id
        if after_time is not None:
            params['afterTime'] = after_time
        if before_time is not None:
            params['beforeTime'] = before_time
        if include_resolved_cases is not None:
            params['includeResolvedCases'] = include_resolved_cases
        if next_token is not None:
            params['nextToken'] = next_token
        if max_results is not None:
            params['maxResults'] = max_results
        if language is not None:
            params['language'] = language
        return self.make_request(action='DescribeCases',
                                 body=json.dumps(params))

</source>
<source file="systems/boto-2.13.2/boto/swf/layer1_decisions.py" startline="16" endline="74" pcid="4166">
    def schedule_activity_task(self,
                               activity_id,
                               activity_type_name,
                               activity_type_version,
                               task_list=None,
                               control=None,
                               heartbeat_timeout=None,
                               schedule_to_close_timeout=None,
                               schedule_to_start_timeout=None,
                               start_to_close_timeout=None,
                               input=None):
        """
        Schedules an activity task.

        :type activity_id: string
        :param activity_id: The activityId of the type of the activity
            being scheduled.

        :type activity_type_name: string
        :param activity_type_name: The name of the type of the activity
            being scheduled.

        :type activity_type_version: string
        :param activity_type_version: The version of the type of the
            activity being scheduled.

        :type task_list: string
        :param task_list: If set, specifies the name of the task list in
            which to schedule the activity task. If not specified, the
            defaultTaskList registered with the activity type will be used.
            Note: a task list for this activity task must be specified either
            as a default for the activity type or through this field. If
            neither this field is set nor a default task list was specified
            at registration time then a fault will be returned.
        """
        o = {}
        o['decisionType'] = 'ScheduleActivityTask'
        attrs = o['scheduleActivityTaskDecisionAttributes'] = {}
        attrs['activityId'] = activity_id
        attrs['activityType'] = {
            'name': activity_type_name,
            'version': activity_type_version,
        }
        if task_list is not None:
            attrs['taskList'] = {'name': task_list}
        if control is not None:
            attrs['control'] = control
        if heartbeat_timeout is not None:
            attrs['heartbeatTimeout'] = heartbeat_timeout
        if schedule_to_close_timeout is not None:
            attrs['scheduleToCloseTimeout'] = schedule_to_close_timeout
        if schedule_to_start_timeout is not None:
            attrs['scheduleToStartTimeout'] = schedule_to_start_timeout
        if start_to_close_timeout is not None:
            attrs['startToCloseTimeout'] = start_to_close_timeout
        if input is not None:
            attrs['input'] = input
        self._data.append(o)

</source>
<source file="systems/boto-2.13.2/boto/swf/layer1_decisions.py" startline="248" endline="287" pcid="4177">
    def start_child_workflow_execution(self,
                                       workflow_type_name,
                                       workflow_type_version,
                                       workflow_id,
                                       child_policy=None,
                                       control=None,
                                       execution_start_to_close_timeout=None,
                                       input=None,
                                       tag_list=None,
                                       task_list=None,
                                       task_start_to_close_timeout=None):
        """
        Requests that a child workflow execution be started and
        records a StartChildWorkflowExecutionInitiated event in the
        history.  The child workflow execution is a separate workflow
        execution with its own history.
        """
        o = {}
        o['decisionType'] = 'StartChildWorkflowExecution'
        attrs = o['startChildWorkflowExecutionDecisionAttributes'] = {}
        attrs['workflowType'] = {
            'name': workflow_type_name,
            'version': workflow_type_version,
        }
        attrs['workflowId'] = workflow_id
        if child_policy is not None:
            attrs['childPolicy'] = child_policy
        if control is not None:
            attrs['control'] = control
        if execution_start_to_close_timeout is not None:
            attrs['executionStartToCloseTimeout'] = execution_start_to_close_timeout
        if input is not None:
            attrs['input'] = input
        if tag_list is not None:
            attrs['tagList'] = tag_list
        if task_list is not None:
            attrs['taskList'] = {'name': task_list}
        if task_start_to_close_timeout is not None:
            attrs['taskStartToCloseTimeout'] = task_start_to_close_timeout
        self._data.append(o)
</source>
<source file="systems/boto-2.13.2/boto/elastictranscoder/layer1.py" startline="144" endline="359" pcid="3080">
    def create_pipeline(self, name=None, input_bucket=None,
                        output_bucket=None, role=None, notifications=None,
                        content_config=None, thumbnail_config=None):
        """
        The CreatePipeline operation creates a pipeline with settings
        that you specify.

        :type name: string
        :param name: The name of the pipeline. We recommend that the name be
            unique within the AWS account, but uniqueness is not enforced.
        Constraints: Maximum 40 characters.

        :type input_bucket: string
        :param input_bucket: The Amazon S3 bucket in which you saved the media
            files that you want to transcode.

        :type output_bucket: string
        :param output_bucket: The Amazon S3 bucket in which you want Elastic
            Transcoder to save the transcoded files. (Use this, or use
            ContentConfig:Bucket plus ThumbnailConfig:Bucket.)
        Specify this value when all of the following are true:

        + You want to save transcoded files, thumbnails (if any), and playlists
              (if any) together in one bucket.
        + You do not want to specify the users or groups who have access to the
              transcoded files, thumbnails, and playlists.
        + You do not want to specify the permissions that Elastic Transcoder
              grants to the files. When Elastic Transcoder saves files in
              `OutputBucket`, it grants full control over the files only to the
              AWS account that owns the role that is specified by `Role`.
        + You want to associate the transcoded files and thumbnails with the
              Amazon S3 Standard storage class.



        If you want to save transcoded files and playlists in one bucket and
            thumbnails in another bucket, specify which users can access the
            transcoded files or the permissions the users have, or change the
            Amazon S3 storage class, omit `OutputBucket` and specify values for
            `ContentConfig` and `ThumbnailConfig` instead.

        :type role: string
        :param role: The IAM Amazon Resource Name (ARN) for the role that you
            want Elastic Transcoder to use to create the pipeline.

        :type notifications: dict
        :param notifications:
        The Amazon Simple Notification Service (Amazon SNS) topic that you want
            to notify to report job status.
        To receive notifications, you must also subscribe to the new topic in
            the Amazon SNS console.

        + **Progressing**: The topic ARN for the Amazon Simple Notification
              Service (Amazon SNS) topic that you want to notify when Elastic
              Transcoder has started to process a job in this pipeline. This is
              the ARN that Amazon SNS returned when you created the topic. For
              more information, see Create a Topic in the Amazon Simple
              Notification Service Developer Guide.
        + **Completed**: The topic ARN for the Amazon SNS topic that you want
              to notify when Elastic Transcoder has finished processing a job in
              this pipeline. This is the ARN that Amazon SNS returned when you
              created the topic.
        + **Warning**: The topic ARN for the Amazon SNS topic that you want to
              notify when Elastic Transcoder encounters a warning condition while
              processing a job in this pipeline. This is the ARN that Amazon SNS
              returned when you created the topic.
        + **Error**: The topic ARN for the Amazon SNS topic that you want to
              notify when Elastic Transcoder encounters an error condition while
              processing a job in this pipeline. This is the ARN that Amazon SNS
              returned when you created the topic.

        :type content_config: dict
        :param content_config:
        The optional `ContentConfig` object specifies information about the
            Amazon S3 bucket in which you want Elastic Transcoder to save
            transcoded files and playlists: which bucket to use, which users
            you want to have access to the files, the type of access you want
            users to have, and the storage class that you want to assign to the
            files.

        If you specify values for `ContentConfig`, you must also specify values
            for `ThumbnailConfig`.

        If you specify values for `ContentConfig` and `ThumbnailConfig`, omit
            the `OutputBucket` object.


        + **Bucket**: The Amazon S3 bucket in which you want Elastic Transcoder
              to save transcoded files and playlists.
        + **Permissions** (Optional): The Permissions object specifies which
              users you want to have access to transcoded files and the type of
              access you want them to have. You can grant permissions to a
              maximum of 30 users and/or predefined Amazon S3 groups.
        + **Grantee Type**: Specify the type of value that appears in the
              `Grantee` object:

            + **Canonical**: The value in the `Grantee` object is either the
                  canonical user ID for an AWS account or an origin access identity
                  for an Amazon CloudFront distribution. For more information about
                  canonical user IDs, see Access Control List (ACL) Overview in the
                  Amazon Simple Storage Service Developer Guide. For more information
                  about using CloudFront origin access identities to require that
                  users use CloudFront URLs instead of Amazon S3 URLs, see Using an
                  Origin Access Identity to Restrict Access to Your Amazon S3
                  Content. A canonical user ID is not the same as an AWS account
                  number.
            + **Email**: The value in the `Grantee` object is the registered email
                  address of an AWS account.
            + **Group**: The value in the `Grantee` object is one of the following
                  predefined Amazon S3 groups: `AllUsers`, `AuthenticatedUsers`, or
                  `LogDelivery`.

        + **Grantee**: The AWS user or group that you want to have access to
              transcoded files and playlists. To identify the user or group, you
              can specify the canonical user ID for an AWS account, an origin
              access identity for a CloudFront distribution, the registered email
              address of an AWS account, or a predefined Amazon S3 group
        + **Access**: The permission that you want to give to the AWS user that
              you specified in `Grantee`. Permissions are granted on the files
              that Elastic Transcoder adds to the bucket, including playlists and
              video files. Valid values include:

            + `READ`: The grantee can read the objects and metadata for objects
                  that Elastic Transcoder adds to the Amazon S3 bucket.
            + `READ_ACP`: The grantee can read the object ACL for objects that
                  Elastic Transcoder adds to the Amazon S3 bucket.
            + `WRITE_ACP`: The grantee can write the ACL for the objects that
                  Elastic Transcoder adds to the Amazon S3 bucket.
            + `FULL_CONTROL`: The grantee has `READ`, `READ_ACP`, and `WRITE_ACP`
                  permissions for the objects that Elastic Transcoder adds to the
                  Amazon S3 bucket.

        + **StorageClass**: The Amazon S3 storage class, `Standard` or
              `ReducedRedundancy`, that you want Elastic Transcoder to assign to
              the video files and playlists that it stores in your Amazon S3
              bucket.

        :type thumbnail_config: dict
        :param thumbnail_config:
        The `ThumbnailConfig` object specifies several values, including the
            Amazon S3 bucket in which you want Elastic Transcoder to save
            thumbnail files, which users you want to have access to the files,
            the type of access you want users to have, and the storage class
            that you want to assign to the files.

        If you specify values for `ContentConfig`, you must also specify values
            for `ThumbnailConfig` even if you don't want to create thumbnails.

        If you specify values for `ContentConfig` and `ThumbnailConfig`, omit
            the `OutputBucket` object.


        + **Bucket**: The Amazon S3 bucket in which you want Elastic Transcoder
              to save thumbnail files.
        + **Permissions** (Optional): The `Permissions` object specifies which
              users and/or predefined Amazon S3 groups you want to have access to
              thumbnail files, and the type of access you want them to have. You
              can grant permissions to a maximum of 30 users and/or predefined
              Amazon S3 groups.
        + **GranteeType**: Specify the type of value that appears in the
              Grantee object:

            + **Canonical**: The value in the `Grantee` object is either the
                  canonical user ID for an AWS account or an origin access identity
                  for an Amazon CloudFront distribution. A canonical user ID is not
                  the same as an AWS account number.
            + **Email**: The value in the `Grantee` object is the registered email
                  address of an AWS account.
            + **Group**: The value in the `Grantee` object is one of the following
                  predefined Amazon S3 groups: `AllUsers`, `AuthenticatedUsers`, or
                  `LogDelivery`.

        + **Grantee**: The AWS user or group that you want to have access to
              thumbnail files. To identify the user or group, you can specify the
              canonical user ID for an AWS account, an origin access identity for
              a CloudFront distribution, the registered email address of an AWS
              account, or a predefined Amazon S3 group.
        + **Access**: The permission that you want to give to the AWS user that
              you specified in `Grantee`. Permissions are granted on the
              thumbnail files that Elastic Transcoder adds to the bucket. Valid
              values include:

            + `READ`: The grantee can read the thumbnails and metadata for objects
                  that Elastic Transcoder adds to the Amazon S3 bucket.
            + `READ_ACP`: The grantee can read the object ACL for thumbnails that
                  Elastic Transcoder adds to the Amazon S3 bucket.
            + `WRITE_ACP`: The grantee can write the ACL for the thumbnails that
                  Elastic Transcoder adds to the Amazon S3 bucket.
            + `FULL_CONTROL`: The grantee has `READ`, `READ_ACP`, and `WRITE_ACP`
                  permissions for the thumbnails that Elastic Transcoder adds to the
                  Amazon S3 bucket.

        + **StorageClass**: The Amazon S3 storage class, `Standard` or
              `ReducedRedundancy`, that you want Elastic Transcoder to assign to
              the thumbnails that it stores in your Amazon S3 bucket.

        """
        uri = '/2012-09-25/pipelines'
        params = {}
        if name is not None:
            params['Name'] = name
        if input_bucket is not None:
            params['InputBucket'] = input_bucket
        if output_bucket is not None:
            params['OutputBucket'] = output_bucket
        if role is not None:
            params['Role'] = role
        if notifications is not None:
            params['Notifications'] = notifications
        if content_config is not None:
            params['ContentConfig'] = content_config
        if thumbnail_config is not None:
            params['ThumbnailConfig'] = thumbnail_config
        return self.make_request('POST', uri, expected_status=201,
                                 data=json.dumps(params))

</source>
<source file="systems/boto-2.13.2/boto/opsworks/layer1.py" startline="1514" endline="1570" pcid="3068">
    def update_app(self, app_id, name=None, description=None, type=None,
                   app_source=None, domains=None, enable_ssl=None,
                   ssl_configuration=None, attributes=None):
        """
        Updates a specified app.

        :type app_id: string
        :param app_id: The app ID.

        :type name: string
        :param name: The app name.

        :type description: string
        :param description: A description of the app.

        :type type: string
        :param type: The app type.

        :type app_source: dict
        :param app_source: A `Source` object that specifies the app repository.

        :type domains: list
        :param domains: The app's virtual host settings, with multiple domains
            separated by commas. For example: `'www.example.com, example.com'`

        :type enable_ssl: boolean
        :param enable_ssl: Whether SSL is enabled for the app.

        :type ssl_configuration: dict
        :param ssl_configuration: An `SslConfiguration` object with the SSL
            configuration.

        :type attributes: map
        :param attributes: One or more user-defined key/value pairs to be added
            to the stack attributes bag.

        """
        params = {'AppId': app_id, }
        if name is not None:
            params['Name'] = name
        if description is not None:
            params['Description'] = description
        if type is not None:
            params['Type'] = type
        if app_source is not None:
            params['AppSource'] = app_source
        if domains is not None:
            params['Domains'] = domains
        if enable_ssl is not None:
            params['EnableSsl'] = enable_ssl
        if ssl_configuration is not None:
            params['SslConfiguration'] = ssl_configuration
        if attributes is not None:
            params['Attributes'] = attributes
        return self.make_request(action='UpdateApp',
                                 body=json.dumps(params))

</source>
<source file="systems/boto-2.13.2/boto/dynamodb2/layer1.py" startline="730" endline="968" pcid="1864">
    def query(self, table_name, index_name=None, select=None,
              attributes_to_get=None, limit=None, consistent_read=None,
              key_conditions=None, scan_index_forward=None,
              exclusive_start_key=None, return_consumed_capacity=None):
        """
        A Query operation directly accesses items from a table using
        the table primary key, or from an index using the index key.
        You must provide a specific hash key value. You can narrow the
        scope of the query by using comparison operators on the range
        key value, or on the index key. You can use the
        ScanIndexForward parameter to get results in forward or
        reverse order, by range key or by index key.

        Queries that do not return results consume the minimum read
        capacity units according to the type of read.

        If the total number of items meeting the query criteria
        exceeds the result set size limit of 1 MB, the query stops and
        results are returned to the user with a LastEvaluatedKey to
        continue the query in a subsequent operation. Unlike a Scan
        operation, a Query operation never returns an empty result set
        and a LastEvaluatedKey . The LastEvaluatedKey is only provided
        if the results exceed 1 MB, or if you have used Limit .

        To request a strongly consistent result, set ConsistentRead to
        true.

        :type table_name: string
        :param table_name: The name of the table containing the requested
            items.

        :type index_name: string
        :param index_name: The name of an index on the table to query.

        :type select: string
        :param select: The attributes to be returned in the result. You can
            retrieve all item attributes, specific item attributes, the count
            of matching items, or in the case of an index, some or all of the
            attributes projected into the index.

        + `ALL_ATTRIBUTES`: Returns all of the item attributes. For a table,
              this is the default. For an index, this mode causes Amazon DynamoDB
              to fetch the full item from the table for each matching item in the
              index. If the index is configured to project all item attributes,
              the matching items will not be fetched from the table. Fetching
              items from the table incurs additional throughput cost and latency.
        + `ALL_PROJECTED_ATTRIBUTES`: Allowed only when querying an index.
              Retrieves all attributes which have been projected into the index.
              If the index is configured to project all attributes, this is
              equivalent to specifying ALL_ATTRIBUTES .
        + `COUNT`: Returns the number of matching items, rather than the
              matching items themselves.
        + `SPECIFIC_ATTRIBUTES` : Returns only the attributes listed in
              AttributesToGet . This is equivalent to specifying AttributesToGet
              without specifying any value for Select . If you are querying an
              index and request only attributes that are projected into that
              index, the operation will read only the index and not the table. If
              any of the requested attributes are not projected into the index,
              Amazon DynamoDB will need to fetch each matching item from the
              table. This extra fetching incurs additional throughput cost and
              latency.


        When neither Select nor AttributesToGet are specified, Amazon DynamoDB
            defaults to `ALL_ATTRIBUTES` when accessing a table, and
            `ALL_PROJECTED_ATTRIBUTES` when accessing an index. You cannot use
            both Select and AttributesToGet together in a single request,
            unless the value for Select is `SPECIFIC_ATTRIBUTES`. (This usage
            is equivalent to specifying AttributesToGet without any value for
            Select .)

        :type attributes_to_get: list
        :param attributes_to_get: The names of one or more attributes to
            retrieve. If no attribute names are specified, then all attributes
            will be returned. If any of the requested attributes are not found,
            they will not appear in the result.
        If you are querying an index and request only attributes that are
            projected into that index, the operation will read only the index
            and not the table. If any of the requested attributes are not
            projected into the index, Amazon DynamoDB will need to fetch each
            matching item from the table. This extra fetching incurs additional
            throughput cost and latency.

        You cannot use both AttributesToGet and Select together in a Query
            request, unless the value for Select is `SPECIFIC_ATTRIBUTES`.
            (This usage is equivalent to specifying AttributesToGet without any
            value for Select .)

        :type limit: integer
        :param limit: The maximum number of items to evaluate (not necessarily
            the number of matching items). If Amazon DynamoDB processes the
            number of items up to the limit while processing the results, it
            stops the operation and returns the matching values up to that
            point, and a LastEvaluatedKey to apply in a subsequent operation,
            so that you can pick up where you left off. Also, if the processed
            data set size exceeds 1 MB before Amazon DynamoDB reaches this
            limit, it stops the operation and returns the matching values up to
            the limit, and a LastEvaluatedKey to apply in a subsequent
            operation to continue the operation. For more information see
            `Query and Scan`_ in the Amazon DynamoDB Developer Guide .

        :type consistent_read: boolean
        :param consistent_read: If set to `True`, then the operation uses
            strongly consistent reads; otherwise, eventually consistent reads
            are used.

        :type key_conditions: map
        :param key_conditions:
        The selection criteria for the query.

        For a query on a table, you can only have conditions on the table
            primary key attributes. you must specify the hash key attribute
            name and value as an `EQ` condition. You can optionally specify a
            second condition, referring to the range key attribute.

        For a query on a secondary index, you can only have conditions on the
            index key attributes. You must specify the index hash attribute
            name and value as an EQ condition. You can optionally specify a
            second condition, referring to the index key range attribute.

        Multiple conditions are evaluated using "AND"; in other words, all of
            the conditions must be met in order for an item to appear in the
            results results.

        Each KeyConditions element consists of an attribute name to compare,
            along with the following:


        + AttributeValueList - One or more values to evaluate against the
              supplied attribute. This list contains exactly one value, except
              for a `BETWEEN` or `IN` comparison, in which case the list contains
              two values. For type Number, value comparisons are numeric. String
              value comparisons for greater than, equals, or less than are based
              on ASCII character code values. For example, `a` is greater than
              `A`, and `aa` is greater than `B`. For a list of code values, see
              `http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters`_.
              For Binary, Amazon DynamoDB treats each byte of the binary data as
              unsigned when it compares binary values, for example when
              evaluating query expressions.
        + ComparisonOperator - A comparator for evaluating attributes. For
              example, equals, greater than, less than, etc. Valid comparison
              operators for Query: `EQ | LE | LT | GE | GT | BEGINS_WITH |
              BETWEEN` For information on specifying data types in JSON, see
              `JSON Data Format`_ in the Amazon DynamoDB Developer Guide . The
              following are descriptions of each comparison operator.

            + `EQ` : Equal. AttributeValueList can contain only one AttributeValue
                  of type String, Number, or Binary (not a set). If an item contains
                  an AttributeValue of a different type than the one specified in the
                  request, the value does not match. For example, `{"S":"6"}` does
                  not equal `{"N":"6"}`. Also, `{"N":"6"}` does not equal
                  `{"NS":["6", "2", "1"]}`.
            + `LE` : Less than or equal. AttributeValueList can contain only one
                  AttributeValue of type String, Number, or Binary (not a set). If an
                  item contains an AttributeValue of a different type than the one
                  specified in the request, the value does not match. For example,
                  `{"S":"6"}` does not equal `{"N":"6"}`. Also, `{"N":"6"}` does not
                  compare to `{"NS":["6", "2", "1"]}`.
            + `LT` : Less than. AttributeValueList can contain only one
                  AttributeValue of type String, Number, or Binary (not a set). If an
                  item contains an AttributeValue of a different type than the one
                  specified in the request, the value does not match. For example,
                  `{"S":"6"}` does not equal `{"N":"6"}`. Also, `{"N":"6"}` does not
                  compare to `{"NS":["6", "2", "1"]}`.
            + `GE` : Greater than or equal. AttributeValueList can contain only one
                  AttributeValue of type String, Number, or Binary (not a set). If an
                  item contains an AttributeValue of a different type than the one
                  specified in the request, the value does not match. For example,
                  `{"S":"6"}` does not equal `{"N":"6"}`. Also, `{"N":"6"}` does not
                  compare to `{"NS":["6", "2", "1"]}`.
            + `GT` : Greater than. AttributeValueList can contain only one
                  AttributeValue of type String, Number, or Binary (not a set). If an
                  item contains an AttributeValue of a different type than the one
                  specified in the request, the value does not match. For example,
                  `{"S":"6"}` does not equal `{"N":"6"}`. Also, `{"N":"6"}` does not
                  compare to `{"NS":["6", "2", "1"]}`.
            + `BEGINS_WITH` : checks for a prefix. AttributeValueList can contain
                  only one AttributeValue of type String or Binary (not a Number or a
                  set). The target attribute of the comparison must be a String or
                  Binary (not a Number or a set).
            + `BETWEEN` : Greater than or equal to the first value, and less than
                  or equal to the second value. AttributeValueList must contain two
                  AttributeValue elements of the same type, either String, Number, or
                  Binary (not a set). A target attribute matches if the target value
                  is greater than, or equal to, the first element and less than, or
                  equal to, the second element. If an item contains an AttributeValue
                  of a different type than the one specified in the request, the
                  value does not match. For example, `{"S":"6"}` does not compare to
                  `{"N":"6"}`. Also, `{"N":"6"}` does not compare to `{"NS":["6",
                  "2", "1"]}`

        :type scan_index_forward: boolean
        :param scan_index_forward: Specifies ascending (true) or descending
            (false) traversal of the index. Amazon DynamoDB returns results
            reflecting the requested order determined by the range key. If the
            data type is Number, the results are returned in numeric order. For
            String, the results are returned in order of ASCII character code
            values. For Binary, Amazon DynamoDB treats each byte of the binary
            data as unsigned when it compares binary values.
        If ScanIndexForward is not specified, the results are returned in
            ascending order.

        :type exclusive_start_key: map
        :param exclusive_start_key: The primary key of the item from which to
            continue an earlier operation. An earlier operation might provide
            this value as the LastEvaluatedKey if that operation was
            interrupted before completion; either because of the result set
            size or because of the setting for Limit . The LastEvaluatedKey can
            be passed back in a new request to continue the operation from that
            point.
        The data type for ExclusiveStartKey must be String, Number or Binary.
            No set data types are allowed.

        :type return_consumed_capacity: string
        :param return_consumed_capacity:

        """
        params = {'TableName': table_name, }
        if index_name is not None:
            params['IndexName'] = index_name
        if select is not None:
            params['Select'] = select
        if attributes_to_get is not None:
            params['AttributesToGet'] = attributes_to_get
        if limit is not None:
            params['Limit'] = limit
        if consistent_read is not None:
            params['ConsistentRead'] = consistent_read
        if key_conditions is not None:
            params['KeyConditions'] = key_conditions
        if scan_index_forward is not None:
            params['ScanIndexForward'] = scan_index_forward
        if exclusive_start_key is not None:
            params['ExclusiveStartKey'] = exclusive_start_key
        if return_consumed_capacity is not None:
            params['ReturnConsumedCapacity'] = return_consumed_capacity
        return self.make_request(action='Query',
                                 body=json.dumps(params))

</source>
<source file="systems/boto-2.13.2/boto/opsworks/layer1.py" startline="432" endline="557" pcid="3034">
    def create_instance(self, stack_id, layer_ids, instance_type,
                        auto_scaling_type=None, hostname=None, os=None,
                        ami_id=None, ssh_key_name=None,
                        availability_zone=None, subnet_id=None,
                        architecture=None, root_device_type=None,
                        install_updates_on_boot=None):
        """
        Creates an instance in a specified stack. For more
        information, see `Adding an Instance to a Layer`_.

        :type stack_id: string
        :param stack_id: The stack ID.

        :type layer_ids: list
        :param layer_ids: An array that contains the instance layer IDs.

        :type instance_type: string
        :param instance_type: The instance type. AWS OpsWorks supports all
            instance types except Cluster Compute, Cluster GPU, and High Memory
            Cluster. For more information, see `Instance Families and Types`_.
            The parameter values that you use to specify the various types are
            in the API Name column of the Available Instance Types table.

        :type auto_scaling_type: string
        :param auto_scaling_type:
        The instance auto scaling type, which has three possible values:


        + **AlwaysRunning**: A 24/7 instance, which is not affected by auto
              scaling.
        + **TimeBasedAutoScaling**: A time-based auto scaling instance, which
              is started and stopped based on a specified schedule. To specify
              the schedule, call SetTimeBasedAutoScaling.
        + **LoadBasedAutoScaling**: A load-based auto scaling instance, which
              is started and stopped based on load metrics. To use load-based
              auto scaling, you must enable it for the instance layer and
              configure the thresholds by calling SetLoadBasedAutoScaling.

        :type hostname: string
        :param hostname: The instance host name.

        :type os: string
        :param os: The instance operating system, which must be set to one of
            the following.

        + Standard operating systems: `Amazon Linux` or `Ubuntu 12.04 LTS`
        + Custom AMIs: `Custom`


        The default option is `Amazon Linux`. If you set this parameter to
            `Custom`, you must use the CreateInstance action's AmiId parameter
            to specify the custom AMI that you want to use. For more
            information on the standard operating systems, see `Operating
            Systems`_For more information on how to use custom AMIs with
            OpsWorks, see `Using Custom AMIs`_.

        :type ami_id: string
        :param ami_id: A custom AMI ID to be used to create the instance. The
            AMI should be based on one of the standard AWS OpsWorks APIs:
            Amazon Linux or Ubuntu 12.04 LTS. For more information, see
            `Instances`_

        :type ssh_key_name: string
        :param ssh_key_name: The instance SSH key name.

        :type availability_zone: string
        :param availability_zone: The instance Availability Zone. For more
            information, see `Regions and Endpoints`_.

        :type subnet_id: string
        :param subnet_id: The ID of the instance's subnet. If the stack is
            running in a VPC, you can use this parameter to override the
            stack's default subnet ID value and direct AWS OpsWorks to launch
            the instance in a different subnet.

        :type architecture: string
        :param architecture: The instance architecture. Instance types do not
            necessarily support both architectures. For a list of the
            architectures that are supported by the different instance types,
            see `Instance Families and Types`_.

        :type root_device_type: string
        :param root_device_type: The instance root device type. For more
            information, see `Storage for the Root Device`_.

        :type install_updates_on_boot: boolean
        :param install_updates_on_boot:
        Whether to install operating system and package updates when the
            instance boots. The default value is `True`. To control when
            updates are installed, set this value to `False`. You must then
            update your instances manually by using CreateDeployment to run the
            `update_dependencies` stack command or manually running `yum`
            (Amazon Linux) or `apt-get` (Ubuntu) on the instances.

        We strongly recommend using the default value of `True`, to ensure that
            your instances have the latest security updates.

        """
        params = {
            'StackId': stack_id,
            'LayerIds': layer_ids,
            'InstanceType': instance_type,
        }
        if auto_scaling_type is not None:
            params['AutoScalingType'] = auto_scaling_type
        if hostname is not None:
            params['Hostname'] = hostname
        if os is not None:
            params['Os'] = os
        if ami_id is not None:
            params['AmiId'] = ami_id
        if ssh_key_name is not None:
            params['SshKeyName'] = ssh_key_name
        if availability_zone is not None:
            params['AvailabilityZone'] = availability_zone
        if subnet_id is not None:
            params['SubnetId'] = subnet_id
        if architecture is not None:
            params['Architecture'] = architecture
        if root_device_type is not None:
            params['RootDeviceType'] = root_device_type
        if install_updates_on_boot is not None:
            params['InstallUpdatesOnBoot'] = install_updates_on_boot
        return self.make_request(action='CreateInstance',
                                 body=json.dumps(params))

</source>
<source file="systems/boto-2.13.2/boto/dynamodb2/layer1.py" startline="969" endline="1239" pcid="1865">
    def scan(self, table_name, attributes_to_get=None, limit=None,
             select=None, scan_filter=None, exclusive_start_key=None,
             return_consumed_capacity=None, total_segments=None,
             segment=None):
        """
        The Scan operation returns one or more items and item
        attributes by accessing every item in the table. To have
        Amazon DynamoDB return fewer items, you can provide a
        ScanFilter .

        If the total number of scanned items exceeds the maximum data
        set size limit of 1 MB, the scan stops and results are
        returned to the user with a LastEvaluatedKey to continue the
        scan in a subsequent operation. The results also include the
        number of items exceeding the limit. A scan can result in no
        table data meeting the filter criteria.

        The result set is eventually consistent.

        By default, Scan operations proceed sequentially; however, for
        faster performance on large tables, applications can perform a
        parallel Scan by specifying the Segment and TotalSegments
        parameters. For more information, see `Parallel Scan`_ in the
        Amazon DynamoDB Developer Guide .

        :type table_name: string
        :param table_name: The name of the table containing the requested
            items.

        :type attributes_to_get: list
        :param attributes_to_get: The names of one or more attributes to
            retrieve. If no attribute names are specified, then all attributes
            will be returned. If any of the requested attributes are not found,
            they will not appear in the result.

        :type limit: integer
        :param limit: The maximum number of items to evaluate (not necessarily
            the number of matching items). If Amazon DynamoDB processes the
            number of items up to the limit while processing the results, it
            stops the operation and returns the matching values up to that
            point, and a LastEvaluatedKey to apply in a subsequent operation,
            so that you can pick up where you left off. Also, if the processed
            data set size exceeds 1 MB before Amazon DynamoDB reaches this
            limit, it stops the operation and returns the matching values up to
            the limit, and a LastEvaluatedKey to apply in a subsequent
            operation to continue the operation. For more information see
            `Query and Scan`_ in the Amazon DynamoDB Developer Guide .

        :type select: string
        :param select: The attributes to be returned in the result. You can
            retrieve all item attributes, specific item attributes, the count
            of matching items, or in the case of an index, some or all of the
            attributes projected into the index.

        + `ALL_ATTRIBUTES`: Returns all of the item attributes. For a table,
              this is the default. For an index, this mode causes Amazon DynamoDB
              to fetch the full item from the table for each matching item in the
              index. If the index is configured to project all item attributes,
              the matching items will not be fetched from the table. Fetching
              items from the table incurs additional throughput cost and latency.
        + `ALL_PROJECTED_ATTRIBUTES`: Retrieves all attributes which have been
              projected into the index. If the index is configured to project all
              attributes, this is equivalent to specifying ALL_ATTRIBUTES .
        + `COUNT`: Returns the number of matching items, rather than the
              matching items themselves.
        + `SPECIFIC_ATTRIBUTES` : Returns only the attributes listed in
              AttributesToGet . This is equivalent to specifying AttributesToGet
              without specifying any value for Select . If you are querying an
              index and request only attributes that are projected into that
              index, the operation will read only the index and not the table. If
              any of the requested attributes are not projected into the index,
              Amazon DynamoDB will need to fetch each matching item from the
              table. This extra fetching incurs additional throughput cost and
              latency.


        When neither Select nor AttributesToGet are specified, Amazon DynamoDB
            defaults to `ALL_ATTRIBUTES` when accessing a table, and
            `ALL_PROJECTED_ATTRIBUTES` when accessing an index. You cannot use
            both Select and AttributesToGet together in a single request,
            unless the value for Select is `SPECIFIC_ATTRIBUTES`. (This usage
            is equivalent to specifying AttributesToGet without any value for
            Select .)

        :type scan_filter: map
        :param scan_filter:
        Evaluates the scan results and returns only the desired values.
            Multiple conditions are treated as "AND" operations: all conditions
            must be met to be included in the results.

        Each ScanConditions element consists of an attribute name to compare,
            along with the following:


        + AttributeValueList - One or more values to evaluate against the
              supplied attribute. This list contains exactly one value, except
              for a `BETWEEN` or `IN` comparison, in which case the list contains
              two values. For type Number, value comparisons are numeric. String
              value comparisons for greater than, equals, or less than are based
              on ASCII character code values. For example, `a` is greater than
              `A`, and `aa` is greater than `B`. For a list of code values, see
              `http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters`_.
              For Binary, Amazon DynamoDB treats each byte of the binary data as
              unsigned when it compares binary values, for example when
              evaluating query expressions.
        + ComparisonOperator - A comparator for evaluating attributes. For
              example, equals, greater than, less than, etc. Valid comparison
              operators for Scan: `EQ | NE | LE | LT | GE | GT | NOT_NULL | NULL
              | CONTAINS | NOT_CONTAINS | BEGINS_WITH | IN | BETWEEN` For
              information on specifying data types in JSON, see `JSON Data
              Format`_ in the Amazon DynamoDB Developer Guide . The following are
              descriptions of each comparison operator.

            + `EQ` : Equal. AttributeValueList can contain only one AttributeValue
                  of type String, Number, or Binary (not a set). If an item contains
                  an AttributeValue of a different type than the one specified in the
                  request, the value does not match. For example, `{"S":"6"}` does
                  not equal `{"N":"6"}`. Also, `{"N":"6"}` does not equal
                  `{"NS":["6", "2", "1"]}`.
            + `NE` : Not equal. AttributeValueList can contain only one
                  AttributeValue of type String, Number, or Binary (not a set). If an
                  item contains an AttributeValue of a different type than the one
                  specified in the request, the value does not match. For example,
                  `{"S":"6"}` does not equal `{"N":"6"}`. Also, `{"N":"6"}` does not
                  equal `{"NS":["6", "2", "1"]}`.
            + `LE` : Less than or equal. AttributeValueList can contain only one
                  AttributeValue of type String, Number, or Binary (not a set). If an
                  item contains an AttributeValue of a different type than the one
                  specified in the request, the value does not match. For example,
                  `{"S":"6"}` does not equal `{"N":"6"}`. Also, `{"N":"6"}` does not
                  compare to `{"NS":["6", "2", "1"]}`.
            + `LT` : Less than. AttributeValueList can contain only one
                  AttributeValue of type String, Number, or Binary (not a set). If an
                  item contains an AttributeValue of a different type than the one
                  specified in the request, the value does not match. For example,
                  `{"S":"6"}` does not equal `{"N":"6"}`. Also, `{"N":"6"}` does not
                  compare to `{"NS":["6", "2", "1"]}`.
            + `GE` : Greater than or equal. AttributeValueList can contain only one
                  AttributeValue of type String, Number, or Binary (not a set). If an
                  item contains an AttributeValue of a different type than the one
                  specified in the request, the value does not match. For example,
                  `{"S":"6"}` does not equal `{"N":"6"}`. Also, `{"N":"6"}` does not
                  compare to `{"NS":["6", "2", "1"]}`.
            + `GT` : Greater than. AttributeValueList can contain only one
                  AttributeValue of type String, Number, or Binary (not a set). If an
                  item contains an AttributeValue of a different type than the one
                  specified in the request, the value does not match. For example,
                  `{"S":"6"}` does not equal `{"N":"6"}`. Also, `{"N":"6"}` does not
                  compare to `{"NS":["6", "2", "1"]}`.
            + `NOT_NULL` : The attribute exists.
            + `NULL` : The attribute does not exist.
            + `CONTAINS` : checks for a subsequence, or value in a set.
                  AttributeValueList can contain only one AttributeValue of type
                  String, Number, or Binary (not a set). If the target attribute of
                  the comparison is a String, then the operation checks for a
                  substring match. If the target attribute of the comparison is
                  Binary, then the operation looks for a subsequence of the target
                  that matches the input. If the target attribute of the comparison
                  is a set ("SS", "NS", or "BS"), then the operation checks for a
                  member of the set (not as a substring).
            + `NOT_CONTAINS` : checks for absence of a subsequence, or absence of a
                  value in a set. AttributeValueList can contain only one
                  AttributeValue of type String, Number, or Binary (not a set). If
                  the target attribute of the comparison is a String, then the
                  operation checks for the absence of a substring match. If the
                  target attribute of the comparison is Binary, then the operation
                  checks for the absence of a subsequence of the target that matches
                  the input. If the target attribute of the comparison is a set
                  ("SS", "NS", or "BS"), then the operation checks for the absence of
                  a member of the set (not as a substring).
            + `BEGINS_WITH` : checks for a prefix. AttributeValueList can contain
                  only one AttributeValue of type String or Binary (not a Number or a
                  set). The target attribute of the comparison must be a String or
                  Binary (not a Number or a set).
            + `IN` : checks for exact matches. AttributeValueList can contain more
                  than one AttributeValue of type String, Number, or Binary (not a
                  set). The target attribute of the comparison must be of the same
                  type and exact value to match. A String never matches a String set.
            + `BETWEEN` : Greater than or equal to the first value, and less than
                  or equal to the second value. AttributeValueList must contain two
                  AttributeValue elements of the same type, either String, Number, or
                  Binary (not a set). A target attribute matches if the target value
                  is greater than, or equal to, the first element and less than, or
                  equal to, the second element. If an item contains an AttributeValue
                  of a different type than the one specified in the request, the
                  value does not match. For example, `{"S":"6"}` does not compare to
                  `{"N":"6"}`. Also, `{"N":"6"}` does not compare to `{"NS":["6",
                  "2", "1"]}`

        :type exclusive_start_key: map
        :param exclusive_start_key: The primary key of the item from which to
            continue an earlier operation. An earlier operation might provide
            this value as the LastEvaluatedKey if that operation was
            interrupted before completion; either because of the result set
            size or because of the setting for Limit . The LastEvaluatedKey can
            be passed back in a new request to continue the operation from that
            point.
        The data type for ExclusiveStartKey must be String, Number or Binary.
            No set data types are allowed.

        If you are performing a parallel scan, the value of ExclusiveStartKey
            must fall into the key space of the Segment being scanned. For
            example, suppose that there are two application threads scanning a
            table using the following Scan parameters


        + Thread 0: Segment =0; TotalSegments =2
        + Thread 1: Segment =1; TotalSegments =2


        Now suppose that the Scan request for Thread 0 completed and returned a
            LastEvaluatedKey of "X". Because "X" is part of Segment 0's key
            space, it cannot be used anywhere else in the table. If Thread 1
            were to issue another Scan request with an ExclusiveStartKey of
            "X", Amazon DynamoDB would throw an InputValidationError because
            hash key "X" cannot be in Segment 1.

        :type return_consumed_capacity: string
        :param return_consumed_capacity:

        :type total_segments: integer
        :param total_segments: For parallel Scan requests, TotalSegments
            represents the total number of segments for a table that is being
            scanned. Segments are a way to logically divide a table into
            equally sized portions, for the duration of the Scan request. The
            value of TotalSegments corresponds to the number of application
            "workers" (such as threads or processes) that will perform the
            parallel Scan . For example, if you want to scan a table using four
            application threads, you would specify a TotalSegments value of 4.
        The value for TotalSegments must be greater than or equal to 1, and
            less than or equal to 4096. If you specify a TotalSegments value of
            1, the Scan will be sequential rather than parallel.

        If you specify TotalSegments , you must also specify Segment .

        :type segment: integer
        :param segment: For parallel Scan requests, Segment identifies an
            individual segment to be scanned by an application "worker" (such
            as a thread or a process). Each worker issues a Scan request with a
            distinct value for the segment it will scan.
        Segment IDs are zero-based, so the first segment is always 0. For
            example, if you want to scan a table using four application
            threads, the first thread would specify a Segment value of 0, the
            second thread would specify 1, and so on.

        The value for Segment must be greater than or equal to 0, and less than
            the value provided for TotalSegments .

        If you specify Segment , you must also specify TotalSegments .

        """
        params = {'TableName': table_name, }
        if attributes_to_get is not None:
            params['AttributesToGet'] = attributes_to_get
        if limit is not None:
            params['Limit'] = limit
        if select is not None:
            params['Select'] = select
        if scan_filter is not None:
            params['ScanFilter'] = scan_filter
        if exclusive_start_key is not None:
            params['ExclusiveStartKey'] = exclusive_start_key
        if return_consumed_capacity is not None:
            params['ReturnConsumedCapacity'] = return_consumed_capacity
        if total_segments is not None:
            params['TotalSegments'] = total_segments
        if segment is not None:
            params['Segment'] = segment
        return self.make_request(action='Scan',
                                 body=json.dumps(params))

</source>
<source file="systems/boto-2.13.2/boto/opsworks/layer1.py" startline="1672" endline="1765" pcid="3070">
    def update_layer(self, layer_id, name=None, shortname=None,
                     attributes=None, custom_instance_profile_arn=None,
                     custom_security_group_ids=None, packages=None,
                     volume_configurations=None, enable_auto_healing=None,
                     auto_assign_elastic_ips=None, custom_recipes=None,
                     install_updates_on_boot=None):
        """
        Updates a specified layer.

        :type layer_id: string
        :param layer_id: The layer ID.

        :type name: string
        :param name: The layer name, which is used by the console.

        :type shortname: string
        :param shortname: The layer short name, which is used internally by AWS
            OpsWorksand by Chef. The short name is also used as the name for
            the directory where your app files are installed. It can have a
            maximum of 200 characters and must be in the following format:
            /\A[a-z0-9\-\_\.]+\Z/.

        :type attributes: map
        :param attributes: One or more user-defined key/value pairs to be added
            to the stack attributes bag.

        :type custom_instance_profile_arn: string
        :param custom_instance_profile_arn: The ARN of an IAM profile to be
            used for all of the layer's EC2 instances. For more information
            about IAM ARNs, see `Using Identifiers`_.

        :type custom_security_group_ids: list
        :param custom_security_group_ids: An array containing the layer's
            custom security group IDs.

        :type packages: list
        :param packages: An array of `Package` objects that describe the
            layer's packages.

        :type volume_configurations: list
        :param volume_configurations: A `VolumeConfigurations` object that
            describes the layer's Amazon EBS volumes.

        :type enable_auto_healing: boolean
        :param enable_auto_healing: Whether to disable auto healing for the
            layer.

        :type auto_assign_elastic_ips: boolean
        :param auto_assign_elastic_ips: Whether to automatically assign an
            `Elastic IP address`_ to the layer.

        :type custom_recipes: dict
        :param custom_recipes: A `LayerCustomRecipes` object that specifies the
            layer's custom recipes.

        :type install_updates_on_boot: boolean
        :param install_updates_on_boot:
        Whether to install operating system and package updates when the
            instance boots. The default value is `True`. To control when
            updates are installed, set this value to `False`. You must then
            update your instances manually by using CreateDeployment to run the
            `update_dependencies` stack command or manually running `yum`
            (Amazon Linux) or `apt-get` (Ubuntu) on the instances.

        We strongly recommend using the default value of `True`, to ensure that
            your instances have the latest security updates.

        """
        params = {'LayerId': layer_id, }
        if name is not None:
            params['Name'] = name
        if shortname is not None:
            params['Shortname'] = shortname
        if attributes is not None:
            params['Attributes'] = attributes
        if custom_instance_profile_arn is not None:
            params['CustomInstanceProfileArn'] = custom_instance_profile_arn
        if custom_security_group_ids is not None:
            params['CustomSecurityGroupIds'] = custom_security_group_ids
        if packages is not None:
            params['Packages'] = packages
        if volume_configurations is not None:
            params['VolumeConfigurations'] = volume_configurations
        if enable_auto_healing is not None:
            params['EnableAutoHealing'] = enable_auto_healing
        if auto_assign_elastic_ips is not None:
            params['AutoAssignElasticIps'] = auto_assign_elastic_ips
        if custom_recipes is not None:
            params['CustomRecipes'] = custom_recipes
        if install_updates_on_boot is not None:
            params['InstallUpdatesOnBoot'] = install_updates_on_boot
        return self.make_request(action='UpdateLayer',
                                 body=json.dumps(params))

</source>
<source file="systems/boto-2.13.2/boto/opsworks/layer1.py" startline="558" endline="677" pcid="3035">
    def create_layer(self, stack_id, type, name, shortname, attributes=None,
                     custom_instance_profile_arn=None,
                     custom_security_group_ids=None, packages=None,
                     volume_configurations=None, enable_auto_healing=None,
                     auto_assign_elastic_ips=None, custom_recipes=None,
                     install_updates_on_boot=None):
        """
        Creates a layer. For more information, see `How to Create a
        Layer`_.

        You should use **CreateLayer** for noncustom layer types such
        as PHP App Server only if the stack does not have an existing
        layer of that type. A stack can have at most one instance of
        each noncustom layer; if you attempt to create a second
        instance, **CreateLayer** fails. A stack can have an arbitrary
        number of custom layers, so you can call **CreateLayer** as
        many times as you like for that layer type.

        :type stack_id: string
        :param stack_id: The layer stack ID.

        :type type: string
        :param type:
        The layer type. A stack cannot have more than one layer of the same
            type. This parameter must be set to one of the following:


        + lb: An HAProxy layer
        + web: A Static Web Server layer
        + rails-app: A Rails App Server layer
        + php-app: A PHP App Server layer
        + nodejs-app: A Node.js App Server layer
        + memcached: A Memcached layer
        + db-master: A MySQL layer
        + monitoring-master: A Ganglia layer
        + custom: A custom layer

        :type name: string
        :param name: The layer name, which is used by the console.

        :type shortname: string
        :param shortname: The layer short name, which is used internally by AWS
            OpsWorks and by Chef recipes. The short name is also used as the
            name for the directory where your app files are installed. It can
            have a maximum of 200 characters, which are limited to the
            alphanumeric characters, '-', '_', and '.'.

        :type attributes: map
        :param attributes: One or more user-defined key/value pairs to be added
            to the stack attributes bag.

        :type custom_instance_profile_arn: string
        :param custom_instance_profile_arn: The ARN of an IAM profile that to
            be used for the layer's EC2 instances. For more information about
            IAM ARNs, see `Using Identifiers`_.

        :type custom_security_group_ids: list
        :param custom_security_group_ids: An array containing the layer custom
            security group IDs.

        :type packages: list
        :param packages: An array of `Package` objects that describe the layer
            packages.

        :type volume_configurations: list
        :param volume_configurations: A `VolumeConfigurations` object that
            describes the layer Amazon EBS volumes.

        :type enable_auto_healing: boolean
        :param enable_auto_healing: Whether to disable auto healing for the
            layer.

        :type auto_assign_elastic_ips: boolean
        :param auto_assign_elastic_ips: Whether to automatically assign an
            `Elastic IP address`_ to the layer.

        :type custom_recipes: dict
        :param custom_recipes: A `LayerCustomRecipes` object that specifies the
            layer custom recipes.

        :type install_updates_on_boot: boolean
        :param install_updates_on_boot:
        Whether to install operating system and package updates when the
            instance boots. The default value is `True`. To control when
            updates are installed, set this value to `False`. You must then
            update your instances manually by using CreateDeployment to run the
            `update_dependencies` stack command or manually running `yum`
            (Amazon Linux) or `apt-get` (Ubuntu) on the instances.

        We strongly recommend using the default value of `True`, to ensure that
            your instances have the latest security updates.

        """
        params = {
            'StackId': stack_id,
            'Type': type,
            'Name': name,
            'Shortname': shortname,
        }
        if attributes is not None:
            params['Attributes'] = attributes
        if custom_instance_profile_arn is not None:
            params['CustomInstanceProfileArn'] = custom_instance_profile_arn
        if custom_security_group_ids is not None:
            params['CustomSecurityGroupIds'] = custom_security_group_ids
        if packages is not None:
            params['Packages'] = packages
        if volume_configurations is not None:
            params['VolumeConfigurations'] = volume_configurations
        if enable_auto_healing is not None:
            params['EnableAutoHealing'] = enable_auto_healing
        if auto_assign_elastic_ips is not None:
            params['AutoAssignElasticIps'] = auto_assign_elastic_ips
        if custom_recipes is not None:
            params['CustomRecipes'] = custom_recipes
        if install_updates_on_boot is not None:
            params['InstallUpdatesOnBoot'] = install_updates_on_boot
        return self.make_request(action='CreateLayer',
                                 body=json.dumps(params))

</source>
<source file="systems/boto-2.13.2/boto/elastictranscoder/layer1.py" startline="81" endline="143" pcid="3079">
    def create_job(self, pipeline_id=None, input_name=None, output=None,
                   outputs=None, output_key_prefix=None, playlists=None):
        """
        When you create a job, Elastic Transcoder returns JSON data
        that includes the values that you specified plus information
        about the job that is created.

        If you have specified more than one output for your jobs (for
        example, one output for the Kindle Fire and another output for
        the Apple iPhone 4s), you currently must use the Elastic
        Transcoder API to list the jobs (as opposed to the AWS
        Console).

        :type pipeline_id: string
        :param pipeline_id: The `Id` of the pipeline that you want Elastic
            Transcoder to use for transcoding. The pipeline determines several
            settings, including the Amazon S3 bucket from which Elastic
            Transcoder gets the files to transcode and the bucket into which
            Elastic Transcoder puts the transcoded files.

        :type input_name: dict
        :param input_name: A section of the request body that provides
            information about the file that is being transcoded.

        :type output: dict
        :param output: The `CreateJobOutput` structure.

        :type outputs: list
        :param outputs: A section of the request body that provides information
            about the transcoded (target) files. We recommend that you use the
            `Outputs` syntax instead of the `Output` syntax.

        :type output_key_prefix: string
        :param output_key_prefix: The value, if any, that you want Elastic
            Transcoder to prepend to the names of all files that this job
            creates, including output files, thumbnails, and playlists.

        :type playlists: list
        :param playlists: If you specify a preset in `PresetId` for which the
            value of `Container` is ts (MPEG-TS), Playlists contains
            information about the master playlists that you want Elastic
            Transcoder to create.
        We recommend that you create only one master playlist. The maximum
            number of master playlists in a job is 30.

        """
        uri = '/2012-09-25/jobs'
        params = {}
        if pipeline_id is not None:
            params['PipelineId'] = pipeline_id
        if input_name is not None:
            params['Input'] = input_name
        if output is not None:
            params['Output'] = output
        if outputs is not None:
            params['Outputs'] = outputs
        if output_key_prefix is not None:
            params['OutputKeyPrefix'] = output_key_prefix
        if playlists is not None:
            params['Playlists'] = playlists
        return self.make_request('POST', uri, expected_status=201,
                                 data=json.dumps(params))

</source>
<source file="systems/boto-2.13.2/boto/elastictranscoder/layer1.py" startline="631" endline="808" pcid="3092">
    def update_pipeline(self, id, name=None, input_bucket=None, role=None,
                        notifications=None, content_config=None,
                        thumbnail_config=None):
        """
        Use the `UpdatePipeline` operation to update settings for a
        pipeline. When you change pipeline settings, your changes take
        effect immediately. Jobs that you have already submitted and
        that Elastic Transcoder has not started to process are
        affected in addition to jobs that you submit after you change
        settings.

        :type id: string
        :param id: The ID of the pipeline that you want to update.

        :type name: string
        :param name: The name of the pipeline. We recommend that the name be
            unique within the AWS account, but uniqueness is not enforced.
        Constraints: Maximum 40 characters

        :type input_bucket: string
        :param input_bucket: The Amazon S3 bucket in which you saved the media
            files that you want to transcode and the graphics that you want to
            use as watermarks.

        :type role: string
        :param role: The IAM Amazon Resource Name (ARN) for the role that you
            want Elastic Transcoder to use to transcode jobs for this pipeline.

        :type notifications: dict
        :param notifications:
        The Amazon Simple Notification Service (Amazon SNS) topic or topics to
            notify in order to report job status.
        To receive notifications, you must also subscribe to the new topic in
            the Amazon SNS console.

        :type content_config: dict
        :param content_config:
        The optional `ContentConfig` object specifies information about the
            Amazon S3 bucket in which you want Elastic Transcoder to save
            transcoded files and playlists: which bucket to use, which users
            you want to have access to the files, the type of access you want
            users to have, and the storage class that you want to assign to the
            files.

        If you specify values for `ContentConfig`, you must also specify values
            for `ThumbnailConfig`.

        If you specify values for `ContentConfig` and `ThumbnailConfig`, omit
            the `OutputBucket` object.


        + **Bucket**: The Amazon S3 bucket in which you want Elastic Transcoder
              to save transcoded files and playlists.
        + **Permissions** (Optional): The Permissions object specifies which
              users you want to have access to transcoded files and the type of
              access you want them to have. You can grant permissions to a
              maximum of 30 users and/or predefined Amazon S3 groups.
        + **Grantee Type**: Specify the type of value that appears in the
              `Grantee` object:

            + **Canonical**: The value in the `Grantee` object is either the
                  canonical user ID for an AWS account or an origin access identity
                  for an Amazon CloudFront distribution. For more information about
                  canonical user IDs, see Access Control List (ACL) Overview in the
                  Amazon Simple Storage Service Developer Guide. For more information
                  about using CloudFront origin access identities to require that
                  users use CloudFront URLs instead of Amazon S3 URLs, see Using an
                  Origin Access Identity to Restrict Access to Your Amazon S3
                  Content. A canonical user ID is not the same as an AWS account
                  number.
            + **Email**: The value in the `Grantee` object is the registered email
                  address of an AWS account.
            + **Group**: The value in the `Grantee` object is one of the following
                  predefined Amazon S3 groups: `AllUsers`, `AuthenticatedUsers`, or
                  `LogDelivery`.

        + **Grantee**: The AWS user or group that you want to have access to
              transcoded files and playlists. To identify the user or group, you
              can specify the canonical user ID for an AWS account, an origin
              access identity for a CloudFront distribution, the registered email
              address of an AWS account, or a predefined Amazon S3 group
        + **Access**: The permission that you want to give to the AWS user that
              you specified in `Grantee`. Permissions are granted on the files
              that Elastic Transcoder adds to the bucket, including playlists and
              video files. Valid values include:

            + `READ`: The grantee can read the objects and metadata for objects
                  that Elastic Transcoder adds to the Amazon S3 bucket.
            + `READ_ACP`: The grantee can read the object ACL for objects that
                  Elastic Transcoder adds to the Amazon S3 bucket.
            + `WRITE_ACP`: The grantee can write the ACL for the objects that
                  Elastic Transcoder adds to the Amazon S3 bucket.
            + `FULL_CONTROL`: The grantee has `READ`, `READ_ACP`, and `WRITE_ACP`
                  permissions for the objects that Elastic Transcoder adds to the
                  Amazon S3 bucket.

        + **StorageClass**: The Amazon S3 storage class, `Standard` or
              `ReducedRedundancy`, that you want Elastic Transcoder to assign to
              the video files and playlists that it stores in your Amazon S3
              bucket.

        :type thumbnail_config: dict
        :param thumbnail_config:
        The `ThumbnailConfig` object specifies several values, including the
            Amazon S3 bucket in which you want Elastic Transcoder to save
            thumbnail files, which users you want to have access to the files,
            the type of access you want users to have, and the storage class
            that you want to assign to the files.

        If you specify values for `ContentConfig`, you must also specify values
            for `ThumbnailConfig` even if you don't want to create thumbnails.

        If you specify values for `ContentConfig` and `ThumbnailConfig`, omit
            the `OutputBucket` object.


        + **Bucket**: The Amazon S3 bucket in which you want Elastic Transcoder
              to save thumbnail files.
        + **Permissions** (Optional): The `Permissions` object specifies which
              users and/or predefined Amazon S3 groups you want to have access to
              thumbnail files, and the type of access you want them to have. You
              can grant permissions to a maximum of 30 users and/or predefined
              Amazon S3 groups.
        + **GranteeType**: Specify the type of value that appears in the
              Grantee object:

            + **Canonical**: The value in the `Grantee` object is either the
                  canonical user ID for an AWS account or an origin access identity
                  for an Amazon CloudFront distribution. A canonical user ID is not
                  the same as an AWS account number.
            + **Email**: The value in the `Grantee` object is the registered email
                  address of an AWS account.
            + **Group**: The value in the `Grantee` object is one of the following
                  predefined Amazon S3 groups: `AllUsers`, `AuthenticatedUsers`, or
                  `LogDelivery`.

        + **Grantee**: The AWS user or group that you want to have access to
              thumbnail files. To identify the user or group, you can specify the
              canonical user ID for an AWS account, an origin access identity for
              a CloudFront distribution, the registered email address of an AWS
              account, or a predefined Amazon S3 group.
        + **Access**: The permission that you want to give to the AWS user that
              you specified in `Grantee`. Permissions are granted on the
              thumbnail files that Elastic Transcoder adds to the bucket. Valid
              values include:

            + `READ`: The grantee can read the thumbnails and metadata for objects
                  that Elastic Transcoder adds to the Amazon S3 bucket.
            + `READ_ACP`: The grantee can read the object ACL for thumbnails that
                  Elastic Transcoder adds to the Amazon S3 bucket.
            + `WRITE_ACP`: The grantee can write the ACL for the thumbnails that
                  Elastic Transcoder adds to the Amazon S3 bucket.
            + `FULL_CONTROL`: The grantee has `READ`, `READ_ACP`, and `WRITE_ACP`
                  permissions for the thumbnails that Elastic Transcoder adds to the
                  Amazon S3 bucket.

        + **StorageClass**: The Amazon S3 storage class, `Standard` or
              `ReducedRedundancy`, that you want Elastic Transcoder to assign to
              the thumbnails that it stores in your Amazon S3 bucket.

        """
        uri = '/2012-09-25/pipelines/{0}'.format(id)
        params = {}
        if name is not None:
            params['Name'] = name
        if input_bucket is not None:
            params['InputBucket'] = input_bucket
        if role is not None:
            params['Role'] = role
        if notifications is not None:
            params['Notifications'] = notifications
        if content_config is not None:
            params['ContentConfig'] = content_config
        if thumbnail_config is not None:
            params['ThumbnailConfig'] = thumbnail_config
        return self.make_request('PUT', uri, expected_status=200,
                                 data=json.dumps(params))

</source>
<source file="systems/boto-2.13.2/boto/elastictranscoder/layer1.py" startline="360" endline="422" pcid="3081">
    def create_preset(self, name=None, description=None, container=None,
                      video=None, audio=None, thumbnails=None):
        """
        The CreatePreset operation creates a preset with settings that
        you specify.
        Elastic Transcoder checks the CreatePreset settings to ensure
        that they meet Elastic Transcoder requirements and to
        determine whether they comply with H.264 standards. If your
        settings are not valid for Elastic Transcoder, Elastic
        Transcoder returns an HTTP 400 response (
        `ValidationException`) and does not create the preset. If the
        settings are valid for Elastic Transcoder but aren't strictly
        compliant with the H.264 standard, Elastic Transcoder creates
        the preset and returns a warning message in the response. This
        helps you determine whether your settings comply with the
        H.264 standard while giving you greater flexibility with
        respect to the video that Elastic Transcoder produces.
        Elastic Transcoder uses the H.264 video-compression format.
        For more information, see the International Telecommunication
        Union publication Recommendation ITU-T H.264: Advanced video
        coding for generic audiovisual services .

        :type name: string
        :param name: The name of the preset. We recommend that the name be
            unique within the AWS account, but uniqueness is not enforced.

        :type description: string
        :param description: A description of the preset.

        :type container: string
        :param container: The container type for the output file. This value
            must be `mp4`.

        :type video: dict
        :param video: A section of the request body that specifies the video
            parameters.

        :type audio: dict
        :param audio: A section of the request body that specifies the audio
            parameters.

        :type thumbnails: dict
        :param thumbnails: A section of the request body that specifies the
            thumbnail parameters, if any.

        """
        uri = '/2012-09-25/presets'
        params = {}
        if name is not None:
            params['Name'] = name
        if description is not None:
            params['Description'] = description
        if container is not None:
            params['Container'] = container
        if video is not None:
            params['Video'] = video
        if audio is not None:
            params['Audio'] = audio
        if thumbnails is not None:
            params['Thumbnails'] = thumbnails
        return self.make_request('POST', uri, expected_status=201,
                                 data=json.dumps(params))

</source>
<source file="systems/boto-2.13.2/boto/opsworks/layer1.py" startline="315" endline="376" pcid="3032">
    def create_app(self, stack_id, name, type, shortname=None,
                   description=None, app_source=None, domains=None,
                   enable_ssl=None, ssl_configuration=None, attributes=None):
        """
        Creates an app for a specified stack. For more information,
        see `Creating Apps`_.

        :type stack_id: string
        :param stack_id: The stack ID.

        :type shortname: string
        :param shortname: The app's short name.

        :type name: string
        :param name: The app name.

        :type description: string
        :param description: A description of the app.

        :type type: string
        :param type: The app type. Each supported type is associated with a
            particular layer. For example, PHP applications are associated with
            a PHP layer. AWS OpsWorks deploys an application to those instances
            that are members of the corresponding layer.

        :type app_source: dict
        :param app_source: A `Source` object that specifies the app repository.

        :type domains: list
        :param domains: The app virtual host settings, with multiple domains
            separated by commas. For example: `'www.example.com, example.com'`

        :type enable_ssl: boolean
        :param enable_ssl: Whether to enable SSL for the app.

        :type ssl_configuration: dict
        :param ssl_configuration: An `SslConfiguration` object with the SSL
            configuration.

        :type attributes: map
        :param attributes: One or more user-defined key/value pairs to be added
            to the stack attributes bag.

        """
        params = {'StackId': stack_id, 'Name': name, 'Type': type, }
        if shortname is not None:
            params['Shortname'] = shortname
        if description is not None:
            params['Description'] = description
        if app_source is not None:
            params['AppSource'] = app_source
        if domains is not None:
            params['Domains'] = domains
        if enable_ssl is not None:
            params['EnableSsl'] = enable_ssl
        if ssl_configuration is not None:
            params['SslConfiguration'] = ssl_configuration
        if attributes is not None:
            params['Attributes'] = attributes
        return self.make_request(action='CreateApp',
                                 body=json.dumps(params))

</source>
<source file="systems/boto-2.13.2/boto/opsworks/layer1.py" startline="678" endline="854" pcid="3036">
    def create_stack(self, name, region, service_role_arn,
                     default_instance_profile_arn, vpc_id=None,
                     attributes=None, default_os=None, hostname_theme=None,
                     default_availability_zone=None, default_subnet_id=None,
                     custom_json=None, configuration_manager=None,
                     use_custom_cookbooks=None, custom_cookbooks_source=None,
                     default_ssh_key_name=None,
                     default_root_device_type=None):
        """
        Creates a new stack. For more information, see `Create a New
        Stack`_.

        :type name: string
        :param name: The stack name.

        :type region: string
        :param region: The stack AWS region, such as "us-east-1". For more
            information about Amazon regions, see `Regions and Endpoints`_.

        :type vpc_id: string
        :param vpc_id: The ID of the VPC that the stack is to be launched into.
            It must be in the specified region. All instances will be launched
            into this VPC, and you cannot change the ID later.

        + If your account supports EC2 Classic, the default value is no VPC.
        + If you account does not support EC2 Classic, the default value is the
              default VPC for the specified region.


        If the VPC ID corresponds to a default VPC and you have specified
            either the `DefaultAvailabilityZone` or the `DefaultSubnetId`
            parameter only, AWS OpsWorks infers the value of the other
            parameter. If you specify neither parameter, AWS OpsWorks sets
            these parameters to the first valid Availability Zone for the
            specified region and the corresponding default VPC subnet ID,
            respectively.

        If you specify a nondefault VPC ID, note the following:


        + It must belong to a VPC in your account that is in the specified
              region.
        + You must specify a value for `DefaultSubnetId`.


        For more information on how to use AWS OpsWorks with a VPC, see
            `Running a Stack in a VPC`_. For more information on default VPC
            and EC2 Classic, see `Supported Platforms`_.

        :type attributes: map
        :param attributes: One or more user-defined key/value pairs to be added
            to the stack attributes bag.

        :type service_role_arn: string
        :param service_role_arn: The stack AWS Identity and Access Management
            (IAM) role, which allows AWS OpsWorks to work with AWS resources on
            your behalf. You must set this parameter to the Amazon Resource
            Name (ARN) for an existing IAM role. For more information about IAM
            ARNs, see `Using Identifiers`_.

        :type default_instance_profile_arn: string
        :param default_instance_profile_arn: The ARN of an IAM profile that is
            the default profile for all of the stack's EC2 instances. For more
            information about IAM ARNs, see `Using Identifiers`_.

        :type default_os: string
        :param default_os: The stack's default operating system, which must be
            set to `Amazon Linux` or `Ubuntu 12.04 LTS`. The default option is
            `Amazon Linux`.

        :type hostname_theme: string
        :param hostname_theme: The stack's host name theme, with spaces are
            replaced by underscores. The theme is used to generate host names
            for the stack's instances. By default, `HostnameTheme` is set to
            Layer_Dependent, which creates host names by appending integers to
            the layer's short name. The other themes are:

        + Baked_Goods
        + Clouds
        + European_Cities
        + Fruits
        + Greek_Deities
        + Legendary_Creatures_from_Japan
        + Planets_and_Moons
        + Roman_Deities
        + Scottish_Islands
        + US_Cities
        + Wild_Cats


        To obtain a generated host name, call `GetHostNameSuggestion`, which
            returns a host name based on the current theme.

        :type default_availability_zone: string
        :param default_availability_zone: The stack's default Availability
            Zone, which must be in the specified region. For more information,
            see `Regions and Endpoints`_. If you also specify a value for
            `DefaultSubnetId`, the subnet must be in the same zone. For more
            information, see the `VpcId` parameter description.

        :type default_subnet_id: string
        :param default_subnet_id: The stack's default subnet ID. All instances
            will be launched into this subnet unless you specify otherwise when
            you create the instance. If you also specify a value for
            `DefaultAvailabilityZone`, the subnet must be in that zone. For
            information on default values and when this parameter is required,
            see the `VpcId` parameter description.

        :type custom_json: string
        :param custom_json: A string that contains user-defined, custom JSON.
            It is used to override the corresponding default stack
            configuration JSON values. The string should be in the following
            format and must escape characters such as '"'.: `"{\"key1\":
            \"value1\", \"key2\": \"value2\",...}"`
        For more information on custom JSON, see `Use Custom JSON to Modify the
            Stack Configuration JSON`_.

        :type configuration_manager: dict
        :param configuration_manager: The configuration manager. When you
            create a stack we recommend that you use the configuration manager
            to specify the Chef version, 0.9 or 11.4. The default value is
            currently 0.9. However, we expect to change the default value to
            11.4 in September 2013.

        :type use_custom_cookbooks: boolean
        :param use_custom_cookbooks: Whether the stack uses custom cookbooks.

        :type custom_cookbooks_source: dict
        :param custom_cookbooks_source: Contains the information required to
            retrieve an app or cookbook from a repository. For more
            information, see `Creating Apps`_ or `Custom Recipes and
            Cookbooks`_.

        :type default_ssh_key_name: string
        :param default_ssh_key_name: A default SSH key for the stack instances.
            You can override this value when you create or update an instance.

        :type default_root_device_type: string
        :param default_root_device_type: The default root device type. This
            value is used by default for all instances in the cloned stack, but
            you can override it when you create an instance. For more
            information, see `Storage for the Root Device`_.

        """
        params = {
            'Name': name,
            'Region': region,
            'ServiceRoleArn': service_role_arn,
            'DefaultInstanceProfileArn': default_instance_profile_arn,
        }
        if vpc_id is not None:
            params['VpcId'] = vpc_id
        if attributes is not None:
            params['Attributes'] = attributes
        if default_os is not None:
            params['DefaultOs'] = default_os
        if hostname_theme is not None:
            params['HostnameTheme'] = hostname_theme
        if default_availability_zone is not None:
            params['DefaultAvailabilityZone'] = default_availability_zone
        if default_subnet_id is not None:
            params['DefaultSubnetId'] = default_subnet_id
        if custom_json is not None:
            params['CustomJson'] = custom_json
        if configuration_manager is not None:
            params['ConfigurationManager'] = configuration_manager
        if use_custom_cookbooks is not None:
            params['UseCustomCookbooks'] = use_custom_cookbooks
        if custom_cookbooks_source is not None:
            params['CustomCookbooksSource'] = custom_cookbooks_source
        if default_ssh_key_name is not None:
            params['DefaultSshKeyName'] = default_ssh_key_name
        if default_root_device_type is not None:
            params['DefaultRootDeviceType'] = default_root_device_type
        return self.make_request(action='CreateStack',
                                 body=json.dumps(params))

</source>
<source file="systems/boto-2.13.2/boto/opsworks/layer1.py" startline="1766" endline="1913" pcid="3071">
    def update_stack(self, stack_id, name=None, attributes=None,
                     service_role_arn=None,
                     default_instance_profile_arn=None, default_os=None,
                     hostname_theme=None, default_availability_zone=None,
                     default_subnet_id=None, custom_json=None,
                     configuration_manager=None, use_custom_cookbooks=None,
                     custom_cookbooks_source=None, default_ssh_key_name=None,
                     default_root_device_type=None):
        """
        Updates a specified stack.

        :type stack_id: string
        :param stack_id: The stack ID.

        :type name: string
        :param name: The stack's new name.

        :type attributes: map
        :param attributes: One or more user-defined key/value pairs to be added
            to the stack attributes bag.

        :type service_role_arn: string
        :param service_role_arn:
        The stack AWS Identity and Access Management (IAM) role, which allows
            AWS OpsWorks to work with AWS resources on your behalf. You must
            set this parameter to the Amazon Resource Name (ARN) for an
            existing IAM role. For more information about IAM ARNs, see `Using
            Identifiers`_.

        You must set this parameter to a valid service role ARN or the action
            will fail; there is no default value. You can specify the stack's
            current service role ARN, if you prefer, but you must do so
            explicitly.

        :type default_instance_profile_arn: string
        :param default_instance_profile_arn: The ARN of an IAM profile that is
            the default profile for all of the stack's EC2 instances. For more
            information about IAM ARNs, see `Using Identifiers`_.

        :type default_os: string
        :param default_os: The stack's default operating system, which must be
            set to `Amazon Linux` or `Ubuntu 12.04 LTS`. The default option is
            `Amazon Linux`.

        :type hostname_theme: string
        :param hostname_theme: The stack's new host name theme, with spaces are
            replaced by underscores. The theme is used to generate host names
            for the stack's instances. By default, `HostnameTheme` is set to
            Layer_Dependent, which creates host names by appending integers to
            the layer's short name. The other themes are:

        + Baked_Goods
        + Clouds
        + European_Cities
        + Fruits
        + Greek_Deities
        + Legendary_Creatures_from_Japan
        + Planets_and_Moons
        + Roman_Deities
        + Scottish_Islands
        + US_Cities
        + Wild_Cats


        To obtain a generated host name, call `GetHostNameSuggestion`, which
            returns a host name based on the current theme.

        :type default_availability_zone: string
        :param default_availability_zone: The stack's default Availability
            Zone, which must be in the specified region. For more information,
            see `Regions and Endpoints`_. If you also specify a value for
            `DefaultSubnetId`, the subnet must be in the same zone. For more
            information, see CreateStack.

        :type default_subnet_id: string
        :param default_subnet_id: The stack's default subnet ID. All instances
            will be launched into this subnet unless you specify otherwise when
            you create the instance. If you also specify a value for
            `DefaultAvailabilityZone`, the subnet must be in that zone. For
            more information, see CreateStack.

        :type custom_json: string
        :param custom_json: A string that contains user-defined, custom JSON.
            It is used to override the corresponding default stack
            configuration JSON values. The string should be in the following
            format and must escape characters such as '"'.: `"{\"key1\":
            \"value1\", \"key2\": \"value2\",...}"`
        For more information on custom JSON, see `Use Custom JSON to Modify the
            Stack Configuration JSON`_.

        :type configuration_manager: dict
        :param configuration_manager: The configuration manager. When you
            update a stack you can optionally use the configuration manager to
            specify the Chef version, 0.9 or 11.4. If you omit this parameter,
            AWS OpsWorks does not change the Chef version.

        :type use_custom_cookbooks: boolean
        :param use_custom_cookbooks: Whether the stack uses custom cookbooks.

        :type custom_cookbooks_source: dict
        :param custom_cookbooks_source: Contains the information required to
            retrieve an app or cookbook from a repository. For more
            information, see `Creating Apps`_ or `Custom Recipes and
            Cookbooks`_.

        :type default_ssh_key_name: string
        :param default_ssh_key_name: A default SSH key for the stack instances.
            You can override this value when you create or update an instance.

        :type default_root_device_type: string
        :param default_root_device_type: The default root device type. This
            value is used by default for all instances in the cloned stack, but
            you can override it when you create an instance. For more
            information, see `Storage for the Root Device`_.

        """
        params = {'StackId': stack_id, }
        if name is not None:
            params['Name'] = name
        if attributes is not None:
            params['Attributes'] = attributes
        if service_role_arn is not None:
            params['ServiceRoleArn'] = service_role_arn
        if default_instance_profile_arn is not None:
            params['DefaultInstanceProfileArn'] = default_instance_profile_arn
        if default_os is not None:
            params['DefaultOs'] = default_os
        if hostname_theme is not None:
            params['HostnameTheme'] = hostname_theme
        if default_availability_zone is not None:
            params['DefaultAvailabilityZone'] = default_availability_zone
        if default_subnet_id is not None:
            params['DefaultSubnetId'] = default_subnet_id
        if custom_json is not None:
            params['CustomJson'] = custom_json
        if configuration_manager is not None:
            params['ConfigurationManager'] = configuration_manager
        if use_custom_cookbooks is not None:
            params['UseCustomCookbooks'] = use_custom_cookbooks
        if custom_cookbooks_source is not None:
            params['CustomCookbooksSource'] = custom_cookbooks_source
        if default_ssh_key_name is not None:
            params['DefaultSshKeyName'] = default_ssh_key_name
        if default_root_device_type is not None:
            params['DefaultRootDeviceType'] = default_root_device_type
        return self.make_request(action='UpdateStack',
                                 body=json.dumps(params))

</source>
<source file="systems/boto-2.13.2/boto/elastictranscoder/layer1.py" startline="585" endline="630" pcid="3091">
    def test_role(self, role=None, input_bucket=None, output_bucket=None,
                  topics=None):
        """
        The TestRole operation tests the IAM role used to create the
        pipeline.

        The `TestRole` action lets you determine whether the IAM role
        you are using has sufficient permissions to let Elastic
        Transcoder perform tasks associated with the transcoding
        process. The action attempts to assume the specified IAM role,
        checks read access to the input and output buckets, and tries
        to send a test notification to Amazon SNS topics that you
        specify.

        :type role: string
        :param role: The IAM Amazon Resource Name (ARN) for the role that you
            want Elastic Transcoder to test.

        :type input_bucket: string
        :param input_bucket: The Amazon S3 bucket that contains media files to
            be transcoded. The action attempts to read from this bucket.

        :type output_bucket: string
        :param output_bucket: The Amazon S3 bucket that Elastic Transcoder will
            write transcoded media files to. The action attempts to read from
            this bucket.

        :type topics: list
        :param topics: The ARNs of one or more Amazon Simple Notification
            Service (Amazon SNS) topics that you want the action to send a test
            notification to.

        """
        uri = '/2012-09-25/roleTests'
        params = {}
        if role is not None:
            params['Role'] = role
        if input_bucket is not None:
            params['InputBucket'] = input_bucket
        if output_bucket is not None:
            params['OutputBucket'] = output_bucket
        if topics is not None:
            params['Topics'] = topics
        return self.make_request('POST', uri, expected_status=200,
                                 data=json.dumps(params))

</source>
<source file="systems/boto-2.13.2/boto/opsworks/layer1.py" startline="110" endline="314" pcid="3031">
    def clone_stack(self, source_stack_id, service_role_arn, name=None,
                    region=None, vpc_id=None, attributes=None,
                    default_instance_profile_arn=None, default_os=None,
                    hostname_theme=None, default_availability_zone=None,
                    default_subnet_id=None, custom_json=None,
                    configuration_manager=None, use_custom_cookbooks=None,
                    custom_cookbooks_source=None, default_ssh_key_name=None,
                    clone_permissions=None, clone_app_ids=None,
                    default_root_device_type=None):
        """
        Creates a clone of a specified stack. For more information,
        see `Clone a Stack`_.

        :type source_stack_id: string
        :param source_stack_id: The source stack ID.

        :type name: string
        :param name: The cloned stack name.

        :type region: string
        :param region: The cloned stack AWS region, such as "us-east-1". For
            more information about AWS regions, see `Regions and Endpoints`_.

        :type vpc_id: string
        :param vpc_id: The ID of the VPC that the cloned stack is to be
            launched into. It must be in the specified region. All instances
            will be launched into this VPC, and you cannot change the ID later.

        + If your account supports EC2 Classic, the default value is no VPC.
        + If you account does not support EC2 Classic, the default value is the
              default VPC for the specified region.


        If the VPC ID corresponds to a default VPC and you have specified
            either the `DefaultAvailabilityZone` or the `DefaultSubnetId`
            parameter only, AWS OpsWorks infers the value of the other
            parameter. If you specify neither parameter, AWS OpsWorks sets
            these parameters to the first valid Availability Zone for the
            specified region and the corresponding default VPC subnet ID,
            respectively.

        If you specify a nondefault VPC ID, note the following:


        + It must belong to a VPC in your account that is in the specified
              region.
        + You must specify a value for `DefaultSubnetId`.


        For more information on how to use AWS OpsWorks with a VPC, see
            `Running a Stack in a VPC`_. For more information on default VPC
            and EC2 Classic, see `Supported Platforms`_.

        :type attributes: map
        :param attributes: A list of stack attributes and values as key/value
            pairs to be added to the cloned stack.

        :type service_role_arn: string
        :param service_role_arn:
        The stack AWS Identity and Access Management (IAM) role, which allows
            AWS OpsWorks to work with AWS resources on your behalf. You must
            set this parameter to the Amazon Resource Name (ARN) for an
            existing IAM role. If you create a stack by using the AWS OpsWorks
            console, it creates the role for you. You can obtain an existing
            stack's IAM ARN programmatically by calling DescribePermissions.
            For more information about IAM ARNs, see `Using Identifiers`_.

        You must set this parameter to a valid service role ARN or the action
            will fail; there is no default value. You can specify the source
            stack's service role ARN, if you prefer, but you must do so
            explicitly.

        :type default_instance_profile_arn: string
        :param default_instance_profile_arn: The ARN of an IAM profile that is
            the default profile for all of the stack's EC2 instances. For more
            information about IAM ARNs, see `Using Identifiers`_.

        :type default_os: string
        :param default_os: The cloned stack's default operating system, which
            must be set to `Amazon Linux` or `Ubuntu 12.04 LTS`. The default
            option is `Amazon Linux`.

        :type hostname_theme: string
        :param hostname_theme: The stack's host name theme, with spaces are
            replaced by underscores. The theme is used to generate host names
            for the stack's instances. By default, `HostnameTheme` is set to
            Layer_Dependent, which creates host names by appending integers to
            the layer's short name. The other themes are:

        + Baked_Goods
        + Clouds
        + European_Cities
        + Fruits
        + Greek_Deities
        + Legendary_Creatures_from_Japan
        + Planets_and_Moons
        + Roman_Deities
        + Scottish_Islands
        + US_Cities
        + Wild_Cats


        To obtain a generated host name, call `GetHostNameSuggestion`, which
            returns a host name based on the current theme.

        :type default_availability_zone: string
        :param default_availability_zone: The cloned stack's default
            Availability Zone, which must be in the specified region. For more
            information, see `Regions and Endpoints`_. If you also specify a
            value for `DefaultSubnetId`, the subnet must be in the same zone.
            For more information, see the `VpcId` parameter description.

        :type default_subnet_id: string
        :param default_subnet_id: The stack's default subnet ID. All instances
            will be launched into this subnet unless you specify otherwise when
            you create the instance. If you also specify a value for
            `DefaultAvailabilityZone`, the subnet must be in the same zone. For
            information on default values and when this parameter is required,
            see the `VpcId` parameter description.

        :type custom_json: string
        :param custom_json: A string that contains user-defined, custom JSON.
            It is used to override the corresponding default stack
            configuration JSON values. The string should be in the following
            format and must escape characters such as '"'.: `"{\"key1\":
            \"value1\", \"key2\": \"value2\",...}"`
        For more information on custom JSON, see `Use Custom JSON to Modify the
            Stack Configuration JSON`_

        :type configuration_manager: dict
        :param configuration_manager: The configuration manager. When you clone
            a stack we recommend that you use the configuration manager to
            specify the Chef version, 0.9 or 11.4. The default value is
            currently 0.9. However, we expect to change the default value to
            11.4 in September 2013.

        :type use_custom_cookbooks: boolean
        :param use_custom_cookbooks: Whether to use custom cookbooks.

        :type custom_cookbooks_source: dict
        :param custom_cookbooks_source: Contains the information required to
            retrieve an app or cookbook from a repository. For more
            information, see `Creating Apps`_ or `Custom Recipes and
            Cookbooks`_.

        :type default_ssh_key_name: string
        :param default_ssh_key_name: A default SSH key for the stack instances.
            You can override this value when you create or update an instance.

        :type clone_permissions: boolean
        :param clone_permissions: Whether to clone the source stack's
            permissions.

        :type clone_app_ids: list
        :param clone_app_ids: A list of source stack app IDs to be included in
            the cloned stack.

        :type default_root_device_type: string
        :param default_root_device_type: The default root device type. This
            value is used by default for all instances in the cloned stack, but
            you can override it when you create an instance. For more
            information, see `Storage for the Root Device`_.

        """
        params = {
            'SourceStackId': source_stack_id,
            'ServiceRoleArn': service_role_arn,
        }
        if name is not None:
            params['Name'] = name
        if region is not None:
            params['Region'] = region
        if vpc_id is not None:
            params['VpcId'] = vpc_id
        if attributes is not None:
            params['Attributes'] = attributes
        if default_instance_profile_arn is not None:
            params['DefaultInstanceProfileArn'] = default_instance_profile_arn
        if default_os is not None:
            params['DefaultOs'] = default_os
        if hostname_theme is not None:
            params['HostnameTheme'] = hostname_theme
        if default_availability_zone is not None:
            params['DefaultAvailabilityZone'] = default_availability_zone
        if default_subnet_id is not None:
            params['DefaultSubnetId'] = default_subnet_id
        if custom_json is not None:
            params['CustomJson'] = custom_json
        if configuration_manager is not None:
            params['ConfigurationManager'] = configuration_manager
        if use_custom_cookbooks is not None:
            params['UseCustomCookbooks'] = use_custom_cookbooks
        if custom_cookbooks_source is not None:
            params['CustomCookbooksSource'] = custom_cookbooks_source
        if default_ssh_key_name is not None:
            params['DefaultSshKeyName'] = default_ssh_key_name
        if clone_permissions is not None:
            params['ClonePermissions'] = clone_permissions
        if clone_app_ids is not None:
            params['CloneAppIds'] = clone_app_ids
        if default_root_device_type is not None:
            params['DefaultRootDeviceType'] = default_root_device_type
        return self.make_request(action='CloneStack',
                                 body=json.dumps(params))

</source>
<source file="systems/boto-2.13.2/boto/support/layer1.py" startline="294" endline="335" pcid="1767">
    def describe_communications(self, case_id, before_time=None,
                                after_time=None, next_token=None,
                                max_results=None):
        """
        This action returns communications regarding the support case.
        You can use the AfterTime and BeforeTime parameters to filter
        by date. The CaseId parameter enables you to identify a
        specific case by its CaseId number.

        The MaxResults and NextToken parameters enable you to control
        the pagination of the result set. Set MaxResults to the number
        of cases you want displayed on each page, and use NextToken to
        specify the resumption of pagination.

        :type case_id: string
        :param case_id:

        :type before_time: string
        :param before_time:

        :type after_time: string
        :param after_time:

        :type next_token: string
        :param next_token:

        :type max_results: integer
        :param max_results:

        """
        params = {'caseId': case_id, }
        if before_time is not None:
            params['beforeTime'] = before_time
        if after_time is not None:
            params['afterTime'] = after_time
        if next_token is not None:
            params['nextToken'] = next_token
        if max_results is not None:
            params['maxResults'] = max_results
        return self.make_request(action='DescribeCommunications',
                                 body=json.dumps(params))

</source>
<source file="systems/boto-2.13.2/boto/dynamodb2/layer1.py" startline="370" endline="474" pcid="1858">
    def delete_item(self, table_name, key, expected=None, return_values=None,
                    return_consumed_capacity=None,
                    return_item_collection_metrics=None):
        """
        Deletes a single item in a table by primary key. You can
        perform a conditional delete operation that deletes the item
        if it exists, or if it has an expected attribute value.

        In addition to deleting an item, you can also return the
        item's attribute values in the same operation, using the
        ReturnValues parameter.

        Unless you specify conditions, the DeleteItem is an idempotent
        operation; running it multiple times on the same item or
        attribute does not result in an error response.

        Conditional deletes are useful for only deleting items if
        specific conditions are met. If those conditions are met,
        Amazon DynamoDB performs the delete. Otherwise, the item is
        not deleted.

        :type table_name: string
        :param table_name: The name of the table from which to delete the item.

        :type key: map
        :param key: A map of attribute names to AttributeValue objects,
            representing the primary key of the item to delete.

        :type expected: map
        :param expected: A map of attribute/condition pairs. This is the
            conditional block for the DeleteItem operation. All the conditions
            must be met for the operation to succeed.
        Expected allows you to provide an attribute name, and whether or not
            Amazon DynamoDB should check to see if the attribute value already
            exists; or if the attribute value exists and has a particular value
            before changing it.

        Each item in Expected represents an attribute name for Amazon DynamoDB
            to check, along with the following:


        + Value - The attribute value for Amazon DynamoDB to check.
        + Exists - Causes Amazon DynamoDB to evaluate the value before
              attempting a conditional operation:

            + If Exists is `True`, Amazon DynamoDB will check to see if that
                  attribute value already exists in the table. If it is found, then
                  the operation succeeds. If it is not found, the operation fails
                  with a ConditionalCheckFailedException .
            + If Exists is `False`, Amazon DynamoDB assumes that the attribute
                  value does not exist in the table. If in fact the value does not
                  exist, then the assumption is valid and the operation succeeds. If
                  the value is found, despite the assumption that it does not exist,
                  the operation fails with a ConditionalCheckFailedException .
          The default setting for Exists is `True`. If you supply a Value all by
              itself, Amazon DynamoDB assumes the attribute exists: You don't
              have to set Exists to `True`, because it is implied. Amazon
              DynamoDB returns a ValidationException if:

            + Exists is `True` but there is no Value to check. (You expect a value
                  to exist, but don't specify what that value is.)
            + Exists is `False` but you also specify a Value . (You cannot expect
                  an attribute to have a value, while also expecting it not to
                  exist.)



        If you specify more than one condition for Exists , then all of the
            conditions must evaluate to true. (In other words, the conditions
            are ANDed together.) Otherwise, the conditional operation will
            fail.

        :type return_values: string
        :param return_values:
        Use ReturnValues if you want to get the item attributes as they
            appeared before they were deleted. For DeleteItem , the valid
            values are:


        + `NONE` - If ReturnValues is not specified, or if its value is `NONE`,
              then nothing is returned. (This is the default for ReturnValues .)
        + `ALL_OLD` - The content of the old item is returned.

        :type return_consumed_capacity: string
        :param return_consumed_capacity:

        :type return_item_collection_metrics: string
        :param return_item_collection_metrics: If set to `SIZE`, statistics
            about item collections, if any, that were modified during the
            operation are returned in the response. If set to `NONE` (the
            default), no statistics are returned..

        """
        params = {'TableName': table_name, 'Key': key, }
        if expected is not None:
            params['Expected'] = expected
        if return_values is not None:
            params['ReturnValues'] = return_values
        if return_consumed_capacity is not None:
            params['ReturnConsumedCapacity'] = return_consumed_capacity
        if return_item_collection_metrics is not None:
            params['ReturnItemCollectionMetrics'] = return_item_collection_metrics
        return self.make_request(action='DeleteItem',
                                 body=json.dumps(params))

</source>
<source file="systems/boto-2.13.2/boto/dynamodb2/layer1.py" startline="603" endline="729" pcid="1863">
    def put_item(self, table_name, item, expected=None, return_values=None,
                 return_consumed_capacity=None,
                 return_item_collection_metrics=None):
        """
        Creates a new item, or replaces an old item with a new item.
        If an item already exists in the specified table with the same
        primary key, the new item completely replaces the existing
        item. You can perform a conditional put (insert a new item if
        one with the specified primary key doesn't exist), or replace
        an existing item if it has certain attribute values.

        In addition to putting an item, you can also return the item's
        attribute values in the same operation, using the ReturnValues
        parameter.

        When you add an item, the primary key attribute(s) are the
        only required attributes. Attribute values cannot be null.
        String and binary type attributes must have lengths greater
        than zero. Set type attributes cannot be empty. Requests with
        empty values will be rejected with a ValidationException .

        You can request that PutItem return either a copy of the old
        item (before the update) or a copy of the new item (after the
        update). For more information, see the ReturnValues
        description.

        To prevent a new item from replacing an existing item, use a
        conditional put operation with Exists set to `False` for the
        primary key attribute, or attributes.

        For more information about using this API, see `Working with
        Items`_ in the Amazon DynamoDB Developer Guide .

        :type table_name: string
        :param table_name: The name of the table to contain the item.

        :type item: map
        :param item: A map of attribute name/value pairs, one for each
            attribute. Only the primary key attributes are required; you can
            optionally provide other attribute name-value pairs for the item.
        If you specify any attributes that are part of an index key, then the
            data types for those attributes must match those of the schema in
            the table's attribute definition.

        For more information about primary keys, see `Primary Key`_ in the
            Amazon DynamoDB Developer Guide .

        Each element in the Item map is an AttributeValue object.

        :type expected: map
        :param expected: A map of attribute/condition pairs. This is the
            conditional block for the PutItem operation. All the conditions
            must be met for the operation to succeed.
        Expected allows you to provide an attribute name, and whether or not
            Amazon DynamoDB should check to see if the attribute value already
            exists; or if the attribute value exists and has a particular value
            before changing it.

        Each item in Expected represents an attribute name for Amazon DynamoDB
            to check, along with the following:


        + Value - The attribute value for Amazon DynamoDB to check.
        + Exists - Causes Amazon DynamoDB to evaluate the value before
              attempting a conditional operation:

            + If Exists is `True`, Amazon DynamoDB will check to see if that
                  attribute value already exists in the table. If it is found, then
                  the operation succeeds. If it is not found, the operation fails
                  with a ConditionalCheckFailedException .
            + If Exists is `False`, Amazon DynamoDB assumes that the attribute
                  value does not exist in the table. If in fact the value does not
                  exist, then the assumption is valid and the operation succeeds. If
                  the value is found, despite the assumption that it does not exist,
                  the operation fails with a ConditionalCheckFailedException .
          The default setting for Exists is `True`. If you supply a Value all by
              itself, Amazon DynamoDB assumes the attribute exists: You don't
              have to set Exists to `True`, because it is implied. Amazon
              DynamoDB returns a ValidationException if:

            + Exists is `True` but there is no Value to check. (You expect a value
                  to exist, but don't specify what that value is.)
            + Exists is `False` but you also specify a Value . (You cannot expect
                  an attribute to have a value, while also expecting it not to
                  exist.)



        If you specify more than one condition for Exists , then all of the
            conditions must evaluate to true. (In other words, the conditions
            are ANDed together.) Otherwise, the conditional operation will
            fail.

        :type return_values: string
        :param return_values:
        Use ReturnValues if you want to get the item attributes as they
            appeared before they were updated with the PutItem request. For
            PutItem , the valid values are:


        + `NONE` - If ReturnValues is not specified, or if its value is `NONE`,
              then nothing is returned. (This is the default for ReturnValues .)
        + `ALL_OLD` - If PutItem overwrote an attribute name-value pair, then
              the content of the old item is returned.

        :type return_consumed_capacity: string
        :param return_consumed_capacity:

        :type return_item_collection_metrics: string
        :param return_item_collection_metrics: If set to `SIZE`, statistics
            about item collections, if any, that were modified during the
            operation are returned in the response. If set to `NONE` (the
            default), no statistics are returned..

        """
        params = {'TableName': table_name, 'Item': item, }
        if expected is not None:
            params['Expected'] = expected
        if return_values is not None:
            params['ReturnValues'] = return_values
        if return_consumed_capacity is not None:
            params['ReturnConsumedCapacity'] = return_consumed_capacity
        if return_item_collection_metrics is not None:
            params['ReturnItemCollectionMetrics'] = return_item_collection_metrics
        return self.make_request(action='PutItem',
                                 body=json.dumps(params))

</source>
<source file="systems/boto-2.13.2/boto/dynamodb2/layer1.py" startline="1240" endline="1428" pcid="1866">
    def update_item(self, table_name, key, attribute_updates=None,
                    expected=None, return_values=None,
                    return_consumed_capacity=None,
                    return_item_collection_metrics=None):
        """
        Edits an existing item's attributes, or inserts a new item if
        it does not already exist. You can put, delete, or add
        attribute values. You can also perform a conditional update
        (insert a new attribute name-value pair if it doesn't exist,
        or replace an existing name-value pair if it has certain
        expected attribute values).

        In addition to updating an item, you can also return the
        item's attribute values in the same operation, using the
        ReturnValues parameter.

        :type table_name: string
        :param table_name: The name of the table containing the item to update.

        :type key: map
        :param key: The primary key that defines the item. Each element
            consists of an attribute name and a value for that attribute.

        :type attribute_updates: map
        :param attribute_updates: The names of attributes to be modified, the
            action to perform on each, and the new value for each. If you are
            updating an attribute that is an index key attribute for any
            indexes on that table, the attribute type must match the index key
            type defined in the AttributesDefinition of the table description.
            You can use UpdateItem to update any non-key attributes.
        Attribute values cannot be null. String and binary type attributes must
            have lengths greater than zero. Set type attributes must not be
            empty. Requests with empty values will be rejected with a
            ValidationException .

        Each AttributeUpdates element consists of an attribute name to modify,
            along with the following:


        + Value - The new value, if applicable, for this attribute.
        + Action - Specifies how to perform the update. Valid values for Action
              are `PUT`, `DELETE`, and `ADD`. The behavior depends on whether the
              specified primary key already exists in the table. **If an item
              with the specified Key is found in the table:**

            + `PUT` - Adds the specified attribute to the item. If the attribute
                  already exists, it is replaced by the new value.
            + `DELETE` - If no value is specified, the attribute and its value are
                  removed from the item. The data type of the specified value must
                  match the existing value's data type. If a set of values is
                  specified, then those values are subtracted from the old set. For
                  example, if the attribute value was the set `[a,b,c]` and the
                  DELETE action specified `[a,c]`, then the final attribute value
                  would be `[b]`. Specifying an empty set is an error.
            + `ADD` - If the attribute does not already exist, then the attribute
                  and its values are added to the item. If the attribute does exist,
                  then the behavior of `ADD` depends on the data type of the
                  attribute:

                + If the existing attribute is a number, and if Value is also a number,
                      then the Value is mathematically added to the existing attribute.
                      If Value is a negative number, then it is subtracted from the
                      existing attribute. If you use `ADD` to increment or decrement a
                      number value for an item that doesn't exist before the update,
                      Amazon DynamoDB uses 0 as the initial value. In addition, if you
                      use `ADD` to update an existing item, and intend to increment or
                      decrement an attribute value which does not yet exist, Amazon
                      DynamoDB uses `0` as the initial value. For example, suppose that
                      the item you want to update does not yet have an attribute named
                      itemcount , but you decide to `ADD` the number `3` to this
                      attribute anyway, even though it currently does not exist. Amazon
                      DynamoDB will create the itemcount attribute, set its initial value
                      to `0`, and finally add `3` to it. The result will be a new
                      itemcount attribute in the item, with a value of `3`.
                + If the existing data type is a set, and if the Value is also a set,
                      then the Value is added to the existing set. (This is a set
                      operation, not mathematical addition.) For example, if the
                      attribute value was the set `[1,2]`, and the `ADD` action specified
                      `[3]`, then the final attribute value would be `[1,2,3]`. An error
                      occurs if an Add action is specified for a set attribute and the
                      attribute type specified does not match the existing set type. Both
                      sets must have the same primitive data type. For example, if the
                      existing data type is a set of strings, the Value must also be a
                      set of strings. The same holds true for number sets and binary
                      sets.
              This action is only valid for an existing attribute whose data type is
                  number or is a set. Do not use `ADD` for any other data types.
          **If no item with the specified Key is found:**

            + `PUT` - Amazon DynamoDB creates a new item with the specified primary
                  key, and then adds the attribute.
            + `DELETE` - Nothing happens; there is no attribute to delete.
            + `ADD` - Amazon DynamoDB creates an item with the supplied primary key
                  and number (or set of numbers) for the attribute value. The only
                  data types allowed are number and number set; no other data types
                  can be specified.



        If you specify any attributes that are part of an index key, then the
            data types for those attributes must match those of the schema in
            the table's attribute definition.

        :type expected: map
        :param expected: A map of attribute/condition pairs. This is the
            conditional block for the UpdateItem operation. All the conditions
            must be met for the operation to succeed.
        Expected allows you to provide an attribute name, and whether or not
            Amazon DynamoDB should check to see if the attribute value already
            exists; or if the attribute value exists and has a particular value
            before changing it.

        Each item in Expected represents an attribute name for Amazon DynamoDB
            to check, along with the following:


        + Value - The attribute value for Amazon DynamoDB to check.
        + Exists - Causes Amazon DynamoDB to evaluate the value before
              attempting a conditional operation:

            + If Exists is `True`, Amazon DynamoDB will check to see if that
                  attribute value already exists in the table. If it is found, then
                  the operation succeeds. If it is not found, the operation fails
                  with a ConditionalCheckFailedException .
            + If Exists is `False`, Amazon DynamoDB assumes that the attribute
                  value does not exist in the table. If in fact the value does not
                  exist, then the assumption is valid and the operation succeeds. If
                  the value is found, despite the assumption that it does not exist,
                  the operation fails with a ConditionalCheckFailedException .
          The default setting for Exists is `True`. If you supply a Value all by
              itself, Amazon DynamoDB assumes the attribute exists: You don't
              have to set Exists to `True`, because it is implied. Amazon
              DynamoDB returns a ValidationException if:

            + Exists is `True` but there is no Value to check. (You expect a value
                  to exist, but don't specify what that value is.)
            + Exists is `False` but you also specify a Value . (You cannot expect
                  an attribute to have a value, while also expecting it not to
                  exist.)



        If you specify more than one condition for Exists , then all of the
            conditions must evaluate to true. (In other words, the conditions
            are ANDed together.) Otherwise, the conditional operation will
            fail.

        :type return_values: string
        :param return_values:
        Use ReturnValues if you want to get the item attributes as they
            appeared either before or after they were updated. For UpdateItem ,
            the valid values are:


        + `NONE` - If ReturnValues is not specified, or if its value is `NONE`,
              then nothing is returned. (This is the default for ReturnValues .)
        + `ALL_OLD` - If UpdateItem overwrote an attribute name-value pair,
              then the content of the old item is returned.
        + `UPDATED_OLD` - The old versions of only the updated attributes are
              returned.
        + `ALL_NEW` - All of the attributes of the new version of the item are
              returned.
        + `UPDATED_NEW` - The new versions of only the updated attributes are
              returned.

        :type return_consumed_capacity: string
        :param return_consumed_capacity:

        :type return_item_collection_metrics: string
        :param return_item_collection_metrics: If set to `SIZE`, statistics
            about item collections, if any, that were modified during the
            operation are returned in the response. If set to `NONE` (the
            default), no statistics are returned..

        """
        params = {'TableName': table_name, 'Key': key, }
        if attribute_updates is not None:
            params['AttributeUpdates'] = attribute_updates
        if expected is not None:
            params['Expected'] = expected
        if return_values is not None:
            params['ReturnValues'] = return_values
        if return_consumed_capacity is not None:
            params['ReturnConsumedCapacity'] = return_consumed_capacity
        if return_item_collection_metrics is not None:
            params['ReturnItemCollectionMetrics'] = return_item_collection_metrics
        return self.make_request(action='UpdateItem',
                                 body=json.dumps(params))

</source>
<source file="systems/boto-2.13.2/boto/opsworks/layer1.py" startline="377" endline="431" pcid="3033">
    def create_deployment(self, stack_id, command, app_id=None,
                          instance_ids=None, comment=None, custom_json=None):
        """
        Deploys a stack or app.


        + App deployment generates a `deploy` event, which runs the
          associated recipes and passes them a JSON stack configuration
          object that includes information about the app.
        + Stack deployment runs the `deploy` recipes but does not
          raise an event.


        For more information, see `Deploying Apps`_ and `Run Stack
        Commands`_.

        :type stack_id: string
        :param stack_id: The stack ID.

        :type app_id: string
        :param app_id: The app ID. This parameter is required for app
            deployments, but not for other deployment commands.

        :type instance_ids: list
        :param instance_ids: The instance IDs for the deployment targets.

        :type command: dict
        :param command: A `DeploymentCommand` object that specifies the
            deployment command and any associated arguments.

        :type comment: string
        :param comment: A user-defined comment.

        :type custom_json: string
        :param custom_json: A string that contains user-defined, custom JSON.
            It is used to override the corresponding default stack
            configuration JSON values. The string should be in the following
            format and must escape characters such as '"'.: `"{\"key1\":
            \"value1\", \"key2\": \"value2\",...}"`
        For more information on custom JSON, see `Use Custom JSON to Modify the
            Stack Configuration JSON`_.

        """
        params = {'StackId': stack_id, 'Command': command, }
        if app_id is not None:
            params['AppId'] = app_id
        if instance_ids is not None:
            params['InstanceIds'] = instance_ids
        if comment is not None:
            params['Comment'] = comment
        if custom_json is not None:
            params['CustomJson'] = custom_json
        return self.make_request(action='CreateDeployment',
                                 body=json.dumps(params))

</source>
<source file="systems/boto-2.13.2/boto/opsworks/layer1.py" startline="1369" endline="1410" pcid="3061">
    def set_load_based_auto_scaling(self, layer_id, enable=None,
                                    up_scaling=None, down_scaling=None):
        """
        Specify the load-based auto scaling configuration for a
        specified layer. For more information, see `Managing Load with
        Time-based and Load-based Instances`_.

        To use load-based auto scaling, you must create a set of load-
        based auto scaling instances. Load-based auto scaling operates
        only on the instances from that set, so you must ensure that
        you have created enough instances to handle the maximum
        anticipated load.

        :type layer_id: string
        :param layer_id: The layer ID.

        :type enable: boolean
        :param enable: Enables load-based auto scaling for the layer.

        :type up_scaling: dict
        :param up_scaling: An `AutoScalingThresholds` object with the upscaling
            threshold configuration. If the load exceeds these thresholds for a
            specified amount of time, AWS OpsWorks starts a specified number of
            instances.

        :type down_scaling: dict
        :param down_scaling: An `AutoScalingThresholds` object with the
            downscaling threshold configuration. If the load falls below these
            thresholds for a specified amount of time, AWS OpsWorks stops a
            specified number of instances.

        """
        params = {'LayerId': layer_id, }
        if enable is not None:
            params['Enable'] = enable
        if up_scaling is not None:
            params['UpScaling'] = up_scaling
        if down_scaling is not None:
            params['DownScaling'] = down_scaling
        return self.make_request(action='SetLoadBasedAutoScaling',
                                 body=json.dumps(params))

</source>
<source file="systems/boto-2.13.2/boto/sns/connection.py" startline="596" endline="644" pcid="1111">
    def create_platform_endpoint(self, platform_application_arn=None,
                                 token=None, custom_user_data=None,
                                 attributes=None):
        """
        The `CreatePlatformEndpoint` creates an endpoint for a device
        and mobile app on one of the supported push notification
        services, such as GCM and APNS. `CreatePlatformEndpoint`
        requires the PlatformApplicationArn that is returned from
        `CreatePlatformApplication`. The EndpointArn that is returned
        when using `CreatePlatformEndpoint` can then be used by the
        `Publish` action to send a message to a mobile app or by the
        `Subscribe` action for subscription to a topic. For more
        information, see `Using Amazon SNS Mobile Push
        Notifications`_.

        :type platform_application_arn: string
        :param platform_application_arn: PlatformApplicationArn returned from
            CreatePlatformApplication is used to create a an endpoint.

        :type token: string
        :param token: Unique identifier created by the notification service for
            an app on a device. The specific name for Token will vary,
            depending on which notification service is being used. For example,
            when using APNS as the notification service, you need the device
            token. Alternatively, when using GCM or ADM, the device token
            equivalent is called the registration ID.

        :type custom_user_data: string
        :param custom_user_data: Arbitrary user data to associate with the
            endpoint. SNS does not use this data. The data must be in UTF-8
            format and less than 2KB.

        :type attributes: map
        :param attributes: For a list of attributes, see
            `SetEndpointAttributes`_.

        """
        params = {}
        if platform_application_arn is not None:
            params['PlatformApplicationArn'] = platform_application_arn
        if token is not None:
            params['Token'] = token
        if custom_user_data is not None:
            params['CustomUserData'] = custom_user_data
        if attributes is not None:
            self._build_dict_as_list_params(params, attributes, 'Attributes')
        return self._make_request(action='CreatePlatformEndpoint',
                                  params=params)

</source>
<source file="systems/boto-2.13.2/boto/datapipeline/layer1.py" startline="398" endline="448" pcid="2981">
    def query_objects(self, pipeline_id, sphere, marker=None, query=None,
                      limit=None):
        """
        Queries a pipeline for the names of objects that match a
        specified set of conditions.

        The objects returned by QueryObjects are paginated and then
        filtered by the value you set for query. This means the action
        may return an empty result set with a value set for marker. If
        `HasMoreResults` is set to `True`, you should continue to call
        QueryObjects, passing in the returned value for marker, until
        `HasMoreResults` returns `False`.

        :type pipeline_id: string
        :param pipeline_id: Identifier of the pipeline to be queried for object
            names.

        :type query: dict
        :param query: Query that defines the objects to be returned. The Query
            object can contain a maximum of ten selectors. The conditions in
            the query are limited to top-level String fields in the object.
            These filters can be applied to components, instances, and
            attempts.

        :type sphere: string
        :param sphere: Specifies whether the query applies to components or
            instances. Allowable values: `COMPONENT`, `INSTANCE`, `ATTEMPT`.

        :type marker: string
        :param marker: The starting point for the results to be returned. The
            first time you call QueryObjects, this value should be empty. As
            long as the action returns `HasMoreResults` as `True`, you can call
            QueryObjects again and pass the marker value from the response to
            retrieve the next set of results.

        :type limit: integer
        :param limit: Specifies the maximum number of object names that
            QueryObjects will return in a single call. The default value is
            100.

        """
        params = {'pipelineId': pipeline_id, 'sphere': sphere, }
        if query is not None:
            params['query'] = query
        if marker is not None:
            params['marker'] = marker
        if limit is not None:
            params['limit'] = limit
        return self.make_request(action='QueryObjects',
                                 body=json.dumps(params))

</source>
<source file="systems/boto-2.13.2/boto/datapipeline/layer1.py" startline="546" endline="596" pcid="2985">
    def set_task_status(self, task_id, task_status, error_id=None,
                        error_message=None, error_stack_trace=None):
        """
        Notifies AWS Data Pipeline that a task is completed and
        provides information about the final status. The task runner
        calls this action regardless of whether the task was
        sucessful. The task runner does not need to call SetTaskStatus
        for tasks that are canceled by the web service during a call
        to ReportTaskProgress.

        :type task_id: string
        :param task_id: Identifies the task assigned to the task runner. This
            value is set in the TaskObject that is returned by the PollForTask
            action.

        :type task_status: string
        :param task_status: If `FINISHED`, the task successfully completed. If
            `FAILED` the task ended unsuccessfully. The `FALSE` value is used
            by preconditions.

        :type error_id: string
        :param error_id: If an error occurred during the task, this value
            specifies an id value that represents the error. This value is set
            on the physical attempt object. It is used to display error
            information to the user. It should not start with string "Service_"
            which is reserved by the system.

        :type error_message: string
        :param error_message: If an error occurred during the task, this value
            specifies a text description of the error. This value is set on the
            physical attempt object. It is used to display error information to
            the user. The web service does not parse this value.

        :type error_stack_trace: string
        :param error_stack_trace: If an error occurred during the task, this
            value specifies the stack trace associated with the error. This
            value is set on the physical attempt object. It is used to display
            error information to the user. The web service does not parse this
            value.

        """
        params = {'taskId': task_id, 'taskStatus': task_status, }
        if error_id is not None:
            params['errorId'] = error_id
        if error_message is not None:
            params['errorMessage'] = error_message
        if error_stack_trace is not None:
            params['errorStackTrace'] = error_stack_trace
        return self.make_request(action='SetTaskStatus',
                                 body=json.dumps(params))

</source>
<source file="systems/boto-2.13.2/boto/dynamodb2/layer1.py" startline="527" endline="571" pcid="1861">
    def get_item(self, table_name, key, attributes_to_get=None,
                 consistent_read=None, return_consumed_capacity=None):
        """
        The GetItem operation returns a set of attributes for the item
        with the given primary key. If there is no matching item,
        GetItem does not return any data.

        GetItem provides an eventually consistent read by default. If
        your application requires a strongly consistent read, set
        ConsistentRead to `True`. Although a strongly consistent read
        might take more time than an eventually consistent read, it
        always returns the last updated value.

        :type table_name: string
        :param table_name: The name of the table containing the requested item.

        :type key: map
        :param key: A map of attribute names to AttributeValue objects,
            representing the primary key of the item to retrieve.

        :type attributes_to_get: list
        :param attributes_to_get: The names of one or more attributes to
            retrieve. If no attribute names are specified, then all attributes
            will be returned. If any of the requested attributes are not found,
            they will not appear in the result.

        :type consistent_read: boolean
        :param consistent_read: If set to `True`, then the operation uses
            strongly consistent reads; otherwise, eventually consistent reads
            are used.

        :type return_consumed_capacity: string
        :param return_consumed_capacity:

        """
        params = {'TableName': table_name, 'Key': key, }
        if attributes_to_get is not None:
            params['AttributesToGet'] = attributes_to_get
        if consistent_read is not None:
            params['ConsistentRead'] = consistent_read
        if return_consumed_capacity is not None:
            params['ReturnConsumedCapacity'] = return_consumed_capacity
        return self.make_request(action='GetItem',
                                 body=json.dumps(params))

</source>
<source file="systems/boto-2.13.2/boto/opsworks/layer1.py" startline="1212" endline="1243" pcid="3053">
    def describe_service_errors(self, stack_id=None, instance_id=None,
                                service_error_ids=None):
        """
        Describes AWS OpsWorks service errors.

        :type stack_id: string
        :param stack_id: The stack ID. If you use this parameter,
            `DescribeServiceErrors` returns descriptions of the errors
            associated with the specified stack.

        :type instance_id: string
        :param instance_id: The instance ID. If you use this parameter,
            `DescribeServiceErrors` returns descriptions of the errors
            associated with the specified instance.

        :type service_error_ids: list
        :param service_error_ids: An array of service error IDs. If you use
            this parameter, `DescribeServiceErrors` returns descriptions of the
            specified errors. Otherwise, it returns a description of every
            error.

        """
        params = {}
        if stack_id is not None:
            params['StackId'] = stack_id
        if instance_id is not None:
            params['InstanceId'] = instance_id
        if service_error_ids is not None:
            params['ServiceErrorIds'] = service_error_ids
        return self.make_request(action='DescribeServiceErrors',
                                 body=json.dumps(params))

</source>
<source file="systems/boto-2.13.2/boto/opsworks/layer1.py" startline="982" endline="1015" pcid="3044">
    def describe_commands(self, deployment_id=None, instance_id=None,
                          command_ids=None):
        """
        Describes the results of specified commands.

        You must specify at least one of the parameters.

        :type deployment_id: string
        :param deployment_id: The deployment ID. If you include this parameter,
            `DescribeCommands` returns a description of the commands associated
            with the specified deployment.

        :type instance_id: string
        :param instance_id: The instance ID. If you include this parameter,
            `DescribeCommands` returns a description of the commands associated
            with the specified instance.

        :type command_ids: list
        :param command_ids: An array of command IDs. If you include this
            parameter, `DescribeCommands` returns a description of the
            specified commands. Otherwise, it returns a description of every
            command.

        """
        params = {}
        if deployment_id is not None:
            params['DeploymentId'] = deployment_id
        if instance_id is not None:
            params['InstanceId'] = instance_id
        if command_ids is not None:
            params['CommandIds'] = command_ids
        return self.make_request(action='DescribeCommands',
                                 body=json.dumps(params))

</source>
<source file="systems/boto-2.13.2/boto/opsworks/layer1.py" startline="1099" endline="1132" pcid="3048">
    def describe_instances(self, stack_id=None, layer_id=None,
                           instance_ids=None):
        """
        Requests a description of a set of instances.

        You must specify at least one of the parameters.

        :type stack_id: string
        :param stack_id: A stack ID. If you use this parameter,
            `DescribeInstances` returns descriptions of the instances
            associated with the specified stack.

        :type layer_id: string
        :param layer_id: A layer ID. If you use this parameter,
            `DescribeInstances` returns descriptions of the instances
            associated with the specified layer.

        :type instance_ids: list
        :param instance_ids: An array of instance IDs to be described. If you
            use this parameter, `DescribeInstances` returns a description of
            the specified instances. Otherwise, it returns a description of
            every instance.

        """
        params = {}
        if stack_id is not None:
            params['StackId'] = stack_id
        if layer_id is not None:
            params['LayerId'] = layer_id
        if instance_ids is not None:
            params['InstanceIds'] = instance_ids
        return self.make_request(action='DescribeInstances',
                                 body=json.dumps(params))

</source>
<source file="systems/boto-2.13.2/boto/opsworks/layer1.py" startline="1288" endline="1320" pcid="3057">
    def describe_volumes(self, instance_id=None, raid_array_id=None,
                         volume_ids=None):
        """
        Describes an instance's Amazon EBS volumes.

        You must specify at least one of the parameters.

        :type instance_id: string
        :param instance_id: The instance ID. If you use this parameter,
            `DescribeVolumes` returns descriptions of the volumes associated
            with the specified instance.

        :type raid_array_id: string
        :param raid_array_id: The RAID array ID. If you use this parameter,
            `DescribeVolumes` returns descriptions of the volumes associated
            with the specified RAID array.

        :type volume_ids: list
        :param volume_ids: Am array of volume IDs. If you use this parameter,
            `DescribeVolumes` returns descriptions of the specified volumes.
            Otherwise, it returns a description of every volume.

        """
        params = {}
        if instance_id is not None:
            params['InstanceId'] = instance_id
        if raid_array_id is not None:
            params['RaidArrayId'] = raid_array_id
        if volume_ids is not None:
            params['VolumeIds'] = volume_ids
        return self.make_request(action='DescribeVolumes',
                                 body=json.dumps(params))

</source>
<source file="systems/boto-2.13.2/boto/opsworks/layer1.py" startline="1016" endline="1049" pcid="3045">
    def describe_deployments(self, stack_id=None, app_id=None,
                             deployment_ids=None):
        """
        Requests a description of a specified set of deployments.

        You must specify at least one of the parameters.

        :type stack_id: string
        :param stack_id: The stack ID. If you include this parameter,
            `DescribeDeployments` returns a description of the commands
            associated with the specified stack.

        :type app_id: string
        :param app_id: The app ID. If you include this parameter,
            `DescribeDeployments` returns a description of the commands
            associated with the specified app.

        :type deployment_ids: list
        :param deployment_ids: An array of deployment IDs to be described. If
            you include this parameter, `DescribeDeployments` returns a
            description of the specified deployments. Otherwise, it returns a
            description of every deployment.

        """
        params = {}
        if stack_id is not None:
            params['StackId'] = stack_id
        if app_id is not None:
            params['AppId'] = app_id
        if deployment_ids is not None:
            params['DeploymentIds'] = deployment_ids
        return self.make_request(action='DescribeDeployments',
                                 body=json.dumps(params))

</source>
<source file="systems/boto-2.13.2/boto/sns/connection.py" startline="403" endline="449" pcid="1105">
    def create_platform_application(self, name=None, platform=None,
                                    attributes=None):
        """
        The `CreatePlatformApplication` action creates a platform
        application object for one of the supported push notification
        services, such as APNS and GCM, to which devices and mobile
        apps may register. You must specify PlatformPrincipal and
        PlatformCredential attributes when using the
        `CreatePlatformApplication` action. The PlatformPrincipal is
        received from the notification service. For APNS/APNS_SANDBOX,
        PlatformPrincipal is "SSL certificate". For GCM,
        PlatformPrincipal is not applicable. For ADM,
        PlatformPrincipal is "client id". The PlatformCredential is
        also received from the notification service. For
        APNS/APNS_SANDBOX, PlatformCredential is "private key". For
        GCM, PlatformCredential is "API key". For ADM,
        PlatformCredential is "client secret". The
        PlatformApplicationArn that is returned when using
        `CreatePlatformApplication` is then used as an attribute for
        the `CreatePlatformEndpoint` action. For more information, see
        `Using Amazon SNS Mobile Push Notifications`_.

        :type name: string
        :param name: Application names must be made up of only uppercase and
            lowercase ASCII letters, numbers, underscores, hyphens, and
            periods, and must be between 1 and 256 characters long.

        :type platform: string
        :param platform: The following platforms are supported: ADM (Amazon
            Device Messaging), APNS (Apple Push Notification Service),
            APNS_SANDBOX, and GCM (Google Cloud Messaging).

        :type attributes: map
        :param attributes: For a list of attributes, see
            `SetPlatformApplicationAttributes`_

        """
        params = {}
        if name is not None:
            params['Name'] = name
        if platform is not None:
            params['Platform'] = platform
        if attributes is not None:
            self._build_dict_as_list_params(params, attributes, 'Attributes')
        return self._make_request(action='CreatePlatformApplication',
                                  params=params)

</source>
<source file="systems/boto-2.13.2/boto/iam/connection.py" startline="1160" endline="1192" pcid="1646">
    def list_instance_profiles(self, path_prefix=None, marker=None,
                               max_items=None):
        """
        Lists the instance profiles that have the specified path prefix. If
        there are none, the action returns an empty list.

        :type path_prefix: string
        :param path_prefix: The path prefix for filtering the results. For
            example: /application_abc/component_xyz/, which would get all
            instance profiles whose path starts with
            /application_abc/component_xyz/.

        :type marker: string
        :param marker: Use this parameter only when paginating results, and
            only in a subsequent request after you've received a response
            where the results are truncated. Set it to the value of the
            Marker element in the response you just received.

        :type max_items: int
        :param max_items: Use this parameter only when paginating results to
            indicate the maximum number of user names you want in the response.
        """
        params = {}
        if path_prefix is not None:
            params['PathPrefix'] = path_prefix
        if marker is not None:
            params['Marker'] = marker
        if max_items is not None:
            params['MaxItems'] = max_items

        return self.get_response('ListInstanceProfiles', params,
                                 list_marker='InstanceProfiles')

</source>
<source file="systems/boto-2.13.2/boto/elastictranscoder/layer1.py" startline="455" endline="490" pcid="3084">
    def list_jobs_by_pipeline(self, pipeline_id=None, ascending=None,
                              page_token=None):
        """
        The ListJobsByPipeline operation gets a list of the jobs
        currently in a pipeline.

        Elastic Transcoder returns all of the jobs currently in the
        specified pipeline. The response body contains one element for
        each job that satisfies the search criteria.

        :type pipeline_id: string
        :param pipeline_id: The ID of the pipeline for which you want to get
            job information.

        :type ascending: string
        :param ascending: To list jobs in chronological order by the date and
            time that they were submitted, enter `True`. To list jobs in
            reverse chronological order, enter `False`.

        :type page_token: string
        :param page_token: When Elastic Transcoder returns more than one page
            of results, use `pageToken` in subsequent `GET` requests to get
            each successive page of results.

        """
        uri = '/2012-09-25/jobsByPipeline/{0}'.format(pipeline_id)
        params = {}
        if pipeline_id is not None:
            params['PipelineId'] = pipeline_id
        if ascending is not None:
            params['Ascending'] = ascending
        if page_token is not None:
            params['PageToken'] = page_token
        return self.make_request('GET', uri, expected_status=200,
                                 params=params)

</source>
<source file="systems/boto-2.13.2/boto/elastictranscoder/layer1.py" startline="491" endline="525" pcid="3085">
    def list_jobs_by_status(self, status=None, ascending=None,
                            page_token=None):
        """
        The ListJobsByStatus operation gets a list of jobs that have a
        specified status. The response body contains one element for
        each job that satisfies the search criteria.

        :type status: string
        :param status: To get information about all of the jobs associated with
            the current AWS account that have a given status, specify the
            following status: `Submitted`, `Progressing`, `Complete`,
            `Canceled`, or `Error`.

        :type ascending: string
        :param ascending: To list jobs in chronological order by the date and
            time that they were submitted, enter `True`. To list jobs in
            reverse chronological order, enter `False`.

        :type page_token: string
        :param page_token: When Elastic Transcoder returns more than one page
            of results, use `pageToken` in subsequent `GET` requests to get
            each successive page of results.

        """
        uri = '/2012-09-25/jobsByStatus/{0}'.format(status)
        params = {}
        if status is not None:
            params['Status'] = status
        if ascending is not None:
            params['Ascending'] = ascending
        if page_token is not None:
            params['PageToken'] = page_token
        return self.make_request('GET', uri, expected_status=200,
                                 params=params)

</source>
<source file="systems/boto-2.13.2/boto/sns/connection.py" startline="543" endline="577" pcid="1109">
    def list_endpoints_by_platform_application(self,
                                               platform_application_arn=None,
                                               next_token=None):
        """
        The `ListEndpointsByPlatformApplication` action lists the
        endpoints and endpoint attributes for devices in a supported
        push notification service, such as GCM and APNS. The results
        for `ListEndpointsByPlatformApplication` are paginated and
        return a limited list of endpoints, up to 100. If additional
        records are available after the first page results, then a
        NextToken string will be returned. To receive the next page,
        you call `ListEndpointsByPlatformApplication` again using the
        NextToken string received from the previous call. When there
        are no more records to return, NextToken will be null. For
        more information, see `Using Amazon SNS Mobile Push
        Notifications`_.

        :type platform_application_arn: string
        :param platform_application_arn: PlatformApplicationArn for
            ListEndpointsByPlatformApplicationInput action.

        :type next_token: string
        :param next_token: NextToken string is used when calling
            ListEndpointsByPlatformApplication action to retrieve additional
            records that are available after the first page results.

        """
        params = {}
        if platform_application_arn is not None:
            params['PlatformApplicationArn'] = platform_application_arn
        if next_token is not None:
            params['NextToken'] = next_token
        return self._make_request(action='ListEndpointsByPlatformApplication',
                                  params=params)

</source>
<source file="systems/boto-2.13.2/boto/sns/connection.py" startline="450" endline="496" pcid="1106">
    def set_platform_application_attributes(self,
                                            platform_application_arn=None,
                                            attributes=None):
        """
        The `SetPlatformApplicationAttributes` action sets the
        attributes of the platform application object for the
        supported push notification services, such as APNS and GCM.
        For more information, see `Using Amazon SNS Mobile Push
        Notifications`_.

        :type platform_application_arn: string
        :param platform_application_arn: PlatformApplicationArn for
            SetPlatformApplicationAttributes action.

        :type attributes: map
        :param attributes:
        A map of the platform application attributes. Attributes in this map
            include the following:


        + `PlatformCredential` -- The credential received from the notification
              service. For APNS/APNS_SANDBOX, PlatformCredential is "private
              key". For GCM, PlatformCredential is "API key". For ADM,
              PlatformCredential is "client secret".
        + `PlatformPrincipal` -- The principal received from the notification
              service. For APNS/APNS_SANDBOX, PlatformPrincipal is "SSL
              certificate". For GCM, PlatformPrincipal is not applicable. For
              ADM, PlatformPrincipal is "client id".
        + `EventEndpointCreated` -- Topic ARN to which EndpointCreated event
              notifications should be sent.
        + `EventEndpointDeleted` -- Topic ARN to which EndpointDeleted event
              notifications should be sent.
        + `EventEndpointUpdated` -- Topic ARN to which EndpointUpdate event
              notifications should be sent.
        + `EventDeliveryFailure` -- Topic ARN to which DeliveryFailure event
              notifications should be sent upon Direct Publish delivery failure
              (permanent) to one of the application's endpoints.

        """
        params = {}
        if platform_application_arn is not None:
            params['PlatformApplicationArn'] = platform_application_arn
        if attributes is not None:
            self._build_dict_as_list_params(params, attributes, 'Attributes')
        return self._make_request(action='SetPlatformApplicationAttributes',
                                  params=params)

</source>
</class>

<class classid="4" nclones="4" nlines="45" similarity="70">
<source file="systems/boto-2.13.2/boto/elasticache/layer1.py" startline="102" endline="286" pcid="6">
    def create_cache_cluster(self, cache_cluster_id, num_cache_nodes,
                             cache_node_type, engine,
                             replication_group_id=None, engine_version=None,
                             cache_parameter_group_name=None,
                             cache_subnet_group_name=None,
                             cache_security_group_names=None,
                             security_group_ids=None, snapshot_arns=None,
                             preferred_availability_zone=None,
                             preferred_maintenance_window=None, port=None,
                             notification_topic_arn=None,
                             auto_minor_version_upgrade=None):
        """
        The CreateCacheCluster operation creates a new cache cluster.
        All nodes in the cache cluster run the same protocol-compliant
        cache engine software - either Memcached or Redis.

        :type cache_cluster_id: string
        :param cache_cluster_id:
        The cache cluster identifier. This parameter is stored as a lowercase
            string.

        Constraints:


        + Must contain from 1 to 20 alphanumeric characters or hyphens.
        + First character must be a letter.
        + Cannot end with a hyphen or contain two consecutive hyphens.

        :type replication_group_id: string
        :param replication_group_id: The replication group to which this cache
            cluster should belong. If this parameter is specified, the cache
            cluster will be added to the specified replication group as a read
            replica; otherwise, the cache cluster will be a standalone primary
            that is not part of any replication group.

        :type num_cache_nodes: integer
        :param num_cache_nodes: The initial number of cache nodes that the
            cache cluster will have.
        For a Memcached cluster, valid values are between 1 and 20. If you need
            to exceed this limit, please fill out the ElastiCache Limit
            Increase Request form at ``_ .

        For Redis, only single-node cache clusters are supported at this time,
            so the value for this parameter must be 1.

        :type cache_node_type: string
        :param cache_node_type: The compute and memory capacity of the nodes in
            the cache cluster.
        Valid values for Memcached:

        `cache.t1.micro` | `cache.m1.small` | `cache.m1.medium` |
            `cache.m1.large` | `cache.m1.xlarge` | `cache.m3.xlarge` |
            `cache.m3.2xlarge` | `cache.m2.xlarge` | `cache.m2.2xlarge` |
            `cache.m2.4xlarge` | `cache.c1.xlarge`

        Valid values for Redis:

        `cache.t1.micro` | `cache.m1.small` | `cache.m1.medium` |
            `cache.m1.large` | `cache.m1.xlarge` | `cache.m2.xlarge` |
            `cache.m2.2xlarge` | `cache.m2.4xlarge` | `cache.c1.xlarge`

        For a complete listing of cache node types and specifications, see `.

        :type engine: string
        :param engine: The name of the cache engine to be used for this cache
            cluster.
        Valid values for this parameter are:

        `memcached` | `redis`

        :type engine_version: string
        :param engine_version: The version number of the cache engine to be
            used for this cluster. To view the supported cache engine versions,
            use the DescribeCacheEngineVersions operation.

        :type cache_parameter_group_name: string
        :param cache_parameter_group_name: The name of the cache parameter
            group to associate with this cache cluster. If this argument is
            omitted, the default cache parameter group for the specified engine
            will be used.

        :type cache_subnet_group_name: string
        :param cache_subnet_group_name: The name of the cache subnet group to
            be used for the cache cluster.
        Use this parameter only when you are creating a cluster in an Amazon
            Virtual Private Cloud (VPC).

        :type cache_security_group_names: list
        :param cache_security_group_names: A list of cache security group names
            to associate with this cache cluster.
        Use this parameter only when you are creating a cluster outside of an
            Amazon Virtual Private Cloud (VPC).

        :type security_group_ids: list
        :param security_group_ids: One or more VPC security groups associated
            with the cache cluster.
        Use this parameter only when you are creating a cluster in an Amazon
            Virtual Private Cloud (VPC).

        :type snapshot_arns: list
        :param snapshot_arns: A single-element string list containing an Amazon
            Resource Name (ARN) that uniquely identifies a Redis RDB snapshot
            file stored in Amazon S3. The snapshot file will be used to
            populate the Redis cache in the new cache cluster. The Amazon S3
            object name in the ARN cannot contain any commas.
        Here is an example of an Amazon S3 ARN:
            `arn:aws:s3:::my_bucket/snapshot1.rdb`

        **Note:** This parameter is only valid if the `Engine` parameter is
            `redis`.

        :type preferred_availability_zone: string
        :param preferred_availability_zone: The EC2 Availability Zone in which
            the cache cluster will be created.
        All cache nodes belonging to a cache cluster are placed in the
            preferred availability zone.

        Default: System chosen availability zone.

        :type preferred_maintenance_window: string
        :param preferred_maintenance_window: The weekly time range (in UTC)
            during which system maintenance can occur.
        Example: `sun:05:00-sun:09:00`

        :type port: integer
        :param port: The port number on which each of the cache nodes will
            accept connections.

        :type notification_topic_arn: string
        :param notification_topic_arn:
        The Amazon Resource Name (ARN) of the Amazon Simple Notification
            Service (SNS) topic to which notifications will be sent.

        The Amazon SNS topic owner must be the same as the cache cluster owner.

        :type auto_minor_version_upgrade: boolean
        :param auto_minor_version_upgrade: Determines whether minor engine
            upgrades will be applied automatically to the cache cluster during
            the maintenance window. A value of `True` allows these upgrades to
            occur; `False` disables automatic upgrades.
        Default: `True`

        """
        params = {
            'CacheClusterId': cache_cluster_id,
            'NumCacheNodes': num_cache_nodes,
            'CacheNodeType': cache_node_type,
            'Engine': engine,
        }
        if replication_group_id is not None:
            params['ReplicationGroupId'] = replication_group_id
        if engine_version is not None:
            params['EngineVersion'] = engine_version
        if cache_parameter_group_name is not None:
            params['CacheParameterGroupName'] = cache_parameter_group_name
        if cache_subnet_group_name is not None:
            params['CacheSubnetGroupName'] = cache_subnet_group_name
        if cache_security_group_names is not None:
            self.build_list_params(params,
                                   cache_security_group_names,
                                   'CacheSecurityGroupNames.member')
        if security_group_ids is not None:
            self.build_list_params(params,
                                   security_group_ids,
                                   'SecurityGroupIds.member')
        if snapshot_arns is not None:
            self.build_list_params(params,
                                   snapshot_arns,
                                   'SnapshotArns.member')
        if preferred_availability_zone is not None:
            params['PreferredAvailabilityZone'] = preferred_availability_zone
        if preferred_maintenance_window is not None:
            params['PreferredMaintenanceWindow'] = preferred_maintenance_window
        if port is not None:
            params['Port'] = port
        if notification_topic_arn is not None:
            params['NotificationTopicArn'] = notification_topic_arn
        if auto_minor_version_upgrade is not None:
            params['AutoMinorVersionUpgrade'] = str(
                auto_minor_version_upgrade).lower()
        return self._make_request(
            action='CreateCacheCluster',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/redshift/layer1.py" startline="1610" endline="1818" pcid="3018">
    def modify_cluster(self, cluster_identifier, cluster_type=None,
                       node_type=None, number_of_nodes=None,
                       cluster_security_groups=None,
                       vpc_security_group_ids=None,
                       master_user_password=None,
                       cluster_parameter_group_name=None,
                       automated_snapshot_retention_period=None,
                       preferred_maintenance_window=None,
                       cluster_version=None, allow_version_upgrade=None):
        """
        Modifies the settings for a cluster. For example, you can add
        another security or parameter group, update the preferred
        maintenance window, or change the master user password.
        Resetting a cluster password or modifying the security groups
        associated with a cluster do not need a reboot. However,
        modifying parameter group requires a reboot for parameters to
        take effect. For more information about managing clusters, go
        to `Amazon Redshift Clusters`_ in the Amazon Redshift
        Management Guide

        You can also change node type and the number of nodes to scale
        up or down the cluster. When resizing a cluster, you must
        specify both the number of nodes and the node type even if one
        of the parameters does not change. If you specify the same
        number of nodes and node type that are already configured for
        the cluster, an error is returned.

        :type cluster_identifier: string
        :param cluster_identifier: The unique identifier of the cluster to be
            modified.
        Example: `examplecluster`

        :type cluster_type: string
        :param cluster_type: The new cluster type.
        When you submit your cluster resize request, your existing cluster goes
            into a read-only mode. After Amazon Redshift provisions a new
            cluster based on your resize requirements, there will be outage for
            a period while the old cluster is deleted and your connection is
            switched to the new cluster. You can use DescribeResize to track
            the progress of the resize request.

        Valid Values: ` multi-node | single-node `

        :type node_type: string
        :param node_type: The new node type of the cluster. If you specify a
            new node type, you must also specify the number of nodes parameter
            also.
        When you submit your request to resize a cluster, Amazon Redshift sets
            access permissions for the cluster to read-only. After Amazon
            Redshift provisions a new cluster according to your resize
            requirements, there will be a temporary outage while the old
            cluster is deleted and your connection is switched to the new
            cluster. When the new connection is complete, the original access
            permissions for the cluster are restored. You can use the
            DescribeResize to track the progress of the resize request.

        Valid Values: ` dw.hs1.xlarge` | `dw.hs1.8xlarge`

        :type number_of_nodes: integer
        :param number_of_nodes: The new number of nodes of the cluster. If you
            specify a new number of nodes, you must also specify the node type
            parameter also.
        When you submit your request to resize a cluster, Amazon Redshift sets
            access permissions for the cluster to read-only. After Amazon
            Redshift provisions a new cluster according to your resize
            requirements, there will be a temporary outage while the old
            cluster is deleted and your connection is switched to the new
            cluster. When the new connection is complete, the original access
            permissions for the cluster are restored. You can use
            DescribeResize to track the progress of the resize request.

        Valid Values: Integer greater than `0`.

        :type cluster_security_groups: list
        :param cluster_security_groups:
        A list of cluster security groups to be authorized on this cluster.
            This change is asynchronously applied as soon as possible.

        Security groups currently associated with the cluster and not in the
            list of groups to apply, will be revoked from the cluster.

        Constraints:


        + Must be 1 to 255 alphanumeric characters or hyphens
        + First character must be a letter
        + Cannot end with a hyphen or contain two consecutive hyphens

        :type vpc_security_group_ids: list
        :param vpc_security_group_ids: A list of Virtual Private Cloud (VPC)
            security groups to be associated with the cluster.

        :type master_user_password: string
        :param master_user_password:
        The new password for the cluster master user. This change is
            asynchronously applied as soon as possible. Between the time of the
            request and the completion of the request, the `MasterUserPassword`
            element exists in the `PendingModifiedValues` element of the
            operation response.
        Operations never return the password, so this operation provides a way
            to regain access to the master user account for a cluster if the
            password is lost.


        Default: Uses existing setting.

        Constraints:


        + Must be between 8 and 64 characters in length.
        + Must contain at least one uppercase letter.
        + Must contain at least one lowercase letter.
        + Must contain one number.
        + Can be any printable ASCII character (ASCII code 33 to 126) except '
              (single quote), " (double quote), \, /, @, or space.

        :type cluster_parameter_group_name: string
        :param cluster_parameter_group_name: The name of the cluster parameter
            group to apply to this cluster. This change is applied only after
            the cluster is rebooted. To reboot a cluster use RebootCluster.
        Default: Uses existing setting.

        Constraints: The cluster parameter group must be in the same parameter
            group family that matches the cluster version.

        :type automated_snapshot_retention_period: integer
        :param automated_snapshot_retention_period: The number of days that
            automated snapshots are retained. If the value is 0, automated
            snapshots are disabled. Even if automated snapshots are disabled,
            you can still create manual snapshots when you want with
            CreateClusterSnapshot.
        If you decrease the automated snapshot retention period from its
            current value, existing automated snapshots which fall outside of
            the new retention period will be immediately deleted.

        Default: Uses existing setting.

        Constraints: Must be a value from 0 to 35.

        :type preferred_maintenance_window: string
        :param preferred_maintenance_window: The weekly time range (in UTC)
            during which system maintenance can occur, if necessary. If system
            maintenance is necessary during the window, it may result in an
            outage.
        This maintenance window change is made immediately. If the new
            maintenance window indicates the current time, there must be at
            least 120 minutes between the current time and end of the window in
            order to ensure that pending changes are applied.

        Default: Uses existing setting.

        Format: ddd:hh24:mi-ddd:hh24:mi, for example `wed:07:30-wed:08:00`.

        Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun

        Constraints: Must be at least 30 minutes.

        :type cluster_version: string
        :param cluster_version: The new version number of the Amazon Redshift
            engine to upgrade to.
        For major version upgrades, if a non-default cluster parameter group is
            currently in use, a new cluster parameter group in the cluster
            parameter group family for the new version must be specified. The
            new cluster parameter group can be the default for that cluster
            parameter group family. For more information about managing
            parameter groups, go to `Amazon Redshift Parameter Groups`_ in the
            Amazon Redshift Management Guide .

        Example: `1.0`

        :type allow_version_upgrade: boolean
        :param allow_version_upgrade: If `True`, upgrades will be applied
            automatically to the cluster during the maintenance window.
        Default: `False`

        """
        params = {'ClusterIdentifier': cluster_identifier, }
        if cluster_type is not None:
            params['ClusterType'] = cluster_type
        if node_type is not None:
            params['NodeType'] = node_type
        if number_of_nodes is not None:
            params['NumberOfNodes'] = number_of_nodes
        if cluster_security_groups is not None:
            self.build_list_params(params,
                                   cluster_security_groups,
                                   'ClusterSecurityGroups.member')
        if vpc_security_group_ids is not None:
            self.build_list_params(params,
                                   vpc_security_group_ids,
                                   'VpcSecurityGroupIds.member')
        if master_user_password is not None:
            params['MasterUserPassword'] = master_user_password
        if cluster_parameter_group_name is not None:
            params['ClusterParameterGroupName'] = cluster_parameter_group_name
        if automated_snapshot_retention_period is not None:
            params['AutomatedSnapshotRetentionPeriod'] = automated_snapshot_retention_period
        if preferred_maintenance_window is not None:
            params['PreferredMaintenanceWindow'] = preferred_maintenance_window
        if cluster_version is not None:
            params['ClusterVersion'] = cluster_version
        if allow_version_upgrade is not None:
            params['AllowVersionUpgrade'] = str(
                allow_version_upgrade).lower()
        return self._make_request(
            action='ModifyCluster',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/elasticache/layer1.py" startline="1163" endline="1306" pcid="27">
    def modify_cache_cluster(self, cache_cluster_id, num_cache_nodes=None,
                             cache_node_ids_to_remove=None,
                             cache_security_group_names=None,
                             security_group_ids=None,
                             preferred_maintenance_window=None,
                             notification_topic_arn=None,
                             cache_parameter_group_name=None,
                             notification_topic_status=None,
                             apply_immediately=None, engine_version=None,
                             auto_minor_version_upgrade=None):
        """
        The ModifyCacheCluster operation modifies the settings for a
        cache cluster. You can use this operation to change one or
        more cluster configuration parameters by specifying the
        parameters and the new values.

        :type cache_cluster_id: string
        :param cache_cluster_id: The cache cluster identifier. This value is
            stored as a lowercase string.

        :type num_cache_nodes: integer
        :param num_cache_nodes: The number of cache nodes that the cache
            cluster should have. If the value for NumCacheNodes is greater than
            the existing number of cache nodes, then more nodes will be added.
            If the value is less than the existing number of cache nodes, then
            cache nodes will be removed.
        If you are removing cache nodes, you must use the CacheNodeIdsToRemove
            parameter to provide the IDs of the specific cache nodes to be
            removed.

        :type cache_node_ids_to_remove: list
        :param cache_node_ids_to_remove: A list of cache node IDs to be
            removed. A node ID is a numeric identifier (0001, 0002, etc.). This
            parameter is only valid when NumCacheNodes is less than the
            existing number of cache nodes. The number of cache node IDs
            supplied in this parameter must match the difference between the
            existing number of cache nodes in the cluster and the value of
            NumCacheNodes in the request.

        :type cache_security_group_names: list
        :param cache_security_group_names: A list of cache security group names
            to authorize on this cache cluster. This change is asynchronously
            applied as soon as possible.
        This parameter can be used only with clusters that are created outside
            of an Amazon Virtual Private Cloud (VPC).

        Constraints: Must contain no more than 255 alphanumeric characters.
            Must not be "Default".

        :type security_group_ids: list
        :param security_group_ids: Specifies the VPC Security Groups associated
            with the cache cluster.
        This parameter can be used only with clusters that are created in an
            Amazon Virtual Private Cloud (VPC).

        :type preferred_maintenance_window: string
        :param preferred_maintenance_window: The weekly time range (in UTC)
            during which system maintenance can occur. Note that system
            maintenance may result in an outage. This change is made
            immediately. If you are moving this window to the current time,
            there must be at least 120 minutes between the current time and end
            of the window to ensure that pending changes are applied.

        :type notification_topic_arn: string
        :param notification_topic_arn:
        The Amazon Resource Name (ARN) of the SNS topic to which notifications
            will be sent.

        The SNS topic owner must be same as the cache cluster owner.

        :type cache_parameter_group_name: string
        :param cache_parameter_group_name: The name of the cache parameter
            group to apply to this cache cluster. This change is asynchronously
            applied as soon as possible for parameters when the
            ApplyImmediately parameter is specified as true for this request.

        :type notification_topic_status: string
        :param notification_topic_status: The status of the Amazon SNS
            notification topic. Notifications are sent only if the status is
            active .
        Valid values: `active` | `inactive`

        :type apply_immediately: boolean
        :param apply_immediately: If `True`, this parameter causes the
            modifications in this request and any pending modifications to be
            applied, asynchronously and as soon as possible, regardless of the
            PreferredMaintenanceWindow setting for the cache cluster.
        If `False`, then changes to the cache cluster are applied on the next
            maintenance reboot, or the next failure reboot, whichever occurs
            first.

        Valid values: `True` | `False`

        Default: `False`

        :type engine_version: string
        :param engine_version: The upgraded version of the cache engine to be
            run on the cache cluster nodes.

        :type auto_minor_version_upgrade: boolean
        :param auto_minor_version_upgrade: If `True`, then minor engine
            upgrades will be applied automatically to the cache cluster during
            the maintenance window.
        Valid values: `True` | `False`

        Default: `True`

        """
        params = {'CacheClusterId': cache_cluster_id, }
        if num_cache_nodes is not None:
            params['NumCacheNodes'] = num_cache_nodes
        if cache_node_ids_to_remove is not None:
            self.build_list_params(params,
                                   cache_node_ids_to_remove,
                                   'CacheNodeIdsToRemove.member')
        if cache_security_group_names is not None:
            self.build_list_params(params,
                                   cache_security_group_names,
                                   'CacheSecurityGroupNames.member')
        if security_group_ids is not None:
            self.build_list_params(params,
                                   security_group_ids,
                                   'SecurityGroupIds.member')
        if preferred_maintenance_window is not None:
            params['PreferredMaintenanceWindow'] = preferred_maintenance_window
        if notification_topic_arn is not None:
            params['NotificationTopicArn'] = notification_topic_arn
        if cache_parameter_group_name is not None:
            params['CacheParameterGroupName'] = cache_parameter_group_name
        if notification_topic_status is not None:
            params['NotificationTopicStatus'] = notification_topic_status
        if apply_immediately is not None:
            params['ApplyImmediately'] = str(
                apply_immediately).lower()
        if engine_version is not None:
            params['EngineVersion'] = engine_version
        if auto_minor_version_upgrade is not None:
            params['AutoMinorVersionUpgrade'] = str(
                auto_minor_version_upgrade).lower()
        return self._make_request(
            action='ModifyCacheCluster',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/elasticache/layer1.py" startline="1373" endline="1505" pcid="30">
    def modify_replication_group(self, replication_group_id,
                                 replication_group_description=None,
                                 cache_security_group_names=None,
                                 security_group_ids=None,
                                 preferred_maintenance_window=None,
                                 notification_topic_arn=None,
                                 cache_parameter_group_name=None,
                                 notification_topic_status=None,
                                 apply_immediately=None, engine_version=None,
                                 auto_minor_version_upgrade=None,
                                 primary_cluster_id=None):
        """
        The ModifyReplicationGroup operation modifies the settings for
        a replication group.

        :type replication_group_id: string
        :param replication_group_id: The identifier of the replication group to
            modify.

        :type replication_group_description: string
        :param replication_group_description: A description for the replication
            group. Maximum length is 255 characters.

        :type cache_security_group_names: list
        :param cache_security_group_names: A list of cache security group names
            to authorize for the clusters in this replication group. This
            change is asynchronously applied as soon as possible.
        This parameter can be used only with replication groups containing
            cache clusters running outside of an Amazon Virtual Private Cloud
            (VPC).

        Constraints: Must contain no more than 255 alphanumeric characters.
            Must not be "Default".

        :type security_group_ids: list
        :param security_group_ids: Specifies the VPC Security Groups associated
            with the cache clusters in the replication group.
        This parameter can be used only with replication groups containing
            cache clusters running in an Amazon Virtual Private Cloud (VPC).

        :type preferred_maintenance_window: string
        :param preferred_maintenance_window: The weekly time range (in UTC)
            during which replication group system maintenance can occur. Note
            that system maintenance may result in an outage. This change is
            made immediately. If you are moving this window to the current
            time, there must be at least 120 minutes between the current time
            and end of the window to ensure that pending changes are applied.

        :type notification_topic_arn: string
        :param notification_topic_arn:
        The Amazon Resource Name (ARN) of the SNS topic to which notifications
            will be sent.

        The SNS topic owner must be same as the replication group owner.

        :type cache_parameter_group_name: string
        :param cache_parameter_group_name: The name of the cache parameter
            group to apply to all of the cache nodes in this replication group.
            This change is asynchronously applied as soon as possible for
            parameters when the ApplyImmediately parameter is specified as true
            for this request.

        :type notification_topic_status: string
        :param notification_topic_status: The status of the Amazon SNS
            notification topic for the replication group. Notifications are
            sent only if the status is active .
        Valid values: `active` | `inactive`

        :type apply_immediately: boolean
        :param apply_immediately: If `True`, this parameter causes the
            modifications in this request and any pending modifications to be
            applied, asynchronously and as soon as possible, regardless of the
            PreferredMaintenanceWindow setting for the replication group.
        If `False`, then changes to the nodes in the replication group are
            applied on the next maintenance reboot, or the next failure reboot,
            whichever occurs first.

        Valid values: `True` | `False`

        Default: `False`

        :type engine_version: string
        :param engine_version: The upgraded version of the cache engine to be
            run on the nodes in the replication group..

        :type auto_minor_version_upgrade: boolean
        :param auto_minor_version_upgrade: Determines whether minor engine
            upgrades will be applied automatically to all of the cache nodes in
            the replication group during the maintenance window. A value of
            `True` allows these upgrades to occur; `False` disables automatic
            upgrades.

        :type primary_cluster_id: string
        :param primary_cluster_id: If this parameter is specified, ElastiCache
            will promote each of the nodes in the specified cache cluster to
            the primary role. The nodes of all other clusters in the
            replication group will be read replicas.

        """
        params = {'ReplicationGroupId': replication_group_id, }
        if replication_group_description is not None:
            params['ReplicationGroupDescription'] = replication_group_description
        if cache_security_group_names is not None:
            self.build_list_params(params,
                                   cache_security_group_names,
                                   'CacheSecurityGroupNames.member')
        if security_group_ids is not None:
            self.build_list_params(params,
                                   security_group_ids,
                                   'SecurityGroupIds.member')
        if preferred_maintenance_window is not None:
            params['PreferredMaintenanceWindow'] = preferred_maintenance_window
        if notification_topic_arn is not None:
            params['NotificationTopicArn'] = notification_topic_arn
        if cache_parameter_group_name is not None:
            params['CacheParameterGroupName'] = cache_parameter_group_name
        if notification_topic_status is not None:
            params['NotificationTopicStatus'] = notification_topic_status
        if apply_immediately is not None:
            params['ApplyImmediately'] = str(
                apply_immediately).lower()
        if engine_version is not None:
            params['EngineVersion'] = engine_version
        if auto_minor_version_upgrade is not None:
            params['AutoMinorVersionUpgrade'] = str(
                auto_minor_version_upgrade).lower()
        if primary_cluster_id is not None:
            params['PrimaryClusterId'] = primary_cluster_id
        return self._make_request(
            action='ModifyReplicationGroup',
            verb='POST',
            path='/', params=params)

</source>
</class>

<class classid="5" nclones="2" nlines="12" similarity="75">
<source file="systems/boto-2.13.2/boto/elasticache/layer1.py" startline="1307" endline="1337" pcid="28">
    def modify_cache_parameter_group(self, cache_parameter_group_name,
                                     parameter_name_values):
        """
        The ModifyCacheParameterGroup operation modifies the
        parameters of a cache parameter group. You can modify up to 20
        parameters in a single request by submitting a list parameter
        name and value pairs.

        :type cache_parameter_group_name: string
        :param cache_parameter_group_name: The name of the cache parameter
            group to modify.

        :type parameter_name_values: list
        :param parameter_name_values: An array of parameter names and values
            for the parameter update. You must supply at least one parameter
            name and value; subsequent arguments are optional. A maximum of 20
            parameters may be modified per request.

        """
        params = {
            'CacheParameterGroupName': cache_parameter_group_name,
        }
        self.build_complex_list_params(
            params, parameter_name_values,
            'ParameterNameValues.member',
            ('ParameterName', 'ParameterValue'))
        return self._make_request(
            action='ModifyCacheParameterGroup',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/redshift/layer1.py" startline="1819" endline="1849" pcid="3019">
    def modify_cluster_parameter_group(self, parameter_group_name,
                                       parameters):
        """
        Modifies the parameters of a parameter group.

        For more information about managing parameter groups, go to
        `Amazon Redshift Parameter Groups`_ in the Amazon Redshift
        Management Guide .

        :type parameter_group_name: string
        :param parameter_group_name: The name of the parameter group to be
            modified.

        :type parameters: list
        :param parameters: An array of parameters to be modified. A maximum of
            20 parameters can be modified in a single request.
        For each parameter to be modified, you must supply at least the
            parameter name and parameter value; other name-value pairs of the
            parameter are optional.

        """
        params = {'ParameterGroupName': parameter_group_name, }
        self.build_complex_list_params(
            params, parameters,
            'Parameters.member',
            ('ParameterName', 'ParameterValue', 'Description', 'Source', 'DataType', 'AllowedValues', 'IsModifiable', 'MinimumEngineVersion'))
        return self._make_request(
            action='ModifyClusterParameterGroup',
            verb='POST',
            path='/', params=params)

</source>
</class>

<class classid="6" nclones="3" nlines="14" similarity="71">
<source file="systems/boto-2.13.2/boto/elasticache/layer1.py" startline="1338" endline="1372" pcid="29">
    def modify_cache_subnet_group(self, cache_subnet_group_name,
                                  cache_subnet_group_description=None,
                                  subnet_ids=None):
        """
        The ModifyCacheSubnetGroup operation modifies an existing
        cache subnet group.

        :type cache_subnet_group_name: string
        :param cache_subnet_group_name: The name for the cache subnet group.
            This value is stored as a lowercase string.
        Constraints: Must contain no more than 255 alphanumeric characters or
            hyphens.

        Example: `mysubnetgroup`

        :type cache_subnet_group_description: string
        :param cache_subnet_group_description: A description for the cache
            subnet group.

        :type subnet_ids: list
        :param subnet_ids: The EC2 subnet IDs for the cache subnet group.

        """
        params = {'CacheSubnetGroupName': cache_subnet_group_name, }
        if cache_subnet_group_description is not None:
            params['CacheSubnetGroupDescription'] = cache_subnet_group_description
        if subnet_ids is not None:
            self.build_list_params(params,
                                   subnet_ids,
                                   'SubnetIds.member')
        return self._make_request(
            action='ModifyCacheSubnetGroup',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/redshift/layer1.py" startline="759" endline="821" pcid="3000">
    def delete_cluster(self, cluster_identifier,
                       skip_final_cluster_snapshot=None,
                       final_cluster_snapshot_identifier=None):
        """
        Deletes a previously provisioned cluster. A successful
        response from the web service indicates that the request was
        received correctly. If a final cluster snapshot is requested
        the status of the cluster will be "final-snapshot" while the
        snapshot is being taken, then it's "deleting" once Amazon
        Redshift begins deleting the cluster. Use DescribeClusters to
        monitor the status of the deletion. The delete operation
        cannot be canceled or reverted once submitted. For more
        information about managing clusters, go to `Amazon Redshift
        Clusters`_ in the Amazon Redshift Management Guide .

        :type cluster_identifier: string
        :param cluster_identifier:
        The identifier of the cluster to be deleted.

        Constraints:


        + Must contain lowercase characters.
        + Must contain from 1 to 63 alphanumeric characters or hyphens.
        + First character must be a letter.
        + Cannot end with a hyphen or contain two consecutive hyphens.

        :type skip_final_cluster_snapshot: boolean
        :param skip_final_cluster_snapshot: Determines whether a final snapshot
            of the cluster is created before Amazon Redshift deletes the
            cluster. If `True`, a final cluster snapshot is not created. If
            `False`, a final cluster snapshot is created before the cluster is
            deleted.
        The FinalClusterSnapshotIdentifier parameter must be specified if
            SkipFinalClusterSnapshot is `False`.

        Default: `False`

        :type final_cluster_snapshot_identifier: string
        :param final_cluster_snapshot_identifier:
        The identifier of the final snapshot that is to be created immediately
            before deleting the cluster. If this parameter is provided,
            SkipFinalClusterSnapshot must be `False`.

        Constraints:


        + Must be 1 to 255 alphanumeric characters.
        + First character must be a letter.
        + Cannot end with a hyphen or contain two consecutive hyphens.

        """
        params = {'ClusterIdentifier': cluster_identifier, }
        if skip_final_cluster_snapshot is not None:
            params['SkipFinalClusterSnapshot'] = str(
                skip_final_cluster_snapshot).lower()
        if final_cluster_snapshot_identifier is not None:
            params['FinalClusterSnapshotIdentifier'] = final_cluster_snapshot_identifier
        return self._make_request(
            action='DeleteCluster',
            verb='POST',
            path='/', params=params)

</source>
<source file="systems/boto-2.13.2/boto/redshift/layer1.py" startline="1937" endline="1978" pcid="3023">
    def reset_cluster_parameter_group(self, parameter_group_name,
                                      reset_all_parameters=None,
                                      parameters=None):
        """
        Sets one or more parameters of the specified parameter group
        to their default values and sets the source values of the
        parameters to "engine-default". To reset the entire parameter
        group specify the ResetAllParameters parameter. For parameter
        changes to take effect you must reboot any associated
        clusters.

        :type parameter_group_name: string
        :param parameter_group_name: The name of the cluster parameter group to
            be reset.

        :type reset_all_parameters: boolean
        :param reset_all_parameters: If `True`, all parameters in the specified
            parameter group will be reset to their default values.
        Default: `True`

        :type parameters: list
        :param parameters: An array of names of parameters to be reset. If
            ResetAllParameters option is not used, then at least one parameter
            name must be supplied.
        Constraints: A maximum of 20 parameters can be reset in a single
            request.

        """
        params = {'ParameterGroupName': parameter_group_name, }
        if reset_all_parameters is not None:
            params['ResetAllParameters'] = str(
                reset_all_parameters).lower()
        if parameters is not None:
            self.build_complex_list_params(
                params, parameters,
                'Parameters.member',
                ('ParameterName', 'ParameterValue', 'Description', 'Source', 'DataType', 'AllowedValues', 'IsModifiable', 'MinimumEngineVersion'))
        return self._make_request(
            action='ResetClusterParameterGroup',
            verb='POST',
            path='/', params=params)

</source>
</class>

<class classid="7" nclones="33" nlines="14" similarity="70">
<source file="systems/boto-2.13.2/boto/ec2/reservedinstance.py" startline="29" endline="47" pcid="39">
    def __init__(self, connection=None, id=None, instance_type=None,
                 availability_zone=None, duration=None, fixed_price=None,
                 usage_price=None, description=None, instance_tenancy=None,
                 currency_code=None, offering_type=None,
                 recurring_charges=None, pricing_details=None):
        EC2Object.__init__(self, connection)
        self.id = id
        self.instance_type = instance_type
        self.availability_zone = availability_zone
        self.duration = duration
        self.fixed_price = fixed_price
        self.usage_price = usage_price
        self.description = description
        self.instance_tenancy = instance_tenancy
        self.currency_code = currency_code
        self.offering_type = offering_type
        self.recurring_charges = recurring_charges
        self.pricing_details = pricing_details

</source>
<source file="systems/boto-2.13.2/boto/ec2/launchspecification.py" startline="46" endline="61" pcid="371">
    def __init__(self, connection=None):
        EC2Object.__init__(self, connection)
        self.key_name = None
        self.instance_type = None
        self.image_id = None
        self.groups = []
        self.placement = None
        self.kernel = None
        self.ramdisk = None
        self.monitored = False
        self.subnet_id = None
        self._in_monitoring_element = False
        self.block_device_mapping = None
        self.instance_profile = None
        self.ebs_optimized = False

</source>
<source file="systems/boto-2.13.2/boto/ec2/networkinterface.py" startline="101" endline="117" pcid="467">
    def __init__(self, connection=None):
        TaggedEC2Object.__init__(self, connection)
        self.id = None
        self.subnet_id = None
        self.vpc_id = None
        self.availability_zone = None
        self.description = None
        self.owner_id = None
        self.requester_managed = False
        self.status = None
        self.mac_address = None
        self.private_ip_address = None
        self.source_dest_check = None
        self.groups = []
        self.attachment = None
        self.private_ip_addresses = []

</source>
<source file="systems/boto-2.13.2/boto/ec2/spotinstancerequest.py" startline="122" endline="139" pcid="236">
    def __init__(self, connection=None):
        TaggedEC2Object.__init__(self, connection)
        self.id = None
        self.price = None
        self.type = None
        self.state = None
        self.fault = None
        self.valid_from = None
        self.valid_until = None
        self.launch_group = None
        self.launched_availability_zone = None
        self.product_description = None
        self.availability_zone_group = None
        self.create_time = None
        self.launch_specification = None
        self.instance_id = None
        self.status = None

</source>
<source file="systems/boto-2.13.2/boto/ec2/bundleinstance.py" startline="30" endline="44" pcid="444">
    def __init__(self, connection=None):
        EC2Object.__init__(self, connection)
        self.id = None
        self.instance_id = None
        self.progress = None
        self.start_time = None
        self.state = None
        self.bucket = None
        self.prefix = None
        self.upload_policy = None
        self.upload_policy_signature = None
        self.update_time = None 
        self.code = None
        self.message = None

</source>
<source file="systems/boto-2.13.2/boto/ec2/volume.py" startline="49" endline="60" pcid="479">
    def __init__(self, connection=None):
        TaggedEC2Object.__init__(self, connection)
        self.id = None
        self.create_time = None
        self.status = None
        self.size = None
        self.snapshot_id = None
        self.attach_data = None
        self.zone = None
        self.type = None
        self.iops = None

</source>
<source file="systems/boto-2.13.2/boto/ec2/snapshot.py" startline="33" endline="44" pcid="551">
    def __init__(self, connection=None):
        TaggedEC2Object.__init__(self, connection)
        self.id = None
        self.volume_id = None
        self.status = None
        self.progress = None
        self.start_time = None
        self.owner_id = None
        self.owner_alias = None
        self.volume_size = None
        self.description = None

</source>
<source file="systems/boto-2.13.2/boto/roboto/param.py" startline="72" endline="88" pcid="4151">
    def __init__(self, name=None, ptype='string', optional=True,
                 short_name=None, long_name=None, doc='',
                 metavar=None, cardinality=1, default=None,
                 choices=None, encoder=None, request_param=True):
        self.name = name
        self.ptype = ptype
        self.optional = optional
        self.short_name = short_name
        self.long_name = long_name
        self.doc = doc
        self.metavar = metavar
        self.cardinality = cardinality
        self.default = default
        self.choices = choices
        self.encoder = encoder
        self.request_param = request_param

</source>
<source file="systems/boto-2.13.2/boto/ec2/autoscale/activity.py" startline="26" endline="37" pcid="167">
    def __init__(self, connection=None):
        self.connection = connection
        self.start_time = None
        self.end_time = None
        self.activity_id = None
        self.progress = None
        self.status_code = None
        self.cause = None
        self.description = None
        self.status_message = None
        self.group_name = None

</source>
<source file="systems/boto-2.13.2/boto/cloudformation/stack.py" startline="250" endline="261" pcid="952">
    def __init__(self, connection=None):
        self.connection = connection
        self.description = None
        self.logical_resource_id = None
        self.physical_resource_id = None
        self.resource_status = None
        self.resource_status_reason = None
        self.resource_type = None
        self.stack_id = None
        self.stack_name = None
        self.timestamp = None

</source>
<source file="systems/boto-2.13.2/boto/cloudformation/stack.py" startline="341" endline="353" pcid="960">
    def __init__(self, connection=None):
        self.connection = connection
        self.event_id = None
        self.logical_resource_id = None
        self.physical_resource_id = None
        self.resource_properties = None
        self.resource_status = None
        self.resource_status_reason = None
        self.resource_type = None
        self.stack_id = None
        self.stack_name = None
        self.timestamp = None

</source>
<source file="systems/boto-2.13.2/boto/ec2/autoscale/scheduled.py" startline="27" endline="39" pcid="181">
    def __init__(self, connection=None):
        self.connection = connection
        self.name = None
        self.action_arn = None
        self.as_group = None
        self.time = None
        self.start_time = None
        self.end_time = None
        self.recurrence = None
        self.desired_capacity = None
        self.max_size = None
        self.min_size = None

</source>
<source file="systems/boto-2.13.2/boto/s3/multipart.py" startline="133" endline="147" pcid="3475">
    def __init__(self, bucket=None):
        self.bucket = bucket
        self.bucket_name = None
        self.key_name = None
        self.id = id
        self.initiator = None
        self.owner = None
        self.storage_class = None
        self.initiated = None
        self.part_number_marker = None
        self.next_part_number_marker = None
        self.max_parts = None
        self.is_truncated = False
        self._parts = None

</source>
<source file="systems/boto-2.13.2/boto/rds/dbsnapshot.py" startline="43" endline="56" pcid="2272">
    def __init__(self, connection=None, id=None):
        self.connection = connection
        self.id = id
        self.engine = None
        self.snapshot_create_time = None
        self.instance_create_time = None
        self.port = None
        self.status = None
        self.availability_zone = None
        self.master_username = None
        self.allocated_storage = None
        self.instance_id = None
        self.availability_zone = None

</source>
<source file="systems/boto-2.13.2/boto/resultset.py" startline="45" endline="62" pcid="3096">
    def __init__(self, marker_elem=None):
        list.__init__(self)
        if isinstance(marker_elem, list):
            self.markers = marker_elem
        else:
            self.markers = []
        self.marker = None
        self.key_marker = None
        self.next_marker = None  # avail when delimiter used
        self.next_key_marker = None
        self.next_upload_id_marker = None
        self.next_version_id_marker = None
        self.next_generation_marker= None
        self.version_id_marker = None
        self.is_truncated = False
        self.next_token = None
        self.status = True

</source>
<source file="systems/boto-2.13.2/boto/ec2/elb/loadbalancer.py" startline="75" endline="125" pcid="681">
    def __init__(self, connection=None, name=None, endpoints=None):
        """
        :ivar boto.ec2.elb.ELBConnection connection: The connection this load
            balancer was instance was instantiated from.
        :ivar list listeners: A list of tuples in the form of
            ``(<Inbound port>, <Outbound port>, <Protocol>)``
        :ivar boto.ec2.elb.healthcheck.HealthCheck health_check: The health
            check policy for this load balancer.
        :ivar boto.ec2.elb.policies.Policies policies: Cookie stickiness and
            other policies.
        :ivar str dns_name: The external DNS name for the balancer.
        :ivar str created_time: A date+time string showing when the
            load balancer was created.
        :ivar list instances: A list of :py:class:`boto.ec2.instanceinfo.InstanceInfo`
            instances, representing the EC2 instances this load balancer is
            distributing requests to.
        :ivar list availability_zones: The availability zones this balancer
            covers.
        :ivar str canonical_hosted_zone_name: Current CNAME for the balancer.
        :ivar str canonical_hosted_zone_name_id: The Route 53 hosted zone
            ID of this balancer. Needed when creating an Alias record in a
            Route 53 hosted zone.
        :ivar boto.ec2.elb.securitygroup.SecurityGroup source_security_group:
            The security group that you can use as part of your inbound rules
            for your load balancer back-end instances to disallow traffic
            from sources other than your load balancer.
        :ivar list subnets: A list of subnets this balancer is on.
        :ivar list security_groups: A list of additional security groups that
            have been applied.
        :ivar str vpc_id: The ID of the VPC that this ELB resides within.
        :ivar list backends: A list of :py:class:`boto.ec2.elb.loadbalancer.Backend
            back-end server descriptions.
        """
        self.connection = connection
        self.name = name
        self.listeners = None
        self.health_check = None
        self.policies = None
        self.dns_name = None
        self.created_time = None
        self.instances = None
        self.availability_zones = ListElement()
        self.canonical_hosted_zone_name = None
        self.canonical_hosted_zone_name_id = None
        self.source_security_group = None
        self.subnets = ListElement()
        self.security_groups = ListElement()
        self.vpc_id = None
        self.scheme = None
        self.backends = None

</source>
<source file="systems/boto-2.13.2/boto/ec2/image.py" startline="49" endline="73" pcid="626">
    def __init__(self, connection=None):
        TaggedEC2Object.__init__(self, connection)
        self.id = None
        self.location = None
        self.state = None
        self.ownerId = None  # for backwards compatibility
        self.owner_id = None
        self.owner_alias = None
        self.is_public = False
        self.architecture = None
        self.platform = None
        self.type = None
        self.kernel_id = None
        self.ramdisk_id = None
        self.name = None
        self.description = None
        self.product_codes = ProductCodes()
        self.billing_products = BillingProducts()
        self.block_device_mapping = None
        self.root_device_type = None
        self.root_device_name = None
        self.virtualization_type = None
        self.hypervisor = None
        self.instance_lifecycle = None

</source>
<source file="systems/boto-2.13.2/boto/sdb/db/manager/sdbmanager.py" startline="401" endline="421" pcid="2704">
    def __init__(self, cls, db_name, db_user, db_passwd,
                 db_host, db_port, db_table, ddl_dir, enable_ssl,
                 consistent=None):
        self.cls = cls
        self.db_name = db_name
        self.db_user = db_user
        self.db_passwd = db_passwd
        self.db_host = db_host
        self.db_port = db_port
        self.db_table = db_table
        self.ddl_dir = ddl_dir
        self.enable_ssl = enable_ssl
        self.s3 = None
        self.bucket = None
        self.converter = SDBConverter(self)
        self._sdb = None
        self._domain = None
        if consistent == None and hasattr(cls, "__consistent__"):
            consistent = cls.__consistent__
        self.consistent = consistent

</source>
<source file="systems/boto-2.13.2/boto/cloudfront/distribution.py" startline="284" endline="297" pcid="1485">
    def __init__(self, connection=None, config=None, domain_name='',
                 id='', last_modified_time=None, status=''):
        self.connection = connection
        self.config = config
        self.domain_name = domain_name
        self.id = id
        self.last_modified_time = last_modified_time
        self.status = status
        self.in_progress_invalidation_batches = 0
        self.active_signers = None
        self.etag = None
        self._bucket = None
        self._object_class = Object

</source>
<source file="systems/boto-2.13.2/boto/ec2/address.py" startline="39" endline="50" pcid="527">
    def __init__(self, connection=None, public_ip=None, instance_id=None):
        EC2Object.__init__(self, connection)
        self.connection = connection
        self.public_ip = public_ip
        self.instance_id = instance_id
        self.domain = None
        self.allocation_id = None
        self.association_id = None
        self.network_interface_id = None
        self.network_interface_owner_id = None
        self.private_ip_address = None

</source>
<source file="systems/boto-2.13.2/boto/ec2/reservedinstance.py" startline="298" endline="312" pcid="72">
    def __init__(self, connection=None, modification_id=None,
                 reserved_instances=None, modification_results=None,
                 create_date=None, update_date=None, effective_date=None,
                 status=None, status_message=None, client_token=None):
        self.connection = connection
        self.modification_id = modification_id
        self.reserved_instances = reserved_instances
        self.modification_results = modification_results
        self.create_date = create_date
        self.update_date = update_date
        self.effective_date = effective_date
        self.status = status
        self.status_message = status_message
        self.client_token = client_token

</source>
<source file="systems/boto-2.13.2/boto/ec2/reservedinstance.py" startline="155" endline="166" pcid="54">
    def __init__(self, connection=None, listing_id=None, id=None,
                 create_date=None, update_date=None,
                 status=None, status_message=None, client_token=None):
        self.connection = connection
        self.listing_id = listing_id
        self.id = id
        self.create_date = create_date
        self.update_date = update_date
        self.status = status
        self.status_message = status_message
        self.client_token = client_token

</source>
<source file="systems/boto-2.13.2/boto/rds/parametergroup.py" startline="83" endline="93" pcid="2284">
    def __init__(self, group=None, name=None):
        self.group = group
        self.name = name
        self._value = None
        self.type = 'string'
        self.source = None
        self.is_modifiable = True
        self.description = None
        self.apply_method = None
        self.allowed_values = None

</source>
<source file="systems/boto-2.13.2/tests/integration/s3/mock_storage_service.py" startline="64" endline="76" pcid="4524">
    def __init__(self, bucket=None, name=None):
        self.bucket = bucket
        self.name = name
        self.data = None
        self.etag = None
        self.size = None
        self.closed = True
        self.content_encoding = None
        self.content_language = None
        self.content_type = None
        self.last_modified = 'Wed, 06 Oct 2010 05:11:54 GMT'
        self.BufferSize = 8192

</source>
<source file="systems/boto-2.13.2/boto/mashups/order.py" startline="38" endline="49" pcid="2497">
    def __init__(self):
        self.region = None
        self.name = None
        self.instance_type = None
        self.quantity = 0
        self.zone = None
        self.ami = None
        self.groups = []
        self.key = None
        self.ec2 = None
        self.config = None

</source>
<source file="systems/boto-2.13.2/boto/rds/optiongroup.py" startline="197" endline="209" pcid="2247">
    def __init__(self, name=None, description=None, value=None,
                 default_value=False, allowed_values=None, data_type=None,
                 apply_type=None, is_modifiable=False, is_collection=False):
        self.name = name
        self.description = description
        self.value = value
        self.default_value = default_value
        self.allowed_values = allowed_values
        self.data_type = data_type
        self.apply_type = apply_type
        self.is_modifiable = is_modifiable
        self.is_collection = is_collection

</source>
<source file="systems/boto-2.13.2/boto/vpc/vpnconnection.py" startline="154" endline="165" pcid="3141">
    def __init__(self, connection=None):
        TaggedEC2Object.__init__(self, connection)
        self.id = None
        self.state = None
        self.customer_gateway_configuration = None
        self.type = None
        self.customer_gateway_id = None
        self.vpn_gateway_id = None
        self.tunnels = []
        self.options = None
        self.static_routes = []

</source>
<source file="systems/boto-2.13.2/boto/s3/key.py" startline="103" endline="134" pcid="3523">
    def __init__(self, bucket=None, name=None):
        self.bucket = bucket
        self.name = name
        self.metadata = {}
        self.cache_control = None
        self.content_type = self.DefaultContentType
        self.content_encoding = None
        self.content_disposition = None
        self.content_language = None
        self.filename = None
        self.etag = None
        self.is_latest = False
        self.last_modified = None
        self.owner = None
        self.storage_class = 'STANDARD'
        self.path = None
        self.resp = None
        self.mode = None
        self.size = None
        self.version_id = None
        self.source_version_id = None
        self.delete_marker = False
        self.encrypted = None
        # If the object is being restored, this attribute will be set to True.
        # If the object is restored, it will be set to False.  Otherwise this
        # value will be None. If the restore is completed (ongoing_restore =
        # False), the expiry_date will be populated with the expiry date of the
        # restored object.
        self.ongoing_restore = None
        self.expiry_date = None
        self.local_hashes = {}

</source>
<source file="systems/boto-2.13.2/boto/rds/dbinstance.py" startline="81" endline="107" pcid="2215">
    def __init__(self, connection=None, id=None):
        self.connection = connection
        self.id = id
        self.create_time = None
        self.engine = None
        self.status = None
        self.allocated_storage = None
        self.endpoint = None
        self.instance_class = None
        self.master_username = None
        self.parameter_groups = []
        self.security_groups = []
        self.read_replica_dbinstance_identifiers = []
        self.availability_zone = None
        self.backup_retention_period = None
        self.preferred_backup_window = None
        self.preferred_maintenance_window = None
        self.latest_restorable_time = None
        self.multi_az = False
        self.iops = None
        self.vpc_security_groups = None
        self.pending_modified_values = None
        self._in_endpoint = False
        self._port = None
        self._address = None
        self.status_infos = None

</source>
<source file="systems/boto-2.13.2/boto/ec2/networkinterface.py" startline="261" endline="276" pcid="478">

                key = full_prefix + 'AssociatePublicIpAddress'

                if spec.associate_public_ip_address:
                    params[key] = 'true'
                else:
                    params[key] = 'false'


class NetworkInterfaceSpecification(object):
    def __init__(self, network_interface_id=None, device_index=None,
                 subnet_id=None, description=None, private_ip_address=None,
                 groups=None, delete_on_termination=None,
                 private_ip_addresses=None,
                 secondary_private_ip_address_count=None,
                 associate_public_ip_address=None):
</source>
<source file="systems/boto-2.13.2/boto/route53/record.py" startline="215" endline="229" pcid="3889">
    def __init__(self, name=None, type=None, ttl=600, resource_records=None,
            alias_hosted_zone_id=None, alias_dns_name=None, identifier=None,
            weight=None, region=None):
        self.name = name
        self.type = type
        self.ttl = ttl
        if resource_records == None:
            resource_records = []
        self.resource_records = resource_records
        self.alias_hosted_zone_id = alias_hosted_zone_id
        self.alias_dns_name = alias_dns_name
        self.identifier = identifier
        self.weight = weight
        self.region = region

</source>
<source file="systems/boto-2.13.2/boto/rds/optiongroup.py" startline="58" endline="68" pcid="2238">
    def __init__(self, connection=None, name=None, engine_name=None,
                 major_engine_version=None, description=None,
                 allow_both_vpc_and_nonvpc=False, vpc_id=None):
        self.name = name
        self.engine_name = engine_name
        self.major_engine_version = major_engine_version
        self.description = description
        self.allow_both_vpc_and_nonvpc = allow_both_vpc_and_nonvpc
        self.vpc_id = vpc_id
        self.options = []

</source>
<source file="systems/boto-2.13.2/boto/roboto/awsqueryrequest.py" startline="180" endline="191" pcid="4123">
    def __init__(self, **args):
        self.args = args
        self.parser = None
        self.cli_options = None
        self.cli_args = None
        self.cli_output_format = None
        self.connection = None
        self.list_markers = []
        self.item_markers = []
        self.request_params = {}
        self.connection_args = None

</source>
</class>

<class classid="8" nclones="82" nlines="18" similarity="70">
<source file="systems/boto-2.13.2/boto/ec2/reservedinstance.py" startline="60" endline="83" pcid="42">
    def endElement(self, name, value, connection):
        if name == 'reservedInstancesOfferingId':
            self.id = value
        elif name == 'instanceType':
            self.instance_type = value
        elif name == 'availabilityZone':
            self.availability_zone = value
        elif name == 'duration':
            self.duration = int(value)
        elif name == 'fixedPrice':
            self.fixed_price = value
        elif name == 'usagePrice':
            self.usage_price = value
        elif name == 'productDescription':
            self.description = value
        elif name == 'instanceTenancy':
            self.instance_tenancy = value
        elif name == 'currencyCode':
            self.currency_code = value
        elif name == 'offeringType':
            self.offering_type = value
        elif name == 'marketplace':
            self.marketplace = True if value == 'true' else False

</source>
<source file="systems/boto-2.13.2/boto/rds/parametergroup.py" startline="100" endline="125" pcid="2287">
    def endElement(self, name, value, connection):
        if name == 'ParameterName':
            self.name = value
        elif name == 'ParameterValue':
            self._value = value
        elif name == 'DataType':
            if value in self.ValidTypes:
                self.type = value
        elif name == 'Source':
            if value in self.ValidSources:
                self.source = value
        elif name == 'IsModifiable':
            if value.lower() == 'true':
                self.is_modifiable = True
            else:
                self.is_modifiable = False
        elif name == 'Description':
            self.description = value
        elif name == 'ApplyType':
            if value in self.ValidApplyTypes:
                self.apply_type = value
        elif name == 'AllowedValues':
            self.allowed_values = value
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/ec2/spotinstancerequest.py" startline="159" endline="186" pcid="239">
    def endElement(self, name, value, connection):
        if name == 'spotInstanceRequestId':
            self.id = value
        elif name == 'spotPrice':
            self.price = float(value)
        elif name == 'type':
            self.type = value
        elif name == 'state':
            self.state = value
        elif name == 'validFrom':
            self.valid_from = value
        elif name == 'validUntil':
            self.valid_until = value
        elif name == 'launchGroup':
            self.launch_group = value
        elif name == 'availabilityZoneGroup':
            self.availability_zone_group = value
        elif name == 'launchedAvailabilityZone':
            self.launched_availability_zone = value
        elif name == 'instanceId':
            self.instance_id = value
        elif name == 'createTime':
            self.create_time = value
        elif name == 'productDescription':
            self.product_description = value
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/ec2/snapshot.py" startline="48" endline="70" pcid="553">
    def endElement(self, name, value, connection):
        if name == 'snapshotId':
            self.id = value
        elif name == 'volumeId':
            self.volume_id = value
        elif name == 'status':
            self.status = value
        elif name == 'startTime':
            self.start_time = value
        elif name == 'ownerId':
            self.owner_id = value
        elif name == 'ownerAlias':
            self.owner_alias = value
        elif name == 'volumeSize':
            try:
                self.volume_size = int(value)
            except:
                self.volume_size = value
        elif name == 'description':
            self.description = value
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/route53/record.py" startline="292" endline="311" pcid="3895">
    def endElement(self, name, value, connection):
        if name == 'Name':
            self.name = value
        elif name == 'Type':
            self.type = value
        elif name == 'TTL':
            self.ttl = value
        elif name == 'Value':
            self.resource_records.append(value)
        elif name == 'HostedZoneId':
            self.alias_hosted_zone_id = value
        elif name == 'DNSName':
            self.alias_dns_name = value
        elif name == 'SetIdentifier':
            self.identifier = value
        elif name == 'Weight':
            self.weight = value
        elif name == 'Region':
            self.region = value

</source>
<source file="systems/boto-2.13.2/boto/rds/optiongroup.py" startline="216" endline="244" pcid="2250">
    def endElement(self, name, value, connection):
        if name == 'Name':
            self.name = value
        elif name == 'Description':
            self.description = value
        elif name == 'Value':
            self.value = value
        elif name == 'DefaultValue':
            self.default_value = value
        elif name == 'AllowedValues':
            self.allowed_values = value
        elif name == 'DataType':
            self.data_type = value
        elif name == 'ApplyType':
            self.apply_type = value
        elif name == 'IsModifiable':
            if value.lower() == 'true':
                self.is_modifiable = True
            else:
                self.is_modifiable = False
        elif name == 'IsCollection':
            if value.lower() == 'true':
                self.is_collection = True
            else:
                self.is_collection = False
        else:
            setattr(self, name, value)


</source>
<source file="systems/boto-2.13.2/boto/cloudformation/stack.py" startline="265" endline="289" pcid="954">
    def endElement(self, name, value, connection):
        if name == "Description":
            self.description = value
        elif name == "LogicalResourceId":
            self.logical_resource_id = value
        elif name == "PhysicalResourceId":
            self.physical_resource_id = value
        elif name == "ResourceStatus":
            self.resource_status = value
        elif name == "ResourceStatusReason":
            self.resource_status_reason = value
        elif name == "ResourceType":
            self.resource_type = value
        elif name == "StackId":
            self.stack_id = value
        elif name == "StackName":
            self.stack_name = value
        elif name == "Timestamp":
            try:
                self.timestamp = datetime.strptime(value, '%Y-%m-%dT%H:%M:%SZ')
            except ValueError:
                self.timestamp = datetime.strptime(value, '%Y-%m-%dT%H:%M:%S.%fZ')
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/ec2/launchspecification.py" startline="80" endline="105" pcid="374">
    def endElement(self, name, value, connection):
        if name == 'imageId':
            self.image_id = value
        elif name == 'keyName':
            self.key_name = value
        elif name == 'instanceType':
            self.instance_type = value
        elif name == 'availabilityZone':
            self.placement = value
        elif name == 'placement':
            pass
        elif name == 'kernelId':
            self.kernel = value
        elif name == 'ramdiskId':
            self.ramdisk = value
        elif name == 'subnetId':
            self.subnet_id = value
        elif name == 'state':
            if self._in_monitoring_element:
                if value == 'enabled':
                    self.monitored = True
                self._in_monitoring_element = False
        elif name == 'ebsOptimized':
            self.ebs_optimized = (value == 'true')
        else:
            setattr(self, name, value)
</source>
<source file="systems/boto-2.13.2/boto/ec2/blockdevicemapping.py" startline="57" endline="81" pcid="567">
    def endElement(self, name, value, connection):
        if name == 'volumeId':
            self.volume_id = value
        elif name == 'virtualName':
            self.ephemeral_name = value
        elif name == 'NoDevice':
            self.no_device = (value == 'true')
        elif name == 'snapshotId':
            self.snapshot_id = value
        elif name == 'volumeSize':
            self.size = int(value)
        elif name == 'status':
            self.status = value
        elif name == 'attachTime':
            self.attach_time = value
        elif name == 'deleteOnTermination':
            self.delete_on_termination = (value == 'true')
        elif name == 'volumeType':
            self.volume_type = value
        elif name == 'iops':
            self.iops = int(value)
        else:
            setattr(self, name, value)

# for backwards compatibility
</source>
<source file="systems/boto-2.13.2/boto/ec2/bundleinstance.py" startline="51" endline="78" pcid="447">
    def endElement(self, name, value, connection):
        if name == 'bundleId':
            self.id = value
        elif name == 'instanceId':
            self.instance_id = value
        elif name == 'progress':
            self.progress = value
        elif name == 'startTime':
            self.start_time = value
        elif name == 'state':
            self.state = value
        elif name == 'bucket':
            self.bucket = value
        elif name == 'prefix':
            self.prefix = value
        elif name == 'uploadPolicy':
            self.upload_policy = value
        elif name == 'uploadPolicySignature':
            self.upload_policy_signature = value
        elif name == 'updateTime':
            self.update_time = value
        elif name == 'code':
            self.code = value
        elif name == 'message':
            self.message = value
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/ec2/address.py" startline="54" endline="73" pcid="529">
    def endElement(self, name, value, connection):
        if name == 'publicIp':
            self.public_ip = value
        elif name == 'instanceId':
            self.instance_id = value
        elif name == 'domain':
            self.domain = value
        elif name == 'allocationId':
            self.allocation_id = value
        elif name == 'associationId':
            self.association_id = value
        elif name == 'networkInterfaceId':
            self.network_interface_id = value
        elif name == 'networkInterfaceOwnerId':
            self.network_interface_owner_id = value
        elif name == 'privateIpAddress':
            self.private_ip_address = value
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/rds/dbsnapshot.py" startline="63" endline="88" pcid="2275">
    def endElement(self, name, value, connection):
        if name == 'Engine':
            self.engine = value
        elif name == 'InstanceCreateTime':
            self.instance_create_time = value
        elif name == 'SnapshotCreateTime':
            self.snapshot_create_time = value
        elif name == 'DBInstanceIdentifier':
            self.instance_id = value
        elif name == 'DBSnapshotIdentifier':
            self.id = value
        elif name == 'Port':
            self.port = int(value)
        elif name == 'Status':
            self.status = value
        elif name == 'AvailabilityZone':
            self.availability_zone = value
        elif name == 'MasterUsername':
            self.master_username = value
        elif name == 'AllocatedStorage':
            self.allocated_storage = int(value)
        elif name == 'SnapshotTime':
            self.time = value
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/s3/multipart.py" startline="177" endline="201" pcid="3480">
    def endElement(self, name, value, connection):
        if name == 'Bucket':
            self.bucket_name = value
        elif name == 'Key':
            self.key_name = value
        elif name == 'UploadId':
            self.id = value
        elif name == 'StorageClass':
            self.storage_class = value
        elif name == 'PartNumberMarker':
            self.part_number_marker = value
        elif name == 'NextPartNumberMarker':
            self.next_part_number_marker = value
        elif name == 'MaxParts':
            self.max_parts = int(value)
        elif name == 'IsTruncated':
            if value == 'true':
                self.is_truncated = True
            else:
                self.is_truncated = False
        elif name == 'Initiated':
            self.initiated = value
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/cloudfront/distribution.py" startline="249" endline="273" pcid="1482">
    def endElement(self, name, value, connection):
        if name == 'Id':
            self.id = value
        elif name == 'Status':
            self.status = value
        elif name == 'LastModifiedTime':
            self.last_modified_time = value
        elif name == 'DomainName':
            self.domain_name = value
        elif name == 'Origin':
            self.origin = value
        elif name == 'CNAME':
            self.cnames.append(value)
        elif name == 'Comment':
            self.comment = value
        elif name == 'Enabled':
            if value.lower() == 'true':
                self.enabled = True
            else:
                self.enabled = False
        elif name == 'StreamingDistributionSummary':
            self.streaming = True
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/cloudformation/stack.py" startline="357" endline="383" pcid="962">
    def endElement(self, name, value, connection):
        if name == "EventId":
            self.event_id = value
        elif name == "LogicalResourceId":
            self.logical_resource_id = value
        elif name == "PhysicalResourceId":
            self.physical_resource_id = value
        elif name == "ResourceProperties":
            self.resource_properties = value
        elif name == "ResourceStatus":
            self.resource_status = value
        elif name == "ResourceStatusReason":
            self.resource_status_reason = value
        elif name == "ResourceType":
            self.resource_type = value
        elif name == "StackId":
            self.stack_id = value
        elif name == "StackName":
            self.stack_name = value
        elif name == "Timestamp":
            try:
                self.timestamp = datetime.strptime(value, '%Y-%m-%dT%H:%M:%SZ')
            except ValueError:
                self.timestamp = datetime.strptime(value, '%Y-%m-%dT%H:%M:%S.%fZ')
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/gs/key.py" startline="81" endline="107" pcid="3824">
    def endElement(self, name, value, connection):
        if name == 'Key':
            self.name = value
        elif name == 'ETag':
            self.etag = value
        elif name == 'IsLatest':
            if value == 'true':
                self.is_latest = True
            else:
                self.is_latest = False
        elif name == 'LastModified':
            self.last_modified = value
        elif name == 'Size':
            self.size = int(value)
        elif name == 'StorageClass':
            self.storage_class = value
        elif name == 'Owner':
            pass
        elif name == 'VersionId':
            self.version_id = value
        elif name == 'Generation':
            self.generation = value
        elif name == 'MetaGeneration':
            self.metageneration = value
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/ec2/securitygroup.py" startline="57" endline="84" pcid="508">
    def endElement(self, name, value, connection):
        if name == 'ownerId':
            self.owner_id = value
        elif name == 'groupId':
            self.id = value
        elif name == 'groupName':
            self.name = value
        elif name == 'vpcId':
            self.vpc_id = value
        elif name == 'groupDescription':
            self.description = value
        elif name == 'ipRanges':
            pass
        elif name == 'return':
            if value == 'false':
                self.status = False
            elif value == 'true':
                self.status = True
            else:
                raise Exception(
                    'Unexpected value of status %s for group %s' % (
                        value,
                        self.name
                    )
                )
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/rds/optiongroup.py" startline="323" endline="354" pcid="2258">
    def endElement(self, name, value, connection):
        if name == 'Name':
            self.name = value
        elif name == 'Description':
            self.description = value
        elif name == 'EngineName':
            self.engine_name = value
        elif name == 'MajorEngineVersion':
            self.major_engine_version = value
        elif name == 'MinimumRequiredMinorEngineVersion':
            self.min_minor_engine_version = value
        elif name == 'Permanent':
            if value.lower() == 'true':
                self.permenant = True
            else:
                self.permenant = False
        elif name == 'Persistent':
            if value.lower() == 'true':
                self.persistent = True
            else:
                self.persistent = False
        elif name == 'PortRequired':
            if value.lower() == 'true':
                self.port_required = True
            else:
                self.port_required = False
        elif name == 'DefaultPort':
            self.default_port = int(value)
        else:
            setattr(self, name, value)


</source>
<source file="systems/boto-2.13.2/boto/ec2/elb/loadbalancer.py" startline="159" endline="178" pcid="684">
    def endElement(self, name, value, connection):
        if name == 'LoadBalancerName':
            self.name = value
        elif name == 'DNSName':
            self.dns_name = value
        elif name == 'CreatedTime':
            self.created_time = value
        elif name == 'InstanceId':
            self.instances.append(value)
        elif name == 'CanonicalHostedZoneName':
            self.canonical_hosted_zone_name = value
        elif name == 'CanonicalHostedZoneNameID':
            self.canonical_hosted_zone_name_id = value
        elif name == 'VPCId':
            self.vpc_id = value
        elif name == 'Scheme':
            self.scheme = value
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/rds/optiongroup.py" startline="80" endline="98" pcid="2241">
    def endElement(self, name, value, connection):
        if name == 'OptionGroupName':
            self.name = value
        elif name == 'EngineName':
            self.engine_name = value
        elif name == 'MajorEngineVersion':
            self.major_engine_version = value
        elif name == 'OptionGroupDescription':
            self.description = value
        elif name == 'AllowsVpcAndNonVpcInstanceMemberships':
            if value.lower() == 'true':
                self.allow_both_vpc_and_nonvpc = True
            else:
                self.allow_both_vpc_and_nonvpc = False
        elif name == 'VpcId':
            self.vpc_id = value
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/ec2/networkinterface.py" startline="137" endline="168" pcid="470">
    def endElement(self, name, value, connection):
        if name == 'networkInterfaceId':
            self.id = value
        elif name == 'subnetId':
            self.subnet_id = value
        elif name == 'vpcId':
            self.vpc_id = value
        elif name == 'availabilityZone':
            self.availability_zone = value
        elif name == 'description':
            self.description = value
        elif name == 'ownerId':
            self.owner_id = value
        elif name == 'requesterManaged':
            if value.lower() == 'true':
                self.requester_managed = True
            else:
                self.requester_managed = False
        elif name == 'status':
            self.status = value
        elif name == 'macAddress':
            self.mac_address = value
        elif name == 'privateIpAddress':
            self.private_ip_address = value
        elif name == 'sourceDestCheck':
            if value.lower() == 'true':
                self.source_dest_check = True
            else:
                self.source_dest_check = False
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/ec2/autoscale/activity.py" startline="47" endline="74" pcid="170">
    def endElement(self, name, value, connection):
        if name == 'ActivityId':
            self.activity_id = value
        elif name == 'AutoScalingGroupName':
            self.group_name = value
        elif name == 'StartTime':
            try:
                self.start_time = datetime.strptime(value, '%Y-%m-%dT%H:%M:%S.%fZ')
            except ValueError:
                self.start_time = datetime.strptime(value, '%Y-%m-%dT%H:%M:%SZ')
        elif name == 'EndTime':
            try:
                self.end_time = datetime.strptime(value, '%Y-%m-%dT%H:%M:%S.%fZ')
            except ValueError:
                self.end_time = datetime.strptime(value, '%Y-%m-%dT%H:%M:%SZ')
        elif name == 'Progress':
            self.progress = value
        elif name == 'Cause':
            self.cause = value
        elif name == 'Description':
            self.description = value
        elif name == 'StatusMessage':
            self.status_message = value
        elif name == 'StatusCode':
            self.status_code = value
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/cloudformation/stack.py" startline="42" endline="69" pcid="922">
    def endElement(self, name, value, connection):
        if name == 'CreationTime':
            try:
                self.creation_time = datetime.strptime(value, '%Y-%m-%dT%H:%M:%SZ')
            except ValueError:
                self.creation_time = datetime.strptime(value, '%Y-%m-%dT%H:%M:%S.%fZ')
        elif name == "Description":
            self.description = value
        elif name == "DisableRollback":
            if str(value).lower() == 'true':
                self.disable_rollback = True
            else:
                self.disable_rollback = False
        elif name == 'StackId':
            self.stack_id = value
        elif name == 'StackName':
            self.stack_name = value
        elif name == 'StackStatus':
            self.stack_status = value
        elif name == "StackStatusReason":
            self.stack_status_reason = value
        elif name == "TimeoutInMinutes":
            self.timeout_in_minutes = int(value)
        elif name == "member":
            pass
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/ec2/autoscale/group.py" startline="223" endline="253" pcid="113">
    def endElement(self, name, value, connection):
        if name == 'MinSize':
            self.min_size = int(value)
        elif name == 'AutoScalingGroupARN':
            self.autoscaling_group_arn = value
        elif name == 'CreatedTime':
            self.created_time = value
        elif name == 'DefaultCooldown':
            self.default_cooldown = int(value)
        elif name == 'LaunchConfigurationName':
            self.launch_config_name = value
        elif name == 'DesiredCapacity':
            self.desired_capacity = int(value)
        elif name == 'MaxSize':
            self.max_size = int(value)
        elif name == 'AutoScalingGroupName':
            self.name = value
        elif name == 'PlacementGroup':
            self.placement_group = value
        elif name == 'HealthCheckGracePeriod':
            try:
                self.health_check_period = int(value)
            except ValueError:
                self.health_check_period = None
        elif name == 'HealthCheckType':
            self.health_check_type = value
        elif name == 'VPCZoneIdentifier':
            self.vpc_zone_identifier = value
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/ec2/autoscale/launchconfig.py" startline="181" endline="213" pcid="141">
    def endElement(self, name, value, connection):
        if name == 'InstanceType':
            self.instance_type = value
        elif name == 'LaunchConfigurationName':
            self.name = value
        elif name == 'KeyName':
            self.key_name = value
        elif name == 'ImageId':
            self.image_id = value
        elif name == 'CreatedTime':
            self.created_time = boto.utils.parse_ts(value)
        elif name == 'KernelId':
            self.kernel_id = value
        elif name == 'RamdiskId':
            self.ramdisk_id = value
        elif name == 'UserData':
            try:
                self.user_data = base64.b64decode(value)
            except TypeError:
                self.user_data = value
        elif name == 'LaunchConfigurationARN':
            self.launch_configuration_arn = value
        elif name == 'InstanceMonitoring':
            self.instance_monitoring = value
        elif name == 'SpotPrice':
            self.spot_price = float(value)
        elif name == 'IamInstanceProfile':
            self.instance_profile_name = value
        elif name == 'EbsOptimized':
            self.ebs_optimized = True if value.lower() == 'true' else False
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/ec2/cloudwatch/alarm.py" startline="182" endline="215" pcid="398">
    def endElement(self, name, value, connection):
        if name == 'ActionsEnabled':
            self.actions_enabled = value
        elif name == 'AlarmArn':
            self.alarm_arn = value
        elif name == 'AlarmConfigurationUpdatedTimestamp':
            self.last_updated = value
        elif name == 'AlarmDescription':
            self.description = value
        elif name == 'AlarmName':
            self.name = value
        elif name == 'ComparisonOperator':
            setattr(self, 'comparison', self._rev_cmp_map[value])
        elif name == 'EvaluationPeriods':
            self.evaluation_periods = int(value)
        elif name == 'MetricName':
            self.metric = value
        elif name == 'Namespace':
            self.namespace = value
        elif name == 'Period':
            self.period = int(value)
        elif name == 'StateReason':
            self.state_reason = value
        elif name == 'StateValue':
            self.state_value = value
        elif name == 'Statistic':
            self.statistic = value
        elif name == 'Threshold':
            self.threshold = float(value)
        elif name == 'Unit':
            self.unit = value
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/rds/optiongroup.py" startline="387" endline="404" pcid="2262">
    def endElement(self, name, value, connection):
        if name == 'SettingName':
            self.name = value
        elif name == 'SettingDescription':
            self.description = value
        elif name == 'DefaultValue':
            self.default_value = value
        elif name == 'AllowedValues':
            self.allowed_values = value
        elif name == 'ApplyType':
            self.apply_type = value
        elif name == 'IsModifiable':
            if value.lower() == 'true':
                self.is_modifiable = True
            else:
                self.is_modifiable = False
        else:
            setattr(self, name, value)
</source>
<source file="systems/boto-2.13.2/boto/s3/key.py" startline="483" endline="505" pcid="3547">
    def endElement(self, name, value, connection):
        if name == 'Key':
            self.name = value
        elif name == 'ETag':
            self.etag = value
        elif name == 'IsLatest':
            if value == 'true':
                self.is_latest = True
            else:
                self.is_latest = False
        elif name == 'LastModified':
            self.last_modified = value
        elif name == 'Size':
            self.size = int(value)
        elif name == 'StorageClass':
            self.storage_class = value
        elif name == 'Owner':
            pass
        elif name == 'VersionId':
            self.version_id = value
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/ec2/volume.py" startline="77" endline="97" pcid="482">
    def endElement(self, name, value, connection):
        if name == 'volumeId':
            self.id = value
        elif name == 'createTime':
            self.create_time = value
        elif name == 'status':
            if value != '':
                self.status = value
        elif name == 'size':
            self.size = int(value)
        elif name == 'snapshotId':
            self.snapshot_id = value
        elif name == 'availabilityZone':
            self.zone = value
        elif name == 'volumeType':
            self.type = value
        elif name == 'iops':
            self.iops = int(value)
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/ec2/networkinterface.py" startline="58" endline="79" pcid="466">
    def endElement(self, name, value, connection):
        if name == 'attachmentId':
            self.id = value
        elif name == 'instanceId':
            self.instance_id = value
        elif name == 'deviceIndex':
            self.device_index = int(value)
        elif name == 'instanceOwnerId':
            self.instance_owner_id = value
        elif name == 'status':
            self.status = value
        elif name == 'attachTime':
            self.attach_time = value
        elif name == 'deleteOnTermination':
            if value.lower() == 'true':
                self.delete_on_termination = True
            else:
                self.delete_on_termination = False
        else:
            setattr(self, name, value)


</source>
<source file="systems/boto-2.13.2/boto/ec2/reservedinstance.py" startline="326" endline="342" pcid="74">
    def endElement(self, name, value, connection):
        if name == 'reservedInstancesModificationId':
            self.modification_id = value
        elif name == 'createDate':
            self.create_date = parse_ts(value)
        elif name == 'updateDate':
            self.update_date = parse_ts(value)
        elif name == 'effectiveDate':
            self.effective_date = parse_ts(value)
        elif name == 'status':
            self.status = value
        elif name == 'statusMessage':
            self.status_message = value
        elif name == 'clientToken':
            self.client_token = value
        else:
            setattr(self, name, value)
</source>
<source file="systems/boto-2.13.2/boto/ec2/reservedinstance.py" startline="176" endline="192" pcid="56">
    def endElement(self, name, value, connection):
        if name == 'reservedInstancesListingId':
            self.listing_id = value
        elif name == 'reservedInstancesId':
            self.id = value
        elif name == 'createDate':
            self.create_date = value
        elif name == 'updateDate':
            self.update_date = value
        elif name == 'status':
            self.status = value
        elif name == 'statusMessage':
            self.status_message = value
        else:
            setattr(self, name, value)


</source>
<source file="systems/boto-2.13.2/boto/s3/acl.py" startline="133" endline="148" pcid="3430">
    def endElement(self, name, value, connection):
        if name == 'ID':
            self.id = value
        elif name == 'DisplayName':
            self.display_name = value
        elif name == 'URI':
            self.uri = value
        elif name == 'EmailAddress':
            self.email_address = value
        elif name == 'Grantee':
            pass
        elif name == 'Permission':
            self.permission = value
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/rds/optiongroup.py" startline="159" endline="179" pcid="2246">
    def endElement(self, name, value, connection):
        if name == 'OptionName':
            self.name = value
        elif name == 'OptionDescription':
            self.description = value
        elif name == 'Permanent':
            if value.lower() == 'true':
                self.permenant = True
            else:
                self.permenant = False
        elif name == 'Persistent':
            if value.lower() == 'true':
                self.persistent = True
            else:
                self.persistent = False
        elif name == 'Port':
            self.port = int(value)
        else:
            setattr(self, name, value)


</source>
<source file="systems/boto-2.13.2/boto/ec2/autoscale/instance.py" startline="45" endline="60" pcid="180">
    def endElement(self, name, value, connection):
        if name == 'InstanceId':
            self.instance_id = value
        elif name == 'HealthStatus':
            self.health_status = value
        elif name == 'LaunchConfigurationName':
            self.launch_config_name = value
        elif name == 'LifecycleState':
            self.lifecycle_state = value
        elif name == 'AvailabilityZone':
            self.availability_zone = value
        elif name == 'AutoScalingGroupName':
            self.group_name = value
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/vpc/subnet.py" startline="42" endline="57" pcid="3125">
    def endElement(self, name, value, connection):
        if name == 'subnetId':
            self.id = value
        elif name == 'vpcId':
            self.vpc_id = value
        elif name == 'state':
            self.state = value
        elif name == 'cidrBlock':
            self.cidr_block = value
        elif name == 'availableIpAddressCount':
            self.available_ip_address_count = int(value)
        elif name == 'availabilityZone':
            self.availability_zone = value
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/vpc/vpnconnection.py" startline="184" endline="199" pcid="3144">
    def endElement(self, name, value, connection):
        if name == 'vpnConnectionId':
            self.id = value
        elif name == 'state':
            self.state = value
        elif name == 'customerGatewayConfiguration':
            self.customer_gateway_configuration = value
        elif name == 'type':
            self.type = value
        elif name == 'customerGatewayId':
            self.customer_gateway_id = value
        elif name == 'vpnGatewayId':
            self.vpn_gateway_id = value
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/vpc/vpc.py" startline="53" endline="68" pcid="3148">
    def endElement(self, name, value, connection):
        if name == 'vpcId':
            self.id = value
        elif name == 'dhcpOptionsId':
            self.dhcp_options_id = value
        elif name == 'state':
            self.state = value
        elif name == 'cidrBlock':
            self.cidr_block = value
        elif name == 'isDefault':
            self.is_default = True if value == 'true' else False
        elif name == 'instanceTenancy':
            self.instance_tenancy = value
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/route53/hostedzone.py" startline="43" endline="56" pcid="3940">
    def endElement(self, name, value, connection):
        if name == 'Id':
            self.id = value
        elif name == 'Name':
            self.name = value
        elif name == 'Owner':
            self.owner = value
        elif name == 'Version':
            self.version = value
        elif name == 'CallerReference':
            self.caller_reference = value
        else:
            setattr(self, name, value)
        
</source>
<source file="systems/boto-2.13.2/boto/cloudfront/distribution.py" startline="157" endline="173" pcid="1477">
    def endElement(self, name, value, connection):
        if name == 'CNAME':
            self.cnames.append(value)
        elif name == 'Comment':
            self.comment = value
        elif name == 'Enabled':
            if value.lower() == 'true':
                self.enabled = True
            else:
                self.enabled = False
        elif name == 'CallerReference':
            self.caller_reference = value
        elif name == 'DefaultRootObject':
            self.default_root_object = value
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/s3/deletemarker.py" startline="40" endline="55" pcid="3279">
    def endElement(self, name, value, connection):
        if name == 'Key':
            self.name = value
        elif name == 'IsLatest':
            if value == 'true':
                self.is_latest = True
            else:
                self.is_latest = False
        elif name == 'LastModified':
            self.last_modified = value
        elif name == 'Owner':
            pass
        elif name == 'VersionId':
            self.version_id = value
        else:
            setattr(self, name, value)
</source>
<source file="systems/boto-2.13.2/boto/vpc/customergateway.py" startline="41" endline="54" pcid="3128">
    def endElement(self, name, value, connection):
        if name == 'customerGatewayId':
            self.id = value
        elif name == 'ipAddress':
            self.ip_address = value
        elif name == 'type':
            self.type = value
        elif name == 'state':
            self.state = value
        elif name == 'bgpAsn':
            self.bgp_asn = value
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/ec2/volume.py" startline="277" endline="291" pcid="495">
    def endElement(self, name, value, connection):
        if name == 'volumeId':
            self.id = value
        elif name == 'instanceId':
            self.instance_id = value
        elif name == 'status':
            self.status = value
        elif name == 'attachTime':
            self.attach_time = value
        elif name == 'device':
            self.device = value
        else:
            setattr(self, name, value)


</source>
<source file="systems/boto-2.13.2/boto/ec2/volumestatus.py" startline="54" endline="68" pcid="244">
    def endElement(self, name, value, connection):
        if name == 'eventType':
            self.type = value
        elif name == 'eventId':
            self.id = value
        elif name == 'description':
            self.description = value
        elif name == 'notBefore':
            self.not_before = value
        elif name == 'notAfter':
            self.not_after = value
        else:
            setattr(self, name, value)


</source>
<source file="systems/boto-2.13.2/boto/cloudformation/stack.py" startline="124" endline="148" pcid="932">
    def endElement(self, name, value, connection):
        if name == 'StackId':
            self.stack_id = value
        elif name == 'StackStatus':
            self.stack_status = value
        elif name == 'StackName':
            self.stack_name = value
        elif name == 'CreationTime':
            try:
                self.creation_time = datetime.strptime(value, '%Y-%m-%dT%H:%M:%SZ')
            except ValueError:
                self.creation_time = datetime.strptime(value, '%Y-%m-%dT%H:%M:%S.%fZ')
        elif name == "DeletionTime":
            try:
                self.deletion_time = datetime.strptime(value, '%Y-%m-%dT%H:%M:%SZ')
            except ValueError:
                self.deletion_time = datetime.strptime(value, '%Y-%m-%dT%H:%M:%S.%fZ')
        elif name == 'TemplateDescription':
            self.template_description = value
        elif name == "member":
            pass
        else:
            setattr(self, name, value)


</source>
<source file="systems/boto-2.13.2/boto/ec2/autoscale/policy.py" startline="144" endline="159" pcid="162">
    def endElement(self, name, value, connection):
        if name == 'PolicyName':
            self.name = value
        elif name == 'AutoScalingGroupName':
            self.as_name = value
        elif name == 'PolicyARN':
            self.policy_arn = value
        elif name == 'ScalingAdjustment':
            self.scaling_adjustment = int(value)
        elif name == 'Cooldown':
            self.cooldown = int(value)
        elif name == 'AdjustmentType':
            self.adjustment_type = value
        elif name == 'MinAdjustmentStep':
            self.min_adjustment_step = int(value)

</source>
<source file="systems/boto-2.13.2/boto/ec2/elb/listener.py" startline="56" endline="69" pcid="670">
    def endElement(self, name, value, connection):
        if name == 'LoadBalancerPort':
            self.load_balancer_port = int(value)
        elif name == 'InstancePort':
            self.instance_port = int(value)
        elif name == 'InstanceProtocol':
            self.instance_protocol = value
        elif name == 'Protocol':
            self.protocol = value
        elif name == 'SSLCertificateId':
            self.ssl_certificate_id = value
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/ec2/spotpricehistory.py" startline="41" endline="55" pcid="544">
    def endElement(self, name, value, connection):
        if name == 'instanceType':
            self.instance_type = value
        elif name == 'spotPrice':
            self.price = float(value)
        elif name == 'productDescription':
            self.product_description = value
        elif name == 'timestamp':
            self.timestamp = value
        elif name == 'availabilityZone':
            self.availability_zone = value
        else:
            setattr(self, name, value)


</source>
<source file="systems/boto-2.13.2/boto/resultset.py" startline="155" endline="169" pcid="3105">
    def endElement(self, name, value, connection):
        if name == 'return':
            self.status = self.to_boolean(value)
        elif name == 'StatusCode':
            self.status = self.to_boolean(value, 'Success')
        elif name == 'IsValid':
            self.status = self.to_boolean(value, 'True')
        elif name == 'RequestId':
            self.request_id = value
        elif name == 'requestId':
            self.request_id = value
        elif name == 'BoxUsage':
            self.request_id = value
        else:
            setattr(self, name, value)
</source>
<source file="systems/boto-2.13.2/boto/cloudfront/origin.py" startline="124" endline="141" pcid="1516">
    def endElement(self, name, value, connection):
        if name == 'DNSName':
            self.dns_name = value
        elif name == 'HTTPPort':
            try:
                self.http_port = int(value)
            except ValueError:
                self.http_port = value
        elif name == 'HTTPSPort':
            try:
                self.https_port = int(value)
            except ValueError:
                self.https_port = value
        elif name == 'OriginProtocolPolicy':
            self.origin_protocol_policy = value
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/sdb/domain.py" startline="296" endline="313" pcid="2575">
    def endElement(self, name, value, connection):
        if name == 'ItemCount':
            self.item_count = int(value)
        elif name == 'ItemNamesSizeBytes':
            self.item_names_size = int(value)
        elif name == 'AttributeNameCount':
            self.attr_name_count = int(value)
        elif name == 'AttributeNamesSizeBytes':
            self.attr_names_size = int(value)
        elif name == 'AttributeValueCount':
            self.attr_value_count = int(value)
        elif name == 'AttributeValuesSizeBytes':
            self.attr_values_size = int(value)
        elif name == 'Timestamp':
            self.timestamp = value
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/s3/multipart.py" startline="61" endline="73" pcid="3469">
    def endElement(self, name, value, connection):
        if name == 'Location':
            self.location = value
        elif name == 'Bucket':
            self.bucket_name = value
        elif name == 'Key':
            self.key_name = value
        elif name == 'ETag':
            self.etag = value
        else:
            setattr(self, name, value)


</source>
<source file="systems/boto-2.13.2/boto/s3/multidelete.py" startline="97" endline="108" pcid="3493">
    def endElement(self, name, value, connection):
        if name == 'Key':
            self.key = value
        elif name == 'VersionId':
            self.version_id = value
        elif name == 'Code':
            self.code = value
        elif name == 'Message':
            self.message = value
        else:
            setattr(self, name, value)
            
</source>
<source file="systems/boto-2.13.2/boto/ec2/instancestatus.py" startline="69" endline="81" pcid="80">
    def endElement(self, name, value, connection):
        if name == 'code':
            self.code = value
        elif name == 'description':
            self.description = value
        elif name == 'notBefore':
            self.not_before = value
        elif name == 'notAfter':
            self.not_after = value
        else:
            setattr(self, name, value)


</source>
<source file="systems/boto-2.13.2/boto/ec2/elb/instancestate.py" startline="52" endline="62" pcid="713">
    def endElement(self, name, value, connection):
        if name == 'Description':
            self.description = value
        elif name == 'State':
            self.state = value
        elif name == 'InstanceId':
            self.instance_id = value
        elif name == 'ReasonCode':
            self.reason_code = value
        else:
            setattr(self, name, value)
</source>
<source file="systems/boto-2.13.2/boto/ec2/volumestatus.py" startline="105" endline="117" pcid="250">
    def endElement(self, name, value, connection):
        if name == 'eventType':
            self.type = value
        elif name == 'eventId':
            self.id = value
        elif name == 'description':
            self.description = value
        elif name == 'code':
            self.code = value
        else:
            setattr(self, name, value)


</source>
<source file="systems/boto-2.13.2/boto/sts/credentials.py" startline="80" endline="93" pcid="1742">
    def endElement(self, name, value, connection):
        if name == 'AccessKeyId':
            self.access_key = value
        elif name == 'SecretAccessKey':
            self.secret_key = value
        elif name == 'SessionToken':
            self.session_token = value
        elif name == 'Expiration':
            self.expiration = value
        elif name == 'RequestId':
            self.request_id = value
        else:
            pass

</source>
<source file="systems/boto-2.13.2/boto/rds/event.py" startline="38" endline="49" pcid="2237">
    def endElement(self, name, value, connection):
        if name == 'SourceIdentifier':
            self.source_identifier = value
        elif name == 'SourceType':
            self.source_type = value
        elif name == 'Message':
            self.message = value
        elif name == 'Date':
            self.date = value
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/cloudfront/distribution.py" startline="308" endline="321" pcid="1487">
    def endElement(self, name, value, connection):
        if name == 'Id':
            self.id = value
        elif name == 'LastModifiedTime':
            self.last_modified_time = value
        elif name == 'Status':
            self.status = value
        elif name == 'InProgressInvalidationBatches':
            self.in_progress_invalidation_batches = int(value)
        elif name == 'DomainName':
            self.domain_name = value
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/ec2/tag.py" startline="74" endline="84" pcid="462">
    def endElement(self, name, value, connection):
        if name == 'resourceId':
            self.res_id = value
        elif name == 'resourceType':
            self.res_type = value
        elif name == 'key':
            self.name = value
        elif name == 'value':
            self.value = value
        else:
            setattr(self, name, value)
</source>
<source file="systems/boto-2.13.2/boto/ec2/vmtype.py" startline="49" endline="59" pcid="455">
    def endElement(self, name, value, connection):
        if name == 'euca:name':
            self.name = value
        elif name == 'euca:cpu':
            self.cores = value
        elif name == 'euca:disk':
            self.disk = value
        elif name == 'euca:memory':
            self.memory = value
        else:
            setattr(self, name, value)
</source>
<source file="systems/boto-2.13.2/boto/ec2/spotdatafeedsubscription.py" startline="49" endline="60" pcid="451">
    def endElement(self, name, value, connection):
        if name == 'ownerId':
            self.owner_id = value
        elif name == 'bucket':
            self.bucket = value
        elif name == 'prefix':
            self.prefix = value
        elif name == 'state':
            self.state = value
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/vpc/vpngateway.py" startline="67" endline="80" pcid="3174">
    def endElement(self, name, value, connection):
        if name == 'vpnGatewayId':
            self.id = value
        elif name == 'type':
            self.type = value
        elif name == 'state':
            self.state = value
        elif name == 'availabilityZone':
            self.availability_zone = value
        elif name == 'attachments':
            pass
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/s3/multidelete.py" startline="55" endline="67" pcid="3489">
    def endElement(self, name, value, connection):
        if name == 'Key':
            self.key = value
        elif name == 'VersionId':
            self.version_id = value
        elif name == 'DeleteMarker':
            if value.lower() == 'true':
                self.delete_marker = True
        elif name == 'DeleteMarkerVersionId':
            self.delete_marker_version_id = value
        else:
            setattr(self, name, value)
            
</source>
<source file="systems/boto-2.13.2/boto/cloudsearch/optionstatus.py" startline="92" endline="105" pcid="2351">
    def endElement(self, name, value, connection):
        if name == 'CreationDate':
            self.created = value
        elif name == 'State':
            self.state = value
        elif name == 'UpdateDate':
            self.updated = value
        elif name == 'UpdateVersion':
            self.update_version = int(value)
        elif name == 'Options':
            self.update_from_json_doc(value)
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/rds/dbsubnetgroup.py" startline="56" endline="69" pcid="2271">
    def endElement(self, name, value, connection):
        if name == 'SubnetIdentifier':
            self.subnet_ids.append(value)
        elif name == 'DBSubnetGroupName':
            self.name = value
        elif name == 'DBSubnetGroupDescription':
            self.description = value
        elif name == 'VpcId':
            self.vpc_id = value
        elif name == 'SubnetGroupStatus':
            self.status = value
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/ec2/autoscale/tag.py" startline="53" endline="67" pcid="174">
    def endElement(self, name, value, connection):
        if name == 'Key':
            self.key = value
        elif name == 'Value':
            self.value = value
        elif name == 'PropogateAtLaunch':
            if value.lower() == 'true':
                self.propogate_at_launch = True
            else:
                self.propogate_at_launch = False
        elif name == 'ResourceId':
            self.resource_id = value
        elif name == 'ResourceType':
            self.resource_type = value

</source>
<source file="systems/boto-2.13.2/boto/rds/statusinfo.py" startline="41" endline="54" pcid="2233">
    def endElement(self, name, value, connection):
        if name == 'StatusType':
            self.status_type = value
        elif name == 'Normal':
            if value.lower() == 'true':
                self.normal = True
            else:
                self.normal = False
        elif name == 'Status':
            self.status = value
        elif name == 'Message':
            self.message = value
        else:
            setattr(self, name, value)
</source>
<source file="systems/boto-2.13.2/boto/rds/dbsecuritygroup.py" startline="70" endline="81" pcid="2298">
    def endElement(self, name, value, connection):
        if name == 'OwnerId':
            self.owner_id = value
        elif name == 'DBSecurityGroupName':
            self.name = value
        elif name == 'DBSecurityGroupDescription':
            self.description = value
        elif name == 'IPRanges':
            pass
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/ec2/reservedinstance.py" startline="284" endline="296" pcid="71">
    def endElement(self, name, value, connection):
        if name == 'reservedInstancesModificationId':
            self.modification_id = value
        elif name == 'availabilityZone':
            self.availability_zone = value
        elif name == 'platform':
            self.platform = value
        elif name == 'instanceCount':
            self.instance_count = int(value)
        else:
            setattr(self, name, value)


</source>
<source file="systems/boto-2.13.2/boto/ec2/instancestatus.py" startline="170" endline="182" pcid="90">
    def endElement(self, name, value, connection):
        if name == 'instanceId':
            self.id = value
        elif name == 'availabilityZone':
            self.zone = value
        elif name == 'code':
            self.state_code = int(value)
        elif name == 'name':
            self.state_name = value
        else:
            setattr(self, name, value)


</source>
<source file="systems/boto-2.13.2/boto/cloudformation/template.py" startline="33" endline="43" pcid="985">
    def endElement(self, name, value, connection):
        if name == "DefaultValue":
            self.default_value = value
        elif name == "Description":
            self.description = value
        elif name == "NoEcho":
            self.no_echo = bool(value)
        elif name == "ParameterKey":
            self.parameter_key = value
        else:
            setattr(self, name, value)
</source>
<source file="systems/boto-2.13.2/boto/s3/cors.py" startline="86" endline="101" pcid="3265">
    def endElement(self, name, value, connection):
        if name == 'ID':
            self.id = value
        elif name == 'AllowedMethod':
            self.allowed_method.append(value)
        elif name == 'AllowedOrigin':
            self.allowed_origin.append(value)
        elif name == 'AllowedHeader':
            self.allowed_header.append(value)
        elif name == 'MaxAgeSeconds':
            self.max_age_seconds = int(value)
        elif name == 'ExposeHeader':
            self.expose_header.append(value)
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/cloudfront/invalidation.py" startline="92" endline="105" pcid="1572">
    def endElement(self, name, value, connection):
        if name == 'Path':
            self.paths.append(value)
        elif name == "Status":
            self.status = value
        elif name == "Id":
            self.id = value
        elif name == "CreateTime":
            self.create_time = value
        elif name == "CallerReference":
            self.caller_reference = value
        return None


</source>
<source file="systems/boto-2.13.2/boto/sqs/message.py" startline="96" endline="107" pcid="3632">
    def endElement(self, name, value, connection):
        if name == 'Body':
            self.set_body(self.decode(value))
        elif name == 'MessageId':
            self.id = value
        elif name == 'ReceiptHandle':
            self.receipt_handle = value
        elif name == 'MD5OfMessageBody':
            self.md5 = value
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/ec2/securitygroup.py" startline="379" endline="389" pcid="526">
    def endElement(self, name, value, connection):
        if name == 'userId':
            self.owner_id = value
        elif name == 'groupId':
            self.group_id = value
        elif name == 'groupName':
            self.name = value
        if name == 'cidrIp':
            self.cidr_ip = value
        else:
            setattr(self, name, value)
</source>
<source file="systems/boto-2.13.2/boto/s3/multipart.py" startline="101" endline="113" pcid="3473">
    def endElement(self, name, value, connection):
        if name == 'PartNumber':
            self.part_number = int(value)
        elif name == 'LastModified':
            self.last_modified = value
        elif name == 'ETag':
            self.etag = value
        elif name == 'Size':
            self.size = int(value)
        else:
            setattr(self, name, value)


</source>
<source file="systems/boto-2.13.2/boto/ec2/reservedinstance.py" startline="222" endline="234" pcid="62">
    def endElement(self, name, value, connection):
        if name == 'term':
            self.term = int(value)
        elif name == 'price':
            self.price = value
        elif name == 'currencyCode':
            self.currency_code = value
        elif name == 'active':
            self.active = True if value == 'true' else False
        else:
            setattr(self, name, value)


</source>
<source file="systems/boto-2.13.2/boto/ec2/elb/healthcheck.py" startline="56" endline="69" pcid="649">
    def endElement(self, name, value, connection):
        if name == 'Interval':
            self.interval = int(value)
        elif name == 'Target':
            self.target = value
        elif name == 'HealthyThreshold':
            self.healthy_threshold = int(value)
        elif name == 'Timeout':
            self.timeout = int(value)
        elif name == 'UnhealthyThreshold':
            self.unhealthy_threshold = int(value)
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/sts/credentials.py" startline="167" endline="179" pcid="1748">
    def endElement(self, name, value, connection):
        if name == 'Arn':
            self.federated_user_arn = value
        elif name == 'FederatedUserId':
            self.federated_user_id = value
        elif name == 'PackedPolicySize':
            self.packed_policy_size = int(value)
        elif name == 'RequestId':
            self.request_id = value
        else:
            pass


</source>
<source file="systems/boto-2.13.2/boto/exception.py" startline="120" endline="130" pcid="1047">
    def endElement(self, name, value, connection):
        if name in ('RequestId', 'RequestID'):
            self.request_id = value
        elif name == 'Code':
            self.error_code = value
        elif name == 'Message':
            self.message = value
        elif name == 'BoxUsage':
            self.box_usage = value
        return None

</source>
<source file="systems/boto-2.13.2/boto/ec2/reservedinstance.py" startline="141" endline="153" pcid="53">
    def endElement(self, name, value, connection):
        if name == 'reservedInstancesId':
            self.id = value
        if name == 'instanceCount':
            self.instance_count = int(value)
        elif name == 'state':
            self.state = value
        elif name == 'start':
            self.start = value
        else:
            ReservedInstancesOffering.endElement(self, name, value, connection)


</source>
</class>

<class classid="9" nclones="15" nlines="12" similarity="70">
<source file="systems/boto-2.13.2/boto/ec2/instancestatus.py" startline="159" endline="169" pcid="89">
    def startElement(self, name, attrs, connection):
        if name == 'eventsSet':
            self.events = EventSet()
            return self.events
        elif name == 'systemStatus':
            return self.system_status
        elif name == 'instanceStatus':
            return self.instance_status
        else:
            return None

</source>
<source file="systems/boto-2.13.2/boto/cloudfront/distribution.py" startline="237" endline="248" pcid="1481">
    def startElement(self, name, attrs, connection):
        if name == 'TrustedSigners':
            self.trusted_signers = TrustedSigners()
            return self.trusted_signers
        elif name == 'S3Origin':
            self.origin = S3Origin()
            return self.origin
        elif name == 'CustomOrigin':
            self.origin = CustomOrigin()
            return self.origin
        return None

</source>
<source file="systems/boto-2.13.2/boto/ec2/image.py" startline="77" endline="90" pcid="628">
    def startElement(self, name, attrs, connection):
        retval = TaggedEC2Object.startElement(self, name, attrs, connection)
        if retval is not None:
            return retval
        if name == 'blockDeviceMapping':
            self.block_device_mapping = BlockDeviceMapping()
            return self.block_device_mapping
        elif name == 'productCodes':
            return self.product_codes
        elif name == 'billingProducts':
            return self.billing_products
        else:
            return None

</source>
<source file="systems/boto-2.13.2/boto/ec2/autoscale/launchconfig.py" startline="170" endline="180" pcid="140">
    def startElement(self, name, attrs, connection):
        if name == 'SecurityGroups':
            return self.security_groups
        elif name == 'BlockDeviceMappings':
            self.block_device_mappings = ResultSet([('member',
                                                     BlockDeviceMapping)])
            return self.block_device_mappings
        elif name == 'InstanceMonitoring':
            self.instance_monitoring = InstanceMonitoring(self)
            return self.instance_monitoring

</source>
<source file="systems/boto-2.13.2/boto/ec2/volumestatus.py" startline="155" endline="166" pcid="255">
    def startElement(self, name, attrs, connection):
        if name == 'eventsSet':
            self.events = EventSet()
            return self.events
        elif name == 'actionsSet':
            self.actions = ActionSet()
            return self.actions
        elif name == 'volumeStatus':
            return self.volume_status
        else:
            return None

</source>
<source file="systems/boto-2.13.2/boto/ec2/securitygroup.py" startline="46" endline="56" pcid="507">
    def startElement(self, name, attrs, connection):
        retval = TaggedEC2Object.startElement(self, name, attrs, connection)
        if retval is not None:
            return retval
        if name == 'ipPermissions':
            return self.rules
        elif name == 'ipPermissionsEgress':
            return self.rules_egress
        else:
            return None

</source>
<source file="systems/boto-2.13.2/boto/emr/emrobject.py" startline="165" endline="176" pcid="2039">
    def startElement(self, name, attrs, connection):
        if name == 'Steps':
            self.steps = ResultSet([('member', Step)])
            return self.steps
        elif name == 'InstanceGroups':
            self.instancegroups = ResultSet([('member', InstanceGroup)])
            return self.instancegroups
        elif name == 'BootstrapActions':
            self.bootstrapactions = ResultSet([('member', BootstrapAction)])
            return self.bootstrapactions
        else:
            return None
</source>
<source file="systems/boto-2.13.2/boto/cloudfront/distribution.py" startline="141" endline="156" pcid="1476">
    def startElement(self, name, attrs, connection):
        if name == 'TrustedSigners':
            self.trusted_signers = TrustedSigners()
            return self.trusted_signers
        elif name == 'Logging':
            self.logging = LoggingInfo()
            return self.logging
        elif name == 'S3Origin':
            self.origin = S3Origin()
            return self.origin
        elif name == 'CustomOrigin':
            self.origin = CustomOrigin()
            return self.origin
        else:
            return None

</source>
<source file="systems/boto-2.13.2/boto/vpc/vpnconnection.py" startline="169" endline="183" pcid="3143">
    def startElement(self, name, attrs, connection):
        retval = super(VpnConnection, self).startElement(name, attrs, connection)
        if retval is not None:
            return retval
        if name == 'vgwTelemetry':
            self.tunnels = ResultSet([('item', VpnTunnel)])
            return self.tunnels
        elif name == 'routes':
            self.static_routes = ResultSet([('item', VpnStaticRoute)])
            return self.static_routes
        elif name == 'options':
            self.options = VpnConnectionOptions()
            return self.options
        return None

</source>
<source file="systems/boto-2.13.2/boto/ec2/volume.py" startline="64" endline="76" pcid="481">
    def startElement(self, name, attrs, connection):
        retval = TaggedEC2Object.startElement(self, name, attrs, connection)
        if retval is not None:
            return retval
        if name == 'attachmentSet':
            self.attach_data = AttachmentSet()
            return self.attach_data
        elif name == 'tagSet':
            self.tags = ResultSet([('item', Tag)])
            return self.tags
        else:
            return None

</source>
<source file="systems/boto-2.13.2/boto/ec2/networkinterface.py" startline="121" endline="136" pcid="469">
    def startElement(self, name, attrs, connection):
        retval = TaggedEC2Object.startElement(self, name, attrs, connection)
        if retval is not None:
            return retval
        if name == 'groupSet':
            self.groups = ResultSet([('item', Group)])
            return self.groups
        elif name == 'attachment':
            self.attachment = Attachment()
            return self.attachment
        elif name == 'privateIpAddressesSet':
            self.private_ip_addresses = ResultSet([('item', PrivateIPAddress)])
            return self.private_ip_addresses
        else:
            return None

</source>
<source file="systems/boto-2.13.2/boto/ec2/spotinstancerequest.py" startline="143" endline="158" pcid="238">
    def startElement(self, name, attrs, connection):
        retval = TaggedEC2Object.startElement(self, name, attrs, connection)
        if retval is not None:
            return retval
        if name == 'launchSpecification':
            self.launch_specification = LaunchSpecification(connection)
            return self.launch_specification
        elif name == 'fault':
            self.fault = SpotInstanceStateFault()
            return self.fault
        elif name == 'status':
            self.status = SpotInstanceStatus()
            return self.status
        else:
            return None

</source>
<source file="systems/boto-2.13.2/boto/ec2/launchspecification.py" startline="65" endline="79" pcid="373">
    def startElement(self, name, attrs, connection):
        if name == 'groupSet':
            self.groups = ResultSet([('item', Group)])
            return self.groups
        elif name == 'monitoring':
            self._in_monitoring_element = True
        elif name == 'blockDeviceMapping':
            self.block_device_mapping = BlockDeviceMapping()
            return self.block_device_mapping
        elif name == 'iamInstanceProfile':
            self.instance_profile = SubParse('iamInstanceProfile')
            return self.instance_profile
        else:
            return None

</source>
<source file="systems/boto-2.13.2/boto/vpc/routetable.py" startline="41" endline="56" pcid="3113">
    def startElement(self, name, attrs, connection):
        result = super(RouteTable, self).startElement(name, attrs, connection)

        if result is not None:
            # Parent found an interested element, just return it
            return result

        if name == 'routeSet':
            self.routes = ResultSet([('item', Route)])
            return self.routes
        elif name == 'associationSet':
            self.associations = ResultSet([('item', RouteAssociation)])
            return self.associations
        else:
            return None

</source>
<source file="systems/boto-2.13.2/boto/ec2/cloudwatch/alarm.py" startline="166" endline="181" pcid="397">
    def startElement(self, name, attrs, connection):
        if name == 'AlarmActions':
            self.alarm_actions = ListElement()
            return self.alarm_actions
        elif name == 'InsufficientDataActions':
            self.insufficient_data_actions = ListElement()
            return self.insufficient_data_actions
        elif name == 'OKActions':
            self.ok_actions = ListElement()
            return self.ok_actions
        elif name == 'Dimensions':
            self.dimensions = Dimension()
            return self.dimensions
        else:
            pass

</source>
</class>

<class classid="10" nclones="2" nlines="20" similarity="71">
<source file="systems/boto-2.13.2/boto/ec2/autoscale/group.py" startline="201" endline="222" pcid="112">
    def startElement(self, name, attrs, connection):
        if name == 'Instances':
            self.instances = ResultSet([('member', Instance)])
            return self.instances
        elif name == 'LoadBalancerNames':
            return self.load_balancers
        elif name == 'AvailabilityZones':
            return self.availability_zones
        elif name == 'EnabledMetrics':
            self.enabled_metrics = ResultSet([('member', EnabledMetric)])
            return self.enabled_metrics
        elif name == 'SuspendedProcesses':
            self.suspended_processes = ResultSet([('member', SuspendedProcess)])
            return self.suspended_processes
        elif name == 'Tags':
            self.tags = ResultSet([('member', Tag)])
            return self.tags
        elif name == 'TerminationPolicies':
            return self.termination_policies
        else:
            return

</source>
<source file="systems/boto-2.13.2/boto/cloudformation/stack.py" startline="23" endline="41" pcid="921">
    def startElement(self, name, attrs, connection):
        if name == "Parameters":
            self.parameters = ResultSet([('member', Parameter)])
            return self.parameters
        elif name == "Outputs":
            self.outputs = ResultSet([('member', Output)])
            return self.outputs
        elif name == "Capabilities":
            self.capabilities = ResultSet([('member', Capability)])
            return self.capabilities
        elif name == "Tags":
            self.tags = Tag()
            return self.tags
        elif name == 'NotificationARNs':
            self.notification_arns = ResultSet([('member', NotificationARN)])
            return self.notification_arns
        else:
            return None

</source>
</class>

<class classid="11" nclones="13" nlines="18" similarity="70">
<source file="systems/boto-2.13.2/boto/ec2/autoscale/__init__.py" startline="101" endline="125" pcid="191">
    def __init__(self, aws_access_key_id=None, aws_secret_access_key=None,
                 is_secure=True, port=None, proxy=None, proxy_port=None,
                 proxy_user=None, proxy_pass=None, debug=0,
                 https_connection_factory=None, region=None, path='/',
                 security_token=None, validate_certs=True):
        """
        Init method to create a new connection to the AutoScaling service.

        B{Note:} The host argument is overridden by the host specified in the
                 boto configuration file.
        """
        if not region:
            region = RegionInfo(self, self.DefaultRegionName,
                                self.DefaultRegionEndpoint,
                                AutoScaleConnection)
        self.region = region
        AWSQueryConnection.__init__(self, aws_access_key_id,
                                    aws_secret_access_key,
                                    is_secure, port, proxy, proxy_port,
                                    proxy_user, proxy_pass,
                                    self.region.endpoint, debug,
                                    https_connection_factory, path=path,
                                    security_token=security_token,
                                    validate_certs=validate_certs)

</source>
<source file="systems/boto-2.13.2/boto/ec2/cloudwatch/__init__.py" startline="89" endline="118" pcid="416">
    def __init__(self, aws_access_key_id=None, aws_secret_access_key=None,
                 is_secure=True, port=None, proxy=None, proxy_port=None,
                 proxy_user=None, proxy_pass=None, debug=0,
                 https_connection_factory=None, region=None, path='/',
                 security_token=None, validate_certs=True):
        """
        Init method to create a new connection to EC2 Monitoring Service.

        B{Note:} The host argument is overridden by the host specified in the
        boto configuration file.
        """
        if not region:
            region = RegionInfo(self, self.DefaultRegionName,
                                self.DefaultRegionEndpoint)
        self.region = region

        # Ugly hack to get around both a bug in Python and a
        # misconfigured SSL cert for the eu-west-1 endpoint
        if self.region.name == 'eu-west-1':
            validate_certs = False

        AWSQueryConnection.__init__(self, aws_access_key_id,
                                    aws_secret_access_key,
                                    is_secure, port, proxy, proxy_port,
                                    proxy_user, proxy_pass,
                                    self.region.endpoint, debug,
                                    https_connection_factory, path,
                                    security_token,
                                    validate_certs=validate_certs)

</source>
<source file="systems/boto-2.13.2/boto/sqs/connection.py" startline="42" endline="61" pcid="3656">
    def __init__(self, aws_access_key_id=None, aws_secret_access_key=None,
                 is_secure=True, port=None, proxy=None, proxy_port=None,
                 proxy_user=None, proxy_pass=None, debug=0,
                 https_connection_factory=None, region=None, path='/',
                 security_token=None, validate_certs=True):
        if not region:
            region = SQSRegionInfo(self, self.DefaultRegionName,
                                   self.DefaultRegionEndpoint)
        self.region = region
        AWSQueryConnection.__init__(self, aws_access_key_id,
                                    aws_secret_access_key,
                                    is_secure, port,
                                    proxy, proxy_port,
                                    proxy_user, proxy_pass,
                                    self.region.endpoint, debug,
                                    https_connection_factory, path,
                                    security_token=security_token,
                                    validate_certs=validate_certs)
        self.auth_region_name = self.region.name

</source>
<source file="systems/boto-2.13.2/boto/sns/connection.py" startline="55" endline="73" pcid="1088">
    def __init__(self, aws_access_key_id=None, aws_secret_access_key=None,
                 is_secure=True, port=None, proxy=None, proxy_port=None,
                 proxy_user=None, proxy_pass=None, debug=0,
                 https_connection_factory=None, region=None, path='/',
                 security_token=None, validate_certs=True):
        if not region:
            region = RegionInfo(self, self.DefaultRegionName,
                                self.DefaultRegionEndpoint,
                                connection_cls=SNSConnection)
        self.region = region
        AWSQueryConnection.__init__(self, aws_access_key_id,
                                    aws_secret_access_key,
                                    is_secure, port, proxy, proxy_port,
                                    proxy_user, proxy_pass,
                                    self.region.endpoint, debug,
                                    https_connection_factory, path,
                                    security_token=security_token,
                                    validate_certs=validate_certs)

</source>
<source file="systems/boto-2.13.2/boto/sts/connection.py" startline="68" endline="87" pcid="1729">
    def __init__(self, aws_access_key_id=None, aws_secret_access_key=None,
                 is_secure=True, port=None, proxy=None, proxy_port=None,
                 proxy_user=None, proxy_pass=None, debug=0,
                 https_connection_factory=None, region=None, path='/',
                 converter=None, validate_certs=True, anon=False):
        if not region:
            region = RegionInfo(self, self.DefaultRegionName,
                                self.DefaultRegionEndpoint,
                                connection_cls=STSConnection)
        self.region = region
        self.anon = anon
        self._mutex = threading.Semaphore()
        AWSQueryConnection.__init__(self, aws_access_key_id,
                                    aws_secret_access_key,
                                    is_secure, port, proxy, proxy_port,
                                    proxy_user, proxy_pass,
                                    self.region.endpoint, debug,
                                    https_connection_factory, path,
                                    validate_certs=validate_certs)

</source>
<source file="systems/boto-2.13.2/boto/rds/__init__.py" startline="91" endline="108" pcid="2312">
    def __init__(self, aws_access_key_id=None, aws_secret_access_key=None,
                 is_secure=True, port=None, proxy=None, proxy_port=None,
                 proxy_user=None, proxy_pass=None, debug=0,
                 https_connection_factory=None, region=None, path='/',
                 security_token=None, validate_certs=True):
        if not region:
            region = RDSRegionInfo(self, self.DefaultRegionName,
                                   self.DefaultRegionEndpoint)
        self.region = region
        AWSQueryConnection.__init__(self, aws_access_key_id,
                                    aws_secret_access_key,
                                    is_secure, port, proxy, proxy_port,
                                    proxy_user, proxy_pass,
                                    self.region.endpoint, debug,
                                    https_connection_factory, path,
                                    security_token,
                                    validate_certs=validate_certs)

</source>
<source file="systems/boto-2.13.2/boto/ec2/elb/__init__.py" startline="90" endline="113" pcid="718">
    def __init__(self, aws_access_key_id=None, aws_secret_access_key=None,
                 is_secure=True, port=None, proxy=None, proxy_port=None,
                 proxy_user=None, proxy_pass=None, debug=0,
                 https_connection_factory=None, region=None, path='/',
                 security_token=None, validate_certs=True):
        """
        Init method to create a new connection to EC2 Load Balancing Service.

        .. note:: The region argument is overridden by the region specified in
            the boto configuration file.
        """
        if not region:
            region = RegionInfo(self, self.DefaultRegionName,
                                self.DefaultRegionEndpoint)
        self.region = region
        AWSQueryConnection.__init__(self, aws_access_key_id,
                                    aws_secret_access_key,
                                    is_secure, port, proxy, proxy_port,
                                    proxy_user, proxy_pass,
                                    self.region.endpoint, debug,
                                    https_connection_factory, path,
                                    security_token,
                                    validate_certs=validate_certs)

</source>
<source file="systems/boto-2.13.2/boto/cloudformation/connection.py" startline="51" endline="68" pcid="964">
    def __init__(self, aws_access_key_id=None, aws_secret_access_key=None,
                 is_secure=True, port=None, proxy=None, proxy_port=None,
                 proxy_user=None, proxy_pass=None, debug=0,
                 https_connection_factory=None, region=None, path='/',
                 converter=None, security_token=None, validate_certs=True):
        if not region:
            region = RegionInfo(self, self.DefaultRegionName,
                self.DefaultRegionEndpoint, CloudFormationConnection)
        self.region = region
        AWSQueryConnection.__init__(self, aws_access_key_id,
                                    aws_secret_access_key,
                                    is_secure, port, proxy, proxy_port,
                                    proxy_user, proxy_pass,
                                    self.region.endpoint, debug,
                                    https_connection_factory, path,
                                    security_token,
                                    validate_certs=validate_certs)

</source>
<source file="systems/boto-2.13.2/boto/emr/connection.py" startline="51" endline="68" pcid="2007">
    def __init__(self, aws_access_key_id=None, aws_secret_access_key=None,
                 is_secure=True, port=None, proxy=None, proxy_port=None,
                 proxy_user=None, proxy_pass=None, debug=0,
                 https_connection_factory=None, region=None, path='/',
                 security_token=None, validate_certs=True):
        if not region:
            region = RegionInfo(self, self.DefaultRegionName,
                                self.DefaultRegionEndpoint)
        self.region = region
        AWSQueryConnection.__init__(self, aws_access_key_id,
                                    aws_secret_access_key,
                                    is_secure, port, proxy, proxy_port,
                                    proxy_user, proxy_pass,
                                    self.region.endpoint, debug,
                                    https_connection_factory, path,
                                    security_token,
                                    validate_certs=validate_certs)

</source>
<source file="systems/boto-2.13.2/boto/ec2/connection.py" startline="78" endline="102" pcid="260">
    def __init__(self, aws_access_key_id=None, aws_secret_access_key=None,
                 is_secure=True, host=None, port=None,
                 proxy=None, proxy_port=None,
                 proxy_user=None, proxy_pass=None, debug=0,
                 https_connection_factory=None, region=None, path='/',
                 api_version=None, security_token=None,
                 validate_certs=True):
        """
        Init method to create a new connection to EC2.
        """
        if not region:
            region = RegionInfo(self, self.DefaultRegionName,
                                self.DefaultRegionEndpoint)
        self.region = region
        AWSQueryConnection.__init__(self, aws_access_key_id,
                                    aws_secret_access_key,
                                    is_secure, port, proxy, proxy_port,
                                    proxy_user, proxy_pass,
                                    self.region.endpoint, debug,
                                    https_connection_factory, path,
                                    security_token,
                                    validate_certs=validate_certs)
        if api_version:
            self.APIVersion = api_version

</source>
<source file="systems/boto-2.13.2/boto/beanstalk/layer1.py" startline="38" endline="55" pcid="814">
    def __init__(self, aws_access_key_id=None, aws_secret_access_key=None,
                 is_secure=True, port=None,
                 proxy=None, proxy_port=None,
                 proxy_user=None, proxy_pass=None, debug=0,
                 https_connection_factory=None, region=None, path='/',
                 api_version=None, security_token=None):
        if not region:
            region = RegionInfo(self, self.DefaultRegionName,
                                self.DefaultRegionEndpoint)
        self.region = region
        AWSQueryConnection.__init__(self, aws_access_key_id,
                                    aws_secret_access_key,
                                    is_secure, port, proxy, proxy_port,
                                    proxy_user, proxy_pass,
                                    self.region.endpoint, debug,
                                    https_connection_factory, path,
                                    security_token)

</source>
<source file="systems/boto-2.13.2/boto/ses/connection.py" startline="41" endline="57" pcid="2059">
    def __init__(self, aws_access_key_id=None, aws_secret_access_key=None,
                 is_secure=True, port=None, proxy=None, proxy_port=None,
                 proxy_user=None, proxy_pass=None, debug=0,
                 https_connection_factory=None, region=None, path='/',
                 security_token=None, validate_certs=True):
        if not region:
            region = RegionInfo(self, self.DefaultRegionName,
                                self.DefaultRegionEndpoint)
        self.region = region
        AWSAuthConnection.__init__(self, self.region.endpoint,
                                   aws_access_key_id, aws_secret_access_key,
                                   is_secure, port, proxy, proxy_port,
                                   proxy_user, proxy_pass, debug,
                                   https_connection_factory, path,
                                   security_token=security_token,
                                   validate_certs=validate_certs)

</source>
<source file="systems/boto-2.13.2/tests/unit/test_connection.py" startline="77" endline="93" pcid="4986">
    def __init__(self, aws_access_key_id=None, aws_secret_access_key=None,
                 is_secure=True, host=None, port=None,
                 proxy=None, proxy_port=None,
                 proxy_user=None, proxy_pass=None, debug=0,
                 https_connection_factory=None, region=None, path='/',
                 api_version=None, security_token=None,
                 validate_certs=True):
        self.region = region
        AWSQueryConnection.__init__(self, aws_access_key_id,
                                    aws_secret_access_key,
                                    is_secure, port, proxy, proxy_port,
                                    proxy_user, proxy_pass,
                                    self.region.endpoint, debug,
                                    https_connection_factory, path,
                                    security_token,
                                    validate_certs=validate_certs)

</source>
</class>

<class classid="12" nclones="33" nlines="11" similarity="70">
<source file="systems/boto-2.13.2/boto/ec2/autoscale/__init__.py" startline="278" endline="308" pcid="200">

    def get_all_groups(self, names=None, max_records=None, next_token=None):
        """
        Returns a full description of each Auto Scaling group in the given
        list. This includes all Amazon EC2 instances that are members of the
        group. If a list of names is not provided, the service returns the full
        details of all Auto Scaling groups.

        This action supports pagination by returning a token if there are more
        pages to retrieve. To get the next page, call this action again with
        the returned token as the NextToken parameter.

        :type names: list
        :param names: List of group names which should be searched for.

        :type max_records: int
        :param max_records: Maximum amount of groups to return.

        :rtype: list
        :returns: List of :class:`boto.ec2.autoscale.group.AutoScalingGroup`
            instances.
        """
        params = {}
        if max_records:
            params['MaxRecords'] = max_records
        if next_token:
            params['NextToken'] = next_token
        if names:
            self.build_list_params(params, names, 'AutoScalingGroupNames')
        return self.get_list('DescribeAutoScalingGroups', params,
                             [('member', AutoScalingGroup)])
</source>
<source file="systems/boto-2.13.2/boto/iam/connection.py" startline="82" endline="109" pcid="1590">
    def get_all_groups(self, path_prefix='/', marker=None, max_items=None):
        """
        List the groups that have the specified path prefix.

        :type path_prefix: string
        :param path_prefix: If provided, only groups whose paths match
            the provided prefix will be returned.

        :type marker: string
        :param marker: Use this only when paginating results and only
            in follow-up request after you've received a response
            where the results are truncated.  Set this to the value of
            the Marker element in the response you just received.

        :type max_items: int
        :param max_items: Use this only when paginating results to indicate
            the maximum number of groups you want in the response.
        """
        params = {}
        if path_prefix:
            params['PathPrefix'] = path_prefix
        if marker:
            params['Marker'] = marker
        if max_items:
            params['MaxItems'] = max_items
        return self.get_response('ListGroups', params,
                                 list_marker='Groups')

</source>
<source file="systems/boto-2.13.2/boto/rds/__init__.py" startline="699" endline="729" pcid="2320">
    def get_all_dbparameter_groups(self, groupname=None, max_records=None,
                                  marker=None):
        """
        Get all parameter groups associated with your account in a region.

        :type groupname: str
        :param groupname: The name of the DBParameter group to retrieve.
                          If not provided, all DBParameter groups will be returned.

        :type max_records: int
        :param max_records: The maximum number of records to be returned.
                            If more results are available, a MoreToken will
                            be returned in the response that can be used to
                            retrieve additional records.  Default is 100.

        :type marker: str
        :param marker: The marker provided by a previous request.

        :rtype: list
        :return: A list of :class:`boto.ec2.parametergroup.ParameterGroup`
        """
        params = {}
        if groupname:
            params['DBParameterGroupName'] = groupname
        if max_records:
            params['MaxRecords'] = max_records
        if marker:
            params['Marker'] = marker
        return self.get_list('DescribeDBParameterGroups', params,
                             [('DBParameterGroup', ParameterGroup)])

</source>
<source file="systems/boto-2.13.2/boto/rds/__init__.py" startline="842" endline="873" pcid="2326">
    def get_all_dbsecurity_groups(self, groupname=None, max_records=None,
                                  marker=None):
        """
        Get all security groups associated with your account in a region.

        :type groupnames: list
        :param groupnames: A list of the names of security groups to retrieve.
                           If not provided, all security groups will
                           be returned.

        :type max_records: int
        :param max_records: The maximum number of records to be returned.
                            If more results are available, a MoreToken will
                            be returned in the response that can be used to
                            retrieve additional records.  Default is 100.

        :type marker: str
        :param marker: The marker provided by a previous request.

        :rtype: list
        :return: A list of :class:`boto.rds.dbsecuritygroup.DBSecurityGroup`
        """
        params = {}
        if groupname:
            params['DBSecurityGroupName'] = groupname
        if max_records:
            params['MaxRecords'] = max_records
        if marker:
            params['Marker'] = marker
        return self.get_list('DescribeDBSecurityGroups', params,
                             [('DBSecurityGroup', DBSecurityGroup)])

</source>
<source file="systems/boto-2.13.2/boto/rds/__init__.py" startline="114" endline="146" pcid="2314">
    def get_all_dbinstances(self, instance_id=None, max_records=None,
                            marker=None):
        """
        Retrieve all the DBInstances in your account.

        :type instance_id: str
        :param instance_id: DB Instance identifier.  If supplied, only
                            information this instance will be returned.
                            Otherwise, info about all DB Instances will
                            be returned.

        :type max_records: int
        :param max_records: The maximum number of records to be returned.
                            If more results are available, a MoreToken will
                            be returned in the response that can be used to
                            retrieve additional records.  Default is 100.

        :type marker: str
        :param marker: The marker provided by a previous request.

        :rtype: list
        :return: A list of :class:`boto.rds.dbinstance.DBInstance`
        """
        params = {}
        if instance_id:
            params['DBInstanceIdentifier'] = instance_id
        if max_records:
            params['MaxRecords'] = max_records
        if marker:
            params['Marker'] = marker
        return self.get_list('DescribeDBInstances', params,
                             [('DBInstance', DBInstance)])

</source>
<source file="systems/boto-2.13.2/boto/sts/connection.py" startline="106" endline="117" pcid="1732">
    def _get_session_token(self, duration=None,
                           mfa_serial_number=None, mfa_token=None):
        params = {}
        if duration:
            params['DurationSeconds'] = duration
        if mfa_serial_number:
            params['SerialNumber'] = mfa_serial_number
        if mfa_token:
            params['TokenCode'] = mfa_token
        return self.get_object('GetSessionToken', params,
                                Credentials, verb='POST')

</source>
<source file="systems/boto-2.13.2/boto/rds/__init__.py" startline="989" endline="1027" pcid="2331">
    def get_all_dbsnapshots(self, snapshot_id=None, instance_id=None,
                            max_records=None, marker=None):
        """
        Get information about DB Snapshots.

        :type snapshot_id: str
        :param snapshot_id: The unique identifier of an RDS snapshot.
                            If not provided, all RDS snapshots will be returned.

        :type instance_id: str
        :param instance_id: The identifier of a DBInstance.  If provided,
                            only the DBSnapshots related to that instance will
                            be returned.
                            If not provided, all RDS snapshots will be returned.

        :type max_records: int
        :param max_records: The maximum number of records to be returned.
                            If more results are available, a MoreToken will
                            be returned in the response that can be used to
                            retrieve additional records.  Default is 100.

        :type marker: str
        :param marker: The marker provided by a previous request.

        :rtype: list
        :return: A list of :class:`boto.rds.dbsnapshot.DBSnapshot`
        """
        params = {}
        if snapshot_id:
            params['DBSnapshotIdentifier'] = snapshot_id
        if instance_id:
            params['DBInstanceIdentifier'] = instance_id
        if max_records:
            params['MaxRecords'] = max_records
        if marker:
            params['Marker'] = marker
        return self.get_list('DescribeDBSnapshots', params,
                             [('DBSnapshot', DBSnapshot)])

</source>
<source file="systems/boto-2.13.2/boto/ec2/autoscale/__init__.py" startline="483" endline="515" pcid="210">

    def get_all_policies(self, as_group=None, policy_names=None,
                         max_records=None, next_token=None):
        """
        Returns descriptions of what each policy does. This action supports
        pagination. If the response includes a token, there are more records
        available. To get the additional records, repeat the request with the
        response token as the NextToken parameter.

        If no group name or list of policy names are provided, all
        available policies are returned.

        :type as_name: str
        :param as_name: The name of the
            :class:`boto.ec2.autoscale.group.AutoScalingGroup` to filter for.

        :type names: list
        :param names: List of policy names which should be searched for.

        :type max_records: int
        :param max_records: Maximum amount of groups to return.
        """
        params = {}
        if as_group:
            params['AutoScalingGroupName'] = as_group
        if policy_names:
            self.build_list_params(params, policy_names, 'PolicyNames')
        if max_records:
            params['MaxRecords'] = max_records
        if next_token:
            params['NextToken'] = next_token
        return self.get_list('DescribePolicies', params,
                             [('member', ScalingPolicy)])
</source>
<source file="systems/boto-2.13.2/boto/iam/connection.py" startline="577" endline="608" pcid="1615">
    def get_all_signing_certs(self, marker=None, max_items=None,
                              user_name=None):
        """
        Get all signing certificates associated with an account.

        If the user_name is not specified, it is determined implicitly based
        on the AWS Access Key ID used to sign the request.

        :type marker: string
        :param marker: Use this only when paginating results and only
            in follow-up request after you've received a response
            where the results are truncated.  Set this to the value of
            the Marker element in the response you just received.

        :type max_items: int
        :param max_items: Use this only when paginating results to indicate
            the maximum number of groups you want in the response.

        :type user_name: string
        :param user_name: The username of the user

        """
        params = {}
        if marker:
            params['Marker'] = marker
        if max_items:
            params['MaxItems'] = max_items
        if user_name:
            params['UserName'] = user_name
        return self.get_response('ListSigningCertificates',
                                 params, list_marker='Certificates')

</source>
<source file="systems/boto-2.13.2/boto/beanstalk/layer1.py" startline="895" endline="932" pcid="841">
    def terminate_environment(self, environment_id=None, environment_name=None,
                              terminate_resources=None):
        """Terminates the specified environment.

        :type environment_id: string
        :param environment_id: The ID of the environment to terminate.
            Condition: You must specify either this or an EnvironmentName, or
            both.  If you do not specify either, AWS Elastic Beanstalk returns
            MissingRequiredParameter error.

        :type environment_name: string
        :param environment_name: The name of the environment to terminate.
            Condition: You must specify either this or an EnvironmentId, or
            both.  If you do not specify either, AWS Elastic Beanstalk returns
            MissingRequiredParameter error.

        :type terminate_resources: boolean
        :param terminate_resources: Indicates whether the associated AWS
            resources should shut down when the environment is terminated:
            true: (default) The user AWS resources (for example, the Auto
            Scaling group, LoadBalancer, etc.) are terminated along with the
            environment.  false: The environment is removed from the AWS
            Elastic Beanstalk but the AWS resources continue to operate.  For
            more information, see the  AWS Elastic Beanstalk User Guide.
            Default: true  Valid Values: true | false

        :raises: InsufficientPrivilegesException
        """
        params = {}
        if environment_id:
            params['EnvironmentId'] = environment_id
        if environment_name:
            params['EnvironmentName'] = environment_name
        if terminate_resources:
            params['TerminateResources'] = self._encode_bool(
                terminate_resources)
        return self._get_response('TerminateEnvironment', params)

</source>
<source file="systems/boto-2.13.2/boto/vpc/__init__.py" startline="626" endline="663" pcid="3198">
    def get_all_vpn_gateways(self, vpn_gateway_ids=None, filters=None,
                             dry_run=False):
        """
        Retrieve information about your VpnGateways.  You can filter results to
        return information only about those VpnGateways that match your search
        parameters.  Otherwise, all VpnGateways associated with your account
        are returned.

        :type vpn_gateway_ids: list
        :param vpn_gateway_ids: A list of strings with the desired VpnGateway ID's

        :type filters: list of tuples
        :param filters: A list of tuples containing filters.  Each tuple
                        consists of a filter key and a filter value.
                        Possible filter keys are:

                        - *state*, a list of states of the VpnGateway
                          (pending,available,deleting,deleted)
                        - *type*, a list types of customer gateway (ipsec.1)
                        - *availabilityZone*, a list of  Availability zones the
                          VPN gateway is in.

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: list
        :return: A list of :class:`boto.vpc.customergateway.VpnGateway`
        """
        params = {}
        if vpn_gateway_ids:
            self.build_list_params(params, vpn_gateway_ids, 'VpnGatewayId')
        if filters:
            self.build_filter_params(params, dict(filters))
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_list('DescribeVpnGateways', params,
                             [('item', VpnGateway)])

</source>
<source file="systems/boto-2.13.2/boto/vpc/__init__.py" startline="197" endline="228" pcid="3182">
    def get_all_route_tables(self, route_table_ids=None, filters=None,
                             dry_run=False):
        """
        Retrieve information about your routing tables. You can filter results
        to return information only about those route tables that match your
        search parameters. Otherwise, all route tables associated with your
        account are returned.

        :type route_table_ids: list
        :param route_table_ids: A list of strings with the desired route table
                                IDs.

        :type filters: list of tuples
        :param filters: A list of tuples containing filters. Each tuple
                        consists of a filter key and a filter value.

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: list
        :return: A list of :class:`boto.vpc.routetable.RouteTable`
        """
        params = {}
        if route_table_ids:
            self.build_list_params(params, route_table_ids, "RouteTableId")
        if filters:
            self.build_filter_params(params, dict(filters))
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_list('DescribeRouteTables', params,
                             [('item', RouteTable)])

</source>
<source file="systems/boto-2.13.2/boto/cloudformation/connection.py" startline="306" endline="318" pcid="973">
    def describe_stack_resources(self, stack_name_or_id=None,
            logical_resource_id=None,
            physical_resource_id=None):
        params = {}
        if stack_name_or_id:
            params['StackName'] = stack_name_or_id
        if logical_resource_id:
            params['LogicalResourceId'] = logical_resource_id
        if physical_resource_id:
            params['PhysicalResourceId'] = physical_resource_id
        return self.get_list('DescribeStackResources', params,
                             [('member', StackResource)])

</source>
<source file="systems/boto-2.13.2/boto/rds/__init__.py" startline="946" endline="984" pcid="2330">
    def revoke_dbsecurity_group(self, group_name, ec2_security_group_name=None,
                                ec2_security_group_owner_id=None, cidr_ip=None):
        """
        Remove an existing rule from an existing security group.
        You need to pass in either ec2_security_group_name and
        ec2_security_group_owner_id OR a CIDR block.

        :type group_name: string
        :param group_name: The name of the security group you are removing
                           the rule from.

        :type ec2_security_group_name: string
        :param ec2_security_group_name: The name of the EC2 security group
                                        from which you are removing access.

        :type ec2_security_group_owner_id: string
        :param ec2_security_group_owner_id: The ID of the owner of the EC2
                                            security from which you are
                                            removing access.

        :type cidr_ip: string
        :param cidr_ip: The CIDR block from which you are removing access.
                        See http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing

        :rtype: bool
        :return: True if successful.
        """
        params = {'DBSecurityGroupName': group_name}
        if ec2_security_group_name:
            params['EC2SecurityGroupName'] = ec2_security_group_name
        if ec2_security_group_owner_id:
            params['EC2SecurityGroupOwnerId'] = ec2_security_group_owner_id
        if cidr_ip:
            params['CIDRIP'] = cidr_ip
        return self.get_object('RevokeDBSecurityGroupIngress', params,
                               DBSecurityGroup)

    # For backwards compatibility.  This method was improperly named
    # in previous versions.  I have renamed it to match the others.
</source>
<source file="systems/boto-2.13.2/boto/ec2/autoscale/__init__.py" startline="443" endline="474" pcid="208">

    def get_all_autoscaling_instances(self, instance_ids=None,
                                      max_records=None, next_token=None):
        """
        Returns a description of each Auto Scaling instance in the instance_ids
        list. If a list is not provided, the service returns the full details
        of all instances up to a maximum of fifty.

        This action supports pagination by returning a token if there are more
        pages to retrieve. To get the next page, call this action again with
        the returned token as the NextToken parameter.

        :type instance_ids: list
        :param instance_ids: List of Autoscaling Instance IDs which should be
            searched for.

        :type max_records: int
        :param max_records: Maximum number of results to return.

        :rtype: list
        :returns: List of
            :class:`boto.ec2.autoscale.instance.Instance` objects.
        """
        params = {}
        if instance_ids:
            self.build_list_params(params, instance_ids, 'InstanceIds')
        if max_records:
            params['MaxRecords'] = max_records
        if next_token:
            params['NextToken'] = next_token
        return self.get_list('DescribeAutoScalingInstances',
                             params, [('member', Instance)])
</source>
<source file="systems/boto-2.13.2/boto/ec2/cloudwatch/__init__.py" startline="256" endline="297" pcid="423">

    def list_metrics(self, next_token=None, dimensions=None,
                     metric_name=None, namespace=None):
        """
        Returns a list of the valid metrics for which there is recorded
        data available.

        :type next_token: str
        :param next_token: A maximum of 500 metrics will be returned
            at one time.  If more results are available, the ResultSet
            returned will contain a non-Null next_token attribute.
            Passing that token as a parameter to list_metrics will
            retrieve the next page of metrics.

        :type dimensions: dict
        :param dimensions: A dictionary containing name/value
            pairs that will be used to filter the results.  The key in
            the dictionary is the name of a Dimension.  The value in
            the dictionary is either a scalar value of that Dimension
            name that you want to filter on, a list of values to
            filter on or None if you want all metrics with that
            Dimension name.

        :type metric_name: str
        :param metric_name: The name of the Metric to filter against.  If None,
            all Metric names will be returned.

        :type namespace: str
        :param namespace: A Metric namespace to filter against (e.g. AWS/EC2).
            If None, Metrics from all namespaces will be returned.
        """
        params = {}
        if next_token:
            params['NextToken'] = next_token
        if dimensions:
            self.build_dimension_param(dimensions, params)
        if metric_name:
            params['MetricName'] = metric_name
        if namespace:
            params['Namespace'] = namespace

        return self.get_list('ListMetrics', params, [('member', Metric)])
</source>
<source file="systems/boto-2.13.2/boto/ec2/autoscale/__init__.py" startline="615" endline="630" pcid="215">

    def get_all_scheduled_actions(self, as_group=None, start_time=None,
                                  end_time=None, scheduled_actions=None,
                                  max_records=None, next_token=None):
        params = {}
        if as_group:
            params['AutoScalingGroupName'] = as_group
        if scheduled_actions:
            self.build_list_params(params, scheduled_actions,
                                   'ScheduledActionNames')
        if max_records:
            params['MaxRecords'] = max_records
        if next_token:
            params['NextToken'] = next_token
        return self.get_list('DescribeScheduledActions', params,
                             [('member', ScheduledUpdateGroupAction)])
</source>
<source file="systems/boto-2.13.2/boto/ec2/connection.py" startline="3753" endline="3786" pcid="349">
                               BundleInstanceTask, verb='POST')

    def get_all_bundle_tasks(self, bundle_ids=None, filters=None,
                             dry_run=False):
        """
        Retrieve current bundling tasks. If no bundle id is specified, all
        tasks are retrieved.

        :type bundle_ids: list
        :param bundle_ids: A list of strings containing identifiers for
                           previously created bundling tasks.

        :type filters: dict
        :param filters: Optional filters that can be used to limit
                        the results returned.  Filters are provided
                        in the form of a dictionary consisting of
                        filter names as the key and filter values
                        as the value.  The set of allowable filter
                        names/values is dependent on the request
                        being performed.  Check the EC2 API guide
                        for details.

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        """
        params = {}
        if bundle_ids:
            self.build_list_params(params, bundle_ids, 'BundleId')
        if filters:
            self.build_filter_params(params, filters)
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_list('DescribeBundleTasks', params,
</source>
<source file="systems/boto-2.13.2/boto/vpc/__init__.py" startline="953" endline="993" pcid="3210">
    def get_all_vpn_connections(self, vpn_connection_ids=None, filters=None,
                                dry_run=False):
        """
        Retrieve information about your VPN_CONNECTIONs.  You can filter results to
        return information only about those VPN_CONNECTIONs that match your search
        parameters.  Otherwise, all VPN_CONNECTIONs associated with your account
        are returned.

        :type vpn_connection_ids: list
        :param vpn_connection_ids: A list of strings with the desired VPN_CONNECTION ID's

        :type filters: list of tuples
        :param filters: A list of tuples containing filters.  Each tuple
                        consists of a filter key and a filter value.
                        Possible filter keys are:

                        - *state*, a list of states of the VPN_CONNECTION
                          pending,available,deleting,deleted
                        - *type*, a list of types of connection, currently 'ipsec.1'
                        - *customerGatewayId*, a list of IDs of the customer gateway
                          associated with the VPN
                        - *vpnGatewayId*, a list of IDs of the VPN gateway associated
                          with the VPN connection

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: list
        :return: A list of :class:`boto.vpn_connection.vpnconnection.VpnConnection`
        """
        params = {}
        if vpn_connection_ids:
            self.build_list_params(params, vpn_connection_ids,
                                   'Vpn_ConnectionId')
        if filters:
            self.build_filter_params(params, dict(filters))
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_list('DescribeVpnConnections', params,
                             [('item', VpnConnection)])

</source>
<source file="systems/boto-2.13.2/boto/ec2/connection.py" startline="3826" endline="3861" pcid="352">
    #

    def get_all_placement_groups(self, groupnames=None, filters=None,
                                 dry_run=False):
        """
        Get all placement groups associated with your account in a region.

        :type groupnames: list
        :param groupnames: A list of the names of placement groups to retrieve.
                           If not provided, all placement groups will be
                           returned.

        :type filters: dict
        :param filters: Optional filters that can be used to limit
                        the results returned.  Filters are provided
                        in the form of a dictionary consisting of
                        filter names as the key and filter values
                        as the value.  The set of allowable filter
                        names/values is dependent on the request
                        being performed.  Check the EC2 API guide
                        for details.

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: list
        :return: A list of :class:`boto.ec2.placementgroup.PlacementGroup`
        """
        params = {}
        if groupnames:
            self.build_list_params(params, groupnames, 'GroupName')
        if filters:
            self.build_filter_params(params, filters)
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_list('DescribePlacementGroups', params,
</source>
<source file="systems/boto-2.13.2/boto/beanstalk/layer1.py" startline="850" endline="894" pcid="840">
    def swap_environment_cnames(self, source_environment_id=None,
                                 source_environment_name=None,
                                 destination_environment_id=None,
                                 destination_environment_name=None):
        """Swaps the CNAMEs of two environments.

        :type source_environment_id: string
        :param source_environment_id: The ID of the source environment.
            Condition: You must specify at least the SourceEnvironmentID or the
            SourceEnvironmentName. You may also specify both. If you specify
            the SourceEnvironmentId, you must specify the
            DestinationEnvironmentId.

        :type source_environment_name: string
        :param source_environment_name: The name of the source environment.
            Condition: You must specify at least the SourceEnvironmentID or the
            SourceEnvironmentName. You may also specify both. If you specify
            the SourceEnvironmentName, you must specify the
            DestinationEnvironmentName.

        :type destination_environment_id: string
        :param destination_environment_id: The ID of the destination
            environment.  Condition: You must specify at least the
            DestinationEnvironmentID or the DestinationEnvironmentName. You may
            also specify both. You must specify the SourceEnvironmentId with
            the DestinationEnvironmentId.

        :type destination_environment_name: string
        :param destination_environment_name: The name of the destination
            environment.  Condition: You must specify at least the
            DestinationEnvironmentID or the DestinationEnvironmentName. You may
            also specify both. You must specify the SourceEnvironmentName with
            the DestinationEnvironmentName.
        """
        params = {}
        if source_environment_id:
            params['SourceEnvironmentId'] = source_environment_id
        if source_environment_name:
            params['SourceEnvironmentName'] = source_environment_name
        if destination_environment_id:
            params['DestinationEnvironmentId'] = destination_environment_id
        if destination_environment_name:
            params['DestinationEnvironmentName'] = destination_environment_name
        return self._get_response('SwapEnvironmentCNAMEs', params)

</source>
<source file="systems/boto-2.13.2/boto/rds/__init__.py" startline="908" endline="945" pcid="2329">
    def authorize_dbsecurity_group(self, group_name, cidr_ip=None,
                                   ec2_security_group_name=None,
                                   ec2_security_group_owner_id=None):
        """
        Add a new rule to an existing security group.
        You need to pass in either src_security_group_name and
        src_security_group_owner_id OR a CIDR block but not both.

        :type group_name: string
        :param group_name: The name of the security group you are adding
                           the rule to.

        :type ec2_security_group_name: string
        :param ec2_security_group_name: The name of the EC2 security group
                                        you are granting access to.

        :type ec2_security_group_owner_id: string
        :param ec2_security_group_owner_id: The ID of the owner of the EC2
                                            security group you are granting
                                            access to.

        :type cidr_ip: string
        :param cidr_ip: The CIDR block you are providing access to.
                        See http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing

        :rtype: bool
        :return: True if successful.
        """
        params = {'DBSecurityGroupName': group_name}
        if ec2_security_group_name:
            params['EC2SecurityGroupName'] = ec2_security_group_name
        if ec2_security_group_owner_id:
            params['EC2SecurityGroupOwnerId'] = ec2_security_group_owner_id
        if cidr_ip:
            params['CIDRIP'] = urllib.quote(cidr_ip)
        return self.get_object('AuthorizeDBSecurityGroupIngress', params,
                               DBSecurityGroup)

</source>
<source file="systems/boto-2.13.2/boto/rds/__init__.py" startline="730" endline="765" pcid="2321">
    def get_all_dbparameters(self, groupname, source=None,
                             max_records=None, marker=None):
        """
        Get all parameters associated with a ParameterGroup

        :type groupname: str
        :param groupname: The name of the DBParameter group to retrieve.

        :type source: str
        :param source: Specifies which parameters to return.
                       If not specified, all parameters will be returned.
                       Valid values are: user|system|engine-default

        :type max_records: int
        :param max_records: The maximum number of records to be returned.
                            If more results are available, a MoreToken will
                            be returned in the response that can be used to
                            retrieve additional records.  Default is 100.

        :type marker: str
        :param marker: The marker provided by a previous request.

        :rtype: :class:`boto.ec2.parametergroup.ParameterGroup`
        :return: The ParameterGroup
        """
        params = {'DBParameterGroupName': groupname}
        if source:
            params['Source'] = source
        if max_records:
            params['MaxRecords'] = max_records
        if marker:
            params['Marker'] = marker
        pg = self.get_object('DescribeDBParameters', params, ParameterGroup)
        pg.name = groupname
        return pg

</source>
<source file="systems/boto-2.13.2/boto/ec2/connection.py" startline="184" endline="212" pcid="265">
    def get_all_kernels(self, kernel_ids=None, owners=None, dry_run=False):
        """
        Retrieve all the EC2 kernels available on your account.
        Constructs a filter to allow the processing to happen server side.

        :type kernel_ids: list
        :param kernel_ids: A list of strings with the image IDs wanted

        :type owners: list
        :param owners: A list of owner IDs

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: list
        :return: A list of :class:`boto.ec2.image.Image`
        """
        params = {}
        if kernel_ids:
            self.build_list_params(params, kernel_ids, 'ImageId')
        if owners:
            self.build_list_params(params, owners, 'Owner')
        filter = {'image-type': 'kernel'}
        self.build_filter_params(params, filter)
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_list('DescribeImages', params,
                             [('item', Image)], verb='POST')

</source>
<source file="systems/boto-2.13.2/boto/ec2/connection.py" startline="1569" endline="1605" pcid="296">
    def get_all_zones(self, zones=None, filters=None, dry_run=False):
        """
        Get all Availability Zones associated with the current region.

        :type zones: list
        :param zones: Optional list of zones.  If this list is present,
                      only the Zones associated with these zone names
                      will be returned.

        :type filters: dict
        :param filters: Optional filters that can be used to limit
                        the results returned.  Filters are provided
                        in the form of a dictionary consisting of
                        filter names as the key and filter values
                        as the value.  The set of allowable filter
                        names/values is dependent on the request
                        being performed.  Check the EC2 API guide
                        for details.

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: list of :class:`boto.ec2.zone.Zone`
        :return: The requested Zone objects
        """
        params = {}
        if zones:
            self.build_list_params(params, zones, 'ZoneName')
        if filters:
            self.build_filter_params(params, filters)
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_list('DescribeAvailabilityZones', params,
                             [('item', Zone)], verb='POST')

    # Address methods

</source>
<source file="systems/boto-2.13.2/boto/ec2/connection.py" startline="2561" endline="2592" pcid="321">

    def get_all_key_pairs(self, keynames=None, filters=None, dry_run=False):
        """
        Get all key pairs associated with your account.

        :type keynames: list
        :param keynames: A list of the names of keypairs to retrieve.
            If not provided, all key pairs will be returned.

        :type filters: dict
        :param filters: Optional filters that can be used to limit the
            results returned.  Filters are provided in the form of a
            dictionary consisting of filter names as the key and
            filter values as the value.  The set of allowable filter
            names/values is dependent on the request being performed.
            Check the EC2 API guide for details.

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: list
        :return: A list of :class:`boto.ec2.keypair.KeyPair`
        """
        params = {}
        if keynames:
            self.build_list_params(params, keynames, 'KeyName')
        if filters:
            self.build_filter_params(params, filters)
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_list('DescribeKeyPairs', params,
                             [('item', KeyPair)], verb='POST')
</source>
<source file="systems/boto-2.13.2/boto/ec2/connection.py" startline="1893" endline="1927" pcid="304">

    def get_all_volumes(self, volume_ids=None, filters=None, dry_run=False):
        """
        Get all Volumes associated with the current credentials.

        :type volume_ids: list
        :param volume_ids: Optional list of volume ids.  If this list
                           is present, only the volumes associated with
                           these volume ids will be returned.

        :type filters: dict
        :param filters: Optional filters that can be used to limit
                        the results returned.  Filters are provided
                        in the form of a dictionary consisting of
                        filter names as the key and filter values
                        as the value.  The set of allowable filter
                        names/values is dependent on the request
                        being performed.  Check the EC2 API guide
                        for details.

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: list of :class:`boto.ec2.volume.Volume`
        :return: The requested Volume objects
        """
        params = {}
        if volume_ids:
            self.build_list_params(params, volume_ids, 'VolumeId')
        if filters:
            self.build_filter_params(params, filters)
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_list('DescribeVolumes', params,
                             [('item', Volume)], verb='POST')
</source>
<source file="systems/boto-2.13.2/boto/ec2/connection.py" startline="213" endline="241" pcid="266">
    def get_all_ramdisks(self, ramdisk_ids=None, owners=None, dry_run=False):
        """
        Retrieve all the EC2 ramdisks available on your account.
        Constructs a filter to allow the processing to happen server side.

        :type ramdisk_ids: list
        :param ramdisk_ids: A list of strings with the image IDs wanted

        :type owners: list
        :param owners: A list of owner IDs

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: list
        :return: A list of :class:`boto.ec2.image.Image`
        """
        params = {}
        if ramdisk_ids:
            self.build_list_params(params, ramdisk_ids, 'ImageId')
        if owners:
            self.build_list_params(params, owners, 'Owner')
        filter = {'image-type': 'ramdisk'}
        self.build_filter_params(params, filter)
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_list('DescribeImages', params,
                             [('item', Image)], verb='POST')

</source>
<source file="systems/boto-2.13.2/boto/vpc/__init__.py" startline="422" endline="450" pcid="3190">
    def get_all_internet_gateways(self, internet_gateway_ids=None,
                                  filters=None, dry_run=False):
        """
        Get a list of internet gateways. You can filter results to return information
        about only those gateways that you're interested in.

        :type internet_gateway_ids: list
        :param internet_gateway_ids: A list of strings with the desired gateway IDs.

        :type filters: list of tuples
        :param filters: A list of tuples containing filters.  Each tuple
                        consists of a filter key and a filter value.

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        """
        params = {}

        if internet_gateway_ids:
            self.build_list_params(params, internet_gateway_ids,
                                   'InternetGatewayId')
        if filters:
            self.build_filter_params(params, dict(filters))
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_list('DescribeInternetGateways', params,
                             [('item', InternetGateway)])

</source>
<source file="systems/boto-2.13.2/boto/vpc/__init__.py" startline="536" endline="577" pcid="3195">
    def get_all_customer_gateways(self, customer_gateway_ids=None,
                                  filters=None, dry_run=False):
        """
        Retrieve information about your CustomerGateways.  You can filter
        results to return information only about those CustomerGateways that
        match your search parameters.  Otherwise, all CustomerGateways
        associated with your account are returned.

        :type customer_gateway_ids: list
        :param customer_gateway_ids: A list of strings with the desired
            CustomerGateway ID's.

        :type filters: list of tuples
        :param filters: A list of tuples containing filters.  Each tuple
                        consists of a filter key and a filter value.
                        Possible filter keys are:

                         - *state*, the state of the CustomerGateway
                           (pending,available,deleting,deleted)
                         - *type*, the type of customer gateway (ipsec.1)
                         - *ipAddress* the IP address of customer gateway's
                           internet-routable external inteface

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: list
        :return: A list of :class:`boto.vpc.customergateway.CustomerGateway`
        """
        params = {}
        if customer_gateway_ids:
            self.build_list_params(params, customer_gateway_ids,
                                   'CustomerGatewayId')
        if filters:
            self.build_filter_params(params, dict(filters))

        if dry_run:
            params['DryRun'] = 'true'

        return self.get_list('DescribeCustomerGateways', params,
                             [('item', CustomerGateway)])

</source>
<source file="systems/boto-2.13.2/boto/beanstalk/layer1.py" startline="480" endline="527" pcid="830">
    def describe_configuration_options(self, application_name=None,
                                       template_name=None,
                                       environment_name=None,
                                       solution_stack_name=None, options=None):
        """Describes configuration options used in a template or environment.

        Describes the configuration options that are used in a
        particular configuration template or environment, or that a
        specified solution stack defines. The description includes the
        values the options, their default values, and an indication of
        the required action on a running environment if an option value
        is changed.

        :type application_name: string
        :param application_name: The name of the application associated with
            the configuration template or environment. Only needed if you want
            to describe the configuration options associated with either the
            configuration template or environment.

        :type template_name: string
        :param template_name: The name of the configuration template whose
            configuration options you want to describe.

        :type environment_name: string
        :param environment_name: The name of the environment whose
            configuration options you want to describe.

        :type solution_stack_name: string
        :param solution_stack_name: The name of the solution stack whose
            configuration options you want to describe.

        :type options: list
        :param options: If specified, restricts the descriptions to only
            the specified options.
        """
        params = {}
        if application_name:
            params['ApplicationName'] = application_name
        if template_name:
            params['TemplateName'] = template_name
        if environment_name:
            params['EnvironmentName'] = environment_name
        if solution_stack_name:
            params['SolutionStackName'] = solution_stack_name
        if options:
            self.build_list_params(params, options, 'Options.member')
        return self._get_response('DescribeConfigurationOptions', params)

</source>
<source file="systems/boto-2.13.2/boto/ec2/connection.py" startline="890" endline="915" pcid="280">
    def stop_instances(self, instance_ids=None, force=False, dry_run=False):
        """
        Stop the instances specified

        :type instance_ids: list
        :param instance_ids: A list of strings of the Instance IDs to stop

        :type force: bool
        :param force: Forces the instance to stop

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: list
        :return: A list of the instances stopped
        """
        params = {}
        if force:
            params['Force'] = 'true'
        if instance_ids:
            self.build_list_params(params, instance_ids, 'InstanceId')
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_list('StopInstances', params,
                             [('item', Instance)], verb='POST')

</source>
<source file="systems/boto-2.13.2/boto/ec2/connection.py" startline="3378" endline="3412" pcid="337">
                             verb='POST')

    def get_all_reserved_instances(self, reserved_instances_id=None,
                                   filters=None, dry_run=False):
        """
        Describes one or more of the Reserved Instances that you purchased.

        :type reserved_instance_ids: list
        :param reserved_instance_ids: A list of the reserved instance ids that
            will be returned. If not provided, all reserved instances
            will be returned.

        :type filters: dict
        :param filters: Optional filters that can be used to limit the
            results returned.  Filters are provided in the form of a
            dictionary consisting of filter names as the key and
            filter values as the value.  The set of allowable filter
            names/values is dependent on the request being performed.
            Check the EC2 API guide for details.

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: list
        :return: A list of :class:`boto.ec2.reservedinstance.ReservedInstance`
        """
        params = {}
        if reserved_instances_id:
            self.build_list_params(params, reserved_instances_id,
                                   'ReservedInstancesId')
        if filters:
            self.build_filter_params(params, filters)
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_list('DescribeReservedInstances',
</source>
</class>

<class classid="13" nclones="2" nlines="15" similarity="73">
<source file="systems/boto-2.13.2/boto/ec2/connection.py" startline="428" endline="471" pcid="272">
    def modify_image_attribute(self, image_id, attribute='launchPermission',
                               operation='add', user_ids=None, groups=None,
                               product_codes=None, dry_run=False):
        """
        Changes an attribute of an image.

        :type image_id: string
        :param image_id: The image id you wish to change

        :type attribute: string
        :param attribute: The attribute you wish to change

        :type operation: string
        :param operation: Either add or remove (this is required for changing
            launchPermissions)

        :type user_ids: list
        :param user_ids: The Amazon IDs of users to add/remove attributes

        :type groups: list
        :param groups: The groups to add/remove attributes

        :type product_codes: list
        :param product_codes: Amazon DevPay product code. Currently only one
            product code can be associated with an AMI. Once
            set, the product code cannot be changed or reset.

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        """
        params = {'ImageId': image_id,
                  'Attribute': attribute,
                  'OperationType': operation}
        if user_ids:
            self.build_list_params(params, user_ids, 'UserId')
        if groups:
            self.build_list_params(params, groups, 'UserGroup')
        if product_codes:
            self.build_list_params(params, product_codes, 'ProductCode')
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_status('ModifyImageAttribute', params, verb='POST')

</source>
<source file="systems/boto-2.13.2/boto/ec2/connection.py" startline="2495" endline="2534" pcid="319">

    def modify_snapshot_attribute(self, snapshot_id,
                                  attribute='createVolumePermission',
                                  operation='add', user_ids=None, groups=None,
                                  dry_run=False):
        """
        Changes an attribute of an image.

        :type snapshot_id: string
        :param snapshot_id: The snapshot id you wish to change

        :type attribute: string
        :param attribute: The attribute you wish to change.  Valid values are:
            createVolumePermission

        :type operation: string
        :param operation: Either add or remove (this is required for changing
            snapshot ermissions)

        :type user_ids: list
        :param user_ids: The Amazon IDs of users to add/remove attributes

        :type groups: list
        :param groups: The groups to add/remove attributes.  The only valid
            value at this time is 'all'.

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        """
        params = {'SnapshotId': snapshot_id,
                  'Attribute': attribute,
                  'OperationType': operation}
        if user_ids:
            self.build_list_params(params, user_ids, 'UserId')
        if groups:
            self.build_list_params(params, groups, 'UserGroup')
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_status('ModifySnapshotAttribute', params, verb='POST')
</source>
</class>

<class classid="14" nclones="2" nlines="17" similarity="88">
<source file="systems/boto-2.13.2/boto/ec2/connection.py" startline="562" endline="601" pcid="276">
    def get_all_reservations(self, instance_ids=None, filters=None,
                             dry_run=False):
        """
        Retrieve all the instance reservations associated with your account.

        :type instance_ids: list
        :param instance_ids: A list of strings of instance IDs

        :type filters: dict
        :param filters: Optional filters that can be used to limit the
            results returned.  Filters are provided in the form of a
            dictionary consisting of filter names as the key and
            filter values as the value.  The set of allowable filter
            names/values is dependent on the request being performed.
            Check the EC2 API guide for details.

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: list
        :return: A list of  :class:`boto.ec2.instance.Reservation`
        """
        params = {}
        if instance_ids:
            self.build_list_params(params, instance_ids, 'InstanceId')
        if filters:
            if 'group-id' in filters:
                gid = filters.get('group-id')
                if not gid.startswith('sg-') or len(gid) != 11:
                    warnings.warn(
                        "The group-id filter now requires a security group "
                        "identifier (sg-*) instead of a group name. To filter "
                        "by group name use the 'group-name' filter instead.",
                        UserWarning)
            self.build_filter_params(params, filters)
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_list('DescribeInstances', params,
                             [('item', Reservation)], verb='POST')

</source>
<source file="systems/boto-2.13.2/boto/ec2/connection.py" startline="1193" endline="1233" pcid="289">
    def get_all_spot_instance_requests(self, request_ids=None,
                                       filters=None, dry_run=False):
        """
        Retrieve all the spot instances requests associated with your account.

        :type request_ids: list
        :param request_ids: A list of strings of spot instance request IDs

        :type filters: dict
        :param filters: Optional filters that can be used to limit the
            results returned.  Filters are provided in the form of a
            dictionary consisting of filter names as the key and
            filter values as the value.  The set of allowable filter
            names/values is dependent on the request being performed.
            Check the EC2 API guide for details.

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: list
        :return: A list of
                 :class:`boto.ec2.spotinstancerequest.SpotInstanceRequest`
        """
        params = {}
        if request_ids:
            self.build_list_params(params, request_ids, 'SpotInstanceRequestId')
        if filters:
            if 'launch.group-id' in filters:
                lgid = filters.get('launch.group-id')
                if not lgid.startswith('sg-') or len(lgid) != 11:
                    warnings.warn(
                        "The 'launch.group-id' filter now requires a security "
                        "group id (sg-*) and no longer supports filtering by "
                        "group name. Please update your filters accordingly.",
                        UserWarning)
            self.build_filter_params(params, filters)
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_list('DescribeSpotInstanceRequests', params,
                             [('item', SpotInstanceRequest)], verb='POST')

</source>
</class>

<class classid="15" nclones="4" nlines="16" similarity="72">
<source file="systems/boto-2.13.2/boto/ec2/connection.py" startline="602" endline="648" pcid="277">
    def get_all_instance_status(self, instance_ids=None,
                                max_results=None, next_token=None,
                                filters=None, dry_run=False):
        """
        Retrieve all the instances in your account scheduled for maintenance.

        :type instance_ids: list
        :param instance_ids: A list of strings of instance IDs

        :type max_results: int
        :param max_results: The maximum number of paginated instance
            items per response.

        :type next_token: str
        :param next_token: A string specifying the next paginated set
            of results to return.

        :type filters: dict
        :param filters: Optional filters that can be used to limit
            the results returned.  Filters are provided
            in the form of a dictionary consisting of
            filter names as the key and filter values
            as the value.  The set of allowable filter
            names/values is dependent on the request
            being performed.  Check the EC2 API guide
            for details.

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: list
        :return: A list of instances that have maintenance scheduled.
        """
        params = {}
        if instance_ids:
            self.build_list_params(params, instance_ids, 'InstanceId')
        if max_results:
            params['MaxResults'] = max_results
        if next_token:
            params['NextToken'] = next_token
        if filters:
            self.build_filter_params(params, filters)
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_object('DescribeInstanceStatus', params,
                               InstanceStatusSet, verb='POST')

</source>
<source file="systems/boto-2.13.2/boto/ec2/connection.py" startline="1928" endline="1974" pcid="305">

    def get_all_volume_status(self, volume_ids=None,
                              max_results=None, next_token=None,
                              filters=None, dry_run=False):
        """
        Retrieve the status of one or more volumes.

        :type volume_ids: list
        :param volume_ids: A list of strings of volume IDs

        :type max_results: int
        :param max_results: The maximum number of paginated instance
            items per response.

        :type next_token: str
        :param next_token: A string specifying the next paginated set
            of results to return.

        :type filters: dict
        :param filters: Optional filters that can be used to limit
            the results returned.  Filters are provided
            in the form of a dictionary consisting of
            filter names as the key and filter values
            as the value.  The set of allowable filter
            names/values is dependent on the request
            being performed.  Check the EC2 API guide
            for details.

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: list
        :return: A list of volume status.
        """
        params = {}
        if volume_ids:
            self.build_list_params(params, volume_ids, 'VolumeId')
        if max_results:
            params['MaxResults'] = max_results
        if next_token:
            params['NextToken'] = next_token
        if filters:
            self.build_filter_params(params, filters)
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_object('DescribeVolumeStatus', params,
                               VolumeStatusSet, verb='POST')
</source>
<source file="systems/boto-2.13.2/boto/ec2/connection.py" startline="2180" endline="2232" pcid="313">

    def get_all_snapshots(self, snapshot_ids=None,
                          owner=None, restorable_by=None,
                          filters=None, dry_run=False):
        """
        Get all EBS Snapshots associated with the current credentials.

        :type snapshot_ids: list
        :param snapshot_ids: Optional list of snapshot ids.  If this list is
                             present, only the Snapshots associated with
                             these snapshot ids will be returned.

        :type owner: str
        :param owner: If present, only the snapshots owned by the specified user
                      will be returned.  Valid values are:

                      * self
                      * amazon
                      * AWS Account ID

        :type restorable_by: str
        :param restorable_by: If present, only the snapshots that are restorable
                              by the specified account id will be returned.

        :type filters: dict
        :param filters: Optional filters that can be used to limit
                        the results returned.  Filters are provided
                        in the form of a dictionary consisting of
                        filter names as the key and filter values
                        as the value.  The set of allowable filter
                        names/values is dependent on the request
                        being performed.  Check the EC2 API guide
                        for details.

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: list of :class:`boto.ec2.snapshot.Snapshot`
        :return: The requested Snapshot objects
        """
        params = {}
        if snapshot_ids:
            self.build_list_params(params, snapshot_ids, 'SnapshotId')
        if owner:
            params['Owner'] = owner
        if restorable_by:
            params['RestorableBy'] = restorable_by
        if filters:
            self.build_filter_params(params, filters)
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_list('DescribeSnapshots', params,
                             [('item', Snapshot)], verb='POST')
</source>
<source file="systems/boto-2.13.2/boto/ec2/connection.py" startline="1234" endline="1288" pcid="290">
    def get_spot_price_history(self, start_time=None, end_time=None,
                               instance_type=None, product_description=None,
                               availability_zone=None, dry_run=False):
        """
        Retrieve the recent history of spot instances pricing.

        :type start_time: str
        :param start_time: An indication of how far back to provide price
            changes for. An ISO8601 DateTime string.

        :type end_time: str
        :param end_time: An indication of how far forward to provide price
            changes for.  An ISO8601 DateTime string.

        :type instance_type: str
        :param instance_type: Filter responses to a particular instance type.

        :type product_description: str
        :param product_description: Filter responses to a particular platform.
            Valid values are currently:

            * Linux/UNIX
            * SUSE Linux
            * Windows
            * Linux/UNIX (Amazon VPC)
            * SUSE Linux (Amazon VPC)
            * Windows (Amazon VPC)

        :type availability_zone: str
        :param availability_zone: The availability zone for which prices
            should be returned.  If not specified, data for all
            availability zones will be returned.

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: list
        :return: A list tuples containing price and timestamp.
        """
        params = {}
        if start_time:
            params['StartTime'] = start_time
        if end_time:
            params['EndTime'] = end_time
        if instance_type:
            params['InstanceType'] = instance_type
        if product_description:
            params['ProductDescription'] = product_description
        if availability_zone:
            params['AvailabilityZone'] = availability_zone
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_list('DescribeSpotPriceHistory', params,
                             [('item', SpotPriceHistory)], verb='POST')

</source>
</class>

<class classid="16" nclones="2" nlines="10" similarity="100">
<source file="systems/boto-2.13.2/boto/ec2/connection.py" startline="1788" endline="1816" pcid="301">

    def disassociate_address(self, public_ip=None, association_id=None,
                             dry_run=False):
        """
        Disassociate an Elastic IP address from a currently running instance.

        :type public_ip: string
        :param public_ip: The public IP address for EC2 elastic IPs.

        :type association_id: string
        :param association_id: The association ID for a VPC based elastic ip.

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: bool
        :return: True if successful
        """
        params = {}

        if public_ip is not None:
            params['PublicIp'] = public_ip
        elif association_id is not None:
            params['AssociationId'] = association_id

        if dry_run:
            params['DryRun'] = 'true'

        return self.get_status('DisassociateAddress', params, verb='POST')
</source>
<source file="systems/boto-2.13.2/boto/ec2/connection.py" startline="1817" endline="1855" pcid="302">

    def release_address(self, public_ip=None, allocation_id=None,
                        dry_run=False):
        """
        Free up an Elastic IP address.  Pass a public IP address to
        release an EC2 Elastic IP address and an AllocationId to
        release a VPC Elastic IP address.  You should only pass
        one value.

        This requires one of ``public_ip`` or ``allocation_id`` depending
        on if you're associating a VPC address or a plain EC2 address.

        When using an Allocation ID, make sure to pass ``None`` for ``public_ip``
        as EC2 expects a single parameter and if ``public_ip`` is passed boto
        will preference that instead of ``allocation_id``.

        :type public_ip: string
        :param public_ip: The public IP address for EC2 elastic IPs.

        :type allocation_id: string
        :param allocation_id: The Allocation ID for VPC elastic IPs.

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: bool
        :return: True if successful
        """
        params = {}

        if public_ip is not None:
            params['PublicIp'] = public_ip
        elif allocation_id is not None:
            params['AllocationId'] = allocation_id

        if dry_run:
            params['DryRun'] = 'true'

        return self.get_status('ReleaseAddress', params, verb='POST')
</source>
</class>

<class classid="17" nclones="2" nlines="22" similarity="100">
<source file="systems/boto-2.13.2/boto/ec2/connection.py" startline="2810" endline="2868" pcid="329">

    def authorize_security_group_deprecated(self, group_name,
                                            src_security_group_name=None,
                                            src_security_group_owner_id=None,
                                            ip_protocol=None,
                                            from_port=None, to_port=None,
                                            cidr_ip=None, dry_run=False):
        """
        NOTE: This method uses the old-style request parameters
              that did not allow a port to be specified when
              authorizing a group.

        :type group_name: string
        :param group_name: The name of the security group you are adding
            the rule to.

        :type src_security_group_name: string
        :param src_security_group_name: The name of the security group you are
            granting access to.

        :type src_security_group_owner_id: string
        :param src_security_group_owner_id: The ID of the owner of the security
            group you are granting access to.

        :type ip_protocol: string
        :param ip_protocol: Either tcp | udp | icmp

        :type from_port: int
        :param from_port: The beginning port number you are enabling

        :type to_port: int
        :param to_port: The ending port number you are enabling

        :type to_port: string
        :param to_port: The CIDR block you are providing access to.
            See http://goo.gl/Yj5QC

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: bool
        :return: True if successful.
        """
        params = {'GroupName':group_name}
        if src_security_group_name:
            params['SourceSecurityGroupName'] = src_security_group_name
        if src_security_group_owner_id:
            params['SourceSecurityGroupOwnerId'] = src_security_group_owner_id
        if ip_protocol:
            params['IpProtocol'] = ip_protocol
        if from_port:
            params['FromPort'] = from_port
        if to_port:
            params['ToPort'] = to_port
        if cidr_ip:
            params['CidrIp'] = cidr_ip
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_status('AuthorizeSecurityGroupIngress', params)
</source>
<source file="systems/boto-2.13.2/boto/ec2/connection.py" startline="3001" endline="3065" pcid="332">
                               params, verb='POST')

    def revoke_security_group_deprecated(self, group_name,
                                         src_security_group_name=None,
                                         src_security_group_owner_id=None,
                                         ip_protocol=None,
                                         from_port=None, to_port=None,
                                         cidr_ip=None, dry_run=False):
        """
        NOTE: This method uses the old-style request parameters
              that did not allow a port to be specified when
              authorizing a group.

        Remove an existing rule from an existing security group.
        You need to pass in either src_security_group_name and
        src_security_group_owner_id OR ip_protocol, from_port, to_port,
        and cidr_ip.  In other words, either you are revoking another
        group or you are revoking some ip-based rule.

        :type group_name: string
        :param group_name: The name of the security group you are removing
                           the rule from.

        :type src_security_group_name: string
        :param src_security_group_name: The name of the security group you are
                                        revoking access to.

        :type src_security_group_owner_id: string
        :param src_security_group_owner_id: The ID of the owner of the security
                                            group you are revoking access to.

        :type ip_protocol: string
        :param ip_protocol: Either tcp | udp | icmp

        :type from_port: int
        :param from_port: The beginning port number you are disabling

        :type to_port: int
        :param to_port: The ending port number you are disabling

        :type to_port: string
        :param to_port: The CIDR block you are revoking access to.
                        http://goo.gl/Yj5QC

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: bool
        :return: True if successful.
        """
        params = {'GroupName':group_name}
        if src_security_group_name:
            params['SourceSecurityGroupName'] = src_security_group_name
        if src_security_group_owner_id:
            params['SourceSecurityGroupOwnerId'] = src_security_group_owner_id
        if ip_protocol:
            params['IpProtocol'] = ip_protocol
        if from_port:
            params['FromPort'] = from_port
        if to_port:
            params['ToPort'] = to_port
        if cidr_ip:
            params['CidrIp'] = cidr_ip
        if dry_run:
            params['DryRun'] = 'true'
</source>
</class>

<class classid="18" nclones="2" nlines="40" similarity="76">
<source file="systems/boto-2.13.2/boto/ec2/connection.py" startline="2869" endline="2962" pcid="330">

    def authorize_security_group(self, group_name=None,
                                 src_security_group_name=None,
                                 src_security_group_owner_id=None,
                                 ip_protocol=None,
                                 from_port=None, to_port=None,
                                 cidr_ip=None, group_id=None,
                                 src_security_group_group_id=None,
                                 dry_run=False):
        """
        Add a new rule to an existing security group.
        You need to pass in either src_security_group_name and
        src_security_group_owner_id OR ip_protocol, from_port, to_port,
        and cidr_ip.  In other words, either you are authorizing another
        group or you are authorizing some ip-based rule.

        :type group_name: string
        :param group_name: The name of the security group you are adding
            the rule to.

        :type src_security_group_name: string
        :param src_security_group_name: The name of the security group you are
            granting access to.

        :type src_security_group_owner_id: string
        :param src_security_group_owner_id: The ID of the owner of the security
            group you are granting access to.

        :type ip_protocol: string
        :param ip_protocol: Either tcp | udp | icmp

        :type from_port: int
        :param from_port: The beginning port number you are enabling

        :type to_port: int
        :param to_port: The ending port number you are enabling

        :type cidr_ip: string or list of strings
        :param cidr_ip: The CIDR block you are providing access to.
            See http://goo.gl/Yj5QC

        :type group_id: string
        :param group_id: ID of the EC2 or VPC security group to
            modify.  This is required for VPC security groups and can
            be used instead of group_name for EC2 security groups.

        :type src_security_group_group_id: string
        :param src_security_group_group_id: The ID of the security
            group you are granting access to.  Can be used instead of
            src_security_group_name

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: bool
        :return: True if successful.
        """
        if src_security_group_name:
            if from_port is None and to_port is None and ip_protocol is None:
                return self.authorize_security_group_deprecated(
                    group_name, src_security_group_name,
                    src_security_group_owner_id)

        params = {}

        if group_name:
            params['GroupName'] = group_name
        if group_id:
            params['GroupId'] = group_id
        if src_security_group_name:
            param_name = 'IpPermissions.1.Groups.1.GroupName'
            params[param_name] = src_security_group_name
        if src_security_group_owner_id:
            param_name = 'IpPermissions.1.Groups.1.UserId'
            params[param_name] = src_security_group_owner_id
        if src_security_group_group_id:
            param_name = 'IpPermissions.1.Groups.1.GroupId'
            params[param_name] = src_security_group_group_id
        if ip_protocol:
            params['IpPermissions.1.IpProtocol'] = ip_protocol
        if from_port is not None:
            params['IpPermissions.1.FromPort'] = from_port
        if to_port is not None:
            params['IpPermissions.1.ToPort'] = to_port
        if cidr_ip:
            if not isinstance(cidr_ip, list):
                cidr_ip = [cidr_ip]
            for i, single_cidr_ip in enumerate(cidr_ip):
                params['IpPermissions.1.IpRanges.%d.CidrIp' % (i+1)] = \
                    single_cidr_ip
        if dry_run:
            params['DryRun'] = 'true'

        return self.get_status('AuthorizeSecurityGroupIngress',
</source>
<source file="systems/boto-2.13.2/boto/ec2/connection.py" startline="3066" endline="3151" pcid="333">
        return self.get_status('RevokeSecurityGroupIngress', params)

    def revoke_security_group(self, group_name=None,
                              src_security_group_name=None,
                              src_security_group_owner_id=None,
                              ip_protocol=None, from_port=None, to_port=None,
                              cidr_ip=None, group_id=None,
                              src_security_group_group_id=None, dry_run=False):
        """
        Remove an existing rule from an existing security group.
        You need to pass in either src_security_group_name and
        src_security_group_owner_id OR ip_protocol, from_port, to_port,
        and cidr_ip.  In other words, either you are revoking another
        group or you are revoking some ip-based rule.

        :type group_name: string
        :param group_name: The name of the security group you are removing
            the rule from.

        :type src_security_group_name: string
        :param src_security_group_name: The name of the security group you are
            revoking access to.

        :type src_security_group_owner_id: string
        :param src_security_group_owner_id: The ID of the owner of the security
            group you are revoking access to.

        :type ip_protocol: string
        :param ip_protocol: Either tcp | udp | icmp

        :type from_port: int
        :param from_port: The beginning port number you are disabling

        :type to_port: int
        :param to_port: The ending port number you are disabling

        :type cidr_ip: string
        :param cidr_ip: The CIDR block you are revoking access to.
            See http://goo.gl/Yj5QC

        :type group_id: string
        :param group_id: ID of the EC2 or VPC security group to
            modify.  This is required for VPC security groups and can
            be used instead of group_name for EC2 security groups.

        :type src_security_group_group_id: string
        :param src_security_group_group_id: The ID of the security group
            for which you are revoking access.  Can be used instead
            of src_security_group_name

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: bool
        :return: True if successful.
        """
        if src_security_group_name:
            if from_port is None and to_port is None and ip_protocol is None:
                return self.revoke_security_group_deprecated(
                    group_name, src_security_group_name,
                    src_security_group_owner_id)
        params = {}
        if group_name is not None:
            params['GroupName'] = group_name
        if group_id is not None:
            params['GroupId'] = group_id
        if src_security_group_name:
            param_name = 'IpPermissions.1.Groups.1.GroupName'
            params[param_name] = src_security_group_name
        if src_security_group_group_id:
            param_name = 'IpPermissions.1.Groups.1.GroupId'
            params[param_name] = src_security_group_group_id
        if src_security_group_owner_id:
            param_name = 'IpPermissions.1.Groups.1.UserId'
            params[param_name] = src_security_group_owner_id
        if ip_protocol:
            params['IpPermissions.1.IpProtocol'] = ip_protocol
        if from_port is not None:
            params['IpPermissions.1.FromPort'] = from_port
        if to_port is not None:
            params['IpPermissions.1.ToPort'] = to_port
        if cidr_ip:
            params['IpPermissions.1.IpRanges.1.CidrIp'] = cidr_ip
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_status('RevokeSecurityGroupIngress',
</source>
</class>

<class classid="19" nclones="2" nlines="24" similarity="70">
<source file="systems/boto-2.13.2/boto/ec2/connection.py" startline="2963" endline="3000" pcid="331">
                               params, verb='POST')

    def authorize_security_group_egress(self,
                                        group_id,
                                        ip_protocol,
                                        from_port=None,
                                        to_port=None,
                                        src_group_id=None,
                                        cidr_ip=None,
                                        dry_run=False):
        """
        The action adds one or more egress rules to a VPC security
        group. Specifically, this action permits instances in a
        security group to send traffic to one or more destination
        CIDR IP address ranges, or to one or more destination
        security groups in the same VPC.

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        """
        params = {
            'GroupId': group_id,
            'IpPermissions.1.IpProtocol': ip_protocol
        }

        if from_port is not None:
            params['IpPermissions.1.FromPort'] = from_port
        if to_port is not None:
            params['IpPermissions.1.ToPort'] = to_port
        if src_group_id is not None:
            params['IpPermissions.1.Groups.1.GroupId'] = src_group_id
        if cidr_ip is not None:
            params['IpPermissions.1.IpRanges.1.CidrIp'] = cidr_ip
        if dry_run:
            params['DryRun'] = 'true'

        return self.get_status('AuthorizeSecurityGroupEgress',
</source>
<source file="systems/boto-2.13.2/boto/ec2/connection.py" startline="3152" endline="3215" pcid="334">
                               params, verb='POST')

    def revoke_security_group_egress(self,
                                     group_id,
                                     ip_protocol,
                                     from_port=None,
                                     to_port=None,
                                     src_group_id=None,
                                     cidr_ip=None, dry_run=False):
        """
        Remove an existing egress rule from an existing VPC security
        group.  You need to pass in an ip_protocol, from_port and
        to_port range only if the protocol you are using is
        port-based. You also need to pass in either a src_group_id or
        cidr_ip.

        :type group_name: string
        :param group_id:  The name of the security group you are removing
            the rule from.

        :type ip_protocol: string
        :param ip_protocol: Either tcp | udp | icmp | -1

        :type from_port: int
        :param from_port: The beginning port number you are disabling

        :type to_port: int
        :param to_port: The ending port number you are disabling

        :type src_group_id: src_group_id
        :param src_group_id: The source security group you are
            revoking access to.

        :type cidr_ip: string
        :param cidr_ip: The CIDR block you are revoking access to.
            See http://goo.gl/Yj5QC

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: bool
        :return: True if successful.
        """

        params = {}
        if group_id:
            params['GroupId'] = group_id
        if ip_protocol:
            params['IpPermissions.1.IpProtocol'] = ip_protocol
        if from_port is not None:
            params['IpPermissions.1.FromPort'] = from_port
        if to_port is not None:
            params['IpPermissions.1.ToPort'] = to_port
        if src_group_id is not None:
            params['IpPermissions.1.Groups.1.GroupId'] = src_group_id
        if cidr_ip:
            params['IpPermissions.1.IpRanges.1.CidrIp'] = cidr_ip
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_status('RevokeSecurityGroupEgress',
                               params, verb='POST')

    #
    # Regions
</source>
</class>

<class classid="20" nclones="2" nlines="38" similarity="87">
<source file="systems/boto-2.13.2/boto/ec2/securitygroup.py" startline="143" endline="209" pcid="512">
    def authorize(self, ip_protocol=None, from_port=None, to_port=None,
                  cidr_ip=None, src_group=None, dry_run=False):
        """
        Add a new rule to this security group.
        You need to pass in either src_group_name
        OR ip_protocol, from_port, to_port,
        and cidr_ip.  In other words, either you are authorizing another
        group or you are authorizing some ip-based rule.

        :type ip_protocol: string
        :param ip_protocol: Either tcp | udp | icmp

        :type from_port: int
        :param from_port: The beginning port number you are enabling

        :type to_port: int
        :param to_port: The ending port number you are enabling

        :type cidr_ip: string or list of strings
        :param cidr_ip: The CIDR block you are providing access to.
                        See http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing

        :type src_group: :class:`boto.ec2.securitygroup.SecurityGroup` or
                         :class:`boto.ec2.securitygroup.GroupOrCIDR`
        :param src_group: The Security Group you are granting access to.

        :rtype: bool
        :return: True if successful.
        """
        group_name = None
        if not self.vpc_id:
            group_name = self.name
        group_id = None
        if self.vpc_id:
            group_id = self.id
        src_group_name = None
        src_group_owner_id = None
        src_group_group_id = None
        if src_group:
            cidr_ip = None
            src_group_owner_id = src_group.owner_id
            if not self.vpc_id:
                src_group_name = src_group.name
            else:
                if hasattr(src_group, 'group_id'):
                    src_group_group_id = src_group.group_id
                else:
                    src_group_group_id = src_group.id
        status = self.connection.authorize_security_group(group_name,
                                                          src_group_name,
                                                          src_group_owner_id,
                                                          ip_protocol,
                                                          from_port,
                                                          to_port,
                                                          cidr_ip,
                                                          group_id,
                                                          src_group_group_id,
                                                          dry_run=dry_run)
        if status:
            if not isinstance(cidr_ip, list):
                cidr_ip = [cidr_ip]
            for single_cidr_ip in cidr_ip:
                self.add_rule(ip_protocol, from_port, to_port, src_group_name,
                              src_group_owner_id, single_cidr_ip,
                              src_group_group_id, dry_run=dry_run)
        return status

</source>
<source file="systems/boto-2.13.2/boto/ec2/securitygroup.py" startline="210" endline="246" pcid="513">
    def revoke(self, ip_protocol=None, from_port=None, to_port=None,
               cidr_ip=None, src_group=None, dry_run=False):
        group_name = None
        if not self.vpc_id:
            group_name = self.name
        group_id = None
        if self.vpc_id:
            group_id = self.id
        src_group_name = None
        src_group_owner_id = None
        src_group_group_id = None
        if src_group:
            cidr_ip = None
            src_group_owner_id = src_group.owner_id
            if not self.vpc_id:
                src_group_name = src_group.name
            else:
                if hasattr(src_group, 'group_id'):
                    src_group_group_id = src_group.group_id
                else:
                    src_group_group_id = src_group.id
        status = self.connection.revoke_security_group(group_name,
                                                       src_group_name,
                                                       src_group_owner_id,
                                                       ip_protocol,
                                                       from_port,
                                                       to_port,
                                                       cidr_ip,
                                                       group_id,
                                                       src_group_group_id,
                                                       dry_run=dry_run)
        if status:
            self.remove_rule(ip_protocol, from_port, to_port, src_group_name,
                             src_group_owner_id, cidr_ip, src_group_group_id,
                             dry_run=dry_run)
        return status

</source>
</class>

<class classid="21" nclones="2" nlines="10" similarity="100">
<source file="systems/boto-2.13.2/boto/ec2/address.py" startline="74" endline="89" pcid="530">
    def release(self, dry_run=False):
        """
        Free up this Elastic IP address.
        :see: :meth:`boto.ec2.connection.EC2Connection.release_address`
        """
        if self.allocation_id:
            return self.connection.release_address(
                None,
                self.allocation_id,
                dry_run=dry_run)
        else:
            return self.connection.release_address(
                self.public_ip,
                dry_run=dry_run
            )

</source>
<source file="systems/boto-2.13.2/boto/ec2/address.py" startline="103" endline="120" pcid="532">
    def disassociate(self, dry_run=False):
        """
        Disassociate this Elastic IP address from a currently running instance.
        :see: :meth:`boto.ec2.connection.EC2Connection.disassociate_address`
        """
        if self.association_id:
            return self.connection.disassociate_address(
                None,
                self.association_id,
                dry_run=dry_run
            )
        else:
            return self.connection.disassociate_address(
                self.public_ip,
                dry_run=dry_run
            )


</source>
</class>

<class classid="22" nclones="3" nlines="46" similarity="70">
<source file="systems/boto-2.13.2/boto/ec2/image.py" startline="91" endline="141" pcid="629">
    def endElement(self, name, value, connection):
        if name == 'imageId':
            self.id = value
        elif name == 'imageLocation':
            self.location = value
        elif name == 'imageState':
            self.state = value
        elif name == 'imageOwnerId':
            self.ownerId = value # for backwards compatibility
            self.owner_id = value
        elif name == 'isPublic':
            if value == 'false':
                self.is_public = False
            elif value == 'true':
                self.is_public = True
            else:
                raise Exception(
                    'Unexpected value of isPublic %s for image %s'%(
                        value,
                        self.id
                    )
                )
        elif name == 'architecture':
            self.architecture = value
        elif name == 'imageType':
            self.type = value
        elif name == 'kernelId':
            self.kernel_id = value
        elif name == 'ramdiskId':
            self.ramdisk_id = value
        elif name == 'imageOwnerAlias':
            self.owner_alias = value
        elif name == 'platform':
            self.platform = value
        elif name == 'name':
            self.name = value
        elif name == 'description':
            self.description = value
        elif name == 'rootDeviceType':
            self.root_device_type = value
        elif name == 'rootDeviceName':
            self.root_device_name = value
        elif name == 'virtualizationType':
            self.virtualization_type = value
        elif name == 'hypervisor':
            self.hypervisor = value
        elif name == 'instanceLifecycle':
            self.instance_lifecycle = value
        else:
            setattr(self, name, value)

</source>
<source file="systems/boto-2.13.2/boto/rds/dbinstance.py" startline="139" endline="182" pcid="2218">

    def endElement(self, name, value, connection):
        if name == 'DBInstanceIdentifier':
            self.id = value
        elif name == 'DBInstanceStatus':
            self.status = value
        elif name == 'InstanceCreateTime':
            self.create_time = value
        elif name == 'Engine':
            self.engine = value
        elif name == 'DBInstanceStatus':
            self.status = value
        elif name == 'AllocatedStorage':
            self.allocated_storage = int(value)
        elif name == 'DBInstanceClass':
            self.instance_class = value
        elif name == 'MasterUsername':
            self.master_username = value
        elif name == 'Port':
            if self._in_endpoint:
                self._port = int(value)
        elif name == 'Address':
            if self._in_endpoint:
                self._address = value
        elif name == 'Endpoint':
            self.endpoint = (self._address, self._port)
            self._in_endpoint = False
        elif name == 'AvailabilityZone':
            self.availability_zone = value
        elif name == 'BackupRetentionPeriod':
            self.backup_retention_period = value
        elif name == 'LatestRestorableTime':
            self.latest_restorable_time = value
        elif name == 'PreferredMaintenanceWindow':
            self.preferred_maintenance_window = value
        elif name == 'PreferredBackupWindow':
            self.preferred_backup_window = value
        elif name == 'MultiAZ':
            if value.lower() == 'true':
                self.multi_az = True
        elif name == 'Iops':
            self.iops = int(value)
        else:
            setattr(self, name, value)
</source>
<source file="systems/boto-2.13.2/boto/resultset.py" startline="83" endline="129" pcid="3099">
    def endElement(self, name, value, connection):
        if name == 'IsTruncated':
            self.is_truncated = self.to_boolean(value)
        elif name == 'Marker':
            self.marker = value
        elif name == 'KeyMarker':
            self.key_marker = value
        elif name == 'NextMarker':
            self.next_marker = value
        elif name == 'NextKeyMarker':
            self.next_key_marker = value
        elif name == 'VersionIdMarker':
            self.version_id_marker = value
        elif name == 'NextVersionIdMarker':
            self.next_version_id_marker = value
        elif name == 'NextGenerationMarker':
            self.next_generation_marker = value
        elif name == 'UploadIdMarker':
            self.upload_id_marker = value
        elif name == 'NextUploadIdMarker':
            self.next_upload_id_marker = value
        elif name == 'Bucket':
            self.bucket = value
        elif name == 'MaxUploads':
            self.max_uploads = int(value)
        elif name == 'MaxItems':
            self.max_items = int(value)
        elif name == 'Prefix':
            self.prefix = value
        elif name == 'return':
            self.status = self.to_boolean(value)
        elif name == 'StatusCode':
            self.status = self.to_boolean(value, 'Success')
        elif name == 'ItemName':
            self.append(value)
        elif name == 'NextToken':
            self.next_token = value
        elif name == 'BoxUsage':
            try:
                connection.box_usage += float(value)
            except:
                pass
        elif name == 'IsValid':
            self.status = self.to_boolean(value, 'True')
        else:
            setattr(self, name, value)

</source>
</class>

<class classid="23" nclones="3" nlines="16" similarity="82">
<source file="systems/boto-2.13.2/boto/beanstalk/response.py" startline="135" endline="152" pcid="763">
    def __init__(self, response):
        super(ConfigurationSettingsDescription, self).__init__()

        self.application_name = str(response['ApplicationName'])
        self.date_created = datetime.fromtimestamp(response['DateCreated'])
        self.date_updated = datetime.fromtimestamp(response['DateUpdated'])
        self.deployment_status = str(response['DeploymentStatus'])
        self.description = str(response['Description'])
        self.environment_name = str(response['EnvironmentName'])
        self.option_settings = []
        if response['OptionSettings']:
            for member in response['OptionSettings']:
                option_setting = ConfigurationOptionSetting(member)
                self.option_settings.append(option_setting)
        self.solution_stack_name = str(response['SolutionStackName'])
        self.template_name = str(response['TemplateName'])


</source>
<source file="systems/boto-2.13.2/boto/beanstalk/response.py" startline="648" endline="667" pcid="805">
    def __init__(self, response):
        response = response['UpdateConfigurationTemplateResponse']
        super(UpdateConfigurationTemplateResponse, self).__init__(response)

        response = response['UpdateConfigurationTemplateResult']
        self.application_name = str(response['ApplicationName'])
        self.date_created = datetime.fromtimestamp(response['DateCreated'])
        self.date_updated = datetime.fromtimestamp(response['DateUpdated'])
        self.deployment_status = str(response['DeploymentStatus'])
        self.description = str(response['Description'])
        self.environment_name = str(response['EnvironmentName'])
        self.option_settings = []
        if response['OptionSettings']:
            for member in response['OptionSettings']:
                option_setting = ConfigurationOptionSetting(member)
                self.option_settings.append(option_setting)
        self.solution_stack_name = str(response['SolutionStackName'])
        self.template_name = str(response['TemplateName'])


</source>
<source file="systems/boto-2.13.2/boto/beanstalk/response.py" startline="370" endline="389" pcid="782">
    def __init__(self, response):
        response = response['CreateConfigurationTemplateResponse']
        super(CreateConfigurationTemplateResponse, self).__init__(response)

        response = response['CreateConfigurationTemplateResult']
        self.application_name = str(response['ApplicationName'])
        self.date_created = datetime.fromtimestamp(response['DateCreated'])
        self.date_updated = datetime.fromtimestamp(response['DateUpdated'])
        self.deployment_status = str(response['DeploymentStatus'])
        self.description = str(response['Description'])
        self.environment_name = str(response['EnvironmentName'])
        self.option_settings = []
        if response['OptionSettings']:
            for member in response['OptionSettings']:
                option_setting = ConfigurationOptionSetting(member)
                self.option_settings.append(option_setting)
        self.solution_stack_name = str(response['SolutionStackName'])
        self.template_name = str(response['TemplateName'])


</source>
</class>

<class classid="24" nclones="4" nlines="20" similarity="85">
<source file="systems/boto-2.13.2/boto/beanstalk/response.py" startline="154" endline="175" pcid="764">
    def __init__(self, response):
        super(EnvironmentDescription, self).__init__()

        self.application_name = str(response['ApplicationName'])
        self.cname = str(response['CNAME'])
        self.date_created = datetime.fromtimestamp(response['DateCreated'])
        self.date_updated = datetime.fromtimestamp(response['DateUpdated'])
        self.description = str(response['Description'])
        self.endpoint_url = str(response['EndpointURL'])
        self.environment_id = str(response['EnvironmentId'])
        self.environment_name = str(response['EnvironmentName'])
        self.health = str(response['Health'])
        if response['Resources']:
            self.resources = EnvironmentResourcesDescription(response['Resources'])
        else:
            self.resources = None
        self.solution_stack_name = str(response['SolutionStackName'])
        self.status = str(response['Status'])
        self.template_name = str(response['TemplateName'])
        self.version_label = str(response['VersionLabel'])


</source>
<source file="systems/boto-2.13.2/boto/beanstalk/response.py" startline="669" endline="692" pcid="806">
    def __init__(self, response):
        response = response['UpdateEnvironmentResponse']
        super(UpdateEnvironmentResponse, self).__init__(response)

        response = response['UpdateEnvironmentResult']
        self.application_name = str(response['ApplicationName'])
        self.cname = str(response['CNAME'])
        self.date_created = datetime.fromtimestamp(response['DateCreated'])
        self.date_updated = datetime.fromtimestamp(response['DateUpdated'])
        self.description = str(response['Description'])
        self.endpoint_url = str(response['EndpointURL'])
        self.environment_id = str(response['EnvironmentId'])
        self.environment_name = str(response['EnvironmentName'])
        self.health = str(response['Health'])
        if response['Resources']:
            self.resources = EnvironmentResourcesDescription(response['Resources'])
        else:
            self.resources = None
        self.solution_stack_name = str(response['SolutionStackName'])
        self.status = str(response['Status'])
        self.template_name = str(response['TemplateName'])
        self.version_label = str(response['VersionLabel'])


</source>
<source file="systems/boto-2.13.2/boto/beanstalk/response.py" startline="391" endline="414" pcid="783">
    def __init__(self, response):
        response = response['CreateEnvironmentResponse']
        super(CreateEnvironmentResponse, self).__init__(response)

        response = response['CreateEnvironmentResult']
        self.application_name = str(response['ApplicationName'])
        self.cname = str(response['CNAME'])
        self.date_created = datetime.fromtimestamp(response['DateCreated'])
        self.date_updated = datetime.fromtimestamp(response['DateUpdated'])
        self.description = str(response['Description'])
        self.endpoint_url = str(response['EndpointURL'])
        self.environment_id = str(response['EnvironmentId'])
        self.environment_name = str(response['EnvironmentName'])
        self.health = str(response['Health'])
        if response['Resources']:
            self.resources = EnvironmentResourcesDescription(response['Resources'])
        else:
            self.resources = None
        self.solution_stack_name = str(response['SolutionStackName'])
        self.status = str(response['Status'])
        self.template_name = str(response['TemplateName'])
        self.version_label = str(response['VersionLabel'])


</source>
<source file="systems/boto-2.13.2/boto/beanstalk/response.py" startline="599" endline="622" pcid="802">
    def __init__(self, response):
        response = response['TerminateEnvironmentResponse']
        super(TerminateEnvironmentResponse, self).__init__(response)

        response = response['TerminateEnvironmentResult']
        self.application_name = str(response['ApplicationName'])
        self.cname = str(response['CNAME'])
        self.date_created = datetime.fromtimestamp(response['DateCreated'])
        self.date_updated = datetime.fromtimestamp(response['DateUpdated'])
        self.description = str(response['Description'])
        self.endpoint_url = str(response['EndpointURL'])
        self.environment_id = str(response['EnvironmentId'])
        self.environment_name = str(response['EnvironmentName'])
        self.health = str(response['Health'])
        if response['Resources']:
            self.resources = EnvironmentResourcesDescription(response['Resources'])
        else:
            self.resources = None
        self.solution_stack_name = str(response['SolutionStackName'])
        self.status = str(response['Status'])
        self.template_name = str(response['TemplateName'])
        self.version_label = str(response['VersionLabel'])


</source>
</class>

<class classid="25" nclones="2" nlines="10" similarity="100">
<source file="systems/boto-2.13.2/boto/beanstalk/response.py" startline="475" endline="487" pcid="791">
    def __init__(self, response):
        response = response['DescribeConfigurationOptionsResponse']
        super(DescribeConfigurationOptionsResponse, self).__init__(response)

        response = response['DescribeConfigurationOptionsResult']
        self.options = []
        if response['Options']:
            for member in response['Options']:
                option = ConfigurationOptionDescription(member)
                self.options.append(option)
        self.solution_stack_name = str(response['SolutionStackName'])


</source>
<source file="systems/boto-2.13.2/boto/beanstalk/response.py" startline="527" endline="539" pcid="795">
    def __init__(self, response):
        response = response['DescribeEventsResponse']
        super(DescribeEventsResponse, self).__init__(response)

        response = response['DescribeEventsResult']
        self.events = []
        if response['Events']:
            for member in response['Events']:
                event = EventDescription(member)
                self.events.append(event)
        self.next_tokent = str(response['NextToken'])


</source>
</class>

<class classid="26" nclones="2" nlines="29" similarity="90">
<source file="systems/boto-2.13.2/boto/beanstalk/__init__.py" startline="26" endline="60" pcid="812">
def regions():
    """
    Get all available regions for the AWS Elastic Beanstalk service.

    :rtype: list
    :return: A list of :class:`boto.regioninfo.RegionInfo`
    """
    import boto.beanstalk.layer1
    return [RegionInfo(name='us-east-1',
                       endpoint='elasticbeanstalk.us-east-1.amazonaws.com',
                       connection_cls=boto.beanstalk.layer1.Layer1),
            RegionInfo(name='us-west-1',
                       endpoint='elasticbeanstalk.us-west-1.amazonaws.com',
                       connection_cls=boto.beanstalk.layer1.Layer1),
            RegionInfo(name='us-west-2',
                       endpoint='elasticbeanstalk.us-west-2.amazonaws.com',
                       connection_cls=boto.beanstalk.layer1.Layer1),
            RegionInfo(name='ap-northeast-1',
                       endpoint='elasticbeanstalk.ap-northeast-1.amazonaws.com',
                       connection_cls=boto.beanstalk.layer1.Layer1),
            RegionInfo(name='ap-southeast-1',
                       endpoint='elasticbeanstalk.ap-southeast-1.amazonaws.com',
                       connection_cls=boto.beanstalk.layer1.Layer1),
            RegionInfo(name='ap-southeast-2',
                       endpoint='elasticbeanstalk.ap-southeast-2.amazonaws.com',
                       connection_cls=boto.beanstalk.layer1.Layer1),
            RegionInfo(name='eu-west-1',
                       endpoint='elasticbeanstalk.eu-west-1.amazonaws.com',
                       connection_cls=boto.beanstalk.layer1.Layer1),
            RegionInfo(name='sa-east-1',
                       endpoint='elasticbeanstalk.sa-east-1.amazonaws.com',
                       connection_cls=boto.beanstalk.layer1.Layer1),
            ]


</source>
<source file="systems/boto-2.13.2/boto/dynamodb/__init__.py" startline="27" endline="64" pcid="4087">
def regions():
    """
    Get all available regions for the Amazon DynamoDB service.

    :rtype: list
    :return: A list of :class:`boto.regioninfo.RegionInfo`
    """
    import boto.dynamodb.layer2
    return [RegionInfo(name='us-east-1',
                       endpoint='dynamodb.us-east-1.amazonaws.com',
                       connection_cls=boto.dynamodb.layer2.Layer2),
            RegionInfo(name='us-gov-west-1',
                       endpoint='dynamodb.us-gov-west-1.amazonaws.com',
                       connection_cls=boto.dynamodb.layer2.Layer2),
            RegionInfo(name='us-west-1',
                       endpoint='dynamodb.us-west-1.amazonaws.com',
                       connection_cls=boto.dynamodb.layer2.Layer2),
            RegionInfo(name='us-west-2',
                       endpoint='dynamodb.us-west-2.amazonaws.com',
                       connection_cls=boto.dynamodb.layer2.Layer2),
            RegionInfo(name='ap-northeast-1',
                       endpoint='dynamodb.ap-northeast-1.amazonaws.com',
                       connection_cls=boto.dynamodb.layer2.Layer2),
            RegionInfo(name='ap-southeast-1',
                       endpoint='dynamodb.ap-southeast-1.amazonaws.com',
                       connection_cls=boto.dynamodb.layer2.Layer2),
            RegionInfo(name='ap-southeast-2',
                       endpoint='dynamodb.ap-southeast-2.amazonaws.com',
                       connection_cls=boto.dynamodb.layer2.Layer2),
            RegionInfo(name='eu-west-1',
                       endpoint='dynamodb.eu-west-1.amazonaws.com',
                       connection_cls=boto.dynamodb.layer2.Layer2),
            RegionInfo(name='sa-east-1',
                   endpoint='dynamodb.sa-east-1.amazonaws.com',
                   connection_cls=boto.dynamodb.layer2.Layer2),
            ]


</source>
</class>

<class classid="27" nclones="3" nlines="23" similarity="73">
<source file="systems/boto-2.13.2/boto/beanstalk/layer1.py" startline="158" endline="235" pcid="821">
    def create_configuration_template(self, application_name, template_name,
                                      solution_stack_name=None,
                                      source_configuration_application_name=None,
                                      source_configuration_template_name=None,
                                      environment_id=None, description=None,
                                      option_settings=None):
        """Creates a configuration template.

        Templates are associated with a specific application and are used to
        deploy different versions of the application with the same
        configuration settings.

        :type application_name: string
        :param application_name: The name of the application to associate with
            this configuration template. If no application is found with this
            name, AWS Elastic Beanstalk returns an InvalidParameterValue error.

        :type template_name: string
        :param template_name: The name of the configuration template.
            Constraint: This name must be unique per application.  Default: If
            a configuration template already exists with this name, AWS Elastic
            Beanstalk returns an InvalidParameterValue error.

        :type solution_stack_name: string
        :param solution_stack_name: The name of the solution stack used by this
            configuration. The solution stack specifies the operating system,
            architecture, and application server for a configuration template.
            It determines the set of configuration options as well as the
            possible and default values.  Use ListAvailableSolutionStacks to
            obtain a list of available solution stacks.  Default: If the
            SolutionStackName is not specified and the source configuration
            parameter is blank, AWS Elastic Beanstalk uses the default solution
            stack. If not specified and the source configuration parameter is
            specified, AWS Elastic Beanstalk uses the same solution stack as
            the source configuration template.

        :type source_configuration_application_name: string
        :param source_configuration_application_name: The name of the
            application associated with the configuration.

        :type source_configuration_template_name: string
        :param source_configuration_template_name: The name of the
            configuration template.

        :type environment_id: string
        :param environment_id: The ID of the environment used with this
            configuration template.

        :type description: string
        :param description: Describes this configuration.

        :type option_settings: list
        :param option_settings: If specified, AWS Elastic Beanstalk sets the
            specified configuration option to the requested value. The new
            value overrides the value obtained from the solution stack or the
            source configuration template.

        :raises: InsufficientPrivilegesException,
                 TooManyConfigurationTemplatesException
        """
        params = {'ApplicationName': application_name,
                  'TemplateName': template_name}
        if solution_stack_name:
            params['SolutionStackName'] = solution_stack_name
        if source_configuration_application_name:
            params['SourceConfiguration.ApplicationName'] = source_configuration_application_name
        if source_configuration_template_name:
            params['SourceConfiguration.TemplateName'] = source_configuration_template_name
        if environment_id:
            params['EnvironmentId'] = environment_id
        if description:
            params['Description'] = description
        if option_settings:
            self._build_list_params(params, option_settings,
                                   'OptionSettings.member',
                                   ('Namespace', 'OptionName', 'Value'))
        return self._get_response('CreateConfigurationTemplate', params)

</source>
<source file="systems/boto-2.13.2/boto/beanstalk/layer1.py" startline="236" endline="334" pcid="822">
    def create_environment(self, application_name, environment_name,
                           version_label=None, template_name=None,
                           solution_stack_name=None, cname_prefix=None,
                           description=None, option_settings=None,
                           options_to_remove=None):
        """Launches an environment for the application using a configuration.

        :type application_name: string
        :param application_name: The name of the application that contains the
            version to be deployed.  If no application is found with this name,
            CreateEnvironment returns an InvalidParameterValue error.

        :type version_label: string
        :param version_label: The name of the application version to deploy. If
            the specified application has no associated application versions,
            AWS Elastic Beanstalk UpdateEnvironment returns an
            InvalidParameterValue error.  Default: If not specified, AWS
            Elastic Beanstalk attempts to launch the most recently created
            application version.

        :type environment_name: string
        :param environment_name: A unique name for the deployment environment.
            Used in the application URL. Constraint: Must be from 4 to 23
            characters in length. The name can contain only letters, numbers,
            and hyphens. It cannot start or end with a hyphen. This name must
            be unique in your account. If the specified name already exists,
            AWS Elastic Beanstalk returns an InvalidParameterValue error.
            Default: If the CNAME parameter is not specified, the environment
            name becomes part of the CNAME, and therefore part of the visible
            URL for your application.

        :type template_name: string
        :param template_name: The name of the configuration template to
            use in deployment. If no configuration template is found with this
            name, AWS Elastic Beanstalk returns an InvalidParameterValue error.
            Condition: You must specify either this parameter or a
            SolutionStackName, but not both. If you specify both, AWS Elastic
            Beanstalk returns an InvalidParameterCombination error. If you do
            not specify either, AWS Elastic Beanstalk returns a
            MissingRequiredParameter error.

        :type solution_stack_name: string
        :param solution_stack_name: This is an alternative to specifying a
            configuration name. If specified, AWS Elastic Beanstalk sets the
            configuration values to the default values associated with the
            specified solution stack.  Condition: You must specify either this
            or a TemplateName, but not both. If you specify both, AWS Elastic
            Beanstalk returns an InvalidParameterCombination error. If you do
            not specify either, AWS Elastic Beanstalk returns a
            MissingRequiredParameter error.

        :type cname_prefix: string
        :param cname_prefix: If specified, the environment attempts to use this
            value as the prefix for the CNAME. If not specified, the
            environment uses the environment name.

        :type description: string
        :param description: Describes this environment.

        :type option_settings: list
        :param option_settings: If specified, AWS Elastic Beanstalk sets the
            specified configuration options to the requested value in the
            configuration set for the new environment. These override the
            values obtained from the solution stack or the configuration
            template.  Each element in the list is a tuple of (Namespace,
            OptionName, Value), for example::

                [('aws:autoscaling:launchconfiguration',
                    'Ec2KeyName', 'mykeypair')]

        :type options_to_remove: list
        :param options_to_remove: A list of custom user-defined configuration
            options to remove from the configuration set for this new
            environment.

        :raises: TooManyEnvironmentsException, InsufficientPrivilegesException

        """
        params = {'ApplicationName': application_name,
                  'EnvironmentName': environment_name}
        if version_label:
            params['VersionLabel'] = version_label
        if template_name:
            params['TemplateName'] = template_name
        if solution_stack_name:
            params['SolutionStackName'] = solution_stack_name
        if cname_prefix:
            params['CNAMEPrefix'] = cname_prefix
        if description:
            params['Description'] = description
        if option_settings:
            self._build_list_params(params, option_settings,
                                   'OptionSettings.member',
                                   ('Namespace', 'OptionName', 'Value'))
        if options_to_remove:
            self.build_list_params(params, options_to_remove,
                                   'OptionsToRemove.member')
        return self._get_response('CreateEnvironment', params)

</source>
<source file="systems/boto-2.13.2/boto/beanstalk/layer1.py" startline="1021" endline="1097" pcid="845">
    def update_environment(self, environment_id=None, environment_name=None,
                           version_label=None, template_name=None,
                           description=None, option_settings=None,
                           options_to_remove=None):
        """
        Updates the environment description, deploys a new application
        version, updates the configuration settings to an entirely new
        configuration template, or updates select configuration option
        values in the running environment.  Attempting to update both
        the release and configuration is not allowed and AWS Elastic
        Beanstalk returns an InvalidParameterCombination error.  When
        updating the configuration settings to a new template or
        individual settings, a draft configuration is created and
        DescribeConfigurationSettings for this environment returns two
        setting descriptions with different DeploymentStatus values.

        :type environment_id: string
        :param environment_id: The ID of the environment to update. If no
            environment with this ID exists, AWS Elastic Beanstalk returns an
            InvalidParameterValue error.  Condition: You must specify either
            this or an EnvironmentName, or both. If you do not specify either,
            AWS Elastic Beanstalk returns MissingRequiredParameter error.

        :type environment_name: string
        :param environment_name: The name of the environment to update.  If no
            environment with this name exists, AWS Elastic Beanstalk returns an
            InvalidParameterValue error.  Condition: You must specify either
            this or an EnvironmentId, or both. If you do not specify either,
            AWS Elastic Beanstalk returns MissingRequiredParameter error.

        :type version_label: string
        :param version_label: If this parameter is specified, AWS Elastic
            Beanstalk deploys the named application version to the environment.
            If no such application version is found, returns an
            InvalidParameterValue error.

        :type template_name: string
        :param template_name: If this parameter is specified, AWS Elastic
            Beanstalk deploys this configuration template to the environment.
            If no such configuration template is found, AWS Elastic Beanstalk
            returns an InvalidParameterValue error.

        :type description: string
        :param description: If this parameter is specified, AWS Elastic
            Beanstalk updates the description of this environment.

        :type option_settings: list
        :param option_settings: If specified, AWS Elastic Beanstalk updates the
            configuration set associated with the running environment and sets
            the specified configuration options to the requested value.

        :type options_to_remove: list
        :param options_to_remove: A list of custom user-defined configuration
            options to remove from the configuration set for this environment.

        :raises: InsufficientPrivilegesException
        """
        params = {}
        if environment_id:
            params['EnvironmentId'] = environment_id
        if environment_name:
            params['EnvironmentName'] = environment_name
        if version_label:
            params['VersionLabel'] = version_label
        if template_name:
            params['TemplateName'] = template_name
        if description:
            params['Description'] = description
        if option_settings:
            self._build_list_params(params, option_settings,
                                   'OptionSettings.member',
                                   ('Namespace', 'OptionName', 'Value'))
        if options_to_remove:
            self.build_list_params(params, options_to_remove,
                                   'OptionsToRemove.member')
        return self._get_response('UpdateEnvironment', params)

</source>
</class>

<class classid="28" nclones="4" nlines="14" similarity="73">
<source file="systems/boto-2.13.2/boto/fps/connection.py" startline="57" endline="74" pcid="882">
def requires(*groups):

    def decorator(func):

        def wrapper(*args, **kw):
            hasgroup = lambda x: len(x) == len(filter(kw.has_key, x))
            if 1 != len(filter(hasgroup, groups)):
                message = ' OR '.join(['+'.join(g) for g in groups])
                message = "{0} requires {1} argument(s)" \
                          "".format(getattr(func, 'action', 'Method'), message)
                raise KeyError(message)
            return func(*args, **kw)
        message = ' OR '.join(['+'.join(g) for g in groups])
        wrapper.__doc__ = "{0}\nRequired: {1}".format(func.__doc__,
                                                           message)
        return add_attrs_from(func, to=wrapper)
    return decorator

</source>
<source file="systems/boto-2.13.2/boto/mws/connection.py" startline="160" endline="178" pcid="1385">
        return add_attrs_from(func, to=wrapper)
    return decorator


def dependent(field, *groups):

    def decorator(func):

        def wrapper(*args, **kw):
            hasgroup = lambda x: len(x) == len(filter(kw.has_key, x))
            if field in kw and 1 > len(filter(hasgroup, groups)):
                message = ' OR '.join(['+'.join(g) for g in groups])
                message = "{0} argument {1} requires {2}" \
                          "".format(func.action, field, message)
                raise KeyError(message)
            return func(*args, **kw)
        message = ' OR '.join(['+'.join(g) for g in groups])
        wrapper.__doc__ = "{0}\n{1} requires: {2}".format(func.__doc__,
                                                           field,
</source>
<source file="systems/boto-2.13.2/boto/mws/connection.py" startline="124" endline="141" pcid="1379">


def requires(*groups):

    def decorator(func):

        def wrapper(*args, **kw):
            hasgroup = lambda x: len(x) == len(filter(kw.has_key, x))
            if 1 != len(filter(hasgroup, groups)):
                message = ' OR '.join(['+'.join(g) for g in groups])
                message = "{0} requires {1} argument(s)" \
                          "".format(func.action, message)
                raise KeyError(message)
            return func(*args, **kw)
        message = ' OR '.join(['+'.join(g) for g in groups])
        wrapper.__doc__ = "{0}\nRequired: {1}".format(func.__doc__,
                                                           message)
        return add_attrs_from(func, to=wrapper)
</source>
<source file="systems/boto-2.13.2/boto/mws/connection.py" startline="142" endline="159" pcid="1382">
    return decorator


def exclusive(*groups):

    def decorator(func):

        def wrapper(*args, **kw):
            hasgroup = lambda x: len(x) == len(filter(kw.has_key, x))
            if len(filter(hasgroup, groups)) not in (0, 1):
                message = ' OR '.join(['+'.join(g) for g in groups])
                message = "{0} requires either {1}" \
                          "".format(func.action, message)
                raise KeyError(message)
            return func(*args, **kw)
        message = ' OR '.join(['+'.join(g) for g in groups])
        wrapper.__doc__ = "{0}\nEither: {1}".format(func.__doc__,
                                                           message)
</source>
</class>

<class classid="29" nclones="2" nlines="15" similarity="100">
<source file="systems/boto-2.13.2/boto/cloudformation/connection.py" startline="152" endline="211" pcid="968">
    def create_stack(self, stack_name, template_body=None, template_url=None,
            parameters=[], notification_arns=[], disable_rollback=False,
            timeout_in_minutes=None, capabilities=None, tags=None):
        """
        Creates a CloudFormation Stack as specified by the template.

        :type stack_name: string
        :param stack_name: The name of the Stack, must be unique amoung running
                            Stacks

        :type template_body: string
        :param template_body: The template body (JSON string)

        :type template_url: string
        :param template_url: An S3 URL of a stored template JSON document. If
            both the template_body and template_url are
            specified, the template_body takes precedence

        :type parameters: list of tuples
        :param parameters: A list of (key, value) pairs for template input
            parameters.

        :type notification_arns: list of strings
        :param notification_arns: A list of SNS topics to send Stack event
            notifications to.

        :type disable_rollback: bool
        :param disable_rollback: Indicates whether or not to rollback on
            failure.

        :type timeout_in_minutes: int
        :param timeout_in_minutes: Maximum amount of time to let the Stack
            spend creating itself. If this timeout is exceeded,
            the Stack will enter the CREATE_FAILED state.

        :type capabilities: list
        :param capabilities: The list of capabilities you want to allow in
            the stack.  Currently, the only valid capability is
            'CAPABILITY_IAM'.

        :type tags: dict
        :param tags: A dictionary of (key, value) pairs of tags to
            associate with this stack.

        :rtype: string
        :return: The unique Stack ID.
        """
        params = self._build_create_or_update_params(stack_name,
            template_body, template_url, parameters, notification_arns,
            disable_rollback, timeout_in_minutes, capabilities, tags)
        response = self.make_request('CreateStack', params, '/', 'POST')
        body = response.read()
        if response.status == 200:
            body = json.loads(body)
            return body['CreateStackResponse']['CreateStackResult']['StackId']
        else:
            boto.log.error('%s %s' % (response.status, response.reason))
            boto.log.error('%s' % body)
            raise self.ResponseError(response.status, response.reason, body)

</source>
<source file="systems/boto-2.13.2/boto/cloudformation/connection.py" startline="212" endline="271" pcid="969">
    def update_stack(self, stack_name, template_body=None, template_url=None,
            parameters=[], notification_arns=[], disable_rollback=False,
            timeout_in_minutes=None, capabilities=None, tags=None):
        """
        Updates a CloudFormation Stack as specified by the template.

        :type stack_name: string
        :param stack_name: The name of the Stack, must be unique amoung running
            Stacks.

        :type template_body: string
        :param template_body: The template body (JSON string)

        :type template_url: string
        :param template_url: An S3 URL of a stored template JSON document. If
            both the template_body and template_url are
            specified, the template_body takes precedence.

        :type parameters: list of tuples
        :param parameters: A list of (key, value) pairs for template input
            parameters.

        :type notification_arns: list of strings
        :param notification_arns: A list of SNS topics to send Stack event
            notifications to.

        :type disable_rollback: bool
        :param disable_rollback: Indicates whether or not to rollback on
            failure.

        :type timeout_in_minutes: int
        :param timeout_in_minutes: Maximum amount of time to let the Stack
                            spend creating itself. If this timeout is exceeded,
                            the Stack will enter the CREATE_FAILED state

        :type capabilities: list
        :param capabilities: The list of capabilities you want to allow in
            the stack.  Currently, the only valid capability is
            'CAPABILITY_IAM'.

        :type tags: dict
        :param tags: A dictionary of (key, value) pairs of tags to
            associate with this stack.

        :rtype: string
        :return: The unique Stack ID.
        """
        params = self._build_create_or_update_params(stack_name,
            template_body, template_url, parameters, notification_arns,
            disable_rollback, timeout_in_minutes, capabilities, tags)
        response = self.make_request('UpdateStack', params, '/', 'POST')
        body = response.read()
        if response.status == 200:
            body = json.loads(body)
            return body['UpdateStackResponse']['UpdateStackResult']['StackId']
        else:
            boto.log.error('%s %s' % (response.status, response.reason))
            boto.log.error('%s' % body)
            raise self.ResponseError(response.status, response.reason, body)

</source>
</class>

<class classid="30" nclones="2" nlines="10" similarity="100">
<source file="systems/boto-2.13.2/boto/cloudformation/connection.py" startline="272" endline="283" pcid="970">
    def delete_stack(self, stack_name_or_id):
        params = {'ContentType': "JSON", 'StackName': stack_name_or_id}
        # TODO: change this to get_status ?
        response = self.make_request('DeleteStack', params, '/', 'GET')
        body = response.read()
        if response.status == 200:
            return json.loads(body)
        else:
            boto.log.error('%s %s' % (response.status, response.reason))
            boto.log.error('%s' % body)
            raise self.ResponseError(response.status, response.reason, body)

</source>
<source file="systems/boto-2.13.2/boto/cloudformation/connection.py" startline="325" endline="335" pcid="975">
    def get_template(self, stack_name_or_id):
        params = {'ContentType': "JSON", 'StackName': stack_name_or_id}
        response = self.make_request('GetTemplate', params, '/', 'GET')
        body = response.read()
        if response.status == 200:
            return json.loads(body)
        else:
            boto.log.error('%s %s' % (response.status, response.reason))
            boto.log.error('%s' % body)
            raise self.ResponseError(response.status, response.reason, body)

</source>
</class>

<class classid="31" nclones="2" nlines="13" similarity="84">
<source file="systems/boto-2.13.2/boto/auth.py" startline="590" endline="604" pcid="1032">
    def _calc_signature(self, params, *args):
        boto.log.debug('using _calc_signature_0')
        hmac = self._get_hmac()
        s = params['Action'] + params['Timestamp']
        hmac.update(s)
        keys = params.keys()
        keys.sort(cmp=lambda x, y: cmp(x.lower(), y.lower()))
        pairs = []
        for key in keys:
            val = boto.utils.get_utf8_value(params[key])
            pairs.append(key + '=' + urllib.quote(val))
        qs = '&'.join(pairs)
        return (qs, base64.b64encode(hmac.digest()))


</source>
<source file="systems/boto-2.13.2/boto/auth.py" startline="618" endline="632" pcid="1034">
    def _calc_signature(self, params, *args):
        boto.log.debug('using _calc_signature_1')
        hmac = self._get_hmac()
        keys = params.keys()
        keys.sort(cmp=lambda x, y: cmp(x.lower(), y.lower()))
        pairs = []
        for key in keys:
            hmac.update(key)
            val = boto.utils.get_utf8_value(params[key])
            hmac.update(val)
            pairs.append(key + '=' + urllib.quote(val))
        qs = '&'.join(pairs)
        return (qs, base64.b64encode(hmac.digest()))


</source>
</class>

<class classid="32" nclones="3" nlines="19" similarity="78">
<source file="systems/boto-2.13.2/boto/connection.py" startline="1052" endline="1071" pcid="1224">
        :type names: tuple of strings
        :param names: The names associated with each tuple element.

        """
        for i, item in enumerate(items, 1):
            current_prefix = '%s.%s' % (label, i)
            for key, value in zip(names, item):
                full_key = '%s.%s' % (current_prefix, key)
                params[full_key] = value

    # generics

    def get_list(self, action, params, markers, path='/',
                 parent=None, verb='GET'):
        if not parent:
            parent = self
        response = self.make_request(action, params, path, verb)
        body = response.read()
        boto.log.debug(body)
        if not body:
</source>
<source file="systems/boto-2.13.2/boto/connection.py" startline="1092" endline="1109" pcid="1226">
            boto.log.error('Null body %s' % body)
            raise self.ResponseError(response.status, response.reason, body)
        elif response.status == 200:
            obj = cls(parent)
            h = boto.handler.XmlHandler(obj, parent)
            xml.sax.parseString(body, h)
            return obj
        else:
            boto.log.error('%s %s' % (response.status, response.reason))
            boto.log.error('%s' % body)
            raise self.ResponseError(response.status, response.reason, body)

    def get_status(self, action, params, path='/', parent=None, verb='GET'):
        if not parent:
            parent = self
        response = self.make_request(action, params, path, verb)
        body = response.read()
        boto.log.debug(body)
</source>
<source file="systems/boto-2.13.2/boto/connection.py" startline="1072" endline="1091" pcid="1225">
            boto.log.error('Null body %s' % body)
            raise self.ResponseError(response.status, response.reason, body)
        elif response.status == 200:
            rs = ResultSet(markers)
            h = boto.handler.XmlHandler(rs, parent)
            xml.sax.parseString(body, h)
            return rs
        else:
            boto.log.error('%s %s' % (response.status, response.reason))
            boto.log.error('%s' % body)
            raise self.ResponseError(response.status, response.reason, body)

    def get_object(self, action, params, cls, path='/',
                   parent=None, verb='GET'):
        if not parent:
            parent = self
        response = self.make_request(action, params, path, verb)
        body = response.read()
        boto.log.debug(body)
        if not body:
</source>
</class>

<class classid="33" nclones="2" nlines="11" similarity="81">
<source file="systems/boto-2.13.2/boto/storage_uri.py" startline="480" endline="491" pcid="1263">
    def add_email_grant(self, permission, email_address, recursive=False,
                        validate=False, headers=None):
        self._check_bucket_uri('add_email_grant')
        if not self.object_name:
            bucket = self.get_bucket(validate, headers)
            bucket.add_email_grant(permission, email_address, recursive,
                                   headers)
        else:
            key = self.get_key(validate, headers)
            self.check_response(key, 'key', self.uri)
            key.add_email_grant(permission, email_address)

</source>
<source file="systems/boto-2.13.2/boto/storage_uri.py" startline="492" endline="502" pcid="1264">
    def add_user_grant(self, permission, user_id, recursive=False,
                       validate=False, headers=None):
        self._check_bucket_uri('add_user_grant')
        if not self.object_name:
            bucket = self.get_bucket(validate, headers)
            bucket.add_user_grant(permission, user_id, recursive, headers)
        else:
            key = self.get_key(validate, headers)
            self.check_response(key, 'key', self.uri)
            key.add_user_grant(permission, user_id)

</source>
</class>

<class classid="34" nclones="2" nlines="13" similarity="84">
<source file="systems/boto-2.13.2/boto/storage_uri.py" startline="579" endline="592" pcid="1280">
    def set_acl(self, acl_or_str, key_name='', validate=False, headers=None,
                version_id=None, if_generation=None, if_metageneration=None):
        """Sets or updates a bucket's ACL."""
        self._check_bucket_uri('set_acl')
        key_name = key_name or self.object_name or ''
        bucket = self.get_bucket(validate, headers)
        if self.generation:
          bucket.set_acl(
              acl_or_str, key_name, headers, generation=self.generation,
              if_generation=if_generation, if_metageneration=if_metageneration)
        else:
          version_id = version_id or self.version_id
          bucket.set_acl(acl_or_str, key_name, headers, version_id)

</source>
<source file="systems/boto-2.13.2/boto/storage_uri.py" startline="593" endline="607" pcid="1281">
    def set_xml_acl(self, xmlstring, key_name='', validate=False, headers=None,
            version_id=None, if_generation=None, if_metageneration=None):
        """Sets or updates a bucket's ACL with an XML string."""
        self._check_bucket_uri('set_xml_acl')
        key_name = key_name or self.object_name or ''
        bucket = self.get_bucket(validate, headers)
        if self.generation:
          bucket.set_xml_acl(
              xmlstring, key_name, headers, generation=self.generation,
              if_generation=if_generation, if_metageneration=if_metageneration)
        else:
          version_id = version_id or self.version_id
          bucket.set_xml_acl(xmlstring, key_name, headers,
                             version_id=version_id)

</source>
</class>

<class classid="35" nclones="3" nlines="10" similarity="72">
<source file="systems/boto-2.13.2/boto/mws/connection.py" startline="110" endline="123" pcid="1376">


def structured_objects(*fields):

    def decorator(func):

        def wrapper(*args, **kw):
            for field in filter(kw.has_key, fields):
                destructure_object(kw.pop(field), into=kw, prefix=field)
            return func(*args, **kw)
        wrapper.__doc__ = "{0}\nObjects: {1}".format(func.__doc__,
                                                   ', '.join(fields))
        return add_attrs_from(func, to=wrapper)
    return decorator
</source>
<source file="systems/boto-2.13.2/boto/mws/connection.py" startline="194" endline="207" pcid="1391">
        wrapper.__doc__ = "{0}\nSome Required: {1}".format(func.__doc__,
                                                         ', '.join(fields))
        return add_attrs_from(func, to=wrapper)
    return decorator


def boolean_arguments(*fields):

    def decorator(func):

        def wrapper(*args, **kw):
            for field in filter(lambda x: isinstance(kw.get(x), bool), fields):
                kw[field] = str(kw[field]).lower()
            return func(*args, **kw)
</source>
<source file="systems/boto-2.13.2/boto/mws/connection.py" startline="179" endline="193" pcid="1388">
                                                           message)
        return add_attrs_from(func, to=wrapper)
    return decorator


def requires_some_of(*fields):

    def decorator(func):

        def wrapper(*args, **kw):
            if not filter(kw.has_key, fields):
                message = "{0} requires at least one of {1} argument(s)" \
                          "".format(func.action, ', '.join(fields))
                raise KeyError(message)
            return func(*args, **kw)
</source>
</class>

<class classid="36" nclones="2" nlines="33" similarity="91">
<source file="systems/boto-2.13.2/boto/cloudfront/distribution.py" startline="106" endline="140" pcid="1475">
    def to_xml(self):
        s = '<?xml version="1.0" encoding="UTF-8"?>\n'
        s += '<DistributionConfig xmlns="http://cloudfront.amazonaws.com/doc/2010-07-15/">\n'
        if self.origin:
            s += self.origin.to_xml()
        s += '  <CallerReference>%s</CallerReference>\n' % self.caller_reference
        for cname in self.cnames:
            s += '  <CNAME>%s</CNAME>\n' % cname
        if self.comment:
            s += '  <Comment>%s</Comment>\n' % self.comment
        s += '  <Enabled>'
        if self.enabled:
            s += 'true'
        else:
            s += 'false'
        s += '</Enabled>\n'
        if self.trusted_signers:
            s += '<TrustedSigners>\n'
            for signer in self.trusted_signers:
                if signer == 'Self':
                    s += '  <Self></Self>\n'
                else:
                    s += '  <AwsAccountNumber>%s</AwsAccountNumber>\n' % signer
            s += '</TrustedSigners>\n'
        if self.logging:
            s += '<Logging>\n'
            s += '  <Bucket>%s</Bucket>\n' % self.logging.bucket
            s += '  <Prefix>%s</Prefix>\n' % self.logging.prefix
            s += '</Logging>\n'
        if self.default_root_object:
            dro = self.default_root_object
            s += '<DefaultRootObject>%s</DefaultRootObject>\n' % dro
        s += '</DistributionConfig>\n'
        return s

</source>
<source file="systems/boto-2.13.2/boto/cloudfront/distribution.py" startline="185" endline="216" pcid="1479">
    def to_xml(self):
        s = '<?xml version="1.0" encoding="UTF-8"?>\n'
        s += '<StreamingDistributionConfig xmlns="http://cloudfront.amazonaws.com/doc/2010-07-15/">\n'
        if self.origin:
            s += self.origin.to_xml()
        s += '  <CallerReference>%s</CallerReference>\n' % self.caller_reference
        for cname in self.cnames:
            s += '  <CNAME>%s</CNAME>\n' % cname
        if self.comment:
            s += '  <Comment>%s</Comment>\n' % self.comment
        s += '  <Enabled>'
        if self.enabled:
            s += 'true'
        else:
            s += 'false'
        s += '</Enabled>\n'
        if self.trusted_signers:
            s += '<TrustedSigners>\n'
            for signer in self.trusted_signers:
                if signer == 'Self':
                    s += '  <Self/>\n'
                else:
                    s += '  <AwsAccountNumber>%s</AwsAccountNumber>\n' % signer
            s += '</TrustedSigners>\n'
        if self.logging:
            s += '<Logging>\n'
            s += '  <Bucket>%s</Bucket>\n' % self.logging.bucket
            s += '  <Prefix>%s</Prefix>\n' % self.logging.prefix
            s += '</Logging>\n'
        s += '</StreamingDistributionConfig>\n'
        return s

</source>
</class>

<class classid="37" nclones="2" nlines="14" similarity="73">
<source file="systems/boto-2.13.2/boto/cloudfront/__init__.py" startline="82" endline="97" pcid="1536">
    def _get_info(self, id, resource, dist_class):
        uri = '/%s/%s/%s' % (self.Version, resource, id)
        response = self.make_request('GET', uri)
        body = response.read()
        boto.log.debug(body)
        if response.status >= 300:
            raise CloudFrontServerError(response.status, response.reason, body)
        d = dist_class(connection=self)
        response_headers = response.msg
        for key in response_headers.keys():
            if key.lower() == 'etag':
                d.etag = response_headers[key]
        h = handler.XmlHandler(d, self)
        xml.sax.parseString(body, h)
        return d

</source>
<source file="systems/boto-2.13.2/boto/cloudfront/__init__.py" startline="98" endline="110" pcid="1537">
    def _get_config(self, id, resource, config_class):
        uri = '/%s/%s/%s/config' % (self.Version, resource, id)
        response = self.make_request('GET', uri)
        body = response.read()
        boto.log.debug(body)
        if response.status >= 300:
            raise CloudFrontServerError(response.status, response.reason, body)
        d = config_class(connection=self)
        d.etag = self.get_etag(response)
        h = handler.XmlHandler(d, self)
        xml.sax.parseString(body, h)
        return d

</source>
</class>

<class classid="38" nclones="4" nlines="23" similarity="91">
<source file="systems/boto-2.13.2/boto/support/layer1.py" startline="506" endline="529" pcid="1776">
    def make_request(self, action, body):
        headers = {
            'X-Amz-Target': '%s.%s' % (self.TargetPrefix, action),
            'Host': self.region.endpoint,
            'Content-Type': 'application/x-amz-json-1.1',
            'Content-Length': str(len(body)),
        }
        http_request = self.build_base_http_request(
            method='POST', path='/', auth_path='/', params={},
            headers=headers, data=body)
        response = self._mexe(http_request, sender=None,
                              override_num_retries=10)
        response_body = response.read()
        boto.log.debug(response_body)
        if response.status == 200:
            if response_body:
                return json.loads(response_body)
        else:
            json_body = json.loads(response_body)
            fault_name = json_body.get('__type', None)
            exception_class = self._faults.get(fault_name, self.ResponseError)
            raise exception_class(response.status, response.reason,
                                  body=json_body)

</source>
<source file="systems/boto-2.13.2/boto/opsworks/layer1.py" startline="1937" endline="1960" pcid="3073">
    def make_request(self, action, body):
        headers = {
            'X-Amz-Target': '%s.%s' % (self.TargetPrefix, action),
            'Host': self.region.endpoint,
            'Content-Type': 'application/x-amz-json-1.1',
            'Content-Length': str(len(body)),
        }
        http_request = self.build_base_http_request(
            method='POST', path='/', auth_path='/', params={},
            headers=headers, data=body)
        response = self._mexe(http_request, sender=None,
                              override_num_retries=10)
        response_body = response.read()
        boto.log.debug(response_body)
        if response.status == 200:
            if response_body:
                return json.loads(response_body)
        else:
            json_body = json.loads(response_body)
            fault_name = json_body.get('__type', None)
            exception_class = self._faults.get(fault_name, self.ResponseError)
            raise exception_class(response.status, response.reason,
                                  body=json_body)

</source>
<source file="systems/boto-2.13.2/boto/datapipeline/layer1.py" startline="618" endline="641" pcid="2987">
    def make_request(self, action, body):
        headers = {
            'X-Amz-Target': '%s.%s' % (self.TargetPrefix, action),
            'Host': self.region.endpoint,
            'Content-Type': 'application/x-amz-json-1.1',
            'Content-Length': str(len(body)),
        }
        http_request = self.build_base_http_request(
            method='POST', path='/', auth_path='/', params={},
            headers=headers, data=body)
        response = self._mexe(http_request, sender=None,
                              override_num_retries=10)
        response_body = response.read()
        boto.log.debug(response_body)
        if response.status == 200:
            if response_body:
                return json.loads(response_body)
        else:
            json_body = json.loads(response_body)
            fault_name = json_body.get('__type', None)
            exception_class = self._faults.get(fault_name, self.ResponseError)
            raise exception_class(response.status, response.reason,
                                  body=json_body)

</source>
<source file="systems/boto-2.13.2/boto/dynamodb2/layer1.py" startline="1467" endline="1491" pcid="1868">
    def make_request(self, action, body):
        headers = {
            'X-Amz-Target': '%s.%s' % (self.TargetPrefix, action),
            'Host': self.region.endpoint,
            'Content-Type': 'application/x-amz-json-1.0',
            'Content-Length': str(len(body)),
        }
        http_request = self.build_base_http_request(
            method='POST', path='/', auth_path='/', params={},
            headers=headers, data=body)
        response = self._mexe(http_request, sender=None,
                              override_num_retries=self.NumberRetries,
                              retry_handler=self._retry_handler)
        response_body = response.read()
        boto.log.debug(response_body)
        if response.status == 200:
            if response_body:
                return json.loads(response_body)
        else:
            json_body = json.loads(response_body)
            fault_name = json_body.get('__type', None)
            exception_class = self._faults.get(fault_name, self.ResponseError)
            raise exception_class(response.status, response.reason,
                                  body=json_body)

</source>
</class>

<class classid="39" nclones="2" nlines="35" similarity="82">
<source file="systems/boto-2.13.2/boto/dynamodb2/table.py" startline="797" endline="849" pcid="1836">

    def _query(self, limit=None, index=None, reverse=False, consistent=False,
               exclusive_start_key=None, select=None, attributes_to_get=None,
               **filter_kwargs):
        """
        The internal method that performs the actual queries. Used extensively
        by ``ResultSet`` to perform each (paginated) request.
        """
        kwargs = {
            'limit': limit,
            'index_name': index,
            'scan_index_forward': reverse,
            'consistent_read': consistent,
            'select': select,
            'attributes_to_get': attributes_to_get
        }

        if exclusive_start_key:
            kwargs['exclusive_start_key'] = {}

            for key, value in exclusive_start_key.items():
                kwargs['exclusive_start_key'][key] = \
                    self._dynamizer.encode(value)

        # Convert the filters into something we can actually use.
        kwargs['key_conditions'] = self._build_filters(
            filter_kwargs,
            using=QUERY_OPERATORS
        )

        raw_results = self.connection.query(
            self.table_name,
            **kwargs
        )
        results = []
        last_key = None

        for raw_item in raw_results.get('Items', []):
            item = Item(self)
            item.load({
                'Item': raw_item,
            })
            results.append(item)

        if raw_results.get('LastEvaluatedKey', None):
            last_key = {}

            for key, value in raw_results['LastEvaluatedKey'].items():
                last_key[key] = self._dynamizer.decode(value)

        return {
            'results': results,
            'last_key': last_key,
</source>
<source file="systems/boto-2.13.2/boto/dynamodb2/table.py" startline="903" endline="951" pcid="1838">
        return results

    def _scan(self, limit=None, exclusive_start_key=None, segment=None,
              total_segments=None, **filter_kwargs):
        """
        The internal method that performs the actual scan. Used extensively
        by ``ResultSet`` to perform each (paginated) request.
        """
        kwargs = {
            'limit': limit,
            'segment': segment,
            'total_segments': total_segments,
        }

        if exclusive_start_key:
            kwargs['exclusive_start_key'] = {}

            for key, value in exclusive_start_key.items():
                kwargs['exclusive_start_key'][key] = \
                    self._dynamizer.encode(value)

        # Convert the filters into something we can actually use.
        kwargs['scan_filter'] = self._build_filters(
            filter_kwargs,
            using=FILTER_OPERATORS
        )

        raw_results = self.connection.scan(
            self.table_name,
            **kwargs
        )
        results = []
        last_key = None

        for raw_item in raw_results.get('Items', []):
            item = Item(self)
            item.load({
                'Item': raw_item,
            })
            results.append(item)

        if raw_results.get('LastEvaluatedKey', None):
            last_key = {}

            for key, value in raw_results['LastEvaluatedKey'].items():
                last_key[key] = self._dynamizer.decode(value)

        return {
            'results': results,
</source>
</class>

<class classid="40" nclones="2" nlines="38" similarity="78">
<source file="systems/boto-2.13.2/boto/dynamodb2/layer1.py" startline="1492" endline="1534" pcid="1869">
    def _retry_handler(self, response, i, next_sleep):
        status = None
        boto.log.debug("Saw HTTP status: %s" % response.status)
        if response.status == 400:
            response_body = response.read()
            boto.log.debug(response_body)
            data = json.loads(response_body)
            if 'ProvisionedThroughputExceededException' in data.get('__type'):
                self.throughput_exceeded_events += 1
                msg = "%s, retry attempt %s" % (
                    'ProvisionedThroughputExceededException',
                    i
                )
                next_sleep = self._exponential_time(i)
                i += 1
                status = (msg, i, next_sleep)
                if i == self.NumberRetries:
                    # If this was our last retry attempt, raise
                    # a specific error saying that the throughput
                    # was exceeded.
                    raise exceptions.ProvisionedThroughputExceededException(
                        response.status, response.reason, data)
            elif 'ConditionalCheckFailedException' in data.get('__type'):
                raise exceptions.ConditionalCheckFailedException(
                    response.status, response.reason, data)
            elif 'ValidationException' in data.get('__type'):
                raise exceptions.ValidationException(
                    response.status, response.reason, data)
            else:
                raise self.ResponseError(response.status, response.reason,
                                         data)
        expected_crc32 = response.getheader('x-amz-crc32')
        if self._validate_checksums and expected_crc32 is not None:
            boto.log.debug('Validating crc32 checksum for body: %s',
                           response.read())
            actual_crc32 = crc32(response.read()) & 0xffffffff
            expected_crc32 = int(expected_crc32)
            if actual_crc32 != expected_crc32:
                msg = ("The calculated checksum %s did not match the expected "
                       "checksum %s" % (actual_crc32, expected_crc32))
                status = (msg, i + 1, self._exponential_time(i))
        return status

</source>
<source file="systems/boto-2.13.2/boto/dynamodb/layer1.py" startline="128" endline="170" pcid="4093">
    def _retry_handler(self, response, i, next_sleep):
        status = None
        if response.status == 400:
            response_body = response.read()
            boto.log.debug(response_body)
            data = json.loads(response_body)
            if self.ThruputError in data.get('__type'):
                self.throughput_exceeded_events += 1
                msg = "%s, retry attempt %s" % (self.ThruputError, i)
                next_sleep = self._exponential_time(i)
                i += 1
                status = (msg, i, next_sleep)
                if i == self.NumberRetries:
                    # If this was our last retry attempt, raise
                    # a specific error saying that the throughput
                    # was exceeded.
                    raise dynamodb_exceptions.DynamoDBThroughputExceededError(
                        response.status, response.reason, data)
            elif self.SessionExpiredError in data.get('__type'):
                msg = 'Renewing Session Token'
                self._get_session_token()
                status = (msg, i + self.num_retries - 1, 0)
            elif self.ConditionalCheckFailedError in data.get('__type'):
                raise dynamodb_exceptions.DynamoDBConditionalCheckFailedError(
                    response.status, response.reason, data)
            elif self.ValidationError in data.get('__type'):
                raise dynamodb_exceptions.DynamoDBValidationError(
                    response.status, response.reason, data)
            else:
                raise self.ResponseError(response.status, response.reason,
                                         data)
        expected_crc32 = response.getheader('x-amz-crc32')
        if self._validate_checksums and expected_crc32 is not None:
            boto.log.debug('Validating crc32 checksum for body: %s',
                           response.read())
            actual_crc32 = crc32(response.read()) & 0xffffffff
            expected_crc32 = int(expected_crc32)
            if actual_crc32 != expected_crc32:
                msg = ("The calculated checksum %s did not match the expected "
                       "checksum %s" % (actual_crc32, expected_crc32))
                status = (msg, i + 1, self._exponential_time(i))
        return status

</source>
</class>

<class classid="41" nclones="2" nlines="12" similarity="75">
<source file="systems/boto-2.13.2/boto/manage/server.py" startline="190" endline="202" pcid="1918">
    def get_group(self, params):
        group = params.get('group', None)
        if isinstance(group, str) or isinstance(group, unicode):
            group_list = self.ec2.get_all_security_groups()
            for g in group_list:
                if g.name == group:
                    group = g
                    params['group'] = g
        if not group:
            prop = StringProperty(name='group', verbose_name='EC2 Security Group',
                                  choices=self.ec2.get_all_security_groups)
            params['group'] = propget.get(prop)

</source>
<source file="systems/boto-2.13.2/boto/manage/server.py" startline="203" endline="215" pcid="1919">
    def get_key(self, params):
        keypair = params.get('keypair', None)
        if isinstance(keypair, str) or isinstance(keypair, unicode):
            key_list = self.ec2.get_all_key_pairs()
            for k in key_list:
                if k.name == keypair:
                    keypair = k.name
                    params['keypair'] = k.name
        if not keypair:
            prop = StringProperty(name='keypair', verbose_name='EC2 KeyPair',
                                  choices=self.ec2.get_all_key_pairs)
            params['keypair'] = propget.get(prop).name

</source>
</class>

<class classid="42" nclones="2" nlines="18" similarity="73">
<source file="systems/boto-2.13.2/boto/rds/optiongroup.py" startline="119" endline="139" pcid="2243">
    def __init__(self, name=None, description=None, permanent=False,
                 persistent=False, port=None, settings=None,
                 db_security_groups=None, vpc_security_groups=None):
        self.name = name
        self.description = description
        self.permanent = permanent
        self.persistent = persistent
        self.port = port
        self.settings = settings
        self.db_security_groups = db_security_groups
        self.vpc_security_groups = vpc_security_groups

        if self.settings is None:
            self.settings = []

        if self.db_security_groups is None:
            self.db_security_groups = []

        if self.vpc_security_groups is None:
            self.vpc_security_groups = []

</source>
<source file="systems/boto-2.13.2/boto/rds/optiongroup.py" startline="288" endline="309" pcid="2255">
    def __init__(self, name=None, description=None, engine_name=None,
                 major_engine_version=None, min_minor_engine_version=None,
                 permanent=False, persistent=False, port_required=False,
                 default_port=None, settings=None, depends_on=None):
        self.name = name
        self.description = description
        self.engine_name = engine_name
        self.major_engine_version = major_engine_version
        self.min_minor_engine_version = min_minor_engine_version
        self.permanent = permanent
        self.persistent = persistent
        self.port_required = port_required
        self.default_port = default_port
        self.settings = settings
        self.depends_on = depends_on

        if self.settings is None:
            self.settings = []

        if self.depends_on is None:
            self.depends_on = []

</source>
</class>

<class classid="43" nclones="3" nlines="10" similarity="72">
<source file="systems/boto-2.13.2/boto/rds/dbsecuritygroup.py" startline="58" endline="69" pcid="2297">
    def startElement(self, name, attrs, connection):
        if name == 'IPRange':
            cidr = IPRange(self)
            self.ip_ranges.append(cidr)
            return cidr
        elif name == 'EC2SecurityGroup':
            ec2_grp = EC2SecurityGroup(self)
            self.ec2_groups.append(ec2_grp)
            return ec2_grp
        else:
            return None

</source>
<source file="systems/boto-2.13.2/boto/s3/multidelete.py" startline="125" endline="135" pcid="3495">
    def startElement(self, name, attrs, connection):
        if name == 'Deleted':
            d = Deleted()
            self.deleted.append(d)
            return d
        elif name == 'Error':
            e = Error()
            self.errors.append(e)
            return e
        return None

</source>
<source file="systems/boto-2.13.2/boto/sqs/batchresults.py" startline="81" endline="91" pcid="3627">
    def startElement(self, name, attrs, connection):
        if name.endswith('MessageBatchResultEntry'):
            entry = ResultEntry()
            self.results.append(entry)
            return entry
        if name == 'BatchResultErrorEntry':
            entry = ResultEntry()
            self.errors.append(entry)
            return entry
        return None

</source>
</class>

<class classid="44" nclones="3" nlines="19" similarity="80">
<source file="systems/boto-2.13.2/boto/rds/__init__.py" startline="35" endline="62" pcid="2310">
def regions():
    """
    Get all available regions for the RDS service.

    :rtype: list
    :return: A list of :class:`boto.rds.regioninfo.RDSRegionInfo`
    """
    return [RDSRegionInfo(name='us-east-1',
                          endpoint='rds.amazonaws.com'),
            RDSRegionInfo(name='us-gov-west-1',
                          endpoint='rds.us-gov-west-1.amazonaws.com'),
            RDSRegionInfo(name='eu-west-1',
                          endpoint='rds.eu-west-1.amazonaws.com'),
            RDSRegionInfo(name='us-west-1',
                          endpoint='rds.us-west-1.amazonaws.com'),
            RDSRegionInfo(name='us-west-2',
                          endpoint='rds.us-west-2.amazonaws.com'),
            RDSRegionInfo(name='sa-east-1',
                          endpoint='rds.sa-east-1.amazonaws.com'),
            RDSRegionInfo(name='ap-northeast-1',
                          endpoint='rds.ap-northeast-1.amazonaws.com'),
            RDSRegionInfo(name='ap-southeast-1',
                          endpoint='rds.ap-southeast-1.amazonaws.com'),
            RDSRegionInfo(name='ap-southeast-2',
                          endpoint='rds.ap-southeast-2.amazonaws.com'),
            ]


</source>
<source file="systems/boto-2.13.2/boto/sqs/__init__.py" startline="26" endline="53" pcid="3713">
def regions():
    """
    Get all available regions for the SQS service.

    :rtype: list
    :return: A list of :class:`boto.sqs.regioninfo.RegionInfo`
    """
    return [SQSRegionInfo(name='us-east-1',
                          endpoint='queue.amazonaws.com'),
            SQSRegionInfo(name='us-gov-west-1',
                          endpoint='sqs.us-gov-west-1.amazonaws.com'),
            SQSRegionInfo(name='eu-west-1',
                          endpoint='eu-west-1.queue.amazonaws.com'),
            SQSRegionInfo(name='us-west-1',
                          endpoint='us-west-1.queue.amazonaws.com'),
            SQSRegionInfo(name='us-west-2',
                          endpoint='us-west-2.queue.amazonaws.com'),
            SQSRegionInfo(name='sa-east-1',
                          endpoint='sa-east-1.queue.amazonaws.com'),
            SQSRegionInfo(name='ap-northeast-1',
                          endpoint='ap-northeast-1.queue.amazonaws.com'),
            SQSRegionInfo(name='ap-southeast-1',
                          endpoint='ap-southeast-1.queue.amazonaws.com'),
            SQSRegionInfo(name='ap-southeast-2',
                          endpoint='ap-southeast-2.queue.amazonaws.com')
            ]


</source>
<source file="systems/boto-2.13.2/boto/sdb/__init__.py" startline="26" endline="51" pcid="2846">
def regions():
    """
    Get all available regions for the SDB service.

    :rtype: list
    :return: A list of :class:`boto.sdb.regioninfo.RegionInfo` instances
    """
    return [SDBRegionInfo(name='us-east-1',
                          endpoint='sdb.amazonaws.com'),
            SDBRegionInfo(name='eu-west-1',
                          endpoint='sdb.eu-west-1.amazonaws.com'),
            SDBRegionInfo(name='us-west-1',
                          endpoint='sdb.us-west-1.amazonaws.com'),
            SDBRegionInfo(name='sa-east-1',
                          endpoint='sdb.sa-east-1.amazonaws.com'),
            SDBRegionInfo(name='us-west-2',
                          endpoint='sdb.us-west-2.amazonaws.com'),
            SDBRegionInfo(name='ap-northeast-1',
                          endpoint='sdb.ap-northeast-1.amazonaws.com'),
            SDBRegionInfo(name='ap-southeast-1',
                          endpoint='sdb.ap-southeast-1.amazonaws.com'),
            SDBRegionInfo(name='ap-southeast-2',
                          endpoint='sdb.ap-southeast-2.amazonaws.com')
            ]


</source>
</class>

<class classid="45" nclones="2" nlines="14" similarity="73">
<source file="systems/boto-2.13.2/boto/rds/__init__.py" startline="1386" endline="1431" pcid="2343">
    def describe_option_groups(self, name=None, engine_name=None,
                               major_engine_version=None, max_records=100,
                               marker=None):
        """
        Describes the available option groups.

        :type name: str
        :param name: The name of the option group to describe. Cannot be
                     supplied together with engine_name or major_engine_version.

        :type engine_name: str
        :param engine_name: Filters the list of option groups to only include
                            groups associated with a specific database engine.

        :type major_engine_version: datetime
        :param major_engine_version: Filters the list of option groups to only
                                     include groups associated with a specific
                                     database engine version. If specified, then
                                     engine_name must also be specified.

        :type max_records: int
        :param max_records: The maximum number of records to be returned.
                            If more results are available, a MoreToken will
                            be returned in the response that can be used to
                            retrieve additional records.  Default is 100.

        :type marker: str
        :param marker: The marker provided by a previous request.

        :rtype: list
        :return: A list of class:`boto.rds.optiongroup.OptionGroup`
        """
        params = {}
        if name:
            params['OptionGroupName'] = name
        elif engine_name and major_engine_version:
            params['EngineName'] = engine_name
            params['MajorEngineVersion'] = major_engine_version
        if max_records:
            params['MaxRecords'] = int(max_records)
        if marker:
            params['Marker'] = marker
        return self.get_list('DescribeOptionGroups', params, [
            ('OptionGroup', OptionGroup)
        ])

</source>
<source file="systems/boto-2.13.2/boto/rds/__init__.py" startline="1432" endline="1470" pcid="2344">
    def describe_option_group_options(self, engine_name=None,
                               major_engine_version=None, max_records=100,
                               marker=None):
        """
        Describes the available option group options.

        :type engine_name: str
        :param engine_name: Filters the list of option groups to only include
                            groups associated with a specific database engine.

        :type major_engine_version: datetime
        :param major_engine_version: Filters the list of option groups to only
                                     include groups associated with a specific
                                     database engine version. If specified, then
                                     engine_name must also be specified.

        :type max_records: int
        :param max_records: The maximum number of records to be returned.
                            If more results are available, a MoreToken will
                            be returned in the response that can be used to
                            retrieve additional records.  Default is 100.

        :type marker: str
        :param marker: The marker provided by a previous request.

        :rtype: list
        :return: A list of class:`boto.rds.optiongroup.Option`
        """
        params = {}
        if engine_name and major_engine_version:
            params['EngineName'] = engine_name
            params['MajorEngineVersion'] = major_engine_version
        if max_records:
            params['MaxRecords'] = int(max_records)
        if marker:
            params['Marker'] = marker
        return self.get_list('DescribeOptionGroupOptions', params, [
            ('OptionGroupOptions', OptionGroupOption)
        ])
</source>
</class>

<class classid="46" nclones="2" nlines="10" similarity="80">
<source file="systems/boto-2.13.2/boto/cloudsearch/search.py" startline="318" endline="339" pcid="2383">
    def get_all_paged(self, query, per_page):
        """Get a generator to iterate over all pages of search results

        :type query: :class:`boto.cloudsearch.search.Query`
        :param query: A group of search criteria

        :type per_page: int
        :param per_page: Number of docs in each :class:`boto.cloudsearch.search.SearchResults` object.

        :rtype: generator
        :return: Generator containing :class:`boto.cloudsearch.search.SearchResults`
        """
        query.update_size(per_page)
        page = 0
        num_pages_needed = 0
        while page <= num_pages_needed:
            results = self(query)
            num_pages_needed = results.num_pages_needed
            yield results
            query.start += query.real_size
            page += 1

</source>
<source file="systems/boto-2.13.2/boto/cloudsearch/search.py" startline="340" endline="363" pcid="2384">
    def get_all_hits(self, query):
        """Get a generator to iterate over all search results

        Transparently handles the results paging from Cloudsearch
        search results so even if you have many thousands of results
        you can iterate over all results in a reasonably efficient
        manner.

        :type query: :class:`boto.cloudsearch.search.Query`
        :param query: A group of search criteria

        :rtype: generator
        :return: All docs matching query
        """
        page = 0
        num_pages_needed = 0
        while page <= num_pages_needed:
            results = self(query)
            num_pages_needed = results.num_pages_needed
            for doc in results:
                yield doc
            query.start += query.real_size
            page += 1

</source>
</class>

<class classid="47" nclones="3" nlines="11" similarity="81">
<source file="systems/boto-2.13.2/boto/cloudsearch/layer1.py" startline="397" endline="417" pcid="2442">
    def describe_domains(self, domain_names=None):
        """
        Describes the domains (optionally limited to one or more
        domains by name) owned by this account.

        :type domain_names: list
        :param domain_names: Limits the response to the specified domains.

        :raises: BaseException, InternalException
        """
        doc_path = ('describe_domains_response',
                    'describe_domains_result',
                    'domain_status_list')
        params = {}
        if domain_names:
            for i, domain_name in enumerate(domain_names, 1):
                params['DomainNames.member.%d' % i] = domain_name
        return self.get_response(doc_path, 'DescribeDomains',
                                 params, verb='POST',
                                 list_marker='DomainStatusList')

</source>
<source file="systems/boto-2.13.2/boto/cloudsearch/layer1.py" startline="448" endline="477" pcid="2444">
    def describe_rank_expressions(self, domain_name, rank_names=None):
        """
        Describes RankExpressions in the search domain, optionally
        limited to a single expression.

        :type domain_name: string
        :param domain_name: A string that represents the name of a
            domain. Domain names must be unique across the domains
            owned by an account within an AWS region. Domain names
            must start with a letter or number and can contain the
            following characters: a-z (lowercase), 0-9, and -
            (hyphen). Uppercase letters and underscores are not
            allowed.

        :type rank_names: list
        :param rank_names: Limit response to the specified rank names.

        :raises: BaseException, InternalException, ResourceNotFoundException
        """
        doc_path = ('describe_rank_expressions_response',
                    'describe_rank_expressions_result',
                    'rank_expressions')
        params = {'DomainName': domain_name}
        if rank_names:
            for i, rank_name in enumerate(rank_names, 1):
                params['RankNames.member.%d' % i] = rank_name
        return self.get_response(doc_path, 'DescribeRankExpressions',
                                 params, verb='POST',
                                 list_marker='RankExpressions')

</source>
<source file="systems/boto-2.13.2/boto/cloudsearch/layer1.py" startline="418" endline="447" pcid="2443">
    def describe_index_fields(self, domain_name, field_names=None):
        """
        Describes index fields in the search domain, optionally
        limited to a single ``IndexField``.

        :type domain_name: string
        :param domain_name: A string that represents the name of a
            domain. Domain names must be unique across the domains
            owned by an account within an AWS region. Domain names
            must start with a letter or number and can contain the
            following characters: a-z (lowercase), 0-9, and -
            (hyphen). Uppercase letters and underscores are not
            allowed.

        :type field_names: list
        :param field_names: Limits the response to the specified fields.

        :raises: BaseException, InternalException, ResourceNotFoundException
        """
        doc_path = ('describe_index_fields_response',
                    'describe_index_fields_result',
                    'index_fields')
        params = {'DomainName': domain_name}
        if field_names:
            for i, field_name in enumerate(field_names, 1):
                params['FieldNames.member.%d' % i] = field_name
        return self.get_response(doc_path, 'DescribeIndexFields',
                                 params, verb='POST',
                                 list_marker='IndexFields')

</source>
</class>

<class classid="48" nclones="2" nlines="15" similarity="80">
<source file="systems/boto-2.13.2/boto/sdb/queryresultset.py" startline="22" endline="37" pcid="2548">
def query_lister(domain, query='', max_items=None, attr_names=None):
    more_results = True
    num_results = 0
    next_token = None
    while more_results:
        rs = domain.connection.query_with_attributes(domain, query, attr_names,
                                                     next_token=next_token)
        for item in rs:
            if max_items:
                if num_results == max_items:
                    raise StopIteration
            yield item
            num_results += 1
        next_token = rs.next_token
        more_results = next_token != None
        
</source>
<source file="systems/boto-2.13.2/boto/sdb/queryresultset.py" startline="49" endline="63" pcid="2551">
def select_lister(domain, query='', max_items=None):
    more_results = True
    num_results = 0
    next_token = None
    while more_results:
        rs = domain.connection.select(domain, query, next_token=next_token)
        for item in rs:
            if max_items:
                if num_results == max_items:
                    raise StopIteration
            yield item
            num_results += 1
        next_token = rs.next_token
        more_results = next_token != None
        
</source>
</class>

<class classid="49" nclones="2" nlines="20" similarity="80">
<source file="systems/boto-2.13.2/boto/sdb/db/property.py" startline="622" endline="644" pcid="2838">
    def validate(self, value):
        if self.validator:
            self.validator(value)
        if value is not None:
            if not isinstance(value, list):
                value = [value]

        if self.item_type in (int, long):
            item_type = (int, long)
        elif self.item_type in (str, unicode):
            item_type = (str, unicode)
        else:
            item_type = self.item_type

        for item in value:
            if not isinstance(item, item_type):
                if item_type == (int, long):
                    raise ValueError('Items in the %s list must all be integers.' % self.name)
                else:
                    raise ValueError('Items in the %s list must all be %s instances' %
                                     (self.name, self.item_type.__name__))
        return value

</source>
<source file="systems/boto-2.13.2/boto/sdb/db/property.py" startline="677" endline="698" pcid="2843">
    def validate(self, value):
        value = super(MapProperty, self).validate(value)
        if value is not None:
            if not isinstance(value, dict):
                raise ValueError('Value must of type dict')

        if self.item_type in (int, long):
            item_type = (int, long)
        elif self.item_type in (str, unicode):
            item_type = (str, unicode)
        else:
            item_type = self.item_type

        for key in value:
            if not isinstance(value[key], item_type):
                if item_type == (int, long):
                    raise ValueError('Values in the %s Map must all be integers.' % self.name)
                else:
                    raise ValueError('Values in the %s Map must all be %s instances' %
                                     (self.name, self.item_type.__name__))
        return value

</source>
</class>

<class classid="50" nclones="2" nlines="11" similarity="100">
<source file="systems/boto-2.13.2/boto/jsonresponse.py" startline="72" endline="83" pcid="2961">
    def __getattr__(self, key):
        if key in self:
            return self[key]
        for k in self:
            e = self[k]
            if isinstance(e, Element):
                try:
                    return getattr(e, key)
                except AttributeError:
                    pass
        raise AttributeError

</source>
<source file="systems/boto-2.13.2/boto/core/dictresponse.py" startline="86" endline="97" pcid="3612">
    def __getattr__(self, key):
        if key in self:
            return self[key]
        for k in self:
            e = self[k]
            if isinstance(e, Element):
                try:
                    return getattr(e, key)
                except AttributeError:
                    pass
        raise AttributeError

</source>
</class>

<class classid="51" nclones="2" nlines="17" similarity="100">
<source file="systems/boto-2.13.2/boto/jsonresponse.py" startline="89" endline="106" pcid="2963">
    def startElement(self, name, attrs, connection):
        self.stack.append(name)
        for lm in self.list_marker:
            if name.endswith(lm):
                l = ListElement(self.connection, name, self.list_marker,
                                self.item_marker, self.pythonize_name)
                self[self.get_name(name)] = l
                return l
        if len(self.stack) > 0:
            element_name = self.stack[-1]
            e = Element(self.connection, element_name, self.stack, self,
                        self.list_marker, self.item_marker,
                        self.pythonize_name)
            self[self.get_name(element_name)] = e
            return (element_name, e)
        else:
            return None

</source>
<source file="systems/boto-2.13.2/boto/core/dictresponse.py" startline="103" endline="120" pcid="3614">
    def startElement(self, name, attrs, connection):
        self.stack.append(name)
        for lm in self.list_marker:
            if name.endswith(lm):
                l = ListElement(self.connection, name, self.list_marker,
                                self.item_marker, self.pythonize_name)
                self[self.get_name(name)] = l
                return l
        if len(self.stack) > 0:
            element_name = self.stack[-1]
            e = Element(self.connection, element_name, self.stack, self,
                        self.list_marker, self.item_marker,
                        self.pythonize_name)
            self[self.get_name(element_name)] = e
            return (element_name, e)
        else:
            return None

</source>
</class>

<class classid="52" nclones="2" nlines="17" similarity="100">
<source file="systems/boto-2.13.2/boto/jsonresponse.py" startline="134" endline="151" pcid="2967">
    def startElement(self, name, attrs, connection):
        for lm in self.list_marker:
            if name.endswith(lm):
                l = ListElement(self.connection, name,
                                self.list_marker, self.item_marker,
                                self.pythonize_name)
                setattr(self, self.get_name(name), l)
                return l
        if name in self.item_marker:
            e = Element(self.connection, name, parent=self,
                        list_marker=self.list_marker,
                        item_marker=self.item_marker,
                        pythonize_name=self.pythonize_name)
            self.append(e)
            return e
        else:
            return None

</source>
<source file="systems/boto-2.13.2/boto/core/dictresponse.py" startline="149" endline="166" pcid="3618">
    def startElement(self, name, attrs, connection):
        for lm in self.list_marker:
            if name.endswith(lm):
                l = ListElement(self.connection, name,
                                self.list_marker, self.item_marker,
                                self.pythonize_name)
                setattr(self, self.get_name(name), l)
                return l
        if name in self.item_marker:
            e = Element(self.connection, name, parent=self,
                        list_marker=self.list_marker,
                        item_marker=self.item_marker,
                        pythonize_name=self.pythonize_name)
            self.append(e)
            return e
        else:
            return None

</source>
</class>

<class classid="53" nclones="2" nlines="12" similarity="100">
<source file="systems/boto-2.13.2/boto/jsonresponse.py" startline="152" endline="163" pcid="2968">
    def endElement(self, name, value, connection):
        if name == self.element_name:
            if len(self) > 0:
                empty = []
                for e in self:
                    if isinstance(e, Element):
                        if len(e) == 0:
                            empty.append(e)
                for e in empty:
                    self.remove(e)
        else:
            setattr(self, self.get_name(name), value)
</source>
<source file="systems/boto-2.13.2/boto/core/dictresponse.py" startline="167" endline="178" pcid="3619">
    def endElement(self, name, value, connection):
        if name == self.element_name:
            if len(self) > 0:
                empty = []
                for e in self:
                    if isinstance(e, Element):
                        if len(e) == 0:
                            empty.append(e)
                for e in empty:
                    self.remove(e)
        else:
            setattr(self, self.get_name(name), value)
</source>
</class>

<class classid="54" nclones="2" nlines="14" similarity="73">
<source file="systems/boto-2.13.2/boto/vpc/__init__.py" startline="310" endline="349" pcid="3187">
    def create_route(self, route_table_id, destination_cidr_block,
                     gateway_id=None, instance_id=None, dry_run=False):
        """
        Creates a new route in the route table within a VPC. The route's target
        can be either a gateway attached to the VPC or a NAT instance in the
        VPC.

        :type route_table_id: str
        :param route_table_id: The ID of the route table for the route.

        :type destination_cidr_block: str
        :param destination_cidr_block: The CIDR address block used for the
                                       destination match.

        :type gateway_id: str
        :param gateway_id: The ID of the gateway attached to your VPC.

        :type instance_id: str
        :param instance_id: The ID of a NAT instance in your VPC.

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: bool
        :return: True if successful
        """
        params = {
            'RouteTableId': route_table_id,
            'DestinationCidrBlock': destination_cidr_block
        }

        if gateway_id is not None:
            params['GatewayId'] = gateway_id
        elif instance_id is not None:
            params['InstanceId'] = instance_id
        if dry_run:
            params['DryRun'] = 'true'

        return self.get_status('CreateRoute', params)

</source>
<source file="systems/boto-2.13.2/boto/vpc/__init__.py" startline="350" endline="393" pcid="3188">
    def replace_route(self, route_table_id, destination_cidr_block,
                     gateway_id=None, instance_id=None, interface_id=None,
                     dry_run=False):
        """
        Replaces an existing route within a route table in a VPC.

        :type route_table_id: str
        :param route_table_id: The ID of the route table for the route.

        :type destination_cidr_block: str
        :param destination_cidr_block: The CIDR address block used for the
                                       destination match.

        :type gateway_id: str
        :param gateway_id: The ID of the gateway attached to your VPC.

        :type instance_id: str
        :param instance_id: The ID of a NAT instance in your VPC.

        :type interface_id: str
        :param interface_id: Allows routing to network interface attachments.

        :type dry_run: bool
        :param dry_run: Set to True if the operation should not actually run.

        :rtype: bool
        :return: True if successful
        """
        params = {
            'RouteTableId': route_table_id,
            'DestinationCidrBlock': destination_cidr_block
        }

        if gateway_id is not None:
            params['GatewayId'] = gateway_id
        elif instance_id is not None:
            params['InstanceId'] = instance_id
        elif interface_id is not None:
            params['NetworkInterfaceId'] = interface_id
        if dry_run:
            params['DryRun'] = 'true'

        return self.get_status('ReplaceRoute', params)

</source>
</class>

<class classid="55" nclones="2" nlines="11" similarity="72">
<source file="systems/boto-2.13.2/boto/s3/bucket.py" startline="143" endline="171" pcid="3349">
    def get_key(self, key_name, headers=None, version_id=None,
                response_headers=None):
        """
        Check to see if a particular key exists within the bucket.  This
        method uses a HEAD request to check for the existance of the key.
        Returns: An instance of a Key object or None

        :type key_name: string
        :param key_name: The name of the key to retrieve

        :type response_headers: dict
        :param response_headers: A dictionary containing HTTP
            headers/values that will override any headers associated
            with the stored object in the response.  See
            http://goo.gl/EWOPb for details.

        :rtype: :class:`boto.s3.key.Key`
        :returns: A Key object from this bucket.
        """
        query_args_l = []
        if version_id:
            query_args_l.append('versionId=%s' % version_id)
        if response_headers:
            for rk, rv in response_headers.iteritems():
                query_args_l.append('%s=%s' % (rk, urllib.quote(rv)))

        key, resp = self._get_key_internal(key_name, headers, query_args_l)
        return key

</source>
<source file="systems/boto-2.13.2/boto/gs/bucket.py" startline="70" endline="106" pcid="3754">
    def get_key(self, key_name, headers=None, version_id=None,
                response_headers=None, generation=None):
        """Returns a Key instance for an object in this bucket.

         Note that this method uses a HEAD request to check for the existence of
         the key.

        :type key_name: string
        :param key_name: The name of the key to retrieve

        :type response_headers: dict
        :param response_headers: A dictionary containing HTTP
            headers/values that will override any headers associated
            with the stored object in the response.  See
            http://goo.gl/06N3b for details.

        :type version_id: string
        :param version_id: Unused in this subclass.

        :type generation: int
        :param generation: A specific generation number to fetch the key at. If
            not specified, the latest generation is fetched.

        :rtype: :class:`boto.gs.key.Key`
        :returns: A Key object from this bucket.
        """
        query_args_l = []
        if generation:
            query_args_l.append('generation=%s' % generation)
        if response_headers:
            for rk, rv in response_headers.iteritems():
                query_args_l.append('%s=%s' % (rk, urllib.quote(rv)))

        key, resp = self._get_key_internal(key_name, headers,
                                           query_args_l=query_args_l)
        return key

</source>
</class>

<class classid="56" nclones="2" nlines="12" similarity="75">
<source file="systems/boto-2.13.2/boto/s3/bucket.py" startline="750" endline="762" pcid="3367">
    def get_xml_acl(self, key_name='', headers=None, version_id=None):
        query_args = 'acl'
        if version_id:
            query_args += '&versionId=%s' % version_id
        response = self.connection.make_request('GET', self.name, key_name,
                                                query_args=query_args,
                                                headers=headers)
        body = response.read()
        if response.status != 200:
            raise self.connection.provider.storage_response_error(
                response.status, response.reason, body)
        return body

</source>
<source file="systems/boto-2.13.2/boto/s3/bucket.py" startline="763" endline="775" pcid="3368">
    def set_xml_acl(self, acl_str, key_name='', headers=None, version_id=None,
                    query_args='acl'):
        if version_id:
            query_args += '&versionId=%s' % version_id
        response = self.connection.make_request('PUT', self.name, key_name,
                                                data=acl_str.encode('UTF-8'),
                                                query_args=query_args,
                                                headers=headers)
        body = response.read()
        if response.status != 200:
            raise self.connection.provider.storage_response_error(
                response.status, response.reason, body)

</source>
</class>

<class classid="57" nclones="2" nlines="15" similarity="86">
<source file="systems/boto-2.13.2/boto/s3/bucket.py" startline="801" endline="837" pcid="3371">
    def set_subresource(self, subresource, value, key_name='', headers=None,
                        version_id=None):
        """
        Set a subresource for a bucket or key.

        :type subresource: string
        :param subresource: The subresource to set.

        :type value: string
        :param value: The value of the subresource.

        :type key_name: string
        :param key_name: The key to operate on, or None to operate on the
            bucket.

        :type headers: dict
        :param headers: Additional HTTP headers to include in the request.

        :type src_version_id: string
        :param src_version_id: Optional. The version id of the key to
            operate on. If not specified, operate on the newest
            version.
        """
        if not subresource:
            raise TypeError('set_subresource called with subresource=None')
        query_args = subresource
        if version_id:
            query_args += '&versionId=%s' % version_id
        response = self.connection.make_request('PUT', self.name, key_name,
                                                data=value.encode('UTF-8'),
                                                query_args=query_args,
                                                headers=headers)
        body = response.read()
        if response.status != 200:
            raise self.connection.provider.storage_response_error(
                response.status, response.reason, body)

</source>
<source file="systems/boto-2.13.2/boto/s3/bucket.py" startline="838" endline="874" pcid="3372">
    def get_subresource(self, subresource, key_name='', headers=None,
                        version_id=None):
        """
        Get a subresource for a bucket or key.

        :type subresource: string
        :param subresource: The subresource to get.

        :type key_name: string
        :param key_name: The key to operate on, or None to operate on the
            bucket.

        :type headers: dict
        :param headers: Additional HTTP headers to include in the request.

        :type src_version_id: string
        :param src_version_id: Optional. The version id of the key to
            operate on. If not specified, operate on the newest
            version.

        :rtype: string
        :returns: The value of the subresource.
        """
        if not subresource:
            raise TypeError('get_subresource called with subresource=None')
        query_args = subresource
        if version_id:
            query_args += '&versionId=%s' % version_id
        response = self.connection.make_request('GET', self.name, key_name,
                                                query_args=query_args,
                                                headers=headers)
        body = response.read()
        if response.status != 200:
            raise self.connection.provider.storage_response_error(
                response.status, response.reason, body)
        return body

</source>
</class>

<class classid="58" nclones="4" nlines="11" similarity="72">
<source file="systems/boto-2.13.2/boto/s3/bucket.py" startline="881" endline="914" pcid="3374">
    def add_email_grant(self, permission, email_address,
                        recursive=False, headers=None):
        """
        Convenience method that provides a quick way to add an email grant
        to a bucket. This method retrieves the current ACL, creates a new
        grant based on the parameters passed in, adds that grant to the ACL
        and then PUT's the new ACL back to S3.

        :type permission: string
        :param permission: The permission being granted. Should be one of:
            (READ, WRITE, READ_ACP, WRITE_ACP, FULL_CONTROL).

        :type email_address: string
        :param email_address: The email address associated with the AWS
            account your are granting the permission to.

        :type recursive: boolean
        :param recursive: A boolean value to controls whether the
            command will apply the grant to all keys within the bucket
            or not.  The default value is False.  By passing a True
            value, the call will iterate through all keys in the
            bucket and apply the same grant to each key.  CAUTION: If
            you have a lot of keys, this could take a long time!
        """
        if permission not in S3Permissions:
            raise self.connection.provider.storage_permissions_error(
                'Unknown Permission: %s' % permission)
        policy = self.get_acl(headers=headers)
        policy.acl.add_email_grant(permission, email_address)
        self.set_acl(policy, headers=headers)
        if recursive:
            for key in self:
                key.add_email_grant(permission, email_address, headers=headers)

</source>
<source file="systems/boto-2.13.2/boto/gs/bucket.py" startline="589" endline="625" pcid="3773">
    def add_email_grant(self, permission, email_address,
                        recursive=False, headers=None):
        """
        Convenience method that provides a quick way to add an email grant
        to a bucket. This method retrieves the current ACL, creates a new
        grant based on the parameters passed in, adds that grant to the ACL
        and then PUT's the new ACL back to GCS.

        :type permission: string
        :param permission: The permission being granted. Should be one of:
                           (READ, WRITE, FULL_CONTROL).

        :type email_address: string
        :param email_address: The email address associated with the GS
                              account your are granting the permission to.

        :type recursive: bool
        :param recursive: A boolean value to controls whether the call
                          will apply the grant to all keys within the bucket
                          or not.  The default value is False.  By passing a
                          True value, the call will iterate through all keys
                          in the bucket and apply the same grant to each key.
                          CAUTION: If you have a lot of keys, this could take
                          a long time!
        """
        if permission not in GSPermissions:
            raise self.connection.provider.storage_permissions_error(
                'Unknown Permission: %s' % permission)
        acl = self.get_acl(headers=headers)
        acl.add_email_grant(permission, email_address)
        self.set_acl(acl, headers=headers)
        if recursive:
            for key in self:
                key.add_email_grant(permission, email_address, headers=headers)

    # Method with same signature as boto.s3.bucket.Bucket.add_user_grant(),
    # to allow polymorphic treatment at application layer.
</source>
<source file="systems/boto-2.13.2/boto/gs/bucket.py" startline="626" endline="660" pcid="3774">
    def add_user_grant(self, permission, user_id, recursive=False,
                       headers=None):
        """
        Convenience method that provides a quick way to add a canonical user
        grant to a bucket. This method retrieves the current ACL, creates a new
        grant based on the parameters passed in, adds that grant to the ACL and
        then PUTs the new ACL back to GCS.

        :type permission: string
        :param permission:  The permission being granted.  Should be one of:
                            (READ|WRITE|FULL_CONTROL)

        :type user_id: string
        :param user_id:     The canonical user id associated with the GS account
                            you are granting the permission to.

        :type recursive: bool
        :param recursive: A boolean value to controls whether the call
                          will apply the grant to all keys within the bucket
                          or not.  The default value is False.  By passing a
                          True value, the call will iterate through all keys
                          in the bucket and apply the same grant to each key.
                          CAUTION: If you have a lot of keys, this could take
                          a long time!
        """
        if permission not in GSPermissions:
            raise self.connection.provider.storage_permissions_error(
                'Unknown Permission: %s' % permission)
        acl = self.get_acl(headers=headers)
        acl.add_user_grant(permission, user_id)
        self.set_acl(acl, headers=headers)
        if recursive:
            for key in self:
                key.add_user_grant(permission, user_id, headers=headers)

</source>
<source file="systems/boto-2.13.2/boto/gs/bucket.py" startline="661" endline="701" pcid="3775">
    def add_group_email_grant(self, permission, email_address, recursive=False,
                              headers=None):
        """
        Convenience method that provides a quick way to add an email group
        grant to a bucket. This method retrieves the current ACL, creates a new
        grant based on the parameters passed in, adds that grant to the ACL and
        then PUT's the new ACL back to GCS.

        :type permission: string
        :param permission: The permission being granted. Should be one of:
            READ|WRITE|FULL_CONTROL
            See http://code.google.com/apis/storage/docs/developer-guide.html#authorization
            for more details on permissions.

        :type email_address: string
        :param email_address: The email address associated with the Google
            Group to which you are granting the permission.

        :type recursive: bool
        :param recursive: A boolean value to controls whether the call
                          will apply the grant to all keys within the bucket
                          or not.  The default value is False.  By passing a
                          True value, the call will iterate through all keys
                          in the bucket and apply the same grant to each key.
                          CAUTION: If you have a lot of keys, this could take
                          a long time!
        """
        if permission not in GSPermissions:
            raise self.connection.provider.storage_permissions_error(
                'Unknown Permission: %s' % permission)
        acl = self.get_acl(headers=headers)
        acl.add_group_email_grant(permission, email_address)
        self.set_acl(acl, headers=headers)
        if recursive:
            for key in self:
                key.add_group_email_grant(permission, email_address,
                                          headers=headers)

    # Method with same input signature as boto.s3.bucket.Bucket.list_grants()
    # (but returning different object type), to allow polymorphic treatment
    # at application layer.
</source>
</class>

<class classid="59" nclones="2" nlines="12" similarity="100">
<source file="systems/boto-2.13.2/boto/s3/bucket.py" startline="959" endline="978" pcid="3377">
    def get_location(self):
        """
        Returns the LocationConstraint for the bucket.

        :rtype: str
        :return: The LocationConstraint for the bucket or the empty
            string if no constraint was specified when bucket was created.
        """
        response = self.connection.make_request('GET', self.name,
                                                query_args='location')
        body = response.read()
        if response.status == 200:
            rs = ResultSet(self)
            h = handler.XmlHandler(rs, self)
            xml.sax.parseString(body, h)
            return rs.LocationConstraint
        else:
            raise self.connection.provider.storage_response_error(
                response.status, response.reason, body)

</source>
<source file="systems/boto-2.13.2/boto/gs/bucket.py" startline="567" endline="588" pcid="3772">
    def get_storage_class(self):
        """
        Returns the StorageClass for the bucket.

        :rtype: str
        :return: The StorageClass for the bucket.
        """
        response = self.connection.make_request('GET', self.name,
                                                query_args='storageClass')
        body = response.read()
        if response.status == 200:
            rs = ResultSet(self)
            h = handler.XmlHandler(rs, self)
            xml.sax.parseString(body, h)
            return rs.StorageClass
        else:
            raise self.connection.provider.storage_response_error(
                response.status, response.reason, body)


    # Method with same signature as boto.s3.bucket.Bucket.add_email_grant(),
    # to allow polymorphic treatment at application layer.
</source>
</class>

<class classid="60" nclones="15" nlines="10" similarity="70">
<source file="systems/boto-2.13.2/boto/s3/bucket.py" startline="979" endline="1001" pcid="3378">
    def set_xml_logging(self, logging_str, headers=None):
        """
        Set logging on a bucket directly to the given xml string.

        :type logging_str: unicode string
        :param logging_str: The XML for the bucketloggingstatus which
            will be set.  The string will be converted to utf-8 before
            it is sent.  Usually, you will obtain this XML from the
            BucketLogging object.

        :rtype: bool
        :return: True if ok or raises an exception.
        """
        body = logging_str.encode('utf-8')
        response = self.connection.make_request('PUT', self.name, data=body,
                query_args='logging', headers=headers)
        body = response.read()
        if response.status == 200:
            return True
        else:
            raise self.connection.provider.storage_response_error(
                response.status, response.reason, body)

</source>
<source file="systems/boto-2.13.2/boto/s3/bucket.py" startline="1352" endline="1365" pcid="3397">
    def delete_website_configuration(self, headers=None):
        """
        Removes all website configuration from the bucket.
        """
        response = self.connection.make_request('DELETE', self.name,
                query_args='website', headers=headers)
        body = response.read()
        boto.log.debug(body)
        if response.status == 204:
            return True
        else:
            raise self.connection.provider.storage_response_error(
                response.status, response.reason, body)

</source>
<source file="systems/boto-2.13.2/boto/s3/bucket.py" startline="1458" endline="1472" pcid="3404">
    def get_cors_xml(self, headers=None):
        """
        Returns the current CORS configuration on the bucket as an
        XML document.
        """
        response = self.connection.make_request('GET', self.name,
                query_args='cors', headers=headers)
        body = response.read()
        boto.log.debug(body)
        if response.status == 200:
            return body
        else:
            raise self.connection.provider.storage_response_error(
                response.status, response.reason, body)

</source>
<source file="systems/boto-2.13.2/boto/s3/bucket.py" startline="1274" endline="1285" pcid="3392">
    def set_website_configuration_xml(self, xml, headers=None):
        """Upload xml website configuration"""
        response = self.connection.make_request('PUT', self.name, data=xml,
                                                query_args='website',
                                                headers=headers)
        body = response.read()
        if response.status == 200:
            return True
        else:
            raise self.connection.provider.storage_response_error(
                response.status, response.reason, body)

</source>
<source file="systems/boto-2.13.2/boto/s3/bucket.py" startline="1078" endline="1088" pcid="3384">
    def set_request_payment(self, payer='BucketOwner', headers=None):
        body = self.BucketPaymentBody % payer
        response = self.connection.make_request('PUT', self.name, data=body,
                query_args='requestPayment', headers=headers)
        body = response.read()
        if response.status == 200:
            return True
        else:
            raise self.connection.provider.storage_response_error(
                response.status, response.reason, body)

</source>
<source file="systems/boto-2.13.2/boto/s3/bucket.py" startline="1214" endline="1228" pcid="3389">
    def delete_lifecycle_configuration(self, headers=None):
        """
        Removes all lifecycle configuration from the bucket.
        """
        response = self.connection.make_request('DELETE', self.name,
                                                query_args='lifecycle',
                                                headers=headers)
        body = response.read()
        boto.log.debug(body)
        if response.status == 204:
            return True
        else:
            raise self.connection.provider.storage_response_error(
                response.status, response.reason, body)

</source>
<source file="systems/boto-2.13.2/boto/s3/bucket.py" startline="1659" endline="1669" pcid="3415">
    def delete_tags(self, headers=None):
        response = self.connection.make_request('DELETE', self.name,
                                                query_args='tagging',
                                                headers=headers)
        body = response.read()
        boto.log.debug(body)
        if response.status == 204:
            return True
        else:
            raise self.connection.provider.storage_response_error(
                response.status, response.reason, body)
</source>
<source file="systems/boto-2.13.2/boto/s3/bucket.py" startline="1037" endline="1055" pcid="3381">
    def get_logging_status(self, headers=None):
        """
        Get the logging status for this bucket.

        :rtype: :class:`boto.s3.bucketlogging.BucketLogging`
        :return: A BucketLogging object for this bucket.
        """
        response = self.connection.make_request('GET', self.name,
                query_args='logging', headers=headers)
        body = response.read()
        if response.status == 200:
            blogging = BucketLogging()
            h = handler.XmlHandler(blogging, self)
            xml.sax.parseString(body, h)
            return blogging
        else:
            raise self.connection.provider.storage_response_error(
                response.status, response.reason, body)

</source>
<source file="systems/boto-2.13.2/boto/s3/bucket.py" startline="1193" endline="1213" pcid="3388">
    def get_lifecycle_config(self, headers=None):
        """
        Returns the current lifecycle configuration on the bucket.

        :rtype: :class:`boto.s3.lifecycle.Lifecycle`
        :returns: A LifecycleConfig object that describes all current
            lifecycle rules in effect for the bucket.
        """
        response = self.connection.make_request('GET', self.name,
                query_args='lifecycle', headers=headers)
        body = response.read()
        boto.log.debug(body)
        if response.status == 200:
            lifecycle = Lifecycle()
            h = handler.XmlHandler(lifecycle, self)
            xml.sax.parseString(body, h)
            return lifecycle
        else:
            raise self.connection.provider.storage_response_error(
                response.status, response.reason, body)

</source>
<source file="systems/boto-2.13.2/boto/s3/bucket.py" startline="1629" endline="1639" pcid="3412">
    def get_xml_tags(self):
        response = self.connection.make_request('GET', self.name,
                                                query_args='tagging',
                                                headers=None)
        body = response.read()
        if response.status == 200:
            return body
        else:
            raise self.connection.provider.storage_response_error(
                response.status, response.reason, body)

</source>
<source file="systems/boto-2.13.2/boto/s3/bucket.py" startline="1487" endline="1501" pcid="3406">
    def delete_cors(self, headers=None):
        """
        Removes all CORS configuration from the bucket.
        """
        response = self.connection.make_request('DELETE', self.name,
                                                query_args='cors',
                                                headers=headers)
        body = response.read()
        boto.log.debug(body)
        if response.status == 204:
            return True
        else:
            raise self.connection.provider.storage_response_error(
                response.status, response.reason, body)

</source>
<source file="systems/boto-2.13.2/boto/s3/bucket.py" startline="1391" endline="1408" pcid="3400">
    def set_policy(self, policy, headers=None):
        """
        Add or replace the JSON policy associated with the bucket.

        :type policy: str
        :param policy: The JSON policy as a string.
        """
        response = self.connection.make_request('PUT', self.name,
                                                data=policy,
                                                query_args='policy',
                                                headers=headers)
        body = response.read()
        if response.status >= 200 and response.status <= 204:
            return True
        else:
            raise self.connection.provider.storage_response_error(
                response.status, response.reason, body)

</source>
<source file="systems/boto-2.13.2/boto/s3/bucket.py" startline="1409" endline="1420" pcid="3401">
    def delete_policy(self, headers=None):
        response = self.connection.make_request('DELETE', self.name,
                                                data='/?policy',
                                                query_args='policy',
                                                headers=headers)
        body = response.read()
        if response.status >= 200 and response.status <= 204:
            return True
        else:
            raise self.connection.provider.storage_response_error(
                response.status, response.reason, body)

</source>
<source file="systems/boto-2.13.2/boto/gs/bucket.py" startline="924" endline="944" pcid="3787">
    def get_lifecycle_config(self, headers=None):
        """
        Returns the current lifecycle configuration on the bucket.

        :rtype: :class:`boto.gs.lifecycle.LifecycleConfig`
        :returns: A LifecycleConfig object that describes all current
            lifecycle rules in effect for the bucket.
        """
        response = self.connection.make_request('GET', self.name,
                query_args=LIFECYCLE_ARG, headers=headers)
        body = response.read()
        boto.log.debug(body)
        if response.status == 200:
            lifecycle_config = LifecycleConfig()
            h = handler.XmlHandler(lifecycle_config, self)
            xml.sax.parseString(body, h)
            return lifecycle_config
        else:
            raise self.connection.provider.storage_response_error(
                response.status, response.reason, body)

</source>
<source file="systems/boto-2.13.2/boto/gs/bucket.py" startline="533" endline="552" pcid="3770">
    def get_cors(self, headers=None):
        """Returns a bucket's CORS XML document.

        :param dict headers: Additional headers to send with the request.
        :rtype: :class:`~.cors.Cors`
        """
        response = self.connection.make_request('GET', self.name,
                                                query_args=CORS_ARG,
                                                headers=headers)
        body = response.read()
        if response.status == 200:
            # Success - parse XML and return Cors object.
            cors = Cors()
            h = handler.XmlHandler(cors, self)
            xml.sax.parseString(body, h)
            return cors
        else:
            raise self.connection.provider.storage_response_error(
                response.status, response.reason, body)

</source>
</class>

<class classid="61" nclones="2" nlines="18" similarity="89">
<source file="systems/boto-2.13.2/boto/s3/bucket.py" startline="1166" endline="1192" pcid="3387">
    def configure_lifecycle(self, lifecycle_config, headers=None):
        """
        Configure lifecycle for this bucket.

        :type lifecycle_config: :class:`boto.s3.lifecycle.Lifecycle`
        :param lifecycle_config: The lifecycle configuration you want
            to configure for this bucket.
        """
        xml = lifecycle_config.to_xml()
        xml = xml.encode('utf-8')
        fp = StringIO.StringIO(xml)
        md5 = boto.utils.compute_md5(fp)
        if headers is None:
            headers = {}
        headers['Content-MD5'] = md5[1]
        headers['Content-Type'] = 'text/xml'
        response = self.connection.make_request('PUT', self.name,
                                                data=fp.getvalue(),
                                                query_args='lifecycle',
                                                headers=headers)
        body = response.read()
        if response.status == 200:
            return True
        else:
            raise self.connection.provider.storage_response_error(
                response.status, response.reason, body)

</source>
<source file="systems/boto-2.13.2/boto/s3/bucket.py" startline="1421" endline="1446" pcid="3402">
    def set_cors_xml(self, cors_xml, headers=None):
        """
        Set the CORS (Cross-Origin Resource Sharing) for a bucket.

        :type cors_xml: str
        :param cors_xml: The XML document describing your desired
            CORS configuration.  See the S3 documentation for details
            of the exact syntax required.
        """
        fp = StringIO.StringIO(cors_xml)
        md5 = boto.utils.compute_md5(fp)
        if headers is None:
            headers = {}
        headers['Content-MD5'] = md5[1]
        headers['Content-Type'] = 'text/xml'
        response = self.connection.make_request('PUT', self.name,
                                                data=fp.getvalue(),
                                                query_args='cors',
                                                headers=headers)
        body = response.read()
        if response.status == 200:
            return True
        else:
            raise self.connection.provider.storage_response_error(
                response.status, response.reason, body)

</source>
</class>

<class classid="62" nclones="2" nlines="14" similarity="100">
<source file="systems/boto-2.13.2/boto/s3/bucketlistresultset.py" startline="58" endline="75" pcid="3452">
def versioned_bucket_lister(bucket, prefix='', delimiter='',
                            key_marker='', version_id_marker='', headers=None):
    """
    A generator function for listing versions in a bucket.
    """
    more_results = True
    k = None
    while more_results:
        rs = bucket.get_all_versions(prefix=prefix, key_marker=key_marker,
                                     version_id_marker=version_id_marker,
                                     delimiter=delimiter, headers=headers,
                                     max_keys=999)
        for k in rs:
            yield k
        key_marker = rs.next_key_marker
        version_id_marker = rs.next_version_id_marker
        more_results= rs.is_truncated
        
</source>
<source file="systems/boto-2.13.2/boto/gs/bucketlistresultset.py" startline="23" endline="40" pcid="3814">
def versioned_bucket_lister(bucket, prefix='', delimiter='',
                            marker='', generation_marker='', headers=None):
    """
    A generator function for listing versioned objects.
    """
    more_results = True
    k = None
    while more_results:
        rs = bucket.get_all_versions(prefix=prefix, marker=marker,
                                     generation_marker=generation_marker,
                                     delimiter=delimiter, headers=headers,
                                     max_keys=999)
        for k in rs:
            yield k
        marker = rs.next_marker
        generation_marker = rs.next_generation_marker
        more_results= rs.is_truncated

</source>
</class>

<class classid="63" nclones="2" nlines="17" similarity="83">
<source file="systems/boto-2.13.2/boto/s3/key.py" startline="1524" endline="1579" pcid="3574">
    def get_contents_to_file(self, fp, headers=None,
                             cb=None, num_cb=10,
                             torrent=False,
                             version_id=None,
                             res_download_handler=None,
                             response_headers=None):
        """
        Retrieve an object from S3 using the name of the Key object as the
        key in S3.  Write the contents of the object to the file pointed
        to by 'fp'.

        :type fp: File -like object
        :param fp:

        :type headers: dict
        :param headers: additional HTTP headers that will be sent with
            the GET request.

        :type cb: function
        :param cb: a callback function that will be called to report
            progress on the upload.  The callback should accept two
            integer parameters, the first representing the number of
            bytes that have been successfully transmitted to S3 and
            the second representing the size of the to be transmitted
            object.

        :type cb: int
        :param num_cb: (optional) If a callback is specified with the
            cb parameter this parameter determines the granularity of
            the callback by defining the maximum number of times the
            callback will be called during the file transfer.

        :type torrent: bool
        :param torrent: If True, returns the contents of a torrent
            file as a string.

        :type res_upload_handler: ResumableDownloadHandler
        :param res_download_handler: If provided, this handler will
            perform the download.

        :type response_headers: dict
        :param response_headers: A dictionary containing HTTP
            headers/values that will override any headers associated
            with the stored object in the response.  See
            http://goo.gl/EWOPb for details.
        """
        if self.bucket != None:
            if res_download_handler:
                res_download_handler.get_file(self, fp, headers, cb, num_cb,
                                              torrent=torrent,
                                              version_id=version_id)
            else:
                self.get_file(fp, headers, cb, num_cb, torrent=torrent,
                              version_id=version_id,
                              response_headers=response_headers)

</source>
<source file="systems/boto-2.13.2/boto/gs/key.py" startline="175" endline="233" pcid="3829">
    def get_contents_to_file(self, fp, headers=None,
                             cb=None, num_cb=10,
                             torrent=False,
                             version_id=None,
                             res_download_handler=None,
                             response_headers=None,
                             hash_algs=None):
        """
        Retrieve an object from GCS using the name of the Key object as the
        key in GCS. Write the contents of the object to the file pointed
        to by 'fp'.

        :type fp: File -like object
        :param fp:

        :type headers: dict
        :param headers: additional HTTP headers that will be sent with
            the GET request.

        :type cb: function
        :param cb: a callback function that will be called to report
            progress on the upload. The callback should accept two
            integer parameters, the first representing the number of
            bytes that have been successfully transmitted to GCS and
            the second representing the size of the to be transmitted
            object.

        :type cb: int
        :param num_cb: (optional) If a callback is specified with the
            cb parameter this parameter determines the granularity of
            the callback by defining the maximum number of times the
            callback will be called during the file transfer.

        :type torrent: bool
        :param torrent: If True, returns the contents of a torrent
            file as a string.

        :type res_upload_handler: ResumableDownloadHandler
        :param res_download_handler: If provided, this handler will
            perform the download.

        :type response_headers: dict
        :param response_headers: A dictionary containing HTTP
            headers/values that will override any headers associated
            with the stored object in the response. See
            http://goo.gl/sMkcC for details.
        """
        if self.bucket != None:
            if res_download_handler:
                res_download_handler.get_file(self, fp, headers, cb, num_cb,
                                              torrent=torrent,
                                              version_id=version_id,
                                              hash_algs=hash_algs)
            else:
                self.get_file(fp, headers, cb, num_cb, torrent=torrent,
                              version_id=version_id,
                              response_headers=response_headers,
                              hash_algs=hash_algs)

</source>
</class>

<class classid="64" nclones="2" nlines="16" similarity="81">
<source file="systems/boto-2.13.2/boto/s3/resumable_download_handler.py" startline="151" endline="170" pcid="3591">
    def _save_tracker_info(self, key):
        self.etag_value_for_current_download = key.etag.strip('"\'')
        if not self.tracker_file_name:
            return
        f = None
        try:
            f = open(self.tracker_file_name, 'w')
            f.write('%s\n' % self.etag_value_for_current_download)
        except IOError, e:
            raise ResumableDownloadException(
                'Couldn\'t write tracker file (%s): %s.\nThis can happen'
                'if you\'re using an incorrectly configured download tool\n'
                '(e.g., gsutil configured to save tracker files to an '
                'unwritable directory)' %
                (self.tracker_file_name, e.strerror),
                ResumableTransferDisposition.ABORT)
        finally:
            if f:
                f.close()

</source>
<source file="systems/boto-2.13.2/boto/gs/resumable_upload_handler.py" startline="119" endline="140" pcid="3722">
    def _save_tracker_uri_to_file(self):
        """
        Saves URI to tracker file if one was passed to constructor.
        """
        if not self.tracker_file_name:
            return
        f = None
        try:
            f = open(self.tracker_file_name, 'w')
            f.write(self.tracker_uri)
        except IOError, e:
            raise ResumableUploadException(
                'Couldn\'t write URI tracker file (%s): %s.\nThis can happen'
                'if you\'re using an incorrectly configured upload tool\n'
                '(e.g., gsutil configured to save tracker files to an '
                'unwritable directory)' %
                (self.tracker_file_name, e.strerror),
                ResumableTransferDisposition.ABORT)
        finally:
            if f:
                f.close()

</source>
</class>

<class classid="65" nclones="2" nlines="11" similarity="72">
<source file="systems/boto-2.13.2/boto/sqs/queue.py" startline="381" endline="399" pcid="3701">
    def save_to_file(self, fp, sep='\n'):
        """
        Read all messages from the queue and persist them to file-like object.
        Messages are written to the file and the 'sep' string is written
        in between messages.  Messages are deleted from the queue after
        being written to the file.
        Returns the number of messages saved.
        """
        n = 0
        m = self.read()
        while m:
            n += 1
            fp.write(m.get_body())
            if sep:
                fp.write(sep)
            self.delete_message(m)
            m = self.read()
        return n

</source>
<source file="systems/boto-2.13.2/boto/sqs/queue.py" startline="416" endline="435" pcid="3703">
    def save_to_s3(self, bucket):
        """
        Read all messages from the queue and persist them to S3.
        Messages are stored in the S3 bucket using a naming scheme of::

            <queue_id>/<message_id>

        Messages are deleted from the queue after being saved to S3.
        Returns the number of messages saved.
        """
        n = 0
        m = self.read()
        while m:
            n += 1
            key = bucket.new_key('%s/%s' % (self.id, m.id))
            key.set_contents_from_string(m.get_body())
            self.delete_message(m)
            m = self.read()
        return n

</source>
</class>

<class classid="66" nclones="3" nlines="13" similarity="76">
<source file="systems/boto-2.13.2/boto/gs/bucket.py" startline="742" endline="775" pcid="3779">
    def get_logging_config_with_xml(self, headers=None):
        """Returns the current status of logging configuration on the bucket as
        unparsed XML.

        :param dict headers: Additional headers to send with the request.

        :rtype: 2-Tuple
        :returns: 2-tuple containing:

            1) A dictionary containing the parsed XML response from GCS. The
              overall structure is:

              * Logging

                * LogObjectPrefix: Prefix that is prepended to log objects.
                * LogBucket: Target bucket for log objects.

            2) Unparsed XML describing the bucket's logging configuration.
        """
        response = self.connection.make_request('GET', self.name,
                                                query_args='logging',
                                                headers=headers)
        body = response.read()
        boto.log.debug(body)

        if response.status != 200:
            raise self.connection.provider.storage_response_error(
                response.status, response.reason, body)

        e = boto.jsonresponse.Element()
        h = boto.jsonresponse.XmlHandler(e, None)
        h.parse(body)
        return e, body

</source>
<source file="systems/boto-2.13.2/boto/gs/bucket.py" startline="892" endline="909" pcid="3785">
    def get_versioning_status(self, headers=None):
        """Returns the current status of versioning configuration on the bucket.

        :rtype: bool
        """
        response = self.connection.make_request('GET', self.name,
                                                query_args='versioning',
                                                headers=headers)
        body = response.read()
        boto.log.debug(body)
        if response.status != 200:
            raise self.connection.provider.storage_response_error(
                    response.status, response.reason, body)
        resp_json = boto.jsonresponse.Element()
        boto.jsonresponse.XmlHandler(resp_json, None).parse(body)
        resp_json = resp_json['VersioningConfiguration']
        return ('Status' in resp_json) and (resp_json['Status'] == 'Enabled')

</source>
<source file="systems/boto-2.13.2/boto/gs/bucket.py" startline="850" endline="884" pcid="3783">
    def get_website_configuration_with_xml(self, headers=None):
        """Returns the current status of website configuration on the bucket as
        unparsed XML.

        :param dict headers: Additional headers to send with the request.

        :rtype: 2-Tuple
        :returns: 2-tuple containing:

            1) A dictionary containing the parsed XML response from GCS. The
              overall structure is:

              * WebsiteConfiguration

                * MainPageSuffix: suffix that is appended to request that is for
                  a "directory" on the website endpoint.
                * NotFoundPage: name of an object to serve when site visitors
                  encounter a 404

            2) Unparsed XML describing the bucket's website configuration.
        """
        response = self.connection.make_request('GET', self.name,
                query_args='websiteConfig', headers=headers)
        body = response.read()
        boto.log.debug(body)

        if response.status != 200:
            raise self.connection.provider.storage_response_error(
                response.status, response.reason, body)

        e = boto.jsonresponse.Element()
        h = boto.jsonresponse.XmlHandler(e, None)
        h.parse(body)
        return e, body

</source>
</class>

<class classid="67" nclones="2" nlines="13" similarity="71">
<source file="systems/boto-2.13.2/boto/file/key.py" startline="57" endline="83" pcid="3875">
    def get_file(self, fp, headers=None, cb=None, num_cb=10, torrent=False):
        """
        Retrieves a file from a Key

        :type fp: file
        :param fp: File pointer to put the data into

        :type headers: string
        :param: ignored in this subclass.

        :type cb: function
        :param cb: ignored in this subclass.

        :type cb: int
        :param num_cb: ignored in this subclass.
        """
        if self.key_type & self.KEY_STREAM_WRITABLE:
            raise BotoClientError('Stream is not readable')
        elif self.key_type & self.KEY_STREAM_READABLE:
            key_file = self.fp
        else:
            key_file = open(self.full_path, 'rb')
        try:
            shutil.copyfileobj(key_file, fp)
        finally:
            key_file.close()

</source>
<source file="systems/boto-2.13.2/boto/file/key.py" startline="84" endline="131" pcid="3876">
    def set_contents_from_file(self, fp, headers=None, replace=True, cb=None,
                               num_cb=10, policy=None, md5=None):
        """
        Store an object in a file using the name of the Key object as the
        key in file URI and the contents of the file pointed to by 'fp' as the
        contents.

        :type fp: file
        :param fp: the file whose contents to upload

        :type headers: dict
        :param headers: ignored in this subclass.

        :type replace: bool
        :param replace: If this parameter is False, the method
                        will first check to see if an object exists in the
                        bucket with the same key.  If it does, it won't
                        overwrite it.  The default value is True which will
                        overwrite the object.

        :type cb: function
        :param cb: ignored in this subclass.

        :type cb: int
        :param num_cb: ignored in this subclass.

        :type policy: :class:`boto.s3.acl.CannedACLStrings`
        :param policy: ignored in this subclass.

        :type md5: A tuple containing the hexdigest version of the MD5 checksum
                   of the file as the first element and the Base64-encoded
                   version of the plain checksum as the second element.
                   This is the same format returned by the compute_md5 method.
        :param md5: ignored in this subclass.
        """
        if self.key_type & self.KEY_STREAM_READABLE:
            raise BotoClientError('Stream is not writable')
        elif self.key_type & self.KEY_STREAM_WRITABLE:
            key_file = self.fp
        else:
            if not replace and os.path.exists(self.full_path):
                return
            key_file = open(self.full_path, 'wb')
        try:
            shutil.copyfileobj(fp, key_file)
        finally:
            key_file.close()

</source>
</class>

<class classid="68" nclones="4" nlines="14" similarity="73">
<source file="systems/boto-2.13.2/boto/route53/connection.py" startline="118" endline="139" pcid="3901">
    def get_hosted_zone(self, hosted_zone_id):
        """
        Get detailed information about a particular Hosted Zone.
        
        :type hosted_zone_id: str
        :param hosted_zone_id: The unique identifier for the Hosted Zone

        """
        uri = '/%s/hostedzone/%s' % (self.Version, hosted_zone_id)
        response = self.make_request('GET', uri)
        body = response.read()
        boto.log.debug(body)
        if response.status >= 300:
            raise exception.DNSServerError(response.status,
                                           response.reason,
                                           body)
        e = boto.jsonresponse.Element(list_marker='NameServers',
                                      item_marker=('NameServer',))
        h = boto.jsonresponse.XmlHandler(e, None)
        h.parse(body)
        return e

</source>
<source file="systems/boto-2.13.2/boto/route53/connection.py" startline="321" endline="345" pcid="3907">
    def get_change(self, change_id):
        """
        Get information about a proposed set of changes, as submitted
        by the change_rrsets method.
        Returns a Python data structure with status information about the
        changes.

        :type change_id: str
        :param change_id: The unique identifier for the set of changes.
            This ID is returned in the response to the change_rrsets method.

        """
        uri = '/%s/change/%s' % (self.Version, change_id)
        response = self.make_request('GET', uri)
        body = response.read()
        boto.log.debug(body)
        if response.status >= 300:
            raise exception.DNSServerError(response.status,
                                           response.reason,
                                           body)
        e = boto.jsonresponse.Element()
        h = boto.jsonresponse.XmlHandler(e, None)
        h.parse(body)
        return e

</source>
<source file="systems/boto-2.13.2/boto/route53/connection.py" startline="208" endline="223" pcid="3904">
    def delete_hosted_zone(self, hosted_zone_id):
        uri = '/%s/hostedzone/%s' % (self.Version, hosted_zone_id)
        response = self.make_request('DELETE', uri)
        body = response.read()
        boto.log.debug(body)
        if response.status not in (200, 204):
            raise exception.DNSServerError(response.status,
                                           response.reason,
                                           body)
        e = boto.jsonresponse.Element()
        h = boto.jsonresponse.XmlHandler(e, None)
        h.parse(body)
        return e

    # Resource Record Sets

</source>
<source file="systems/boto-2.13.2/boto/route53/connection.py" startline="291" endline="320" pcid="3906">
    def change_rrsets(self, hosted_zone_id, xml_body):
        """
        Create or change the authoritative DNS information for this
        Hosted Zone.
        Returns a Python data structure with information about the set of
        changes, including the Change ID.

        :type hosted_zone_id: str
        :param hosted_zone_id: The unique identifier for the Hosted Zone

        :type xml_body: str
        :param xml_body: The list of changes to be made, defined in the
            XML schema defined by the Route53 service.

        """
        uri = '/%s/hostedzone/%s/rrset' % (self.Version, hosted_zone_id)
        response = self.make_request('POST', uri,
                                     {'Content-Type': 'text/xml'},
                                     xml_body)
        body = response.read()
        boto.log.debug(body)
        if response.status >= 300:
            raise exception.DNSServerError(response.status,
                                           response.reason,
                                           body)
        e = boto.jsonresponse.Element()
        h = boto.jsonresponse.XmlHandler(e, None)
        h.parse(body)
        return e

</source>
</class>

<class classid="69" nclones="3" nlines="10" similarity="70">
<source file="systems/boto-2.13.2/boto/route53/zone.py" startline="158" endline="172" pcid="3922">
    def add_cname(self, name, value, ttl=None, identifier=None, comment=""):
        """
        Add a new CNAME record to this Zone.  See _new_record for
        parameter documentation.  Returns a Status object.
        """
        ttl = ttl or default_ttl
        name = self.route53connection._make_qualified(name)
        value = self.route53connection._make_qualified(value)
        return self.add_record(resource_type='CNAME',
                               name=name,
                               value=value,
                               ttl=ttl,
                               identifier=identifier,
                               comment=comment)

</source>
<source file="systems/boto-2.13.2/boto/route53/zone.py" startline="303" endline="320" pcid="3929">
    def update_cname(self, name, value, ttl=None, identifier=None, comment=""):
        """
        Update the given CNAME record in this Zone to a new value, ttl,
        and identifier.  Returns a Status object.

        Will throw TooManyRecordsException is name, value does not match
        a single record.
        """
        name = self.route53connection._make_qualified(name)
        value = self.route53connection._make_qualified(value)
        old_record = self.get_cname(name)
        ttl = ttl or old_record.ttl
        return self.update_record(old_record,
                                  new_value=value,
                                  new_ttl=ttl,
                                  new_identifier=identifier,
                                  comment=comment)

</source>
<source file="systems/boto-2.13.2/boto/route53/zone.py" startline="338" endline="355" pcid="3931">
    def update_mx(self, name, value, ttl=None, identifier=None, comment=""):
        """
        Update the given MX record in this Zone to a new value, ttl,
        and identifier.  Returns a Status object.

        Will throw TooManyRecordsException is name, value does not match
        a single record.
        """
        name = self.route53connection._make_qualified(name)
        value = self.route53connection._make_qualified(value)
        old_record = self.get_mx(name)
        ttl = ttl or old_record.ttl
        return self.update_record(old_record,
                                  new_value=value,
                                  new_ttl=ttl,
                                  new_identifier=identifier,
                                  comment=comment)

</source>
</class>

<class classid="70" nclones="3" nlines="12" similarity="84">
<source file="systems/boto-2.13.2/boto/dynamodb/layer1.py" startline="345" endline="383" pcid="4103">
    def put_item(self, table_name, item,
                 expected=None, return_values=None,
                 object_hook=None):
        """
        Create a new item or replace an old item with a new
        item (including all attributes).  If an item already
        exists in the specified table with the same primary
        key, the new item will completely replace the old item.
        You can perform a conditional put by specifying an
        expected rule.

        :type table_name: str
        :param table_name: The name of the table in which to put the item.

        :type item: dict
        :param item: A Python version of the Item data structure
            defined by DynamoDB.

        :type expected: dict
        :param expected: A Python version of the Expected
            data structure defined by DynamoDB.

        :type return_values: str
        :param return_values: Controls the return of attribute
            name-value pairs before then were changed.  Possible
            values are: None or 'ALL_OLD'. If 'ALL_OLD' is
            specified and the item is overwritten, the content
            of the old item is returned.
        """
        data = {'TableName': table_name,
                'Item': item}
        if expected:
            data['Expected'] = expected
        if return_values:
            data['ReturnValues'] = return_values
        json_input = json.dumps(data)
        return self.make_request('PutItem', json_input,
                                 object_hook=object_hook)

</source>
<source file="systems/boto-2.13.2/boto/dynamodb/layer1.py" startline="384" endline="425" pcid="4104">
    def update_item(self, table_name, key, attribute_updates,
                    expected=None, return_values=None,
                    object_hook=None):
        """
        Edits an existing item's attributes. You can perform a conditional
        update (insert a new attribute name-value pair if it doesn't exist,
        or replace an existing name-value pair if it has certain expected
        attribute values).

        :type table_name: str
        :param table_name: The name of the table.

        :type key: dict
        :param key: A Python version of the Key data structure
            defined by DynamoDB which identifies the item to be updated.

        :type attribute_updates: dict
        :param attribute_updates: A Python version of the AttributeUpdates
            data structure defined by DynamoDB.

        :type expected: dict
        :param expected: A Python version of the Expected
            data structure defined by DynamoDB.

        :type return_values: str
        :param return_values: Controls the return of attribute
            name-value pairs before then were changed.  Possible
            values are: None or 'ALL_OLD'. If 'ALL_OLD' is
            specified and the item is overwritten, the content
            of the old item is returned.
        """
        data = {'TableName': table_name,
                'Key': key,
                'AttributeUpdates': attribute_updates}
        if expected:
            data['Expected'] = expected
        if return_values:
            data['ReturnValues'] = return_values
        json_input = json.dumps(data)
        return self.make_request('UpdateItem', json_input,
                                 object_hook=object_hook)

</source>
<source file="systems/boto-2.13.2/boto/dynamodb/layer1.py" startline="426" endline="461" pcid="4105">
    def delete_item(self, table_name, key,
                    expected=None, return_values=None,
                    object_hook=None):
        """
        Delete an item and all of it's attributes by primary key.
        You can perform a conditional delete by specifying an
        expected rule.

        :type table_name: str
        :param table_name: The name of the table containing the item.

        :type key: dict
        :param key: A Python version of the Key data structure
            defined by DynamoDB.

        :type expected: dict
        :param expected: A Python version of the Expected
            data structure defined by DynamoDB.

        :type return_values: str
        :param return_values: Controls the return of attribute
            name-value pairs before then were changed.  Possible
            values are: None or 'ALL_OLD'. If 'ALL_OLD' is
            specified and the item is overwritten, the content
            of the old item is returned.
        """
        data = {'TableName': table_name,
                'Key': key}
        if expected:
            data['Expected'] = expected
        if return_values:
            data['ReturnValues'] = return_values
        json_input = json.dumps(data)
        return self.make_request('DeleteItem', json_input,
                                 object_hook=object_hook)

</source>
</class>

<class classid="71" nclones="3" nlines="14" similarity="72">
<source file="systems/boto-2.13.2/boto/swf/layer1_decisions.py" startline="175" endline="192" pcid="4173">
    def start_timer(self,
                    start_to_fire_timeout,
                    timer_id,
                    control=None):
        """
        Starts a timer for this workflow execution and records a TimerStarted
        event in the history.  This timer will fire after the specified delay
        and record a TimerFired event.
        """
        o = {}
        o['decisionType'] = 'StartTimer'
        attrs = o['startTimerDecisionAttributes'] = {}
        attrs['startToFireTimeout'] = start_to_fire_timeout
        attrs['timerId'] = timer_id
        if control is not None:
            attrs['control'] = control
        self._data.append(o)

</source>
<source file="systems/boto-2.13.2/boto/swf/layer1_decisions.py" startline="228" endline="247" pcid="4176">
    def request_cancel_external_workflow_execution(self,
                                                   workflow_id,
                                                   control=None,
                                                   run_id=None):
        """
        Requests that a request be made to cancel the specified
        external workflow execution and records a
        RequestCancelExternalWorkflowExecutionInitiated event in the
        history.
        """
        o = {}
        o['decisionType'] = 'RequestCancelExternalWorkflowExecution'
        attrs = o['requestCancelExternalWorkflowExecutionDecisionAttributes'] = {}
        attrs['workflowId'] = workflow_id
        if control is not None:
            attrs['control'] = control
        if run_id is not None:
            attrs['runId'] = run_id
        self._data.append(o)

</source>
<source file="systems/boto-2.13.2/boto/swf/layer1_decisions.py" startline="204" endline="227" pcid="4175">
    def signal_external_workflow_execution(self,
                                           workflow_id,
                                           signal_name,
                                           run_id=None,
                                           control=None,
                                           input=None):
        """
        Requests a signal to be delivered to the specified external workflow
        execution and records a SignalExternalWorkflowExecutionInitiated
        event in the history.
        """
        o = {}
        o['decisionType'] = 'SignalExternalWorkflowExecution'
        attrs = o['signalExternalWorkflowExecutionDecisionAttributes'] = {}
        attrs['workflowId'] = workflow_id
        attrs['signalName'] = signal_name
        if run_id is not None:
            attrs['runId'] = run_id
        if control is not None:
            attrs['control'] = control
        if input is not None:
            attrs['input'] = input
        self._data.append(o)

</source>
</class>

<class classid="72" nclones="2" nlines="14" similarity="100">
<source file="systems/boto-2.13.2/boto/swf/layer2.py" startline="68" endline="83" pcid="4184">
    def activities(self, status='REGISTERED', **kwargs):
        """ListActivityTypes."""
        act_types = self._swf.list_activity_types(self.name, status, **kwargs)
        act_objects = []
        for act_args in act_types['typeInfos']:
            act_ident = act_args['activityType']
            del act_args['activityType']
            act_args.update(act_ident)
            act_args.update({
                'aws_access_key_id': self.aws_access_key_id,
                'aws_secret_access_key': self.aws_secret_access_key,
                'domain': self.name,
            })
            act_objects.append(ActivityType(**act_args))
        return act_objects

</source>
<source file="systems/boto-2.13.2/boto/swf/layer2.py" startline="85" endline="101" pcid="4185">
    def workflows(self, status='REGISTERED', **kwargs):
        """ListWorkflowTypes."""
        wf_types = self._swf.list_workflow_types(self.name, status, **kwargs)
        wf_objects = []
        for wf_args in wf_types['typeInfos']:
            wf_ident = wf_args['workflowType']
            del wf_args['workflowType']
            wf_args.update(wf_ident)
            wf_args.update({
                'aws_access_key_id': self.aws_access_key_id,
                'aws_secret_access_key': self.aws_secret_access_key,
                'domain': self.name,
            })
            
            wf_objects.append(WorkflowType(**wf_args))
        return wf_objects

</source>
</class>

<class classid="73" nclones="5" nlines="12" similarity="75">
<source file="systems/boto-2.13.2/boto/swf/layer1.py" startline="275" endline="327" pcid="4221">
    def poll_for_decision_task(self, domain, task_list, identity=None,
                               maximum_page_size=None,
                               next_page_token=None,
                               reverse_order=None):
        """
        Used by deciders to get a DecisionTask from the specified
        decision taskList. A decision task may be returned for any
        open workflow execution that is using the specified task
        list. The task includes a paginated view of the history of the
        workflow execution. The decider should use the workflow type
        and the history to determine how to properly handle the task.

        :type domain: string
        :param domain: The name of the domain containing the task
            lists to poll.

        :type task_list: string
        :param task_list: Specifies the task list to poll for decision tasks.

        :type identity: string
        :param identity: Identity of the decider making the request,
            which is recorded in the DecisionTaskStarted event in the
            workflow history. This enables diagnostic tracing when
            problems arise. The form of this identity is user defined.

        :type maximum_page_size: integer :param maximum_page_size: The
            maximum number of history events returned in each page. The
            default is 100, but the caller can override this value to a
            page size smaller than the default. You cannot specify a page
            size greater than 100.

        :type next_page_token: string
        :param next_page_token: If on a previous call to this method a
            NextPageToken was returned, the results are being paginated.
            To get the next page of results, repeat the call with the
            returned token and all other arguments unchanged.

        :type reverse_order: boolean
        :param reverse_order: When set to true, returns the events in
            reverse order. By default the results are returned in
            ascending order of the eventTimestamp of the events.

        :raises: UnknownResourceFault, SWFOperationNotPermittedError
        """
        return self.json_request('PollForDecisionTask', {
            'domain': domain,
            'taskList': {'name': task_list},
            'identity': identity,
            'maximumPageSize': maximum_page_size,
            'nextPageToken': next_page_token,
            'reverseOrder': reverse_order,
        })

</source>
<source file="systems/boto-2.13.2/boto/swf/layer1.py" startline="1038" endline="1089" pcid="4238">
    def get_workflow_execution_history(self, domain, run_id, workflow_id,
                                       maximum_page_size=None,
                                       next_page_token=None,
                                       reverse_order=None):
        """
        Returns the history of the specified workflow execution. The
        results may be split into multiple pages. To retrieve
        subsequent pages, make the call again using the nextPageToken
        returned by the initial call.

        :type domain: string
        :param domain: The name of the domain containing the
            workflow execution.

        :type run_id: string
        :param run_id: A system generated unique identifier for the
            workflow execution.

        :type workflow_id: string
        :param workflow_id: The user defined identifier associated
            with the workflow execution.

        :type maximum_page_size: integer
        :param maximum_page_size: Specifies the maximum number of
            history events returned in one page. The next page in the
            result is identified by the NextPageToken returned. By default
            100 history events are returned in a page but the caller can
            override this value to a page size smaller than the
            default. You cannot specify a page size larger than 100.

        :type next_page_token: string
        :param next_page_token: If a NextPageToken is returned, the
            result has more than one pages. To get the next page, repeat
            the call and specify the nextPageToken with all other
            arguments unchanged.

        :type reverse_order: boolean
        :param reverse_order: When set to true, returns the events in
            reverse order. By default the results are returned in
            ascending order of the eventTimeStamp of the events.

        :raises: UnknownResourceFault, SWFOperationNotPermittedError
        """
        return self.json_request('GetWorkflowExecutionHistory', {
            'domain': domain,
            'execution': {'runId': run_id,
                          'workflowId': workflow_id},
            'maximumPageSize': maximum_page_size,
            'nextPageToken': next_page_token,
            'reverseOrder': reverse_order,
        })

</source>
<source file="systems/boto-2.13.2/boto/swf/layer1.py" startline="851" endline="908" pcid="4233">
    def list_activity_types(self, domain, registration_status,
                            name=None,
                            maximum_page_size=None,
                            next_page_token=None, reverse_order=None):
        """
        Returns information about all activities registered in the
        specified domain that match the specified name and
        registration status. The result includes information like
        creation date, current status of the activity, etc. The
        results may be split into multiple pages. To retrieve
        subsequent pages, make the call again using the nextPageToken
        returned by the initial call.

        :type domain: string
        :param domain: The name of the domain in which the activity
            types have been registered.

        :type registration_status: string
        :param registration_status: Specifies the registration status
            of the activity types to list.  Valid values are:

            * REGISTERED
            * DEPRECATED

        :type name: string
        :param name: If specified, only lists the activity types that
            have this name.

        :type maximum_page_size: integer
        :param maximum_page_size: The maximum number of results
            returned in each page. The default is 100, but the caller can
            override this value to a page size smaller than the
            default. You cannot specify a page size greater than 100.

        :type next_page_token: string
        :param next_page_token: If on a previous call to this method a
            NextResultToken was returned, the results have more than one
            page. To get the next page of results, repeat the call with
            the nextPageToken and keep all other arguments unchanged.

        :type reverse_order: boolean

        :param reverse_order: When set to true, returns the results in
            reverse order. By default the results are returned in
            ascending alphabetical order of the name of the activity
            types.

        :raises: SWFOperationNotPermittedError, UnknownResourceFault
        """
        return self.json_request('ListActivityTypes', {
            'domain': domain,
            'name': name,
            'registrationStatus': registration_status,
            'maximumPageSize': maximum_page_size,
            'nextPageToken': next_page_token,
            'reverseOrder': reverse_order,
        })

</source>
<source file="systems/boto-2.13.2/boto/swf/layer1.py" startline="935" endline="985" pcid="4235">
    def list_workflow_types(self, domain, registration_status,
                            maximum_page_size=None, name=None,
                            next_page_token=None, reverse_order=None):
        """
        Returns information about workflow types in the specified
        domain. The results may be split into multiple pages that can
        be retrieved by making the call repeatedly.

        :type domain: string
        :param domain: The name of the domain in which the workflow
            types have been registered.

        :type registration_status: string
        :param registration_status: Specifies the registration status
            of the activity types to list.  Valid values are:

            * REGISTERED
            * DEPRECATED

        :type name: string
        :param name: If specified, lists the workflow type with this name.

        :type maximum_page_size: integer
        :param maximum_page_size: The maximum number of results
            returned in each page. The default is 100, but the caller can
            override this value to a page size smaller than the
            default. You cannot specify a page size greater than 100.

        :type next_page_token: string
        :param next_page_token: If on a previous call to this method a
            NextPageToken was returned, the results are being
            paginated. To get the next page of results, repeat the call
            with the returned token and all other arguments unchanged.

        :type reverse_order: boolean
        :param reverse_order: When set to true, returns the results in
            reverse order. By default the results are returned in
            ascending alphabetical order of the name of the workflow
            types.

        :raises: SWFOperationNotPermittedError, UnknownResourceFault
        """
        return self.json_request('ListWorkflowTypes', {
            'domain': domain,
            'name': name,
            'registrationStatus': registration_status,
            'maximumPageSize': maximum_page_size,
            'nextPageToken': next_page_token,
            'reverseOrder': reverse_order,
        })

</source>
<source file="systems/boto-2.13.2/boto/swf/layer1.py" startline="519" endline="581" pcid="4226">
    def terminate_workflow_execution(self, domain, workflow_id,
                                     child_policy=None, details=None,
                                     reason=None, run_id=None):
        """
        Records a WorkflowExecutionTerminated event and forces closure
        of the workflow execution identified by the given domain,
        runId, and workflowId. The child policy, registered with the
        workflow type or specified when starting this execution, is
        applied to any open child workflow executions of this workflow
        execution.

        :type domain: string
        :param domain: The domain of the workflow execution to terminate.

        :type workflow_id: string
        :param workflow_id: The workflowId of the workflow execution
            to terminate.

        :type child_policy: string
        :param child_policy: If set, specifies the policy to use for
            the child workflow executions of the workflow execution being
            terminated. This policy overrides the child policy specified
            for the workflow execution at registration time or when
            starting the execution. The supported child policies are:

            * TERMINATE: the child executions will be terminated.

            * REQUEST_CANCEL: a request to cancel will be attempted
              for each child execution by recording a
              WorkflowExecutionCancelRequested event in its
              history. It is up to the decider to take appropriate
              actions when it receives an execution history with this
              event.

            * ABANDON: no action will be taken. The child executions
              will continue to run.

        :type details: string
        :param details: Optional details for terminating the
            workflow execution.

        :type reason: string
        :param reason: An optional descriptive reason for terminating
            the workflow execution.

        :type run_id: string
        :param run_id: The runId of the workflow execution to terminate.

        :raises: UnknownResourceFault, SWFOperationNotPermittedError
        """
        return self.json_request('TerminateWorkflowExecution', {
            'domain': domain,
            'workflowId': workflow_id,
            'childPolicy': child_policy,
            'details': details,
            'reason': reason,
            'runId': run_id,
        })

# Actions related to Administration

## Activity Management

</source>
</class>

<class classid="74" nclones="2" nlines="17" similarity="88">
<source file="systems/boto-2.13.2/boto/swf/layer1.py" startline="582" endline="660" pcid="4227">
    def register_activity_type(self, domain, name, version, task_list=None,
                               default_task_heartbeat_timeout=None,
                               default_task_schedule_to_close_timeout=None,
                               default_task_schedule_to_start_timeout=None,
                               default_task_start_to_close_timeout=None,
                               description=None):
        """
        Registers a new activity type along with its configuration
        settings in the specified domain.

        :type domain: string
        :param domain: The name of the domain in which this activity is
            to be registered.

        :type name: string
        :param name: The name of the activity type within the domain.

        :type version: string
        :param version: The version of the activity type.

        :type task_list: string
        :param task_list: If set, specifies the default task list to
            use for scheduling tasks of this activity type. This default
            task list is used if a task list is not provided when a task
            is scheduled through the schedule_activity_task Decision.

        :type default_task_heartbeat_timeout: string
        :param default_task_heartbeat_timeout: If set, specifies the
            default maximum time before which a worker processing a task
            of this type must report progress by calling
            RecordActivityTaskHeartbeat. If the timeout is exceeded, the
            activity task is automatically timed out. This default can be
            overridden when scheduling an activity task using the
            ScheduleActivityTask Decision. If the activity worker
            subsequently attempts to record a heartbeat or returns a
            result, the activity worker receives an UnknownResource
            fault. In this case, Amazon SWF no longer considers the
            activity task to be valid; the activity worker should clean up
            the activity task.no docs

        :type default_task_schedule_to_close_timeout: string
        :param default_task_schedule_to_close_timeout: If set,
            specifies the default maximum duration for a task of this
            activity type. This default can be overridden when scheduling
            an activity task using the ScheduleActivityTask Decision.no
            docs

        :type default_task_schedule_to_start_timeout: string
        :param default_task_schedule_to_start_timeout: If set,
            specifies the default maximum duration that a task of this
            activity type can wait before being assigned to a worker. This
            default can be overridden when scheduling an activity task
            using the ScheduleActivityTask Decision.

        :type default_task_start_to_close_timeout: string
        :param default_task_start_to_close_timeout: If set, specifies
            the default maximum duration that a worker can take to process
            tasks of this activity type. This default can be overridden
            when scheduling an activity task using the
            ScheduleActivityTask Decision.

        :type description: string
        :param description: A textual description of the activity type.

        :raises: SWFTypeAlreadyExistsError, SWFLimitExceededError,
            UnknownResourceFault, SWFOperationNotPermittedError
        """
        return self.json_request('RegisterActivityType', {
            'domain': domain,
            'name': name,
            'version': version,
            'defaultTaskList': {'name': task_list},
            'defaultTaskHeartbeatTimeout': default_task_heartbeat_timeout,
            'defaultTaskScheduleToCloseTimeout': default_task_schedule_to_close_timeout,
            'defaultTaskScheduleToStartTimeout': default_task_schedule_to_start_timeout,
            'defaultTaskStartToCloseTimeout': default_task_start_to_close_timeout,
            'description': description,
        })

</source>
<source file="systems/boto-2.13.2/boto/swf/layer1.py" startline="688" endline="768" pcid="4229">
    def register_workflow_type(self, domain, name, version,
                               task_list=None,
                               default_child_policy=None,
                               default_execution_start_to_close_timeout=None,
                               default_task_start_to_close_timeout=None,
                               description=None):
        """
        Registers a new workflow type and its configuration settings
        in the specified domain.

        :type domain: string
        :param domain: The name of the domain in which to register
            the workflow type.

        :type name: string
        :param name: The name of the workflow type.

        :type version: string
        :param version: The version of the workflow type.

        :type task_list: list of name, version of tasks
        :param task_list: If set, specifies the default task list to use
            for scheduling decision tasks for executions of this workflow
            type. This default is used only if a task list is not provided
            when starting the execution through the StartWorkflowExecution
            Action or StartChildWorkflowExecution Decision.

        :type default_child_policy: string

        :param default_child_policy: If set, specifies the default
            policy to use for the child workflow executions when a
            workflow execution of this type is terminated, by calling the
            TerminateWorkflowExecution action explicitly or due to an
            expired timeout. This default can be overridden when starting
            a workflow execution using the StartWorkflowExecution action
            or the StartChildWorkflowExecution Decision. The supported
            child policies are:

            * TERMINATE: the child executions will be terminated.

            * REQUEST_CANCEL: a request to cancel will be attempted
              for each child execution by recording a
              WorkflowExecutionCancelRequested event in its
              history. It is up to the decider to take appropriate
              actions when it receives an execution history with this
              event.

            * ABANDON: no action will be taken. The child executions
              will continue to run.no docs

        :type default_execution_start_to_close_timeout: string
        :param default_execution_start_to_close_timeout: If set,
            specifies the default maximum duration for executions of this
            workflow type. You can override this default when starting an
            execution through the StartWorkflowExecution Action or
            StartChildWorkflowExecution Decision.

        :type default_task_start_to_close_timeout: string
        :param default_task_start_to_close_timeout: If set, specifies
            the default maximum duration of decision tasks for this
            workflow type. This default can be overridden when starting a
            workflow execution using the StartWorkflowExecution action or
            the StartChildWorkflowExecution Decision.

        :type description: string
        :param description: Textual description of the workflow type.

        :raises: SWFTypeAlreadyExistsError, SWFLimitExceededError,
            UnknownResourceFault, SWFOperationNotPermittedError
        """
        return self.json_request('RegisterWorkflowType', {
            'domain': domain,
            'name': name,
            'version': version,
            'defaultTaskList':  {'name': task_list},
            'defaultChildPolicy': default_child_policy,
            'defaultExecutionStartToCloseTimeout': default_execution_start_to_close_timeout,
            'defaultTaskStartToCloseTimeout': default_task_start_to_close_timeout,
            'description': description,
        })

</source>
</class>

<class classid="75" nclones="3" nlines="24" similarity="71">
<source file="systems/boto-2.13.2/boto/swf/layer1.py" startline="1141" endline="1219" pcid="4240">
    def list_open_workflow_executions(self, domain,
                                      oldest_date,
                                      latest_date=None,
                                      tag=None,
                                      workflow_id=None,
                                      workflow_name=None,
                                      workflow_version=None,
                                      maximum_page_size=None,
                                      next_page_token=None,
                                      reverse_order=None):
        """
        Returns the list of open workflow executions within the
        given domain that meet the specified filtering criteria.

        .. note:
            workflow_id, workflow_name/workflow_version
            and tag are mutually exclusive. You can specify at most
            one of these in a request.

        :type domain: string
        :param domain: The name of the domain containing the
            workflow executions to count.

        :type latest_date: timestamp
        :param latest_date: Specifies the latest start or close date
            and time to return.

        :type oldest_date: timestamp
        :param oldest_date: Specifies the oldest start or close date
            and time to return.

        :type tag: string
        :param tag: If specified, only executions that have a tag
            that matches the filter are counted.

        :type workflow_id: string
        :param workflow_id: If specified, only workflow executions
            matching the workflow_id are counted.

        :type workflow_name: string
        :param workflow_name: Name of the workflow type to filter on.

        :type workflow_version: string
        :param workflow_version: Version of the workflow type to filter on.

        :type maximum_page_size: integer
        :param maximum_page_size: The maximum number of results
            returned in each page. The default is 100, but the caller can
            override this value to a page size smaller than the
            default. You cannot specify a page size greater than 100.

        :type next_page_token: string
        :param next_page_token: If on a previous call to this method a
            NextPageToken was returned, the results are being
            paginated. To get the next page of results, repeat the call
            with the returned token and all other arguments unchanged.

        :type reverse_order: boolean
        :param reverse_order: When set to true, returns the results in
            reverse order. By default the results are returned in
            descending order of the start or the close time of the
            executions.

        :raises: UnknownResourceFault, SWFOperationNotPermittedError

        """
        return self.json_request('ListOpenWorkflowExecutions', {
            'domain': domain,
            'startTimeFilter': {'oldestDate': oldest_date,
                                'latestDate': latest_date},
            'tagFilter': {'tag': tag},
            'typeFilter': {'name': workflow_name,
                           'version': workflow_version},
            'executionFilter': {'workflowId': workflow_id},
            'maximumPageSize': maximum_page_size,
            'nextPageToken': next_page_token,
            'reverseOrder': reverse_order,
        })

</source>
<source file="systems/boto-2.13.2/boto/swf/layer1.py" startline="1305" endline="1415" pcid="4242">
    def list_closed_workflow_executions(self, domain,
                                        start_latest_date=None,
                                        start_oldest_date=None,
                                        close_latest_date=None,
                                        close_oldest_date=None,
                                        close_status=None,
                                        tag=None,
                                        workflow_id=None,
                                        workflow_name=None,
                                        workflow_version=None,
                                        maximum_page_size=None,
                                        next_page_token=None,
                                        reverse_order=None):
        """
        Returns the number of closed workflow executions within the
        given domain that meet the specified filtering criteria.

        .. note:
            close_status, workflow_id, workflow_name/workflow_version
            and tag are mutually exclusive. You can specify at most
            one of these in a request.

        .. note:
            start_latest_date/start_oldest_date and
            close_latest_date/close_oldest_date are mutually
            exclusive. You can specify at most one of these in a request.

        :type domain: string
        :param domain: The name of the domain containing the
            workflow executions to count.

        :type start_latest_date: timestamp
        :param start_latest_date: If specified, only workflow executions
            that meet the start time criteria of the filter are counted.

        :type start_oldest_date: timestamp
        :param start_oldest_date: If specified, only workflow executions
            that meet the start time criteria of the filter are counted.

        :type close_latest_date: timestamp
        :param close_latest_date: If specified, only workflow executions
            that meet the close time criteria of the filter are counted.

        :type close_oldest_date: timestamp
        :param close_oldest_date: If specified, only workflow executions
            that meet the close time criteria of the filter are counted.

        :type close_status: string
        :param close_status: The close status that must match the close status
            of an execution for it to meet the criteria of this filter.
            Valid values are:

            * COMPLETED
            * FAILED
            * CANCELED
            * TERMINATED
            * CONTINUED_AS_NEW
            * TIMED_OUT

        :type tag: string
        :param tag: If specified, only executions that have a tag
            that matches the filter are counted.

        :type workflow_id: string
        :param workflow_id: If specified, only workflow executions
            matching the workflow_id are counted.

        :type workflow_name: string
        :param workflow_name: Name of the workflow type to filter on.

        :type workflow_version: string
        :param workflow_version: Version of the workflow type to filter on.

        :type maximum_page_size: integer
        :param maximum_page_size: The maximum number of results
            returned in each page. The default is 100, but the caller can
            override this value to a page size smaller than the
            default. You cannot specify a page size greater than 100.

        :type next_page_token: string
        :param next_page_token: If on a previous call to this method a
            NextPageToken was returned, the results are being
            paginated. To get the next page of results, repeat the call
            with the returned token and all other arguments unchanged.

        :type reverse_order: boolean
        :param reverse_order: When set to true, returns the results in
            reverse order. By default the results are returned in
            descending order of the start or the close time of the
            executions.

        :raises: UnknownResourceFault, SWFOperationNotPermittedError
        """
        return self.json_request('ListClosedWorkflowExecutions', {
            'domain': domain,
            'startTimeFilter': {'oldestDate': start_oldest_date,
                                'latestDate': start_latest_date},
            'closeTimeFilter': {'oldestDate': close_oldest_date,
                                'latestDate': close_latest_date},
            'executionFilter': {'workflowId': workflow_id},
            'closeStatusFilter': {'status': close_status},
            'tagFilter': {'tag': tag},
            'typeFilter': {'name': workflow_name,
                           'version': workflow_version},
            'maximumPageSize': maximum_page_size,
            'nextPageToken': next_page_token,
            'reverseOrder': reverse_order,
        })

## Domain Visibility

</source>
<source file="systems/boto-2.13.2/boto/swf/layer1.py" startline="1220" endline="1304" pcid="4241">
    def count_closed_workflow_executions(self, domain,
                                         start_latest_date=None,
                                         start_oldest_date=None,
                                         close_latest_date=None,
                                         close_oldest_date=None,
                                         close_status=None,
                                         tag=None,
                                         workflow_id=None,
                                         workflow_name=None,
                                         workflow_version=None):
        """
        Returns the number of closed workflow executions within the
        given domain that meet the specified filtering criteria.

        .. note:
            close_status, workflow_id, workflow_name/workflow_version
            and tag are mutually exclusive. You can specify at most
            one of these in a request.

        .. note:
            start_latest_date/start_oldest_date and
            close_latest_date/close_oldest_date are mutually
            exclusive. You can specify at most one of these in a request.

        :type domain: string
        :param domain: The name of the domain containing the
            workflow executions to count.

        :type start_latest_date: timestamp
        :param start_latest_date: If specified, only workflow executions
            that meet the start time criteria of the filter are counted.

        :type start_oldest_date: timestamp
        :param start_oldest_date: If specified, only workflow executions
            that meet the start time criteria of the filter are counted.

        :type close_latest_date: timestamp
        :param close_latest_date: If specified, only workflow executions
            that meet the close time criteria of the filter are counted.

        :type close_oldest_date: timestamp
        :param close_oldest_date: If specified, only workflow executions
            that meet the close time criteria of the filter are counted.

        :type close_status: string
        :param close_status: The close status that must match the close status
            of an execution for it to meet the criteria of this filter.
            Valid values are:

            * COMPLETED
            * FAILED
            * CANCELED
            * TERMINATED
            * CONTINUED_AS_NEW
            * TIMED_OUT

        :type tag: string
        :param tag: If specified, only executions that have a tag
            that matches the filter are counted.

        :type workflow_id: string
        :param workflow_id: If specified, only workflow executions
            matching the workflow_id are counted.

        :type workflow_name: string
        :param workflow_name: Name of the workflow type to filter on.

        :type workflow_version: string
        :param workflow_version: Version of the workflow type to filter on.

        :raises: UnknownResourceFault, SWFOperationNotPermittedError
        """
        return self.json_request('CountClosedWorkflowExecutions', {
            'domain': domain,
            'startTimeFilter': {'oldestDate': start_oldest_date,
                                'latestDate': start_latest_date},
            'closeTimeFilter': {'oldestDate': close_oldest_date,
                                'latestDate': close_latest_date},
            'closeStatusFilter': {'status': close_status},
            'tagFilter': {'tag': tag},
            'typeFilter': {'name': workflow_name,
                           'version': workflow_version},
            'executionFilter': {'workflowId': workflow_id}
        })

</source>
</class>

<class classid="76" nclones="2" nlines="12" similarity="83">
<source file="systems/boto-2.13.2/boto/__init__.py" startline="80" endline="93" pcid="4255">
def set_file_logger(name, filepath, level=logging.INFO, format_string=None):
    global log
    if not format_string:
        format_string = "%(asctime)s %(name)s [%(levelname)s]:%(message)s"
    logger = logging.getLogger(name)
    logger.setLevel(level)
    fh = logging.FileHandler(filepath)
    fh.setLevel(level)
    formatter = logging.Formatter(format_string)
    fh.setFormatter(formatter)
    logger.addHandler(fh)
    log = logger


</source>
<source file="systems/boto-2.13.2/boto/__init__.py" startline="94" endline="107" pcid="4256">
def set_stream_logger(name, level=logging.DEBUG, format_string=None):
    global log
    if not format_string:
        format_string = "%(asctime)s %(name)s [%(levelname)s]:%(message)s"
    logger = logging.getLogger(name)
    logger.setLevel(level)
    fh = logging.StreamHandler()
    fh.setLevel(level)
    formatter = logging.Formatter(format_string)
    fh.setFormatter(formatter)
    logger.addHandler(fh)
    log = logger


</source>
</class>

<class classid="77" nclones="2" nlines="20" similarity="80">
<source file="systems/boto-2.13.2/boto/__init__.py" startline="389" endline="427" pcid="4275">
def connect_euca(host=None, aws_access_key_id=None, aws_secret_access_key=None,
                 port=8773, path='/services/Eucalyptus', is_secure=False,
                 **kwargs):
    """
    Connect to a Eucalyptus service.

    :type host: string
    :param host: the host name or ip address of the Eucalyptus server

    :type aws_access_key_id: string
    :param aws_access_key_id: Your AWS Access Key ID

    :type aws_secret_access_key: string
    :param aws_secret_access_key: Your AWS Secret Access Key

    :rtype: :class:`boto.ec2.connection.EC2Connection`
    :return: A connection to Eucalyptus server
    """
    from boto.ec2 import EC2Connection
    from boto.ec2.regioninfo import RegionInfo

    # Check for values in boto config, if not supplied as args
    if not aws_access_key_id:
        aws_access_key_id = config.get('Credentials',
                                       'euca_access_key_id',
                                       None)
    if not aws_secret_access_key:
        aws_secret_access_key = config.get('Credentials',
                                           'euca_secret_access_key',
                                           None)
    if not host:
        host = config.get('Boto', 'eucalyptus_host', None)

    reg = RegionInfo(name='eucalyptus', endpoint=host)
    return EC2Connection(aws_access_key_id, aws_secret_access_key,
                         region=reg, port=port, path=path,
                         is_secure=is_secure, **kwargs)


</source>
<source file="systems/boto-2.13.2/boto/__init__.py" startline="481" endline="520" pcid="4278">
def connect_walrus(host=None, aws_access_key_id=None,
                   aws_secret_access_key=None,
                   port=8773, path='/services/Walrus', is_secure=False,
                   **kwargs):
    """
    Connect to a Walrus service.

    :type host: string
    :param host: the host name or ip address of the Walrus server

    :type aws_access_key_id: string
    :param aws_access_key_id: Your AWS Access Key ID

    :type aws_secret_access_key: string
    :param aws_secret_access_key: Your AWS Secret Access Key

    :rtype: :class:`boto.s3.connection.S3Connection`
    :return: A connection to Walrus
    """
    from boto.s3.connection import S3Connection
    from boto.s3.connection import OrdinaryCallingFormat

    # Check for values in boto config, if not supplied as args
    if not aws_access_key_id:
        aws_access_key_id = config.get('Credentials',
                                       'euca_access_key_id',
                                       None)
    if not aws_secret_access_key:
        aws_secret_access_key = config.get('Credentials',
                                           'euca_secret_access_key',
                                           None)
    if not host:
        host = config.get('Boto', 'walrus_host', None)

    return S3Connection(aws_access_key_id, aws_secret_access_key,
                        host=host, port=port, path=path,
                        calling_format=OrdinaryCallingFormat(),
                        is_secure=is_secure, **kwargs)


</source>
</class>

<class classid="78" nclones="2" nlines="11" similarity="70">
<source file="systems/boto-2.13.2/tests/integration/ec2/cloudwatch/test_connection.py" startline="106" endline="117" pcid="4342">
    def test_build_list_params(self):
        c = CloudWatchConnection()
        params = {}
        c.build_list_params(
            params, ['thing1', 'thing2', 'thing3'], 'ThingName%d')
        expected_params = {
            'ThingName1': 'thing1',
            'ThingName2': 'thing2',
            'ThingName3': 'thing3'
            }
        self.assertEqual(params, expected_params)

</source>
<source file="systems/boto-2.13.2/tests/integration/ec2/cloudwatch/test_connection.py" startline="118" endline="129" pcid="4343">
    def test_build_put_params_one(self):
        c = CloudWatchConnection()
        params = {}
        c.build_put_params(params, name="N", value=1, dimensions={"D": "V"})
        expected_params = {
            'MetricData.member.1.MetricName': 'N',
            'MetricData.member.1.Value': 1,
            'MetricData.member.1.Dimensions.member.1.Name': 'D',
            'MetricData.member.1.Dimensions.member.1.Value': 'V',
            }
        self.assertEqual(params, expected_params)

</source>
</class>

<class classid="79" nclones="2" nlines="15" similarity="92">
<source file="systems/boto-2.13.2/tests/integration/ec2/cloudwatch/test_connection.py" startline="130" endline="145" pcid="4344">
    def test_build_put_params_multiple_metrics(self):
        c = CloudWatchConnection()
        params = {}
        c.build_put_params(params, name=["N", "M"], value=[1, 2], dimensions={"D": "V"})
        expected_params = {
            'MetricData.member.1.MetricName': 'N',
            'MetricData.member.1.Value': 1,
            'MetricData.member.1.Dimensions.member.1.Name': 'D',
            'MetricData.member.1.Dimensions.member.1.Value': 'V',
            'MetricData.member.2.MetricName': 'M',
            'MetricData.member.2.Value': 2,
            'MetricData.member.2.Dimensions.member.1.Name': 'D',
            'MetricData.member.2.Dimensions.member.1.Value': 'V',
            }
        self.assertEqual(params, expected_params)

</source>
<source file="systems/boto-2.13.2/tests/integration/ec2/cloudwatch/test_connection.py" startline="146" endline="161" pcid="4345">
    def test_build_put_params_multiple_dimensions(self):
        c = CloudWatchConnection()
        params = {}
        c.build_put_params(params, name="N", value=[1, 2], dimensions=[{"D": "V"}, {"D": "W"}])
        expected_params = {
            'MetricData.member.1.MetricName': 'N',
            'MetricData.member.1.Value': 1,
            'MetricData.member.1.Dimensions.member.1.Name': 'D',
            'MetricData.member.1.Dimensions.member.1.Value': 'V',
            'MetricData.member.2.MetricName': 'N',
            'MetricData.member.2.Value': 2,
            'MetricData.member.2.Dimensions.member.1.Name': 'D',
            'MetricData.member.2.Dimensions.member.1.Value': 'W',
            }
        self.assertEqual(params, expected_params)

</source>
</class>

<class classid="80" nclones="2" nlines="16" similarity="75">
<source file="systems/boto-2.13.2/tests/integration/ec2/cloudwatch/test_connection.py" startline="182" endline="196" pcid="4347">
    def test_build_get_params_multiple_parameter_dimension1(self):
        from collections import OrderedDict
        self.maxDiff = None
        c = CloudWatchConnection()
        params = {}
        dimensions = OrderedDict((("D1", "V"), ("D2", "W")))
        c.build_dimension_param(dimensions, params)
        expected_params = {
            'Dimensions.member.1.Name': 'D1',
            'Dimensions.member.1.Value': 'V',
            'Dimensions.member.2.Name': 'D2',
            'Dimensions.member.2.Value': 'W',
            }
        self.assertEqual(params, expected_params)

</source>
<source file="systems/boto-2.13.2/tests/integration/ec2/cloudwatch/test_connection.py" startline="197" endline="214" pcid="4348">
    def test_build_get_params_multiple_parameter_dimension2(self):
        from collections import OrderedDict
        self.maxDiff = None
        c = CloudWatchConnection()
        params = {}
        dimensions = OrderedDict((("D1", ["V1", "V2"]), ("D2", "W"), ("D3", None)))
        c.build_dimension_param(dimensions, params)
        expected_params = {
            'Dimensions.member.1.Name': 'D1',
            'Dimensions.member.1.Value': 'V1',
            'Dimensions.member.2.Name': 'D1',
            'Dimensions.member.2.Value': 'V2',
            'Dimensions.member.3.Name': 'D2',
            'Dimensions.member.3.Value': 'W',
            'Dimensions.member.4.Name': 'D3',
            }
        self.assertEqual(params, expected_params)

</source>
</class>

<class classid="81" nclones="4" nlines="10" similarity="70">
<source file="systems/boto-2.13.2/tests/integration/gs/test_resumable_downloads.py" startline="75" endline="88" pcid="4668">
    def test_download_without_persistent_tracker(self):
        """
        Tests a single resumable download, with no tracker persistence
        """
        res_download_handler = ResumableDownloadHandler()
        dst_fp = self.make_dst_fp()
        small_src_key_as_string, small_src_key = self.make_small_key()
        small_src_key.get_contents_to_file(
            dst_fp, res_download_handler=res_download_handler)
        self.assertEqual(SMALL_KEY_SIZE,
                         get_cur_file_size(dst_fp))
        self.assertEqual(small_src_key_as_string,
                         small_src_key.get_contents_as_string())

</source>
<source file="systems/boto-2.13.2/tests/integration/gs/test_resumable_uploads.py" startline="93" endline="106" pcid="4708">
    def test_upload_without_persistent_tracker(self):
        """
        Tests a single resumable upload, with no tracker URI persistence
        """
        res_upload_handler = ResumableUploadHandler()
        small_src_file_as_string, small_src_file = self.make_small_file()
        small_src_file.seek(0)
        dst_key = self._MakeKey(set_contents=False)
        dst_key.set_contents_from_file(
            small_src_file, res_upload_handler=res_upload_handler)
        self.assertEqual(SMALL_KEY_SIZE, dst_key.size)
        self.assertEqual(small_src_file_as_string,
                         dst_key.get_contents_as_string())

</source>
<source file="systems/boto-2.13.2/tests/integration/gs/test_resumable_downloads.py" startline="194" endline="208" pcid="4674">
    def test_multiple_in_process_failures_then_succeed(self):
        """
        Tests resumable download that fails twice in one process, then completes
        """
        res_download_handler = ResumableDownloadHandler(num_retries=3)
        dst_fp = self.make_dst_fp()
        small_src_key_as_string, small_src_key = self.make_small_key()
        small_src_key.get_contents_to_file(
            dst_fp, res_download_handler=res_download_handler)
        # Ensure downloaded object has correct content.
        self.assertEqual(SMALL_KEY_SIZE,
                         get_cur_file_size(dst_fp))
        self.assertEqual(small_src_key_as_string,
                         small_src_key.get_contents_as_string())

</source>
<source file="systems/boto-2.13.2/tests/integration/gs/test_resumable_uploads.py" startline="214" endline="228" pcid="4714">
    def test_multiple_in_process_failures_then_succeed(self):
        """
        Tests resumable upload that fails twice in one process, then completes
        """
        res_upload_handler = ResumableUploadHandler(num_retries=3)
        small_src_file_as_string, small_src_file = self.make_small_file()
        small_src_file.seek(0)
        dst_key = self._MakeKey(set_contents=False)
        dst_key.set_contents_from_file(
            small_src_file, res_upload_handler=res_upload_handler)
        # Ensure uploaded object has correct content.
        self.assertEqual(SMALL_KEY_SIZE, dst_key.size)
        self.assertEqual(small_src_file_as_string,
                         dst_key.get_contents_as_string())

</source>
</class>

<class classid="82" nclones="2" nlines="21" similarity="72">
<source file="systems/boto-2.13.2/tests/integration/gs/test_resumable_downloads.py" startline="89" endline="115" pcid="4669">
    def test_failed_download_with_persistent_tracker(self):
        """
        Tests that failed resumable download leaves a correct tracker file
        """
        harness = CallbackTestHarness()
        tmpdir = self._MakeTempDir()
        tracker_file_name = self.make_tracker_file(tmpdir)
        dst_fp = self.make_dst_fp(tmpdir)
        res_download_handler = ResumableDownloadHandler(
            tracker_file_name=tracker_file_name, num_retries=0)
        small_src_key_as_string, small_src_key = self.make_small_key()
        try:
            small_src_key.get_contents_to_file(
                dst_fp, cb=harness.call,
                res_download_handler=res_download_handler)
            self.fail('Did not get expected ResumableDownloadException')
        except ResumableDownloadException, e:
            # We'll get a ResumableDownloadException at this point because
            # of CallbackTestHarness (above). Check that the tracker file was
            # created correctly.
            self.assertEqual(e.disposition,
                             ResumableTransferDisposition.ABORT_CUR_PROCESS)
            self.assertTrue(os.path.exists(tracker_file_name))
            f = open(tracker_file_name)
            etag_line = f.readline()
            self.assertEquals(etag_line.rstrip('\n'), small_src_key.etag.strip('"\''))

</source>
<source file="systems/boto-2.13.2/tests/integration/gs/test_resumable_uploads.py" startline="107" endline="135" pcid="4709">
    def test_failed_upload_with_persistent_tracker(self):
        """
        Tests that failed resumable upload leaves a correct tracker URI file
        """
        harness = CallbackTestHarness()
        tracker_file_name = self.make_tracker_file()
        res_upload_handler = ResumableUploadHandler(
            tracker_file_name=tracker_file_name, num_retries=0)
        small_src_file_as_string, small_src_file = self.make_small_file()
        small_src_file.seek(0)
        dst_key = self._MakeKey(set_contents=False)
        try:
            dst_key.set_contents_from_file(
                small_src_file, cb=harness.call,
                res_upload_handler=res_upload_handler)
            self.fail('Did not get expected ResumableUploadException')
        except ResumableUploadException, e:
            # We'll get a ResumableUploadException at this point because
            # of CallbackTestHarness (above). Check that the tracker file was
            # created correctly.
            self.assertEqual(e.disposition,
                             ResumableTransferDisposition.ABORT_CUR_PROCESS)
            self.assertTrue(os.path.exists(tracker_file_name))
            f = open(tracker_file_name)
            uri_from_file = f.readline().strip()
            f.close()
            self.assertEqual(uri_from_file,
                             res_upload_handler.get_tracker_uri())

</source>
</class>

<class classid="83" nclones="4" nlines="13" similarity="76">
<source file="systems/boto-2.13.2/tests/integration/gs/test_resumable_downloads.py" startline="116" endline="134" pcid="4670">
    def test_retryable_exception_recovery(self):
        """
        Tests handling of a retryable exception
        """
        # Test one of the RETRYABLE_EXCEPTIONS.
        exception = ResumableDownloadHandler.RETRYABLE_EXCEPTIONS[0]
        harness = CallbackTestHarness(exception=exception)
        res_download_handler = ResumableDownloadHandler(num_retries=1)
        dst_fp = self.make_dst_fp()
        small_src_key_as_string, small_src_key = self.make_small_key()
        small_src_key.get_contents_to_file(
            dst_fp, cb=harness.call,
            res_download_handler=res_download_handler)
        # Ensure downloaded object has correct content.
        self.assertEqual(SMALL_KEY_SIZE,
                         get_cur_file_size(dst_fp))
        self.assertEqual(small_src_key_as_string,
                         small_src_key.get_contents_as_string())

</source>
<source file="systems/boto-2.13.2/tests/integration/gs/test_resumable_uploads.py" startline="136" endline="154" pcid="4710">
    def test_retryable_exception_recovery(self):
        """
        Tests handling of a retryable exception
        """
        # Test one of the RETRYABLE_EXCEPTIONS.
        exception = ResumableUploadHandler.RETRYABLE_EXCEPTIONS[0]
        harness = CallbackTestHarness(exception=exception)
        res_upload_handler = ResumableUploadHandler(num_retries=1)
        small_src_file_as_string, small_src_file = self.make_small_file()
        small_src_file.seek(0)
        dst_key = self._MakeKey(set_contents=False)
        dst_key.set_contents_from_file(
            small_src_file, cb=harness.call,
            res_upload_handler=res_upload_handler)
        # Ensure uploaded object has correct content.
        self.assertEqual(SMALL_KEY_SIZE, dst_key.size)
        self.assertEqual(small_src_file_as_string,
                         dst_key.get_contents_as_string())

</source>
<source file="systems/boto-2.13.2/tests/integration/gs/test_resumable_downloads.py" startline="135" endline="152" pcid="4671">
    def test_broken_pipe_recovery(self):
        """
        Tests handling of a Broken Pipe (which interacts with an httplib bug)
        """
        exception = IOError(errno.EPIPE, "Broken pipe")
        harness = CallbackTestHarness(exception=exception)
        res_download_handler = ResumableDownloadHandler(num_retries=1)
        dst_fp = self.make_dst_fp()
        small_src_key_as_string, small_src_key = self.make_small_key()
        small_src_key.get_contents_to_file(
            dst_fp, cb=harness.call,
            res_download_handler=res_download_handler)
        # Ensure downloaded object has correct content.
        self.assertEqual(SMALL_KEY_SIZE,
                         get_cur_file_size(dst_fp))
        self.assertEqual(small_src_key_as_string,
                         small_src_key.get_contents_as_string())

</source>
<source file="systems/boto-2.13.2/tests/integration/gs/test_resumable_uploads.py" startline="155" endline="172" pcid="4711">
    def test_broken_pipe_recovery(self):
        """
        Tests handling of a Broken Pipe (which interacts with an httplib bug)
        """
        exception = IOError(errno.EPIPE, "Broken pipe")
        harness = CallbackTestHarness(exception=exception)
        res_upload_handler = ResumableUploadHandler(num_retries=1)
        small_src_file_as_string, small_src_file = self.make_small_file()
        small_src_file.seek(0)
        dst_key = self._MakeKey(set_contents=False)
        dst_key.set_contents_from_file(
            small_src_file, cb=harness.call,
            res_upload_handler=res_upload_handler)
        # Ensure uploaded object has correct content.
        self.assertEqual(SMALL_KEY_SIZE, dst_key.size)
        self.assertEqual(small_src_file_as_string,
                         dst_key.get_contents_as_string())

</source>
</class>

<class classid="84" nclones="2" nlines="14" similarity="85">
<source file="systems/boto-2.13.2/tests/integration/gs/test_resumable_downloads.py" startline="153" endline="170" pcid="4672">
    def test_non_retryable_exception_handling(self):
        """
        Tests resumable download that fails with a non-retryable exception
        """
        harness = CallbackTestHarness(
            exception=OSError(errno.EACCES, 'Permission denied'))
        res_download_handler = ResumableDownloadHandler(num_retries=1)
        dst_fp = self.make_dst_fp()
        small_src_key_as_string, small_src_key = self.make_small_key()
        try:
            small_src_key.get_contents_to_file(
                dst_fp, cb=harness.call,
                res_download_handler=res_download_handler)
            self.fail('Did not get expected OSError')
        except OSError, e:
            # Ensure the error was re-raised.
            self.assertEqual(e.errno, 13)

</source>
<source file="systems/boto-2.13.2/tests/integration/gs/test_resumable_uploads.py" startline="173" endline="191" pcid="4712">
    def test_non_retryable_exception_handling(self):
        """
        Tests a resumable upload that fails with a non-retryable exception
        """
        harness = CallbackTestHarness(
            exception=OSError(errno.EACCES, 'Permission denied'))
        res_upload_handler = ResumableUploadHandler(num_retries=1)
        small_src_file_as_string, small_src_file = self.make_small_file()
        small_src_file.seek(0)
        dst_key = self._MakeKey(set_contents=False)
        try:
            dst_key.set_contents_from_file(
                small_src_file, cb=harness.call,
                res_upload_handler=res_upload_handler)
            self.fail('Did not get expected OSError')
        except OSError, e:
            # Ensure the error was re-raised.
            self.assertEqual(e.errno, 13)

</source>
</class>

<class classid="85" nclones="2" nlines="30" similarity="73">
<source file="systems/boto-2.13.2/tests/integration/gs/test_resumable_downloads.py" startline="209" endline="249" pcid="4675">
    def test_multiple_in_process_failures_then_succeed_with_tracker_file(self):
        """
        Tests resumable download that fails completely in one process,
        then when restarted completes, using a tracker file
        """
        # Set up test harness that causes more failures than a single
        # ResumableDownloadHandler instance will handle, writing enough data
        # before the first failure that some of it survives that process run.
        harness = CallbackTestHarness(
            fail_after_n_bytes=LARGE_KEY_SIZE/2, num_times_to_fail=2)
        larger_src_key_as_string = os.urandom(LARGE_KEY_SIZE)
        larger_src_key = self._MakeKey(data=larger_src_key_as_string)
        tmpdir = self._MakeTempDir()
        tracker_file_name = self.make_tracker_file(tmpdir)
        dst_fp = self.make_dst_fp(tmpdir)
        res_download_handler = ResumableDownloadHandler(
            tracker_file_name=tracker_file_name, num_retries=0)
        try:
            larger_src_key.get_contents_to_file(
                dst_fp, cb=harness.call,
                res_download_handler=res_download_handler)
            self.fail('Did not get expected ResumableDownloadException')
        except ResumableDownloadException, e:
            self.assertEqual(e.disposition,
                             ResumableTransferDisposition.ABORT_CUR_PROCESS)
            # Ensure a tracker file survived.
            self.assertTrue(os.path.exists(tracker_file_name))
        # Try it one more time; this time should succeed.
        larger_src_key.get_contents_to_file(
            dst_fp, cb=harness.call,
            res_download_handler=res_download_handler)
        self.assertEqual(LARGE_KEY_SIZE,
                         get_cur_file_size(dst_fp))
        self.assertEqual(larger_src_key_as_string,
                         larger_src_key.get_contents_as_string())
        self.assertFalse(os.path.exists(tracker_file_name))
        # Ensure some of the file was downloaded both before and after failure.
        self.assertTrue(
            len(harness.transferred_seq_before_first_failure) > 1 and
            len(harness.transferred_seq_after_first_failure) > 1)

</source>
<source file="systems/boto-2.13.2/tests/integration/gs/test_resumable_uploads.py" startline="229" endline="268" pcid="4715">
    def test_multiple_in_process_failures_then_succeed_with_tracker_file(self):
        """
        Tests resumable upload that fails completely in one process,
        then when restarted completes, using a tracker file
        """
        # Set up test harness that causes more failures than a single
        # ResumableUploadHandler instance will handle, writing enough data
        # before the first failure that some of it survives that process run.
        harness = CallbackTestHarness(
            fail_after_n_bytes=LARGE_KEY_SIZE/2, num_times_to_fail=2)
        tracker_file_name = self.make_tracker_file()
        res_upload_handler = ResumableUploadHandler(
            tracker_file_name=tracker_file_name, num_retries=1)
        larger_src_file_as_string, larger_src_file = self.make_large_file()
        larger_src_file.seek(0)
        dst_key = self._MakeKey(set_contents=False)
        try:
            dst_key.set_contents_from_file(
                larger_src_file, cb=harness.call,
                res_upload_handler=res_upload_handler)
            self.fail('Did not get expected ResumableUploadException')
        except ResumableUploadException, e:
            self.assertEqual(e.disposition,
                             ResumableTransferDisposition.ABORT_CUR_PROCESS)
            # Ensure a tracker file survived.
            self.assertTrue(os.path.exists(tracker_file_name))
        # Try it one more time; this time should succeed.
        larger_src_file.seek(0)
        dst_key.set_contents_from_file(
            larger_src_file, cb=harness.call,
            res_upload_handler=res_upload_handler)
        self.assertEqual(LARGE_KEY_SIZE, dst_key.size)
        self.assertEqual(larger_src_file_as_string,
                         dst_key.get_contents_as_string())
        self.assertFalse(os.path.exists(tracker_file_name))
        # Ensure some of the file was uploaded both before and after failure.
        self.assertTrue(len(harness.transferred_seq_before_first_failure) > 1
                        and
                        len(harness.transferred_seq_after_first_failure) > 1)

</source>
</class>

<class classid="86" nclones="2" nlines="14" similarity="92">
<source file="systems/boto-2.13.2/tests/integration/gs/test_resumable_downloads.py" startline="336" endline="354" pcid="4680">
    def test_download_with_unwritable_tracker_file(self):
        """
        Tests resumable download with an unwritable tracker file
        """
        # Make dir where tracker_file lives temporarily unwritable.
        tmp_dir = self._MakeTempDir()
        tracker_file_name = os.path.join(tmp_dir, 'tracker')
        save_mod = os.stat(tmp_dir).st_mode
        try:
            os.chmod(tmp_dir, 0)
            res_download_handler = ResumableDownloadHandler(
                tracker_file_name=tracker_file_name)
        except ResumableDownloadException, e:
            self.assertEqual(e.disposition, ResumableTransferDisposition.ABORT)
            self.assertNotEqual(
                e.message.find('Couldn\'t write URI tracker file'), -1)
        finally:
            # Restore original protection of dir where tracker_file lives.
            os.chmod(tmp_dir, save_mod)
</source>
<source file="systems/boto-2.13.2/tests/integration/gs/test_resumable_uploads.py" startline="505" endline="523" pcid="4725">
    def test_upload_with_unwritable_tracker_file(self):
        """
        Tests resumable upload with an unwritable tracker file
        """
        # Make dir where tracker_file lives temporarily unwritable.
        tmp_dir = self._MakeTempDir()
        tracker_file_name = self.make_tracker_file(tmp_dir)
        save_mod = os.stat(tmp_dir).st_mode
        try:
            os.chmod(tmp_dir, 0)
            res_upload_handler = ResumableUploadHandler(
                tracker_file_name=tracker_file_name)
        except ResumableUploadException, e:
            self.assertEqual(e.disposition, ResumableTransferDisposition.ABORT)
            self.assertNotEqual(
                e.message.find('Couldn\'t write URI tracker file'), -1)
        finally:
            # Restore original protection of dir where tracker_file lives.
            os.chmod(tmp_dir, save_mod)
</source>
</class>

<class classid="87" nclones="2" nlines="20" similarity="90">
<source file="systems/boto-2.13.2/tests/integration/gs/test_basic.py" startline="299" endline="330" pcid="4689">
    def test_default_object_acls(self):
        """Test default object acls."""
        # create a new bucket
        bucket = self._MakeBucket()
        # get default acl and make sure it's project-private
        acl = bucket.get_def_acl()
        self.assertIsNotNone(re.search(PROJECT_PRIVATE_RE, acl.to_xml()))
        # set default acl to a canned acl and verify it gets set
        bucket.set_def_acl('public-read')
        acl = bucket.get_def_acl()
        # save public-read acl for later test
        public_read_acl = acl
        self.assertEqual(acl.to_xml(), ('<AccessControlList><Entries><Entry>'
          '<Scope type="AllUsers"></Scope><Permission>READ</Permission>'
          '</Entry></Entries></AccessControlList>'))
        # back to private acl
        bucket.set_def_acl('private')
        acl = bucket.get_def_acl()
        self.assertEqual(acl.to_xml(),
                         '<AccessControlList></AccessControlList>')
        # set default acl to an xml acl and verify it gets set
        bucket.set_def_acl(public_read_acl)
        acl = bucket.get_def_acl()
        self.assertEqual(acl.to_xml(), ('<AccessControlList><Entries><Entry>'
          '<Scope type="AllUsers"></Scope><Permission>READ</Permission>'
          '</Entry></Entries></AccessControlList>'))
        # back to private acl
        bucket.set_def_acl('private')
        acl = bucket.get_def_acl()
        self.assertEqual(acl.to_xml(),
                         '<AccessControlList></AccessControlList>')

</source>
<source file="systems/boto-2.13.2/tests/integration/gs/test_basic.py" startline="331" endline="364" pcid="4690">
    def test_default_object_acls_storage_uri(self):
        """Test default object acls using storage_uri."""
        # create a new bucket
        bucket = self._MakeBucket()
        bucket_name = bucket.name
        uri = storage_uri('gs://' + bucket_name)
        # get default acl and make sure it's project-private
        acl = uri.get_def_acl()
        self.assertIsNotNone(re.search(PROJECT_PRIVATE_RE, acl.to_xml()))
        # set default acl to a canned acl and verify it gets set
        uri.set_def_acl('public-read')
        acl = uri.get_def_acl()
        # save public-read acl for later test
        public_read_acl = acl
        self.assertEqual(acl.to_xml(), ('<AccessControlList><Entries><Entry>'
          '<Scope type="AllUsers"></Scope><Permission>READ</Permission>'
          '</Entry></Entries></AccessControlList>'))
        # back to private acl
        uri.set_def_acl('private')
        acl = uri.get_def_acl()
        self.assertEqual(acl.to_xml(),
                         '<AccessControlList></AccessControlList>')
        # set default acl to an xml acl and verify it gets set
        uri.set_def_acl(public_read_acl)
        acl = uri.get_def_acl()
        self.assertEqual(acl.to_xml(), ('<AccessControlList><Entries><Entry>'
          '<Scope type="AllUsers"></Scope><Permission>READ</Permission>'
          '</Entry></Entries></AccessControlList>'))
        # back to private acl
        uri.set_def_acl('private')
        acl = uri.get_def_acl()
        self.assertEqual(acl.to_xml(),
                         '<AccessControlList></AccessControlList>')

</source>
</class>

<class classid="88" nclones="2" nlines="11" similarity="90">
<source file="systems/boto-2.13.2/tests/integration/gs/test_basic.py" startline="397" endline="413" pcid="4693">
    def test_lifecycle_config_bucket(self):
        """Test setting and getting of lifecycle config on Bucket."""
        # create a new bucket
        bucket = self._MakeBucket()
        bucket_name = bucket.name
        # now call get_bucket to see if it's really there
        bucket = self._GetConnection().get_bucket(bucket_name)
        # get lifecycle config and make sure it's empty
        xml = bucket.get_lifecycle_config().to_xml()
        self.assertEqual(xml, LIFECYCLE_EMPTY)
        # set lifecycle config
        lifecycle_config = LifecycleConfig()
        lifecycle_config.add_rule('Delete', None, LIFECYCLE_CONDITIONS)
        bucket.configure_lifecycle(lifecycle_config)
        xml = bucket.get_lifecycle_config().to_xml()
        self.assertEqual(xml, LIFECYCLE_DOC)

</source>
<source file="systems/boto-2.13.2/tests/integration/gs/test_basic.py" startline="414" endline="428" pcid="4694">
    def test_lifecycle_config_storage_uri(self):
        """Test setting and getting of lifecycle config with storage_uri."""
        # create a new bucket
        bucket = self._MakeBucket()
        bucket_name = bucket.name
        uri = storage_uri('gs://' + bucket_name)
        # get lifecycle config and make sure it's empty
        xml = uri.get_lifecycle_config().to_xml()
        self.assertEqual(xml, LIFECYCLE_EMPTY)
        # set lifecycle config
        lifecycle_config = LifecycleConfig()
        lifecycle_config.add_rule('Delete', None, LIFECYCLE_CONDITIONS)
        uri.configure_lifecycle(lifecycle_config)
        xml = uri.get_lifecycle_config().to_xml()
        self.assertEqual(xml, LIFECYCLE_DOC)
</source>
</class>

<class classid="89" nclones="3" nlines="32" similarity="78">
<source file="systems/boto-2.13.2/tests/integration/gs/test_versioning.py" startline="116" endline="152" pcid="4698">
    def testVersionedBucketCannedAcl(self):
        b = self._MakeVersionedBucket()
        k = b.new_key("foo")
        s1 = "test1"
        k.set_contents_from_string(s1)

        k = b.get_key("foo")
        g1 = k.generation

        s2 = "test2"
        k.set_contents_from_string(s2)
        k = b.get_key("foo")
        g2 = k.generation

        acl1g1 = b.get_acl("foo", generation=g1)
        acl1g2 = b.get_acl("foo", generation=g2)
        owner1g1 = acl1g1.owner.id
        owner1g2 = acl1g2.owner.id
        self.assertEqual(owner1g1, owner1g2)
        entries1g1 = acl1g1.entries.entry_list
        entries1g2 = acl1g2.entries.entry_list
        self.assertEqual(len(entries1g1), len(entries1g2))

        b.set_acl("public-read", key_name="foo", generation=g1)

        acl2g1 = b.get_acl("foo", generation=g1)
        acl2g2 = b.get_acl("foo", generation=g2)
        entries2g1 = acl2g1.entries.entry_list
        entries2g2 = acl2g2.entries.entry_list
        self.assertEqual(len(entries2g2), len(entries1g2))
        public_read_entries1 = [e for e in entries2g1 if e.permission == "READ"
                                and e.scope.type == acl.ALL_USERS]
        public_read_entries2 = [e for e in entries2g2 if e.permission == "READ"
                                and e.scope.type == acl.ALL_USERS]
        self.assertEqual(len(public_read_entries1), 1)
        self.assertEqual(len(public_read_entries2), 0)

</source>
<source file="systems/boto-2.13.2/tests/integration/gs/test_versioning.py" startline="198" endline="234" pcid="4700">
    def testVersionedObjectCannedAcl(self):
        b = self._MakeVersionedBucket()
        k = b.new_key("foo")
        s1 = "test1"
        k.set_contents_from_string(s1)

        k = b.get_key("foo")
        g1 = k.generation

        s2 = "test2"
        k.set_contents_from_string(s2)
        k = b.get_key("foo")
        g2 = k.generation

        acl1g1 = b.get_acl("foo", generation=g1)
        acl1g2 = b.get_acl("foo", generation=g2)
        owner1g1 = acl1g1.owner.id
        owner1g2 = acl1g2.owner.id
        self.assertEqual(owner1g1, owner1g2)
        entries1g1 = acl1g1.entries.entry_list
        entries1g2 = acl1g2.entries.entry_list
        self.assertEqual(len(entries1g1), len(entries1g2))

        b.set_acl("public-read", key_name="foo", generation=g1)

        acl2g1 = b.get_acl("foo", generation=g1)
        acl2g2 = b.get_acl("foo", generation=g2)
        entries2g1 = acl2g1.entries.entry_list
        entries2g2 = acl2g2.entries.entry_list
        self.assertEqual(len(entries2g2), len(entries1g2))
        public_read_entries1 = [e for e in entries2g1 if e.permission == "READ"
                                and e.scope.type == acl.ALL_USERS]
        public_read_entries2 = [e for e in entries2g2 if e.permission == "READ"
                                and e.scope.type == acl.ALL_USERS]
        self.assertEqual(len(public_read_entries1), 1)
        self.assertEqual(len(public_read_entries2), 0)

</source>
<source file="systems/boto-2.13.2/tests/integration/gs/test_versioning.py" startline="153" endline="197" pcid="4699">
    def testVersionedBucketXmlAcl(self):
        b = self._MakeVersionedBucket()
        k = b.new_key("foo")
        s1 = "test1"
        k.set_contents_from_string(s1)

        k = b.get_key("foo")
        g1 = k.generation

        s2 = "test2"
        k.set_contents_from_string(s2)
        k = b.get_key("foo")
        g2 = k.generation

        acl1g1 = b.get_acl("foo", generation=g1)
        acl1g2 = b.get_acl("foo", generation=g2)
        owner1g1 = acl1g1.owner.id
        owner1g2 = acl1g2.owner.id
        self.assertEqual(owner1g1, owner1g2)
        entries1g1 = acl1g1.entries.entry_list
        entries1g2 = acl1g2.entries.entry_list
        self.assertEqual(len(entries1g1), len(entries1g2))

        acl_xml = (
            '<ACCESSControlList><EntrIes><Entry>'    +
            '<Scope type="AllUsers"></Scope><Permission>READ</Permission>' +
            '</Entry></EntrIes></ACCESSControlList>')
        aclo = acl.ACL()
        h = handler.XmlHandler(aclo, b)
        sax.parseString(acl_xml, h)

        b.set_acl(aclo, key_name="foo", generation=g1)

        acl2g1 = b.get_acl("foo", generation=g1)
        acl2g2 = b.get_acl("foo", generation=g2)
        entries2g1 = acl2g1.entries.entry_list
        entries2g2 = acl2g2.entries.entry_list
        self.assertEqual(len(entries2g2), len(entries1g2))
        public_read_entries1 = [e for e in entries2g1 if e.permission == "READ"
                                and e.scope.type == acl.ALL_USERS]
        public_read_entries2 = [e for e in entries2g2 if e.permission == "READ"
                                and e.scope.type == acl.ALL_USERS]
        self.assertEqual(len(public_read_entries1), 1)
        self.assertEqual(len(public_read_entries2), 0)

</source>
</class>

<class classid="90" nclones="2" nlines="18" similarity="78">
<source file="systems/boto-2.13.2/tests/integration/gs/test_resumable_uploads.py" startline="456" endline="477" pcid="4723">
    def test_upload_with_syntactically_invalid_tracker_uri(self):
        """
        Tests resumable upload with a syntactically invalid tracker URI
        """
        tmp_dir = self._MakeTempDir()
        syntactically_invalid_tracker_file_name = os.path.join(tmp_dir,
            'synt_invalid_uri_tracker')
        with open(syntactically_invalid_tracker_file_name, 'w') as f:
            f.write('ftp://example.com')
        res_upload_handler = ResumableUploadHandler(
            tracker_file_name=syntactically_invalid_tracker_file_name)
        small_src_file_as_string, small_src_file = self.make_small_file()
        # An error should be printed about the invalid URI, but then it
        # should run the update successfully.
        small_src_file.seek(0)
        dst_key = self._MakeKey(set_contents=False)
        dst_key.set_contents_from_file(
            small_src_file, res_upload_handler=res_upload_handler)
        self.assertEqual(SMALL_KEY_SIZE, dst_key.size)
        self.assertEqual(small_src_file_as_string,
                         dst_key.get_contents_as_string())

</source>
<source file="systems/boto-2.13.2/tests/integration/gs/test_resumable_uploads.py" startline="478" endline="504" pcid="4724">
    def test_upload_with_invalid_upload_id_in_tracker_file(self):
        """
        Tests resumable upload with invalid upload ID
        """
        invalid_upload_id = ('http://pub.storage.googleapis.com/?upload_id='
            'AyzB2Uo74W4EYxyi5dp_-r68jz8rtbvshsv4TX7srJVkJ57CxTY5Dw2')
        tmpdir = self._MakeTempDir()
        invalid_upload_id_tracker_file_name = os.path.join(tmpdir,
            'invalid_upload_id_tracker')
        with open(invalid_upload_id_tracker_file_name, 'w') as f:
            f.write(invalid_upload_id)

        res_upload_handler = ResumableUploadHandler(
            tracker_file_name=invalid_upload_id_tracker_file_name)
        small_src_file_as_string, small_src_file = self.make_small_file()
        # An error should occur, but then the tracker URI should be
        # regenerated and the the update should succeed.
        small_src_file.seek(0)
        dst_key = self._MakeKey(set_contents=False)
        dst_key.set_contents_from_file(
            small_src_file, res_upload_handler=res_upload_handler)
        self.assertEqual(SMALL_KEY_SIZE, dst_key.size)
        self.assertEqual(small_src_file_as_string,
                         dst_key.get_contents_as_string())
        self.assertNotEqual(invalid_upload_id,
                            res_upload_handler.get_tracker_uri())

</source>
</class>

<class classid="91" nclones="3" nlines="17" similarity="76">
<source file="systems/boto-2.13.2/tests/integration/gs/test_generation_conditionals.py" startline="43" endline="63" pcid="4746">
    def testConditionalSetContentsFromFile(self):
        b = self._MakeBucket()
        k = b.new_key("foo")
        s1 = "test1"
        fp = StringIO.StringIO(s1)
        with self.assertRaisesRegexp(GSResponseError, VERSION_MISMATCH):
            k.set_contents_from_file(fp, if_generation=999)

        fp = StringIO.StringIO(s1)
        k.set_contents_from_file(fp, if_generation=0)
        g1 = k.generation

        s2 = "test2"
        fp = StringIO.StringIO(s2)
        with self.assertRaisesRegexp(GSResponseError, VERSION_MISMATCH):
            k.set_contents_from_file(fp, if_generation=int(g1)+1)

        fp = StringIO.StringIO(s2)
        k.set_contents_from_file(fp, if_generation=g1)
        self.assertEqual(k.get_contents_as_string(), s2)

</source>
<source file="systems/boto-2.13.2/tests/integration/gs/test_generation_conditionals.py" startline="155" endline="176" pcid="4750">
    def testConditionalSetContentsFromStream(self):
        b = self._MakeBucket()
        k = b.new_key("foo")
        s1 = "test1"
        fp = StringIO.StringIO(s1)
        with self.assertRaisesRegexp(GSResponseError, VERSION_MISMATCH):
            k.set_contents_from_stream(fp, if_generation=999)

        fp = StringIO.StringIO(s1)
        k.set_contents_from_stream(fp, if_generation=0)
        g1 = k.generation

        k = b.get_key("foo")
        s2 = "test2"
        fp = StringIO.StringIO(s2)
        with self.assertRaisesRegexp(GSResponseError, VERSION_MISMATCH):
            k.set_contents_from_stream(fp, if_generation=int(g1)+1)

        fp = StringIO.StringIO(s2)
        k.set_contents_from_stream(fp, if_generation=g1)
        self.assertEqual(k.get_contents_as_string(), s2)

</source>
<source file="systems/boto-2.13.2/tests/integration/gs/test_generation_conditionals.py" startline="64" endline="80" pcid="4747">
    def testConditionalSetContentsFromString(self):
        b = self._MakeBucket()
        k = b.new_key("foo")
        s1 = "test1"
        with self.assertRaisesRegexp(GSResponseError, VERSION_MISMATCH):
            k.set_contents_from_string(s1, if_generation=999)

        k.set_contents_from_string(s1, if_generation=0)
        g1 = k.generation

        s2 = "test2"
        with self.assertRaisesRegexp(GSResponseError, VERSION_MISMATCH):
            k.set_contents_from_string(s2, if_generation=int(g1)+1)

        k.set_contents_from_string(s2, if_generation=g1)
        self.assertEqual(k.get_contents_as_string(), s2)

</source>
</class>

<class classid="92" nclones="2" nlines="32" similarity="93">
<source file="systems/boto-2.13.2/tests/integration/gs/test_generation_conditionals.py" startline="112" endline="154" pcid="4749">
    def testBucketConditionalSetAcl(self):
        b = self._MakeVersionedBucket()
        k = b.new_key("foo")
        s1 = "test1"
        k.set_contents_from_string(s1)

        g1 = k.generation
        mg1 = k.metageneration
        self.assertEqual(str(mg1), "1")
        b.set_acl("public-read", key_name="foo")

        k = b.get_key("foo")
        g2 = k.generation
        mg2 = k.metageneration

        self.assertEqual(g2, g1)
        self.assertGreater(mg2, mg1)

        with self.assertRaisesRegexp(ValueError, ("Received if_metageneration "
                                                  "argument with no "
                                                  "if_generation argument")):
            b.set_acl("bucket-owner-full-control", key_name="foo",
                      if_metageneration=123)

        with self.assertRaisesRegexp(GSResponseError, VERSION_MISMATCH):
            b.set_acl("bucket-owner-full-control", key_name="foo",
                      if_generation=int(g2) + 1)

        with self.assertRaisesRegexp(GSResponseError, VERSION_MISMATCH):
            b.set_acl("bucket-owner-full-control", key_name="foo",
                      if_generation=g2, if_metageneration=int(mg2) + 1)

        b.set_acl("bucket-owner-full-control", key_name="foo", if_generation=g2)

        k = b.get_key("foo")
        g3 = k.generation
        mg3 = k.metageneration
        self.assertEqual(g3, g2)
        self.assertGreater(mg3, mg2)

        b.set_acl("public-read", key_name="foo", if_generation=g3,
                  if_metageneration=mg3)

</source>
<source file="systems/boto-2.13.2/tests/integration/gs/test_generation_conditionals.py" startline="177" endline="220" pcid="4751">
    def testBucketConditionalSetCannedAcl(self):
        b = self._MakeVersionedBucket()
        k = b.new_key("foo")
        s1 = "test1"
        k.set_contents_from_string(s1)

        g1 = k.generation
        mg1 = k.metageneration
        self.assertEqual(str(mg1), "1")
        b.set_canned_acl("public-read", key_name="foo")

        k = b.get_key("foo")
        g2 = k.generation
        mg2 = k.metageneration

        self.assertEqual(g2, g1)
        self.assertGreater(mg2, mg1)

        with self.assertRaisesRegexp(ValueError, ("Received if_metageneration "
                                                  "argument with no "
                                                  "if_generation argument")):
            b.set_canned_acl("bucket-owner-full-control", key_name="foo",
                      if_metageneration=123)

        with self.assertRaisesRegexp(GSResponseError, VERSION_MISMATCH):
            b.set_canned_acl("bucket-owner-full-control", key_name="foo",
                      if_generation=int(g2) + 1)

        with self.assertRaisesRegexp(GSResponseError, VERSION_MISMATCH):
            b.set_canned_acl("bucket-owner-full-control", key_name="foo",
                      if_generation=g2, if_metageneration=int(mg2) + 1)

        b.set_canned_acl("bucket-owner-full-control", key_name="foo",
                         if_generation=g2)

        k = b.get_key("foo")
        g3 = k.generation
        mg3 = k.metageneration
        self.assertEqual(g3, g2)
        self.assertGreater(mg3, mg2)

        b.set_canned_acl("public-read", key_name="foo", if_generation=g3,
                  if_metageneration=mg3)

</source>
</class>

<class classid="93" nclones="2" nlines="36" similarity="78">
<source file="systems/boto-2.13.2/tests/integration/gs/test_generation_conditionals.py" startline="221" endline="271" pcid="4752">
    def testBucketConditionalSetXmlAcl(self):
        b = self._MakeVersionedBucket()
        k = b.new_key("foo")
        s1 = "test1"
        k.set_contents_from_string(s1)

        g1 = k.generation
        mg1 = k.metageneration
        self.assertEqual(str(mg1), "1")

        acl_xml = (
            '<ACCESSControlList><EntrIes><Entry>'    +
            '<Scope type="AllUsers"></Scope><Permission>READ</Permission>' +
            '</Entry></EntrIes></ACCESSControlList>')
        acl = ACL()
        h = handler.XmlHandler(acl, b)
        sax.parseString(acl_xml, h)
        acl = acl.to_xml()

        b.set_xml_acl(acl, key_name="foo")

        k = b.get_key("foo")
        g2 = k.generation
        mg2 = k.metageneration

        self.assertEqual(g2, g1)
        self.assertGreater(mg2, mg1)

        with self.assertRaisesRegexp(ValueError, ("Received if_metageneration "
                                                  "argument with no "
                                                  "if_generation argument")):
            b.set_xml_acl(acl, key_name="foo", if_metageneration=123)

        with self.assertRaisesRegexp(GSResponseError, VERSION_MISMATCH):
            b.set_xml_acl(acl, key_name="foo", if_generation=int(g2) + 1)

        with self.assertRaisesRegexp(GSResponseError, VERSION_MISMATCH):
            b.set_xml_acl(acl, key_name="foo", if_generation=g2,
                          if_metageneration=int(mg2) + 1)

        b.set_xml_acl(acl, key_name="foo", if_generation=g2)

        k = b.get_key("foo")
        g3 = k.generation
        mg3 = k.metageneration
        self.assertEqual(g3, g2)
        self.assertGreater(mg3, mg2)

        b.set_xml_acl(acl, key_name="foo", if_generation=g3,
                      if_metageneration=mg3)

</source>
<source file="systems/boto-2.13.2/tests/integration/gs/test_generation_conditionals.py" startline="352" endline="399" pcid="4755">
    def testObjectConditionalSetXmlAcl(self):
        b = self._MakeVersionedBucket()
        k = b.new_key("foo")
        s1 = "test1"
        k.set_contents_from_string(s1)

        g1 = k.generation
        mg1 = k.metageneration
        self.assertEqual(str(mg1), "1")

        acl_xml = (
            '<ACCESSControlList><EntrIes><Entry>'    +
            '<Scope type="AllUsers"></Scope><Permission>READ</Permission>' +
            '</Entry></EntrIes></ACCESSControlList>')
        acl = ACL()
        h = handler.XmlHandler(acl, b)
        sax.parseString(acl_xml, h)
        acl = acl.to_xml()

        k.set_xml_acl(acl)

        k = b.get_key("foo")
        g2 = k.generation
        mg2 = k.metageneration

        self.assertEqual(g2, g1)
        self.assertGreater(mg2, mg1)

        with self.assertRaisesRegexp(ValueError, ("Received if_metageneration "
                                                  "argument with no "
                                                  "if_generation argument")):
            k.set_xml_acl(acl, if_metageneration=123)

        with self.assertRaisesRegexp(GSResponseError, VERSION_MISMATCH):
            k.set_xml_acl(acl, if_generation=int(g2) + 1)

        with self.assertRaisesRegexp(GSResponseError, VERSION_MISMATCH):
            k.set_xml_acl(acl, if_generation=g2, if_metageneration=int(mg2) + 1)

        k.set_xml_acl(acl, if_generation=g2)

        k = b.get_key("foo")
        g3 = k.generation
        mg3 = k.metageneration
        self.assertEqual(g3, g2)
        self.assertGreater(mg3, mg2)

        k.set_xml_acl(acl, if_generation=g3, if_metageneration=mg3)
</source>
</class>

<class classid="94" nclones="2" nlines="28" similarity="86">
<source file="systems/boto-2.13.2/tests/integration/gs/test_generation_conditionals.py" startline="272" endline="310" pcid="4753">
    def testObjectConditionalSetAcl(self):
        b = self._MakeVersionedBucket()
        k = b.new_key("foo")
        k.set_contents_from_string("test1")

        g1 = k.generation
        mg1 = k.metageneration
        self.assertEqual(str(mg1), "1")
        k.set_acl("public-read")

        k = b.get_key("foo")
        g2 = k.generation
        mg2 = k.metageneration

        self.assertEqual(g2, g1)
        self.assertGreater(mg2, mg1)

        with self.assertRaisesRegexp(ValueError, ("Received if_metageneration "
                                                  "argument with no "
                                                  "if_generation argument")):
            k.set_acl("bucket-owner-full-control", if_metageneration=123)

        with self.assertRaisesRegexp(GSResponseError, VERSION_MISMATCH):
            k.set_acl("bucket-owner-full-control", if_generation=int(g2) + 1)

        with self.assertRaisesRegexp(GSResponseError, VERSION_MISMATCH):
            k.set_acl("bucket-owner-full-control", if_generation=g2,
                      if_metageneration=int(mg2) + 1)

        k.set_acl("bucket-owner-full-control", if_generation=g2)

        k = b.get_key("foo")
        g3 = k.generation
        mg3 = k.metageneration
        self.assertEqual(g3, g2)
        self.assertGreater(mg3, mg2)

        k.set_acl("public-read", if_generation=g3, if_metageneration=mg3)

</source>
<source file="systems/boto-2.13.2/tests/integration/gs/test_generation_conditionals.py" startline="311" endline="351" pcid="4754">
    def testObjectConditionalSetCannedAcl(self):
        b = self._MakeVersionedBucket()
        k = b.new_key("foo")
        k.set_contents_from_string("test1")

        g1 = k.generation
        mg1 = k.metageneration
        self.assertEqual(str(mg1), "1")
        k.set_canned_acl("public-read")

        k = b.get_key("foo")
        g2 = k.generation
        mg2 = k.metageneration

        self.assertEqual(g2, g1)
        self.assertGreater(mg2, mg1)

        with self.assertRaisesRegexp(ValueError, ("Received if_metageneration "
                                                  "argument with no "
                                                  "if_generation argument")):
            k.set_canned_acl("bucket-owner-full-control",
                             if_metageneration=123)

        with self.assertRaisesRegexp(GSResponseError, VERSION_MISMATCH):
            k.set_canned_acl("bucket-owner-full-control",
                             if_generation=int(g2) + 1)

        with self.assertRaisesRegexp(GSResponseError, VERSION_MISMATCH):
            k.set_canned_acl("bucket-owner-full-control", if_generation=g2,
                      if_metageneration=int(mg2) + 1)

        k.set_canned_acl("bucket-owner-full-control", if_generation=g2)

        k = b.get_key("foo")
        g3 = k.generation
        mg3 = k.metageneration
        self.assertEqual(g3, g2)
        self.assertGreater(mg3, mg2)

        k.set_canned_acl("public-read", if_generation=g3, if_metageneration=mg3)

</source>
</class>

<class classid="95" nclones="2" nlines="11" similarity="90">
<source file="systems/boto-2.13.2/tests/integration/route53/test_zone.py" startline="42" endline="53" pcid="4759">
    def test_a(self):
        self.zone.add_a('example.com', '102.11.23.1', 80)
        record = self.zone.get_a('example.com')
        self.assertEquals(record.name, u'example.com.')
        self.assertEquals(record.resource_records, [u'102.11.23.1'])
        self.assertEquals(record.ttl, u'80')
        self.zone.update_a('example.com', '186.143.32.2', '800')
        record = self.zone.get_a('example.com')
        self.assertEquals(record.name, u'example.com.')
        self.assertEquals(record.resource_records, [u'186.143.32.2'])
        self.assertEquals(record.ttl, u'800')

</source>
<source file="systems/boto-2.13.2/tests/integration/route53/test_zone.py" startline="54" endline="65" pcid="4760">
    def test_cname(self):
        self.zone.add_cname('www.example.com', 'webserver.example.com', 200)
        record = self.zone.get_cname('www.example.com')
        self.assertEquals(record.name, u'www.example.com.')
        self.assertEquals(record.resource_records, [u'webserver.example.com.'])
        self.assertEquals(record.ttl, u'200')
        self.zone.update_cname('www.example.com', 'web.example.com', 45)
        record = self.zone.get_cname('www.example.com')
        self.assertEquals(record.name, u'www.example.com.')
        self.assertEquals(record.resource_records, [u'web.example.com.'])
        self.assertEquals(record.ttl, u'45')

</source>
</class>

<class classid="96" nclones="2" nlines="17" similarity="94">
<source file="systems/boto-2.13.2/tests/integration/swf/test_layer1_workflow_execution.py" startline="113" endline="143" pcid="4796">
    def test_workflow_execution(self):
        # Start a workflow execution whose activity task will succeed.
        workflow_id = 'wfid-%.2f' % (time.time(),)
        r = self.conn.start_workflow_execution(self._domain,
                                               workflow_id,
                                               self._workflow_type_name,
                                               self._workflow_type_version,
                                               execution_start_to_close_timeout='20',
                                               input='[600, 15]')
        # Need the run_id to lookup the execution history later.
        run_id = r['runId']

        # Move the workflow execution forward by having the
        # decider schedule an activity task.
        self.run_decider()

        # Run the worker to handle the scheduled activity task.
        self.run_worker()

        # Complete the workflow execution by having the
        # decider close it down.
        self.run_decider()

        # Check that the result was stored in the execution history.
        r = self.conn.get_workflow_execution_history(self._domain,
                                                     run_id, workflow_id,
                                                     reverse_order=True)['events'][0]
        result = r['workflowExecutionCompletedEventAttributes']['result']
        assert json.loads(result) == 615


</source>
<source file="systems/boto-2.13.2/tests/integration/swf/test_layer1_workflow_execution.py" startline="144" endline="173" pcid="4797">
    def test_failed_workflow_execution(self):
        # Start a workflow execution whose activity task will fail.
        workflow_id = 'wfid-%.2f' % (time.time(),)
        r = self.conn.start_workflow_execution(self._domain,
                                               workflow_id,
                                               self._workflow_type_name,
                                               self._workflow_type_version,
                                               execution_start_to_close_timeout='20',
                                               input='[600, "s"]')
        # Need the run_id to lookup the execution history later.
        run_id = r['runId']

        # Move the workflow execution forward by having the
        # decider schedule an activity task.
        self.run_decider()

        # Run the worker to handle the scheduled activity task.
        self.run_worker()

        # Complete the workflow execution by having the
        # decider close it down.
        self.run_decider()

        # Check that the failure was stored in the execution history.
        r = self.conn.get_workflow_execution_history(self._domain,
                                                     run_id, workflow_id,
                                                     reverse_order=True)['events'][0]
        reason = r['workflowExecutionFailedEventAttributes']['reason']
        assert reason == 'an exception was raised'

</source>
</class>

<class classid="97" nclones="3" nlines="12" similarity="76">
<source file="systems/boto-2.13.2/tests/integration/swf/test_layer1.py" startline="147" endline="161" pcid="4800">
    def test_list_domains(self):
        # Find the domain.
        r = self.conn.list_domains('REGISTERED')
        found = None
        for info in r['domainInfos']:
            if info['name'] == self._domain:
                found = info
                break
        self.assertNotEqual(found, None, 'list_domains; test domain not found')
        # Validate some properties.
        self.assertEqual(found['description'], self._domain_description,
                         'list_domains; description does not match')
        self.assertEqual(found['status'], 'REGISTERED',
                         'list_domains; status does not match')

</source>
<source file="systems/boto-2.13.2/tests/integration/swf/test_layer1.py" startline="178" endline="193" pcid="4802">
    def test_list_activity_types(self):
        # Find the activity type.
        r = self.conn.list_activity_types(self._domain, 'REGISTERED')
        found = None
        for info in r['typeInfos']:
            if info['activityType']['name'] == self._activity_type_name:
                found = info
                break
        self.assertNotEqual(found, None, 'list_activity_types; test type not found')
        # Validate some properties.
        self.assertEqual(found['description'], self._activity_type_description,
                         'list_activity_types; description does not match')
        self.assertEqual(found['status'], 'REGISTERED',
                         'list_activity_types; status does not match')


</source>
<source file="systems/boto-2.13.2/tests/integration/swf/test_layer1.py" startline="162" endline="177" pcid="4801">
    def test_list_workflow_types(self):
        # Find the workflow type.
        r = self.conn.list_workflow_types(self._domain, 'REGISTERED')
        found = None
        for info in r['typeInfos']:
            if ( info['workflowType']['name'] == self._workflow_type_name and
                 info['workflowType']['version'] == self._workflow_type_version ):
                found = info
                break
        self.assertNotEqual(found, None, 'list_workflow_types; test type not found')
        # Validate some properties.
        self.assertEqual(found['description'], self._workflow_type_description,
                         'list_workflow_types; description does not match')
        self.assertEqual(found['status'], 'REGISTERED',
                         'list_workflow_types; status does not match')

</source>
</class>

<class classid="98" nclones="2" nlines="11" similarity="83">
<source file="systems/boto-2.13.2/tests/unit/provider/test_provider.py" startline="74" endline="85" pcid="4811">
    def test_config_values_are_used(self):
        self.config = {
            'Credentials': {
                'aws_access_key_id': 'cfg_access_key',
                'aws_secret_access_key': 'cfg_secret_key',
            }
        }
        p = provider.Provider('aws')
        self.assertEqual(p.access_key, 'cfg_access_key')
        self.assertEqual(p.secret_key, 'cfg_secret_key')
        self.assertIsNone(p.security_token)

</source>
<source file="systems/boto-2.13.2/tests/unit/provider/test_provider.py" startline="113" endline="126" pcid="4813">
    def test_env_vars_beat_config_values(self):
        self.environ['AWS_ACCESS_KEY_ID'] = 'env_access_key'
        self.environ['AWS_SECRET_ACCESS_KEY'] = 'env_secret_key'
        self.config = {
            'Credentials': {
                'aws_access_key_id': 'cfg_access_key',
                'aws_secret_access_key': 'cfg_secret_key',
            }
        }
        p = provider.Provider('aws')
        self.assertEqual(p.access_key, 'env_access_key')
        self.assertEqual(p.secret_key, 'env_secret_key')
        self.assertIsNone(p.security_token)

</source>
</class>

<class classid="99" nclones="3" nlines="13" similarity="78">
<source file="systems/boto-2.13.2/tests/unit/ec2/autoscale/test_group.py" startline="276" endline="293" pcid="4840">
    def test_scaling_policy_with_min_adjustment_step(self):
        self.set_http_response(status_code=200)

        policy = ScalingPolicy(
            name='foo', as_name='bar',
            adjustment_type='PercentChangeInCapacity', scaling_adjustment=50,
            min_adjustment_step=30)
        self.service_connection.create_scaling_policy(policy)

        self.assert_request_parameters({
            'Action': 'PutScalingPolicy',
            'PolicyName': 'foo',
            'AutoScalingGroupName': 'bar',
            'AdjustmentType': 'PercentChangeInCapacity',
            'ScalingAdjustment': 50,
            'MinAdjustmentStep': 30
        }, ignore_params_values=['Version'])

</source>
<source file="systems/boto-2.13.2/tests/unit/ec2/autoscale/test_group.py" startline="294" endline="310" pcid="4841">
    def test_scaling_policy_with_wrong_adjustment_type(self):
        self.set_http_response(status_code=200)

        policy = ScalingPolicy(
            name='foo', as_name='bar',
            adjustment_type='ChangeInCapacity', scaling_adjustment=50,
            min_adjustment_step=30)
        self.service_connection.create_scaling_policy(policy)

        self.assert_request_parameters({
            'Action': 'PutScalingPolicy',
            'PolicyName': 'foo',
            'AutoScalingGroupName': 'bar',
            'AdjustmentType': 'ChangeInCapacity',
            'ScalingAdjustment': 50
        }, ignore_params_values=['Version'])

</source>
<source file="systems/boto-2.13.2/tests/unit/ec2/autoscale/test_group.py" startline="311" endline="327" pcid="4842">
    def test_scaling_policy_without_min_adjustment_step(self):
        self.set_http_response(status_code=200)

        policy = ScalingPolicy(
            name='foo', as_name='bar',
            adjustment_type='PercentChangeInCapacity', scaling_adjustment=50)
        self.service_connection.create_scaling_policy(policy)

        self.assert_request_parameters({
            'Action': 'PutScalingPolicy',
            'PolicyName': 'foo',
            'AutoScalingGroupName': 'bar',
            'AdjustmentType': 'PercentChangeInCapacity',
            'ScalingAdjustment': 50
        }, ignore_params_values=['Version'])


</source>
</class>

<class classid="100" nclones="9" nlines="12" similarity="71">
<source file="systems/boto-2.13.2/tests/unit/ec2/test_connection.py" startline="472" endline="486" pcid="4856">
    def test_copy_snapshot(self):
        self.set_http_response(status_code=200)
        snapshot_id = self.ec2.copy_snapshot('us-west-2', 'snap-id',
                                             'description')
        self.assertEqual(snapshot_id, 'snap-copied-id')

        self.assert_request_parameters({
            'Action': 'CopySnapshot',
            'Description': 'description',
            'SourceRegion': 'us-west-2',
            'SourceSnapshotId': 'snap-id'},
             ignore_params_values=['AWSAccessKeyId', 'SignatureMethod',
                                   'SignatureVersion', 'Timestamp',
                                   'Version'])

</source>
<source file="systems/boto-2.13.2/tests/unit/ec2/test_connection.py" startline="801" endline="813" pcid="4871">
    def test_modify_source_dest_check_str(self):
        self.set_http_response(status_code=200)
        self.ec2.modify_network_interface_attribute('id', 'sourceDestCheck',
                                                    'true')

        self.assert_request_parameters({
            'Action': 'ModifyNetworkInterfaceAttribute',
            'NetworkInterfaceId': 'id',
            'SourceDestCheck.Value': 'true'},
             ignore_params_values=['AWSAccessKeyId', 'SignatureMethod',
                                   'SignatureVersion', 'Timestamp',
                                   'Version'])

</source>
<source file="systems/boto-2.13.2/tests/unit/ec2/test_connection.py" startline="512" endline="528" pcid="4859">
    def test_copy_image_without_name(self):
        self.set_http_response(status_code=200)
        copied_ami = self.ec2.copy_image('us-west-2', 'ami-id',
                                         description='description',
                                         client_token='client-token')
        self.assertEqual(copied_ami.image_id, 'ami-copied-id')

        self.assert_request_parameters({
            'Action': 'CopyImage',
            'Description': 'description',
            'SourceRegion': 'us-west-2',
            'SourceImageId': 'ami-id',
            'ClientToken': 'client-token'},
             ignore_params_values=['AWSAccessKeyId', 'SignatureMethod',
                                   'SignatureVersion', 'Timestamp',
                                   'Version'])

</source>
<source file="systems/boto-2.13.2/tests/unit/ec2/test_connection.py" startline="862" endline="875" pcid="4876">
    def test_modify_group_set_list(self):
        self.set_http_response(status_code=200)
        self.ec2.modify_network_interface_attribute('id', 'groupSet',
                                                    ['sg-1', 'sg-2'])

        self.assert_request_parameters({
            'Action': 'ModifyNetworkInterfaceAttribute',
            'NetworkInterfaceId': 'id',
            'SecurityGroupId.1': 'sg-1',
            'SecurityGroupId.2': 'sg-2'},
             ignore_params_values=['AWSAccessKeyId', 'SignatureMethod',
                                   'SignatureVersion', 'Timestamp',
                                   'Version'])

</source>
<source file="systems/boto-2.13.2/tests/unit/ec2/test_connection.py" startline="837" endline="852" pcid="4874">
    def test_modify_delete_on_termination_bool(self):
        self.set_http_response(status_code=200)
        self.ec2.modify_network_interface_attribute('id',
                                                    'deleteOnTermination',
                                                    'false',
                                                    attachment_id='bar')

        self.assert_request_parameters({
            'Action': 'ModifyNetworkInterfaceAttribute',
            'NetworkInterfaceId': 'id',
            'Attachment.AttachmentId': 'bar',
            'Attachment.DeleteOnTermination': 'false'},
             ignore_params_values=['AWSAccessKeyId', 'SignatureMethod',
                                   'SignatureVersion', 'Timestamp',
                                   'Version'])

</source>
<source file="systems/boto-2.13.2/tests/unit/ec2/test_connection.py" startline="822" endline="836" pcid="4873">
    def test_modify_delete_on_termination_str(self):
        self.set_http_response(status_code=200)
        self.ec2.modify_network_interface_attribute('id',
                                                    'deleteOnTermination',
                                                    True, attachment_id='bar')

        self.assert_request_parameters({
            'Action': 'ModifyNetworkInterfaceAttribute',
            'NetworkInterfaceId': 'id',
            'Attachment.AttachmentId': 'bar',
            'Attachment.DeleteOnTermination': 'true'},
             ignore_params_values=['AWSAccessKeyId', 'SignatureMethod',
                                   'SignatureVersion', 'Timestamp',
                                   'Version'])

</source>
<source file="systems/boto-2.13.2/tests/unit/ec2/test_connection.py" startline="496" endline="511" pcid="4858">
    def test_copy_image(self):
        self.set_http_response(status_code=200)
        copied_ami = self.ec2.copy_image('us-west-2', 'ami-id',
                                     'name', 'description', 'client-token')
        self.assertEqual(copied_ami.image_id, 'ami-copied-id')

        self.assert_request_parameters({
            'Action': 'CopyImage',
            'Description': 'description',
            'Name': 'name',
            'SourceRegion': 'us-west-2',
            'SourceImageId': 'ami-id',
            'ClientToken': 'client-token'},
             ignore_params_values=['AWSAccessKeyId', 'SignatureMethod',
                                   'SignatureVersion', 'Timestamp',
                                   'Version'])
</source>
<source file="systems/boto-2.13.2/tests/unit/ec2/test_connection.py" startline="776" endline="787" pcid="4869">
    def test_modify_description(self):
        self.set_http_response(status_code=200)
        self.ec2.modify_network_interface_attribute('id', 'description', 'foo')

        self.assert_request_parameters({
            'Action': 'ModifyNetworkInterfaceAttribute',
            'NetworkInterfaceId': 'id',
            'Description.Value': 'foo'},
             ignore_params_values=['AWSAccessKeyId', 'SignatureMethod',
                                   'SignatureVersion', 'Timestamp',
                                   'Version'])

</source>
<source file="systems/boto-2.13.2/tests/unit/ec2/test_connection.py" startline="788" endline="800" pcid="4870">
    def test_modify_source_dest_check_bool(self):
        self.set_http_response(status_code=200)
        self.ec2.modify_network_interface_attribute('id', 'sourceDestCheck',
                                                    True)

        self.assert_request_parameters({
            'Action': 'ModifyNetworkInterfaceAttribute',
            'NetworkInterfaceId': 'id',
            'SourceDestCheck.Value': 'true'},
             ignore_params_values=['AWSAccessKeyId', 'SignatureMethod',
                                   'SignatureVersion', 'Timestamp',
                                   'Version'])

</source>
</class>

<class classid="101" nclones="2" nlines="12" similarity="83">
<source file="systems/boto-2.13.2/tests/unit/ec2/test_connection.py" startline="957" endline="984" pcid="4884">
    def test_trim_defaults(self):
        """
        Test trimming snapshots with the default arguments, which should
        keep all monthly backups forever. The result of this test should
        be that nothing is deleted.
        """
        # Setup mocks
        orig = {
            'get_all_snapshots': self.ec2.get_all_snapshots,
            'delete_snapshot': self.ec2.delete_snapshot
        }

        snaps = self._get_snapshots()

        self.ec2.get_all_snapshots = MagicMock(return_value=snaps)
        self.ec2.delete_snapshot = MagicMock()

        # Call the tested method
        self.ec2.trim_snapshots()

        # Assertions
        self.assertEqual(True, self.ec2.get_all_snapshots.called)
        self.assertEqual(False, self.ec2.delete_snapshot.called)

        # Restore
        self.ec2.get_all_snapshots = orig['get_all_snapshots']
        self.ec2.delete_snapshot = orig['delete_snapshot']

</source>
<source file="systems/boto-2.13.2/tests/unit/ec2/test_connection.py" startline="985" endline="1013" pcid="4885">
    def test_trim_months(self):
        """
        Test trimming monthly snapshots and ensure that older months
        get deleted properly. The result of this test should be that
        the two oldest snapshots get deleted.
        """
        # Setup mocks
        orig = {
            'get_all_snapshots': self.ec2.get_all_snapshots,
            'delete_snapshot': self.ec2.delete_snapshot
        }

        snaps = self._get_snapshots()

        self.ec2.get_all_snapshots = MagicMock(return_value=snaps)
        self.ec2.delete_snapshot = MagicMock()

        # Call the tested method
        self.ec2.trim_snapshots(monthly_backups=1)

        # Assertions
        self.assertEqual(True, self.ec2.get_all_snapshots.called)
        self.assertEqual(2, self.ec2.delete_snapshot.call_count)

        # Restore
        self.ec2.get_all_snapshots = orig['get_all_snapshots']
        self.ec2.delete_snapshot = orig['delete_snapshot']


</source>
</class>

<class classid="102" nclones="3" nlines="18" similarity="72">
<source file="systems/boto-2.13.2/tests/unit/test_connection.py" startline="138" endline="158" pcid="4991">
    def test_query_connection_noproxy(self):
        HTTPretty.register_uri(HTTPretty.POST,
                               'https://%s/' % self.region.endpoint,
                               json.dumps({'test': 'secure'}),
                               content_type='application/json')

        os.environ['no_proxy'] = self.region.endpoint

        conn = self.region.connect(aws_access_key_id='access_key',
                                   aws_secret_access_key='secret',
                                   proxy="NON_EXISTENT_HOSTNAME",
                                   proxy_port="3128")

        resp = conn.make_request('myCmd',
                                 {'par1': 'foo', 'par2': 'baz'},
                                 "/",
                                 "POST")
        del os.environ['no_proxy']
        args = urlparse.parse_qs(HTTPretty.last_request.body)
        self.assertEqual(args['AWSAccessKeyId'], ['access_key'])

</source>
<source file="systems/boto-2.13.2/tests/unit/test_connection.py" startline="159" endline="180" pcid="4992">
    def test_query_connection_noproxy_nosecure(self):
        HTTPretty.register_uri(HTTPretty.POST,
                               'https://%s/' % self.region.endpoint,
                               json.dumps({'test': 'insecure'}),
                               content_type='application/json')

        os.environ['no_proxy'] = self.region.endpoint

        conn = self.region.connect(aws_access_key_id='access_key',
                                   aws_secret_access_key='secret',
                                   proxy="NON_EXISTENT_HOSTNAME",
                                   proxy_port="3128",
                                   is_secure = False)

        resp = conn.make_request('myCmd',
                                 {'par1': 'foo', 'par2': 'baz'},
                                 "/",
                                 "POST")
        del os.environ['no_proxy']
        args = urlparse.parse_qs(HTTPretty.last_request.body)
        self.assertEqual(args['AWSAccessKeyId'], ['access_key'])

</source>
<source file="systems/boto-2.13.2/tests/unit/test_connection.py" startline="181" endline="202" pcid="4993">
    def test_single_command(self):
        HTTPretty.register_uri(HTTPretty.POST,
                               'https://%s/' % self.region.endpoint,
                               json.dumps({'test': 'secure'}),
                               content_type='application/json')

        conn = self.region.connect(aws_access_key_id='access_key',
                                   aws_secret_access_key='secret')
        resp = conn.make_request('myCmd',
                                 {'par1': 'foo', 'par2': 'baz'},
                                 "/",
                                 "POST")

        args = urlparse.parse_qs(HTTPretty.last_request.body)
        self.assertEqual(args['AWSAccessKeyId'], ['access_key'])
        self.assertEqual(args['SignatureMethod'], ['HmacSHA256'])
        self.assertEqual(args['Version'], [conn.APIVersion])
        self.assertEqual(args['par1'], ['foo'])
        self.assertEqual(args['par2'], ['baz'])

        self.assertEqual(resp.read(), '{"test": "secure"}')

</source>
</class>

<class classid="103" nclones="2" nlines="14" similarity="92">
<source file="systems/boto-2.13.2/tests/unit/test_connection.py" startline="238" endline="253" pcid="4995">
    def test_non_secure(self):
        HTTPretty.register_uri(HTTPretty.POST,
                               'http://%s/' % self.region.endpoint,
                               json.dumps({'test': 'normal'}),
                               content_type='application/json')

        conn = self.region.connect(aws_access_key_id='access_key',
                                   aws_secret_access_key='secret',
                                   is_secure=False)
        resp = conn.make_request('myCmd1',
                                 {'par1': 'foo', 'par2': 'baz'},
                                 "/",
                                 "POST")

        self.assertEqual(resp.read(), '{"test": "normal"}')

</source>
<source file="systems/boto-2.13.2/tests/unit/test_connection.py" startline="254" endline="270" pcid="4996">
    def test_alternate_port(self):
        HTTPretty.register_uri(HTTPretty.POST,
                               'http://%s:8080/' % self.region.endpoint,
                               json.dumps({'test': 'alternate'}),
                               content_type='application/json')

        conn = self.region.connect(aws_access_key_id='access_key',
                                   aws_secret_access_key='secret',
                                   port=8080,
                                   is_secure=False)
        resp = conn.make_request('myCmd1',
                                 {'par1': 'foo', 'par2': 'baz'},
                                 "/",
                                 "POST")

        self.assertEqual(resp.read(), '{"test": "alternate"}')

</source>
</class>

<class classid="104" nclones="3" nlines="11" similarity="75">
<source file="systems/boto-2.13.2/tests/unit/test_connection.py" startline="289" endline="302" pcid="4998">
    def test_get_status(self):
        HTTPretty.register_uri(HTTPretty.GET,
                               'https://%s/status' % self.region.endpoint,
                               '<status>ok</status>',
                               content_type='text/xml')

        conn = self.region.connect(aws_access_key_id='access_key',
                                   aws_secret_access_key='secret')
        resp = conn.get_status('getStatus',
                               {'par1': 'foo', 'par2': 'baz'},
                               'status')

        self.assertEqual(resp, "ok")

</source>
<source file="systems/boto-2.13.2/tests/unit/test_connection.py" startline="303" endline="315" pcid="4999">
    def test_get_status_blank_error(self):
        HTTPretty.register_uri(HTTPretty.GET,
                               'https://%s/status' % self.region.endpoint,
                               '',
                               content_type='text/xml')

        conn = self.region.connect(aws_access_key_id='access_key',
                aws_secret_access_key='secret')
        with self.assertRaises(BotoServerError):
            resp = conn.get_status('getStatus',
                                   {'par1': 'foo', 'par2': 'baz'},
                                   'status')

</source>
<source file="systems/boto-2.13.2/tests/unit/test_connection.py" startline="316" endline="329" pcid="5000">
    def test_get_status_error(self):
        HTTPretty.register_uri(HTTPretty.GET,
                               'https://%s/status' % self.region.endpoint,
                               '<status>error</status>',
                               content_type='text/xml',
                               status=400)

        conn = self.region.connect(aws_access_key_id='access_key',
                                   aws_secret_access_key='secret')
        with self.assertRaises(BotoServerError):
            resp = conn.get_status('getStatus',
                                   {'par1': 'foo', 'par2': 'baz'},
                                   'status')

</source>
</class>

<class classid="105" nclones="3" nlines="14" similarity="76">
<source file="systems/boto-2.13.2/tests/unit/cloudformation/test_stack.py" startline="165" endline="181" pcid="5003">
    def test_resource_time_with_millis(self):
        rs = boto.resultset.ResultSet([
          ('member', boto.cloudformation.stack.StackResource)
        ])
        h = boto.handler.XmlHandler(rs, None)
        xml.sax.parseString(DESCRIBE_STACK_RESOURCE_XML, h)
        timestamp_1 = rs[0].timestamp
        self.assertEqual(
          timestamp_1,
          datetime.datetime(2010, 7, 27, 22, 27, 28)
        )
        timestamp_2 = rs[1].timestamp
        self.assertEqual(
          timestamp_2,
          datetime.datetime(2010, 7, 27, 22, 28, 28, 123456)
        )

</source>
<source file="systems/boto-2.13.2/tests/unit/cloudformation/test_stack.py" startline="182" endline="203" pcid="5004">
    def test_list_stacks_time_with_millis(self):
        rs = boto.resultset.ResultSet([
            ('member', boto.cloudformation.stack.StackSummary)
        ])
        h = boto.handler.XmlHandler(rs, None)
        xml.sax.parseString(LIST_STACKS_XML, h)
        timestamp_1 = rs[0].creation_time
        self.assertEqual(
            timestamp_1,
            datetime.datetime(2011, 5, 23, 15, 47, 44)
        )
        timestamp_2 = rs[1].creation_time
        self.assertEqual(
            timestamp_2,
            datetime.datetime(2011, 3, 5, 19, 57, 58, 161616)
        )
        timestamp_3 = rs[1].deletion_time
        self.assertEqual(
            timestamp_3,
            datetime.datetime(2011, 3, 10, 16, 20, 51, 575757)
        )

</source>
<source file="systems/boto-2.13.2/tests/unit/cloudformation/test_stack.py" startline="204" endline="220" pcid="5005">
    def test_list_stacks_time_with_millis(self):
        rs = boto.resultset.ResultSet([
            ('member', boto.cloudformation.stack.StackResourceSummary)
        ])
        h = boto.handler.XmlHandler(rs, None)
        xml.sax.parseString(LIST_STACK_RESOURCES_XML, h)
        timestamp_1 = rs[0].last_updated_time
        self.assertEqual(
            timestamp_1,
            datetime.datetime(2011, 6, 21, 20, 15, 58)
        )
        timestamp_2 = rs[1].last_updated_time
        self.assertEqual(
            timestamp_2,
            datetime.datetime(2011, 6, 21, 20, 25, 57, 875643)
        )

</source>
</class>

<class classid="106" nclones="2" nlines="27" similarity="89">
<source file="systems/boto-2.13.2/tests/unit/cloudformation/test_connection.py" startline="59" endline="95" pcid="5012">
    def test_create_stack_has_correct_request_params(self):
        self.set_http_response(status_code=200)
        api_response = self.service_connection.create_stack(
            'stack_name', template_url='http://url',
            template_body=SAMPLE_TEMPLATE,
            parameters=[('KeyName', 'myKeyName')],
            tags={'TagKey': 'TagValue'},
            notification_arns=['arn:notify1', 'arn:notify2'],
            disable_rollback=True,
            timeout_in_minutes=20, capabilities=['CAPABILITY_IAM']
        )
        self.assertEqual(api_response, self.stack_id)
        # These are the parameters that are actually sent to the CloudFormation
        # service.
        self.assert_request_parameters({
            'Action': 'CreateStack',
            'Capabilities.member.1': 'CAPABILITY_IAM',
            'ContentType': 'JSON',
            'DisableRollback': 'true',
            'NotificationARNs.member.1': 'arn:notify1',
            'NotificationARNs.member.2': 'arn:notify2',
            'Parameters.member.1.ParameterKey': 'KeyName',
            'Parameters.member.1.ParameterValue': 'myKeyName',
            'Tags.member.1.Key': 'TagKey',
            'Tags.member.1.Value': 'TagValue',
            'StackName': 'stack_name',
            'Version': '2010-05-15',
            'TimeoutInMinutes': 20,
            'TemplateBody': SAMPLE_TEMPLATE,
            'TemplateURL': 'http://url',
        })

    # The test_create_stack_has_correct_request_params verified all of the
    # params needed when making a create_stack service call.  The rest of the
    # tests for create_stack only verify specific parts of the params sent
    # to CloudFormation.

</source>
<source file="systems/boto-2.13.2/tests/unit/cloudformation/test_connection.py" startline="125" endline="152" pcid="5016">
    def test_update_stack_all_args(self):
        self.set_http_response(status_code=200)
        api_response = self.service_connection.update_stack(
            'stack_name', template_url='http://url',
            template_body=SAMPLE_TEMPLATE,
            parameters=[('KeyName', 'myKeyName')],
            tags={'TagKey': 'TagValue'},
            notification_arns=['arn:notify1', 'arn:notify2'],
            disable_rollback=True,
            timeout_in_minutes=20
        )
        self.assert_request_parameters({
            'Action': 'UpdateStack',
            'ContentType': 'JSON',
            'DisableRollback': 'true',
            'NotificationARNs.member.1': 'arn:notify1',
            'NotificationARNs.member.2': 'arn:notify2',
            'Parameters.member.1.ParameterKey': 'KeyName',
            'Parameters.member.1.ParameterValue': 'myKeyName',
            'Tags.member.1.Key': 'TagKey',
            'Tags.member.1.Value': 'TagValue',
            'StackName': 'stack_name',
            'Version': '2010-05-15',
            'TimeoutInMinutes': 20,
            'TemplateBody': SAMPLE_TEMPLATE,
            'TemplateURL': 'http://url',
        })

</source>
</class>

<class classid="107" nclones="5" nlines="11" similarity="75">
<source file="systems/boto-2.13.2/tests/unit/cloudformation/test_connection.py" startline="96" endline="108" pcid="5013">
    def test_create_stack_with_minimum_args(self):
        # This will fail in practice, but the API docs only require stack_name.
        self.set_http_response(status_code=200)
        api_response = self.service_connection.create_stack('stack_name')
        self.assertEqual(api_response, self.stack_id)
        self.assert_request_parameters({
            'Action': 'CreateStack',
            'ContentType': 'JSON',
            'DisableRollback': 'false',
            'StackName': 'stack_name',
            'Version': '2010-05-15',
        })

</source>
<source file="systems/boto-2.13.2/tests/unit/cloudformation/test_connection.py" startline="201" endline="213" pcid="5023">
    def test_describe_stack_resource(self):
        self.set_http_response(status_code=200)
        api_response = self.service_connection.describe_stack_resource(
            'stack_name', 'resource_id')
        self.assertEqual(api_response, 'fake server response')
        self.assert_request_parameters({
            'Action': 'DescribeStackResource',
            'ContentType': 'JSON',
            'LogicalResourceId': 'resource_id',
            'StackName': 'stack_name',
            'Version': '2010-05-15',
        })

</source>
<source file="systems/boto-2.13.2/tests/unit/cloudformation/test_connection.py" startline="153" endline="164" pcid="5017">
    def test_update_stack_with_minimum_args(self):
        self.set_http_response(status_code=200)
        api_response = self.service_connection.update_stack('stack_name')
        self.assertEqual(api_response, self.stack_id)
        self.assert_request_parameters({
            'Action': 'UpdateStack',
            'ContentType': 'JSON',
            'DisableRollback': 'false',
            'StackName': 'stack_name',
            'Version': '2010-05-15',
        })

</source>
<source file="systems/boto-2.13.2/tests/unit/cloudformation/test_connection.py" startline="180" endline="190" pcid="5020">
    def test_delete_stack(self):
        self.set_http_response(status_code=200)
        api_response = self.service_connection.delete_stack('stack_name')
        self.assertEqual(api_response, json.loads(self.default_body()))
        self.assert_request_parameters({
            'Action': 'DeleteStack',
            'ContentType': 'JSON',
            'StackName': 'stack_name',
            'Version': '2010-05-15',
        })

</source>
<source file="systems/boto-2.13.2/tests/unit/cloudformation/test_connection.py" startline="225" endline="236" pcid="5026">
    def test_get_template(self):
        self.set_http_response(status_code=200)
        api_response = self.service_connection.get_template('stack_name')
        self.assertEqual(api_response, 'fake server response')
        self.assert_request_parameters({
            'Action': 'GetTemplate',
            'ContentType': 'JSON',
            'StackName': 'stack_name',
            'Version': '2010-05-15',
        })


</source>
</class>

<class classid="108" nclones="2" nlines="29" similarity="82">
<source file="systems/boto-2.13.2/tests/unit/cloudformation/test_connection.py" startline="273" endline="305" pcid="5029">
    def test_describe_stack_events(self):
        self.set_http_response(status_code=200)
        first, second = self.service_connection.describe_stack_events('stack_name', next_token='next_token')
        self.assertEqual(first.event_id, 'Event-1-Id')
        self.assertEqual(first.logical_resource_id, 'MyStack')
        self.assertEqual(first.physical_resource_id, 'MyStack_One')
        self.assertEqual(first.resource_properties, None)
        self.assertEqual(first.resource_status, 'CREATE_IN_PROGRESS')
        self.assertEqual(first.resource_status_reason, 'User initiated')
        self.assertEqual(first.resource_type, 'AWS::CloudFormation::Stack')
        self.assertEqual(first.stack_id, 'arn:aws:cfn:us-east-1:1:stack')
        self.assertEqual(first.stack_name, 'MyStack')
        self.assertIsNotNone(first.timestamp)

        self.assertEqual(second.event_id, 'Event-2-Id')
        self.assertEqual(second.logical_resource_id, 'MySG1')
        self.assertEqual(second.physical_resource_id, 'MyStack_SG1')
        self.assertEqual(second.resource_properties, None)
        self.assertEqual(second.resource_status, 'CREATE_COMPLETE')
        self.assertEqual(second.resource_status_reason, None)
        self.assertEqual(second.resource_type, 'AWS::SecurityGroup')
        self.assertEqual(second.stack_id, 'arn:aws:cfn:us-east-1:1:stack')
        self.assertEqual(second.stack_name, 'MyStack')
        self.assertIsNotNone(second.timestamp)

        self.assert_request_parameters({
            'Action': 'DescribeStackEvents',
            'NextToken': 'next_token',
            'StackName': 'stack_name',
            'Version': '2010-05-15',
        })


</source>
<source file="systems/boto-2.13.2/tests/unit/cloudformation/test_connection.py" startline="333" endline="365" pcid="5031">
    def test_describe_stack_resources(self):
        self.set_http_response(status_code=200)
        first, second = self.service_connection.describe_stack_resources(
            'stack_name', 'logical_resource_id', 'physical_resource_id')
        self.assertEqual(first.description, None)
        self.assertEqual(first.logical_resource_id, 'MyDBInstance')
        self.assertEqual(first.physical_resource_id, 'MyStack_DB1')
        self.assertEqual(first.resource_status, 'CREATE_COMPLETE')
        self.assertEqual(first.resource_status_reason, None)
        self.assertEqual(first.resource_type, 'AWS::DBInstance')
        self.assertEqual(first.stack_id, 'arn:aws:cfn:us-east-1:1:stack')
        self.assertEqual(first.stack_name, 'MyStack')
        self.assertIsNotNone(first.timestamp)

        self.assertEqual(second.description, None)
        self.assertEqual(second.logical_resource_id, 'MyAutoScalingGroup')
        self.assertEqual(second.physical_resource_id, 'MyStack_ASG1')
        self.assertEqual(second.resource_status, 'CREATE_IN_PROGRESS')
        self.assertEqual(second.resource_status_reason, None)
        self.assertEqual(second.resource_type, 'AWS::AutoScalingGroup')
        self.assertEqual(second.stack_id, 'arn:aws:cfn:us-east-1:1:stack')
        self.assertEqual(second.stack_name, 'MyStack')
        self.assertIsNotNone(second.timestamp)

        self.assert_request_parameters({
            'Action': 'DescribeStackResources',
            'LogicalResourceId': 'logical_resource_id',
            'PhysicalResourceId': 'physical_resource_id',
            'StackName': 'stack_name',
            'Version': '2010-05-15',
        })


</source>
</class>

<class classid="109" nclones="2" nlines="18" similarity="78">
<source file="systems/boto-2.13.2/tests/unit/sns/test_connection.py" startline="48" endline="72" pcid="5044">
    def test_sqs_with_existing_policy(self):
        self.set_http_response(status_code=200)

        queue = Mock()
        queue.get_attributes.return_value = QUEUE_POLICY
        queue.arn = 'arn:aws:sqs:us-east-1:idnum:queuename'

        self.service_connection.subscribe_sqs_queue('topic_arn', queue)
        self.assert_request_parameters({
               'Action': 'Subscribe',
               'ContentType': 'JSON',
               'Endpoint': 'arn:aws:sqs:us-east-1:idnum:queuename',
               'Protocol': 'sqs',
               'TopicArn': 'topic_arn',
               'Version': '2010-03-31',
        }, ignore_params_values=[])

        # Verify that the queue policy was properly updated.
        actual_policy = json.loads(queue.set_attribute.call_args[0][1])
        self.assertEqual(actual_policy['Version'], '2008-10-17')
        # A new statement should be appended to the end of the statement list.
        self.assertEqual(len(actual_policy['Statement']), 2)
        self.assertEqual(actual_policy['Statement'][1]['Action'],
                         'SQS:SendMessage')

</source>
<source file="systems/boto-2.13.2/tests/unit/sns/test_connection.py" startline="73" endline="92" pcid="5045">
    def test_sqs_with_no_previous_policy(self):
        self.set_http_response(status_code=200)

        queue = Mock()
        queue.get_attributes.return_value = {}
        queue.arn = 'arn:aws:sqs:us-east-1:idnum:queuename'

        self.service_connection.subscribe_sqs_queue('topic_arn', queue)
        self.assert_request_parameters({
               'Action': 'Subscribe',
               'ContentType': 'JSON',
               'Endpoint': 'arn:aws:sqs:us-east-1:idnum:queuename',
               'Protocol': 'sqs',
               'TopicArn': 'topic_arn',
               'Version': '2010-03-31',
        }, ignore_params_values=[])
        actual_policy = json.loads(queue.set_attribute.call_args[0][1])
        # Only a single statement should be part of the policy.
        self.assertEqual(len(actual_policy['Statement']), 1)

</source>
</class>

<class classid="110" nclones="2" nlines="11" similarity="100">
<source file="systems/boto-2.13.2/tests/unit/sns/test_connection.py" startline="104" endline="116" pcid="5047">
    def test_publish_with_kwargs(self):
        self.set_http_response(status_code=200)

        self.service_connection.publish(topic='topic',
                                        message='message',
                                        subject='subject')
        self.assert_request_parameters({
            'Action': 'Publish',
            'TopicArn': 'topic',
            'Subject': 'subject',
            'Message': 'message',
        }, ignore_params_values=['Version', 'ContentType'])

</source>
<source file="systems/boto-2.13.2/tests/unit/sns/test_connection.py" startline="117" endline="129" pcid="5048">
    def test_publish_with_target_arn(self):
        self.set_http_response(status_code=200)

        self.service_connection.publish(target_arn='target_arn',
                                        message='message',
                                        subject='subject')
        self.assert_request_parameters({
            'Action': 'Publish',
            'TargetArn': 'target_arn',
            'Subject': 'subject',
            'Message': 'message',
        }, ignore_params_values=['Version', 'ContentType'])

</source>
</class>

<class classid="111" nclones="4" nlines="15" similarity="70">
<source file="systems/boto-2.13.2/tests/unit/sns/test_connection.py" startline="130" endline="150" pcid="5049">
    def test_create_platform_application(self):
        self.set_http_response(status_code=200)

        self.service_connection.create_platform_application(
            name='MyApp',
            platform='APNS',
            attributes={
                'PlatformPrincipal': 'a ssl certificate',
                'PlatformCredential': 'a private key'
            }
        )
        self.assert_request_parameters({
            'Action': 'CreatePlatformApplication',
            'Name': 'MyApp',
            'Platform': 'APNS',
            'Attributes.entry.1.key': 'PlatformCredential',
            'Attributes.entry.1.value': 'a private key',
            'Attributes.entry.2.key': 'PlatformPrincipal',
            'Attributes.entry.2.value': 'a ssl certificate',
        }, ignore_params_values=['Version', 'ContentType'])

</source>
<source file="systems/boto-2.13.2/tests/unit/sns/test_connection.py" startline="167" endline="183" pcid="5051">
    def test_create_platform_endpoint(self):
        self.set_http_response(status_code=200)

        self.service_connection.create_platform_endpoint(
            platform_application_arn='arn:myapp',
            token='abcde12345',
            custom_user_data='john',
            attributes={'Enabled': False})
        self.assert_request_parameters({
            'Action': 'CreatePlatformEndpoint',
            'PlatformApplicationArn': 'arn:myapp',
            'Token': 'abcde12345',
            'CustomUserData': 'john',
            'Attributes.entry.1.key': 'Enabled',
            'Attributes.entry.1.value': False,
        }, ignore_params_values=['Version', 'ContentType'])

</source>
<source file="systems/boto-2.13.2/tests/unit/sns/test_connection.py" startline="151" endline="166" pcid="5050">
    def test_set_platform_application_attributes(self):
        self.set_http_response(status_code=200)

        self.service_connection.set_platform_application_attributes(
            platform_application_arn='arn:myapp',
            attributes={'PlatformPrincipal': 'a ssl certificate',
                        'PlatformCredential': 'a private key'})
        self.assert_request_parameters({
            'Action': 'SetPlatformApplicationAttributes',
            'PlatformApplicationArn': 'arn:myapp',
            'Attributes.entry.1.key': 'PlatformCredential',
            'Attributes.entry.1.value': 'a private key',
            'Attributes.entry.2.key': 'PlatformPrincipal',
            'Attributes.entry.2.value': 'a ssl certificate',
        }, ignore_params_values=['Version', 'ContentType'])

</source>
<source file="systems/boto-2.13.2/tests/unit/sns/test_connection.py" startline="184" endline="199" pcid="5052">
    def test_set_endpoint_attributes(self):
        self.set_http_response(status_code=200)

        self.service_connection.set_endpoint_attributes(
            endpoint_arn='arn:myendpoint',
            attributes={'CustomUserData': 'john',
                        'Enabled': False})
        self.assert_request_parameters({
            'Action': 'SetEndpointAttributes',
            'EndpointArn': 'arn:myendpoint',
            'Attributes.entry.1.key': 'CustomUserData',
            'Attributes.entry.1.value': 'john',
            'Attributes.entry.2.key': 'Enabled',
            'Attributes.entry.2.value': False,
        }, ignore_params_values=['Version', 'ContentType'])

</source>
</class>

<class classid="112" nclones="5" nlines="17" similarity="77">
<source file="systems/boto-2.13.2/tests/unit/cloudfront/test_signed_urls.py" startline="189" endline="210" pcid="5065">
    def test_create_canned_policy(self):
        """
        Test that a canned policy is generated correctly.
        """
        url = "http://1234567.cloudfront.com/test_resource.mp3?dog=true"
        expires = 999999
        policy = self.dist._canned_policy(url, expires)
        policy = json.loads(policy)

        self.assertEqual(1, len(policy.keys()))
        statements = policy["Statement"]
        self.assertEqual(1, len(statements))
        statement = statements[0]
        resource = statement["Resource"]
        self.assertEqual(url, resource)
        condition = statement["Condition"]
        self.assertEqual(1, len(condition.keys()))
        date_less_than = condition["DateLessThan"]
        self.assertEqual(1, len(date_less_than.keys()))
        aws_epoch_time = date_less_than["AWS:EpochTime"]
        self.assertEqual(expires, aws_epoch_time)
        
</source>
<source file="systems/boto-2.13.2/tests/unit/cloudfront/test_signed_urls.py" startline="282" endline="305" pcid="5069">
    def test_custom_policy_ip_range(self):
        """
        Test that a custom policy can be created with an IP address and
        an arbitrary URL.
        """
        url = "http://1234567.cloudfront.com/*"
        ip_range = "192.168.0.0/24"
        policy = self.dist._custom_policy(url, ip_address=ip_range)
        policy = json.loads(policy)

        self.assertEqual(1, len(policy.keys()))
        statements = policy["Statement"]
        self.assertEqual(1, len(statements))
        statement = statements[0]
        resource = statement["Resource"]
        self.assertEqual(url, resource)
        condition = statement["Condition"]
        self.assertEqual(2, len(condition.keys()))
        self.assertTrue("DateLessThan" in condition)
        ip_address = condition["IpAddress"]
        self.assertEqual(1, len(ip_address.keys()))
        source_ip = ip_address["AWS:SourceIp"]
        self.assertEqual(ip_range, source_ip)

</source>
<source file="systems/boto-2.13.2/tests/unit/cloudfront/test_signed_urls.py" startline="234" endline="257" pcid="5067">
    def test_custom_policy_valid_after(self):
        """
        Test that a custom policy can be created with a valid-after time and
        an arbitrary URL.
        """
        url = "http://1234567.cloudfront.com/*"
        valid_after = 999999
        policy = self.dist._custom_policy(url, valid_after=valid_after)
        policy = json.loads(policy)

        self.assertEqual(1, len(policy.keys()))
        statements = policy["Statement"]
        self.assertEqual(1, len(statements))
        statement = statements[0]
        resource = statement["Resource"]
        self.assertEqual(url, resource)
        condition = statement["Condition"]
        self.assertEqual(2, len(condition.keys()))
        date_less_than = condition["DateLessThan"]
        date_greater_than = condition["DateGreaterThan"]
        self.assertEqual(1, len(date_greater_than.keys()))
        aws_epoch_time = date_greater_than["AWS:EpochTime"]
        self.assertEqual(valid_after, aws_epoch_time)

</source>
<source file="systems/boto-2.13.2/tests/unit/cloudfront/test_signed_urls.py" startline="258" endline="281" pcid="5068">
    def test_custom_policy_ip_address(self):
        """
        Test that a custom policy can be created with an IP address and
        an arbitrary URL.
        """
        url = "http://1234567.cloudfront.com/*"
        ip_range = "192.168.0.1"
        policy = self.dist._custom_policy(url, ip_address=ip_range)
        policy = json.loads(policy)

        self.assertEqual(1, len(policy.keys()))
        statements = policy["Statement"]
        self.assertEqual(1, len(statements))
        statement = statements[0]
        resource = statement["Resource"]
        self.assertEqual(url, resource)
        condition = statement["Condition"]
        self.assertEqual(2, len(condition.keys()))
        ip_address = condition["IpAddress"]
        self.assertTrue("DateLessThan" in condition)
        self.assertEqual(1, len(ip_address.keys()))
        source_ip = ip_address["AWS:SourceIp"]
        self.assertEqual("%s/32" % ip_range, source_ip)

</source>
<source file="systems/boto-2.13.2/tests/unit/cloudfront/test_signed_urls.py" startline="211" endline="233" pcid="5066">
    def test_custom_policy_expires_and_policy_url(self):
        """
        Test that a custom policy can be created with an expire time and an
        arbitrary URL.
        """
        url = "http://1234567.cloudfront.com/*"
        expires = 999999
        policy = self.dist._custom_policy(url, expires=expires)
        policy = json.loads(policy)

        self.assertEqual(1, len(policy.keys()))
        statements = policy["Statement"]
        self.assertEqual(1, len(statements))
        statement = statements[0]
        resource = statement["Resource"]
        self.assertEqual(url, resource)
        condition = statement["Condition"]
        self.assertEqual(1, len(condition.keys()))
        date_less_than = condition["DateLessThan"]
        self.assertEqual(1, len(date_less_than.keys()))
        aws_epoch_time = date_less_than["AWS:EpochTime"]
        self.assertEqual(expires, aws_epoch_time)

</source>
</class>

<class classid="113" nclones="3" nlines="11" similarity="90">
<source file="systems/boto-2.13.2/tests/unit/dynamodb2/test_table.py" startline="19" endline="33" pcid="5089">
    def test_hash_key(self):
        hash_key = HashKey('hello')
        self.assertEqual(hash_key.name, 'hello')
        self.assertEqual(hash_key.data_type, STRING)
        self.assertEqual(hash_key.attr_type, 'HASH')

        self.assertEqual(hash_key.definition(), {
            'AttributeName': 'hello',
            'AttributeType': 'S'
        })
        self.assertEqual(hash_key.schema(), {
            'AttributeName': 'hello',
            'KeyType': 'HASH'
        })

</source>
<source file="systems/boto-2.13.2/tests/unit/dynamodb2/test_table.py" startline="49" endline="64" pcid="5091">
    def test_alternate_type(self):
        alt_key = HashKey('alt', data_type=NUMBER)
        self.assertEqual(alt_key.name, 'alt')
        self.assertEqual(alt_key.data_type, NUMBER)
        self.assertEqual(alt_key.attr_type, 'HASH')

        self.assertEqual(alt_key.definition(), {
            'AttributeName': 'alt',
            'AttributeType': 'N'
        })
        self.assertEqual(alt_key.schema(), {
            'AttributeName': 'alt',
            'KeyType': 'HASH'
        })


</source>
<source file="systems/boto-2.13.2/tests/unit/dynamodb2/test_table.py" startline="34" endline="48" pcid="5090">
    def test_range_key(self):
        range_key = RangeKey('hello')
        self.assertEqual(range_key.name, 'hello')
        self.assertEqual(range_key.data_type, STRING)
        self.assertEqual(range_key.attr_type, 'RANGE')

        self.assertEqual(range_key.definition(), {
            'AttributeName': 'hello',
            'AttributeType': 'S'
        })
        self.assertEqual(range_key.schema(), {
            'AttributeName': 'hello',
            'KeyType': 'RANGE'
        })

</source>
</class>

<class classid="114" nclones="3" nlines="24" similarity="72">
<source file="systems/boto-2.13.2/tests/unit/dynamodb2/test_table.py" startline="66" endline="98" pcid="5092">
    def test_all_index(self):
        all_index = AllIndex('AllKeys', parts=[
            HashKey('username'),
            RangeKey('date_joined')
        ])
        self.assertEqual(all_index.name, 'AllKeys')
        self.assertEqual([part.attr_type for part in all_index.parts], [
            'HASH',
            'RANGE'
        ])
        self.assertEqual(all_index.projection_type, 'ALL')

        self.assertEqual(all_index.definition(), [
            {'AttributeName': 'username', 'AttributeType': 'S'},
            {'AttributeName': 'date_joined', 'AttributeType': 'S'}
        ])
        self.assertEqual(all_index.schema(), {
            'IndexName': 'AllKeys',
            'KeySchema': [
                {
                    'AttributeName': 'username',
                    'KeyType': 'HASH'
                },
                {
                    'AttributeName': 'date_joined',
                    'KeyType': 'RANGE'
                }
            ],
            'Projection': {
                'ProjectionType': 'ALL'
            }
        })

</source>
<source file="systems/boto-2.13.2/tests/unit/dynamodb2/test_table.py" startline="99" endline="131" pcid="5093">
    def test_keys_only_index(self):
        keys_only = KeysOnlyIndex('KeysOnly', parts=[
            HashKey('username'),
            RangeKey('date_joined')
        ])
        self.assertEqual(keys_only.name, 'KeysOnly')
        self.assertEqual([part.attr_type for part in keys_only.parts], [
            'HASH',
            'RANGE'
        ])
        self.assertEqual(keys_only.projection_type, 'KEYS_ONLY')

        self.assertEqual(keys_only.definition(), [
            {'AttributeName': 'username', 'AttributeType': 'S'},
            {'AttributeName': 'date_joined', 'AttributeType': 'S'}
        ])
        self.assertEqual(keys_only.schema(), {
            'IndexName': 'KeysOnly',
            'KeySchema': [
                {
                    'AttributeName': 'username',
                    'KeyType': 'HASH'
                },
                {
                    'AttributeName': 'date_joined',
                    'KeyType': 'RANGE'
                }
            ],
            'Projection': {
                'ProjectionType': 'KEYS_ONLY'
            }
        })

</source>
<source file="systems/boto-2.13.2/tests/unit/dynamodb2/test_table.py" startline="132" endline="172" pcid="5094">
    def test_include_index(self):
        include_index = IncludeIndex('IncludeKeys', parts=[
            HashKey('username'),
            RangeKey('date_joined')
        ], includes=[
            'gender',
            'friend_count'
        ])
        self.assertEqual(include_index.name, 'IncludeKeys')
        self.assertEqual([part.attr_type for part in include_index.parts], [
            'HASH',
            'RANGE'
        ])
        self.assertEqual(include_index.projection_type, 'INCLUDE')

        self.assertEqual(include_index.definition(), [
            {'AttributeName': 'username', 'AttributeType': 'S'},
            {'AttributeName': 'date_joined', 'AttributeType': 'S'}
        ])
        self.assertEqual(include_index.schema(), {
            'IndexName': 'IncludeKeys',
            'KeySchema': [
                {
                    'AttributeName': 'username',
                    'KeyType': 'HASH'
                },
                {
                    'AttributeName': 'date_joined',
                    'KeyType': 'RANGE'
                }
            ],
            'Projection': {
                'ProjectionType': 'INCLUDE',
                'NonKeyAttributes': [
                    'gender',
                    'friend_count',
                ]
            }
        })


</source>
</class>

<class classid="115" nclones="2" nlines="24" similarity="95">
<source file="systems/boto-2.13.2/tests/unit/dynamodb2/test_table.py" startline="450" endline="478" pcid="5114">
    def test_prepare_partial(self):
        self.johndoe.mark_clean()
        # Change some data.
        self.johndoe['first_name'] = 'Johann'
        # Add some data.
        self.johndoe['last_name'] = 'Doe'
        # Delete some data.
        del self.johndoe['date_joined']

        final_data, fields = self.johndoe.prepare_partial()
        self.assertEqual(final_data, {
            'date_joined': {
                'Action': 'DELETE',
            },
            'first_name': {
                'Action': 'PUT',
                'Value': {'S': 'Johann'},
            },
            'last_name': {
                'Action': 'PUT',
                'Value': {'S': 'Doe'},
            },
        })
        self.assertEqual(fields, set([
            'first_name',
            'last_name',
            'date_joined'
        ]))

</source>
<source file="systems/boto-2.13.2/tests/unit/dynamodb2/test_table.py" startline="479" endline="509" pcid="5115">
    def test_prepare_partial(self):
        self.johndoe.mark_clean()
        # Change some data.
        self.johndoe['first_name'] = 'Johann'
        # Add some data.
        self.johndoe['last_name'] = 'Doe'
        # Delete some data.
        del self.johndoe['date_joined']
        # Put an empty set on the ``Item``.
        self.johndoe['friends'] = set()

        final_data, fields = self.johndoe.prepare_partial()
        self.assertEqual(final_data, {
            'date_joined': {
                'Action': 'DELETE',
            },
            'first_name': {
                'Action': 'PUT',
                'Value': {'S': 'Johann'},
            },
            'last_name': {
                'Action': 'PUT',
                'Value': {'S': 'Doe'},
            },
        })
        self.assertEqual(fields, set([
            'first_name',
            'last_name',
            'date_joined'
        ]))

</source>
</class>

<class classid="116" nclones="3" nlines="39" similarity="70">
<source file="systems/boto-2.13.2/tests/unit/dynamodb2/test_table.py" startline="1171" endline="1228" pcid="5146">
                ],
                'IndexName': 'FriendCountIndex',
                'Projection': {
                    'ProjectionType': 'KEYS_ONLY'
                }
            }
        ])

    def test_describe(self):
        expected = {
            "Table": {
                "AttributeDefinitions": [
                    {
                        "AttributeName": "username",
                        "AttributeType": "S"
                    }
                ],
                "ItemCount": 5,
                "KeySchema": [
                    {
                        "AttributeName": "username",
                        "KeyType": "HASH"
                    }
                ],
                "LocalSecondaryIndexes": [
                    {
                        "IndexName": "UsernameIndex",
                        "KeySchema": [
                            {
                                "AttributeName": "username",
                                "KeyType": "HASH"
                            }
                        ],
                        "Projection": {
                            "ProjectionType": "KEYS_ONLY"
                        }
                    }
                ],
                "ProvisionedThroughput": {
                    "ReadCapacityUnits": 20,
                    "WriteCapacityUnits": 6
                },
                "TableName": "Thread",
                "TableStatus": "ACTIVE"
            }
        }

        with mock.patch.object(
                self.users.connection,
                'describe_table',
                return_value=expected) as mock_describe:
            self.assertEqual(self.users.throughput['read'], 5)
            self.assertEqual(self.users.throughput['write'], 5)
            self.assertEqual(self.users.schema, None)
            self.assertEqual(self.users.indexes, None)

            self.users.describe()

</source>
<source file="systems/boto-2.13.2/tests/unit/dynamodb2/test_table.py" startline="1350" endline="1409" pcid="5154">
            'username': {
                'S': 'johndoe'
            },
            'date_joined': {
                'N': '23456'
            }
        })

    def test_get_key_fields_no_schema_populated(self):
        expected = {
            "Table": {
                "AttributeDefinitions": [
                    {
                        "AttributeName": "username",
                        "AttributeType": "S"
                    },
                    {
                        "AttributeName": "date_joined",
                        "AttributeType": "N"
                    }
                ],
                "ItemCount": 5,
                "KeySchema": [
                    {
                        "AttributeName": "username",
                        "KeyType": "HASH"
                    },
                    {
                        "AttributeName": "date_joined",
                        "KeyType": "RANGE"
                    }
                ],
                "LocalSecondaryIndexes": [
                    {
                        "IndexName": "UsernameIndex",
                        "KeySchema": [
                            {
                                "AttributeName": "username",
                                "KeyType": "HASH"
                            }
                        ],
                        "Projection": {
                            "ProjectionType": "KEYS_ONLY"
                        }
                    }
                ],
                "ProvisionedThroughput": {
                    "ReadCapacityUnits": 20,
                    "WriteCapacityUnits": 6
                },
                "TableName": "Thread",
                "TableStatus": "ACTIVE"
            }
        }

        with mock.patch.object(
                self.users.connection,
                'describe_table',
                return_value=expected) as mock_describe:
            self.assertEqual(self.users.schema, None)
</source>
<source file="systems/boto-2.13.2/tests/unit/dynamodb2/test_table.py" startline="2075" endline="2119" pcid="5166">
            # New results should have been found.
            self.assertEqual(len(results._results), 1)
            self.assertEqual(res_3['username'], 'zoeydoe')

            self.assertRaises(StopIteration, results.next)

        self.assertEqual(mock_scan_2.call_count, 1)

    def test_count(self):
        expected = {
            "Table": {
                "AttributeDefinitions": [
                    {
                        "AttributeName": "username",
                        "AttributeType": "S"
                    }
                ],
                "ItemCount": 5,
                "KeySchema": [
                    {
                        "AttributeName": "username",
                        "KeyType": "HASH"
                    }
                ],
                "LocalSecondaryIndexes": [
                    {
                        "IndexName": "UsernameIndex",
                        "KeySchema": [
                            {
                                "AttributeName": "username",
                                "KeyType": "HASH"
                            }
                        ],
                        "Projection": {
                            "ProjectionType": "KEYS_ONLY"
                        }
                    }
                ],
                "ProvisionedThroughput": {
                    "ReadCapacityUnits": 20,
                    "WriteCapacityUnits": 6
                },
                "TableName": "Thread",
                "TableStatus": "ACTIVE"
            }
</source>
</class>

<class classid="117" nclones="2" nlines="96" similarity="74">
<source file="systems/boto-2.13.2/tests/unit/dynamodb2/test_table.py" startline="1705" endline="1822" pcid="5161">
        self.assertRaises(exceptions.UnknownFilterTypeError,
            self.users._build_filters,
            {
                'first_name__null': True,
            },
            using=QUERY_OPERATORS
        )

    def test_private_query(self):
        expected = {
            "ConsumedCapacity": {
                "CapacityUnits": 0.5,
                "TableName": "users"
            },
            "Count": 4,
            "Items": [
                {
                    'username': {'S': 'johndoe'},
                    'first_name': {'S': 'John'},
                    'last_name': {'S': 'Doe'},
                    'date_joined': {'N': '1366056668'},
                    'friend_count': {'N': '3'},
                    'friends': {'SS': ['alice', 'bob', 'jane']},
                },
                {
                    'username': {'S': 'jane'},
                    'first_name': {'S': 'Jane'},
                    'last_name': {'S': 'Doe'},
                    'date_joined': {'N': '1366057777'},
                    'friend_count': {'N': '2'},
                    'friends': {'SS': ['alice', 'johndoe']},
                },
                {
                    'username': {'S': 'alice'},
                    'first_name': {'S': 'Alice'},
                    'last_name': {'S': 'Expert'},
                    'date_joined': {'N': '1366056680'},
                    'friend_count': {'N': '1'},
                    'friends': {'SS': ['jane']},
                },
                {
                    'username': {'S': 'bob'},
                    'first_name': {'S': 'Bob'},
                    'last_name': {'S': 'Smith'},
                    'date_joined': {'N': '1366056888'},
                    'friend_count': {'N': '1'},
                    'friends': {'SS': ['johndoe']},
                },
            ],
            "ScannedCount": 4
        }

        with mock.patch.object(
                self.users.connection,
                'query',
                return_value=expected) as mock_query:
            results = self.users._query(
                limit=4,
                reverse=True,
                username__between=['aaa', 'mmm']
            )
            usernames = [res['username'] for res in results['results']]
            self.assertEqual(usernames, ['johndoe', 'jane', 'alice', 'bob'])
            self.assertEqual(len(results['results']), 4)
            self.assertEqual(results['last_key'], None)

        mock_query.assert_called_once_with('users',
            consistent_read=False,
            scan_index_forward=True,
            index_name=None,
            attributes_to_get=None,
            limit=4,
            key_conditions={
                'username': {
                    'AttributeValueList': [{'S': 'aaa'}, {'S': 'mmm'}],
                    'ComparisonOperator': 'BETWEEN',
                }
            },
            select=None
        )

        # Now alter the expected.
        expected['LastEvaluatedKey'] = {
            'username': {
                'S': 'johndoe',
            },
        }

        with mock.patch.object(
                self.users.connection,
                'query',
                return_value=expected) as mock_query_2:
            results = self.users._query(
                limit=4,
                reverse=True,
                username__between=['aaa', 'mmm'],
                exclusive_start_key={
                    'username': 'adam',
                },
                consistent=True
            )
            usernames = [res['username'] for res in results['results']]
            self.assertEqual(usernames, ['johndoe', 'jane', 'alice', 'bob'])
            self.assertEqual(len(results['results']), 4)
            self.assertEqual(results['last_key'], {'username': 'johndoe'})

        mock_query_2.assert_called_once_with('users',
            key_conditions={
                'username': {
                    'AttributeValueList': [{'S': 'aaa'}, {'S': 'mmm'}],
                    'ComparisonOperator': 'BETWEEN',
                }
            },
            index_name=None,
            attributes_to_get=None,
            scan_index_forward=True,
            limit=4,
            exclusive_start_key={
</source>
<source file="systems/boto-2.13.2/tests/unit/dynamodb2/test_table.py" startline="1823" endline="1925" pcid="5162">
                'username': {
                    'S': 'adam',
                },
            },
            consistent_read=True,
            select=None
        )

    def test_private_scan(self):
        expected = {
            "ConsumedCapacity": {
                "CapacityUnits": 0.5,
                "TableName": "users"
            },
            "Count": 4,
            "Items": [
                {
                    'username': {'S': 'alice'},
                    'first_name': {'S': 'Alice'},
                    'last_name': {'S': 'Expert'},
                    'date_joined': {'N': '1366056680'},
                    'friend_count': {'N': '1'},
                    'friends': {'SS': ['jane']},
                },
                {
                    'username': {'S': 'bob'},
                    'first_name': {'S': 'Bob'},
                    'last_name': {'S': 'Smith'},
                    'date_joined': {'N': '1366056888'},
                    'friend_count': {'N': '1'},
                    'friends': {'SS': ['johndoe']},
                },
                {
                    'username': {'S': 'jane'},
                    'first_name': {'S': 'Jane'},
                    'last_name': {'S': 'Doe'},
                    'date_joined': {'N': '1366057777'},
                    'friend_count': {'N': '2'},
                    'friends': {'SS': ['alice', 'johndoe']},
                },
            ],
            "ScannedCount": 4
        }

        with mock.patch.object(
                self.users.connection,
                'scan',
                return_value=expected) as mock_scan:
            results = self.users._scan(
                limit=2,
                friend_count__lte=2
            )
            usernames = [res['username'] for res in results['results']]
            self.assertEqual(usernames, ['alice', 'bob', 'jane'])
            self.assertEqual(len(results['results']), 3)
            self.assertEqual(results['last_key'], None)

        mock_scan.assert_called_once_with('users',
            scan_filter={
                'friend_count': {
                    'AttributeValueList': [{'N': '2'}],
                    'ComparisonOperator': 'LE',
                }
            },
            limit=2,
            segment=None,
            total_segments=None
        )

        # Now alter the expected.
        expected['LastEvaluatedKey'] = {
            'username': {
                'S': 'jane',
            },
        }

        with mock.patch.object(
                self.users.connection,
                'scan',
                return_value=expected) as mock_scan_2:
            results = self.users._scan(
                limit=3,
                friend_count__lte=2,
                exclusive_start_key={
                    'username': 'adam',
                },
                segment=None,
                total_segments=None
            )
            usernames = [res['username'] for res in results['results']]
            self.assertEqual(usernames, ['alice', 'bob', 'jane'])
            self.assertEqual(len(results['results']), 3)
            self.assertEqual(results['last_key'], {'username': 'jane'})

        mock_scan_2.assert_called_once_with('users',
            scan_filter={
                'friend_count': {
                    'AttributeValueList': [{'N': '2'}],
                    'ComparisonOperator': 'LE',
                }
            },
            limit=3,
            exclusive_start_key={
</source>
</class>

<class classid="118" nclones="3" nlines="50" similarity="80">
<source file="systems/boto-2.13.2/tests/unit/dynamodb2/test_table.py" startline="1926" endline="1983" pcid="5163">
                'username': {
                    'S': 'adam',
                },
            },
            segment=None,
            total_segments=None
        )

    def test_query(self):
        items_1 = {
            'results': [
                Item(self.users, data={
                    'username': 'johndoe',
                    'first_name': 'John',
                    'last_name': 'Doe',
                }),
                Item(self.users, data={
                    'username': 'jane',
                    'first_name': 'Jane',
                    'last_name': 'Doe',
                }),
            ],
            'last_key': 'jane',
        }

        results = self.users.query(last_name__eq='Doe')
        self.assertTrue(isinstance(results, ResultSet))
        self.assertEqual(len(results._results), 0)
        self.assertEqual(results.the_callable, self.users._query)

        with mock.patch.object(
                results,
                'the_callable',
                return_value=items_1) as mock_query:
            res_1 = results.next()
            # Now it should be populated.
            self.assertEqual(len(results._results), 2)
            self.assertEqual(res_1['username'], 'johndoe')
            res_2 = results.next()
            self.assertEqual(res_2['username'], 'jane')

        self.assertEqual(mock_query.call_count, 1)

        items_2 = {
            'results': [
                Item(self.users, data={
                    'username': 'foodoe',
                    'first_name': 'Foo',
                    'last_name': 'Doe',
                }),
            ],
        }

        with mock.patch.object(
                results,
                'the_callable',
                return_value=items_2) as mock_query_2:
            res_3 = results.next()
</source>
<source file="systems/boto-2.13.2/tests/unit/dynamodb2/test_table.py" startline="2232" endline="2297" pcid="5168">
                        'friend_count': {'N': '1'}
                    }, {
                        'username': {'S': 'jane'},
                    }
                ]
            }
        })

    def test_batch_get(self):
        items_1 = {
            'results': [
                Item(self.users, data={
                    'username': 'johndoe',
                    'first_name': 'John',
                    'last_name': 'Doe',
                }),
                Item(self.users, data={
                    'username': 'jane',
                    'first_name': 'Jane',
                    'last_name': 'Doe',
                }),
            ],
            'last_key': None,
            'unprocessed_keys': [
                'zoeydoe',
            ]
        }

        results = self.users.batch_get(keys=[
            {'username': 'johndoe'},
            {'username': 'jane'},
            {'username': 'zoeydoe'},
        ])
        self.assertTrue(isinstance(results, BatchGetResultSet))
        self.assertEqual(len(results._results), 0)
        self.assertEqual(results.the_callable, self.users._batch_get)

        with mock.patch.object(
                results,
                'the_callable',
                return_value=items_1) as mock_batch_get:
            res_1 = results.next()
            # Now it should be populated.
            self.assertEqual(len(results._results), 2)
            self.assertEqual(res_1['username'], 'johndoe')
            res_2 = results.next()
            self.assertEqual(res_2['username'], 'jane')

        self.assertEqual(mock_batch_get.call_count, 1)
        self.assertEqual(results._keys_left, ['zoeydoe'])

        items_2 = {
            'results': [
                Item(self.users, data={
                    'username': 'zoeydoe',
                    'first_name': 'Zoey',
                    'last_name': 'Doe',
                }),
            ],
        }

        with mock.patch.object(
                results,
                'the_callable',
                return_value=items_2) as mock_batch_get_2:
            res_3 = results.next()
</source>
<source file="systems/boto-2.13.2/tests/unit/dynamodb2/test_table.py" startline="2017" endline="2074" pcid="5165">
            self.assertEqual(len(results._results), 2)
            self.assertEqual(res_1['username'], 'johndoe')
            self.assertEqual(res_1.keys(), ['username'])
            res_2 = results.next()
            self.assertEqual(res_2['username'], 'jane')

        self.assertEqual(mock_query.call_count, 1)

    def test_scan(self):
        items_1 = {
            'results': [
                Item(self.users, data={
                    'username': 'johndoe',
                    'first_name': 'John',
                    'last_name': 'Doe',
                }),
                Item(self.users, data={
                    'username': 'jane',
                    'first_name': 'Jane',
                    'last_name': 'Doe',
                }),
            ],
            'last_key': 'jane',
        }

        results = self.users.scan(last_name__eq='Doe')
        self.assertTrue(isinstance(results, ResultSet))
        self.assertEqual(len(results._results), 0)
        self.assertEqual(results.the_callable, self.users._scan)

        with mock.patch.object(
                results,
                'the_callable',
                return_value=items_1) as mock_scan:
            res_1 = results.next()
            # Now it should be populated.
            self.assertEqual(len(results._results), 2)
            self.assertEqual(res_1['username'], 'johndoe')
            res_2 = results.next()
            self.assertEqual(res_2['username'], 'jane')

        self.assertEqual(mock_scan.call_count, 1)

        items_2 = {
            'results': [
                Item(self.users, data={
                    'username': 'zoeydoe',
                    'first_name': 'Zoey',
                    'last_name': 'Doe',
                }),
            ],
        }

        with mock.patch.object(
                results,
                'the_callable',
                return_value=items_2) as mock_scan_2:
            res_3 = results.next()
</source>
</class>

<class classid="119" nclones="2" nlines="18" similarity="84">
<source file="systems/boto-2.13.2/tests/unit/emr/test_emr_responses.py" startline="337" endline="353" pcid="5200">
    def test_JobFlows_example(self):
        [jobflow] = self._parse_xml(JOB_FLOW_EXAMPLE,
                                    [('member', emrobject.JobFlow)])
        self._assert_fields(jobflow,
                            creationdatetime='2009-01-28T21:49:16Z',
                            startdatetime='2009-01-28T21:49:16Z',
                            state='STARTING',
                            instancecount='4',
                            jobflowid='j-3UN6WX5RRO2AG',
                            loguri='mybucket/subdir/',
                            name='MyJobFlowName',
                            availabilityzone='us-east-1a',
                            slaveinstancetype='m1.small',
                            masterinstancetype='m1.small',
                            ec2keyname='myec2keyname',
                            keepjobflowalivewhennosteps='true')

</source>
<source file="systems/boto-2.13.2/tests/unit/emr/test_emr_responses.py" startline="354" endline="373" pcid="5201">
    def test_JobFlows_completed(self):
        [jobflow] = self._parse_xml(JOB_FLOW_COMPLETED,
                                    [('member', emrobject.JobFlow)])
        self._assert_fields(jobflow,
                            creationdatetime='2010-10-21T01:00:25Z',
                            startdatetime='2010-10-21T01:03:59Z',
                            enddatetime='2010-10-21T01:44:18Z',
                            state='COMPLETED',
                            instancecount='10',
                            jobflowid='j-3H3Q13JPFLU22',
                            loguri='s3n://example.emrtest.scripts/jobflow_logs/',
                            name='RealJobFlowName',
                            availabilityzone='us-east-1b',
                            slaveinstancetype='m1.large',
                            masterinstancetype='m1.large',
                            ec2keyname='myubersecurekey',
                            keepjobflowalivewhennosteps='false')
        self.assertEquals(6, len(jobflow.steps))
        self.assertEquals(2, len(jobflow.instancegroups))

</source>
</class>

<class classid="120" nclones="2" nlines="37" similarity="92">
<source file="systems/boto-2.13.2/tests/unit/rds/test_connection.py" startline="229" endline="268" pcid="5210">
    def test_create_db_instance_param_group_name(self):
        self.set_http_response(status_code=200)
        db = self.service_connection.create_dbinstance(
            'SimCoProd01',
            10,
            'db.m1.large',
            'master',
            'Password01',
            param_group='default.mysql5.1',
            db_subnet_group_name='dbSubnetgroup01')

        self.assert_request_parameters({
            'Action': 'CreateDBInstance',
            'AllocatedStorage': 10,
            'AutoMinorVersionUpgrade': 'true',
            'DBInstanceClass': 'db.m1.large',
            'DBInstanceIdentifier': 'SimCoProd01',
            'DBParameterGroupName': 'default.mysql5.1',
            'DBSubnetGroupName': 'dbSubnetgroup01',
            'Engine': 'MySQL5.1',
            'MasterUsername': 'master',
            'MasterUserPassword': 'Password01',
            'Port': 3306,
        }, ignore_params_values=['Version'])

        self.assertEqual(db.id, 'simcoprod01')
        self.assertEqual(db.engine, 'mysql')
        self.assertEqual(db.status, 'creating')
        self.assertEqual(db.allocated_storage, 10)
        self.assertEqual(db.instance_class, 'db.m1.large')
        self.assertEqual(db.master_username, 'master')
        self.assertEqual(db.multi_az, False)
        self.assertEqual(db.pending_modified_values,
            {'MasterUserPassword': '****'})

        self.assertEqual(db.parameter_group.name,
                         'default.mysql5.1')
        self.assertEqual(db.parameter_group.description, None)
        self.assertEqual(db.parameter_group.engine, None)

</source>
<source file="systems/boto-2.13.2/tests/unit/rds/test_connection.py" startline="269" endline="310" pcid="5211">
    def test_create_db_instance_param_group_instance(self):
        self.set_http_response(status_code=200)
        param_group = ParameterGroup()
        param_group.name = 'default.mysql5.1'
        db = self.service_connection.create_dbinstance(
            'SimCoProd01',
            10,
            'db.m1.large',
            'master',
            'Password01',
            param_group=param_group,
            db_subnet_group_name='dbSubnetgroup01')

        self.assert_request_parameters({
            'Action': 'CreateDBInstance',
            'AllocatedStorage': 10,
            'AutoMinorVersionUpgrade': 'true',
            'DBInstanceClass': 'db.m1.large',
            'DBInstanceIdentifier': 'SimCoProd01',
            'DBParameterGroupName': 'default.mysql5.1',
            'DBSubnetGroupName': 'dbSubnetgroup01',
            'Engine': 'MySQL5.1',
            'MasterUsername': 'master',
            'MasterUserPassword': 'Password01',
            'Port': 3306,
        }, ignore_params_values=['Version'])

        self.assertEqual(db.id, 'simcoprod01')
        self.assertEqual(db.engine, 'mysql')
        self.assertEqual(db.status, 'creating')
        self.assertEqual(db.allocated_storage, 10)
        self.assertEqual(db.instance_class, 'db.m1.large')
        self.assertEqual(db.master_username, 'master')
        self.assertEqual(db.multi_az, False)
        self.assertEqual(db.pending_modified_values,
            {'MasterUserPassword': '****'})
        self.assertEqual(db.parameter_group.name,
                         'default.mysql5.1')
        self.assertEqual(db.parameter_group.description, None)
        self.assertEqual(db.parameter_group.engine, None)


</source>
</class>

<class classid="121" nclones="2" nlines="29" similarity="86">
<source file="systems/boto-2.13.2/tests/unit/rds/test_connection.py" startline="400" endline="431" pcid="5216">
    def test_create_db_instance_vpc_sg_str(self):
        self.set_http_response(status_code=200)
        vpc_security_groups = [
            VPCSecurityGroupMembership(self.service_connection, 'active', 'sg-1'),
            VPCSecurityGroupMembership(self.service_connection, None, 'sg-2')]

        db = self.service_connection.create_dbinstance(
            'SimCoProd01',
            10,
            'db.m1.large',
            'master',
            'Password01',
            param_group='default.mysql5.1',
            db_subnet_group_name='dbSubnetgroup01',
            vpc_security_groups=vpc_security_groups)

        self.assert_request_parameters({
            'Action': 'CreateDBInstance',
            'AllocatedStorage': 10,
            'AutoMinorVersionUpgrade': 'true',
            'DBInstanceClass': 'db.m1.large',
            'DBInstanceIdentifier': 'SimCoProd01',
            'DBParameterGroupName': 'default.mysql5.1',
            'DBSubnetGroupName': 'dbSubnetgroup01',
            'Engine': 'MySQL5.1',
            'MasterUsername': 'master',
            'MasterUserPassword': 'Password01',
            'Port': 3306,
            'VpcSecurityGroupIds.member.1': 'sg-1',
            'VpcSecurityGroupIds.member.2': 'sg-2'
        }, ignore_params_values=['Version'])

</source>
<source file="systems/boto-2.13.2/tests/unit/rds/test_connection.py" startline="432" endline="468" pcid="5217">
    def test_create_db_instance_vpc_sg_obj(self):
        self.set_http_response(status_code=200)

        sg1 = SecurityGroup(name='sg-1')
        sg2 = SecurityGroup(name='sg-2')

        vpc_security_groups = [
            VPCSecurityGroupMembership(self.service_connection, 'active', sg1.name),
            VPCSecurityGroupMembership(self.service_connection, None, sg2.name)]

        db = self.service_connection.create_dbinstance(
            'SimCoProd01',
            10,
            'db.m1.large',
            'master',
            'Password01',
            param_group='default.mysql5.1',
            db_subnet_group_name='dbSubnetgroup01',
            vpc_security_groups=vpc_security_groups)

        self.assert_request_parameters({
            'Action': 'CreateDBInstance',
            'AllocatedStorage': 10,
            'AutoMinorVersionUpgrade': 'true',
            'DBInstanceClass': 'db.m1.large',
            'DBInstanceIdentifier': 'SimCoProd01',
            'DBParameterGroupName': 'default.mysql5.1',
            'DBSubnetGroupName': 'dbSubnetgroup01',
            'Engine': 'MySQL5.1',
            'MasterUsername': 'master',
            'MasterUserPassword': 'Password01',
            'Port': 3306,
            'VpcSecurityGroupIds.member.1': 'sg-1',
            'VpcSecurityGroupIds.member.2': 'sg-2'
        }, ignore_params_values=['Version'])


</source>
</class>

<class classid="122" nclones="2" nlines="14" similarity="78">
<source file="systems/boto-2.13.2/tests/unit/glacier/test_concurrent.py" startline="140" endline="155" pcid="5326">
    def test_upload_errors_have_exception_messages(self):
        api = mock.Mock()
        job_queue = Queue()
        result_queue = Queue()
        upload_thread = UploadWorkerThread(
            api, 'vault_name', self.filename,
            'upload_id', job_queue, result_queue, num_retries=1,
            time_between_retries=0)
        api.upload_part.side_effect = Exception("exception message")
        job_queue.put((0, 1024))
        job_queue.put(_END_SENTINEL)

        upload_thread.run()
        result = result_queue.get(timeout=1)
        self.assertIn("exception message", str(result))

</source>
<source file="systems/boto-2.13.2/tests/unit/glacier/test_concurrent.py" startline="156" endline="174" pcid="5327">
    def test_num_retries_is_obeyed(self):
        # total attempts is 1 + num_retries so if I have num_retries of 2,
        # I'll attempt the upload once, and if that fails I'll retry up to
        # 2 more times for a total of 3 attempts.
        api = mock.Mock()
        job_queue = Queue()
        result_queue = Queue()
        upload_thread = UploadWorkerThread(
            api, 'vault_name', self.filename,
            'upload_id', job_queue, result_queue, num_retries=2,
            time_between_retries=0)
        api.upload_part.side_effect = Exception()
        job_queue.put((0, 1024))
        job_queue.put(_END_SENTINEL)

        upload_thread.run()
        self.assertEqual(api.upload_part.call_count, 3)


</source>
</class>

<class classid="123" nclones="3" nlines="10" similarity="72">
<source file="systems/boto-2.13.2/tests/unit/s3/test_website.py" startline="82" endline="110" pcid="5417">
    def test_routing_rules_key_prefix(self):
        x = pretty_print_xml
        # This rule redirects requests for docs/* to documentation/*
        rules = RoutingRules()
        condition = Condition(key_prefix='docs/')
        redirect = Redirect(replace_key_prefix='documents/')
        rules.add_rule(RoutingRule(condition, redirect))
        config = WebsiteConfiguration(suffix='index.html', routing_rules=rules)
        xml = config.to_xml()

        expected_xml = """<?xml version="1.0" encoding="UTF-8"?>
            <WebsiteConfiguration xmlns='http://s3.amazonaws.com/doc/2006-03-01/'>
              <IndexDocument>
                <Suffix>index.html</Suffix>
              </IndexDocument>
              <RoutingRules>
                <RoutingRule>
                <Condition>
                  <KeyPrefixEquals>docs/</KeyPrefixEquals>
                </Condition>
                <Redirect>
                  <ReplaceKeyPrefixWith>documents/</ReplaceKeyPrefixWith>
                </Redirect>
                </RoutingRule>
              </RoutingRules>
            </WebsiteConfiguration>
        """
        self.assertEqual(x(expected_xml), x(xml))

</source>
<source file="systems/boto-2.13.2/tests/unit/s3/test_website.py" startline="146" endline="173" pcid="5419">
    def test_key_prefix(self):
        x = pretty_print_xml
        rules = RoutingRules()
        condition = Condition(key_prefix="images/")
        redirect = Redirect(replace_key='folderdeleted.html')
        rules.add_rule(RoutingRule(condition, redirect))
        config = WebsiteConfiguration(suffix='index.html', routing_rules=rules)
        xml = config.to_xml()

        expected_xml = """<?xml version="1.0" encoding="UTF-8"?>
            <WebsiteConfiguration xmlns='http://s3.amazonaws.com/doc/2006-03-01/'>
              <IndexDocument>
                <Suffix>index.html</Suffix>
              </IndexDocument>
              <RoutingRules>
                <RoutingRule>
                <Condition>
                  <KeyPrefixEquals>images/</KeyPrefixEquals>
                </Condition>
                <Redirect>
                  <ReplaceKeyWith>folderdeleted.html</ReplaceKeyWith>
                </Redirect>
                </RoutingRule>
              </RoutingRules>
            </WebsiteConfiguration>
        """
        self.assertEqual(x(expected_xml), x(xml))

</source>
<source file="systems/boto-2.13.2/tests/unit/s3/test_website.py" startline="111" endline="145" pcid="5418">
    def test_routing_rules_to_host_on_404(self):
        x = pretty_print_xml
        # Another example from the docs:
        # Redirect requests to a specific host in the event of a 404.
        # Also, the redirect inserts a report-404/.  For example,
        # if you request a page ExamplePage.html and it results
        # in a 404, the request is routed to a page report-404/ExamplePage.html
        rules = RoutingRules()
        condition = Condition(http_error_code=404)
        redirect = Redirect(hostname='example.com',
                            replace_key_prefix='report-404/')
        rules.add_rule(RoutingRule(condition, redirect))
        config = WebsiteConfiguration(suffix='index.html', routing_rules=rules)
        xml = config.to_xml()

        expected_xml = """<?xml version="1.0" encoding="UTF-8"?>
            <WebsiteConfiguration xmlns='http://s3.amazonaws.com/doc/2006-03-01/'>
              <IndexDocument>
                <Suffix>index.html</Suffix>
              </IndexDocument>
              <RoutingRules>
                <RoutingRule>
                <Condition>
                  <HttpErrorCodeReturnedEquals>404</HttpErrorCodeReturnedEquals>
                </Condition>
                <Redirect>
                  <HostName>example.com</HostName>
                  <ReplaceKeyPrefixWith>report-404/</ReplaceKeyPrefixWith>
                </Redirect>
                </RoutingRule>
              </RoutingRules>
            </WebsiteConfiguration>
        """
        self.assertEqual(x(expected_xml), x(xml))

</source>
</class>

<class classid="124" nclones="8" nlines="20" similarity="75">
<source file="systems/boto-2.13.2/tests/unit/s3/test_uri.py" startline="31" endline="51" pcid="5425">
    def test_provider_uri(self):
        for prov in ('gs', 's3'):
            uri_str = '%s://' % prov
            uri = boto.storage_uri(uri_str, validate=False,
                suppress_consec_slashes=False)
            self.assertEqual(prov, uri.scheme)
            self.assertEqual(uri_str, uri.uri)
            self.assertFalse(hasattr(uri, 'versionless_uri'))
            self.assertEqual('', uri.bucket_name)
            self.assertEqual('', uri.object_name)
            self.assertEqual(None, uri.version_id)
            self.assertEqual(None, uri.generation)
            self.assertEqual(uri.names_provider(), True)
            self.assertEqual(uri.names_container(), True)
            self.assertEqual(uri.names_bucket(), False)
            self.assertEqual(uri.names_object(), False)
            self.assertEqual(uri.names_directory(), False)
            self.assertEqual(uri.names_file(), False)
            self.assertEqual(uri.is_stream(), False)
            self.assertEqual(uri.is_version_specific, False)

</source>
<source file="systems/boto-2.13.2/tests/unit/s3/test_uri.py" startline="94" endline="114" pcid="5428">
    def test_non_versioned_object_uri(self):
        for prov in ('gs', 's3'):
            uri_str = '%s://bucket/obj/a/b' % prov
            uri = boto.storage_uri(uri_str, validate=False,
                suppress_consec_slashes=False)
            self.assertEqual(prov, uri.scheme)
            self.assertEqual(uri_str, uri.uri)
            self.assertEqual(uri_str, uri.versionless_uri)
            self.assertEqual('bucket', uri.bucket_name)
            self.assertEqual('obj/a/b', uri.object_name)
            self.assertEqual(None, uri.version_id)
            self.assertEqual(None, uri.generation)
            self.assertEqual(uri.names_provider(), False)
            self.assertEqual(uri.names_container(), False)
            self.assertEqual(uri.names_bucket(), False)
            self.assertEqual(uri.names_object(), True)
            self.assertEqual(uri.names_directory(), False)
            self.assertEqual(uri.names_file(), False)
            self.assertEqual(uri.is_stream(), False)
            self.assertEqual(uri.is_version_specific, False)

</source>
<source file="systems/boto-2.13.2/tests/unit/s3/test_uri.py" startline="52" endline="72" pcid="5426">
    def test_bucket_uri_no_trailing_slash(self):
        for prov in ('gs', 's3'):
            uri_str = '%s://bucket' % prov
            uri = boto.storage_uri(uri_str, validate=False,
                suppress_consec_slashes=False)
            self.assertEqual(prov, uri.scheme)
            self.assertEqual('%s/' % uri_str, uri.uri)
            self.assertFalse(hasattr(uri, 'versionless_uri'))
            self.assertEqual('bucket', uri.bucket_name)
            self.assertEqual('', uri.object_name)
            self.assertEqual(None, uri.version_id)
            self.assertEqual(None, uri.generation)
            self.assertEqual(uri.names_provider(), False)
            self.assertEqual(uri.names_container(), True)
            self.assertEqual(uri.names_bucket(), True)
            self.assertEqual(uri.names_object(), False)
            self.assertEqual(uri.names_directory(), False)
            self.assertEqual(uri.names_file(), False)
            self.assertEqual(uri.is_stream(), False)
            self.assertEqual(uri.is_version_specific, False)

</source>
<source file="systems/boto-2.13.2/tests/unit/s3/test_uri.py" startline="115" endline="134" pcid="5429">
    def test_versioned_gs_object_uri(self):
        uri_str = 'gs://bucket/obj/a/b#1359908801674000'
        uri = boto.storage_uri(uri_str, validate=False,
            suppress_consec_slashes=False)
        self.assertEqual('gs', uri.scheme)
        self.assertEqual(uri_str, uri.uri)
        self.assertEqual('gs://bucket/obj/a/b', uri.versionless_uri)
        self.assertEqual('bucket', uri.bucket_name)
        self.assertEqual('obj/a/b', uri.object_name)
        self.assertEqual(None, uri.version_id)
        self.assertEqual(1359908801674000, uri.generation)
        self.assertEqual(uri.names_provider(), False)
        self.assertEqual(uri.names_container(), False)
        self.assertEqual(uri.names_bucket(), False)
        self.assertEqual(uri.names_object(), True)
        self.assertEqual(uri.names_directory(), False)
        self.assertEqual(uri.names_file(), False)
        self.assertEqual(uri.is_stream(), False)
        self.assertEqual(uri.is_version_specific, True)

</source>
<source file="systems/boto-2.13.2/tests/unit/s3/test_uri.py" startline="226" endline="246" pcid="5435">
    def test_gs_object_uri_contains_sharp_not_matching_version_syntax(self):
        uri_str = 'gs://bucket/obj#13a990880167400'
        uri = boto.storage_uri(uri_str, validate=False,
            suppress_consec_slashes=False)
        self.assertEqual('gs', uri.scheme)
        self.assertEqual(uri_str, uri.uri)
        self.assertEqual('gs://bucket/obj#13a990880167400',
                         uri.versionless_uri)
        self.assertEqual('bucket', uri.bucket_name)
        self.assertEqual('obj#13a990880167400', uri.object_name)
        self.assertEqual(None, uri.version_id)
        self.assertEqual(None, uri.generation)
        self.assertEqual(uri.names_provider(), False)
        self.assertEqual(uri.names_container(), False)
        self.assertEqual(uri.names_bucket(), False)
        self.assertEqual(uri.names_object(), True)
        self.assertEqual(uri.names_directory(), False)
        self.assertEqual(uri.names_file(), False)
        self.assertEqual(uri.is_stream(), False)
        self.assertEqual(uri.is_version_specific, False)

</source>
<source file="systems/boto-2.13.2/tests/unit/s3/test_uri.py" startline="135" endline="154" pcid="5430">
    def test_versioned_gs_object_uri_with_legacy_generation_value(self):
        uri_str = 'gs://bucket/obj/a/b#1'
        uri = boto.storage_uri(uri_str, validate=False,
            suppress_consec_slashes=False)
        self.assertEqual('gs', uri.scheme)
        self.assertEqual(uri_str, uri.uri)
        self.assertEqual('gs://bucket/obj/a/b', uri.versionless_uri)
        self.assertEqual('bucket', uri.bucket_name)
        self.assertEqual('obj/a/b', uri.object_name)
        self.assertEqual(None, uri.version_id)
        self.assertEqual(1, uri.generation)
        self.assertEqual(uri.names_provider(), False)
        self.assertEqual(uri.names_container(), False)
        self.assertEqual(uri.names_bucket(), False)
        self.assertEqual(uri.names_object(), True)
        self.assertEqual(uri.names_directory(), False)
        self.assertEqual(uri.names_file(), False)
        self.assertEqual(uri.is_stream(), False)
        self.assertEqual(uri.is_version_specific, True)

</source>
<source file="systems/boto-2.13.2/tests/unit/s3/test_uri.py" startline="73" endline="93" pcid="5427">
    def test_bucket_uri_with_trailing_slash(self):
        for prov in ('gs', 's3'):
            uri_str = '%s://bucket/' % prov
            uri = boto.storage_uri(uri_str, validate=False,
                suppress_consec_slashes=False)
            self.assertEqual(prov, uri.scheme)
            self.assertEqual(uri_str, uri.uri)
            self.assertFalse(hasattr(uri, 'versionless_uri'))
            self.assertEqual('bucket', uri.bucket_name)
            self.assertEqual('', uri.object_name)
            self.assertEqual(None, uri.version_id)
            self.assertEqual(None, uri.generation)
            self.assertEqual(uri.names_provider(), False)
            self.assertEqual(uri.names_container(), True)
            self.assertEqual(uri.names_bucket(), True)
            self.assertEqual(uri.names_object(), False)
            self.assertEqual(uri.names_directory(), False)
            self.assertEqual(uri.names_file(), False)
            self.assertEqual(uri.is_stream(), False)
            self.assertEqual(uri.is_version_specific, False)

</source>
<source file="systems/boto-2.13.2/tests/unit/s3/test_uri.py" startline="164" endline="183" pcid="5432">
    def test_versioned_s3_object_uri(self):
        uri_str = 's3://bucket/obj/a/b#eMuM0J15HkJ9QHlktfNP5MfA.oYR2q6S'
        uri = boto.storage_uri(uri_str, validate=False,
            suppress_consec_slashes=False)
        self.assertEqual('s3', uri.scheme)
        self.assertEqual(uri_str, uri.uri)
        self.assertEqual('s3://bucket/obj/a/b', uri.versionless_uri)
        self.assertEqual('bucket', uri.bucket_name)
        self.assertEqual('obj/a/b', uri.object_name)
        self.assertEqual('eMuM0J15HkJ9QHlktfNP5MfA.oYR2q6S', uri.version_id)
        self.assertEqual(None, uri.generation)
        self.assertEqual(uri.names_provider(), False)
        self.assertEqual(uri.names_container(), False)
        self.assertEqual(uri.names_bucket(), False)
        self.assertEqual(uri.names_object(), True)
        self.assertEqual(uri.names_directory(), False)
        self.assertEqual(uri.names_file(), False)
        self.assertEqual(uri.is_stream(), False)
        self.assertEqual(uri.is_version_specific, True)

</source>
</class>

<class classid="125" nclones="2" nlines="16" similarity="93">
<source file="systems/boto-2.13.2/tests/unit/s3/test_uri.py" startline="184" endline="204" pcid="5433">
    def test_explicit_file_uri(self):
        tmp_dir = tempfile.tempdir
        uri_str = 'file://%s' % urllib.pathname2url(tmp_dir)
        uri = boto.storage_uri(uri_str, validate=False,
            suppress_consec_slashes=False)
        self.assertEqual('file', uri.scheme)
        self.assertEqual(uri_str, uri.uri)
        self.assertFalse(hasattr(uri, 'versionless_uri'))
        self.assertEqual('', uri.bucket_name)
        self.assertEqual(tmp_dir, uri.object_name)
        self.assertFalse(hasattr(uri, 'version_id'))
        self.assertFalse(hasattr(uri, 'generation'))
        self.assertFalse(hasattr(uri, 'is_version_specific'))
        self.assertEqual(uri.names_provider(), False)
        self.assertEqual(uri.names_bucket(), False)
        # Don't check uri.names_container(), uri.names_directory(),
        # uri.names_file(), or uri.names_object(), because for file URIs these
        # functions look at the file system and apparently unit tests run
        # chroot'd.
        self.assertEqual(uri.is_stream(), False)

</source>
<source file="systems/boto-2.13.2/tests/unit/s3/test_uri.py" startline="205" endline="225" pcid="5434">
    def test_implicit_file_uri(self):
        tmp_dir = tempfile.tempdir
        uri_str = '%s' % urllib.pathname2url(tmp_dir)
        uri = boto.storage_uri(uri_str, validate=False,
            suppress_consec_slashes=False)
        self.assertEqual('file', uri.scheme)
        self.assertEqual('file://%s' % tmp_dir, uri.uri)
        self.assertFalse(hasattr(uri, 'versionless_uri'))
        self.assertEqual('', uri.bucket_name)
        self.assertEqual(tmp_dir, uri.object_name)
        self.assertFalse(hasattr(uri, 'version_id'))
        self.assertFalse(hasattr(uri, 'generation'))
        self.assertFalse(hasattr(uri, 'is_version_specific'))
        self.assertEqual(uri.names_provider(), False)
        self.assertEqual(uri.names_bucket(), False)
        # Don't check uri.names_container(), uri.names_directory(),
        # uri.names_file(), or uri.names_object(), because for file URIs these
        # functions look at the file system and apparently unit tests run
        # chroot'd.
        self.assertEqual(uri.is_stream(), False)

</source>
</class>

</clones>
