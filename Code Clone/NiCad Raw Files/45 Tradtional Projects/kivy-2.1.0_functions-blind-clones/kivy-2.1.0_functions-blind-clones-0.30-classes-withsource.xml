<clones>
<systeminfo processor="nicad6" system="kivy-2.1.0" granularity="functions-blind" threshold="30%" minlines="10" maxlines="2500"/>
<cloneinfo npcs="3572" npairs="109"/>
<runinfo ncompares="193551" cputime="150155"/>
<classinfo nclasses="51"/>

<class classid="1" nclones="2" nlines="13" similarity="84">
<source file="systems/kivy-2.1.0/kivy/effects/scroll.py" startline="97" endline="110" pcid="52">
    def on_value(self, *args):
        scroll_min = self.min
        scroll_max = self.max
        if scroll_min > scroll_max:
            scroll_min, scroll_max = scroll_max, scroll_min
        if self.value < scroll_min:
            self.overscroll = self.value - scroll_min
            self.reset(scroll_min)
        elif self.value > scroll_max:
            self.overscroll = self.value - scroll_max
            self.reset(scroll_max)
        else:
            self.scroll = self.value

</source>
<source file="systems/kivy-2.1.0/kivy/effects/dampedscroll.py" startline="94" endline="106" pcid="57">
    def on_value(self, *args):
        scroll_min = self.min
        scroll_max = self.max
        if scroll_min > scroll_max:
            scroll_min, scroll_max = scroll_max, scroll_min
        if self.value < scroll_min:
            self.overscroll = self.value - scroll_min
        elif self.value > scroll_max:
            self.overscroll = self.value - scroll_max
        else:
            self.overscroll = 0
        self.scroll = self.value

</source>
</class>

<class classid="2" nclones="2" nlines="15" similarity="73">
<source file="systems/kivy-2.1.0/kivy/tools/texturecompress.py" startline="119" endline="137" pcid="277">
    def locate_etc1tool(self):
        search_directories = [environ.get('ANDROIDSDK', '/')]
        search_directories += environ.get('PATH', '').split(':')
        for directory in search_directories:
            fn = join(directory, 'etc1tool')
            if not exists(fn):
                fn = join(directory, 'tools', 'etc1tool')
                if not exists(fn):
                    continue
            print('Found texturetool at {}'.format(directory))
            self.etc1tool = fn
            return

        if self.etc1tool is None:
            print('Error: Unable to locate "etc1tool".\n'
                  'Make sure that "etc1tool" is available in your PATH.\n'
                  'Or export the path of your Android SDK to ANDROIDSDK')
            exit(1)

</source>
<source file="systems/kivy-2.1.0/kivy/tools/texturecompress.py" startline="172" endline="191" pcid="280">
    def locate_texturetool(self):
        search_directories = [
            ('/Applications/Xcode.app/Contents/Developer/Platforms/'
             'iPhoneOS.platform/Developer/usr/bin/'),
            '/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin/']
        search_directories += environ.get('PATH', '').split(':')

        for directory in search_directories:
            fn = join(directory, 'texturetool')
            if not exists(fn):
                continue
            print('Found texturetool at {}'.format(directory))
            self.texturetool = fn
            return

        print('Error: Unable to locate "texturetool".\n'
              'Please install the iPhone SDK, or the PowerVR SDK.\n'
              'Then make sure that "texturetool" is available in your PATH.')
        exit(1)

</source>
</class>

<class classid="3" nclones="2" nlines="15" similarity="81">
<source file="systems/kivy-2.1.0/kivy/tests/test_animations.py" startline="80" endline="94" pcid="405">
    def test_cancel_all(self):
        from kivy.animation import Animation
        from kivy.uix.widget import Widget
        a1 = Animation(x=100)
        a2 = Animation(y=100)
        w1 = Widget()
        w2 = Widget()
        a1.start(w1)
        a1.start(w2)
        a2.start(w1)
        a2.start(w2)
        assert not no_animations_being_played()
        Animation.cancel_all(None)
        assert no_animations_being_played()

</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_animations.py" startline="95" endline="111" pcid="406">
    def test_cancel_all_2(self):
        from kivy.animation import Animation
        from kivy.uix.widget import Widget
        a1 = Animation(x=100)
        a2 = Animation(y=100)
        w1 = Widget()
        w2 = Widget()
        a1.start(w1)
        a1.start(w2)
        a2.start(w1)
        a2.start(w2)
        assert not no_animations_being_played()
        Animation.cancel_all(None, 'x', 'z')
        assert not no_animations_being_played()
        Animation.cancel_all(None, 'y')
        assert no_animations_being_played()

</source>
</class>

<class classid="4" nclones="3" nlines="26" similarity="73">
<source file="systems/kivy-2.1.0/kivy/tests/test_animations.py" startline="229" endline="262" pcid="419">
    def test_count_events(self, ec_cls):
        from kivy.animation import Animation
        from kivy.uix.widget import Widget
        a = Animation(x=100, d=.5) + Animation(x=0, d=.5)
        w = Widget()
        ec = ec_cls(a)
        ec1 = ec_cls(a.anim1)
        ec2 = ec_cls(a.anim2)
        a.start(w)

        # right after the animation starts
        ec.assert_(1, False, 0)
        ec1.assert_(1, False, 0)
        ec2.assert_(0, False, 0)
        sleep(.2)

        # during the first half of the animation
        ec.assert_(1, True, 0)
        ec1.assert_(1, True, 0)
        ec2.assert_(0, False, 0)
        sleep(.5)

        # during the second half of the animation
        ec.assert_(1, True, 0)
        ec1.assert_(1, True, 1)
        ec2.assert_(1, True, 0)
        sleep(.5)

        # after the animation completed
        ec.assert_(1, True, 1)
        ec1.assert_(1, True, 1)
        ec2.assert_(1, True, 1)
        assert no_animations_being_played()

</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_animations.py" startline="383" endline="415" pcid="429">
    def test_count_events(self, ec_cls):
        from kivy.animation import Animation
        from kivy.uix.widget import Widget
        a = Animation(x=100) & Animation(y=100, d=.5)
        w = Widget()
        ec = ec_cls(a)
        ec1 = ec_cls(a.anim1)
        ec2 = ec_cls(a.anim2)
        a.start(w)

        # right after the animation started
        ec.assert_(1, False, 0)
        ec1.assert_(1, False, 0)
        ec2.assert_(1, False, 0)
        sleep(.2)

        # during the first half of the animation
        ec.assert_(1, False, 0)  # n_progress is still 0 !!
        ec1.assert_(1, True, 0)
        ec2.assert_(1, True, 0)
        sleep(.5)

        # during the second half of the animation
        ec.assert_(1, False, 0)  # n_progress is still 0 !!
        ec1.assert_(1, True, 0)
        ec2.assert_(1, True, 1)
        sleep(.5)

        # after the animation compeleted
        ec.assert_(1, False, 1)  # n_progress is still 0 !
        ec1.assert_(1, True, 1)
        ec2.assert_(1, True, 1)
        assert no_animations_being_played()
</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_animations.py" startline="299" endline="346" pcid="424">
    def test_count_events(self, ec_cls):
        from kivy.animation import Animation
        from kivy.uix.widget import Widget
        a = Animation(x=100, d=.5) + Animation(x=0, d=.5)
        a.repeat = True
        w = Widget()
        ec = ec_cls(a)
        ec1 = ec_cls(a.anim1)
        ec2 = ec_cls(a.anim2)
        a.start(w)

        # right after the animation starts
        ec.assert_(1, False, 0)
        ec1.assert_(1, False, 0)
        ec2.assert_(0, False, 0)
        sleep(.2)

        # during the first half of the first round of the animation
        ec.assert_(1, True, 0)
        ec1.assert_(1, True, 0)
        ec2.assert_(0, False, 0)
        sleep(.5)

        # during the second half of the first round of the animation
        ec.assert_(1, True, 0)
        ec1.assert_(1, True, 1)
        ec2.assert_(1, True, 0)
        sleep(.5)

        # during the first half of the second round of the animation
        ec.assert_(1, True, 0)
        ec1.assert_(2, True, 1)
        ec2.assert_(1, True, 1)
        sleep(.5)

        # during the second half of the second round of the animation
        ec.assert_(1, True, 0)
        ec1.assert_(2, True, 2)
        ec2.assert_(2, True, 1)
        a.stop(w)

        # after the animation stopped
        ec.assert_(1, True, 1)
        ec1.assert_(2, True, 2)
        ec2.assert_(2, True, 2)
        assert no_animations_being_played()


</source>
</class>

<class classid="5" nclones="3" nlines="11" similarity="72">
<source file="systems/kivy-2.1.0/kivy/tests/test_animations.py" startline="263" endline="274" pcid="420">
    def test_have_properties_to_animate(self):
        from kivy.animation import Animation
        from kivy.uix.widget import Widget
        a = Animation(x=100) + Animation(x=0)
        w = Widget()
        assert not a.have_properties_to_animate(w)
        a.start(w)
        assert a.have_properties_to_animate(w)
        a.stop(w)
        assert not a.have_properties_to_animate(w)
        assert no_animations_being_played()

</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_animations.py" startline="349" endline="360" pcid="425">
    def test_have_properties_to_animate(self):
        from kivy.animation import Animation
        from kivy.uix.widget import Widget
        a = Animation(x=100) & Animation(y=100)
        w = Widget()
        assert not a.have_properties_to_animate(w)
        a.start(w)
        assert a.have_properties_to_animate(w)
        a.stop(w)
        assert not a.have_properties_to_animate(w)
        assert no_animations_being_played()

</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_animations.py" startline="361" endline="371" pcid="426">
    def test_cancel_property(self):
        from kivy.animation import Animation
        from kivy.uix.widget import Widget
        a = Animation(x=100) & Animation(y=100)
        w = Widget()
        a.start(w)
        a.cancel_property(w, 'x')
        assert not no_animations_being_played()
        a.stop(w)
        assert no_animations_being_played()

</source>
</class>

<class classid="6" nclones="2" nlines="12" similarity="100">
<source file="systems/kivy-2.1.0/kivy/tests/test_widget.py" startline="63" endline="75" pcid="491">
    def test_position(self):
        wid = self.root
        wid.x = 50
        self.assertEqual(wid.x, 50)
        self.assertEqual(wid.pos, [50, 0])
        wid.y = 60
        self.assertEqual(wid.y, 60)
        self.assertEqual(wid.pos, [50, 60])
        wid.pos = (0, 0)
        self.assertEqual(wid.pos, [0, 0])
        self.assertEqual(wid.x, 0)
        self.assertEqual(wid.y, 0)

</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_widget.py" startline="76" endline="88" pcid="492">
    def test_size(self):
        wid = self.root
        wid.width = 50
        self.assertEqual(wid.width, 50)
        self.assertEqual(wid.size, [50, 100])
        wid.height = 60
        self.assertEqual(wid.height, 60)
        self.assertEqual(wid.size, [50, 60])
        wid.size = (100, 100)
        self.assertEqual(wid.size, [100, 100])
        self.assertEqual(wid.width, 100)
        self.assertEqual(wid.height, 100)

</source>
</class>

<class classid="7" nclones="2" nlines="22" similarity="81">
<source file="systems/kivy-2.1.0/kivy/tests/test_graphics.py" startline="161" endline="185" pcid="514">
def test_create_graphics_second_thread(widget_verify_thread):
    from kivy.graphics import Color
    widget, verify_thread = widget_verify_thread
    exception = None

    def callback():
        nonlocal exception
        try:
            with widget.canvas:
                if verify_thread == '1':
                    with pytest.raises(TypeError):
                        Color()
                else:
                    Color()
        except BaseException as e:
            exception = e, sys.exc_info()[2]
            raise

    thread = Thread(target=callback)
    thread.start()
    thread.join()
    if exception is not None:
        raise exception[0].with_traceback(exception[1])


</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_graphics.py" startline="188" endline="212" pcid="516">
def test_change_graphics_second_thread(widget_verify_thread):
    from kivy.graphics import Color
    widget, verify_thread = widget_verify_thread
    with widget.canvas:
        color = Color()

    exception = None

    def callback():
        nonlocal exception
        try:
            if verify_thread == '1':
                with pytest.raises(TypeError):
                    color.rgb = .1, .2, .3
            else:
                color.rgb = .1, .2, .3
        except BaseException as e:
            exception = e, sys.exc_info()[2]
            raise

    thread = Thread(target=callback)
    thread.start()
    thread.join()
    if exception is not None:
        raise exception[0].with_traceback(exception[1])
</source>
</class>

<class classid="8" nclones="2" nlines="12" similarity="75">
<source file="systems/kivy-2.1.0/kivy/tests/test_utils.py" startline="136" endline="148" pcid="545">
    def test_intersection(self):
        abcd = ['a', 'b', 'c', 'd']
        efgh = ['e', 'f', 'g', 'h']
        fedc = ['c', 'd', 'e', 'f']  # cdef is cython keyword O_o)
        feed = ['f', 'e', 'e', 'd']
        self.assertEqual(intersection(abcd, efgh), [])
        self.assertEqual(intersection(abcd, fedc), ['c', 'd'])
        self.assertEqual(intersection(feed, feed), feed)
        self.assertEqual(intersection([], []), [])
        self.assertEqual(intersection(feed, fedc), feed)
        self.assertEqual(intersection(fedc, feed), ['d', 'e', 'f'])
        self.assertEqual(intersection(feed, efgh), ['f', 'e', 'e'])

</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_utils.py" startline="149" endline="161" pcid="546">
    def test_difference(self):
        abcd = ['a', 'b', 'c', 'd']
        efgh = ['e', 'f', 'g', 'h']
        fedc = ['c', 'd', 'e', 'f']  # cdef is cython keyword O_o
        feed = ['f', 'e', 'e', 'd']
        self.assertEqual(difference(abcd, efgh), ['a', 'b', 'c', 'd'])
        self.assertEqual(difference(efgh, fedc), ['g', 'h'])
        self.assertEqual(difference([], []), [])
        self.assertEqual(difference(abcd, abcd), [])
        self.assertEqual(difference(fedc, feed), ['c'])
        self.assertEqual(difference(feed, abcd), ['f', 'e', 'e'])
        self.assertEqual(difference(abcd, feed), ['a', 'b', 'c'])

</source>
</class>

<class classid="9" nclones="4" nlines="17" similarity="71">
<source file="systems/kivy-2.1.0/kivy/tests/test_urlrequest.py" startline="64" endline="82" pcid="570">
def test_callbacks(kivy_clock):
    from kivy.network.urlrequest import UrlRequest
    obj = UrlRequestQueue([])
    queue = obj.queue
    req = UrlRequest('http://google.com',
                     on_success=obj._on_success,
                     on_progress=obj._on_progress,
                     on_error=obj._on_error,
                     on_redirect=obj._on_redirect,
                     debug=True)
    wait_request_is_finished(kivy_clock, req)

    if req.error and req.error.errno == 11001:
        pytest.skip('Cannot connect to get address')

    ensure_called_from_thread(queue)
    check_queue_values(queue)


</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_urlrequest.py" startline="137" endline="158" pcid="573">
def test_ca_file(kivy_clock, scheme):
    """Passing a `ca_file` should not crash on http scheme, refs #6946"""
    from kivy.network.urlrequest import UrlRequest
    import certifi
    obj = UrlRequestQueue([])
    queue = obj.queue
    req = UrlRequest(
        f"{scheme}://httpbin.org/get",
        on_success=obj._on_success,
        on_progress=obj._on_progress,
        on_error=obj._on_error,
        on_redirect=obj._on_redirect,
        ca_file=certifi.where(),
        debug=True
    )
    wait_request_is_finished(kivy_clock, req)

    if req.error and req.error.errno == 11001:
        pytest.skip('Cannot connect to get address')

    ensure_called_from_thread(queue)
    check_queue_values(queue)
</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_urlrequest.py" startline="113" endline="134" pcid="572">
def test_auth_auto(kivy_clock):
    from kivy.network.urlrequest import UrlRequest
    obj = UrlRequestQueue([])
    queue = obj.queue
    req = UrlRequest(
        'http://user:passwd@httpbin.org/basic-auth/user/passwd',
        on_success=obj._on_success,
        on_progress=obj._on_progress,
        on_error=obj._on_error,
        on_redirect=obj._on_redirect,
        debug=True
    )
    wait_request_is_finished(kivy_clock, req)

    if req.error and req.error.errno == 11001:
        pytest.skip('Cannot connect to get address')

    ensure_called_from_thread(queue)
    check_queue_values(queue)
    assert queue[-1][2] == ({'authenticated': True, 'user': 'user'}, )


</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_urlrequest.py" startline="84" endline="111" pcid="571">
def test_auth_header(kivy_clock):
    from kivy.network.urlrequest import UrlRequest
    obj = UrlRequestQueue([])
    queue = obj.queue
    head = {
        "Authorization": "Basic {}".format(b64encode(
            "{}:{}".format('user', 'passwd').encode('utf-8')
        ).decode('utf-8'))
    }
    req = UrlRequest(
        'http://httpbin.org/basic-auth/user/passwd',
        on_success=obj._on_success,
        on_progress=obj._on_progress,
        on_error=obj._on_error,
        on_redirect=obj._on_redirect,
        req_headers=head,
        debug=True
    )
    wait_request_is_finished(kivy_clock, req)

    if req.error and req.error.errno == 11001:
        pytest.skip('Cannot connect to get address')

    ensure_called_from_thread(queue)
    check_queue_values(queue)
    assert queue[-1][2] == ({'authenticated': True, 'user': 'user'}, )


</source>
</class>

<class classid="10" nclones="4" nlines="33" similarity="72">
<source file="systems/kivy-2.1.0/kivy/tests/test_uix_actionbar.py" startline="120" endline="174" pcid="580">
    def test_1_openclose(self, *args):
        # click on Group 2 to open its DropDown
        # - DropDown shows up
        # then click away
        # - Group 2 DropDown disappears
        # click on Group 1 to open its DropDown
        # - DropDown shows up
        # then click away
        # - Group 1 DropDown disappears
        self._win = EventLoop.window
        self.clean_garbage()
        root = Builder.load_string(KV)
        self.render(root)
        self.assertLess(len(self._win.children), 2)
        group2 = root.ids.group2
        group1 = root.ids.group1
        self.move_frames(5)

        # no DropDown present yet
        self.check_dropdown(present=False)
        self.assertFalse(group2.is_open)
        self.assertFalse(group1.is_open)

        items = ((group2, group1), (group1, group2))
        for item in items:
            active, passive = item
            # click on active Group
            TouchPoint(*active.center)

            # active Group DropDown shows up
            self.check_dropdown(present=True)
            gdd = WeakProxy(self._win.children[0])

            # active Group DropDown == value in WeakProxy
            self.assertIn(gdd, self._win.children)
            self.assertEqual(gdd, self._win.children[0])
            self.assertTrue(active.is_open)
            self.assertFalse(passive.is_open)

            # click away
            TouchPoint(0, 0)

            # wait for closed Group DropDown to disappear
            # go to the next frame after the DropDown disappeared
            sleep(gdd.min_state_time)
            self.move_frames(1)

            # no DropDown is open
            self.assertNotEqual(gdd, self._win.children[0])
            self.assertLess(len(self._win.children), 2)
            self.check_dropdown(present=False)
            self.assertFalse(active.is_open)
            self.assertFalse(passive.is_open)
        self._win.remove_widget(root)

</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_uix_actionbar.py" startline="175" endline="243" pcid="581">
    def test_2_switch(self, *args):
        # click on Group 2 to open its DropDown
        # - DropDown shows up
        # then click on Group 1 to open its DropDown
        # - Group 2 DropDown disappears, Group 1 DropDown shows up
        # click away
        # - no DropDown is opened
        self._win = EventLoop.window
        self.clean_garbage()
        root = Builder.load_string(KV)
        self.render(root)
        self.assertLess(len(self._win.children), 2)
        group2 = root.ids.group2
        group1 = root.ids.group1
        self.move_frames(5)

        # no DropDown present yet
        self.check_dropdown(present=False)
        self.assertFalse(group2.is_open)
        self.assertFalse(group1.is_open)

        # click on Group 2
        TouchPoint(*group2.center)

        # Group 2 DropDown shows up
        self.check_dropdown(present=True)
        g2dd = WeakProxy(self._win.children[0])

        # Group 2 DropDown == value in WeakProxy
        self.assertIn(g2dd, self._win.children)
        self.assertEqual(g2dd, self._win.children[0])
        self.assertTrue(group2.is_open)
        self.assertFalse(group1.is_open)

        # click away from ActionBar and wait for it to disappear
        TouchPoint(0, 0)
        sleep(g2dd.min_state_time)
        self.move_frames(1)

        # click on Group 1
        TouchPoint(*group1.center)

        # wait for closed Group 2 DropDown to disappear
        # and for Group 1 DropDown to appear (there are 2 DDs now)
        # go to the next frame after the DropDown disappeared
        sleep(g2dd.min_state_time)
        self.move_frames(1)

        # Group 1 DropDown != value in WeakProxy (Group 2 DD)
        self.assertNotEqual(g2dd, self._win.children[0])
        self.assertFalse(group2.is_open)
        self.assertTrue(group1.is_open)
        self.check_dropdown(present=True)

        # click away from ActionBar
        TouchPoint(0, 0)

        # wait for closed Group DropDown to disappear
        # go to the next frame after the DropDown disappeared
        sleep(g2dd.min_state_time)
        self.move_frames(1)

        # no DropDown present in Window
        self.check_dropdown(present=False)
        self.assertFalse(group2.is_open)
        self.assertFalse(group1.is_open)
        self.assertNotIn(g2dd, self._win.children)
        self._win.remove_widget(root)

</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_uix_actionbar.py" startline="308" endline="360" pcid="583">
    def test_4_openmulti(self, *args):
        # click on Group to open its DropDown
        # - DropDown shows up
        # then click on Group DropDown button
        # - DropDown disappears
        # repeat
        self._win = EventLoop.window
        self.clean_garbage()
        root = Builder.load_string(KV)
        self.render(root)
        self.assertLess(len(self._win.children), 2)
        group2 = root.ids.group2
        group2button = root.ids.group2button
        group1 = root.ids.group1
        group1button = root.ids.group1button
        self.move_frames(5)

        # no DropDown present yet
        self.check_dropdown(present=False)
        self.assertFalse(group2.is_open)

        items = ((group2, group2button), (group1, group1button))
        for item in items:
            group, button = item

            for _ in range(5):
                # click on Group
                TouchPoint(*group.center)

                # Group DropDown shows up
                self.check_dropdown(present=True)
                gdd = WeakProxy(self._win.children[0])

                # Group DropDown == value in WeakProxy
                self.assertIn(gdd, self._win.children)
                self.assertEqual(gdd, self._win.children[0])
                self.assertTrue(group.is_open)

                # click on Group DropDown Button
                TouchPoint(*button.to_window(*button.center))

                # wait for closed Group DropDown to disappear
                # go to the next frame after the DropDown disappeared
                sleep(gdd.min_state_time)
                self.move_frames(1)

                # no DropDown is open
                self.assertNotEqual(gdd, self._win.children[0])
                self.assertFalse(group.is_open)
                self.check_dropdown(present=False)
        self._win.remove_widget(root)


</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_uix_actionbar.py" startline="244" endline="307" pcid="582">
    def test_3_openpress(self, *args):
        # click on Group 2 to open its DropDown
        # - DropDown shows up
        # then click on Group 2 DropDown button
        # - DropDown disappears
        # click on Group 1 to open its DropDown
        # - DropDown shows up
        # then click on Group 1 DropDown button
        # - DropDown disappears
        self._win = EventLoop.window
        self.clean_garbage()
        root = Builder.load_string(KV)
        self.render(root)
        self.assertLess(len(self._win.children), 2)
        group2 = root.ids.group2
        group2button = root.ids.group2button
        group1 = root.ids.group1
        group1button = root.ids.group1button
        self.move_frames(5)

        # no DropDown present yet
        self.check_dropdown(present=False)
        self.assertFalse(group2.is_open)
        self.assertFalse(group1.is_open)

        items = (
            (group2, group1, group2button),
            (group1, group2, group1button)
        )
        for item in items:
            active, passive, button = item

            # click on active Group
            TouchPoint(*active.center)

            # active Group DropDown shows up
            self.check_dropdown(present=True)
            gdd = WeakProxy(self._win.children[0])

            # active Group DropDown == value in WeakProxy
            self.assertIn(gdd, self._win.children)
            self.assertEqual(gdd, self._win.children[0])
            self.assertTrue(active.is_open)
            self.assertFalse(passive.is_open)

            # click on active Group DropDown Button (needed to_window)
            TouchPoint(*button.to_window(*button.center))
            self.assertTrue(getattr(
                root, active.text[0::6] + 'button'
            ))

            # wait for closed Group DropDown to disappear
            # go to the next frame after the DropDown disappeared
            sleep(gdd.min_state_time)
            self.move_frames(1)

            # no DropDown is open
            self.assertNotEqual(gdd, self._win.children[0])
            self.assertLess(len(self._win.children), 2)
            self.assertFalse(active.is_open)
            self.assertFalse(passive.is_open)
            self.check_dropdown(present=False)
        self._win.remove_widget(root)

</source>
</class>

<class classid="11" nclones="6" nlines="16" similarity="73">
<source file="systems/kivy-2.1.0/kivy/tests/test_uix_scrollview.py" startline="149" endline="169" pcid="592">
    def test_scrollbar_horizontal(self):
        EventLoop.ensure_window()
        win = EventLoop.window
        grid = _TestGrid()
        scroll = _TestScrollbarHorizontal()
        scroll.add_widget(grid)
        win.add_widget(scroll)

        # get widgets ready
        EventLoop.idle()

        left, right = scroll.to_window(scroll.x, scroll.right)
        bottom, top = scroll.to_window(scroll.y, scroll.top)

        points = [
            [left, bottom, right, bottom, 'bottom', 'right', False],
            [left, top, right, top, 'top', 'right', False]
        ]
        self.process_points(scroll, points)
        self.render(scroll)

</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_uix_scrollview.py" startline="191" endline="213" pcid="594">
    def test_scrollbar_both(self):
        EventLoop.ensure_window()
        win = EventLoop.window
        grid = _TestGrid()
        scroll = _TestScrollbarBoth()
        scroll.add_widget(grid)
        win.add_widget(scroll)

        # get widgets ready
        EventLoop.idle()

        left, right = scroll.to_window(scroll.x, scroll.right)
        bottom, top = scroll.to_window(scroll.y, scroll.top)

        points = [
            [left, bottom, right, bottom, 'bottom', 'right', False],
            [left, top, right, top, 'top', 'right', False],
            [right, top, right, bottom, 'bottom', 'right', False],
            [left, top, left, bottom, 'bottom', 'left', False]
        ]
        self.process_points(scroll, points)
        self.render(scroll)

</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_uix_scrollview.py" startline="214" endline="239" pcid="595">
    def test_scrollbar_horizontal_margin(self):
        EventLoop.ensure_window()
        win = EventLoop.window
        grid = _TestGrid()
        scroll = _TestScrollbarHorizontalMargin()
        margin = scroll.bar_margin
        scroll.add_widget(grid)
        win.add_widget(scroll)

        # get widgets ready
        EventLoop.idle()

        left, right = scroll.to_window(scroll.x, scroll.right)
        bottom, top = scroll.to_window(scroll.y, scroll.top)

        # touch in the half of the bar
        m = margin + scroll.bar_width / 2.0
        points = [
            [left, bottom + m, right, bottom + m, 'bottom', 'right', False],
            [left, top - m, right, top - m, 'top', 'right', False],
            [left, bottom, right, bottom, 'bottom', 'right', True],
            [left, top, right, top, 'top', 'right', True]
        ]
        self.process_points(scroll, points)
        self.render(scroll)

</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_uix_scrollview.py" startline="240" endline="265" pcid="596">
    def test_scrollbar_vertical_margin(self):
        EventLoop.ensure_window()
        win = EventLoop.window
        grid = _TestGrid()
        scroll = _TestScrollbarVerticalMargin()
        margin = scroll.bar_margin
        scroll.add_widget(grid)
        win.add_widget(scroll)

        # get widgets ready
        EventLoop.idle()

        left, right = scroll.to_window(scroll.x, scroll.right)
        bottom, top = scroll.to_window(scroll.y, scroll.top)

        # touch in the half of the bar
        m = margin + scroll.bar_width / 2.0
        points = [
            [right - m, top, right - m, bottom, 'bottom', 'right', False],
            [left + m, top, left + m, bottom, 'bottom', 'left', False],
            [right, top, right, bottom, 'bottom', 'right', True],
            [left, top, left, bottom, 'bottom', 'left', True]
        ]
        self.process_points(scroll, points)
        self.render(scroll)

</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_uix_scrollview.py" startline="170" endline="190" pcid="593">
    def test_scrollbar_vertical(self):
        EventLoop.ensure_window()
        win = EventLoop.window
        grid = _TestGrid()
        scroll = _TestScrollbarVertical()
        scroll.add_widget(grid)
        win.add_widget(scroll)

        # get widgets ready
        EventLoop.idle()

        left, right = scroll.to_window(scroll.x, scroll.right)
        bottom, top = scroll.to_window(scroll.y, scroll.top)

        points = [
            [right, top, right, bottom, 'bottom', 'right', False],
            [left, top, left, bottom, 'bottom', 'left', False]
        ]
        self.process_points(scroll, points)
        self.render(scroll)

</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_uix_scrollview.py" startline="266" endline="295" pcid="597">
    def test_scrollbar_both_margin(self):
        EventLoop.ensure_window()
        win = EventLoop.window
        grid = _TestGrid()
        scroll = _TestScrollbarBothMargin()
        margin = scroll.bar_margin
        scroll.add_widget(grid)
        win.add_widget(scroll)

        # get widgets ready
        EventLoop.idle()

        left, right = scroll.to_window(scroll.x, scroll.right)
        bottom, top = scroll.to_window(scroll.y, scroll.top)

        # touch in the half of the bar
        m = margin + scroll.bar_width / 2.0
        points = [
            [left, bottom + m, right, bottom + m, 'bottom', 'right', False],
            [left, top - m, right, top - m, 'top', 'right', False],
            [right - m, top, right - m, bottom, 'bottom', 'right', False],
            [left + m, top, left + m, bottom, 'bottom', 'left', False],
            [left, bottom, right, bottom, 'bottom', 'right', True],
            [left, top, right, top, 'top', 'right', True],
            [right, top, right, bottom, 'bottom', 'right', True],
            [left, top, left, bottom, 'bottom', 'left', True]
        ]
        self.process_points(scroll, points)
        self.render(scroll)

</source>
</class>

<class classid="12" nclones="2" nlines="11" similarity="81">
<source file="systems/kivy-2.1.0/kivy/tests/test_audio.py" startline="34" endline="45" pcid="617">
    def test_length_playing(self):
        import time
        sound = self.get_sound()
        sound.play()
        try:
            time.sleep(DELAY)
            length = sound.length
            self.assertAlmostEqual(SAMPLE_LENGTH, length, delta=DELTA)
        finally:
            sound.stop()
        self.assertAlmostEqual(SAMPLE_LENGTH, length, delta=DELTA)

</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_audio.py" startline="46" endline="57" pcid="618">
    def test_length_stopped(self):
        import time
        sound = self.get_sound()
        sound.play()
        try:
            time.sleep(DELAY)
        finally:
            sound.stop()
        length = sound.length
        self.assertAlmostEqual(SAMPLE_LENGTH, length, delta=DELTA)


</source>
</class>

<class classid="13" nclones="2" nlines="25" similarity="92">
<source file="systems/kivy-2.1.0/kivy/tests/test_module_inspector.py" startline="75" endline="113" pcid="624">
    def test_activate_deactivate_bottom(self, *args):
        EventLoop.ensure_window()
        self._win = EventLoop.window

        self.clean_garbage()

        # build the widget tree & add Window as the main EL
        self.root = self.builder.Builder.load_string(
            KV, filename="InspectorTestCase.KV")
        self.render(self.root)
        self.assertLess(len(self._win.children), 2)

        # activate inspector with root as ctx
        inspector.start(self._win, self.root)
        self.advance_frames(2)

        # pull the Inspector drawer from bottom
        ins = self.root.inspector
        ins.activated = True
        ins.inspect_enabled = True
        self.assertTrue(ins.at_bottom)

        # by default is Inspector appended as the first child
        # to the window and positioned at the bottom
        self.assertEqual(self._win.children[0], ins)
        self.advance_frames(1)
        self.assertLess(ins.layout.pos[1], self._win.height / 2.0)

        # close Inspector
        ins.inspect_enabled = False
        ins.activated = False
        self.render(self.root)
        self.advance_frames(1)

        # stop Inspector completely
        inspector.stop(self._win, self.root)
        self.assertLess(len(self._win.children), 2)
        self.render(self.root)

</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_module_inspector.py" startline="114" endline="154" pcid="625">
    def test_activate_deactivate_top(self, *args):
        EventLoop.ensure_window()
        self._win = EventLoop.window

        self.clean_garbage()

        # build the widget tree & add Window as the main EL
        self.root = self.builder.Builder.load_string(
            KV, filename="InspectorTestCase.KV")
        self.render(self.root)
        self.assertLess(len(self._win.children), 2)

        # activate inspector with root as ctx
        inspector.start(self._win, self.root)
        self.advance_frames(2)

        # pull the Inspector drawer from top
        ins = self.root.inspector
        ins.at_bottom = False
        ins.activated = True
        ins.inspect_enabled = True
        self.assertFalse(ins.at_bottom)

        # by default is Inspector appended as the first child
        # to the window & we move it to the top
        self.assertEqual(self._win.children[0], ins)
        ins.toggle_position(self.root.ids.dummy)
        self.advance_frames(20)  # drawer is moving, like with activate
        self.assertGreater(ins.layout.pos[1], self._win.height / 2.0)

        # close Inspector
        ins.inspect_enabled = False
        ins.activated = False
        self.render(self.root)
        self.advance_frames(1)

        # stop Inspector completely
        inspector.stop(self._win, self.root)
        self.assertLess(len(self._win.children), 2)
        self.render(self.root)

</source>
</class>

<class classid="14" nclones="3" nlines="46" similarity="70">
<source file="systems/kivy-2.1.0/kivy/tests/test_module_inspector.py" startline="155" endline="214" pcid="626">
    def test_widget_button(self, *args):
        EventLoop.ensure_window()
        self._win = EventLoop.window

        self.clean_garbage()

        # build the widget tree & add Window as the main EL
        self.root = self.builder.Builder.load_string(
            KV, filename="InspectorTestCase.KV")
        self.render(self.root)
        self.assertLess(len(self._win.children), 2)

        # checked widget
        highlight = self.root.ids.highlight
        highlight_exp = self.root.ids.highlight.text

        # activate inspector with root as ctx
        inspector.start(self._win, self.root)
        self.advance_frames(2)

        # pull the Inspector drawer from bottom
        ins = self.root.inspector
        ins.activated = True
        ins.inspect_enabled = True
        self.assertTrue(ins.at_bottom)

        # touch button center
        touch = UnitTestTouch(*highlight.center)
        touch.touch_down()
        touch.touch_up()

        # open Inspector properties
        ins.show_widget_info()
        self.advance_frames(2)

        # check if the button is selected
        # stored instance
        self.assertEqual(ins.widget.text, highlight_exp)
        # data in properties
        for node in ins.treeview.iterate_all_nodes():
            lkey = getattr(node.ids, 'lkey', None)
            if not lkey:
                continue
            if lkey.text == 'text':
                ltext = node.ids.ltext
                # slice because the string is displayed with quotes
                self.assertEqual(ltext.text[1:-1], highlight_exp)
                break

        # close Inspector
        ins.inspect_enabled = False
        ins.activated = False
        self.render(self.root)
        self.advance_frames(1)

        # stop Inspector completely
        inspector.stop(self._win, self.root)
        self.assertLess(len(self._win.children), 2)
        self.render(self.root)

</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_module_inspector.py" startline="215" endline="296" pcid="627">
    def test_widget_popup(self, *args):
        EventLoop.ensure_window()
        self._win = EventLoop.window

        self.clean_garbage()

        # build the widget tree & add Window as the main EL
        self.root = self.builder.Builder.load_string(
            KV, filename="InspectorTestCase.KV")
        self.render(self.root)
        self.assertLess(len(self._win.children), 2)

        # checked widget
        popup = self.root.ids.popup

        # activate inspector with root as ctx
        inspector.start(self._win, self.root)
        self.advance_frames(1)

        # pull the Inspector drawer from bottom,
        # but don't inspect yet!
        ins = self.root.inspector
        ins.inspect_enabled = False
        ins.activated = True
        self.assertTrue(ins.at_bottom)

        # touch button center to open the popup
        touch = UnitTestTouch(*popup.center)
        touch.touch_down()
        touch.touch_up()
        self.advance_frames(1)

        # start inspecting
        ins.inspect_enabled = True
        self.advance_frames(1)

        # inspect FirstModal's button
        touch.touch_down()
        touch.touch_up()
        self.advance_frames(1)

        # open Inspector properties
        ins.show_widget_info()
        self.advance_frames(2)

        # check if the popup is selected
        # stored instance
        self.assertIsInstance(ins.widget, Factory.Button)
        self.assertIsInstance(ins.widget.parent, Factory.FirstModal)
        # check with new Popup instance if the properties match
        temp_popup = Factory.FirstModal()
        temp_popup_exp = temp_popup.ids.firstmodal.text
        self.assertEqual(ins.widget.text, temp_popup_exp)
        # data in properties
        for node in ins.treeview.iterate_all_nodes():
            lkey = getattr(node.ids, 'lkey', None)
            if not lkey:
                continue
            if lkey.text == 'text':
                ltext = node.ids.ltext
                # slice because the string is displayed with quotes
                self.assertEqual(ltext.text[1:-1], temp_popup_exp)
                break
        del temp_popup

        # close popup
        ins.inspect_enabled = False
        touch = UnitTestTouch(0, 0)
        touch.touch_down()
        touch.touch_up()
        self.advance_frames(10)

        # close Inspector
        ins.activated = False
        self.render(self.root)
        self.advance_frames(5)

        # stop Inspector completely
        inspector.stop(self._win, self.root)
        self.assertLess(len(self._win.children), 2)
        self.render(self.root)

</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_module_inspector.py" startline="298" endline="379" pcid="628">
    def test_widget_multipopup(self, *args):
        EventLoop.ensure_window()
        self._win = EventLoop.window

        self.clean_garbage()

        # build the widget tree & add Window as the main EL
        self.root = self.builder.Builder.load_string(
            KV, filename="InspectorTestCase.KV")
        self.render(self.root)
        self.assertLess(len(self._win.children), 2)

        # checked widget
        popup = self.root.ids.popup

        # activate inspector with root as ctx
        inspector.start(self._win, self.root)
        self.advance_frames(1)

        # pull the Inspector drawer from bottom,
        # but don't inspect yet!
        ins = self.root.inspector
        ins.inspect_enabled = False
        ins.activated = True
        self.assertTrue(ins.at_bottom)

        # touch button center to open the popup
        touch = UnitTestTouch(*popup.center)
        touch.touch_down()
        touch.touch_up()
        self.advance_frames(1)

        # touch Window center to open
        # the second and the third popup
        touch = UnitTestTouch(
            self._win.width / 2.0,
            self._win.height / 2.0
        )
        for i in range(2):
            touch.touch_down()
            touch.touch_up()
            self.advance_frames(1)

        # fixed order, first opened - last closed
        modals = [
            Factory.ThirdModal,
            Factory.SecondModal,
            Factory.FirstModal
        ]
        for mod in modals:
            # start inspecting
            ins.inspect_enabled = True
            self.advance_frames(1)

            # inspect button
            touch.touch_down()
            touch.touch_up()
            self.advance_frames(1)

            # check if the popup is selected
            # stored instance
            self.assertIsInstance(ins.widget, Factory.Button)
            self.assertIsInstance(ins.widget.parent, mod)

            # close popup
            ins.inspect_enabled = False
            orig = UnitTestTouch(0, 0)
            orig.touch_down()
            orig.touch_up()
            self.advance_frames(10)

        # close Inspector
        ins.activated = False
        self.render(self.root)
        self.advance_frames(5)

        # stop Inspector completely
        inspector.stop(self._win, self.root)
        self.assertLess(len(self._win.children), 2)
        self.render(self.root)


</source>
</class>

<class classid="15" nclones="2" nlines="12" similarity="91">
<source file="systems/kivy-2.1.0/kivy/tests/test_uix_boxlayout.py" startline="14" endline="27" pcid="629">
    def box(self, r, g, b):
        from kivy.uix.widget import Widget
        from kivy.graphics import Color, Rectangle
        wid = Widget()
        with wid.canvas:
            Color(r, g, b)
            r = Rectangle(pos=wid.pos, size=wid.size)

        def linksp(instance, *largs):
            r.pos = instance.pos
            r.size = instance.size
        wid.bind(pos=linksp, size=linksp)
        return wid

</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_uix_anchorlayout.py" startline="11" endline="24" pcid="650">
    def box(self, r, g, b):
        from kivy.uix.widget import Widget
        from kivy.graphics import Color, Rectangle
        wid = Widget(size_hint=(None, None), size=(100, 100))
        with wid.canvas:
            Color(r, g, b)
            r = Rectangle(pos=wid.pos, size=wid.size)

        def linksp(instance, *largs):
            r.pos = instance.pos
            r.size = instance.size
        wid.bind(pos=linksp, size=linksp)
        return wid

</source>
</class>

<class classid="16" nclones="6" nlines="14" similarity="71">
<source file="systems/kivy-2.1.0/kivy/tests/test_uix_boxlayout.py" startline="28" endline="44" pcid="631">
    def test_boxlayout_orientation(self):
        from kivy.uix.boxlayout import BoxLayout
        r = self.render
        b = self.box

        layout = BoxLayout()
        layout.add_widget(b(1, 0, 0))
        layout.add_widget(b(0, 1, 0))
        layout.add_widget(b(0, 0, 1))
        r(layout)

        layout = BoxLayout(orientation='vertical')
        layout.add_widget(b(1, 0, 0))
        layout.add_widget(b(0, 1, 0))
        layout.add_widget(b(0, 0, 1))
        r(layout)

</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_uix_anchorlayout.py" startline="51" endline="67" pcid="654">
    def test_anchorlayout_y(self):
        from kivy.uix.anchorlayout import AnchorLayout
        r = self.render
        b = self.box

        layout = AnchorLayout(anchor_y='bottom')
        layout.add_widget(b(1, 0, 0))
        r(layout)

        layout = AnchorLayout(anchor_y='center')
        layout.add_widget(b(1, 0, 0))
        r(layout)

        layout = AnchorLayout(anchor_y='top')
        layout.add_widget(b(1, 0, 0))
        r(layout)

</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_uix_boxlayout.py" startline="79" endline="94" pcid="634">
    def test_boxlayout_padding_spacing(self):
        from kivy.uix.boxlayout import BoxLayout
        r = self.render
        b = self.box

        layout = BoxLayout(spacing=20, padding=20)
        layout.add_widget(b(1, 0, 0))
        layout.add_widget(b(0, 1, 0))
        layout.add_widget(b(0, 0, 1))
        r(layout)

        layout = BoxLayout(spacing=20, padding=20, orientation='vertical')
        layout.add_widget(b(1, 0, 0))
        layout.add_widget(b(0, 1, 0))
        layout.add_widget(b(0, 0, 1))
        r(layout)
</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_uix_anchorlayout.py" startline="34" endline="50" pcid="653">
    def test_anchorlayout_x(self):
        from kivy.uix.anchorlayout import AnchorLayout
        r = self.render
        b = self.box

        layout = AnchorLayout(anchor_x='left')
        layout.add_widget(b(1, 0, 0))
        r(layout)

        layout = AnchorLayout(anchor_x='center')
        layout.add_widget(b(1, 0, 0))
        r(layout)

        layout = AnchorLayout(anchor_x='right')
        layout.add_widget(b(1, 0, 0))
        r(layout)

</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_uix_boxlayout.py" startline="62" endline="78" pcid="633">
    def test_boxlayout_padding(self):
        from kivy.uix.boxlayout import BoxLayout
        r = self.render
        b = self.box

        layout = BoxLayout(padding=20)
        layout.add_widget(b(1, 0, 0))
        layout.add_widget(b(0, 1, 0))
        layout.add_widget(b(0, 0, 1))
        r(layout)

        layout = BoxLayout(padding=20, orientation='vertical')
        layout.add_widget(b(1, 0, 0))
        layout.add_widget(b(0, 1, 0))
        layout.add_widget(b(0, 0, 1))
        r(layout)

</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_uix_boxlayout.py" startline="45" endline="61" pcid="632">
    def test_boxlayout_spacing(self):
        from kivy.uix.boxlayout import BoxLayout
        r = self.render
        b = self.box

        layout = BoxLayout(spacing=20)
        layout.add_widget(b(1, 0, 0))
        layout.add_widget(b(0, 1, 0))
        layout.add_widget(b(0, 0, 1))
        r(layout)

        layout = BoxLayout(spacing=20, orientation='vertical')
        layout.add_widget(b(1, 0, 0))
        layout.add_widget(b(0, 1, 0))
        layout.add_widget(b(0, 0, 1))
        r(layout)

</source>
</class>

<class classid="17" nclones="2" nlines="32" similarity="71">
<source file="systems/kivy-2.1.0/kivy/tests/perf_test_textinput.py" startline="73" endline="105" pcid="642">
    def stress_del(self, *largs):
        self.test_done = False
        text_input = self.text_input
        self.lt = len_text = len(text_input.text)
        target = len_text - (210 * 9)
        self.tot_time = 0
        ev = None

        def dlt(*l):
            if len(text_input.text) <= target:
                ev.cancel()
                print('Done!')
                m_len = len(text_input._lines)
                print('deleted 210 characters 9 times')
                import resource
                print('mem usage after test')
                print(resource.getrusage(resource.RUSAGE_SELF).ru_maxrss /
                    1024, 'MB')
                print('total lines in text input:', m_len)
                print('--------------------------------------')
                print('total time elapsed:', self.tot_time)
                print('--------------------------------------')
                self.test_done = True
                return
            text_input.select_text(self.lt - 220, self.lt - 10)
            text_input.delete_selection()
            self.lt -= 210
            text_input.scroll_y -= 100
            self.tot_time += l[0]
            ev()
        ev = Clock.create_trigger(dlt)
        ev()

</source>
<source file="systems/kivy-2.1.0/kivy/tests/perf_test_textinput.py" startline="106" endline="139" pcid="644">
    def stress_insert(self, *largs):
        self.test_done = False
        text_input = self.text_input
        text_input.select_all()
        text_input.copy(text_input.selection_text)
        text_input.cursor = text_input.get_cursor_from_index(
            text_input.selection_to)
        len_text = len(text_input._lines)
        self.tot_time = 0
        ev = None

        def pste(*l):
            if len(text_input._lines) >= (len_text) * 9:
                ev.cancel()
                print('Done!')
                m_len = len(text_input._lines)
                print('pasted', len_text, 'lines',
                    round((m_len - len_text) / len_text), 'times')
                import resource
                print('mem usage after test')
                print(resource.getrusage(resource.RUSAGE_SELF).ru_maxrss /
                    1024, 'MB')
                print('total lines in text input:', m_len)
                print('--------------------------------------')
                print('total time elapsed:', self.tot_time)
                print('--------------------------------------')
                self.test_done = True
                return
            self.tot_time += l[0]
            text_input.paste()
            ev()
        ev = Clock.create_trigger(pste)
        ev()

</source>
</class>

<class classid="18" nclones="2" nlines="12" similarity="83">
<source file="systems/kivy-2.1.0/kivy/tests/test_mouse_hover_event.py" startline="189" endline="204" pcid="708">
    def test_with_full_cycle_with_cursor_events(self):
        win, mouse = self.get_providers()
        # Test begin event
        win.dispatch('on_cursor_enter')
        x, y = win.mouse_pos
        self.advance_frames(1)
        self.assert_event('begin', win.to_normalized_pos(x, y))
        # Test update event
        x, y = win.mouse_pos = (10.0, 10.0)
        self.advance_frames(1)
        self.assert_event('update', win.to_normalized_pos(x, y))
        # Test end event
        win.dispatch('on_cursor_leave')
        self.advance_frames(1)
        self.assert_event('end', win.to_normalized_pos(x, y))

</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_mouse_hover_event.py" startline="205" endline="219" pcid="709">
    def test_with_full_cycle_with_mouse_pos_and_on_close_event(self):
        win, mouse = self.get_providers()
        # Test begin event
        x, y = win.mouse_pos = (5.0, 5.0)
        self.advance_frames(1)
        self.assert_event('begin', win.to_normalized_pos(x, y))
        # Test update event
        x, y = win.mouse_pos = (10.0, 10.0)
        self.advance_frames(1)
        self.assert_event('update', win.to_normalized_pos(x, y))
        # Test end event
        win.dispatch('on_close')
        self.advance_frames(1)
        self.assert_event('end', win.to_normalized_pos(x, y))

</source>
</class>

<class classid="19" nclones="2" nlines="14" similarity="92">
<source file="systems/kivy-2.1.0/kivy/tests/test_multistroke.py" startline="353" endline="369" pcid="759">
    def test_protractor_invariant(self):
        gdb = Recognizer(db=[self.Tinvar, self.Ninvar])
        r = gdb.recognize([NGesture], orientation_sensitive=False,
            max_gpf=0)
        self.assertEqual(r.best['name'], 'N')
        self.assertTrue(r.best['score'] == 1.0)

        r = gdb.recognize([NGesture], orientation_sensitive=True,
            max_gpf=0)
        self.assertEqual(r.best['name'], None)
        self.assertEqual(r.best['score'], 0)

        r = gdb.recognize([Ncandidate], orientation_sensitive=False,
            max_gpf=0)
        self.assertEqual(r.best['name'], 'N')
        self.assertTrue(r.best['score'] > 0.94 and r.best['score'] < 0.95)

</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_multistroke.py" startline="370" endline="387" pcid="760">
    def test_protractor_bound(self):
        gdb = Recognizer(db=[self.Tbound, self.Nbound])
        r = gdb.recognize([NGesture], orientation_sensitive=True,
            max_gpf=0)
        self.assertEqual(r.best['name'], 'N')
        self.assertTrue(r.best['score'] >= 0.99)

        r = gdb.recognize([NGesture], orientation_sensitive=False,
            max_gpf=0)
        self.assertEqual(r.best['name'], None)
        self.assertEqual(r.best['score'], 0)

        r = gdb.recognize([Ncandidate], orientation_sensitive=True,
            max_gpf=0)
        self.assertEqual(r.best['name'], 'N')
        self.assertTrue(r.best['score'] > 0.94 and r.best['score'] < 0.95)


</source>
</class>

<class classid="20" nclones="5" nlines="12" similarity="71">
<source file="systems/kivy-2.1.0/kivy/tests/test_properties.py" startline="29" endline="45" pcid="768">
def test_base(self, set_name):
    from kivy.properties import Property

    a = Property(-1)
    if set_name:
        a.set_name(wid, 'a')
        a.link_eagerly(wid)
    else:
        a.link(wid, 'a')
        a.link_deps(wid, 'a')
    self.assertEqual(a.get(wid), -1)
    a.set(wid, 0)
    self.assertEqual(a.get(wid), 0)
    a.set(wid, 1)
    self.assertEqual(a.get(wid), 1)


</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_properties.py" startline="117" endline="137" pcid="773">
def test_numericcheck(self, set_name):
    from kivy.properties import NumericProperty

    a = NumericProperty()
    if set_name:
        a.set_name(wid, 'a')
        a.link_eagerly(wid)
    else:
        a.link(wid, 'a')
        a.link_deps(wid, 'a')
    self.assertEqual(a.get(wid), 0)
    a.set(wid, 99)
    self.assertEqual(a.get(wid), 99)

    # try:
    #    a.set(wid, '')  # string shouldn't be accepted
    #    self.fail('number accept string, fail.')
    # except ValueError:
    #    pass


</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_properties.py" startline="435" endline="450" pcid="786">
def test_numeric_string_without_units(self, set_name):
    from kivy.properties import NumericProperty

    a = NumericProperty()
    if set_name:
        a.set_name(wid, 'a')
        a.link_eagerly(wid)
    else:
        a.link(wid, 'a')
        a.link_deps(wid, 'a')
    self.assertEqual(a.get(wid), 0)

    a.set(wid, '2')
    self.assertEqual(a.get(wid), 2)


</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_properties.py" startline="155" endline="169" pcid="775">
def test_dictcheck(self, set_name):
    from kivy.properties import DictProperty

    a = DictProperty()
    if set_name:
        a.set_name(wid, 'a')
        a.link_eagerly(wid)
    else:
        a.link(wid, 'a')
        a.link_deps(wid, 'a')
    self.assertEqual(a.get(wid), {})
    a.set(wid, {'foo': 'bar'})
    self.assertEqual(a.get(wid), {'foo': 'bar'})


</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_properties.py" startline="139" endline="153" pcid="774">
def test_listcheck(self, set_name):
    from kivy.properties import ListProperty

    a = ListProperty()
    if set_name:
        a.set_name(wid, 'a')
        a.link_eagerly(wid)
    else:
        a.link(wid, 'a')
        a.link_deps(wid, 'a')
    self.assertEqual(a.get(wid), [])
    a.set(wid, [1, 2, 3])
    self.assertEqual(a.get(wid), [1, 2, 3])


</source>
</class>

<class classid="21" nclones="2" nlines="20" similarity="80">
<source file="systems/kivy-2.1.0/kivy/tests/test_properties.py" startline="344" endline="370" pcid="783">
def test_bounded_numeric_property_error_value(self, set_name):
    from kivy.properties import BoundedNumericProperty

    bnp = BoundedNumericProperty(0, min=-5, max=5, errorvalue=1)
    if set_name:
        bnp.set_name(wid, 'bnp')
        bnp.link_eagerly(wid)
    else:
        bnp.link(wid, 'bnp')
        bnp.link_deps(wid, 'bnp')

    bnp.set(wid, 1)
    self.assertEqual(bnp.get(wid), 1)

    bnp.set(wid, 5)
    self.assertEqual(bnp.get(wid), 5)

    bnp.set(wid, 6)
    self.assertEqual(bnp.get(wid), 1)

    bnp.set(wid, -5)
    self.assertEqual(bnp.get(wid), -5)

    bnp.set(wid, -6)
    self.assertEqual(bnp.get(wid), 1)


</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_properties.py" startline="372" endline="401" pcid="784">
def test_bounded_numeric_property_error_handler(self, set_name):
    from kivy.properties import BoundedNumericProperty

    bnp = BoundedNumericProperty(
        0, min=-5, max=5,
        errorhandler=lambda x: 5 if x > 5 else -5)

    if set_name:
        bnp.set_name(wid, 'bnp')
        bnp.link_eagerly(wid)
    else:
        bnp.link(wid, 'bnp')
        bnp.link_deps(wid, 'bnp')

    bnp.set(wid, 1)
    self.assertEqual(bnp.get(wid), 1)

    bnp.set(wid, 5)
    self.assertEqual(bnp.get(wid), 5)

    bnp.set(wid, 10)
    self.assertEqual(bnp.get(wid), 5)

    bnp.set(wid, -5)
    self.assertEqual(bnp.get(wid), -5)

    bnp.set(wid, -10)
    self.assertEqual(bnp.get(wid), -5)


</source>
</class>

<class classid="22" nclones="3" nlines="34" similarity="73">
<source file="systems/kivy-2.1.0/kivy/tests/test_properties.py" startline="641" endline="691" pcid="794">
def test_alias_property(self, watch_before_use):
    from kivy.properties import AliasProperty

    class CustomAlias(EventDispatcher):

        def _get_prop(self):
            self.getter_called += 1

        def _set_prop(self, value):
            self.setter_called += 1

        prop = AliasProperty(
            _get_prop, _set_prop, watch_before_use=watch_before_use)

        def __init__(self, **kwargs):
            super(CustomAlias, self).__init__(**kwargs)
            self.getter_called = 0
            self.setter_called = 0
            self.callback_called = 0

    def callback(widget, value):
        widget.callback_called += 1

    # Initial checks
    wid = CustomAlias()
    wid.bind(prop=callback)
    self.assertEqual(wid.getter_called, 0)
    self.assertEqual(wid.setter_called, 0)
    self.assertEqual(wid.callback_called, 0)

    # Set property, should call setter to set the value
    # Getter and callback should not be called because `_set_prop` doesn't
    # returns True
    wid.prop = 1
    self.assertEqual(wid.getter_called, 0)
    self.assertEqual(wid.setter_called, 1)
    self.assertEqual(wid.callback_called, 0)

    # Set property to same value as before, should only call setter
    wid.prop = 1
    self.assertEqual(wid.getter_called, 0)
    self.assertEqual(wid.setter_called, 2)
    self.assertEqual(wid.callback_called, 0)

    # Get value of the property, should call getter once
    self.assertEqual(wid.prop, None)
    self.assertEqual(wid.getter_called, 1)
    self.assertEqual(wid.setter_called, 2)
    self.assertEqual(wid.callback_called, 0)


</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_properties.py" startline="795" endline="840" pcid="808">
def test_alias_property_with_force_dispatch_true(self, watch_before_use):
    from kivy.properties import AliasProperty

    class CustomAlias(EventDispatcher):

        def _get_prop(self):
            self.getter_called += 1

        def _set_prop(self, value):
            self.setter_called += 1

        prop = AliasProperty(
            _get_prop, _set_prop, force_dispatch=True,
            watch_before_use=watch_before_use)

        def __init__(self, **kwargs):
            super(CustomAlias, self).__init__(**kwargs)
            self.getter_called = 0
            self.setter_called = 0
            self.callback_called = 0

    def callback(widget, value):
        widget.callback_called += 1

    # Initial checks
    wid = CustomAlias()
    wid.bind(prop=callback)
    self.assertEqual(wid.getter_called, 0)
    self.assertEqual(wid.setter_called, 0)
    self.assertEqual(wid.callback_called, 0)

    # Set property, should call setter to set the value and getter to
    # to get the value for dispatch call
    wid.prop = 1
    self.assertEqual(wid.getter_called, 1)
    self.assertEqual(wid.setter_called, 1)
    self.assertEqual(wid.callback_called, 1)

    # Set property to same value as before, setter and getter and callback
    # are called
    wid.prop = 1
    self.assertEqual(wid.getter_called, 2)
    self.assertEqual(wid.setter_called, 2)
    self.assertEqual(wid.callback_called, 2)


</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_properties.py" startline="887" endline="946" pcid="817">
def test_alias_property_cache_true_force_dispatch_true(self, watch_before_use):
    from kivy.properties import AliasProperty

    class CustomAlias(EventDispatcher):

        def _get_prop(self):
            self.getter_called += 1
            return self.base_value * 2

        def _set_prop(self, value):
            self.setter_called += 1
            self.base_value = value / 2
            return True

        prop = AliasProperty(
            _get_prop, _set_prop, cache=True, force_dispatch=True,
            watch_before_use=watch_before_use)

        def __init__(self, **kwargs):
            super(CustomAlias, self).__init__(**kwargs)
            self.base_value = 1
            self.getter_called = 0
            self.setter_called = 0
            self.callback_called = 0

    def callback(widget, value):
        widget.callback_called += 1

    wid = CustomAlias()
    wid.bind(prop=callback)

    # Initial checks
    self.assertEqual(wid.base_value, 1)
    self.assertEqual(wid.getter_called, 0)
    self.assertEqual(wid.setter_called, 0)
    self.assertEqual(wid.callback_called, 0)

    # Set alias property some value, should call setter and then getter to
    # pass the value to callback
    wid.prop = 16
    self.assertEqual(wid.base_value, 8)
    self.assertEqual(wid.getter_called, 1)
    self.assertEqual(wid.setter_called, 1)
    self.assertEqual(wid.callback_called, 1)

    # Same as the step above, should call setter, getter and callback
    wid.prop = 16
    self.assertEqual(wid.base_value, 8)
    self.assertEqual(wid.getter_called, 2)
    self.assertEqual(wid.setter_called, 2)
    self.assertEqual(wid.callback_called, 2)

    # Get the value of property, should use cached value
    value = wid.prop
    self.assertEqual(value, 16)
    self.assertEqual(wid.getter_called, 2)
    self.assertEqual(wid.setter_called, 2)
    self.assertEqual(wid.callback_called, 2)


</source>
</class>

<class classid="23" nclones="2" nlines="11" similarity="90">
<source file="systems/kivy-2.1.0/kivy/tests/test_properties.py" startline="947" endline="961" pcid="822">
def test_dictproperty_is_none():
    from kivy.properties import DictProperty

    d1 = DictProperty(None)
    d1.set_name(wid, 'd1')
    d1.link_eagerly(wid)
    assert d1.get(wid) is None

    d2 = DictProperty({'a': 1, 'b': 2}, allownone=True)
    d2.set_name(wid, 'd2')
    d2.link_eagerly(wid)
    d2.set(wid, None)
    assert d2.get(wid) is None


</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_properties.py" startline="962" endline="976" pcid="823">
def test_listproperty_is_none():
    from kivy.properties import ListProperty

    l1 = ListProperty(None)
    l1.set_name(wid, 'l1')
    l1.link_eagerly(wid)
    assert l1.get(wid) is None

    l2 = ListProperty([1, 2, 3], allownone=True)
    l2.set_name(wid, 'l2')
    l2.link_eagerly(wid)
    l2.set(wid, None)
    assert l2.get(wid) is None


</source>
</class>

<class classid="24" nclones="2" nlines="22" similarity="82">
<source file="systems/kivy-2.1.0/kivy/tests/test_properties.py" startline="1040" endline="1070" pcid="826">
def test_variable_list_property_dp_default(kivy_metrics):
    from kivy.event import EventDispatcher
    from kivy.properties import VariableListProperty
    kivy_metrics.density = 1

    class Number(EventDispatcher):

        a = VariableListProperty(['10dp', (20, 'dp'), 3, 4.0])

    number = Number()
    counter = 0

    def callback(name, *args):
        nonlocal counter
        counter += 1

    number.fbind('a', callback)
    assert list(number.a) == [10, 20, 3, 4]
    assert not counter

    kivy_metrics.density = 2

    assert counter == 1
    assert list(number.a) == [20, 40, 3, 4]

    kivy_metrics.density = 1

    assert counter == 2
    assert list(number.a) == [10, 20, 3, 4]


</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_properties.py" startline="1071" endline="1105" pcid="828">
def test_variable_list_property_dp(kivy_metrics):
    from kivy.event import EventDispatcher
    from kivy.properties import VariableListProperty
    kivy_metrics.density = 1

    class Number(EventDispatcher):

        a = VariableListProperty([0, 20, 3, 4])

    number = Number()
    counter = 0

    def callback(name, *args):
        nonlocal counter
        counter += 1

    number.fbind('a', callback)
    assert list(number.a) == [0, 20, 3, 4]
    assert not counter

    number.a = ['10dp', (20, 'dp'), 3, 4.0]
    assert list(number.a) == [10, 20, 3, 4]
    assert counter == 1

    kivy_metrics.density = 2

    assert counter == 2
    assert list(number.a) == [20, 40, 3, 4]

    kivy_metrics.density = 1

    assert counter == 3
    assert list(number.a) == [10, 20, 3, 4]


</source>
</class>

<class classid="25" nclones="2" nlines="14" similarity="71">
<source file="systems/kivy-2.1.0/kivy/tests/test_properties.py" startline="1282" endline="1302" pcid="843">


def test_known_property_multiple_inheritance():

    class Behavior:
        def __init__(self, name):
            print(f'Behavior: {self}, name={name}')
            super().__init__()

    class Widget2(Behavior, EventDispatcher):
        pass

    class Widget3(EventDispatcher, Behavior):
        pass

    with pytest.raises(TypeError) as cm:
        EventDispatcher(name='Pasta')
    assert "Properties ['name'] passed to __init__ may not be existing" \
           in str(cm.value)

    Widget2(name='Pasta')  # does not raise a ValueError
</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_properties.py" startline="1303" endline="1321" pcid="845">
    Widget3(name='Pasta')  # does not raise a ValueError


def test_pass_other_typeerror():

    class Behavior:
        def __init__(self, name):
            super().__init__()
            raise TypeError("this is a typeerror unrelated to object")

    class Widget2(Behavior, EventDispatcher):
        pass

    class Widget3(EventDispatcher, Behavior):
        pass

    for cls in [Widget2, Widget3]:
        with pytest.raises(TypeError) as cm:
            cls(name='Pasta')
</source>
</class>

<class classid="26" nclones="3" nlines="12" similarity="100">
<source file="systems/kivy-2.1.0/kivy/tests/test_uix_widget.py" startline="41" endline="53" pcid="956">
    def test_add_widget_index_0(self):
        from kivy.uix.widget import Widget
        from kivy.uix.button import Button
        r = self.render
        root = Widget()
        a = Button(text='Hello')
        b = Button(text='World', pos=(50, 10))
        c = Button(text='Kivy', pos=(10, 50))
        root.add_widget(a)
        root.add_widget(b)
        root.add_widget(c, 0)
        r(root)

</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_uix_widget.py" startline="54" endline="66" pcid="957">
    def test_add_widget_index_1(self):
        from kivy.uix.widget import Widget
        from kivy.uix.button import Button
        r = self.render
        root = Widget()
        a = Button(text='Hello')
        b = Button(text='World', pos=(50, 10))
        c = Button(text='Kivy', pos=(10, 50))
        root.add_widget(a)
        root.add_widget(b)
        root.add_widget(c, 1)
        r(root)

</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_uix_widget.py" startline="67" endline="79" pcid="958">
    def test_add_widget_index_2(self):
        from kivy.uix.widget import Widget
        from kivy.uix.button import Button
        r = self.render
        root = Widget()
        a = Button(text='Hello')
        b = Button(text='World', pos=(50, 10))
        c = Button(text='Kivy', pos=(10, 50))
        root.add_widget(a)
        root.add_widget(b)
        root.add_widget(c, 2)
        r(root)

</source>
</class>

<class classid="27" nclones="4" nlines="10" similarity="72">
<source file="systems/kivy-2.1.0/kivy/tests/test_uix_stacklayout.py" startline="18" endline="30" pcid="1036">
    def test_stacklayout_default(self):
        # Default orientation is lr-tb.
        sl = StackLayout()
        wgts = [Widget(size_hint=(.5, .5)) for i in range(4)]
        for wgt in wgts:
            sl.add_widget(wgt)
        sl.do_layout()

        self.assertEqual(wgts[0].pos, [0, sl.height / 2.])
        self.assertEqual(wgts[1].pos, [sl.width / 2., sl.height / 2.])
        self.assertEqual(wgts[2].pos, [0, 0])
        self.assertEqual(wgts[3].pos, [sl.width / 2., 0])

</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_uix_stacklayout.py" startline="31" endline="43" pcid="1037">
    def test_stacklayout_fixed_size(self):
        sl = StackLayout()
        wgts = [Widget(size=(50, 50), size_hint=(None, None))
                for i in range(4)]
        for wgt in wgts:
            sl.add_widget(wgt)
        sl.do_layout()

        self.assertEqual(wgts[0].pos, [0, sl.height / 2.])
        self.assertEqual(wgts[1].pos, [sl.width / 2., sl.height / 2.])
        self.assertEqual(wgts[2].pos, [0, 0])
        self.assertEqual(wgts[3].pos, [sl.width / 2., 0])

</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_uix_stacklayout.py" startline="44" endline="57" pcid="1038">
    def test_stacklayout_orientation_btrl(self):
        # Default orientation is lr-tb.
        sl = StackLayout()
        wgts = [Widget(size_hint=(.5, .5)) for i in range(4)]
        for wgt in wgts:
            sl.add_widget(wgt)
        sl.orientation = 'bt-rl'
        sl.do_layout()

        self.assertEqual(wgts[0].pos, [sl.width / 2., 0])
        self.assertEqual(wgts[1].pos, [sl.width / 2., sl.height / 2.])
        self.assertEqual(wgts[2].pos, [0, 0])
        self.assertEqual(wgts[3].pos, [0, sl.height / 2.])

</source>
<source file="systems/kivy-2.1.0/kivy/tests/test_uix_stacklayout.py" startline="58" endline="71" pcid="1039">
    def test_stacklayout_orientation_rlbt(self):
        # Default orientation is lr-tb.
        sl = StackLayout()
        wgts = [Widget(size_hint=(.5, .5)) for i in range(4)]
        for wgt in wgts:
            sl.add_widget(wgt)
        sl.orientation = 'rl-bt'
        sl.do_layout()

        self.assertEqual(wgts[0].pos, [sl.width / 2., 0])
        self.assertEqual(wgts[1].pos, [0, 0])
        self.assertEqual(wgts[2].pos, [sl.width / 2., sl.height / 2.])
        self.assertEqual(wgts[3].pos, [0, sl.height / 2.])

</source>
</class>

<class classid="28" nclones="2" nlines="28" similarity="93">
<source file="systems/kivy-2.1.0/kivy/input/postproc/doubletap.py" startline="35" endline="67" pcid="1057">
    def find_double_tap(self, ref):
        '''Find a double tap touch within self.touches.
        The touch must be not a previous double tap and the distance must be
        within the specified threshold. Additionally, the touch profiles
        must be the same kind of touch.
        '''
        ref_button = None
        if 'button' in ref.profile:
            ref_button = ref.button

        for touchid in self.touches:
            if ref.uid == touchid:
                continue
            etype, touch = self.touches[touchid]
            if etype != 'end':
                continue
            if touch.is_double_tap:
                continue
            distance = Vector.distance(
                Vector(ref.sx, ref.sy),
                Vector(touch.osx, touch.osy))
            if distance > self.double_tap_distance:
                continue
            if touch.is_mouse_scrolling or ref.is_mouse_scrolling:
                continue
            touch_button = None
            if 'button' in touch.profile:
                touch_button = touch.button
            if touch_button != ref_button:
                continue
            touch.double_tap_distance = distance
            return touch

</source>
<source file="systems/kivy-2.1.0/kivy/input/postproc/tripletap.py" startline="37" endline="71" pcid="1065">
    def find_triple_tap(self, ref):
        '''Find a triple tap touch within *self.touches*.
        The touch must be not be a previous triple tap and the distance
        must be be within the bounds specified. Additionally, the touch profile
        must be the same kind of touch.
        '''
        ref_button = None
        if 'button' in ref.profile:
            ref_button = ref.button

        for touchid in self.touches:
            if ref.uid == touchid:
                continue
            etype, touch = self.touches[touchid]
            if not touch.is_double_tap:
                continue
            if etype != 'end':
                continue
            if touch.is_triple_tap:
                continue
            distance = Vector.distance(
                Vector(ref.sx, ref.sy),
                Vector(touch.osx, touch.osy))
            if distance > self.triple_tap_distance:
                continue
            if touch.is_mouse_scrolling or ref.is_mouse_scrolling:
                continue
            touch_button = None
            if 'button' in touch.profile:
                touch_button = touch.button
            if touch_button != ref_button:
                continue
            touch.triple_tap_distance = distance
            return touch

</source>
</class>

<class classid="29" nclones="2" nlines="28" similarity="96">
<source file="systems/kivy-2.1.0/kivy/input/postproc/doubletap.py" startline="68" endline="101" pcid="1058">
    def process(self, events):
        if self.double_tap_distance == 0 or self.double_tap_time == 0:
            return events
        # first, check if a touch down have a double tap
        for etype, touch in events:
            if not touch.is_touch:
                continue
            if etype == 'begin':
                double_tap = self.find_double_tap(touch)
                if double_tap:
                    touch.is_double_tap = True
                    tap_time = touch.time_start - double_tap.time_start
                    touch.double_tap_time = tap_time
                    distance = double_tap.double_tap_distance
                    touch.double_tap_distance = distance

            # add the touch internally
            self.touches[touch.uid] = (etype, touch)

        # second, check if up-touch is timeout for double tap
        time_current = time()
        to_delete = []
        for touchid in self.touches.keys():
            etype, touch = self.touches[touchid]
            if etype != 'end':
                continue
            if time_current - touch.time_start < self.double_tap_time:
                continue
            to_delete.append(touchid)

        for touchid in to_delete:
            del self.touches[touchid]

        return events
</source>
<source file="systems/kivy-2.1.0/kivy/input/postproc/tripletap.py" startline="72" endline="106" pcid="1066">
    def process(self, events):
        if self.triple_tap_distance == 0 or self.triple_tap_time == 0:
            return events
        # first, check if a touch down have a triple tap
        for etype, touch in events:
            if not touch.is_touch:
                continue
            if etype == 'begin':
                triple_tap = self.find_triple_tap(touch)
                if triple_tap:
                    touch.is_double_tap = False
                    touch.is_triple_tap = True
                    tap_time = touch.time_start - triple_tap.time_start
                    touch.triple_tap_time = tap_time
                    distance = triple_tap.triple_tap_distance
                    touch.triple_tap_distance = distance

            # add the touch internally
            self.touches[touch.uid] = (etype, touch)

        # second, check if up-touch is timeout for triple tap
        time_current = time()
        to_delete = []
        for touchid in self.touches.keys():
            etype, touch = self.touches[touchid]
            if etype != 'end':
                continue
            if time_current - touch.time_start < self.triple_tap_time:
                continue
            to_delete.append(touchid)

        for touchid in to_delete:
            del self.touches[touchid]

        return events
</source>
</class>

<class classid="30" nclones="2" nlines="15" similarity="81">
<source file="systems/kivy-2.1.0/kivy/input/providers/hidinput.py" startline="67" endline="83" pcid="1159">
    def depack(self, args):
        self.sx = args['x']
        self.sy = args['y']
        self.profile = ['pos']
        if 'size_w' in args and 'size_h' in args:
            self.shape = ShapeRect()
            self.shape.width = args['size_w']
            self.shape.height = args['size_h']
            self.profile.append('shape')
        if 'pressure' in args:
            self.pressure = args['pressure']
            self.profile.append('pressure')
        if 'button' in args:
            self.button = args['button']
            self.profile.append('button')
        super().depack(args)

</source>
<source file="systems/kivy-2.1.0/kivy/input/providers/linuxwacom.py" startline="42" endline="55" pcid="1172">
    def depack(self, args):
        self.sx = args['x']
        self.sy = args['y']
        self.profile = ['pos']
        if 'size_w' in args and 'size_h' in args:
            self.shape = ShapeRect()
            self.shape.width = args['size_w']
            self.shape.height = args['size_h']
            self.profile.append('shape')
        if 'pressure' in args:
            self.pressure = args['pressure']
            self.profile.append('pressure')
        super().depack(args)

</source>
</class>

<class classid="31" nclones="3" nlines="39" similarity="73">
<source file="systems/kivy-2.1.0/kivy/input/providers/hidinput.py" startline="331" endline="391" pcid="1161">

        def __init__(self, device, args):
            super(HIDInputMotionEventProvider, self).__init__(device, args)
            global Window, Keyboard

            if Window is None:
                from kivy.core.window import Window
            if Keyboard is None:
                from kivy.core.window import Keyboard

            self.input_fn = None
            self.default_ranges = dict()

            # split arguments
            args = args.split(',')
            if not args:
                Logger.error('HIDInput: Filename missing in configuration')
                Logger.error('HIDInput: Use /dev/input/event0 for example')
                return None

            # read filename
            self.input_fn = args[0]
            Logger.info('HIDInput: Read event from <%s>' % self.input_fn)

            # read parameters
            for arg in args[1:]:
                if arg == '':
                    continue
                arg = arg.split('=')

                # ensure it's a key = value
                if len(arg) != 2:
                    Logger.error('HIDInput: invalid parameter '
                                 '%s, not in key=value format.' % arg)
                    continue

                # ensure the key exist
                key, value = arg
                if key not in HIDInputMotionEventProvider.options:
                    Logger.error('HIDInput: unknown %s option' % key)
                    continue

                # ensure the value
                try:
                    self.default_ranges[key] = int(value)
                except ValueError:
                    err = 'HIDInput: invalid value "%s" for "%s"' % (
                        key, value)
                    Logger.error(err)
                    continue

                # all good!
                Logger.info('HIDInput: Set custom %s to %d' % (
                    key, int(value)))

            if 'rotation' not in self.default_ranges:
                self.default_ranges['rotation'] = 0
            elif self.default_ranges['rotation'] not in (0, 90, 180, 270):
                Logger.error('HIDInput: invalid rotation value ({})'.format(
                    self.default_ranges['rotation']))
                self.default_ranges['rotation'] = 0
</source>
<source file="systems/kivy-2.1.0/kivy/input/providers/mtdev.py" startline="109" endline="161" pcid="1234">
                   'min_pressure', 'max_pressure',
                   'min_touch_major', 'max_touch_major',
                   'min_touch_minor', 'max_touch_minor',
                   'invert_x', 'invert_y',
                   'rotation')

        def __init__(self, device, args):
            super(MTDMotionEventProvider, self).__init__(device, args)
            self._device = None
            self.input_fn = None
            self.default_ranges = dict()

            # split arguments
            args = args.split(',')
            if not args:
                Logger.error('MTD: No filename pass to MTD configuration')
                Logger.error('MTD: Use /dev/input/event0 for example')
                return

            # read filename
            self.input_fn = args[0]
            Logger.info('MTD: Read event from <%s>' % self.input_fn)

            # read parameters
            for arg in args[1:]:
                if arg == '':
                    continue
                arg = arg.split('=')

                # ensure it's a key = value
                if len(arg) != 2:
                    err = 'MTD: Bad parameter %s: Not in key=value format' %\
                        arg
                    Logger.error(err)
                    continue

                # ensure the key exist
                key, value = arg
                if key not in MTDMotionEventProvider.options:
                    Logger.error('MTD: unknown %s option' % key)
                    continue

                # ensure the value
                try:
                    self.default_ranges[key] = int(value)
                except ValueError:
                    err = 'MTD: invalid value %s for option %s' % (key, value)
                    Logger.error(err)
                    continue

                # all good!
                Logger.info('MTD: Set custom %s to %d' % (key, int(value)))

</source>
<source file="systems/kivy-2.1.0/kivy/input/providers/linuxwacom.py" startline="142" endline="193" pcid="1174">

        def __init__(self, device, args):
            super(LinuxWacomMotionEventProvider, self).__init__(device, args)
            self.input_fn = None
            self.default_ranges = dict()
            self.mode = 'touch'

            # split arguments
            args = args.split(',')
            if not args:
                Logger.error('LinuxWacom: No filename given in config')
                Logger.error('LinuxWacom: Use /dev/input/event0 for example')
                return

            # read filename
            self.input_fn = args[0]
            Logger.info('LinuxWacom: Read event from <%s>' % self.input_fn)

            # read parameters
            for arg in args[1:]:
                if arg == '':
                    continue
                arg = arg.split('=')

                # ensure it's a key = value
                if len(arg) != 2:
                    err = 'LinuxWacom: Bad parameter' \
                        '%s: Not in key=value format.' % arg
                    Logger.error(err)
                    continue

                # ensure the key exist
                key, value = arg
                if key == 'mode':
                    self.mode = value
                    continue

                if key not in LinuxWacomMotionEventProvider.options:
                    Logger.error('LinuxWacom: unknown %s option' % key)
                    continue

                # ensure the value
                try:
                    self.default_ranges[key] = int(value)
                except ValueError:
                    err = 'LinuxWacom: value %s invalid for %s' % (key, value)
                    Logger.error(err)
                    continue

                # all good!
                msg = 'LinuxWacom: Set custom %s to %d' % (key, int(value))
                Logger.info(msg)
</source>
</class>

<class classid="32" nclones="3" nlines="15" similarity="87">
<source file="systems/kivy-2.1.0/kivy/input/providers/hidinput.py" startline="392" endline="408" pcid="1162">

        def start(self):
            if self.input_fn is None:
                return
            self.uid = 0
            self.queue = collections.deque()
            self.dispatch_queue = []
            self.thread = threading.Thread(
                name=self.__class__.__name__,
                target=self._thread_run,
                kwargs=dict(
                    queue=self.queue,
                    input_fn=self.input_fn,
                    device=self.device,
                    default_ranges=self.default_ranges))
            self.thread.daemon = True
            self.thread.start()
</source>
<source file="systems/kivy-2.1.0/kivy/input/providers/linuxwacom.py" startline="194" endline="208" pcid="1175">
            Logger.info('LinuxWacom: mode is <%s>' % self.mode)

        def start(self):
            if self.input_fn is None:
                return
            self.uid = 0
            self.queue = collections.deque()
            self.thread = threading.Thread(
                target=self._thread_run,
                kwargs=dict(
                    queue=self.queue,
                    input_fn=self.input_fn,
                    device=self.device,
                    default_ranges=self.default_ranges))
            self.thread.daemon = True
</source>
<source file="systems/kivy-2.1.0/kivy/input/providers/mtdev.py" startline="162" endline="177" pcid="1235">
            if 'rotation' not in self.default_ranges:
                self.default_ranges['rotation'] = 0
            elif self.default_ranges['rotation'] not in (0, 90, 180, 270):
                Logger.error('HIDInput: invalid rotation value ({})'.format(
                    self.default_ranges['rotation']))
                self.default_ranges['rotation'] = 0

        def start(self):
            if self.input_fn is None:
                return
            self.uid = 0
            self.queue = collections.deque()
            self.thread = threading.Thread(
                name=self.__class__.__name__,
                target=self._thread_run,
                kwargs=dict(
</source>
</class>

<class classid="33" nclones="2" nlines="12" similarity="100">
<source file="systems/kivy-2.1.0/kivy/input/providers/hidinput.py" startline="437" endline="449" pcid="1164">

            def assign_coord(point, value, invert, coords):
                cx, cy = coords
                if invert:
                    value = 1. - value
                if rotation == 0:
                    point[cx] = value
                elif rotation == 90:
                    point[cy] = value
                elif rotation == 180:
                    point[cx] = 1. - value
                elif rotation == 270:
                    point[cy] = 1. - value
</source>
<source file="systems/kivy-2.1.0/kivy/input/providers/mtdev.py" startline="188" endline="200" pcid="1237">
            device = kwargs.get('device')
            drs = kwargs.get('default_ranges').get
            touches = {}
            touches_sent = []
            point = {}
            l_points = {}

            def assign_coord(point, value, invert, coords):
                cx, cy = coords
                if invert:
                    value = 1. - value
                if rotation == 0:
                    point[cx] = value
</source>
</class>

<class classid="34" nclones="2" nlines="13" similarity="100">
<source file="systems/kivy-2.1.0/kivy/input/providers/mouse.py" startline="206" endline="219" pcid="1187">
    def start(self):
        '''Start the mouse provider'''
        if not EventLoop.window:
            return
        fbind = EventLoop.window.fbind
        fbind('on_mouse_down', self.on_mouse_press)
        fbind('on_mouse_move', self.on_mouse_motion)
        fbind('on_mouse_up', self.on_mouse_release)
        fbind('on_rotate', self.update_touch_graphics)
        fbind('system_size', self.update_touch_graphics)
        if not self.disable_hover:
            self._start_hover_events()
        self._running = True

</source>
<source file="systems/kivy-2.1.0/kivy/input/providers/mouse.py" startline="229" endline="242" pcid="1189">
    def stop(self):
        '''Stop the mouse provider'''
        if not EventLoop.window:
            return
        funbind = EventLoop.window.funbind
        funbind('on_mouse_down', self.on_mouse_press)
        funbind('on_mouse_move', self.on_mouse_motion)
        funbind('on_mouse_up', self.on_mouse_release)
        funbind('on_rotate', self.update_touch_graphics)
        funbind('system_size', self.update_touch_graphics)
        if not self.disable_hover:
            self._stop_hover_events()
        self._running = False

</source>
</class>

<class classid="35" nclones="2" nlines="12" similarity="100">
<source file="systems/kivy-2.1.0/kivy/storage/jsonstore.py" startline="75" endline="87" pcid="1260">
    def store_find(self, filters):
        for key, values in iteritems(self._data):
            found = True
            for fkey, fvalue in iteritems(filters):
                if fkey not in values:
                    found = False
                    break
                if values[fkey] != fvalue:
                    found = False
                    break
            if found:
                yield key, values

</source>
<source file="systems/kivy-2.1.0/kivy/storage/dictstore.py" startline="81" endline="93" pcid="1270">
    def store_find(self, filters):
        for key, values in iteritems(self._data):
            found = True
            for fkey, fvalue in iteritems(filters):
                if fkey not in values:
                    found = False
                    break
                if values[fkey] != fvalue:
                    found = False
                    break
            if found:
                yield key, values

</source>
</class>

<class classid="36" nclones="2" nlines="16" similarity="87">
<source file="systems/kivy-2.1.0/kivy/uix/behaviors/touchripple.py" startline="265" endline="280" pcid="1332">

    def on_touch_down(self, touch):
        if super(TouchRippleButtonBehavior, self).on_touch_down(touch):
            return True
        if touch.is_mouse_scrolling:
            return False
        if not self.collide_point(touch.x, touch.y):
            return False
        if self in touch.ud:
            return False
        touch.grab(self)
        touch.ud[self] = True
        self.last_touch = touch
        self.ripple_show(touch)
        self.dispatch('on_press')
        return True
</source>
<source file="systems/kivy-2.1.0/kivy/uix/behaviors/button.py" startline="136" endline="152" pcid="1393">

    def on_touch_down(self, touch):
        if super(ButtonBehavior, self).on_touch_down(touch):
            return True
        if touch.is_mouse_scrolling:
            return False
        if not self.collide_point(touch.x, touch.y):
            return False
        if self in touch.ud:
            return False
        touch.grab(self)
        touch.ud[self] = True
        self.last_touch = touch
        self.__touch_time = time()
        self._do_press()
        self.dispatch('on_press')
        return True
</source>
</class>

<class classid="37" nclones="2" nlines="10" similarity="100">
<source file="systems/kivy-2.1.0/kivy/uix/behaviors/drag.py" startline="205" endline="216" pcid="1344">
                super(DragBehavior, self).on_touch_up(touch)
        return self._get_uid() in touch.ud

    def _do_touch_up(self, touch, *largs):
        super(DragBehavior, self).on_touch_up(touch)
        # don't forget about grab event!
        for x in touch.grab_list[:]:
            touch.grab_list.remove(x)
            x = x()
            if not x:
                continue
            touch.grab_current = x
</source>
<source file="systems/kivy-2.1.0/kivy/uix/carousel.py" startline="611" endline="622" pcid="1955">
                Clock.schedule_once(partial(self._do_touch_up, touch), .1)
            else:
                self._start_animation()

        else:
            if self._touch is not touch and self.uid not in touch.ud:
                super(Carousel, self).on_touch_up(touch)
        return self._get_uid() in touch.ud

    def _do_touch_up(self, touch, *largs):
        super(Carousel, self).on_touch_up(touch)
        # don't forget about grab event!
</source>
</class>

<class classid="38" nclones="2" nlines="13" similarity="92">
<source file="systems/kivy-2.1.0/kivy/uix/behaviors/emacs.py" startline="114" endline="127" pcid="1362">
    def delete_word_right(self):
        '''Delete text right of the cursor to the end of the word'''
        if self._selection:
            return
        start_index = self.cursor_index()
        start_cursor = self.cursor
        self.do_cursor_movement('cursor_right', control=True)
        end_index = self.cursor_index()
        if start_index != end_index:
            s = self.text[start_index:end_index]
            self._set_unredo_delsel(start_index, end_index, s, from_undo=False)
            self.text = self.text[:start_index] + self.text[end_index:]
            self._set_cursor(pos=start_cursor)

</source>
<source file="systems/kivy-2.1.0/kivy/uix/behaviors/emacs.py" startline="128" endline="140" pcid="1363">
    def delete_word_left(self):
        '''Delete text left of the cursor to the beginning of word'''
        if self._selection:
            return
        start_index = self.cursor_index()
        self.do_cursor_movement('cursor_left', control=True)
        end_cursor = self.cursor
        end_index = self.cursor_index()
        if start_index != end_index:
            s = self.text[end_index:start_index]
            self._set_unredo_delsel(end_index, start_index, s, from_undo=False)
            self.text = self.text[:end_index] + self.text[start_index:]
            self._set_cursor(pos=end_cursor)
</source>
</class>

<class classid="39" nclones="6" nlines="10" similarity="70">
<source file="systems/kivy-2.1.0/kivy/uix/pagelayout.py" startline="82" endline="93" pcid="1400">
    def __init__(self, **kwargs):
        super(PageLayout, self).__init__(**kwargs)

        trigger = self._trigger_layout
        fbind = self.fbind
        fbind('border', trigger)
        fbind('page', trigger)
        fbind('parent', trigger)
        fbind('children', trigger)
        fbind('size', trigger)
        fbind('pos', trigger)

</source>
<source file="systems/kivy-2.1.0/kivy/uix/anchorlayout.py" startline="67" endline="78" pcid="1461">
    def __init__(self, **kwargs):
        super(AnchorLayout, self).__init__(**kwargs)
        fbind = self.fbind
        update = self._trigger_layout
        fbind('children', update)
        fbind('parent', update)
        fbind('padding', update)
        fbind('anchor_x', update)
        fbind('anchor_y', update)
        fbind('size', update)
        fbind('pos', update)

</source>
<source file="systems/kivy-2.1.0/kivy/uix/stacklayout.py" startline="139" endline="149" pcid="1870">

    def __init__(self, **kwargs):
        super(StackLayout, self).__init__(**kwargs)
        trigger = self._trigger_layout
        fbind = self.fbind
        fbind('padding', trigger)
        fbind('spacing', trigger)
        fbind('children', trigger)
        fbind('orientation', trigger)
        fbind('size', trigger)
        fbind('pos', trigger)
</source>
<source file="systems/kivy-2.1.0/kivy/uix/boxlayout.py" startline="144" endline="155" pcid="2124">
    def __init__(self, **kwargs):
        super(BoxLayout, self).__init__(**kwargs)
        update = self._trigger_layout
        fbind = self.fbind
        fbind('spacing', update)
        fbind('padding', update)
        fbind('children', update)
        fbind('orientation', update)
        fbind('parent', update)
        fbind('size', update)
        fbind('pos', update)

</source>
<source file="systems/kivy-2.1.0/kivy/uix/accordion.py" startline="256" endline="266" pcid="1961">
    def __init__(self, **kwargs):
        self._trigger_title = Clock.create_trigger(self._update_title, -1)
        self._anim_collapse = None
        super(AccordionItem, self).__init__(**kwargs)
        trigger_title = self._trigger_title
        fbind = self.fbind
        fbind('title', trigger_title)
        fbind('title_template', trigger_title)
        fbind('title_args', trigger_title)
        trigger_title()

</source>
<source file="systems/kivy-2.1.0/kivy/uix/camera.py" startline="81" endline="91" pcid="1491">

    def __init__(self, **kwargs):
        self._camera = None
        super(Camera, self).__init__(**kwargs)
        if self.index == -1:
            self.index = 0
        on_index = self._on_index
        fbind = self.fbind
        fbind('index', on_index)
        fbind('resolution', on_index)
        on_index()
</source>
</class>

<class classid="40" nclones="2" nlines="10" similarity="80">
<source file="systems/kivy-2.1.0/kivy/uix/colorpicker.py" startline="184" endline="196" pcid="1414">
    def inertial_incr_sv_idx(self, dt):
        # if its already zoomed all the way out, cancel the inertial zoom
        if self.sv_idx == len(self.sv_s) - self._piece_divisions:
            return False

        self.sv_idx += 1
        self.recolor_wheel()
        if dt * self._inertia_slowdown > self._inertia_cutoff:
            return False
        else:
            Clock.schedule_once(self.inertial_incr_sv_idx,
                                dt * self._inertia_slowdown)

</source>
<source file="systems/kivy-2.1.0/kivy/uix/colorpicker.py" startline="197" endline="208" pcid="1415">
    def inertial_decr_sv_idx(self, dt):
        # if its already zoomed all the way in, cancel the inertial zoom
        if self.sv_idx == 0:
            return False
        self.sv_idx -= 1
        self.recolor_wheel()
        if dt * self._inertia_slowdown > self._inertia_cutoff:
            return False
        else:
            Clock.schedule_once(self.inertial_decr_sv_idx,
                                dt * self._inertia_slowdown)

</source>
</class>

<class classid="41" nclones="3" nlines="17" similarity="88">
<source file="systems/kivy-2.1.0/kivy/uix/recycleview/__init__.py" startline="393" endline="413" pcid="1603">
        return self._data_model

    def _set_data_model(self, value):
        data_model = self._data_model
        if value is data_model:
            return
        if data_model is not None:
            self._data_model = None
            data_model.detach_recycleview()

        if value is None:
            return True

        if not isinstance(value, RecycleDataModelBehavior):
            raise ValueError(
                'Expected object based on RecycleDataModelBehavior, got {}'.
                format(value.__class__))

        self._data_model = value
        value.attach_recycleview(self)
        self.refresh_from_data()
</source>
<source file="systems/kivy-2.1.0/kivy/uix/recycleview/__init__.py" startline="458" endline="479" pcid="1607">
        return self._layout_manager

    def _set_layout_manager(self, value):
        lm = self._layout_manager
        if value is lm:
            return

        if lm is not None:
            self._layout_manager = None
            lm.detach_recycleview()

        if value is None:
            return True

        if not isinstance(value, RecycleLayoutManagerBehavior):
            raise ValueError(
                'Expected object based on RecycleLayoutManagerBehavior, '
                'got {}'.format(value.__class__))

        self._layout_manager = value
        value.attach_recycleview(self)
        self.refresh_from_layout()
</source>
<source file="systems/kivy-2.1.0/kivy/uix/recycleview/__init__.py" startline="425" endline="445" pcid="1605">
        return self._view_adapter

    def _set_view_adapter(self, value):
        view_adapter = self._view_adapter
        if value is view_adapter:
            return
        if view_adapter is not None:
            self._view_adapter = None
            view_adapter.detach_recycleview()

        if value is None:
            return True

        if not isinstance(value, RecycleDataAdapter):
            raise ValueError(
                'Expected object based on RecycleAdapter, got {}'.
                format(value.__class__))

        self._view_adapter = value
        value.attach_recycleview(self)
        self.refresh_from_layout()
</source>
</class>

<class classid="42" nclones="2" nlines="49" similarity="72">
<source file="systems/kivy-2.1.0/kivy/uix/floatlayout.py" startline="74" endline="133" pcid="1713">
    def do_layout(self, *largs, **kwargs):
        # optimize layout by preventing looking at the same attribute in a loop
        w, h = kwargs.get('size', self.size)
        x, y = kwargs.get('pos', self.pos)
        for c in self.children:
            # size
            shw, shh = c.size_hint
            shw_min, shh_min = c.size_hint_min
            shw_max, shh_max = c.size_hint_max

            if shw is not None and shh is not None:
                c_w = shw * w
                c_h = shh * h

                if shw_min is not None and c_w < shw_min:
                    c_w = shw_min
                elif shw_max is not None and c_w > shw_max:
                    c_w = shw_max

                if shh_min is not None and c_h < shh_min:
                    c_h = shh_min
                elif shh_max is not None and c_h > shh_max:
                    c_h = shh_max
                c.size = c_w, c_h
            elif shw is not None:
                c_w = shw * w

                if shw_min is not None and c_w < shw_min:
                    c_w = shw_min
                elif shw_max is not None and c_w > shw_max:
                    c_w = shw_max
                c.width = c_w
            elif shh is not None:
                c_h = shh * h

                if shh_min is not None and c_h < shh_min:
                    c_h = shh_min
                elif shh_max is not None and c_h > shh_max:
                    c_h = shh_max
                c.height = c_h

            # pos
            for key, value in c.pos_hint.items():
                if key == 'x':
                    c.x = x + value * w
                elif key == 'right':
                    c.right = x + value * w
                elif key == 'pos':
                    c.pos = x + value[0] * w, y + value[1] * h
                elif key == 'y':
                    c.y = y + value * h
                elif key == 'top':
                    c.top = y + value * h
                elif key == 'center':
                    c.center = x + value[0] * w, y + value[1] * h
                elif key == 'center_x':
                    c.center_x = x + value * w
                elif key == 'center_y':
                    c.center_y = y + value * h

</source>
<source file="systems/kivy-2.1.0/kivy/core/window/__init__.py" startline="1766" endline="1819" pcid="2636">
        # and update childs
        self.update_childsize()

    def update_childsize(self, childs=None):
        width, height = self.size
        if childs is None:
            childs = self.children
        for w in childs:
            shw, shh = w.size_hint
            shw_min, shh_min = w.size_hint_min
            shw_max, shh_max = w.size_hint_max

            if shw is not None and shh is not None:
                c_w = shw * width
                c_h = shh * height

                if shw_min is not None and c_w < shw_min:
                    c_w = shw_min
                elif shw_max is not None and c_w > shw_max:
                    c_w = shw_max

                if shh_min is not None and c_h < shh_min:
                    c_h = shh_min
                elif shh_max is not None and c_h > shh_max:
                    c_h = shh_max
                w.size = c_w, c_h
            elif shw is not None:
                c_w = shw * width

                if shw_min is not None and c_w < shw_min:
                    c_w = shw_min
                elif shw_max is not None and c_w > shw_max:
                    c_w = shw_max
                w.width = c_w
            elif shh is not None:
                c_h = shh * height

                if shh_min is not None and c_h < shh_min:
                    c_h = shh_min
                elif shh_max is not None and c_h > shh_max:
                    c_h = shh_max
                w.height = c_h

            for key, value in w.pos_hint.items():
                if key == 'x':
                    w.x = value * width
                elif key == 'right':
                    w.right = value * width
                elif key == 'y':
                    w.y = value * height
                elif key == 'top':
                    w.top = value * height
                elif key == 'center_x':
                    w.center_x = value * width
</source>
</class>

<class classid="43" nclones="2" nlines="15" similarity="80">
<source file="systems/kivy-2.1.0/kivy/uix/recyclelayout.py" startline="187" endline="201" pcid="1772">
    def attach_recycleview(self, rv):
        super(RecycleLayout, self).attach_recycleview(rv)
        if rv:
            fbind = self.fbind
            fbind('default_size', rv.refresh_from_data)
            fbind('key_size', rv.refresh_from_data)
            fbind('default_size_hint', rv.refresh_from_data)
            fbind('key_size_hint', rv.refresh_from_data)
            fbind('default_size_hint_min', rv.refresh_from_data)
            fbind('key_size_hint_min', rv.refresh_from_data)
            fbind('default_size_hint_max', rv.refresh_from_data)
            fbind('key_size_hint_max', rv.refresh_from_data)
            fbind('default_pos_hint', rv.refresh_from_data)
            fbind('key_pos_hint', rv.refresh_from_data)

</source>
<source file="systems/kivy-2.1.0/kivy/uix/recyclelayout.py" startline="202" endline="217" pcid="1773">
    def detach_recycleview(self):
        rv = self.recycleview
        if rv:
            funbind = self.funbind
            funbind('default_size', rv.refresh_from_data)
            funbind('key_size', rv.refresh_from_data)
            funbind('default_size_hint', rv.refresh_from_data)
            funbind('key_size_hint', rv.refresh_from_data)
            funbind('default_size_hint_min', rv.refresh_from_data)
            funbind('key_size_hint_min', rv.refresh_from_data)
            funbind('default_size_hint_max', rv.refresh_from_data)
            funbind('key_size_hint_max', rv.refresh_from_data)
            funbind('default_pos_hint', rv.refresh_from_data)
            funbind('key_pos_hint', rv.refresh_from_data)
        super(RecycleLayout, self).detach_recycleview()

</source>
</class>

<class classid="44" nclones="2" nlines="11" similarity="90">
<source file="systems/kivy-2.1.0/kivy/uix/screenmanager.py" startline="1090" endline="1102" pcid="1855">
    def __next__(self):
        '''Py2K backwards compatibility without six or other lib.
        '''
        screens = self.screens
        if not screens:
            return
        try:
            index = screens.index(self.current_screen)
            index = (index + 1) % len(screens)
            return screens[index].name
        except ValueError:
            return

</source>
<source file="systems/kivy-2.1.0/kivy/uix/screenmanager.py" startline="1107" endline="1119" pcid="1857">
    def previous(self):
        '''Return the name of the previous screen from the screen list.
        '''
        screens = self.screens
        if not screens:
            return
        try:
            index = screens.index(self.current_screen)
            index = (index - 1) % len(screens)
            return screens[index].name
        except ValueError:
            return

</source>
</class>

<class classid="45" nclones="2" nlines="11" similarity="100">
<source file="systems/kivy-2.1.0/kivy/uix/scrollview.py" startline="295" endline="308" pcid="2019">
    '''

    def _get_vbar(self):
        # must return (y, height) in %
        # calculate the viewport size / scrollview size %
        if self._viewport is None:
            return 0, 1.
        vh = self._viewport.height
        h = self.height
        if vh < h or vh == 0:
            return 0, 1.
        ph = max(0.01, h / float(vh))
        sy = min(1.0, max(0.0, self.scroll_y))
        py = (1. - ph) * sy
</source>
<source file="systems/kivy-2.1.0/kivy/uix/scrollview.py" startline="324" endline="337" pcid="2020">
    '''

    def _get_hbar(self):
        # must return (x, width) in %
        # calculate the viewport size / scrollview size %
        if self._viewport is None:
            return 0, 1.
        vw = self._viewport.width
        w = self.width
        if vw < w or vw == 0:
            return 0, 1.
        pw = max(0.01, w / float(vw))
        sx = min(1.0, max(0.0, self.scroll_x))
        px = (1. - pw) * sx
</source>
</class>

<class classid="46" nclones="2" nlines="14" similarity="100">
<source file="systems/kivy-2.1.0/kivy/uix/scrollview.py" startline="617" endline="632" pcid="2031">
        self._update_effect_y_bounds()

    def _update_effect_x(self, *args):
        vp = self._viewport
        if not vp or not self.effect_x:
            return

        if self.effect_x.is_manual:
            sw = vp.width - self._effect_x_start_width
        else:
            sw = vp.width - self.width
        if sw < 1 and not (self.always_overscroll and self.do_scroll_x):
            return
        if sw != 0:
            sx = self.effect_x.scroll / sw
            self.scroll_x = -sx
</source>
<source file="systems/kivy-2.1.0/kivy/uix/scrollview.py" startline="633" endline="648" pcid="2032">
        self._trigger_update_from_scroll()

    def _update_effect_y(self, *args):
        vp = self._viewport
        if not vp or not self.effect_y:
            return
        if self.effect_y.is_manual:
            sh = vp.height - self._effect_y_start_height
        else:
            sh = vp.height - self.height

        if sh < 1 and not (self.always_overscroll and self.do_scroll_y):
            return
        if sh != 0:
            sy = self.effect_y.scroll / sh
            self.scroll_y = -sy
</source>
</class>

<class classid="47" nclones="3" nlines="21" similarity="70">
<source file="systems/kivy-2.1.0/kivy/uix/settings.py" startline="394" endline="428" pcid="2065">

    def _create_popup(self, instance):
        # create popup layout
        content = BoxLayout(orientation='vertical', spacing='5dp')
        popup_width = min(0.95 * Window.width, dp(500))
        self.popup = popup = Popup(
            title=self.title, content=content, size_hint=(None, None),
            size=(popup_width, '250dp'))

        # create the textinput used for numeric input
        self.textinput = textinput = TextInput(
            text=self.value, font_size='24sp', multiline=False,
            size_hint_y=None, height='42sp')
        textinput.bind(on_text_validate=self._validate)
        self.textinput = textinput

        # construct the content, widget are used as a spacer
        content.add_widget(Widget())
        content.add_widget(textinput)
        content.add_widget(Widget())
        content.add_widget(SettingSpacer())

        # 2 buttons are created for accept or cancel the current value
        btnlayout = BoxLayout(size_hint_y=None, height='50dp', spacing='5dp')
        btn = Button(text='Ok')
        btn.bind(on_release=self._validate)
        btnlayout.add_widget(btn)
        btn = Button(text='Cancel')
        btn.bind(on_release=self._dismiss)
        btnlayout.add_widget(btn)
        content.add_widget(btnlayout)

        # all done, open the popup !
        popup.open()

</source>
<source file="systems/kivy-2.1.0/kivy/uix/settings.py" startline="559" endline="587" pcid="2073">

    def _create_popup(self, instance):
        # create popup layout
        content = BoxLayout(orientation='vertical', spacing='5dp')
        popup_width = min(0.95 * Window.width, dp(500))
        self.popup = popup = Popup(
            title=self.title, content=content, size_hint=(None, 0.9),
            width=popup_width)

        self.colorpicker = colorpicker = \
            ColorPicker(color=utils.get_color_from_hex(self.value))
        colorpicker.bind(on_color=self._validate)

        self.colorpicker = colorpicker
        content.add_widget(colorpicker)
        content.add_widget(SettingSpacer())

        # 2 buttons are created for accept or cancel the current value
        btnlayout = BoxLayout(size_hint_y=None, height='50dp', spacing='5dp')
        btn = Button(text='Ok')
        btn.bind(on_release=self._validate)
        btnlayout.add_widget(btn)
        btn = Button(text='Cancel')
        btn.bind(on_release=self._dismiss)
        btnlayout.add_widget(btn)
        content.add_widget(btnlayout)

        # all done, open the popup !
        popup.open()
</source>
<source file="systems/kivy-2.1.0/kivy/uix/settings.py" startline="494" endline="526" pcid="2069">

    def _create_popup(self, instance):
        # create popup layout
        content = BoxLayout(orientation='vertical', spacing=5)
        popup_width = min(0.95 * Window.width, dp(500))
        self.popup = popup = Popup(
            title=self.title, content=content, size_hint=(None, 0.9),
            width=popup_width)

        # create the filechooser
        initial_path = self.value or os.getcwd()
        self.textinput = textinput = FileChooserListView(
            path=initial_path, size_hint=(1, 1),
            dirselect=self.dirselect, show_hidden=self.show_hidden)
        textinput.bind(on_path=self._validate)

        # construct the content
        content.add_widget(textinput)
        content.add_widget(SettingSpacer())

        # 2 buttons are created for accept or cancel the current value
        btnlayout = BoxLayout(size_hint_y=None, height='50dp', spacing='5dp')
        btn = Button(text='Ok')
        btn.bind(on_release=self._validate)
        btnlayout.add_widget(btn)
        btn = Button(text='Cancel')
        btn.bind(on_release=self._dismiss)
        btnlayout.add_widget(btn)
        content.add_widget(btnlayout)

        # all done, open the popup !
        popup.open()

</source>
</class>

<class classid="48" nclones="2" nlines="26" similarity="70">
<source file="systems/kivy-2.1.0/kivy/core/text/markup.py" startline="593" endline="634" pcid="2713">
        def n_restricted(line, uw, c):
            ''' Similar to the function `n`, except it only returns the first
            occurrence and it's not an iterator. Furthermore, if the first
            occurrence doesn't fit within width uw, it returns the index of
            whatever amount of text will still fit in uw.

            :returns:
                similar to the function `n`, except it's a 4-tuple, with the
                last element a boolean, indicating if we had to clip the text
                to fit in uw (True) or if the whole text until the first
                occurrence fitted in uw (False).
            '''
            total_w = 0
            if not len(line):
                return 0, 0, 0
            for w in range(len(line)):
                word = line[w]
                f = partial(word.text.find, c)
                self.options = word.options
                extents = self.get_cached_extents()
                i = f()
                if i != -1:
                    ww = extents(word.text[:i])[0]

                if i != -1 and total_w + ww <= uw:  # found and it fits
                    return w, i, total_w + ww, False
                elif i == -1:
                    ww = extents(word.text)[0]
                    if total_w + ww <= uw:  # wasn't found and all fits
                        total_w += ww
                        continue
                    i = len(word.text)

                # now just find whatever amount of the word does fit
                e = 0
                while e != i and total_w + extents(word.text[:e])[0] <= uw:
                    e += 1
                e = max(0, e - 1)
                return w, e, total_w + extents(word.text[:e])[0], True

            return -1, -1, total_w, False

</source>
<source file="systems/kivy-2.1.0/kivy/core/text/markup.py" startline="635" endline="666" pcid="2714">
        def p_restricted(line, uw, c):
            ''' Similar to `n_restricted`, except it returns the first
            occurrence starting from the right, like `p`.
            '''
            total_w = 0
            if not len(line):
                return 0, 0, 0
            for w in range(len(line) - 1, -1, -1):
                word = line[w]
                f = partial(word.text.rfind, c)
                self.options = word.options
                extents = self.get_cached_extents()
                i = f()
                if i != -1:
                    ww = extents(word.text[i + 1:])[0]

                if i != -1 and total_w + ww <= uw:  # found and it fits
                    return w, i, total_w + ww, False
                elif i == -1:
                    ww = extents(word.text)[0]
                    if total_w + ww <= uw:  # wasn't found and all fits
                        total_w += ww
                        continue

                # now just find whatever amount of the word does fit
                s = len(word.text) - 1
                while s >= 0 and total_w + extents(word.text[s:])[0] <= uw:
                    s -= 1
                return w, s, total_w + extents(word.text[s + 1:])[0], True

            return -1, -1, total_w, False

</source>
</class>

<class classid="49" nclones="2" nlines="12" similarity="100">
<source file="systems/kivy-2.1.0/examples/tutorials/pong/steps/step5/main.py" startline="40" endline="58" pcid="3104">
    def update(self, dt):
        self.ball.move()

        # bounce of paddles
        self.player1.bounce_ball(self.ball)
        self.player2.bounce_ball(self.ball)

        # bounce ball off bottom or top
        if (self.ball.y < self.y) or (self.ball.top > self.top):
            self.ball.velocity_y *= -1

        # went of to a side to score point?
        if self.ball.x < self.x:
            self.player2.score += 1
            self.serve_ball(vel=(4, 0))
        if self.ball.right > self.width:
            self.player1.score += 1
            self.serve_ball(vel=(-4, 0))

</source>
<source file="systems/kivy-2.1.0/examples/tutorials/pong/main.py" startline="47" endline="65" pcid="3118">
    def update(self, dt):
        self.ball.move()

        # bounce ball off paddles
        self.player1.bounce_ball(self.ball)
        self.player2.bounce_ball(self.ball)

        # bounce ball off bottom or top
        if (self.ball.y < self.y) or (self.ball.top > self.top):
            self.ball.velocity_y *= -1

        # went off a side to score point?
        if self.ball.x < self.x:
            self.player2.score += 1
            self.serve_ball(vel=(4, 0))
        if self.ball.right > self.width:
            self.player1.score += 1
            self.serve_ball(vel=(-4, 0))

</source>
</class>

<class classid="50" nclones="2" nlines="14" similarity="100">
<source file="systems/kivy-2.1.0/examples/demo/touchtracer/main.py" startline="40" endline="55" pcid="3238">
def calculate_points(x1, y1, x2, y2, steps=5):
    dx = x2 - x1
    dy = y2 - y1
    dist = sqrt(dx * dx + dy * dy)
    if dist < steps:
        return
    o = []
    m = dist / steps
    for i in range(1, int(m)):
        mi = i / m
        lastx = x1 + dx * mi
        lasty = y1 + dy * mi
        o.extend([lastx, lasty])
    return o


</source>
<source file="systems/kivy-2.1.0/examples/widgets/colorpicker.py" startline="118" endline="133" pcid="3383">
def calculate_points(x1, y1, x2, y2, steps=5):
    dx = x2 - x1
    dy = y2 - y1
    dist = sqrt(dx * dx + dy * dy)
    if dist < steps:
        return
    o = []
    m = dist / steps
    for i in range(1, int(m)):
        mi = i / m
        lastx = x1 + dx * mi
        lasty = y1 + dy * mi
        o.extend([lastx, lasty])
    return o


</source>
</class>

<class classid="51" nclones="2" nlines="11" similarity="81">
<source file="systems/kivy-2.1.0/examples/demo/showcase/main.py" startline="164" endline="178" pcid="3261">

    def showcase_boxlayout(self, layout):

        def add_button(*t):
            if not layout.get_parent_window():
                return
            if len(layout.children) > 5:
                layout.orientation = 'vertical'\
                    if layout.orientation == 'horizontal' else 'horizontal'
                layout.clear_widgets()
            layout.add_widget(Builder.load_string('''
Button:
    text: self.parent.orientation if self.parent else ''
'''))
            Clock.schedule_once(add_button, 1)
</source>
<source file="systems/kivy-2.1.0/examples/demo/showcase/main.py" startline="179" endline="196" pcid="3263">
        Clock.schedule_once(add_button)

    def showcase_gridlayout(self, layout):

        def add_button(*t):
            if not layout.get_parent_window():
                return
            if len(layout.children) > 15:
                layout.rows = 3 if layout.rows is None else None
                layout.cols = None if layout.rows == 3 else 3
                layout.clear_widgets()
            layout.add_widget(Builder.load_string('''
Button:
    text:
        'rows: {}\\ncols: {}'.format(self.parent.rows, self.parent.cols)\
        if self.parent else ''
'''))
            Clock.schedule_once(add_button, 1)
</source>
</class>

</clones>
