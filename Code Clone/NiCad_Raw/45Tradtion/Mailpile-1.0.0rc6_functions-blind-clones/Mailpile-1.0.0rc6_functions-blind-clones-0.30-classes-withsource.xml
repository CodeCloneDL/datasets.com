<clones>
<systeminfo processor="nicad6" system="Mailpile-1.0.0rc6" granularity="functions-blind" threshold="30%" minlines="10" maxlines="2500"/>
<cloneinfo npcs="2699" npairs="17"/>
<runinfo ncompares="128582" cputime="117533"/>
<classinfo nclasses="14"/>

<class classid="1" nclones="2" nlines="14" similarity="80">
<source file="systems/Mailpile-1.0.0rc6/mailpile/mail_source/local.py" startline="47" endline="62" pcid="127">
    def open(self):
        with self._lock:
            mailboxes = self.my_config.mailbox.values()
            if self.watching == len(mailboxes):
                return True
            else:
                self.watching = len(mailboxes)

            # Prepare the data section of our event, for keeping state.
            for d in ('mailbox_state', ):
                if d not in self.event.data:
                    self.event.data[d] = {}

        self._log_status(_('Watching %d mbox mailboxes') % self.watching)
        return True

</source>
<source file="systems/Mailpile-1.0.0rc6/mailpile/mail_source/pop3.py" startline="93" endline="111" pcid="151">
    def open(self):
        with self._lock:
            mailboxes = self.my_config.mailbox.values()
            if self.watching == len(mailboxes):
                return True
            else:
                self.watching = len(mailboxes)

            for d in ('mailbox_state', ):
                if d not in self.event.data:
                    self.event.data[d] = {}
            self.event.data['connection'] = {
                'live': False,
                'error': [False, _('Nothing is wrong')]
            }

        self._log_status(_('Watching %d POP3 mailboxes') % self.watching)
        return True

</source>
</class>

<class classid="2" nclones="2" nlines="13" similarity="92">
<source file="systems/Mailpile-1.0.0rc6/mailpile/tests/test_eventlog.py" startline="89" endline="101" pcid="812">
    def test_event_as_dict(self):
        cmd = self.mp.help()
        evt = mailpile.eventlog.Event(source=cmd, data={ 'name' : 'testing'}, message="hello world", private_data={ 'x' : 22})
        res = evt.as_dict()
        self.assertEqual(res['message'], "hello world")
        self.assertEqual(res['data'], { 'name' : 'testing'})
        self.assertIsNotNone( EVENT_ID_RE.match(res['event_id']) )
        self.assertEqual(res['private_data'], { 'x' : 22})
        self.assertIsNotNone( res['flags'] )
        self.assertIsNotNone( res['source'] )
        self.assertIsNotNone( res['date'] )
        self.assertTrue( isinstance(res['ts'], float) )

</source>
<source file="systems/Mailpile-1.0.0rc6/mailpile/tests/test_eventlog.py" startline="109" endline="122" pcid="814">
    def test_event_as_json(self):
        cmd = self.mp.help()
        evt = mailpile.eventlog.Event(source=cmd, data={ 'name' : 'testing'}, message="hello world", private_data={ 'x' : 22})
        json_res = evt.as_json()
        res = json.loads(json_res)
        self.assertEqual(res['message'], "hello world")
        self.assertEqual(res['data'], { 'name' : 'testing'})
        self.assertIsNotNone( EVENT_ID_RE.match(res['event_id']) )
        self.assertEqual(res['private_data'], { 'x' : 22})
        self.assertIsNotNone( res['flags'] )
        self.assertIsNotNone( res['source'] )
        self.assertIsNotNone( res['date'] )
        self.assertTrue( isinstance(res['ts'], float) )

</source>
</class>

<class classid="3" nclones="3" nlines="10" similarity="75">
<source file="systems/Mailpile-1.0.0rc6/mailpile/tests/test_config.py" startline="254" endline="264" pcid="859">
    def test_UrlCheck_valid(self):
        valid_urls = [
          "http://site.io",
          "https://localhost",
          "git://github.com/user/repo.git",
          "magnet:?xt=urn:sha1:1C6HTVCWBTRNJ9V4XNAE52SJUQCZO5D",
        ]
        for v in valid_urls:
            res = validators.UrlCheck(v)
            self.assertEqual(res, v)

</source>
<source file="systems/Mailpile-1.0.0rc6/mailpile/tests/test_config.py" startline="265" endline="278" pcid="860">
    def test_UrlCheck_invalid(self):
        invalid_urls = [
          "obvious",
          "",
          " ",
          ".com",
          "/just/a/path",
        ]
        for i in invalid_urls:
            self.assertRaises(ValueError, lambda: validators.UrlCheck(i))

    #
    #config._EmailCheck should verify that an email address has an @ symbol
    #
</source>
<source file="systems/Mailpile-1.0.0rc6/mailpile/tests/test_config.py" startline="279" endline="293" pcid="861">
    def test_EmailCheck_valid(self):
        valid_emails = [
          '"This is a valid email!"@believe.it',
          'this.address(has-a-comment)@crazy-but-true.com',
          '"ABC\@def"@valid-email.com',
          '\$A12345@valid-email.com',
          '!def!xyz%abc@valid-email.com',
          '_somename@valid-email.com',
          '"Some\\Body"@valid-email.com'
        ]

        for v in valid_emails:
            res = validators.EmailCheck(v)
            self.assertEqual(res, v)

</source>
</class>

<class classid="4" nclones="2" nlines="24" similarity="80">
<source file="systems/Mailpile-1.0.0rc6/mailpile/plugins/vcard_gnupg.py" startline="129" endline="154" pcid="1037">
    def vcards_per_key(cls, keys, vcards):
        """This creates on VCards per key"""
        new_vcards = []
        for key_id, key in keys.iteritems():
            if cls.key_is_useless(key):
                continue
            vcls = [cls.key_vcl(key_id, key)]
            emails = []
            for uid in key.get('uids', []):
                if uid.get('email'):
                    vcls.append(VCardLine(name='email', value=uid['email']))
                    emails.append(uid['email'])
                if uid.get('name'):
                    name = uid['name']
                    vcls.append(VCardLine(name='fn', value=name))
            if emails:
                # This is us taking care to only create one card for each
                # set of e-mail addresses.
                card = MailpileVCard(*vcls)
                card.add(VCardLine(name='x-gpg-mrgid', value=key_id))
                for email in emails:
                    if email not in vcards:
                        vcards[email] = card
                new_vcards.append(card)
        return new_vcards

</source>
<source file="systems/Mailpile-1.0.0rc6/mailpile/plugins/vcard_gnupg.py" startline="156" endline="184" pcid="1038">
    def vcards_merged(cls, keys, vcards):
        """This creates merged VCards, grouping by uid/e-mail and key"""
        new_vcards = []
        for key_id, key in keys.iteritems():
            if cls.key_is_useless(key):
                continue
            vcls = [cls.key_vcl(key_id, key)]
            card = None
            emails = []
            for uid in key.get('uids', []):
                if uid.get('email'):
                    vcls.append(VCardLine(name='email', value=uid['email']))
                    card = card or vcards.get(uid['email'])
                    emails.append(uid['email'])
                if uid.get('name'):
                    name = uid['name']
                    vcls.append(VCardLine(name='fn', value=name))
            if card and emails:
                card.add(*vcls)
            elif emails:
                # This is us taking care to only create one card for each
                # set of e-mail addresses.
                card = MailpileVCard(*vcls)
                card.add(VCardLine(name='x-gpg-mrgid', value=key_id))
                for email in emails:
                    vcards[email] = card
                new_vcards.append(card)
        return new_vcards

</source>
</class>

<class classid="5" nclones="2" nlines="15" similarity="100">
<source file="systems/Mailpile-1.0.0rc6/mailpile/plugins/vcard_libravatar.py" startline="44" endline="66" pcid="1061">
    def _want_update(self):
        def _jittery_time():
            # This introduces 5 hours of jitter into the time check
            # below, biased towards extending the delay by an average
            # of 1.5 hours each time. This is mostly done to spread
            # out the load on the Libravatar server over time, as to
            # begin with all contacts will be checked at roughly the
            # same time.
            return time.time() + random.randrange(-14400, 3600)

        want = []
        vcards = self.session.config.vcards
        for vcard in vcards.find_vcards([], kinds=vcards.KINDS_PEOPLE):
            try:
                ts = int(vcard.get(self.VCARD_TS).value)
            except IndexError:
                ts = 0
            if ts < _jittery_time() - (self.config.interval * 24 * 3600):
                want.append(vcard)
            if len(want) >= self.config.batch:
                break
        return want

</source>
<source file="systems/Mailpile-1.0.0rc6/mailpile/plugins/vcard_gravatar.py" startline="46" endline="67" pcid="1275">
    def _want_update(self):
        def _jittery_time():
            # This introduces 5 hours of jitter into the time check below,
            # biased towards extending the delay by an average of 1.5 hours
            # each time. This is mostly done to spread out the load on the
            # Gravatar server over time, as to begin with all contacts will
            # be checked at roughly the same time.
            return time.time() + random.randrange(-14400, 3600)

        want = []
        vcards = self.session.config.vcards
        for vcard in vcards.find_vcards([], kinds=vcards.KINDS_PEOPLE):
            try:
                ts = int(vcard.get(self.VCARD_TS).value)
            except IndexError:
                ts = 0
            if ts < _jittery_time() - (self.config.interval * 24 * 3600):
                want.append(vcard)
            if len(want) >= self.config.batch:
                break
        return want

</source>
</class>

<class classid="6" nclones="2" nlines="25" similarity="92">
<source file="systems/Mailpile-1.0.0rc6/mailpile/plugins/vcard_libravatar.py" startline="73" endline="111" pcid="1064">
    def check_libravatar(self, vcard, email):
        img = vcf = json = None
        for vcl in vcard.get_all('email'):
            digest = mailpile.util.md5_hex(vcl.value.lower())
            try:
                if mailpile.util.QUITTING:
                    return None, None, None, None
                if not img:
                    img = self._get(('%s/avatar/%s?s=%s&r=%s&d=404'
                                     ) % (self.config.url,
                                          digest,
                                          self.config.size,
                                          self.config.rating))

                # FIXME
                #if not vcf:
                #    vcf = self._get('%s/%s.vcf' % (self.config.url, digest))

                # FIXME
                #if not json:
                #    json = self._get('%s/%s.json' % (self.config.url, digest))

                if img or vcf or json:
                    email = vcl.value
            except IOError:
                pass

        if (self.config.default != '404') and not img:
            try:
                img = self._get(('%s/avatar/%s?s=%s&d=%s'
                                 ) % (self.config.url,
                                      mailpile.util.md5_hex(email.lower()),
                                      self.config.size,
                                      self.config.default))
            except IOError:
                pass

        return email, img, vcf, json

</source>
<source file="systems/Mailpile-1.0.0rc6/mailpile/plugins/vcard_gravatar.py" startline="74" endline="112" pcid="1278">
    def check_gravatar(self, vcard, email):
        img = vcf = json = None
        for vcl in vcard.get_all('email'):
            digest = md5_hex(vcl.value.lower())
            try:
                if mailpile.util.QUITTING:
                    return None, None, None, None
                if not img:
                    img = self._get(('%s/avatar/%s.jpg?s=%s&r=%s&d=404'
                                     ) % (self.config.url,
                                          digest,
                                          self.config.size,
                                          self.config.rating))

                # FIXME
                #if not vcf:
                #    vcf = self._get('%s/%s.vcf' % (self.config.url, digest))

                # FIXME
                #if not json:
                #    json = self._get('%s/%s.json' % (self.config.url, digest))

                if img or vcf or json:
                    email = vcl.value
            except IOError:
                pass

        if (self.config.default != '404') and not img:
            try:
                img = self._get(('%s/avatar/%s.jpg?s=%s&d=%s'
                                 ) % (self.config.url,
                                      md5_hex(email.lower()),
                                      self.config.size,
                                      self.config.default))
            except IOError:
                pass

        return email, img, vcf, json

</source>
</class>

<class classid="7" nclones="2" nlines="28" similarity="100">
<source file="systems/Mailpile-1.0.0rc6/mailpile/plugins/vcard_libravatar.py" startline="112" endline="153" pcid="1065">
    def get_vcards(self):
        if not self.config.active:
            return []

        def _b64(data):
            return data.encode('base64').replace('\n', '')

        results = []
        for contact in self._want_update():
            email = contact.email
            if not email:
                continue

            if mailpile.util.QUITTING:
                return []

            vcard = MailpileVCard(VCardLine(name=self.VCARD_TS,
                                            value=int(time.time())))
            email, img, gcard, gjson = self.check_libravatar(contact, email)

            if gcard:
                # FIXME: Is this boring?
                # vcard.load(data=gcard)
                pass

            if gjson:
                # FIXME: This is less boring!
                pass

            if img:
                vcard.add(VCardLine(
                    name='photo',
                    value='data:image/jpeg;base64,%s' % _b64(img),
                    mediatype='image/jpeg'
                ))

            if gcard or gjson or img:
                vcard.add(VCardLine(name='email', value=email))
                results.append(vcard)
        return results


</source>
<source file="systems/Mailpile-1.0.0rc6/mailpile/plugins/vcard_gravatar.py" startline="113" endline="154" pcid="1279">
    def get_vcards(self):
        if not self.config.active:
            return []

        def _b64(data):
            return data.encode('base64').replace('\n', '')

        results = []
        for contact in self._want_update():
            email = contact.email
            if not email:
                continue

            if mailpile.util.QUITTING:
                return []

            vcard = MailpileVCard(VCardLine(name=self.VCARD_TS,
                                            value=int(time.time())))
            email, img, gcard, gjson = self.check_gravatar(contact, email)

            if gcard:
                # FIXME: Is this boring?
                # vcard.load(data=gcard)
                pass

            if gjson:
                # FIXME: This is less boring!
                pass

            if img:
                vcard.add(VCardLine(
                    name='photo',
                    value='data:image/jpeg;base64,%s' % _b64(img),
                    mediatype='image/jpeg'
                ))

            if gcard or gjson or img:
                vcard.add(VCardLine(name='email', value=email))
                results.append(vcard)
        return results


</source>
</class>

<class classid="8" nclones="2" nlines="36" similarity="91">
<source file="systems/Mailpile-1.0.0rc6/mailpile/plugins/compose.py" startline="553" endline="596" pcid="1094">
    def command(self):
        session, config, idx = self.session, self.session.config, self._idx()
        reply_all = False
        ephemeral = False
        args = list(self.args)
        if not args:
            args = ["=%s" % x for x in self.data.get('mid', [])]
            ephemeral = truthy((self.data.get('ephemeral') or [False])[0])
            reply_all = truthy((self.data.get('reply_all') or [False])[0])
        else:
            while args:
                if args[0].lower() == 'all':
                    reply_all = args.pop(0) or True
                elif args[0].lower() == 'ephemeral':
                    ephemeral = args.pop(0) or True
                else:
                    break

        # Make sure GET does not change backend state, allow on CLI.
        if self.data.get('_method', 'POST') != 'POST':
            ephemeral = True

        refs = [Email(idx, i) for i in self._choose_messages(args)]
        if refs:
            try:
                cid = self.data.get('cid', [None])[0]
                email, ephemeral = self.CreateReply(idx, session, refs,
                                                    self._new_msgid(),
                                                    reply_all=reply_all,
                                                    cid=cid,
                                                    ephemeral=ephemeral)
            except NoFromAddressError:
                return self._error(_('You must configure a '
                                     'From address first.'))

            if not ephemeral:
                self._track_action('replied', refs)
                self._tag_blank([email])

            return self._edit_messages([email], ephemeral=ephemeral)
        else:
            return self._error(_('No message found'))


</source>
<source file="systems/Mailpile-1.0.0rc6/mailpile/plugins/compose.py" startline="658" endline="702" pcid="1096">
    def command(self):
        session, config, idx = self.session, self.session.config, self._idx()

        with_atts = False
        ephemeral = False
        args = list(self.args)
        if not args:
            args = ["=%s" % x for x in self.data.get('mid', [])]
            ephemeral = truthy((self.data.get('ephemeral') or [False])[0])
            with_atts = truthy((self.data.get('atts') or [False])[0])
        else:
            while args:
                if args[0].lower() == 'att':
                    with_atts = args.pop(0) or True
                elif args[0].lower() == 'ephemeral':
                    ephemeral = args.pop(0) or True
                else:
                    break

        # Make sure GET does not change backend state
        if self.data.get('_method', 'POST') != 'POST':
            ephemeral = True

        if ephemeral and with_atts:
            raise UsageError(_('Sorry, ephemeral messages cannot have '
                               'attachments at this time.'))

        refs = [Email(idx, i) for i in self._choose_messages(args)]
        if refs:
            cid = self.data.get('cid', [None])[0]
            email, ephemeral = self.CreateForward(idx, session, refs,
                                                  self._new_msgid(),
                                                  with_atts=with_atts,
                                                  cid=cid,
                                                  ephemeral=ephemeral)

            if not ephemeral:
                self._track_action('fwded', refs)
                self._tag_blank([email])

            return self._edit_messages([email], ephemeral=ephemeral)
        else:
            return self._error(_('No message found'))


</source>
</class>

<class classid="9" nclones="2" nlines="14" similarity="73">
<source file="systems/Mailpile-1.0.0rc6/mailpile/plugins/gui.py" startline="74" endline="89" pcid="1213">
    def _state_need_setup(self, in_state):
        if in_state:
            self._do('set_status', status='attention')
            self._do('set_status_display',
                id="logged-in",
                color='#333',
                icon='image:new-setup',
                title=_('Brand new installation!'),
                details=(
                    _('This appears to be a new installation of Mailpile!')
                    + '\n' +
                    _('You need to choose a language, password and privacy policy.')
                    + '\n' +
                    _('To proceed, open Mailpile in your web browser.')))
            self._do('set_item', id='open', label=_("Get Started!"))

</source>
<source file="systems/Mailpile-1.0.0rc6/mailpile/plugins/gui.py" startline="90" endline="103" pcid="1214">
    def _state_please_log_in(self, in_state):
        if in_state:
            self._do('set_status', status='attention')
            self._do('set_status_display',
                id="logged-in",
                color='#333',
                icon='image:logged-out',
                title=_('Not logged in'),
                details=(_('Your data is stored encrypted and is'
                           ' inaccessible until you log in.')
                         + '\n' +
                         _('To proceed, open Mailpile in your web browser.')))
            self._do('set_item', id='open', label=_("Log In"))

</source>
</class>

<class classid="10" nclones="2" nlines="13" similarity="92">
<source file="systems/Mailpile-1.0.0rc6/mailpile/plugins/__init__.py" startline="505" endline="518" pcid="1365">

    def register_config_variables(self, *args):
        self._compat_check()
        args = list(args)
        rules = args.pop(-1)
        dest = mailpile.config.defaults.CONFIG_RULES
        path = '/'.join(args)
        for arg in args:
            dest = dest[arg][-1]
        for rname, rule in rules.iteritems():
            if rname in dest:
                raise PluginError('Variable already exist: %s/%s' % (path, rname))
            else:
                dest[rname] = rule
</source>
<source file="systems/Mailpile-1.0.0rc6/mailpile/plugins/__init__.py" startline="519" endline="535" pcid="1366">

    def register_config_section(self, *args):
        self._compat_check()
        args = list(args)
        rules = args.pop(-1)
        rname = args.pop(-1)
        dest = mailpile.config.defaults.CONFIG_RULES
        path = '/'.join(args)
        for arg in args:
            dest = dest[arg][-1]
        if rname in dest:
            raise PluginError('Section already exist: %s/%s' % (path, rname))
        else:
            dest[rname] = rules


    ##[ Pluggable message transformations ]###################################
</source>
</class>

<class classid="11" nclones="2" nlines="10" similarity="70">
<source file="systems/Mailpile-1.0.0rc6/mailpile/plugins/__init__.py" startline="541" endline="551" pcid="1367">

    def _txf_in(self, transforms, config, msg, kwargs):
        matched = 0
        for name in sorted(transforms.keys()):
            txf = transforms[name](config)
            msg, match, cont = txf.TransformIncoming(msg, **kwargs)
            if match:
                matched += 1
            if not cont:
                break
        return msg, matched
</source>
<source file="systems/Mailpile-1.0.0rc6/mailpile/plugins/__init__.py" startline="552" endline="562" pcid="1368">

    def _txf_out(self, transforms, cfg, s, r, msg, kwa):
        matched = 0
        for name in sorted(transforms.keys()):
            txf = transforms[name](cfg)
            s, r, msg, match, cont = txf.TransformOutgoing(s, r, msg, **kwa)
            if match:
                matched += 1
            if not cont:
                break
        return s, r, msg, matched
</source>
</class>

<class classid="12" nclones="2" nlines="13" similarity="71">
<source file="systems/Mailpile-1.0.0rc6/mailpile/config/paths.py" startline="51" endline="79" pcid="1710">
def DEFAULT_SHARED_DATADIR():
    # IMPORTANT: This code is duplicated in mailpile-admin.py.
    #            If it needs changing please change both places!
    env_share = os.getenv('MAILPILE_SHARED')
    if env_share is not None:
        return env_share

    # Check if we are running in a virtual env
    # http://stackoverflow.com/questions/1871549/python-determine-if-running-inside-virtualenv
    # We must also check that we are installed in the virtual env,
    # not just that we are running in a virtual env.
    if ((hasattr(sys, 'real_prefix') or hasattr(sys, 'base_prefix'))
            and __file__.startswith(sys.prefix)):
        return os.path.join(sys.prefix, 'share', 'mailpile')

    # Check if we've been installed to /usr/local (or equivalent)
    usr_local = os.path.join(sys.prefix, 'local')
    if __file__.startswith(usr_local):
        return os.path.join(usr_local, 'share', 'mailpile')

    # Check if we are in /usr/ (sys.prefix)
    if __file__.startswith(sys.prefix):
        return os.path.join(sys.prefix, 'share', 'mailpile')

    # Else assume dev mode, source tree layout
    return os.path.join(
        os.path.dirname(__file__), '..', '..', 'shared-data')


</source>
<source file="systems/Mailpile-1.0.0rc6/shared-data/multipile/mailpile-admin.py" startline="321" endline="353" pcid="2506">
def get_mailpile_shared_datadir():
    # IMPORTANT: This code is duplicated in mailpile/config.py.
    #            If it needs changing please change both places!
    #
    # Why? The code is duplicated here, so when running in CGI mode
    # we don't have to load & parse the full Mailpile app just to
    # find this path.
    #
    env_share = os.getenv('MAILPILE_SHARED')
    if env_share is not None:
        return env_share

    # Check if we are running in a virtual env
    # http://stackoverflow.com/questions/1871549/python-determine-if-running-inside-virtualenv
    # We must also check that we are installed in the virtual env,
    # not just that we are running in a virtual env.
    if (hasattr(sys, 'real_prefix') or hasattr(sys, 'base_prefix')) and __file__.startswith(sys.prefix):
        return os.path.join(sys.prefix, 'share', 'mailpile')

    # Check if we've been installed to /usr/local (or equivalent)
    usr_local = os.path.join(sys.prefix, 'local')
    if __file__.startswith(usr_local):
        return os.path.join(usr_local, 'share', 'mailpile')

    # Check if we are in /usr/ (sys.prefix)
    if __file__.startswith(sys.prefix):
        return os.path.join(sys.prefix, 'share', 'mailpile')

    # Else assume dev mode, source tree layout
    # NOTE: This differs from mailpile/config.py!
    return os.path.realpath(os.path.join(os.path.dirname(__file__), '..'))


</source>
</class>

<class classid="13" nclones="3" nlines="11" similarity="75">
<source file="systems/Mailpile-1.0.0rc6/mailpile/www/jinjaextensions.py" startline="477" endline="493" pcid="2160">
    def _show_message_signature(self, status):
        # This avoids crashes when attributes are missing.
        try:
            if status.startswith('hack the planet'):
                pass
        except UndefinedError:
            status = ''

        color, icon, text, message = self._STATUS_SIGNATURE.get(status, self._DEFAULT_SIGNATURE)

        return {
            'color': color,
            'icon': icon,
            'text': text,
            'message': message
        }

</source>
<source file="systems/Mailpile-1.0.0rc6/mailpile/www/jinjaextensions.py" startline="607" endline="621" pcid="2163">
    def _show_crypto_policy(self, policy):
        # This avoids crashes when attributes are missing.
        try:
            if policy.startswith('hack the planet'):
                pass
        except UndefinedError:
            policy = ''

        text, message = self._CRYPTO_POLICY.get(policy, self._DEFAULT_CRYPTO_POLICY)

        return {
            'text': text,
            'message': message
        }

</source>
<source file="systems/Mailpile-1.0.0rc6/mailpile/www/jinjaextensions.py" startline="566" endline="582" pcid="2162">
    def _show_message_encryption(self, status):
        # This avoids crashes when attributes are missing.
        try:
            if status.startswith('hack the planet'):
                pass
        except UndefinedError:
            status = ''

        color, icon, text, message = self._STATUS_ENCRYPTION.get(status, self._DEFAULT_ENCRYPTION)

        return {
            'color': color,
            'icon': icon,
            'text': text,
            'message': message
        }

</source>
</class>

<class classid="14" nclones="2" nlines="16" similarity="82">
<source file="systems/Mailpile-1.0.0rc6/packages/scripts/kite-runner.py" startline="332" endline="348" pcid="2566">
def kite_runner_main(args):
    try:
        bb = BuildbotServer()
        bb.parse_args(args).run()
    except (getopt.GetoptError, ArgumentError):
        print(__doc__)
        traceback.print_exc()
        sys.exit(1)
    except (RuntimeError, KeyboardInterrupt):
        print('Quitting...')
    except Exception:
        traceback.print_exc()
        sys.exit(2)
    finally:
        bb.cleanup()


</source>
<source file="systems/Mailpile-1.0.0rc6/packages/scripts/build-controller.py" startline="128" endline="146" pcid="2580">
    def Main(cls, args):
        bc = None
        try:
            bc = cls()
            bc.parse_args(args).run()
        except (getopt.GetoptError, ArgumentError):
            print(__doc__)
            traceback.print_exc()
            sys.exit(1)
        except (RuntimeError, KeyboardInterrupt):
            print('Quitting...')
        except Exception:
            traceback.print_exc()
            sys.exit(2)
        finally:
            if bc:
                bc.cleanup()


</source>
</class>

</clones>
