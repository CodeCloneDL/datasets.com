<clones>
<systeminfo processor="nicad6" system="Sick-Beard-build-507" granularity="functions-blind" threshold="30%" minlines="10" maxlines="2500"/>
<cloneinfo npcs="4823" npairs="145"/>
<runinfo ncompares="409567" cputime="252137"/>
<classinfo nclasses="49"/>

<class classid="1" nclones="2" nlines="10" similarity="80">
<source file="systems/Sick-Beard-build-507/lib/growl/gntp.py" startline="192" endline="207" pcid="26">
	def encode(self):
		'''
		Encode a GNTP Message
		@return: GNTP Message ready to be sent
		'''
		self.validate()
		SEP = u': '
		EOL = u'\r\n'
		
		message = self.format_info() + EOL
		#Headers
		for k,v in self.headers.iteritems():
			message += k.encode('utf8') + SEP + str(v).encode('utf8') + EOL
		
		message += EOL
		return message
</source>
<source file="systems/Sick-Beard-build-507/lib/growl/gntp.py" startline="355" endline="371" pcid="34">
	def encode(self):
		'''
		Encode a GNTP Notification Message
		@return: GNTP Notification Message ready to be sent
		'''
		self.validate()
		SEP = u': '
		EOL = u'\r\n'
		
		message = self.format_info() + EOL
		#Headers
		for k,v in self.headers.iteritems():
			message += k + SEP + unicode(v) + EOL
		
		message += EOL
		return message.encode('utf-8')

</source>
</class>

<class classid="2" nclones="2" nlines="15" similarity="87">
<source file="systems/Sick-Beard-build-507/lib/growl/gntp.py" startline="246" endline="267" pcid="29">
	def decode(self,data,password):
		'''
		Decode existing GNTP Registration message
		@param data: Message to decode.
		'''
		self.raw = data
		parts = self.raw.split('\r\n\r\n')
		self.info = self.parse_info(data)
		self.validate_password(password)
		self.headers = self.parse_dict(parts[0])
		
		for i,part in enumerate(parts):
			if i==0: continue  #Skip Header
			if part.strip()=='': continue
			notice = self.parse_dict(part)
			if notice.get('Notification-Name',False):
				self.notifications.append(notice)
			elif notice.get('Identifier',False):
				notice['Data'] = self._decode_binary(part,notice)
				#open('register.png','wblol').write(notice['Data'])
				self.resources[ notice.get('Identifier') ] = notice
		
</source>
<source file="systems/Sick-Beard-build-507/lib/growl/gntp.py" startline="336" endline="354" pcid="33">
	def decode(self,data,password):
		'''
		Decode existing GNTP Notification message
		@param data: Message to decode.
		'''
		self.raw = data
		parts = self.raw.split('\r\n\r\n')
		self.info = self.parse_info(data)
		self.validate_password(password)
		self.headers = self.parse_dict(parts[0])
		
		for i,part in enumerate(parts):
			if i==0: continue  #Skip Header
			if part.strip()=='': continue
			notice = self.parse_dict(part)
			if notice.get('Identifier',False):
				notice['Data'] = self._decode_binary(part,notice)
				#open('notice.png','wblol').write(notice['Data'])
				self.resources[ notice.get('Identifier') ] = notice
</source>
</class>

<class classid="3" nclones="2" nlines="20" similarity="80">
<source file="systems/Sick-Beard-build-507/lib/profilehooks.py" startline="333" endline="354" pcid="151">
    def print_stats(self):
        """Print profile information to sys.stdout."""
        funcname = self.fn.__name__
        filename = self.fn.func_code.co_filename
        lineno = self.fn.func_code.co_firstlineno
        print
        print "*** PROFILER RESULTS ***"
        print "%s (%s:%s)" % (funcname, filename, lineno)
        print "function called %d times" % self.ncalls,
        if self.skipped:
            print "(%d calls not profiled)" % self.skipped
        else:
            print
        print
        stats = self.stats
        if self.filename:
            stats.dump_stats(self.filename)
        if not self.dirs:
            stats.strip_dirs()
        stats.sort_stats(*self.sort)
        stats.print_stats(self.entries)

</source>
<source file="systems/Sick-Beard-build-507/lib/profilehooks.py" startline="432" endline="459" pcid="156">
        def atexit(self):
            """Stop profiling and print profile information to sys.stderr.

            This function is registered as an atexit hook.
            """
            self.profiler.close()
            funcname = self.fn.__name__
            filename = self.fn.func_code.co_filename
            lineno = self.fn.func_code.co_firstlineno
            print
            print "*** PROFILER RESULTS ***"
            print "%s (%s:%s)" % (funcname, filename, lineno)
            print "function called %d times" % self.ncalls,
            if self.skipped:
                print "(%d calls not profiled)" % self.skipped
            else:
                print
            print
            stats = hotshot.stats.load(self.logfilename)
            # hotshot.stats.load takes ages, and the .prof file eats megabytes, but
            # a saved stats object is small and fast
            if self.filename:
                stats.dump_stats(self.filename)
            # it is best to save before strip_dirs
            stats.strip_dirs()
            stats.sort_stats('cumulative', 'time', 'calls')
            stats.print_stats(40)

</source>
</class>

<class classid="4" nclones="2" nlines="60" similarity="91">
<source file="systems/Sick-Beard-build-507/lib/pythontwitter/__init__.py" startline="116" endline="222" pcid="834">
  def __init__(self,
               created_at=None,
               favorited=None,
               favorite_count=None,
               id=None,
               text=None,
               location=None,
               user=None,
               in_reply_to_screen_name=None,
               in_reply_to_user_id=None,
               in_reply_to_status_id=None,
               truncated=None,
               source=None,
               now=None,
               urls=None,
               user_mentions=None,
               hashtags=None,
               media=None,
               geo=None,
               place=None,
               coordinates=None,
               contributors=None,
               retweeted=None,
               retweeted_status=None,
               current_user_retweet=None,
               retweet_count=None,
               possibly_sensitive=None,
               scopes=None,
               withheld_copyright=None,
               withheld_in_countries=None,
               withheld_scope=None):
    '''An object to hold a Twitter status message.

    This class is normally instantiated by the twitter.Api class and
    returned in a sequence.

    Note: Dates are posted in the form "Sat Jan 27 04:17:38 +0000 2007"

    Args:
      created_at:
        The time this status message was posted. [Optional]
      favorited:
        Whether this is a favorite of the authenticated user. [Optional]
      favorite_count:
        Number of times this status message has been favorited. [Optional]
      id:
        The unique id of this status message. [Optional]
      text:
        The text of this status message. [Optional]
      location:
        the geolocation string associated with this message. [Optional]
      relative_created_at:
        A human readable string representing the posting time. [Optional]
      user:
        A twitter.User instance representing the person posting the
        message. [Optional]
      now:
        The current time, if the client chooses to set it.
        Defaults to the wall clock time. [Optional]
      urls:
      user_mentions:
      hashtags:
      geo:
      place:
      coordinates:
      contributors:
      retweeted:
      retweeted_status:
      current_user_retweet:
      retweet_count:
      possibly_sensitive:
      scopes:
      withheld_copyright:
      withheld_in_countries:
      withheld_scope:
    '''
    self.created_at = created_at
    self.favorited = favorited
    self.favorite_count = favorite_count
    self.id = id
    self.text = text
    self.location = location
    self.user = user
    self.now = now
    self.in_reply_to_screen_name = in_reply_to_screen_name
    self.in_reply_to_user_id = in_reply_to_user_id
    self.in_reply_to_status_id = in_reply_to_status_id
    self.truncated = truncated
    self.retweeted = retweeted
    self.source = source
    self.urls = urls
    self.user_mentions = user_mentions
    self.hashtags = hashtags
    self.media = media
    self.geo = geo
    self.place = place
    self.coordinates = coordinates
    self.contributors = contributors
    self.retweeted_status = retweeted_status
    self.current_user_retweet = current_user_retweet
    self.retweet_count = retweet_count
    self.possibly_sensitive = possibly_sensitive
    self.scopes = scopes
    self.withheld_copyright = withheld_copyright
    self.withheld_in_countries = withheld_in_countries
    self.withheld_scope = withheld_scope

</source>
<source file="systems/Sick-Beard-build-507/lib/pythontwitter/__init__.py" startline="795" endline="852" pcid="895">
    user.description
    user.profile_image_url
    user.profile_background_tile
    user.profile_background_image_url
    user.profile_sidebar_fill_color
    user.profile_background_color
    user.profile_link_color
    user.profile_text_color
    user.protected
    user.utc_offset
    user.time_zone
    user.url
    user.status
    user.statuses_count
    user.followers_count
    user.friends_count
    user.favourites_count
    user.geo_enabled
    user.verified
    user.lang
    user.notifications
    user.contributors_enabled
    user.created_at
    user.listed_count
  '''
  def __init__(self,
               id=None,
               name=None,
               screen_name=None,
               location=None,
               description=None,
               profile_image_url=None,
               profile_background_tile=None,
               profile_background_image_url=None,
               profile_sidebar_fill_color=None,
               profile_background_color=None,
               profile_link_color=None,
               profile_text_color=None,
               protected=None,
               utc_offset=None,
               time_zone=None,
               followers_count=None,
               friends_count=None,
               statuses_count=None,
               favourites_count=None,
               url=None,
               status=None,
               geo_enabled=None,
               verified=None,
               lang=None,
               notifications=None,
               contributors_enabled=None,
               created_at=None,
               listed_count=None):
    self.id = id
    self.name = name
    self.screen_name = screen_name
    self.location = location
</source>
</class>

<class classid="5" nclones="2" nlines="60" similarity="82">
<source file="systems/Sick-Beard-build-507/lib/pythontwitter/__init__.py" startline="623" endline="691" pcid="893">
             self.scopes == other.scopes and \
             self.withheld_copyright == other.withheld_copyright and \
             self.withheld_in_countries == other.withheld_in_countries and \
             self.withheld_scope == other.withheld_scope
    except AttributeError:
      return False

  def __str__(self):
    '''A string representation of this twitter.Status instance.

    The return value is the same as the JSON string representation.

    Returns:
      A string representation of this twitter.Status instance.
    '''
    return self.AsJsonString()

  def AsJsonString(self):
    '''A JSON string representation of this twitter.Status instance.

    Returns:
      A JSON string representation of this twitter.Status instance
   '''
    return simplejson.dumps(self.AsDict(), sort_keys=True)

  def AsDict(self):
    '''A dict representation of this twitter.Status instance.

    The return value uses the same key names as the JSON representation.

    Return:
      A dict representing this twitter.Status instance
    '''
    data = {}
    if self.created_at:
      data['created_at'] = self.created_at
    if self.favorited:
      data['favorited'] = self.favorited
    if self.favorite_count:
      data['favorite_count'] = self.favorite_count
    if self.id:
      data['id'] = self.id
    if self.text:
      data['text'] = self.text
    if self.location:
      data['location'] = self.location
    if self.user:
      data['user'] = self.user.AsDict()
    if self.in_reply_to_screen_name:
      data['in_reply_to_screen_name'] = self.in_reply_to_screen_name
    if self.in_reply_to_user_id:
      data['in_reply_to_user_id'] = self.in_reply_to_user_id
    if self.in_reply_to_status_id:
      data['in_reply_to_status_id'] = self.in_reply_to_status_id
    if self.truncated is not None:
      data['truncated'] = self.truncated
    if self.retweeted is not None:
      data['retweeted'] = self.retweeted
    if self.favorited is not None:
      data['favorited'] = self.favorited
    if self.source:
      data['source'] = self.source
    if self.geo:
      data['geo'] = self.geo
    if self.place:
      data['place'] = self.place
    if self.coordinates:
      data['coordinates'] = self.coordinates
    if self.contributors:
</source>
<source file="systems/Sick-Beard-build-507/lib/pythontwitter/__init__.py" startline="1349" endline="1414" pcid="956">
  def __eq__(self, other):
    try:
      return other and \
             self.id == other.id and \
             self.name == other.name and \
             self.screen_name == other.screen_name and \
             self.location == other.location and \
             self.description == other.description and \
             self.profile_image_url == other.profile_image_url and \
             self.profile_background_tile == other.profile_background_tile and \
             self.profile_background_image_url == other.profile_background_image_url and \
             self.profile_sidebar_fill_color == other.profile_sidebar_fill_color and \
             self.profile_background_color == other.profile_background_color and \
             self.profile_link_color == other.profile_link_color and \
             self.profile_text_color == other.profile_text_color and \
             self.protected == other.protected and \
             self.utc_offset == other.utc_offset and \
             self.time_zone == other.time_zone and \
             self.url == other.url and \
             self.statuses_count == other.statuses_count and \
             self.followers_count == other.followers_count and \
             self.favourites_count == other.favourites_count and \
             self.friends_count == other.friends_count and \
             self.status == other.status and \
             self.geo_enabled == other.geo_enabled and \
             self.verified == other.verified and \
             self.lang == other.lang and \
             self.notifications == other.notifications and \
             self.contributors_enabled == other.contributors_enabled and \
             self.created_at == other.created_at and \
             self.listed_count == other.listed_count

    except AttributeError:
      return False

  def __str__(self):
    '''A string representation of this twitter.User instance.

    The return value is the same as the JSON string representation.

    Returns:
      A string representation of this twitter.User instance.
    '''
    return self.AsJsonString()

  def AsJsonString(self):
    '''A JSON string representation of this twitter.User instance.

    Returns:
      A JSON string representation of this twitter.User instance
   '''
    return simplejson.dumps(self.AsDict(), sort_keys=True)

  def AsDict(self):
    '''A dict representation of this twitter.User instance.

    The return value uses the same key names as the JSON representation.

    Return:
      A dict representing this twitter.User instance
    '''
    data = {}
    if self.id:
      data['id'] = self.id
    if self.name:
      data['name'] = self.name
</source>
</class>

<class classid="6" nclones="2" nlines="26" similarity="72">
<source file="systems/Sick-Beard-build-507/lib/pythontwitter/__init__.py" startline="1475" endline="1498" pcid="958">

    Returns:
      A twitter.User instance
    '''
    if 'status' in data:
      status = Status.NewFromJsonDict(data['status'])
    else:
      status = None
    return User(id=data.get('id', None),
                name=data.get('name', None),
                screen_name=data.get('screen_name', None),
                location=data.get('location', None),
                description=data.get('description', None),
                statuses_count=data.get('statuses_count', None),
                followers_count=data.get('followers_count', None),
                favourites_count=data.get('favourites_count', None),
                friends_count=data.get('friends_count', None),
                profile_image_url=data.get('profile_image_url_https', data.get('profile_image_url', None)),
                profile_background_tile = data.get('profile_background_tile', None),
                profile_background_image_url = data.get('profile_background_image_url', None),
                profile_sidebar_fill_color = data.get('profile_sidebar_fill_color', None),
                profile_background_color = data.get('profile_background_color', None),
                profile_link_color = data.get('profile_link_color', None),
                profile_text_color = data.get('profile_text_color', None),
</source>
<source file="systems/Sick-Beard-build-507/sickbeard/metadata/generic.py" startline="57" endline="91" pcid="4251">
    def __init__(self,
                 show_metadata=False,
                 episode_metadata=False,
                 fanart=False,
                 poster=False,
                 banner=False,
                 episode_thumbnails=False,
                 season_posters=False,
                 season_banners=False,
                 season_all_poster=False,
                 season_all_banner=False):

        self.name = "Generic"

        self._ep_nfo_extension = "nfo"
        self._show_metadata_filename = "tvshow.nfo"

        self.fanart_name = "fanart.jpg"
        self.poster_name = "poster.jpg"
        self.banner_name = "banner.jpg"

        self.season_all_poster_name = "season-all-poster.jpg"
        self.season_all_banner_name = "season-all-banner.jpg"

        self.show_metadata = show_metadata
        self.episode_metadata = episode_metadata
        self.fanart = fanart
        self.poster = poster
        self.banner = banner
        self.episode_thumbnails = episode_thumbnails
        self.season_posters = season_posters
        self.season_banners = season_banners
        self.season_all_poster = season_all_poster
        self.season_all_banner = season_all_banner

</source>
</class>

<class classid="7" nclones="4" nlines="38" similarity="70">
<source file="systems/Sick-Beard-build-507/lib/pythontwitter/__init__.py" startline="2543" endline="2631" pcid="1025">
      count:
        Number of results to return.  Default is 20
        [Optional]
      include_entities:
        If True, each tweet will include a node called "entities,".
        This node offers a variety of metadata about the tweet in a
        discrete structure, including: user_mentions, urls, and hashtags.
        [Optional]

    Returns:
      A sequence of twitter.User instances, one for each message containing
      the term
    '''
    # Build request parameters
    parameters = {}

    if term is not None:
      parameters['q'] = term

    if include_entities:
      parameters['include_entities'] = 1

    try:
      parameters['count'] = int(count)
    except:
      raise TwitterError("count must be an integer")

    # Make and send requests
    url  = '%s/users/search.json' % self.base_url
    json = self._FetchUrl(url, parameters=parameters)
    data = self._ParseAndCheckTwitter(json)
    return [User.NewFromJsonDict(x) for x in data]

  def GetTrendsCurrent(self, exclude=None):
    '''Get the current top trending topics (global)

    Args:
      exclude:
        Appends the exclude parameter as a request parameter.
        Currently only exclude=hashtags is supported. [Optional]

    Returns:
      A list with 10 entries. Each entry contains a trend.
    '''
    return self.GetTrendsWoeid(id=1, exclude=exclude)

  def GetTrendsWoeid(self, id, exclude=None):
    '''Return the top 10 trending topics for a specific WOEID, if trending
    information is available for it.

    Args:
      woeid:
        the Yahoo! Where On Earth ID for a location.
      exclude:
        Appends the exclude parameter as a request parameter.
        Currently only exclude=hashtags is supported. [Optional]

    Returns:
      A list with 10 entries. Each entry contains a trend.
    '''
    url  = '%s/trends/place.json' % (self.base_url)
    parameters = {'id': id}

    if exclude:
      parameters['exclude'] = exclude

    json = self._FetchUrl(url, parameters=parameters)
    data = self._ParseAndCheckTwitter(json)

    trends = []
    timestamp = data[0]['as_of']

    for trend in data[0]['trends']:
        trends.append(Trend.NewFromJsonDict(trend, timestamp = timestamp))
    return trends

  def GetHomeTimeline(self,
                         count=None,
                         since_id=None,
                         max_id=None,
                         trim_user=False,
                         exclude_replies=False,
                         contributor_details=False,
                         include_entities=True):
    '''
    Fetch a collection of the most recent Tweets and retweets posted by the
    authenticating user and the users they follow.

    The home timeline is central to how most users interact with the Twitter
</source>
<source file="systems/Sick-Beard-build-507/lib/pythontwitter/__init__.py" startline="3732" endline="3804" pcid="1052">
      status:
        The twitter.Status object to unmark as a favorite.
        [Optional]
      include_entities:
        The entities node will be omitted when set to False.
    Returns:
      A twitter.Status instance representing the newly-unmarked favorite.
    '''
    url  = '%s/favorites/destroy.json' % self.base_url
    data = {}
    if id:
      data['id'] = id
    elif status:
      data['id'] = status.id
    else:
      raise TwitterError("Specify id or status")
    if not include_entities:
      data['include_entities'] = 'false'
    json = self._FetchUrl(url, post_data=data)
    data = self._ParseAndCheckTwitter(json)
    return Status.NewFromJsonDict(data)

  def GetFavorites(self,
                   user_id=None,
                   screen_name=None,
                   count=None,
                   since_id=None,
                   max_id=None,
                   include_entities=True):
    '''Return a list of Status objects representing favorited tweets.
    By default, returns the (up to) 20 most recent tweets for the
    authenticated user.

    Args:
      user:
        The twitter name or id of the user whose favorites you are fetching.
        If not specified, defaults to the authenticated user. [Optional]
      page:
        Specifies the page of results to retrieve.
        Note: there are pagination limits. [Optional]
    '''
    parameters = {}

    url = '%s/favorites/list.json' % self.base_url

    if user_id:
      parameters['user_id'] = user_id
    elif screen_name:
      parameters['screen_name'] = user_id

    if since_id:
      try:
        parameters['since_id'] = long(since_id)
      except:
        raise TwitterError("since_id must be an integer")

    if max_id:
      try:
        parameters['max_id'] = long(max_id)
      except:
        raise TwitterError("max_id must be an integer")

    if count:
      try:
        parameters['count'] = int(count)
      except:
        raise TwitterError("count must be an integer")

    if include_entities:
        parameters['include_entities'] = True


    json = self._FetchUrl(url, parameters=parameters)
</source>
<source file="systems/Sick-Beard-build-507/lib/pythontwitter/__init__.py" startline="2632" endline="2722" pcid="1026">
    service.

    The twitter.Api instance must be authenticated.

    Args:
      count:
        Specifies the number of statuses to retrieve. May not be
        greater than 200. Defaults to 20. [Optional]
      since_id:
        Returns results with an ID greater than (that is, more recent
        than) the specified ID. There are limits to the number of
        Tweets which can be accessed through the API. If the limit of
        Tweets has occurred since the since_id, the since_id will be
        forced to the oldest ID available. [Optional]
      max_id:
        Returns results with an ID less than (that is, older than) or
        equal to the specified ID. [Optional]
      trim_user:
        When True, each tweet returned in a timeline will include a user
        object including only the status authors numerical ID. Omit this
        parameter to receive the complete user object. [Optional]
      exclude_replies:
        This parameter will prevent replies from appearing in the
        returned timeline. Using exclude_replies with the count
        parameter will mean you will receive up-to count tweets -
        this is because the count parameter retrieves that many
        tweets before filtering out retweets and replies.
        [Optional]
      contributor_details:
        This parameter enhances the contributors element of the
        status response to include the screen_name of the contributor.
        By default only the user_id of the contributor is included.
        [Optional]
      include_entities:
        The entities node will be disincluded when set to false.
        This node offers a variety of metadata about the tweet in a
        discreet structure, including: user_mentions, urls, and
        hashtags. [Optional]

    Returns:
      A sequence of twitter.Status instances, one for each message
    '''
    url = '%s/statuses/home_timeline.json' % self.base_url

    if not self._oauth_consumer:
      raise TwitterError("API must be authenticated.")
    parameters = {}
    if count is not None:
      try:
        if int(count) > 200:
          raise TwitterError("'count' may not be greater than 200")
      except ValueError:
        raise TwitterError("'count' must be an integer")
      parameters['count'] = count
    if since_id:
      try:
        parameters['since_id'] = long(since_id)
      except ValueError:
        raise TwitterError("'since_id' must be an integer")
    if max_id:
      try:
        parameters['max_id'] = long(max_id)
      except ValueError:
        raise TwitterError("'max_id' must be an integer")
    if trim_user:
      parameters['trim_user'] = 1
    if exclude_replies:
      parameters['exclude_replies'] = 1
    if contributor_details:
      parameters['contributor_details'] = 1
    if not include_entities:
      parameters['include_entities'] = 'false'
    json = self._FetchUrl(url, parameters=parameters)
    data = self._ParseAndCheckTwitter(json)
    return [Status.NewFromJsonDict(x) for x in data]

  def GetUserTimeline(self,
                      user_id=None,
                      screen_name=None,
                      since_id=None,
                      max_id=None,
                      count=None,
                      include_rts=None,
                      trim_user=None,
                      exclude_replies=None):
    '''Fetch the sequence of public Status messages for a single user.

    The twitter.Api instance must be authenticated if the user is private.

    Args:
      user_id:
</source>
<source file="systems/Sick-Beard-build-507/lib/pythontwitter/__init__.py" startline="3678" endline="3731" pcid="1051">
    url  = '%s/friendships/destroy.json' % self.base_url
    data = {}
    if user_id:
      data['user_id'] = user_id
    elif screen_name:
      data['screen_name'] = screen_name
    else:
      raise TwitterError("Specify at least one of user_id or screen_name.")
    json = self._FetchUrl(url, post_data=data)
    data = self._ParseAndCheckTwitter(json)
    return User.NewFromJsonDict(data)

  def CreateFavorite(self, status=None, id=None, include_entities=True):
    '''Favorites the specified status object or id as the authenticating user.
    Returns the favorite status when successful.

    The twitter.Api instance must be authenticated.

    Args:
      id:
        The id of the twitter status to mark as a favorite.
        [Optional]
      status:
        The twitter.Status object to mark as a favorite.
        [Optional]
      include_entities:
        The entities node will be omitted when set to False.
    Returns:
      A twitter.Status instance representing the newly-marked favorite.
    '''
    url  = '%s/favorites/create.json' % self.base_url
    data = {}
    if id:
      data['id'] = id
    elif status:
      data['id'] = status.id
    else:
      raise TwitterError("Specify id or status")
    if not include_entities:
      data['include_entities'] = 'false'
    json = self._FetchUrl(url, post_data=data)
    data = self._ParseAndCheckTwitter(json)
    return Status.NewFromJsonDict(data)

  def DestroyFavorite(self, status=None, id=None, include_entities=True):
    '''Un-Favorites the specified status object or id as the authenticating user.
    Returns the un-favorited status when successful.

    The twitter.Api instance must be authenticated.

    Args:
      id:
        The id of the twitter status to unmark as a favorite.
        [Optional]
</source>
</class>

<class classid="8" nclones="5" nlines="29" similarity="74">
<source file="systems/Sick-Beard-build-507/lib/pythontwitter/__init__.py" startline="3085" endline="3135" pcid="1037">
      count:
        The number of status messages to retrieve. [Optional]
      trim_user:
        If True the returned payload will only contain the user IDs,
        otherwise the payload will contain the full user data item.
        [Optional]

    Returns:
      A list of twitter.Status instances, which are retweets of statusid
    '''
    if not self._oauth_consumer:
      raise TwitterError("The twitter.Api instsance must be authenticated.")
    url = '%s/statuses/retweets/%s.json' % (self.base_url, statusid)
    parameters = {}
    if trim_user:
      parameters['trim_user'] = 'true'
    if count:
      try:
        parameters['count'] = int(count)
      except:
        raise TwitterError("count must be an integer")
    json = self._FetchUrl(url, parameters=parameters)
    data = self._ParseAndCheckTwitter(json)
    return [Status.NewFromJsonDict(s) for s in data]

  def GetRetweetsOfMe(self,
                      count=None,
                      since_id=None,
                      max_id=None,
                      trim_user=False,
                      include_entities=True,
                      include_user_entities=True):
    '''Returns up to 100 of the most recent tweets of the user that have been
    retweeted by others.

    Args:
      count:
        The number of retweets to retrieve, up to 100. If omitted, 20 is
        assumed.
      since_id:
        Returns results with an ID greater than (newer than) this ID.
      max_id:
        Returns results with an ID less than or equal to this ID.
      trim_user:
        When True, the user object for each tweet will only be an ID.
      include_entities:
        When True, the tweet entities will be included.
      include_user_entities:
        When True, the user entities will be included.
    '''
    if not self._oauth_consumer:
</source>
<source file="systems/Sick-Beard-build-507/lib/pythontwitter/__init__.py" startline="3253" endline="3303" pcid="1040">
        result += [x for x in data['ids']]
        if 'next_cursor' in data:
          if data['next_cursor'] == 0 or data['next_cursor'] == data['previous_cursor']:
            break
          else:
            cursor = data['next_cursor']
        else:
          break
      return result


  def GetFollowerIDs(self, user_id=None, screen_name=None, cursor=-1, stringify_ids=False, count=None, total_count=None):
      '''Returns a list of twitter user id's for every person
      that is following the specified user.

      Args:
        user_id:
          The id of the user to retrieve the id list for
          [Optional]
        screen_name:
          The screen_name of the user to retrieve the id list for
          [Optional]
        cursor:
          Specifies the Twitter API Cursor location to start at.
          Note: there are pagination limits.
          [Optional]
        stringify_ids:
          if True then twitter will return the ids as strings instead of integers.
          [Optional]
        count:
          The number of user id's to retrieve per API request. Please be aware that
          this might get you rate-limited if set to a small number. By default Twitter
          will retrieve 5000 UIDs per call.
          [Optional]
        total_count:
          The total amount of UIDs to retrieve. Good if the account has many followers
          and you don't want to get rate limited. The data returned might contain more
          UIDs if total_count is not a multiple of count (5000 by default).
          [Optional]


      Returns:
        A list of integers, one for each user id.
      '''
      url = '%s/followers/ids.json' % self.base_url
      if not self._oauth_consumer:
          raise TwitterError("twitter.Api instance must be authenticated")
      parameters = {}
      if user_id is not None:
        parameters['user_id'] = user_id
      if screen_name is not None:
</source>
<source file="systems/Sick-Beard-build-507/lib/pythontwitter/__init__.py" startline="3136" endline="3187" pcid="1038">
      raise TwitterError("The twitter.Api instance must be authenticated.")
    url = '%s/statuses/retweets_of_me.json' % self.base_url
    parameters = {}
    if count is not None:
      try:
        if int(count) > 100:
          raise TwitterError("'count' may not be greater than 100")
      except ValueError:
        raise TwitterError("'count' must be an integer")
    if count:
      parameters['count'] = count
    if since_id:
      parameters['since_id'] = since_id
    if max_id:
      parameters['max_id'] = max_id
    if trim_user:
      parameters['trim_user'] = trim_user
    if not include_entities:
      parameters['include_entities'] = include_entities
    if not include_user_entities:
      parameters['include_user_entities'] = include_user_entities
    json = self._FetchUrl(url, parameters=parameters)
    data = self._ParseAndCheckTwitter(json)
    return [Status.NewFromJsonDict(s) for s in data]

  def GetFriends(self, user_id=None, screen_name=None, cursor=-1, skip_status=False, include_user_entities=False):
    '''Fetch the sequence of twitter.User instances, one for each friend.

    The twitter.Api instance must be authenticated.

    Args:
      user_id:
        The twitter id of the user whose friends you are fetching.
        If not specified, defaults to the authenticated user. [Optional]
      screen_name:
        The twitter name of the user whose friends you are fetching.
        If not specified, defaults to the authenticated user. [Optional]
      cursor:
        Should be set to -1 for the initial call and then is used to
        control what result page Twitter returns [Optional(ish)]
      skip_status:
        If True the statuses will not be returned in the user items.
        [Optional]
      include_user_entities:
        When True, the user entities will be included.

    Returns:
      A sequence of twitter.User instances, one for each friend
    '''
    if not self._oauth_consumer:
      raise TwitterError("twitter.Api instance must be authenticated")
    url = '%s/friends/list.json' % self.base_url
</source>
<source file="systems/Sick-Beard-build-507/lib/pythontwitter/__init__.py" startline="4038" endline="4093" pcid="1058">
      try:
        data['list_id']= long(list_id)
      except:
        raise TwitterError("list_id must be an integer")
    elif slug:
      data['slug'] = slug
      if owner_id:
        try:
          data['owner_id'] = long(owner_id)
        except:
          raise TwitterError("owner_id must be an integer")
      elif owner_screen_name:
        data['owner_screen_name'] = owner_screen_name
      else:
        raise TwitterError("Identify list by list_id or owner_screen_name/owner_id and slug")
    else:
      raise TwitterError("Identify list by list_id or owner_screen_name/owner_id and slug")
    json = self._FetchUrl(url, post_data=data)
    data = self._ParseAndCheckTwitter(json)
    return List.NewFromJsonDict(data)

  def GetSubscriptions(self, user_id=None, screen_name=None, count=20, cursor=-1):
    '''
    Obtain a collection of the lists the specified user is subscribed to, 20
    lists per page by default. Does not include the user's own lists.

    The twitter.Api instance must be authenticated.

    Args:
      user_id:
        The ID of the user for whom to return results for. [Optional]
      screen_name:
        The screen name of the user for whom to return results for.
        [Optional]
      count:
       The amount of results to return per page. Defaults to 20.
       No more than 1000 results will ever be returned in a single page.
      cursor:
        "page" value that Twitter will use to start building the
        list sequence from.  -1 to start at the beginning.
        Twitter will return in the result the values for next_cursor
        and previous_cursor. [Optional]

    Returns:
      A sequence of twitter.List instances, one for each list
    '''
    if not self._oauth_consumer:
      raise TwitterError("twitter.Api instance must be authenticated")

    url = '%s/lists/subscriptions.json' % (self.base_url)
    parameters = {}

    try:
      parameters['cursor'] = int(cursor)
    except:
      raise TwitterError("cursor must be an integer")
</source>
<source file="systems/Sick-Beard-build-507/lib/pythontwitter/__init__.py" startline="3188" endline="3252" pcid="1039">
    result = []
    parameters = {}
    if user_id is not None:
      parameters['user_id'] = user_id
    if screen_name is not None:
      parameters['screen_name'] = screen_name
    if skip_status:
      parameters['skip_status'] = True
    if include_user_entities:
      parameters['include_user_entities'] = True
    while True:
      parameters['cursor'] = cursor
      json = self._FetchUrl(url, parameters=parameters)
      data = self._ParseAndCheckTwitter(json)
      result += [User.NewFromJsonDict(x) for x in data['users']]
      if 'next_cursor' in data:
        if data['next_cursor'] == 0 or data['next_cursor'] == data['previous_cursor']:
          break
        else:
          cursor = data['next_cursor']
      else:
        break
    return result

  def GetFriendIDs(self, user_id=None, screen_name=None, cursor=-1, stringify_ids=False, count=None):
      '''Returns a list of twitter user id's for every person
      the specified user is following.

      Args:
        user_id:
          The id of the user to retrieve the id list for
          [Optional]
        screen_name:
          The screen_name of the user to retrieve the id list for
          [Optional]
        cursor:
          Specifies the Twitter API Cursor location to start at.
          Note: there are pagination limits.
          [Optional]
        stringify_ids:
          if True then twitter will return the ids as strings instead of integers.
          [Optional]
        count:
          The number of status messages to retrieve. [Optional]

      Returns:
        A list of integers, one for each user id.
      '''
      url = '%s/friends/ids.json' % self.base_url
      if not self._oauth_consumer:
          raise TwitterError("twitter.Api instance must be authenticated")
      parameters = {}
      if user_id is not None:
        parameters['user_id'] = user_id
      if screen_name is not None:
        parameters['screen_name'] = screen_name
      if stringify_ids:
        parameters['stringify_ids'] = True
      if count is not None:
        parameters['count'] = count
      result = []
      while True:
        parameters['cursor'] = cursor
        json = self._FetchUrl(url, parameters=parameters)
        data = self._ParseAndCheckTwitter(json)
</source>
</class>

<class classid="9" nclones="6" nlines="15" similarity="70">
<source file="systems/Sick-Beard-build-507/lib/pythontwitter/__init__.py" startline="3362" endline="3402" pcid="1042">
    if skip_status:
      parameters['skip_status'] = True
    if include_user_entities:
      parameters['include_user_entities'] = True
    while True:
      parameters['cursor'] = cursor
      json = self._FetchUrl(url, parameters=parameters)
      data = self._ParseAndCheckTwitter(json)
      result += [User.NewFromJsonDict(x) for x in data['users']]
      if 'next_cursor' in data:
        if data['next_cursor'] == 0 or data['next_cursor'] == data['previous_cursor']:
          break
        else:
          cursor = data['next_cursor']
      else:
        break
    return result

  def UsersLookup(self, user_id=None, screen_name=None, users=None, include_entities=True):
    '''Fetch extended information for the specified users.

    Users may be specified either as lists of either user_ids,
    screen_names, or twitter.User objects. The list of users that
    are queried is the union of all specified parameters.

    The twitter.Api instance must be authenticated.

    Args:
      user_id:
        A list of user_ids to retrieve extended information.
        [Optional]
      screen_name:
        A list of screen_names to retrieve extended information.
        [Optional]
      users:
        A list of twitter.User objects to retrieve extended information.
        [Optional]
      include_entities:
        The entities node that may appear within embedded statuses will be
        disincluded when set to False.
        [Optional]
</source>
<source file="systems/Sick-Beard-build-507/lib/pythontwitter/__init__.py" startline="3614" endline="3645" pcid="1049">
    '''Destroys the direct message specified in the required ID parameter.

    The twitter.Api instance must be authenticated, and the
    authenticating user must be the recipient of the specified direct
    message.

    Args:
      id: The id of the direct message to be destroyed

    Returns:
      A twitter.DirectMessage instance representing the message destroyed
    '''
    url  = '%s/direct_messages/destroy.json' % self.base_url
    data = {'id': id}
    if not include_entities:
      data['include_entities'] = 'false'
    json = self._FetchUrl(url, post_data=data)
    data = self._ParseAndCheckTwitter(json)
    return DirectMessage.NewFromJsonDict(data)

  def CreateFriendship(self, user_id=None, screen_name=None, follow=True):
    '''Befriends the user specified by the user_id or screen_name.

    The twitter.Api instance must be authenticated.

    Args:
      user_id:
        A user_id to follow [Optional]
      screen_name:
        A screen_name to follow [Optional]
      follow:
        Set to False to disable notifications for the target user
</source>
<source file="systems/Sick-Beard-build-507/lib/pythontwitter/__init__.py" startline="3505" endline="3536" pcid="1045">

    Returns:
      A sequence of twitter.DirectMessage instances
    '''
    url = '%s/direct_messages.json' % self.base_url
    if not self._oauth_consumer:
      raise TwitterError("The twitter.Api instance must be authenticated.")
    parameters = {}
    if since_id:
      parameters['since_id'] = since_id
    if max_id:
      parameters['max_id'] = max_id
    if count:
      try:
        parameters['count'] = int(count)
      except:
        raise TwitterError("count must be an integer")
    if not include_entities:
      parameters['include_entities'] = 'false'
    if skip_status:
      parameters['skip_status'] = 1
    json = self._FetchUrl(url, parameters=parameters)
    data = self._ParseAndCheckTwitter(json)
    return [DirectMessage.NewFromJsonDict(x) for x in data]

  def GetSentDirectMessages(self, since_id=None, max_id=None, count=None, page=None, include_entities=True):
    '''Returns a list of the direct messages sent by the authenticating user.

    The twitter.Api instance must be authenticated.

    Args:
      since_id:
</source>
<source file="systems/Sick-Beard-build-507/lib/pythontwitter/__init__.py" startline="3558" endline="3588" pcid="1047">
      A sequence of twitter.DirectMessage instances
    '''
    url = '%s/direct_messages/sent.json' % self.base_url
    if not self._oauth_consumer:
      raise TwitterError("The twitter.Api instance must be authenticated.")
    parameters = {}
    if since_id:
      parameters['since_id'] = since_id
    if page:
      parameters['page'] = page
    if max_id:
      parameters['max_id'] = max_id
    if count:
      try:
        parameters['count'] = int(count)
      except:
        raise TwitterError("count must be an integer")
    if not include_entities:
      parameters['include_entities'] = 'false'
    json = self._FetchUrl(url, parameters=parameters)
    data = self._ParseAndCheckTwitter(json)
    return [DirectMessage.NewFromJsonDict(x) for x in data]

  def PostDirectMessage(self, text, user_id=None, screen_name=None):
    '''Post a twitter direct message from the authenticated user

    The twitter.Api instance must be authenticated. user_id or screen_name
    must be specified.

    Args:
      text: The message text to be posted.  Must be less than 140 characters.
</source>
<source file="systems/Sick-Beard-build-507/lib/pythontwitter/__init__.py" startline="3646" endline="3677" pcid="1050">
    Returns:
      A twitter.User instance representing the befriended user.
    '''
    url  = '%s/friendships/create.json' % (self.base_url)
    data = {}
    if user_id:
      data['user_id'] = user_id
    elif screen_name:
      data['screen_name'] = screen_name
    else:
      raise TwitterError("Specify at least one of user_id or screen_name.")
    if follow:
      data['follow'] = 'true'
    else:
      data['follow'] = 'false'
    json = self._FetchUrl(url, post_data=data)
    data = self._ParseAndCheckTwitter(json)
    return User.NewFromJsonDict(data)

  def DestroyFriendship(self, user_id=None, screen_name=None):
    '''Discontinues friendship with a user_id or screen_name.

    The twitter.Api instance must be authenticated.

    Args:
      user_id:
        A user_id to unfollow [Optional]
      screen_name:
        A screen_name to unfollow [Optional]
    Returns:
      A twitter.User instance representing the discontinued friend.
    '''
</source>
<source file="systems/Sick-Beard-build-507/lib/pythontwitter/__init__.py" startline="3589" endline="3613" pcid="1048">
      user_id:
        The ID of the user who should receive the direct message.
        [Optional]
      screen_name:
        The screen name of the user who should receive the direct message.
        [Optional]

    Returns:
      A twitter.DirectMessage instance representing the message posted
    '''
    if not self._oauth_consumer:
      raise TwitterError("The twitter.Api instance must be authenticated.")
    url  = '%s/direct_messages/new.json' % self.base_url
    data = {'text': text}
    if user_id:
      data['user_id'] = user_id
    elif screen_name:
      data['screen_name'] = screen_name
    else:
      raise TwitterError("Specify at least one of user_id or screen_name.")
    json = self._FetchUrl(url, post_data=data)
    data = self._ParseAndCheckTwitter(json)
    return DirectMessage.NewFromJsonDict(data)

  def DestroyDirectMessage(self, id, include_entities=True):
</source>
</class>

<class classid="10" nclones="2" nlines="22" similarity="90">
<source file="systems/Sick-Beard-build-507/lib/pythontwitter/__init__.py" startline="3403" endline="3453" pcid="1043">

    Returns:
      A list of twitter.User objects for the requested users
    '''

    if not self._oauth_consumer:
      raise TwitterError("The twitter.Api instance must be authenticated.")
    if not user_id and not screen_name and not users:
      raise TwitterError("Specify at least one of user_id, screen_name, or users.")
    url = '%s/users/lookup.json' % self.base_url
    parameters = {}
    uids = list()
    if user_id:
      uids.extend(user_id)
    if users:
      uids.extend([u.id for u in users])
    if len(uids):
      parameters['user_id'] = ','.join(["%s" % u for u in uids])
    if screen_name:
      parameters['screen_name'] = ','.join(screen_name)
    if not include_entities:
      parameters['include_entities'] = 'false'
    json = self._FetchUrl(url, parameters=parameters)
    try:
      data = self._ParseAndCheckTwitter(json)
    except TwitterError, e:
        _, e, _ = sys.exc_info()
        t = e.args[0]
        if len(t) == 1 and ('code' in t[0]) and (t[0]['code'] == 34):
          data = []
        else:
            raise

    return [User.NewFromJsonDict(u) for u in data]

  def GetUser(self, user_id=None, screen_name=None, include_entities=True):
    '''Returns a single user.

    The twitter.Api instance must be authenticated.

    Args:
      user_id:
        The id of the user to retrieve.
        [Optional]
      screen_name:
        The screen name of the user for whom to return results for. Either a
        user_id or screen_name is required for this method.
        [Optional]
      include_entities:
        if set to False, the 'entities' node will not be included.
        [Optional]
</source>
<source file="systems/Sick-Beard-build-507/lib/pythontwitter/__init__.py" startline="3454" endline="3504" pcid="1044">


    Returns:
      A twitter.User instance representing that user
    '''
    url  = '%s/users/show.json' % (self.base_url)
    parameters = {}

    if not self._oauth_consumer:
      raise TwitterError("The twitter.Api instance must be authenticated.")

    if user_id:
      parameters['user_id'] = user_id
    elif screen_name:
      parameters['screen_name'] = screen_name
    else:
      raise TwitterError("Specify at least one of user_id or screen_name.")

    if not include_entities:
      parameters['include_entities'] = 'false'

    json = self._FetchUrl(url, parameters=parameters)
    data = self._ParseAndCheckTwitter(json)
    return User.NewFromJsonDict(data)

  def GetDirectMessages(self, since_id=None, max_id=None, count=None, include_entities=True, skip_status=False):
    '''Returns a list of the direct messages sent to the authenticating user.

    The twitter.Api instance must be authenticated.

    Args:
      since_id:
        Returns results with an ID greater than (that is, more recent
        than) the specified ID. There are limits to the number of
        Tweets which can be accessed through the API. If the limit of
        Tweets has occurred since the since_id, the since_id will be
        forced to the oldest ID available. [Optional]
      max_id:
        Returns results with an ID less than (that is, older than) or
        equal to the specified ID. [Optional]
      count:
        Specifies the number of direct messages to try and retrieve, up to a
        maximum of 200. The value of count is best thought of as a limit to the
        number of Tweets to return because suspended or deleted content is
        removed after the count has been applied. [Optional]
      include_entities:
        The entities node will not be included when set to False.
        [Optional]
      skip_status:
        When set to True statuses will not be included in the returned user
        objects. [Optional]
</source>
</class>

<class classid="11" nclones="3" nlines="30" similarity="90">
<source file="systems/Sick-Beard-build-507/lib/pythontwitter/__init__.py" startline="3835" endline="3884" pcid="1054">
        object including only the status authors numerical ID. Omit this
        parameter to receive the complete user object.
      contributor_details:
        If set to True, this parameter enhances the contributors element of the
        status response to include the screen_name of the contributor. By
        default only the user_id of the contributor is included.
      include_entities:
        The entities node will be disincluded when set to False.

    Returns:
      A sequence of twitter.Status instances, one for each mention of the user.
    '''

    url = '%s/statuses/mentions_timeline.json' % self.base_url

    if not self._oauth_consumer:
      raise TwitterError("The twitter.Api instance must be authenticated.")

    parameters = {}

    if count:
      try:
        parameters['count'] = int(count)
      except:
        raise TwitterError("count must be an integer")
    if since_id:
      try:
        parameters['since_id'] = long(since_id)
      except:
        raise TwitterError("since_id must be an integer")
    if max_id:
      try:
        parameters['max_id'] = long(max_id)
      except:
        raise TwitterError("max_id must be an integer")
    if trim_user:
      parameters['trim_user'] = 1
    if contributor_details:
      parameters['contributor_details'] = 'true'
    if not include_entities:
      parameters['include_entities'] = 'false'

    json = self._FetchUrl(url, parameters=parameters)
    data = self._ParseAndCheckTwitter(json)
    return [Status.NewFromJsonDict(x) for x in data]

  def CreateList(self, name, mode=None, description=None):
    '''Creates a new list with the give name for the authenticated user.

    The twitter.Api instance must be authenticated.
</source>
<source file="systems/Sick-Beard-build-507/lib/pythontwitter/__init__.py" startline="3885" endline="3933" pcid="1055">

    Args:
      name:
        New name for the list
      mode:
        'public' or 'private'.
        Defaults to 'public'. [Optional]
      description:
        Description of the list. [Optional]

    Returns:
      A twitter.List instance representing the new list
    '''
    url = '%s/lists/create.json' % self.base_url

    if not self._oauth_consumer:
      raise TwitterError("The twitter.Api instance must be authenticated.")
    parameters = {'name': name}
    if mode is not None:
      parameters['mode'] = mode
    if description is not None:
      parameters['description'] = description
    json = self._FetchUrl(url, post_data=parameters)
    data = self._ParseAndCheckTwitter(json)
    return List.NewFromJsonDict(data)

  def DestroyList(self,
                  owner_screen_name=False,
                  owner_id=False,
                  list_id=None,
                  slug=None):
    '''
    Destroys the list identified by list_id or owner_screen_name/owner_id and
    slug.

    The twitter.Api instance must be authenticated.

    Args:
      owner_screen_name:
        The screen_name of the user who owns the list being requested by a slug.
      owner_id:
        The user ID of the user who owns the list being requested by a slug.
      list_id:
        The numerical id of the list.
      slug:
        You can identify a list by its slug instead of its numerical id. If you
        decide to do so, note that you'll also have to specify the list owner
        using the owner_id or owner_screen_name parameters.
    Returns:
</source>
<source file="systems/Sick-Beard-build-507/lib/pythontwitter/__init__.py" startline="3934" endline="3982" pcid="1056">
      A twitter.List instance representing the removed list.
    '''
    url  = '%s/lists/destroy.json' % self.base_url
    data = {}
    if list_id:
      try:
        data['list_id']= long(list_id)
      except:
        raise TwitterError("list_id must be an integer")
    elif slug:
      data['slug'] = slug
      if owner_id:
        try:
          data['owner_id'] = long(owner_id)
        except:
          raise TwitterError("owner_id must be an integer")
      elif owner_screen_name:
        data['owner_screen_name'] = owner_screen_name
      else:
        raise TwitterError("Identify list by list_id or owner_screen_name/owner_id and slug")
    else:
      raise TwitterError("Identify list by list_id or owner_screen_name/owner_id and slug")

    json = self._FetchUrl(url, post_data=data)
    data = self._ParseAndCheckTwitter(json)
    return List.NewFromJsonDict(data)

  def CreateSubscription(self,
                  owner_screen_name=False,
                  owner_id=False,
                  list_id=None,
                  slug=None):
    '''Creates a subscription to a list by the authenticated user

    The twitter.Api instance must be authenticated.

    Args:
      owner_screen_name:
        The screen_name of the user who owns the list being requested by a slug.
      owner_id:
        The user ID of the user who owns the list being requested by a slug.
      list_id:
        The numerical id of the list.
      slug:
        You can identify a list by its slug instead of its numerical id. If you
        decide to do so, note that you'll also have to specify the list owner
        using the owner_id or owner_screen_name parameters.
    Returns:
      A twitter.List instance representing the list subscribed to
</source>
</class>

<class classid="12" nclones="7" nlines="13" similarity="71">
<source file="systems/Sick-Beard-build-507/lib/hachoir_parser/misc/gnome_keyring.py" startline="114" endline="131" pcid="1185">
    def createFields(self):
        yield KeyringString(self, "display_name")
        yield KeyringString(self, "secret")
        yield TimestampUnix64(self, "mtime")
        yield TimestampUnix64(self, "ctime")
        yield KeyringString(self, "reserved[]")
        for index in xrange(4):
            yield UInt32(self, "reserved[]")
        yield UInt32(self, "attr_count")
        for index in xrange(self["attr_count"].value):
            yield Attribute(self, "attr[]")
        yield UInt32(self, "acl_count")
        for index in xrange(self["acl_count"].value):
            yield ACL(self, "acl[]")
#        size = 8 # paddingSize((self.stream.size - self.current_size) // 8, 16)
#        if size:
#            yield NullBytes(self, "hash_padding", size, "16 bytes alignment")

</source>
<source file="systems/Sick-Beard-build-507/lib/hachoir_parser/image/wmf.py" startline="245" endline="259" pcid="2516">
def parseExtCreatePen(parser):
    yield UInt32(parser, "ihPen")
    yield UInt32(parser, "offBmi")
    yield UInt32(parser, "cbBmi")
    yield UInt32(parser, "offBits")
    yield UInt32(parser, "cbBits")
    yield UInt32(parser, "pen_style")
    yield UInt32(parser, "width")
    yield UInt32(parser, "brush_style")
    yield RGBA(parser, "color")
    yield UInt32(parser, "hatch")
    yield UInt32(parser, "nb_style")
    for index in xrange(parser["nb_style"].value):
        yield UInt32(parser, "style")

</source>
<source file="systems/Sick-Beard-build-507/lib/hachoir_parser/audio/s3m.py" startline="503" endline="516" pcid="2171">
    MAGIC = "PTMI"
    ALIGN = 0

    def getType(self):
        return PTMType(self, "flags") # Hack to have more common code

    # PTM doesn't pretend to manage 16bits
    def getSampleBits(self):
        return 8

    def getInstrumentFields(self):
        yield UInt8(self, "volume")
        yield UInt16(self, "c4_speed")
        yield UInt16(self, "sample_segment")
</source>
<source file="systems/Sick-Beard-build-507/lib/hachoir_parser/audio/xm.py" startline="45" endline="56" pcid="2106">
    def createFields(self):
        yield UInt32(self, "length")
        yield UInt32(self, "loop_start")
        yield UInt32(self, "loop_end")
        yield UInt8(self, "volume")
        yield Int8(self, "fine_tune")
        yield SampleType(self, "type")
        yield UInt8(self, "panning")
        yield Int8(self, "relative_note")
        yield UInt8(self, "reserved")
        yield String(self, "name", 22, charset="ASCII", strip=' \0')

</source>
<source file="systems/Sick-Beard-build-507/lib/hachoir_parser/container/realmedia.py" startline="63" endline="77" pcid="1422">
    def createFields(self):
        yield UInt32(self, "size")
        yield UInt16(self, "obj_version")
        yield UInt16(self, "nb_physical_stream")
        for index in xrange(self["nb_physical_stream"].value):
            yield UInt16(self, "physical_stream[]")
        for index in xrange(self["nb_physical_stream"].value):
            yield UInt16(self, "data_offset[]")
        yield UInt16(self, "nb_rule")
        for index in xrange(self["nb_rule"].value):
            yield UInt16(self, "rule[]")
        yield UInt16(self, "nb_prop")
        for index in xrange(self["nb_prop"].value):
            yield NameValueProperty(self, "prop[]")

</source>
<source file="systems/Sick-Beard-build-507/lib/hachoir_parser/container/ogg.py" startline="102" endline="112" pcid="1355">
def parseVorbisHeader(parent):
    yield UInt32(parent, "vorbis_version")
    yield UInt8(parent, "audio_channels")
    yield UInt32(parent, "audio_sample_rate")
    yield UInt32(parent, "bitrate_maximum")
    yield UInt32(parent, "bitrate_nominal")
    yield UInt32(parent, "bitrate_minimum")
    yield Bits(parent, "blocksize_0", 4)
    yield Bits(parent, "blocksize_1", 4)
    yield UInt8(parent, "framing_flag")

</source>
<source file="systems/Sick-Beard-build-507/lib/hachoir_parser/network/tcpdump.py" startline="41" endline="51" pcid="1781">
    def createFields(self):
        yield UInt16(self, "hw_type")
        yield UInt16(self, "proto_type")
        yield UInt8(self, "hw_size")
        yield UInt8(self, "proto_size")
        yield Enum(UInt16(self, "opcode"), ARP.opcode_name)
        yield MAC48_Address(self, "src_mac")
        yield IPv4_Address(self, "src_ip")
        yield MAC48_Address(self, "dst_mac")
        yield IPv4_Address(self, "dst_ip")

</source>
</class>

<class classid="13" nclones="10" nlines="16" similarity="70">
<source file="systems/Sick-Beard-build-507/lib/hachoir_parser/misc/ole2.py" startline="123" endline="141" pcid="1237">
    def createFields(self):
        yield GUID(self, "clsid", "16 bytes GUID used by some apps")
        yield UInt16(self, "ver_min", "Minor version")
        yield UInt16(self, "ver_maj", "Minor version")
        yield Bytes(self, "endian", 2, "Endian (0xFFFE for Intel)")
        yield UInt16(self, "bb_shift", "Log, base 2, of the big block size")
        yield UInt16(self, "sb_shift", "Log, base 2, of the small block size")
        yield NullBytes(self, "reserved[]", 6, "(reserved)")
        yield UInt32(self, "csectdir", "Number of SECTs in directory chain for 4 KB sectors (version 4)")
        yield UInt32(self, "bb_count", "Number of Big Block Depot blocks")
        yield SECT(self, "bb_start", "Root start block")
        yield NullBytes(self, "transaction", 4, "Signature used for transactions (must be zero)")
        yield UInt32(self, "threshold", "Maximum size for a mini stream (typically 4096 bytes)")
        yield SECT(self, "sb_start", "Small Block Depot start block")
        yield UInt32(self, "sb_count")
        yield SECT(self, "db_start", "First block of DIFAT")
        yield UInt32(self, "db_count", "Number of SECTs in DIFAT")

# Header (ole_id, header, difat) size in bytes
</source>
<source file="systems/Sick-Beard-build-507/lib/hachoir_parser/container/realmedia.py" startline="27" endline="42" pcid="1418">
def parseFileProperties(self):
    yield UInt32(self, "max_bit_rate", "Maximum bit rate")
    yield UInt32(self, "avg_bit_rate", "Average bit rate")
    yield UInt32(self, "max_pkt_size", "Size of largest data packet")
    yield UInt32(self, "avg_pkt_size", "Size of average data packet")
    yield UInt32(self, "num_pkts", "Number of data packets")
    yield UInt32(self, "duration", "File duration in milliseconds")
    yield UInt32(self, "preroll", "Suggested preroll in milliseconds")
    yield textHandler(UInt32(self, "index_offset", "Absolute offset of first index chunk"), hexadecimal)
    yield textHandler(UInt32(self, "data_offset", "Absolute offset of first data chunk"), hexadecimal)
    yield UInt16(self, "stream_count", "Number of streams in the file")
    yield RawBits(self, "reserved", 13)
    yield Bit(self, "is_live", "Whether file is a live broadcast")
    yield Bit(self, "is_perfect_play", "Whether PerfectPlay can be used")
    yield Bit(self, "is_saveable", "Whether file can be saved")

</source>
<source file="systems/Sick-Beard-build-507/lib/hachoir_parser/program/exe.py" startline="27" endline="45" pcid="1933">
    def createFields(self):
        yield String(self, "header", 2, "File header (MZ)", charset="ASCII")
        yield UInt16(self, "size_mod_512", "File size in bytes modulo 512")
        yield UInt16(self, "size_div_512", "File size in bytes divide by 512")
        yield UInt16(self, "reloc_entries", "Number of relocation entries")
        yield UInt16(self, "code_offset", "Offset to the code in the file (divided by 16)")
        yield UInt16(self, "needed_memory", "Memory needed to run (divided by 16)")
        yield UInt16(self, "max_memory", "Maximum memory needed to run (divided by 16)")
        yield textHandler(UInt32(self, "init_ss_sp", "Initial value of SP:SS registers"), hexadecimal)
        yield UInt16(self, "checksum", "Checksum")
        yield textHandler(UInt32(self, "init_cs_ip", "Initial value of CS:IP registers"), hexadecimal)
        yield UInt16(self, "reloc_offset", "Offset in file to relocation table")
        yield UInt16(self, "overlay_number", "Overlay number")
        yield PaddingBytes(self, "reserved[]", 8, "Reserved")
        yield UInt16(self, "oem_id", "OEM id")
        yield UInt16(self, "oem_info", "OEM info")
        yield PaddingBytes(self, "reserved[]", 20, "Reserved")
        yield UInt32(self, "next_offset", "Offset to next header (PE or NE)")

</source>
<source file="systems/Sick-Beard-build-507/lib/hachoir_parser/archive/rar.py" startline="130" endline="146" pcid="1542">
    def createFields(self):
        yield Bit(self, "continued_from", "File continued from previous volume")
        yield Bit(self, "continued_in", "File continued in next volume")
        yield Bit(self, "is_encrypted", "File encrypted with password")
        yield Bit(self, "has_comment", "File comment present")
        yield Bit(self, "is_solid", "Information from previous files is used (solid flag)")
        # The 3 following lines are what blocks more staticity
        yield Enum(Bits(self, "dictionary_size", 3, "Dictionary size"), DICTIONARY_SIZE)
        for bit in commonFlags(self):
            yield bit
        yield Bit(self, "is_large", "file64 operations needed")
        yield Bit(self, "is_unicode", "Filename also encoded using Unicode")
        yield Bit(self, "has_salt", "Has salt for encryption")
        yield Bit(self, "uses_file_version", "File versioning is used")
        yield Bit(self, "has_ext_time", "Extra time ??")
        yield Bit(self, "has_ext_flags", "Extra flag ??")

</source>
<source file="systems/Sick-Beard-build-507/lib/hachoir_parser/program/prc.py" startline="17" endline="32" pcid="1945">
    def createFields(self):
        yield String(self, "name", 32, "Name")
        yield UInt16(self, "flags", "Flags")
        yield UInt16(self, "version", "Version")
        yield TimestampMac32(self, "create_time", "Creation time")
        yield TimestampMac32(self, "mod_time", "Modification time")
        yield TimestampMac32(self, "backup_time", "Backup time")
        yield UInt32(self, "mod_num", "mod num")
        yield UInt32(self, "app_info", "app info")
        yield UInt32(self, "sort_info", "sort info")
        yield UInt32(self, "type", "type")
        yield UInt32(self, "id", "id")
        yield UInt32(self, "unique_id_seed", "unique_id_seed")
        yield UInt32(self, "next_record_list", "next_record_list")
        yield UInt16(self, "num_records", "num_records")

</source>
<source file="systems/Sick-Beard-build-507/lib/hachoir_parser/container/riff.py" startline="53" endline="65" pcid="1453">
def parseVideoFormat(self, size):
    yield UInt32(self, "video_size", "Video format: Size")
    yield UInt32(self, "width", "Video format: Width")
    yield UInt32(self, "height", "Video format: Height")
    yield UInt16(self, "panes", "Video format: Panes")
    yield UInt16(self, "depth", "Video format: Depth")
    yield UInt32(self, "tag1", "Video format: Tag1")
    yield UInt32(self, "img_size", "Video format: Image size")
    yield UInt32(self, "xpels_meter", "Video format: XPelsPerMeter")
    yield UInt32(self, "ypels_meter", "Video format: YPelsPerMeter")
    yield UInt32(self, "clr_used", "Video format: ClrUsed")
    yield UInt32(self, "clr_important", "Video format: ClrImportant")

</source>
<source file="systems/Sick-Beard-build-507/lib/hachoir_parser/common/win32.py" startline="135" endline="150" pcid="2331">
    def createFields(self):
        yield UInt32(self, "hdr_size", "Header size (in bytes) (=40)")
        yield UInt32(self, "width", "Width")
        yield UInt32(self, "height", "Height")
        yield UInt16(self, "nb_planes", "Color planes")
        yield UInt16(self, "bpp", "Bits/pixel")
        if self._use_fourcc:
            yield Enum(String(self, "codec", 4, charset="ASCII"), video_fourcc_name)
        else:
            yield Enum(UInt32(self, "codec", "Compression"), self.COMPRESSION_NAME)
        yield UInt32(self, "size", "Image size (in bytes)")
        yield UInt32(self, "xres", "X pixels per meter")
        yield UInt32(self, "yres", "Y pixels per meter")
        yield UInt32(self, "color_used", "Number of used colors")
        yield UInt32(self, "color_important", "Number of important colors")

</source>
<source file="systems/Sick-Beard-build-507/lib/hachoir_parser/misc/chm.py" startline="61" endline="80" pcid="1328">
    def createFields(self):
        yield String(self, "magic", 4, "ITSP", charset="ASCII")
        yield UInt32(self, "version", "Version (=1)")
        yield filesizeHandler(UInt32(self, "size", "Length (in bytes) of the directory header (84)"))
        yield UInt32(self, "unknown[]", "(=10)")
        yield filesizeHandler(UInt32(self, "block_size", "Directory block size"))
        yield UInt32(self, "density", "Density of quickref section, usually 2")
        yield UInt32(self, "index_depth", "Depth of the index tree")
        yield Int32(self, "nb_dir", "Chunk number of root index chunk")
        yield UInt32(self, "first_pmgl", "Chunk number of first PMGL (listing) chunk")
        yield UInt32(self, "last_pmgl", "Chunk number of last PMGL (listing) chunk")
        yield Int32(self, "unknown[]", "-1")
        yield UInt32(self, "nb_dir_chunk", "Number of directory chunks (total)")
        yield Enum(UInt32(self, "lang_id", "Windows language ID"), LANGUAGE_ID)
        yield GUID(self, "system_uuid", "{5D02926A-212E-11D0-9DF9-00A0C922E6EC}")
        yield filesizeHandler(UInt32(self, "size2", "Same value than size"))
        yield Int32(self, "unknown[]", "-1")
        yield Int32(self, "unknown[]", "-1")
        yield Int32(self, "unknown[]", "-1")

</source>
<source file="systems/Sick-Beard-build-507/lib/hachoir_parser/program/elf.py" startline="46" endline="66" pcid="1914">
    def createFields(self):
        yield Bytes(self, "signature", 4, r'ELF signature ("\x7fELF")')
        yield Enum(UInt8(self, "class", "Class"), self.CLASS_NAME)
        yield Enum(UInt8(self, "endian", "Endian"), self.ENDIAN_NAME)
        yield UInt8(self, "file_version", "File version")
        yield String(self, "pad", 8, "Pad")
        yield UInt8(self, "nb_ident", "Size of ident[]")
        yield Enum(UInt16(self, "type", "File type"), self.TYPE_NAME)
        yield Enum(UInt16(self, "machine", "Machine type"), self.MACHINE_NAME)
        yield UInt32(self, "version", "ELF format version")
        yield UInt32(self, "entry", "Number of entries")
        yield UInt32(self, "phoff", "Program header offset")
        yield UInt32(self, "shoff", "Section header offset")
        yield UInt32(self, "flags", "Flags")
        yield UInt16(self, "ehsize", "Elf header size (this header)")
        yield UInt16(self, "phentsize", "Program header entry size")
        yield UInt16(self, "phnum", "Program header entry count")
        yield UInt16(self, "shentsize", "Section header entry size")
        yield UInt16(self, "shnum", "Section header entre count")
        yield UInt16(self, "shstrndx", "Section header strtab index")

</source>
<source file="systems/Sick-Beard-build-507/lib/hachoir_parser/container/riff.py" startline="66" endline="80" pcid="1454">
def parseAudioFormat(self, size):
    yield Enum(UInt16(self, "codec", "Audio format: Codec id"), audio_codec_name)
    yield UInt16(self, "channel", "Audio format: Channels")
    yield UInt32(self, "sample_rate", "Audio format: Sample rate")
    yield UInt32(self, "bit_rate", "Audio format: Bit rate")
    yield UInt16(self, "block_align", "Audio format: Block align")
    if size >= 16:
        yield UInt16(self, "bits_per_sample", "Audio format: Bits per sample")
    if size >= 18:
        yield UInt16(self, "ext_size", "Audio format: Size of extra information")
    if size >= 28: # and self["a_channel"].value > 2
        yield UInt16(self, "reserved", "Audio format: ")
        yield UInt32(self, "channel_mask", "Audio format: channels placement bitmask")
        yield UInt32(self, "subformat", "Audio format: Subformat id")

</source>
</class>

<class classid="14" nclones="2" nlines="12" similarity="76">
<source file="systems/Sick-Beard-build-507/lib/hachoir_parser/misc/chm.py" startline="110" endline="128" pcid="1332">
    def createFields(self):
        # Header
        yield String(self, "magic", 4, "PMGL", charset="ASCII")
        yield filesizeHandler(Int32(self, "free_space",
            "Length of free space and/or quickref area at end of directory chunk"))
        yield Int32(self, "unknown")
        yield Int32(self, "previous", "Chunk number of previous listing chunk")
        yield Int32(self, "next", "Chunk number of previous listing chunk")

        # Entries
        stop = self.size - self["free_space"].value * 8
        while self.current_size < stop:
            yield PMGL_Entry(self, "entry[]")

        # Padding
        padding = (self.size - self.current_size) // 8
        if padding:
            yield PaddingBytes(self, "padding", padding)

</source>
<source file="systems/Sick-Beard-build-507/lib/hachoir_parser/misc/chm.py" startline="139" endline="151" pcid="1335">
    def createFields(self):
        yield String(self, "magic", 4, "PMGI", charset="ASCII")
        yield filesizeHandler(UInt32(self, "free_space",
            "Length of free space and/or quickref area at end of directory chunk"))

        stop = self.size - self["free_space"].value * 8
        while self.current_size < stop:
            yield PMGI_Entry(self, "entry[]")

        padding = (self.size - self.current_size) // 8
        if padding:
            yield PaddingBytes(self, "padding", padding)

</source>
</class>

<class classid="15" nclones="2" nlines="11" similarity="72">
<source file="systems/Sick-Beard-build-507/lib/hachoir_parser/container/ogg.py" startline="137" endline="148" pcid="1357">
    def createFields(self):
        if 7*8 <= self.size:
            yield UInt8(self, 'type')
            yield String(self, 'codec', 6)
        if self.parser:
            for field in self.parser(self):
                yield field
        else:
            size = (self.size - self.current_size) // 8
            if size:
                yield RawBytes(self, "raw", size)

</source>
<source file="systems/Sick-Beard-build-507/lib/hachoir_parser/container/realmedia.py" startline="120" endline="132" pcid="1426">
    def createFields(self):
        yield String(self, "tag", 4, "Chunk FourCC", charset="ASCII")
        yield UInt32(self, "size", "Chunk Size")
        yield UInt16(self, "version", "Chunk Version")

        if self.parse_func:
            for field in self.parse_func(self):
                yield field
        else:
            size = (self.size - self.current_size) // 8
            if size:
                yield RawBytes(self, "raw", size)

</source>
</class>

<class classid="16" nclones="3" nlines="25" similarity="73">
<source file="systems/Sick-Beard-build-507/lib/hachoir_parser/container/riff.py" startline="169" endline="197" pcid="1462">
def parseAviHeader(self):
    yield UInt32(self, "microsec_per_frame", "Microsecond per frame")
    yield UInt32(self, "max_byte_per_sec", "Maximum byte per second")
    yield NullBytes(self, "reserved", 4)

    # Flags
    yield NullBits(self, "reserved[]", 4)
    yield Bit(self, "has_index")
    yield Bit(self, "must_use_index")
    yield NullBits(self, "reserved[]", 2)
    yield Bit(self, "is_interleaved")
    yield NullBits(self, "reserved[]", 2)
    yield Bit(self, "trust_cktype")
    yield NullBits(self, "reserved[]", 4)
    yield Bit(self, "was_capture_file")
    yield Bit(self, "is_copyrighted")
    yield NullBits(self, "reserved[]", 14)

    yield UInt32(self, "total_frame", "Total number of frames in the video")
    yield UInt32(self, "init_frame", "Initial frame (used in interleaved video)")
    yield UInt32(self, "nb_stream", "Number of streams")
    yield UInt32(self, "sug_buf_size", "Suggested buffer size")
    yield UInt32(self, "width", "Width in pixel")
    yield UInt32(self, "height", "Height in pixel")
    yield UInt32(self, "scale")
    yield UInt32(self, "rate")
    yield UInt32(self, "start")
    yield UInt32(self, "length")

</source>
<source file="systems/Sick-Beard-build-507/lib/hachoir_parser/video/mov.py" startline="113" endline="139" pcid="2259">
    def createFields(self):
        yield textHandler(UInt8(self, "version"), hexadecimal)
        yield RawBytes(self, "flags", 3)
        yield TimestampMac32(self, "creation_date")
        yield TimestampMac32(self, "lastmod_date")
        yield UInt32(self, "time_scale")
        yield UInt32(self, "duration")
        yield QTFloat32(self, "play_speed")
        yield UInt16(self, "volume")
        yield PaddingBytes(self, "reserved[]", 10)
        yield QTFloat32(self, "geom_a", "Width scale")
        yield QTFloat32(self, "geom_b", "Width rotate")
        yield QTFloat32(self, "geom_u", "Width angle")
        yield QTFloat32(self, "geom_c", "Height rotate")
        yield QTFloat32(self, "geom_d", "Height scale")
        yield QTFloat32(self, "geom_v", "Height angle")
        yield QTFloat32(self, "geom_x", "Position X")
        yield QTFloat32(self, "geom_y", "Position Y")
        yield QTFloat32(self, "geom_w", "Divider scale")
        yield UInt32(self, "preview_start")
        yield UInt32(self, "preview_length")
        yield UInt32(self, "still_poster")
        yield UInt32(self, "sel_start")
        yield UInt32(self, "sel_length")
        yield UInt32(self, "current_time")
        yield UInt32(self, "next_track")

</source>
<source file="systems/Sick-Beard-build-507/lib/hachoir_parser/video/mov.py" startline="42" endline="71" pcid="2254">
    def createFields(self):
        yield textHandler(UInt8(self, "version"), hexadecimal)

        # TODO: sum of :
        # TrackEnabled = 1;
        # TrackInMovie = 2;
        # TrackInPreview = 4;
        # TrackInPoster = 8
        yield RawBytes(self, "flags", 3)

        yield TimestampMac32(self, "creation_date")
        yield TimestampMac32(self, "lastmod_date")
        yield UInt32(self, "track_id")
        yield PaddingBytes(self, "reserved[]", 8)
        yield UInt32(self, "duration")
        yield PaddingBytes(self, "reserved[]", 8)
        yield Int16(self, "video_layer", "Middle is 0, negative in front")
        yield PaddingBytes(self, "other", 2)
        yield QTFloat32(self, "geom_a", "Width scale")
        yield QTFloat32(self, "geom_b", "Width rotate")
        yield QTFloat32(self, "geom_u", "Width angle")
        yield QTFloat32(self, "geom_c", "Height rotate")
        yield QTFloat32(self, "geom_d", "Height scale")
        yield QTFloat32(self, "geom_v", "Height angle")
        yield QTFloat32(self, "geom_x", "Position X")
        yield QTFloat32(self, "geom_y", "Position Y")
        yield QTFloat32(self, "geom_w", "Divider scale")
        yield QTFloat32(self, "frame_size_width")
        yield QTFloat32(self, "frame_size_height")

</source>
</class>

<class classid="17" nclones="4" nlines="11" similarity="72">
<source file="systems/Sick-Beard-build-507/lib/hachoir_parser/archive/zip.py" startline="146" endline="157" pcid="1599">
def ZipStartCommonFields(self):
    yield ZipVersion(self, "version_needed", "Version needed")
    yield ZipGeneralFlags(self, "flags", "General purpose flag")
    yield Enum(UInt16(self, "compression", "Compression method"),
               COMPRESSION_METHOD)
    yield TimeDateMSDOS32(self, "last_mod", "Last modification file time")
    yield textHandler(UInt32(self, "crc32", "CRC-32"), hexadecimal)
    yield UInt32(self, "compressed_size", "Compressed size")
    yield UInt32(self, "uncompressed_size", "Uncompressed size")
    yield UInt16(self, "filename_length", "Filename length")
    yield UInt16(self, "extra_length", "Extra fields length")

</source>
<source file="systems/Sick-Beard-build-507/lib/hachoir_parser/program/elf.py" startline="103" endline="113" pcid="1918">

    def createFields(self):
        yield Enum(UInt16(self, "type", "Type"), ProgramHeader32.TYPE_NAME)
        yield UInt16(self, "flags", "Flags")
        yield UInt32(self, "offset", "Offset")
        yield textHandler(UInt32(self, "vaddr", "V. address"), hexadecimal)
        yield textHandler(UInt32(self, "paddr", "P. address"), hexadecimal)
        yield UInt32(self, "file_size", "File size")
        yield UInt32(self, "mem_size", "Memory size")
        yield UInt32(self, "align", "Alignment")
        yield UInt32(self, "xxx", "???")
</source>
<source file="systems/Sick-Beard-build-507/lib/hachoir_parser/image/png.py" startline="49" endline="60" pcid="2432">
def headerParse(parent):
    yield UInt32(parent, "width", "Width (pixels)")
    yield UInt32(parent, "height", "Height (pixels)")
    yield UInt8(parent, "bit_depth", "Bit depth")
    yield NullBits(parent, "reserved", 5)
    yield Bit(parent, "has_alpha", "Has alpha channel?")
    yield Bit(parent, "color", "Color used?")
    yield Bit(parent, "has_palette", "Has a color palette?")
    yield Enum(UInt8(parent, "compression", "Compression method"), COMPRESSION_NAME)
    yield UInt8(parent, "filter", "Filter method")
    yield UInt8(parent, "interlace", "Interlace method")

</source>
<source file="systems/Sick-Beard-build-507/lib/hachoir_parser/program/elf.py" startline="82" endline="93" pcid="1916">
    def createFields(self):
        yield UInt32(self, "name", "Name")
        yield Enum(UInt32(self, "type", "Type"), self.TYPE_NAME)
        yield UInt32(self, "flags", "Flags")
        yield textHandler(UInt32(self, "VMA", "Virtual memory address"), hexadecimal)
        yield textHandler(UInt32(self, "LMA", "Logical memory address (in file)"), hexadecimal)
        yield textHandler(UInt32(self, "size", "Size"), hexadecimal)
        yield UInt32(self, "link", "Link")
        yield UInt32(self, "info", "Information")
        yield UInt32(self, "addr_align", "Address alignment")
        yield UInt32(self, "entry_size", "Entry size")

</source>
</class>

<class classid="18" nclones="2" nlines="12" similarity="75">
<source file="systems/Sick-Beard-build-507/lib/hachoir_parser/program/java.py" startline="389" endline="400" pcid="1898">
    def createFields(self):
        yield UInt8(self, "opcode")
        pad = paddingSize(self.address+8, 32)
        if pad:
            yield NullBits(self, "padding", pad)
        yield Int32(self, "default")
        low = Int32(self, "low")
        yield low
        high = Int32(self, "high")
        yield high
        for i in range(high.value-low.value+1):
            yield Int32(self, "offset[]")
</source>
<source file="systems/Sick-Beard-build-507/lib/hachoir_parser/program/java.py" startline="405" endline="415" pcid="1900">
    def createFields(self):
        yield UInt8(self, "opcode")
        pad = paddingSize(self.address+8, 32)
        if pad:
            yield NullBits(self, "padding", pad)
        yield Int32(self, "default")
        n = Int32(self, "npairs")
        yield n
        for i in range(n.value):
            yield Int32(self, "match[]")
            yield Int32(self, "offset[]")
</source>
</class>

<class classid="19" nclones="2" nlines="19" similarity="76">
<source file="systems/Sick-Beard-build-507/lib/hachoir_parser/program/java.py" startline="715" endline="743" pcid="1906">
    def createFields(self):
        # Access flags (16 bits)
        yield NullBits(self, "reserved[]", 8)
        yield Bit(self, "transient")
        yield Bit(self, "volatile")
        yield NullBits(self, "reserved[]", 1)
        yield Bit(self, "final")
        yield Bit(self, "static")
        yield Bit(self, "protected")
        yield Bit(self, "private")
        yield Bit(self, "public")

        yield CPIndex(self, "name_index", "Field name", target_types="Utf8")
        yield CPIndex(self, "descriptor_index", "Field descriptor", target_types="Utf8",
                target_text_handler=parse_field_descriptor)
        yield UInt16(self, "attributes_count", "Number of field attributes")
        if self["attributes_count"].value > 0:
            yield FieldArray(self, "attributes", AttributeInfo,
                    self["attributes_count"].value)


###############################################################################
# method_info {
#        u2 access_flags;
#        u2 name_index;
#        u2 descriptor_index;
#        u2 attributes_count;
#        attribute_info attributes[attributes_count];
# }
</source>
<source file="systems/Sick-Beard-build-507/lib/hachoir_parser/program/java.py" startline="745" endline="776" pcid="1907">
    def createFields(self):
        # Access flags (16 bits)
        yield NullBits(self, "reserved[]", 4)
        yield Bit(self, "strict")
        yield Bit(self, "abstract")
        yield NullBits(self, "reserved[]", 1)
        yield Bit(self, "native")
        yield NullBits(self, "reserved[]", 2)
        yield Bit(self, "synchronized")
        yield Bit(self, "final")
        yield Bit(self, "static")
        yield Bit(self, "protected")
        yield Bit(self, "private")
        yield Bit(self, "public")

        yield CPIndex(self, "name_index", "Method name", target_types="Utf8")
        yield CPIndex(self, "descriptor_index", "Method descriptor",
                target_types="Utf8",
                target_text_handler=parse_method_descriptor)
        yield UInt16(self, "attributes_count", "Number of method attributes")
        if self["attributes_count"].value > 0:
            yield FieldArray(self, "attributes", AttributeInfo,
                    self["attributes_count"].value)


###############################################################################
# attribute_info {
#        u2 attribute_name_index;
#        u4 attribute_length;
#        u1 info[attribute_length];
# }
# [...]
</source>
</class>

<class classid="20" nclones="2" nlines="12" similarity="100">
<source file="systems/Sick-Beard-build-507/lib/hachoir_parser/audio/8svx.py" startline="80" endline="92" pcid="2029">
    def createFields(self):
        yield String(self, "type", 4, "Signature (FORM)", charset="ASCII")
        yield filesizeHandler(UInt32(self, "size"))
        size = self["size"].value
        if size:
            if self._parser:
                for field in self._parser(self):
                    yield field
                if size % 2:
                    yield NullBytes(self, "padding", 1)
            else:
                yield RawBytes(self, "data", size)

</source>
<source file="systems/Sick-Beard-build-507/lib/hachoir_parser/audio/aiff.py" startline="80" endline="92" pcid="2085">
    def createFields(self):
        yield String(self, "type", 4, "Signature (FORM)", charset="ASCII")
        yield filesizeHandler(UInt32(self, "size"))
        size = self["size"].value
        if size:
            if self._parser:
                for field in self._parser(self):
                    yield field
                if size % 2:
                    yield NullBytes(self, "padding", 1)
            else:
                yield RawBytes(self, "data", size)

</source>
</class>

<class classid="21" nclones="2" nlines="10" similarity="80">
<source file="systems/Sick-Beard-build-507/lib/hachoir_parser/image/tga.py" startline="52" endline="62" pcid="2380">
    def validate(self):
        if self["version"].value != 1:
            return "Unknown version"
        if self["codec"].value not in self.CODEC_NAME:
            return "Unknown codec"
        if self["x_min"].value != 0 or self["y_min"].value != 0:
            return "(x_min, y_min) is not (0,0)"
        if self["bpp"].value not in (8, 24):
            return "Unknown bits/pixel value"
        return True

</source>
<source file="systems/Sick-Beard-build-507/lib/hachoir_parser/image/pcx.py" startline="32" endline="42" pcid="2490">
    def validate(self):
        if self["id"].value != 10:
            return "Wrong signature"
        if self["version"].value not in self.version_name:
            return "Unknown format version"
        if self["bpp"].value not in (1, 2, 4, 8, 24, 32):
            return "Unknown bits/pixel"
        if self["reserved[0]"].value != "\0":
            return "Invalid reserved value"
        return True

</source>
</class>

<class classid="22" nclones="2" nlines="10" similarity="80">
<source file="systems/Sick-Beard-build-507/lib/hachoir_core/field/seekable_field_set.py" startline="68" endline="78" pcid="2682">
    def getField(self, key, const=True):
        if isinstance(key, (int, long)):
            if key < 0:
                raise KeyError("Key must be positive!")
            if not const:
                self.readFirstFields(key+1)
            if len(self._field_array) <= key:
                raise MissingField(self, key)
            return self._field_array[key]
        return Field.getField(self, key, const)

</source>
<source file="systems/Sick-Beard-build-507/lib/hachoir_core/field/generic_field_set.py" startline="218" endline="228" pcid="2726">

    def getField(self, key, const=True):
        if isinstance(key, (int, long)):
            if key < 0:
                raise KeyError("Key must be positive!")
            if not const:
                self.readFirstFields(key+1)
            if len(self._fields.values) <= key:
                raise MissingField(self, key)
            return self._fields.values[key]
        return Field.getField(self, key, const)
</source>
</class>

<class classid="23" nclones="3" nlines="11" similarity="72">
<source file="systems/Sick-Beard-build-507/lib/hachoir_core/tools.py" startline="159" endline="182" pcid="2893">

def humanFilesize(size):
    """
    Convert a file size in byte to human natural representation.
    It uses the values: 1 KB is 1024 bytes, 1 MB is 1024 KB, etc.
    The result is an unicode string.

    >>> humanFilesize(1)
    u'1 byte'
    >>> humanFilesize(790)
    u'790 bytes'
    >>> humanFilesize(256960)
    u'250.9 KB'
    """
    if size < 10000:
        return ngettext("%u byte", "%u bytes", size) % size
    units = [_("KB"), _("MB"), _("GB"), _("TB")]
    size = float(size)
    divisor = 1024
    for unit in units:
        size = size / divisor
        if size < divisor:
            return "%.1f %s" % (size, unit)
    return "%u %s" % (size, unit)
</source>
<source file="systems/Sick-Beard-build-507/lib/hachoir_core/tools.py" startline="183" endline="206" pcid="2894">

def humanBitSize(size):
    """
    Convert a size in bit to human classic representation.
    It uses the values: 1 Kbit is 1000 bits, 1 Mbit is 1000 Kbit, etc.
    The result is an unicode string.

    >>> humanBitSize(1)
    u'1 bit'
    >>> humanBitSize(790)
    u'790 bits'
    >>> humanBitSize(256960)
    u'257.0 Kbit'
    """
    divisor = 1000
    if size < divisor:
        return ngettext("%u bit", "%u bits", size) % size
    units = [u"Kbit", u"Mbit", u"Gbit", u"Tbit"]
    size = float(size)
    for unit in units:
        size = size / divisor
        if size < divisor:
            return "%.1f %s" % (size, unit)
    return u"%u %s" % (size, unit)
</source>
<source file="systems/Sick-Beard-build-507/lib/hachoir_core/tools.py" startline="219" endline="240" pcid="2896">

def humanFrequency(hertz):
    """
    Convert a frequency in hertz to human classic representation.
    It uses the values: 1 KHz is 1000 Hz, 1 MHz is 1000 KMhz, etc.
    The result is an unicode string.

    >>> humanFrequency(790)
    u'790 Hz'
    >>> humanFrequency(629469)
    u'629.5 kHz'
    """
    divisor = 1000
    if hertz < divisor:
        return u"%u Hz" % hertz
    units = [u"kHz", u"MHz", u"GHz", u"THz"]
    hertz = float(hertz)
    for unit in units:
        hertz = hertz / divisor
        if hertz < divisor:
            return u"%.1f %s" % (hertz, unit)
    return u"%s %s" % (hertz, unit)
</source>
</class>

<class classid="24" nclones="3" nlines="11" similarity="81">
<source file="systems/Sick-Beard-build-507/cherrypy/wsgiserver/__init__.py" startline="224" endline="236" pcid="3245">
    def readlines(self, sizehint=0):
        # Shamelessly stolen from StringIO
        total = 0
        lines = []
        line = self.readline()
        while line:
            lines.append(line)
            total += len(line)
            if 0 < sizehint <= total:
                break
            line = self.readline()
        return lines
    
</source>
<source file="systems/Sick-Beard-build-507/cherrypy/wsgiserver/__init__.py" startline="411" endline="423" pcid="3260">
    def readlines(self, sizehint=0):
        # Shamelessly stolen from StringIO
        total = 0
        lines = []
        line = self.readline(sizehint)
        while line:
            lines.append(line)
            total += len(line)
            if 0 < sizehint <= total:
                break
            line = self.readline(sizehint)
        return lines
    
</source>
<source file="systems/Sick-Beard-build-507/cherrypy/wsgiserver/__init__.py" startline="281" endline="293" pcid="3252">
    def readlines(self, sizehint=0):
        # Shamelessly stolen from StringIO
        total = 0
        lines = []
        line = self.readline(sizehint)
        while line:
            lines.append(line)
            total += len(line)
            if 0 < sizehint <= total:
                break
            line = self.readline(sizehint)
        return lines
    
</source>
</class>

<class classid="25" nclones="2" nlines="10" similarity="100">
<source file="systems/Sick-Beard-build-507/cherrypy/wsgiserver/__init__.py" startline="257" endline="268" pcid="3250">
    def read(self, size=None):
        if self.remaining == 0:
            return ''
        if size is None:
            size = self.remaining
        else:
            size = min(size, self.remaining)
        
        data = self.rfile.read(size)
        self.remaining -= len(data)
        return data
    
</source>
<source file="systems/Sick-Beard-build-507/cherrypy/wsgiserver/__init__.py" startline="269" endline="280" pcid="3251">
    def readline(self, size=None):
        if self.remaining == 0:
            return ''
        if size is None:
            size = self.remaining
        else:
            size = min(size, self.remaining)
        
        data = self.rfile.readline(size)
        self.remaining -= len(data)
        return data
    
</source>
</class>

<class classid="26" nclones="2" nlines="13" similarity="71">
<source file="systems/Sick-Beard-build-507/cherrypy/process/win32.py" startline="20" endline="32" pcid="3658">
    def start(self):
        if self.is_set:
            self.bus.log('Handler for console events already set.', level=40)
            return
        
        result = win32api.SetConsoleCtrlHandler(self.handle, 1)
        if result == 0:
            self.bus.log('Could not SetConsoleCtrlHandler (error %r)' % 
                         win32api.GetLastError(), level=40)
        else:
            self.bus.log('Set handler for console events.', level=40)
            self.is_set = True
    
</source>
<source file="systems/Sick-Beard-build-507/cherrypy/process/win32.py" startline="33" endline="50" pcid="3659">
    def stop(self):
        if not self.is_set:
            self.bus.log('Handler for console events already off.', level=40)
            return
        
        try:
            result = win32api.SetConsoleCtrlHandler(self.handle, 0)
        except ValueError:
            # "ValueError: The object has not been registered"
            result = 1
        
        if result == 0:
            self.bus.log('Could not remove SetConsoleCtrlHandler (error %r)' % 
                         win32api.GetLastError(), level=40)
        else:
            self.bus.log('Removed handler for console events.', level=40)
            self.is_set = False
    
</source>
</class>

<class classid="27" nclones="2" nlines="11" similarity="72">
<source file="systems/Sick-Beard-build-507/cherrypy/process/servers.py" startline="253" endline="269" pcid="3723">
def wait_for_free_port(host, port):
    """Wait for the specified port to become free (drop requests)."""
    if not host:
        raise ValueError("Host values of '' or None are not allowed.")
    
    for trial in range(50):
        try:
            # we are expecting a free port, so reduce the timeout
            check_port(host, port, timeout=0.1)
        except IOError:
            # Give the old server thread time to free the port.
            time.sleep(0.1)
        else:
            return
    
    raise IOError("Port %r not free on %r" % (port, host))

</source>
<source file="systems/Sick-Beard-build-507/cherrypy/process/servers.py" startline="270" endline="283" pcid="3724">
def wait_for_occupied_port(host, port):
    """Wait for the specified port to become active (receive requests)."""
    if not host:
        raise ValueError("Host values of '' or None are not allowed.")
    
    for trial in range(50):
        try:
            check_port(host, port)
        except IOError:
            return
        else:
            time.sleep(.1)
    
    raise IOError("Port %r not bound on %r" % (port, host))
</source>
</class>

<class classid="28" nclones="3" nlines="10" similarity="100">
<source file="systems/Sick-Beard-build-507/sickbeard/searchBacklog.py" startline="79" endline="89" pcid="3817">
        def titler(x):
            if not x:
                return x
            if not x.lower().startswith('a to ') and x.lower().startswith('a '):
                    x = x[2:]
            elif x.lower().startswith('an '):
                    x = x[3:]
            elif x.lower().startswith('the '):
                    x = x[4:]
            return x
        # sort shows the same way we show them, makes it easier to follow along
</source>
<source file="systems/Sick-Beard-build-507/sickbeard/webapi.py" startline="136" endline="147" pcid="4505">
        def titler(x):
            if not x:
                return x
            if not x.lower().startswith('a to ') and x.lower().startswith('a '):
                    x = x[2:]
            elif x.lower().startswith('an '):
                    x = x[3:]
            elif x.lower().startswith('the '):
                    x = x[4:]
            return x

        # enforce a 100 show limit to ensure performance
</source>
<source file="systems/Sick-Beard-build-507/sickbeard/webserve.py" startline="2264" endline="2273" pcid="4108">
        def titler(x):
            if not x:
                return x
            if not x.lower().startswith('a to ') and x.lower().startswith('a '):
                    x = x[2:]
            elif x.lower().startswith('an '):
                    x = x[3:]
            elif x.lower().startswith('the '):
                    x = x[4:]
            return x
</source>
</class>

<class classid="29" nclones="5" nlines="11" similarity="90">
<source file="systems/Sick-Beard-build-507/sickbeard/config.py" startline="48" endline="63" pcid="3917">
def change_HTTPS_CERT(https_cert):

    if https_cert == '':
        sickbeard.HTTPS_CERT = ''
        return True

    if os.path.normpath(sickbeard.HTTPS_CERT) != os.path.normpath(https_cert):
        if helpers.makeDir(os.path.dirname(os.path.abspath(https_cert))):
            sickbeard.HTTPS_CERT = os.path.normpath(https_cert)
            logger.log(u"Changed https cert path to " + https_cert)
        else:
            return False

    return True


</source>
<source file="systems/Sick-Beard-build-507/sickbeard/config.py" startline="130" endline="145" pcid="3921">
def change_TORRENT_DIR(torrent_dir):

    if torrent_dir == '':
        sickbeard.TORRENT_DIR = ''
        return True

    if os.path.normpath(sickbeard.TORRENT_DIR) != os.path.normpath(torrent_dir):
        if helpers.makeDir(torrent_dir):
            sickbeard.TORRENT_DIR = os.path.normpath(torrent_dir)
            logger.log(u"Changed torrent folder to " + torrent_dir)
        else:
            return False

    return True


</source>
<source file="systems/Sick-Beard-build-507/sickbeard/config.py" startline="64" endline="79" pcid="3918">
def change_HTTPS_KEY(https_key):

    if https_key == '':
        sickbeard.HTTPS_KEY = ''
        return True

    if os.path.normpath(sickbeard.HTTPS_KEY) != os.path.normpath(https_key):
        if helpers.makeDir(os.path.dirname(os.path.abspath(https_key))):
            sickbeard.HTTPS_KEY = os.path.normpath(https_key)
            logger.log(u"Changed https key path to " + https_key)
        else:
            return False

    return True


</source>
<source file="systems/Sick-Beard-build-507/sickbeard/config.py" startline="146" endline="161" pcid="3922">
def change_TV_DOWNLOAD_DIR(tv_download_dir):

    if tv_download_dir == '':
        sickbeard.TV_DOWNLOAD_DIR = ''
        return True

    if os.path.normpath(sickbeard.TV_DOWNLOAD_DIR) != os.path.normpath(tv_download_dir):
        if helpers.makeDir(tv_download_dir):
            sickbeard.TV_DOWNLOAD_DIR = os.path.normpath(tv_download_dir)
            logger.log(u"Changed TV download folder to " + tv_download_dir)
        else:
            return False

    return True


</source>
<source file="systems/Sick-Beard-build-507/sickbeard/config.py" startline="114" endline="129" pcid="3920">
def change_NZB_DIR(nzb_dir):

    if nzb_dir == '':
        sickbeard.NZB_DIR = ''
        return True

    if os.path.normpath(sickbeard.NZB_DIR) != os.path.normpath(nzb_dir):
        if helpers.makeDir(nzb_dir):
            sickbeard.NZB_DIR = os.path.normpath(nzb_dir)
            logger.log(u"Changed NZB folder to " + nzb_dir)
        else:
            return False

    return True


</source>
</class>

<class classid="30" nclones="2" nlines="12" similarity="100">
<source file="systems/Sick-Beard-build-507/sickbeard/config.py" startline="316" endline="332" pcid="3932">
def check_setting_int(config, cfg_name, item_name, def_val):
    try:
        my_val = int(config[cfg_name][item_name])
    except:
        my_val = def_val
        try:
            config[cfg_name][item_name] = my_val
        except:
            config[cfg_name] = {}
            config[cfg_name][item_name] = my_val
    logger.log(item_name + " -> " + str(my_val), logger.DEBUG)
    return my_val


################################################################################
# Check_setting_float                                                          #
################################################################################
</source>
<source file="systems/Sick-Beard-build-507/sickbeard/config.py" startline="333" endline="350" pcid="3933">
def check_setting_float(config, cfg_name, item_name, def_val):
    try:
        my_val = float(config[cfg_name][item_name])
    except:
        my_val = def_val
        try:
            config[cfg_name][item_name] = my_val
        except:
            config[cfg_name] = {}
            config[cfg_name][item_name] = my_val

    logger.log(item_name + " -> " + str(my_val), logger.DEBUG)
    return my_val


################################################################################
# Check_setting_str                                                            #
################################################################################
</source>
</class>

<class classid="31" nclones="2" nlines="16" similarity="93">
<source file="systems/Sick-Beard-build-507/sickbeard/tvcache.py" startline="45" endline="66" pcid="3945">
    def __init__(self, providerName):
        db.DBConnection.__init__(self, "cache.db")

        # Create the table if it's not already there
        try:
            sql = "CREATE TABLE [" + providerName + "] (name TEXT, season NUMERIC, episodes TEXT, tvrid NUMERIC, tvdbid NUMERIC, url TEXT, time NUMERIC, quality TEXT);"
            self.connection.execute(sql)
            self.connection.commit()
        except sqlite3.OperationalError, e:
            if str(e) != "table [" + providerName + "] already exists":
                raise

        # Create the table if it's not already there
        try:
            sql = "CREATE TABLE lastUpdate (provider TEXT, time NUMERIC);"
            self.connection.execute(sql)
            self.connection.commit()
        except sqlite3.OperationalError, e:
            if str(e) != "table lastUpdate already exists":
                raise


</source>
<source file="systems/Sick-Beard-build-507/tests/test_lib.py" startline="136" endline="157" pcid="4781">
    def __init__(self, providerName):
        db.DBConnection.__init__(self, os.path.join(TESTDIR, TESTCACHEDBNAME))

        # Create the table if it's not already there
        try:
            sql = "CREATE TABLE " + providerName + " (name TEXT, season NUMERIC, episodes TEXT, tvrid NUMERIC, tvdbid NUMERIC, url TEXT, time NUMERIC, quality TEXT);"
            self.connection.execute(sql)
            self.connection.commit()
        except sqlite3.OperationalError, e:
            if str(e) != "table " + providerName + " already exists":
                raise

        # Create the table if it's not already there
        try:
            sql = "CREATE TABLE lastUpdate (provider TEXT, time NUMERIC);"
            self.connection.execute(sql)
            self.connection.commit()
        except sqlite3.OperationalError, e:
            if str(e) != "table lastUpdate already exists":
                raise

# this will override the normal db connection
</source>
</class>

<class classid="32" nclones="2" nlines="27" similarity="85">
<source file="systems/Sick-Beard-build-507/sickbeard/tvcache.py" startline="97" endline="138" pcid="3952">
    def updateCache(self):

        if not self.shouldUpdate():
            return

        if self._checkAuth(None):

            data = self._getRSSData()

            # as long as the http request worked we count this as an update
            if data:
                self.setLastUpdate()
            else:
                return []

            # now that we've loaded the current RSS feed lets delete the old cache
            logger.log(u"Clearing " + self.provider.name + " cache and updating with new information")
            self._clearCache()

            parsedXML = helpers.parse_xml(data)

            if parsedXML is None:
                logger.log(u"Error trying to load " + self.provider.name + " RSS feed", logger.ERROR)
                return []

            if self._checkAuth(parsedXML):

                if parsedXML.tag == 'rss':
                    items = parsedXML.findall('.//item')

                else:
                    logger.log(u"Resulting XML from " + self.provider.name + " isn't RSS, not parsing it", logger.ERROR)
                    return []

                for item in items:
                    self._parseItem(item)

            else:
                raise AuthException(u"Your authentication credentials for " + self.provider.name + " are incorrect, check your config")

        return []

</source>
<source file="systems/Sick-Beard-build-507/sickbeard/providers/hdbits.py" startline="177" endline="216" pcid="4429">
    def updateCache(self):

        if not self.shouldUpdate():
            return

        if self._checkAuth(None):

            data = self._getRSSData()

            # As long as we got something from the provider we count it as an update
            if data:
                self.setLastUpdate()
            else:
                return []

            logger.log(u"Clearing " + self.provider.name + " cache and updating with new information")
            self._clearCache()

            parsedJSON = helpers.parse_json(data)

            if parsedJSON is None:
                logger.log(u"Error trying to load " + self.provider.name + " JSON feed", logger.ERROR)
                return []

            if self._checkAuth(parsedJSON):
                if parsedJSON and 'data' in parsedJSON:
                    items = parsedJSON['data']
                else:
                    logger.log(u"Resulting JSON from " + self.provider.name + " isn't correct, not parsing it", logger.ERROR)
                    return []

                for item in items:
                    self._parseItem(item)

            else:
                raise exceptions.AuthException("Your authentication info for " + self.provider.name + " is incorrect, check your config")

        else:
            return []

</source>
</class>

<class classid="33" nclones="2" nlines="10" similarity="100">
<source file="systems/Sick-Beard-build-507/sickbeard/postProcessor.py" startline="219" endline="238" pcid="3999">
    def _move(self, file_path, new_path, new_base_name, associated_files=False):
        """
        file_path: The full path of the media file to move
        new_path: Destination path where we want to move the file to
        new_base_name: The base filename (no extension) to use during the move. Use None to keep the same name.
        associated_files: Boolean, whether we should move similarly-named files too
        """

        def _int_move(cur_file_path, new_file_path):

            self._log(u"Moving file from " + cur_file_path + " to " + new_file_path, logger.DEBUG)
            try:
                helpers.moveFile(cur_file_path, new_file_path)
                helpers.chmodAsParent(new_file_path)
            except (IOError, OSError), e:
                self._log(u"Unable to move file " + cur_file_path + " to " + new_file_path + ": " + ex(e), logger.ERROR)
                raise e

        self._combined_file_operation(file_path, new_path, new_base_name, associated_files, action=_int_move)

</source>
<source file="systems/Sick-Beard-build-507/sickbeard/postProcessor.py" startline="239" endline="258" pcid="4001">
    def _copy(self, file_path, new_path, new_base_name, associated_files=False):
        """
        file_path: The full path of the media file to copy
        new_path: Destination path where we want to copy the file to
        new_base_name: The base filename (no extension) to use during the copy. Use None to keep the same name.
        associated_files: Boolean, whether we should copy similarly-named files too
        """

        def _int_copy(cur_file_path, new_file_path):

            self._log(u"Copying file from " + cur_file_path + " to " + new_file_path, logger.DEBUG)
            try:
                helpers.copyFile(cur_file_path, new_file_path)
                helpers.chmodAsParent(new_file_path)
            except (IOError, OSError), e:
                logger.log(u"Unable to copy file " + cur_file_path + " to " + new_file_path + ": " + ex(e), logger.ERROR)
                raise e

        self._combined_file_operation(file_path, new_path, new_base_name, associated_files, action=_int_copy)

</source>
</class>

<class classid="34" nclones="2" nlines="34" similarity="72">
<source file="systems/Sick-Beard-build-507/sickbeard/webserve.py" startline="1816" endline="1869" pcid="4079">
    def viewlog(self, minLevel=logger.MESSAGE, maxLines=500):

        t = PageTemplate(file="viewlogs.tmpl")
        t.submenu = ErrorLogsMenu

        minLevel = int(minLevel)

        data = []
        if os.path.isfile(logger.sb_log_instance.log_file_path):
            with ek.ek(open, logger.sb_log_instance.log_file_path) as f:
                data = f.readlines()

        regex = "^(\d\d\d\d)\-(\d\d)\-(\d\d)\s*(\d\d)\:(\d\d):(\d\d)\s*([A-Z]+)\s*(.+?)\s*\:\:\s*(.*)$"

        finalData = []

        numLines = 0
        lastLine = False
        numToShow = min(maxLines, len(data))

        for x in reversed(data):

            x = x.decode('utf-8')
            match = re.match(regex, x)

            if match:
                level = match.group(7)
                if level not in logger.reverseNames:
                    lastLine = False
                    continue

                if logger.reverseNames[level] >= minLevel:
                    lastLine = True
                    finalData.append(x)
                else:
                    lastLine = False
                    continue

            elif lastLine:
                finalData.append("AA" + x)

            numLines += 1

            if numLines >= numToShow:
                break

        result = "".join(finalData)

        t.logLines = result
        t.minLevel = minLevel

        return _munge(t)


</source>
<source file="systems/Sick-Beard-build-507/sickbeard/webapi.py" startline="1151" endline="1197" pcid="4552">
    def run(self):
        """ view sickbeard's log """
        # 10 = Debug / 20 = Info / 30 = Warning / 40 = Error
        minLevel = logger.reverseNames[str(self.min_level).upper()]

        data = []
        if os.path.isfile(logger.sb_log_instance.log_file_path):
            with ek.ek(open, logger.sb_log_instance.log_file_path) as f:
                data = f.readlines()

        regex = "^(\d\d\d\d)\-(\d\d)\-(\d\d)\s*(\d\d)\:(\d\d):(\d\d)\s*([A-Z]+)\s*(.+?)\s*\:\:\s*(.*)$"

        finalData = []

        numLines = 0
        lastLine = False
        numToShow = min(50, len(data))

        for x in reversed(data):

            x = x.decode('utf-8')
            match = re.match(regex, x)

            if match:
                level = match.group(7)
                if level not in logger.reverseNames:
                    lastLine = False
                    continue

                if logger.reverseNames[level] >= minLevel:
                    lastLine = True
                    finalData.append(x.rstrip("\n"))
                else:
                    lastLine = False
                    continue

            elif lastLine:
                finalData.append("AA" + x)

            numLines += 1

            if numLines >= numToShow:
                break

        return _responds(RESULT_SUCCESS, finalData)


</source>
</class>

<class classid="35" nclones="2" nlines="12" similarity="100">
<source file="systems/Sick-Beard-build-507/sickbeard/webserve.py" startline="1999" endline="2014" pcid="4091">
    def testXBMC(self, host=None, username=None, password=None):
        cherrypy.response.headers['Cache-Control'] = "max-age=0,no-cache,no-store"

        host = config.clean_hosts(host)
        finalResult = ''

        for curHost in [x.strip() for x in host.split(",")]:
            curResult = notifiers.xbmc_notifier.test_notify(urllib.unquote_plus(curHost), username, password)
            if len(curResult.split(":")) > 2 and 'OK' in curResult.split(":")[2]:
                finalResult += "Test XBMC notice sent successfully to " + urllib.unquote_plus(curHost)
            else:
                finalResult += "Test XBMC notice failed to " + urllib.unquote_plus(curHost)
            finalResult += "<br />\n"

        return finalResult

</source>
<source file="systems/Sick-Beard-build-507/sickbeard/webserve.py" startline="2016" endline="2031" pcid="4092">
    def testPLEX(self, host=None, username=None, password=None):
        cherrypy.response.headers['Cache-Control'] = "max-age=0,no-cache,no-store"

        host = config.clean_hosts(host)
        finalResult = ''

        for curHost in [x.strip() for x in host.split(",")]:
            curResult = notifiers.plex_notifier.test_notify(urllib.unquote_plus(curHost), username, password)
            if len(curResult.split(":")) > 2 and 'OK' in curResult.split(":")[2]:
                finalResult += "Test Plex notice sent successfully to " + urllib.unquote_plus(curHost)
            else:
                finalResult += "Test Plex notice failed to " + urllib.unquote_plus(curHost)
            finalResult += "<br />\n"

        return finalResult

</source>
</class>

<class classid="36" nclones="2" nlines="12" similarity="83">
<source file="systems/Sick-Beard-build-507/sickbeard/webserve.py" startline="2421" endline="2440" pcid="4112">
    def refreshShow(self, show=None):

        if show is None:
            return _genericMessage("Error", "Invalid show ID")

        showObj = sickbeard.helpers.findCertainShow(sickbeard.showList, int(show))

        if showObj is None:
            return _genericMessage("Error", "Unable to find the specified show")

        # force the update from the DB
        try:
            sickbeard.showQueueScheduler.action.refreshShow(showObj)  # @UndefinedVariable
        except exceptions.CantRefreshException, e:
            ui.notifications.error("Unable to refresh this show.", ex(e))

        time.sleep(3)

        redirect("/home/displayShow?show=" + str(showObj.tvdbid))

</source>
<source file="systems/Sick-Beard-build-507/sickbeard/webserve.py" startline="2442" endline="2462" pcid="4113">
    def updateShow(self, show=None, force=0):

        if show is None:
            return _genericMessage("Error", "Invalid show ID")

        showObj = sickbeard.helpers.findCertainShow(sickbeard.showList, int(show))

        if showObj is None:
            return _genericMessage("Error", "Unable to find the specified show")

        # force the update
        try:
            sickbeard.showQueueScheduler.action.updateShow(showObj, bool(force))  # @UndefinedVariable
        except exceptions.CantUpdateException, e:
            ui.notifications.error("Unable to update this show.", ex(e))

        # just give it some time
        time.sleep(3)

        redirect("/home/displayShow?show=" + str(showObj.tvdbid))

</source>
</class>

<class classid="37" nclones="2" nlines="11" similarity="72">
<source file="systems/Sick-Beard-build-507/sickbeard/databases/mainDB.py" startline="39" endline="56" pcid="4165">
    def fix_duplicate_shows(self):
        sqlResults = self.connection.select("SELECT show_id, tvdb_id, COUNT(tvdb_id) as count FROM tv_shows GROUP BY tvdb_id HAVING count > 1")

        for cur_duplicate in sqlResults:

            logger.log(u"Duplicate show detected! tvdb_id: " + str(cur_duplicate["tvdb_id"]) + u" count: " + str(cur_duplicate["count"]), logger.DEBUG)

            cur_dupe_results = self.connection.select("SELECT show_id, tvdb_id FROM tv_shows WHERE tvdb_id = ? LIMIT ?",
                                           [cur_duplicate["tvdb_id"], int(cur_duplicate["count"]) - 1]
                                           )

            for cur_dupe_id in cur_dupe_results:
                logger.log(u"Deleting duplicate show with tvdb_id: " + str(cur_dupe_id["tvdb_id"]) + u" show_id: " + str(cur_dupe_id["show_id"]))
                self.connection.action("DELETE FROM tv_shows WHERE show_id = ?", [cur_dupe_id["show_id"]])

        else:
            logger.log(u"No duplicate show, check passed")

</source>
<source file="systems/Sick-Beard-build-507/sickbeard/databases/mainDB.py" startline="57" endline="74" pcid="4166">
    def fix_duplicate_episodes(self):
        sqlResults = self.connection.select("SELECT showid, season, episode, COUNT(showid) as count FROM tv_episodes GROUP BY showid, season, episode HAVING count > 1")

        for cur_duplicate in sqlResults:

            logger.log(u"Duplicate episode detected! showid: " + str(cur_duplicate["showid"]) + u" season: " + str(cur_duplicate["season"]) + u" episode: " + str(cur_duplicate["episode"]) + u" count: " + str(cur_duplicate["count"]), logger.DEBUG)

            cur_dupe_results = self.connection.select("SELECT episode_id FROM tv_episodes WHERE showid = ? AND season = ? and episode = ? ORDER BY episode_id DESC LIMIT ?",
                                           [cur_duplicate["showid"], cur_duplicate["season"], cur_duplicate["episode"], int(cur_duplicate["count"]) - 1]
                                           )

            for cur_dupe_id in cur_dupe_results:
                logger.log(u"Deleting duplicate episode with episode_id: " + str(cur_dupe_id["episode_id"]))
                self.connection.action("DELETE FROM tv_episodes WHERE episode_id = ?", [cur_dupe_id["episode_id"]])

        else:
            logger.log(u"No duplicate episode, check passed")

</source>
</class>

<class classid="38" nclones="7" nlines="31" similarity="72">
<source file="systems/Sick-Beard-build-507/sickbeard/metadata/mede8er.py" startline="50" endline="89" pcid="4200">
    def __init__(self,
                 show_metadata=False,
                 episode_metadata=False,
                 fanart=False,
                 poster=False,
                 banner=False,
                 episode_thumbnails=False,
                 season_posters=False,
                 season_banners=False,
                 season_all_poster=False,
                 season_all_banner=False):

        mediabrowser.MediaBrowserMetadata.__init__(self,
                                         show_metadata,
                                         episode_metadata,
                                         fanart,
                                         poster,
                                         banner,
                                         episode_thumbnails,
                                         season_posters,
                                         season_banners,
                                         season_all_poster,
                                         season_all_banner)

        self.name = "Mede8er"

        self.fanart_name = "fanart.jpg"

        # web-ui metadata template
        # self.eg_show_metadata = "series.xml"
        self.eg_episode_metadata = "Season##\\<i>filename</i>.xml"
        self.eg_fanart = "fanart.jpg"
        # self.eg_poster = "folder.jpg"
        # self.eg_banner = "banner.jpg"
        self.eg_episode_thumbnails = "Season##\\<i>filename</i>.jpg"
        # self.eg_season_posters = "Season##\\folder.jpg"
        # self.eg_season_banners = "Season##\\banner.jpg"
        # self.eg_season_all_poster = "<i>not supported</i>"
        # self.eg_season_all_banner = "<i>not supported</i>"

</source>
<source file="systems/Sick-Beard-build-507/sickbeard/metadata/ps3.py" startline="37" endline="77" pcid="4211">
    def __init__(self,
                 show_metadata=False,
                 episode_metadata=False,
                 fanart=False,
                 poster=False,
                 banner=False,
                 episode_thumbnails=False,
                 season_posters=False,
                 season_banners=False,
                 season_all_poster=False,
                 season_all_banner=False):

        generic.GenericMetadata.__init__(self,
                                         show_metadata,
                                         episode_metadata,
                                         fanart,
                                         poster,
                                         banner,
                                         episode_thumbnails,
                                         season_posters,
                                         season_banners,
                                         season_all_poster,
                                         season_all_banner)

        self.name = "Sony PS3"

        self.poster_name = "cover.jpg"

        # web-ui metadata template
        self.eg_show_metadata = "<i>not supported</i>"
        self.eg_episode_metadata = "<i>not supported</i>"
        self.eg_fanart = "<i>not supported</i>"
        self.eg_poster = "cover.jpg"
        self.eg_banner = "<i>not supported</i>"
        self.eg_episode_thumbnails = "Season##\\<i>filename</i>.ext.cover.jpg"
        self.eg_season_posters = "<i>not supported</i>"
        self.eg_season_banners = "<i>not supported</i>"
        self.eg_season_all_poster = "<i>not supported</i>"
        self.eg_season_all_banner = "<i>not supported</i>"

    # Override with empty methods for unsupported features
</source>
<source file="systems/Sick-Beard-build-507/sickbeard/metadata/wdtv.py" startline="51" endline="93" pcid="4239">
    def __init__(self,
                 show_metadata=False,
                 episode_metadata=False,
                 fanart=False,
                 poster=False,
                 banner=False,
                 episode_thumbnails=False,
                 season_posters=False,
                 season_banners=False,
                 season_all_poster=False,
                 season_all_banner=False):

        generic.GenericMetadata.__init__(self,
                                         show_metadata,
                                         episode_metadata,
                                         fanart,
                                         poster,
                                         banner,
                                         episode_thumbnails,
                                         season_posters,
                                         season_banners,
                                         season_all_poster,
                                         season_all_banner)

        self.name = 'WDTV'

        self._ep_nfo_extension = 'xml'

        self.poster_name = "folder.jpg"

        # web-ui metadata template
        self.eg_show_metadata = "<i>not supported</i>"
        self.eg_episode_metadata = "Season##\\<i>filename</i>.xml"
        self.eg_fanart = "<i>not supported</i>"
        self.eg_poster = "folder.jpg"
        self.eg_banner = "<i>not supported</i>"
        self.eg_episode_thumbnails = "Season##\\<i>filename</i>.metathumb"
        self.eg_season_posters = "Season##\\folder.jpg"
        self.eg_season_banners = "<i>not supported</i>"
        self.eg_season_all_poster = "<i>not supported</i>"
        self.eg_season_all_banner = "<i>not supported</i>"

    # Override with empty methods for unsupported features
</source>
<source file="systems/Sick-Beard-build-507/sickbeard/metadata/tivo.py" startline="47" endline="87" pcid="4223">
    def __init__(self,
                 show_metadata=False,
                 episode_metadata=False,
                 fanart=False,
                 poster=False,
                 banner=False,
                 episode_thumbnails=False,
                 season_posters=False,
                 season_banners=False,
                 season_all_poster=False,
                 season_all_banner=False):

        generic.GenericMetadata.__init__(self,
                                         show_metadata,
                                         episode_metadata,
                                         fanart,
                                         poster,
                                         banner,
                                         episode_thumbnails,
                                         season_posters,
                                         season_banners,
                                         season_all_poster,
                                         season_all_banner)

        self.name = 'TIVO'

        self._ep_nfo_extension = "txt"

        # web-ui metadata template
        self.eg_show_metadata = "<i>not supported</i>"
        self.eg_episode_metadata = "Season##\\.meta\\<i>filename</i>.ext.txt"
        self.eg_fanart = "<i>not supported</i>"
        self.eg_poster = "<i>not supported</i>"
        self.eg_banner = "<i>not supported</i>"
        self.eg_episode_thumbnails = "<i>not supported</i>"
        self.eg_season_posters = "<i>not supported</i>"
        self.eg_season_banners = "<i>not supported</i>"
        self.eg_season_all_poster = "<i>not supported</i>"
        self.eg_season_all_banner = "<i>not supported</i>"

    # Override with empty methods for unsupported features
</source>
<source file="systems/Sick-Beard-build-507/sickbeard/metadata/xbmc.py" startline="44" endline="85" pcid="4206">
    def __init__(self,
                 show_metadata=False,
                 episode_metadata=False,
                 fanart=False,
                 poster=False,
                 banner=False,
                 episode_thumbnails=False,
                 season_posters=False,
                 season_banners=False,
                 season_all_poster=False,
                 season_all_banner=False):

        xbmc_12plus.XBMC_12PlusMetadata.__init__(self,
                                         show_metadata,
                                         episode_metadata,
                                         fanart,
                                         poster,
                                         banner,
                                         episode_thumbnails,
                                         season_posters,
                                         season_banners,
                                         season_all_poster,
                                         season_all_banner)

        self.name = 'XBMC'

        self.poster_name = self.banner_name = "folder.jpg"
        self.season_all_poster_name = "season-all.tbn"

        # web-ui metadata template
        # self.eg_show_metadata = "tvshow.nfo"
        # self.eg_episode_metadata = "Season##\\<i>filename</i>.nfo"
        # self.eg_fanart = "fanart.jpg"
        self.eg_poster = "folder.jpg"
        self.eg_banner = "folder.jpg"
        self.eg_episode_thumbnails = "Season##\\<i>filename</i>.tbn"
        self.eg_season_posters = "season##.tbn"
        self.eg_season_banners = "<i>not supported</i>"
        self.eg_season_all_poster = "season-all.tbn"
        self.eg_season_all_banner = "<i>not supported</i>"

    # Override with empty methods for unsupported features
</source>
<source file="systems/Sick-Beard-build-507/sickbeard/metadata/mediabrowser.py" startline="53" endline="97" pcid="4307">
    def __init__(self,
                 show_metadata=False,
                 episode_metadata=False,
                 fanart=False,
                 poster=False,
                 banner=False,
                 episode_thumbnails=False,
                 season_posters=False,
                 season_banners=False,
                 season_all_poster=False,
                 season_all_banner=False):

        generic.GenericMetadata.__init__(self,
                                         show_metadata,
                                         episode_metadata,
                                         fanart,
                                         poster,
                                         banner,
                                         episode_thumbnails,
                                         season_posters,
                                         season_banners,
                                         season_all_poster,
                                         season_all_banner)

        self.name = "MediaBrowser"

        self._ep_nfo_extension = "xml"
        self._show_metadata_filename = "series.xml"

        self.fanart_name = "backdrop.jpg"
        self.poster_name = "folder.jpg"

        # web-ui metadata template
        self.eg_show_metadata = "series.xml"
        self.eg_episode_metadata = "Season##\\metadata\\<i>filename</i>.xml"
        self.eg_fanart = "backdrop.jpg"
        self.eg_poster = "folder.jpg"
        self.eg_banner = "banner.jpg"
        self.eg_episode_thumbnails = "Season##\\metadata\\<i>filename</i>.jpg"
        self.eg_season_posters = "Season##\\folder.jpg"
        self.eg_season_banners = "Season##\\banner.jpg"
        self.eg_season_all_poster = "<i>not supported</i>"
        self.eg_season_all_banner = "<i>not supported</i>"

    # Override with empty methods for unsupported features
</source>
<source file="systems/Sick-Beard-build-507/sickbeard/metadata/xbmc_12plus.py" startline="53" endline="93" pcid="4304">
    def __init__(self,
                 show_metadata=False,
                 episode_metadata=False,
                 fanart=False,
                 poster=False,
                 banner=False,
                 episode_thumbnails=False,
                 season_posters=False,
                 season_banners=False,
                 season_all_poster=False,
                 season_all_banner=False):

        generic.GenericMetadata.__init__(self,
                                         show_metadata,
                                         episode_metadata,
                                         fanart,
                                         poster,
                                         banner,
                                         episode_thumbnails,
                                         season_posters,
                                         season_banners,
                                         season_all_poster,
                                         season_all_banner)

        self.name = 'XBMC 12+'

        self.poster_name = "poster.jpg"
        self.season_all_poster_name = "season-all-poster.jpg"

        # web-ui metadata template
        self.eg_show_metadata = "tvshow.nfo"
        self.eg_episode_metadata = "Season##\\<i>filename</i>.nfo"
        self.eg_fanart = "fanart.jpg"
        self.eg_poster = "poster.jpg"
        self.eg_banner = "banner.jpg"
        self.eg_episode_thumbnails = "Season##\\<i>filename</i>-thumb.jpg"
        self.eg_season_posters = "season##-poster.jpg"
        self.eg_season_banners = "season##-banner.jpg"
        self.eg_season_all_poster = "season-all-poster.jpg"
        self.eg_season_all_banner = "season-all-banner.jpg"

</source>
</class>

<class classid="39" nclones="4" nlines="20" similarity="71">
<source file="systems/Sick-Beard-build-507/sickbeard/metadata/tivo.py" startline="288" endline="329" pcid="4238">
    def write_ep_file(self, ep_obj):
        """
        Generates and writes ep_obj's metadata under the given path with the
        given filename root. Uses the episode's name with the extension in
        _ep_nfo_extension.

        ep_obj: TVEpisode object for which to create the metadata

        file_name_path: The file name to use for this metadata. Note that the extension
                will be automatically added based on _ep_nfo_extension. This should
                include an absolute path.
        """
        data = self._ep_data(ep_obj)

        if not data:
            return False

        nfo_file_path = self.get_episode_file_path(ep_obj)
        nfo_file_dir = ek.ek(os.path.dirname, nfo_file_path)

        try:
            if not ek.ek(os.path.isdir, nfo_file_dir):
                logger.log(u"Metadata dir didn't exist, creating it at " + nfo_file_dir, logger.DEBUG)
                ek.ek(os.makedirs, nfo_file_dir)
                helpers.chmodAsParent(nfo_file_dir)

            logger.log(u"Writing episode nfo file to " + nfo_file_path, logger.DEBUG)

            with ek.ek(open, nfo_file_path, 'w') as nfo_file:
                # Calling encode directly, b/c often descriptions have wonky characters.
                nfo_file.write(data.encode("utf-8"))

            helpers.chmodAsParent(nfo_file_path)

        except EnvironmentError, e:
            logger.log(u"Unable to write file to " + nfo_file_path + " - are you sure the folder is writable? " + ex(e), logger.ERROR)
            return False

        return True


# present a standard "interface" from the module
</source>
<source file="systems/Sick-Beard-build-507/sickbeard/metadata/generic.py" startline="414" endline="457" pcid="4290">
    def write_ep_file(self, ep_obj):
        """
        Generates and writes ep_obj's metadata under the given path with the
        given filename root. Uses the episode's name with the extension in
        _ep_nfo_extension.

        ep_obj: TVEpisode object for which to create the metadata

        file_name_path: The file name to use for this metadata. Note that the extension
                will be automatically added based on _ep_nfo_extension. This should
                include an absolute path.

        Note that this method expects that _ep_data will return an ElementTree
        object. If your _ep_data returns data in another format you'll need to
        override this method.
        """

        data = self._ep_data(ep_obj)

        if not data:
            return False

        nfo_file_path = self.get_episode_file_path(ep_obj)
        nfo_file_dir = ek.ek(os.path.dirname, nfo_file_path)

        try:
            if not ek.ek(os.path.isdir, nfo_file_dir):
                logger.log(u"Metadata dir didn't exist, creating it at " + nfo_file_dir, logger.DEBUG)
                ek.ek(os.makedirs, nfo_file_dir)
                helpers.chmodAsParent(nfo_file_dir)

            logger.log(u"Writing episode nfo file to " + nfo_file_path, logger.DEBUG)

            nfo_file = ek.ek(open, nfo_file_path, 'w')

            data.write(nfo_file, encoding="utf-8")
            nfo_file.close()
            helpers.chmodAsParent(nfo_file_path)
        except IOError, e:
            logger.log(u"Unable to write file to " + nfo_file_path + " - are you sure the folder is writable? " + ex(e), logger.ERROR)
            return False

        return True

</source>
<source file="systems/Sick-Beard-build-507/sickbeard/metadata/generic.py" startline="372" endline="413" pcid="4289">
    def write_show_file(self, show_obj):
        """
        Generates and writes show_obj's metadata under the given path to the
        filename given by get_show_file_path()

        show_obj: TVShow object for which to create the metadata

        path: An absolute or relative path where we should put the file. Note that
                the file name will be the default show_file_name.

        Note that this method expects that _show_data will return an ElementTree
        object. If your _show_data returns data in another format you'll need to
        override this method.
        """

        data = self._show_data(show_obj)

        if not data:
            return False

        nfo_file_path = self.get_show_file_path(show_obj)
        nfo_file_dir = ek.ek(os.path.dirname, nfo_file_path)

        try:
            if not ek.ek(os.path.isdir, nfo_file_dir):
                logger.log(u"Metadata dir didn't exist, creating it at " + nfo_file_dir, logger.DEBUG)
                ek.ek(os.makedirs, nfo_file_dir)
                helpers.chmodAsParent(nfo_file_dir)

            logger.log(u"Writing show nfo file to " + nfo_file_path, logger.DEBUG)

            nfo_file = ek.ek(open, nfo_file_path, 'w')

            data.write(nfo_file, encoding="utf-8")
            nfo_file.close()
            helpers.chmodAsParent(nfo_file_path)
        except IOError, e:
            logger.log(u"Unable to write file to " + nfo_file_path + " - are you sure the folder is writable? " + ex(e), logger.ERROR)
            return False

        return True

</source>
<source file="systems/Sick-Beard-build-507/sickbeard/metadata/generic.py" startline="667" endline="702" pcid="4299">
    def _write_image(self, image_data, image_path):
        """
        Saves the data in image_data to the location image_path. Returns True/False
        to represent success or failure.

        image_data: binary image data to write to file
        image_path: file location to save the image to
        """

        # don't bother overwriting it
        if ek.ek(os.path.isfile, image_path):
            logger.log(u"Image already exists, not downloading", logger.DEBUG)
            return False

        if not image_data:
            logger.log(u"Unable to retrieve image, skipping", logger.WARNING)
            return False

        image_dir = ek.ek(os.path.dirname, image_path)

        try:
            if not ek.ek(os.path.isdir, image_dir):
                logger.log(u"Metadata dir didn't exist, creating it at " + image_dir, logger.DEBUG)
                ek.ek(os.makedirs, image_dir)
                helpers.chmodAsParent(image_dir)

            outFile = ek.ek(open, image_path, 'wb')
            outFile.write(image_data)
            outFile.close()
            helpers.chmodAsParent(image_path)
        except IOError, e:
            logger.log(u"Unable to write image to " + image_path + " - are you sure the show folder is writable? " + ex(e), logger.ERROR)
            return False

        return True

</source>
</class>

<class classid="40" nclones="3" nlines="20" similarity="100">
<source file="systems/Sick-Beard-build-507/sickbeard/metadata/wdtv.py" startline="133" endline="168" pcid="4249">
    def get_season_poster_path(self, show_obj, season):
        """
        Season thumbs for WDTV go in Show Dir/Season X/folder.jpg

        If no season folder exists, None is returned
        """

        dir_list = [x for x in ek.ek(os.listdir, show_obj.location) if ek.ek(os.path.isdir, ek.ek(os.path.join, show_obj.location, x))]

        season_dir_regex = '^Season\s+(\d+)$'

        season_dir = None

        for cur_dir in dir_list:
            if season == 0 and cur_dir == "Specials":
                season_dir = cur_dir
                break

            match = re.match(season_dir_regex, cur_dir, re.I)
            if not match:
                continue

            cur_season = int(match.group(1))

            if cur_season == season:
                season_dir = cur_dir
                break

        if not season_dir:
            logger.log(u"Unable to find a season dir for season " + str(season), logger.DEBUG)
            return None

        logger.log(u"Using " + str(season_dir) + "/folder.jpg as season dir for season " + str(season), logger.DEBUG)

        return ek.ek(os.path.join, show_obj.location, season_dir, 'folder.jpg')

</source>
<source file="systems/Sick-Beard-build-507/sickbeard/metadata/mediabrowser.py" startline="143" endline="181" pcid="4313">
    def get_season_poster_path(self, show_obj, season):
        """
        Season thumbs for MediaBrowser go in Show Dir/Season X/folder.jpg

        If no season folder exists, None is returned
        """

        dir_list = [x for x in ek.ek(os.listdir, show_obj.location) if ek.ek(os.path.isdir, ek.ek(os.path.join, show_obj.location, x))]

        season_dir_regex = '^Season\s+(\d+)$'

        season_dir = None

        for cur_dir in dir_list:
            # MediaBrowser 1.x only supports 'Specials'
            # MediaBrowser 2.x looks to only support 'Season 0'
            # MediaBrowser 3.x looks to mimic XBMC/Plex support
            if season == 0 and cur_dir == "Specials":
                season_dir = cur_dir
                break

            match = re.match(season_dir_regex, cur_dir, re.I)
            if not match:
                continue

            cur_season = int(match.group(1))

            if cur_season == season:
                season_dir = cur_dir
                break

        if not season_dir:
            logger.log(u"Unable to find a season dir for season " + str(season), logger.DEBUG)
            return None

        logger.log(u"Using " + str(season_dir) + "/folder.jpg as season dir for season " + str(season), logger.DEBUG)

        return ek.ek(os.path.join, show_obj.location, season_dir, 'folder.jpg')

</source>
<source file="systems/Sick-Beard-build-507/sickbeard/metadata/mediabrowser.py" startline="182" endline="220" pcid="4314">
    def get_season_banner_path(self, show_obj, season):
        """
        Season thumbs for MediaBrowser go in Show Dir/Season X/banner.jpg

        If no season folder exists, None is returned
        """

        dir_list = [x for x in ek.ek(os.listdir, show_obj.location) if ek.ek(os.path.isdir, ek.ek(os.path.join, show_obj.location, x))]

        season_dir_regex = '^Season\s+(\d+)$'

        season_dir = None

        for cur_dir in dir_list:
            # MediaBrowser 1.x only supports 'Specials'
            # MediaBrowser 2.x looks to only support 'Season 0'
            # MediaBrowser 3.x looks to mimic XBMC/Plex support
            if season == 0 and cur_dir == "Specials":
                season_dir = cur_dir
                break

            match = re.match(season_dir_regex, cur_dir, re.I)
            if not match:
                continue

            cur_season = int(match.group(1))

            if cur_season == season:
                season_dir = cur_dir
                break

        if not season_dir:
            logger.log(u"Unable to find a season dir for season " + str(season), logger.DEBUG)
            return None

        logger.log(u"Using " + str(season_dir) + "/banner.jpg as season dir for season " + str(season), logger.DEBUG)

        return ek.ek(os.path.join, show_obj.location, season_dir, 'banner.jpg')

</source>
</class>

<class classid="41" nclones="2" nlines="22" similarity="100">
<source file="systems/Sick-Beard-build-507/sickbeard/metadata/generic.py" startline="549" endline="595" pcid="4295">
    def save_season_posters(self, show_obj, season):
        """
        Saves all season posters to disk for the given show.

        show_obj: a TVShow object for which to save the season thumbs

        Cycles through all seasons and saves the season posters if possible. This
        method should not need to be overridden by implementing classes, changing
        _season_posters_dict and get_season_poster_path should be good enough.
        """

        season_dict = self._season_posters_dict(show_obj, season)
        result = []

        # Returns a nested dictionary of season art with the season
        # number as primary key. It's really overkill but gives the option
        # to present to user via ui to pick down the road.
        for cur_season in season_dict:

            cur_season_art = season_dict[cur_season]

            if len(cur_season_art) == 0:
                continue

            # Just grab whatever's there for now
            art_id, season_url = cur_season_art.popitem()  # @UnusedVariable

            season_poster_file_path = self.get_season_poster_path(show_obj, cur_season)

            if not season_poster_file_path:
                logger.log(u"Path for season " + str(cur_season) + " came back blank, skipping this season", logger.DEBUG)
                continue

            seasonData = metadata_helpers.getShowImage(season_url)

            if not seasonData:
                logger.log(u"No season poster data available, skipping this season", logger.DEBUG)
                continue

            result = result + [self._write_image(seasonData, season_poster_file_path)]
        if result:
            return all(result)
        else:
            return False

        return True

</source>
<source file="systems/Sick-Beard-build-507/sickbeard/metadata/generic.py" startline="596" endline="642" pcid="4296">
    def save_season_banners(self, show_obj, season):
        """
        Saves all season banners to disk for the given show.

        show_obj: a TVShow object for which to save the season thumbs

        Cycles through all seasons and saves the season banners if possible. This
        method should not need to be overridden by implementing classes, changing
        _season_banners_dict and get_season_banner_path should be good enough.
        """

        season_dict = self._season_banners_dict(show_obj, season)
        result = []

        # Returns a nested dictionary of season art with the season
        # number as primary key. It's really overkill but gives the option
        # to present to user via ui to pick down the road.
        for cur_season in season_dict:

            cur_season_art = season_dict[cur_season]

            if len(cur_season_art) == 0:
                continue

            # Just grab whatever's there for now
            art_id, season_url = cur_season_art.popitem()  # @UnusedVariable

            season_banner_file_path = self.get_season_banner_path(show_obj, cur_season)

            if not season_banner_file_path:
                logger.log(u"Path for season " + str(cur_season) + " came back blank, skipping this season", logger.DEBUG)
                continue

            seasonData = metadata_helpers.getShowImage(season_url)

            if not seasonData:
                logger.log(u"No season banner data available, skipping this season", logger.DEBUG)
                continue

            result = result + [self._write_image(seasonData, season_banner_file_path)]
        if result:
            return all(result)
        else:
            return False

        return True

</source>
</class>

<class classid="42" nclones="2" nlines="20" similarity="100">
<source file="systems/Sick-Beard-build-507/sickbeard/metadata/generic.py" startline="740" endline="786" pcid="4301">
    def _season_posters_dict(self, show_obj, season):
        """
        Should return a dict like:

        result = {<season number>:
                    {1: '<url 1>', 2: <url 2>, ...},}
        """

        # This holds our resulting dictionary of season art
        result = {}

        tvdb_lang = show_obj.lang

        try:
            # There's gotta be a better way of doing this but we don't wanna
            # change the language value elsewhere
            ltvdb_api_parms = sickbeard.TVDB_API_PARMS.copy()

            if tvdb_lang and not tvdb_lang == 'en':
                ltvdb_api_parms['language'] = tvdb_lang

            t = tvdb_api.Tvdb(banners=True, **ltvdb_api_parms)
            tvdb_show_obj = t[show_obj.tvdbid]
        except (tvdb_exceptions.tvdb_error, IOError), e:
            logger.log(u"Unable to look up show on TVDB, not downloading images: " + ex(e), logger.ERROR)
            return result

        # if we have no season banners then just finish
        if 'season' not in tvdb_show_obj['_banners'] or 'season' not in tvdb_show_obj['_banners']['season']:
            return result

        # Give us just the normal poster-style season graphics
        seasonsArtObj = tvdb_show_obj['_banners']['season']['season']

        # Returns a nested dictionary of season art with the season
        # number as primary key. It's really overkill but gives the option
        # to present to user via ui to pick down the road.

        result[season] = {}

        # find the correct season in the tvdb object and just copy the dict into our result dict
        for seasonArtID in seasonsArtObj.keys():
            if int(seasonsArtObj[seasonArtID]['season']) == season and seasonsArtObj[seasonArtID]['language'] == 'en':
                result[season][seasonArtID] = seasonsArtObj[seasonArtID]['_bannerpath']

        return result

</source>
<source file="systems/Sick-Beard-build-507/sickbeard/metadata/generic.py" startline="787" endline="833" pcid="4302">
    def _season_banners_dict(self, show_obj, season):
        """
        Should return a dict like:

        result = {<season number>:
                    {1: '<url 1>', 2: <url 2>, ...},}
        """

        # This holds our resulting dictionary of season art
        result = {}

        tvdb_lang = show_obj.lang

        try:
            # There's gotta be a better way of doing this but we don't wanna
            # change the language value elsewhere
            ltvdb_api_parms = sickbeard.TVDB_API_PARMS.copy()

            if tvdb_lang and not tvdb_lang == 'en':
                ltvdb_api_parms['language'] = tvdb_lang

            t = tvdb_api.Tvdb(banners=True, **ltvdb_api_parms)
            tvdb_show_obj = t[show_obj.tvdbid]
        except (tvdb_exceptions.tvdb_error, IOError), e:
            logger.log(u"Unable to look up show on TVDB, not downloading images: " + ex(e), logger.ERROR)
            return result

        # if we have no season banners then just finish
        if 'season' not in tvdb_show_obj['_banners'] or 'seasonwide' not in tvdb_show_obj['_banners']['season']:
            return result

        # Give us just the normal season graphics
        seasonsArtObj = tvdb_show_obj['_banners']['season']['seasonwide']

        # Returns a nested dictionary of season art with the season
        # number as primary key. It's really overkill but gives the option
        # to present to user via ui to pick down the road.

        result[season] = {}

        # find the correct season in the tvdb object and just copy the dict into our result dict
        for seasonArtID in seasonsArtObj.keys():
            if int(seasonsArtObj[seasonArtID]['season']) == season and seasonsArtObj[seasonArtID]['language'] == 'en':
                result[season][seasonArtID] = seasonsArtObj[seasonArtID]['_bannerpath']

        return result

</source>
</class>

<class classid="43" nclones="2" nlines="20" similarity="80">
<source file="systems/Sick-Beard-build-507/sickbeard/versionChecker.py" startline="450" endline="477" pcid="4359">
    def set_newest_text(self):

        # if we're up to date then don't set this
        sickbeard.NEWEST_VERSION_STRING = None

        if self._num_commits_ahead:
            logger.log(u"Local branch is ahead of " + self.branch + ". Automatic update not possible.", logger.ERROR)
            newest_text = "Local branch is ahead of " + self.branch + ". Automatic update not possible."

        elif self._num_commits_behind > 0:

            base_url = 'http://github.com/' + self.github_repo_user + '/' + self.github_repo
            if self._newest_commit_hash:
                url = base_url + '/compare/' + self._cur_commit_hash + '...' + self._newest_commit_hash
            else:
                url = base_url + '/commits/'

            newest_text = 'There is a <a href="' + url + '" onclick="window.open(this.href); return false;">newer version available</a> '
            newest_text += " (you're " + str(self._num_commits_behind) + " commit"
            if self._num_commits_behind > 1:
                newest_text += 's'
            newest_text += ' behind)' + "&mdash; <a href=\"" + self.get_update_url() + "\">Update Now</a>"

        else:
            return

        sickbeard.NEWEST_VERSION_STRING = newest_text

</source>
<source file="systems/Sick-Beard-build-507/sickbeard/versionChecker.py" startline="595" endline="622" pcid="4366">
    def set_newest_text(self):

        # if we're up to date then don't set this
        sickbeard.NEWEST_VERSION_STRING = None

        if not self._cur_commit_hash:
            logger.log(u"Unknown current version number, don't know if we should update or not", logger.DEBUG)

            newest_text = "Unknown current version number: If you've never used the Sick Beard upgrade system before then current version is not set."
            newest_text += "&mdash; <a href=\"" + self.get_update_url() + "\">Update Now</a>"

        elif self._num_commits_behind > 0:
                base_url = 'http://github.com/' + self.github_repo_user + '/' + self.github_repo
                if self._newest_commit_hash:
                    url = base_url + '/compare/' + self._cur_commit_hash + '...' + self._newest_commit_hash
                else:
                    url = base_url + '/commits/'

                newest_text = 'There is a <a href="' + url + '" onclick="window.open(this.href); return false;">newer version available</a>'
                newest_text += " (you're " + str(self._num_commits_behind) + " commit"
                if self._num_commits_behind > 1:
                    newest_text += "s"
                newest_text += " behind)" + "&mdash; <a href=\"" + self.get_update_url() + "\">Update Now</a>"
        else:
            return

        sickbeard.NEWEST_VERSION_STRING = newest_text

</source>
</class>

<class classid="44" nclones="2" nlines="15" similarity="80">
<source file="systems/Sick-Beard-build-507/sickbeard/providers/btn.py" startline="294" endline="314" pcid="4406">
    def findPropers(self, search_date=None):
        results = []

        search_terms = ['%.proper.%', '%.repack.%']

        for term in search_terms:
            for item in self._doSearch({'release': term}, age=4 * 24 * 60 * 60):
                if item['Time']:
                    try:
                        result_date = datetime.fromtimestamp(float(item['Time']))
                    except TypeError:
                        result_date = None

                    if result_date:
                        if not search_date or result_date > search_date:
                            title, url = self._get_title_and_url(item)
                            results.append(classes.Proper(title, url, result_date))

        return results


</source>
<source file="systems/Sick-Beard-build-507/sickbeard/providers/hdbits.py" startline="121" endline="140" pcid="4426">
    def findPropers(self, search_date=None):
        results = []

        search_terms = [' proper ', ' repack ']

        for term in search_terms:
            for item in self._doSearch(self._make_post_data_JSON(search_term=term)):
                if item['utadded']:
                    try:
                        result_date = datetime.datetime.fromtimestamp(int(item['utadded']))
                    except:
                        result_date = None

                    if result_date:
                        if not search_date or result_date > search_date:
                            title, url = self._get_title_and_url(item)
                            results.append(classes.Proper(title, url, result_date))

        return results

</source>
</class>

<class classid="45" nclones="2" nlines="10" similarity="90">
<source file="systems/Sick-Beard-build-507/sickbeard/webapi.py" startline="2057" endline="2070" pcid="4600">
    def run(self):
        """ refresh a show in sickbeard """
        showObj = sickbeard.helpers.findCertainShow(sickbeard.showList, int(self.tvdbid))
        if not showObj:
            return _responds(RESULT_FAILURE, msg="Show not found")

        try:
            sickbeard.showQueueScheduler.action.refreshShow(showObj)  # @UndefinedVariable
            return _responds(RESULT_SUCCESS, msg=u"" + showObj.name + " has queued to be refreshed")
        except exceptions.CantRefreshException, e:
            logger.log(u"API:: Unable to refresh " + showObj.name + ". " + str(ex(e)), logger.ERROR)
            return _responds(RESULT_FAILURE, msg=u"Unable to refresh " + showObj.name)


</source>
<source file="systems/Sick-Beard-build-507/sickbeard/webapi.py" startline="2343" endline="2356" pcid="4610">
    def run(self):
        """ update a show in sickbeard """
        showObj = sickbeard.helpers.findCertainShow(sickbeard.showList, int(self.tvdbid))
        if not showObj:
            return _responds(RESULT_FAILURE, msg="Show not found")

        try:
            sickbeard.showQueueScheduler.action.updateShow(showObj, True)  # @UndefinedVariable
            return _responds(RESULT_SUCCESS, msg=u"" + showObj.name + " has queued to be updated")
        except exceptions.CantUpdateException, e:
            logger.log(u"API:: Unable to update " + showObj.name + ". " + str(ex(e)), logger.ERROR)
            return _responds(RESULT_FAILURE, msg=u"Unable to update " + showObj.name)


</source>
</class>

<class classid="46" nclones="2" nlines="17" similarity="76">
<source file="systems/Sick-Beard-build-507/sickbeard/notifiers/pushbullet.py" startline="36" endline="55" pcid="4652">
    def get_devices(self, accessToken=None):
        # fill in omitted parameters
        if not accessToken:
            accessToken = sickbeard.PUSHBULLET_ACCESS_TOKEN

        # get devices from pushbullet
        try:
            req = urllib2.Request(DEVICEAPI_ENDPOINT)
            base64string = base64.encodestring('%s:%s' % (accessToken, ''))[:-1]
            req.add_header("Authorization", "Basic %s" % base64string)
            handle = urllib2.urlopen(req)
            if handle:
                result = handle.read()
            handle.close()
            return result
        except urllib2.URLError:
            return None
        except socket.timeout:
            return None

</source>
<source file="systems/Sick-Beard-build-507/sickbeard/notifiers/pushover.py" startline="40" endline="62" pcid="4670">
    def get_devices(self, userKey=None):
        # fill in omitted parameters
        if not userKey:
            userKey = sickbeard.PUSHOVER_USERKEY

        data = urllib.urlencode({
            'token': API_KEY,
            'user': userKey
            })

        # get devices from pushover
        try:
            req = urllib2.Request(DEVICE_URL)
            handle = urllib2.urlopen(req, data)
            if handle:
                result = handle.read()
            handle.close()
            return result
        except urllib2.URLError:
            return None
        except socket.timeout:
            return None

</source>
</class>

<class classid="47" nclones="2" nlines="33" similarity="82">
<source file="systems/Sick-Beard-build-507/sickbeard/notifiers/pushbullet.py" startline="56" endline="101" pcid="4653">
    def _sendPushbullet(self, title, body, accessToken, device_iden):

        # build up the URL and parameters
        body = body.strip().encode('utf-8')

        data = urllib.urlencode({
            'type': 'note',
            'title': title,
            'body': body,
            'device_iden': device_iden
            })

        # send the request to pushbullet
        try:
            req = urllib2.Request(PUSHAPI_ENDPOINT)
            base64string = base64.encodestring('%s:%s' % (accessToken, ''))[:-1]
            req.add_header("Authorization", "Basic %s" % base64string)
            handle = urllib2.urlopen(req, data)
            handle.close()
        except socket.timeout:
            return False
        except urllib2.URLError, e:
            # FIXME: Python 2.5 hack, it wrongly reports 201 as an error
            if hasattr(e, 'code') and e.code == 201:
                logger.log(u"PUSHBULLET: Notification successful.", logger.MESSAGE)
                return True

            # if we get an error back that doesn't have an error code then who knows what's really happening
            if not hasattr(e, 'code'):
                logger.log(u"PUSHBULLET: Notification failed." + ex(e), logger.ERROR)
            else:
                logger.log(u"PUSHBULLET: Notification failed. Error code: " + str(e.code), logger.ERROR)

            if e.code == 404:
                logger.log(u"PUSHBULLET: Access token is wrong/not associated to a device.", logger.ERROR)
            elif e.code == 401:
                logger.log(u"PUSHBULLET: Unauthorized, not a valid access token.", logger.ERROR)
            elif e.code == 400:
                logger.log(u"PUSHBULLET: Bad request, missing required parameter.", logger.ERROR)
            elif e.code == 503:
                logger.log(u"PUSHBULLET: Pushbullet server to busy to handle the request at this time.", logger.WARNING)
            return False

        logger.log(u"PUSHBULLET: Notification successful.", logger.MESSAGE)
        return True

</source>
<source file="systems/Sick-Beard-build-507/sickbeard/notifiers/boxcar2.py" startline="35" endline="87" pcid="4659">
    def _sendBoxcar2(self, title, msg, accessToken, sound):
        """
        Sends a boxcar2 notification to the address provided

        msg: The message to send (unicode)
        title: The title of the message
        accessToken: The access token to send notification to

        returns: True if the message succeeded, False otherwise
        """

        # build up the URL and parameters
        msg = msg.strip().encode('utf-8')

        data = urllib.urlencode({
            'user_credentials': accessToken,
            'notification[title]': title + " - " + msg,
            'notification[long_message]': msg,
            'notification[sound]': sound,
            'notification[source_name]': "SickBeard"
            })

        # send the request to boxcar2
        try:
            req = urllib2.Request(API_URL)
            handle = urllib2.urlopen(req, data)
            handle.close()

        except urllib2.URLError, e:
            # FIXME: Python 2.5 hack, it wrongly reports 201 as an error
            if hasattr(e, 'code') and e.code == 201:
                logger.log(u"BOXCAR2: Notification successful.", logger.MESSAGE)
                return True

            # if we get an error back that doesn't have an error code then who knows what's really happening
            if not hasattr(e, 'code'):
                logger.log(u"BOXCAR2: Notification failed." + ex(e), logger.ERROR)
            else:
                logger.log(u"BOXCAR2: Notification failed. Error code: " + str(e.code), logger.ERROR)

            if e.code == 404:
                logger.log(u"BOXCAR2: Access token is wrong/not associated to a device.", logger.ERROR)
            elif e.code == 401:
                logger.log(u"BOXCAR2: Access token not recognized.", logger.ERROR)
            elif e.code == 400:
                logger.log(u"BOXCAR2: Wrong data sent to boxcar.", logger.ERROR)
            elif e.code == 503:
                logger.log(u"BOXCAR2: Boxcar server to busy to handle the request at this time.", logger.WARNING)
            return False

        logger.log(u"BOXCAR2: Notification successful.", logger.MESSAGE)
        return True

</source>
</class>

<class classid="48" nclones="2" nlines="11" similarity="90">
<source file="systems/Sick-Beard-build-507/sickbeard/notifiers/synoindex.py" startline="38" endline="49" pcid="4684">
    def moveObject(self, old_path, new_path):
        if sickbeard.USE_SYNOINDEX:
            synoindex_cmd = ['/usr/syno/bin/synoindex', '-N', ek.ek(os.path.abspath, new_path), ek.ek(os.path.abspath, old_path)]
            logger.log(u"SYNOINDEX: Executing command " + str(synoindex_cmd), logger.DEBUG)
            logger.log(u"SYNOINDEX: Absolute path to command: " + ek.ek(os.path.abspath, synoindex_cmd[0]), logger.DEBUG)
            try:
                p = subprocess.Popen(synoindex_cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, cwd=sickbeard.PROG_DIR)
                out, err = p.communicate()  # @UnusedVariable
                logger.log(u"SYNOINDEX: Script result: " + str(out), logger.DEBUG)
            except OSError, e:
                logger.log(u"SYNOINDEX: Unable to run synoindex: " + ex(e), logger.WARNING)

</source>
<source file="systems/Sick-Beard-build-507/sickbeard/notifiers/synoindex.py" startline="62" endline="73" pcid="4689">
    def makeObject(self, cmd_arg, cur_path):
        if sickbeard.USE_SYNOINDEX:
            synoindex_cmd = ['/usr/syno/bin/synoindex', cmd_arg, ek.ek(os.path.abspath, cur_path)]
            logger.log(u"SYNOINDEX: Executing command " + str(synoindex_cmd), logger.DEBUG)
            logger.log(u"SYNOINDEX: Absolute path to command: " + ek.ek(os.path.abspath, synoindex_cmd[0]), logger.DEBUG)
            try:
                p = subprocess.Popen(synoindex_cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, cwd=sickbeard.PROG_DIR)
                out, err = p.communicate()  # @UnusedVariable
                logger.log(u"SYNOINDEX: Script result: " + str(out), logger.DEBUG)
            except OSError, e:
                logger.log(u"SYNOINDEX: Unable to run synoindex: " + ex(e), logger.WARNING)

</source>
</class>

<class classid="49" nclones="3" nlines="14" similarity="81">
<source file="systems/Sick-Beard-build-507/tests/common_tests.py" startline="14" endline="30" pcid="4788">
    def test_SDTV(self):
        self.assertEqual(common.Quality.SDTV, common.Quality.nameQuality("Test.Show.S01E02.PDTV.XViD-GROUP"))
        self.assertEqual(common.Quality.SDTV, common.Quality.nameQuality("Test.Show.S01E02.PDTV.x264-GROUP"))
        self.assertEqual(common.Quality.SDTV, common.Quality.nameQuality("Test.Show.S01E02.HDTV.XViD-GROUP"))
        self.assertEqual(common.Quality.SDTV, common.Quality.nameQuality("Test.Show.S01E02.HDTV.x264-GROUP"))
        self.assertEqual(common.Quality.SDTV, common.Quality.nameQuality("Test.Show.S01E02.DSR.XViD-GROUP"))
        self.assertEqual(common.Quality.SDTV, common.Quality.nameQuality("Test.Show.S01E02.DSR.x264-GROUP"))
        self.assertEqual(common.Quality.SDTV, common.Quality.nameQuality("Test.Show.S01E02.TVRip.XViD-GROUP"))
        self.assertEqual(common.Quality.SDTV, common.Quality.nameQuality("Test.Show.S01E02.TVRip.x264-GROUP"))
        self.assertEqual(common.Quality.SDTV, common.Quality.nameQuality("Test.Show.S01E02.WEBRip.XViD-GROUP"))
        self.assertEqual(common.Quality.SDTV, common.Quality.nameQuality("Test.Show.S01E02.WEBRip.x264-GROUP"))
        self.assertEqual(common.Quality.SDTV, common.Quality.nameQuality("Test.Show.S01E02.WEB-DL.x264-GROUP"))
        self.assertEqual(common.Quality.SDTV, common.Quality.nameQuality("Test.Show.S01E02.WEB-DL.AAC2.0.H.264-GROUP"))
        self.assertEqual(common.Quality.SDTV, common.Quality.nameQuality("Test.Show.S01E02 WEB-DL H 264-GROUP"))
        self.assertEqual(common.Quality.SDTV, common.Quality.nameQuality("Test.Show.S01E02_WEB-DL_H_264-GROUP"))
        self.assertEqual(common.Quality.SDTV, common.Quality.nameQuality("Test.Show.S01E02.WEB-DL.AAC2.0.H264-GROUP"))

</source>
<source file="systems/Sick-Beard-build-507/tests/common_tests.py" startline="31" endline="44" pcid="4789">
    def test_SDDVD(self):
        self.assertEqual(common.Quality.SDDVD, common.Quality.nameQuality("Test.Show.S01E02.DVDRiP.XViD-GROUP"))
        self.assertEqual(common.Quality.SDDVD, common.Quality.nameQuality("Test.Show.S01E02.DVDRiP.DiVX-GROUP"))
        self.assertEqual(common.Quality.SDDVD, common.Quality.nameQuality("Test.Show.S01E02.DVDRiP.x264-GROUP"))
        self.assertEqual(common.Quality.SDDVD, common.Quality.nameQuality("Test.Show.S01E02.DVDRip.WS.XViD-GROUP"))
        self.assertEqual(common.Quality.SDDVD, common.Quality.nameQuality("Test.Show.S01E02.DVDRip.WS.DiVX-GROUP"))
        self.assertEqual(common.Quality.SDDVD, common.Quality.nameQuality("Test.Show.S01E02.DVDRip.WS.x264-GROUP"))
        self.assertEqual(common.Quality.SDDVD, common.Quality.nameQuality("Test.Show.S01E02.BDRIP.XViD-GROUP"))
        self.assertEqual(common.Quality.SDDVD, common.Quality.nameQuality("Test.Show.S01E02.BDRIP.DiVX-GROUP"))
        self.assertEqual(common.Quality.SDDVD, common.Quality.nameQuality("Test.Show.S01E02.BDRIP.x264-GROUP"))
        self.assertEqual(common.Quality.SDDVD, common.Quality.nameQuality("Test.Show.S01E02.BDRIP.WS.XViD-GROUP"))
        self.assertEqual(common.Quality.SDDVD, common.Quality.nameQuality("Test.Show.S01E02.BDRIP.WS.DiVX-GROUP"))
        self.assertEqual(common.Quality.SDDVD, common.Quality.nameQuality("Test.Show.S01E02.BDRIP.WS.x264-GROUP"))

</source>
<source file="systems/Sick-Beard-build-507/tests/common_tests.py" startline="92" endline="103" pcid="4798">
    def test_reverse_parsing(self):
        self.assertEqual(common.Quality.SDTV, common.Quality.nameQuality("Test Show - S01E02 - SD TV - GROUP"))
        self.assertEqual(common.Quality.SDDVD, common.Quality.nameQuality("Test Show - S01E02 - SD DVD - GROUP"))
        self.assertEqual(common.Quality.HDTV, common.Quality.nameQuality("Test Show - S01E02 - HD TV - GROUP"))
        self.assertEqual(common.Quality.RAWHDTV, common.Quality.nameQuality("Test Show - S01E02 - RawHD TV - GROUP"))
        self.assertEqual(common.Quality.FULLHDTV, common.Quality.nameQuality("Test Show - S01E02 - 1080p HD TV - GROUP"))
        self.assertEqual(common.Quality.HDWEBDL, common.Quality.nameQuality("Test Show - S01E02 - 720p WEB-DL - GROUP"))
        self.assertEqual(common.Quality.FULLHDWEBDL, common.Quality.nameQuality("Test Show - S01E02 - 1080p WEB-DL - GROUP"))
        self.assertEqual(common.Quality.HDBLURAY, common.Quality.nameQuality("Test Show - S01E02 - 720p BluRay - GROUP"))
        self.assertEqual(common.Quality.FULLHDBLURAY, common.Quality.nameQuality("Test Show - S01E02 - 1080p BluRay - GROUP"))
        self.assertEqual(common.Quality.UNKNOWN, common.Quality.nameQuality("Test Show - S01E02 - Unknown - SiCKBEARD"))

</source>
</class>

</clones>
