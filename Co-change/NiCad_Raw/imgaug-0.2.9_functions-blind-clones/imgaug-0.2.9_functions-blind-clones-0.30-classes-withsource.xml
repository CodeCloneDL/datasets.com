<clones>
<systeminfo processor="nicad6" system="imgaug-0.2.9" granularity="functions-blind" threshold="30%" minlines="10" maxlines="2500"/>
<cloneinfo npcs="1319" npairs="116"/>
<runinfo ncompares="46962" cputime="119394"/>
<classinfo nclasses="81"/>

<class classid="1" nclones="2" nlines="36" similarity="71">
<source file="systems/imgaug-0.2.9/imgaug/augmenters/blend.py" startline="295" endline="334" pcid="45">
    def _augment_images(self, images, random_state, parents, hooks):
        result = images
        nb_images = len(images)
        nb_channels = meta.estimate_max_number_of_channels(images)
        rss = ia.derive_random_states(random_state, 2)
        per_channel = self.per_channel.draw_samples(nb_images, random_state=rss[0])
        alphas = self.factor.draw_samples((nb_images, nb_channels), random_state=rss[1])

        if hooks is None or hooks.is_propagating(images, augmenter=self, parents=parents, default=True):
            if self.first is None:
                images_first = images
            else:
                images_first = self.first.augment_images(
                    images=meta.copy_arrays(images),
                    parents=parents + [self],
                    hooks=hooks
                )

            if self.second is None:
                images_second = images
            else:
                images_second = self.second.augment_images(
                    images=meta.copy_arrays(images),
                    parents=parents + [self],
                    hooks=hooks
                )
        else:
            images_first = images
            images_second = images

        for i, (image_first, image_second) in enumerate(zip(images_first, images_second)):
            if per_channel[i] > 0.5:
                nb_channels_i = image_first.shape[2]
                alphas_i = alphas[i, 0:nb_channels_i]
            else:
                alphas_i = alphas[i, 0]

            result[i] = blend_alpha(image_first, image_second, alphas_i, eps=self.epsilon)
        return result

</source>
<source file="systems/imgaug-0.2.9/imgaug/augmenters/blend.py" startline="335" endline="385" pcid="46">
    def _augment_heatmaps(self, heatmaps, random_state, parents, hooks):
        result = heatmaps
        nb_heatmaps = len(heatmaps)
        if nb_heatmaps == 0:
            return heatmaps

        nb_channels = meta.estimate_max_number_of_channels(heatmaps)
        rss = ia.derive_random_states(random_state, 2)
        per_channel = self.per_channel.draw_samples(nb_heatmaps, random_state=rss[0])
        alphas = self.factor.draw_samples((nb_heatmaps, nb_channels), random_state=rss[1])

        if hooks is None or hooks.is_propagating(heatmaps, augmenter=self, parents=parents, default=True):
            if self.first is None:
                heatmaps_first = heatmaps
            else:
                heatmaps_first = self.first.augment_heatmaps(
                    [heatmaps_i.deepcopy() for heatmaps_i in heatmaps],
                    parents=parents + [self],
                    hooks=hooks
                )

            if self.second is None:
                heatmaps_second = heatmaps
            else:
                heatmaps_second = self.second.augment_heatmaps(
                    [heatmaps_i.deepcopy() for heatmaps_i in heatmaps],
                    parents=parents + [self],
                    hooks=hooks
                )
        else:
            heatmaps_first = heatmaps
            heatmaps_second = heatmaps

        for i, (heatmaps_first_i, heatmaps_second_i) in enumerate(zip(heatmaps_first, heatmaps_second)):
            # sample alphas channelwise if necessary and try to use the image's channel number
            # values properly synchronized with the image augmentation
            # per_channel = self.per_channel.draw_sample(random_state=rs_image)
            if per_channel[i] > 0.5:
                nb_channels_i = heatmaps[i].shape[2] if len(heatmaps[i].shape) >= 3 else 1
                alpha = np.average(alphas[i, 0:nb_channels_i])
            else:
                alpha = alphas[i, 0]
            ia.do_assert(0 <= alpha <= 1.0)

            if alpha >= 0.5:
                result[i].arr_0to1 = heatmaps_first_i.arr_0to1
            else:
                result[i].arr_0to1 = heatmaps_second_i.arr_0to1

        return result

</source>
</class>

<class classid="2" nclones="2" nlines="25" similarity="80">
<source file="systems/imgaug-0.2.9/imgaug/augmenters/blend.py" startline="797" endline="982" pcid="65">
def SimplexNoiseAlpha(first=None, second=None, per_channel=False, size_px_max=(2, 16), upscale_method=None,
                      iterations=(1, 3), aggregation_method="max", sigmoid=True, sigmoid_thresh=None,
                      name=None, deterministic=False, random_state=None):
    """
    Augmenter to alpha-blend two image sources using simplex noise alpha masks.

    The alpha masks are sampled using a simplex noise method, roughly creating
    connected blobs of 1s surrounded by 0s. If nearest neighbour upsampling
    is used, these blobs can be rectangular with sharp edges.

    dtype support::

        See ``imgaug.augmenters.blend.AlphaElementwise``.

    Parameters
    ----------
    first : None or imgaug.augmenters.meta.Augmenter or iterable of imgaug.augmenters.meta.Augmenter, optional
        Augmenter(s) that make up the first of the two branches.

            * If None, then the input images will be reused as the output
              of the first branch.
            * If Augmenter, then that augmenter will be used as the branch.
            * If iterable of Augmenter, then that iterable will be converted
              into a Sequential and used as the augmenter.

    second : None or imgaug.augmenters.meta.Augmenter or iterable of imgaug.augmenters.meta.Augmenter, optional
        Augmenter(s) that make up the second of the two branches.

            * If None, then the input images will be reused as the output
              of the second branch.
            * If Augmenter, then that augmenter will be used as the branch.
            * If iterable of Augmenter, then that iterable will be converted
              into a Sequential and used as the augmenter.

    per_channel : bool or float, optional
        Whether to use the same factor for all channels (False)
        or to sample a new value for each channel (True).
        If this value is a float ``p``, then for ``p`` percent of all images
        `per_channel` will be treated as True, otherwise as False.

    size_px_max : int or tuple of int or list of int or imgaug.parameters.StochasticParameter, optional
        The simplex noise is always generated in a low resolution environment.
        This parameter defines the maximum size of that environment (in
        pixels). The environment is initialized at the same size as the input
        image and then downscaled, so that no side exceeds `size_px_max`
        (aspect ratio is kept).

            * If int, then that number will be used as the size for all
              iterations.
            * If tuple of two ints ``(a, b)``, then a value will be sampled
              per iteration from the discrete range ``[a..b]``.
            * If a list of ints, then a value will be picked per iteration at
              random from that list.
            * If a StochasticParameter, then a value will be sampled from
              that parameter per iteration.

    upscale_method : None or imgaug.ALL or str or list of str or imgaug.parameters.StochasticParameter, optional
        After generating the noise maps in low resolution environments, they
        have to be upscaled to the input image size. This parameter controls
        the upscaling method.

            * If None, then either ``nearest`` or ``linear`` or ``cubic`` is picked.
              Most weight is put on linear, followed by cubic.
            * If ia.ALL, then either ``nearest`` or ``linear`` or ``area`` or ``cubic``
              is picked per iteration (all same probability).
            * If string, then that value will be used as the method (must be
              'nearest' or ``linear`` or ``area`` or ``cubic``).
            * If list of string, then a random value will be picked from that
              list per iteration.
            * If StochasticParameter, then a random value will be sampled
              from that parameter per iteration.

    iterations : int or tuple of int or list of int or imgaug.parameters.StochasticParameter, optional
        How often to repeat the simplex noise generation process per image.

            * If int, then that number will be used as the iterations for all
              images.
            * If tuple of two ints ``(a, b)``, then a value will be sampled
              per image from the discrete range ``[a..b]``.
            * If a list of ints, then a value will be picked per image at
              random from that list.
            * If a StochasticParameter, then a value will be sampled from
              that parameter per image.

    aggregation_method : imgaug.ALL or str or list of str or imgaug.parameters.StochasticParameter, optional
        The noise maps (from each iteration) are combined to one noise map
        using an aggregation process. This parameter defines the method used
        for that process. Valid methods are ``min``, ``max`` or ``avg``,
        where ``min`` combines the noise maps by taking the (elementwise) minimum
        over all iteration's results, ``max`` the (elementwise) maximum and
        ``avg`` the (elementwise) average.

            * If imgaug.ALL, then a random value will be picked per image from the
              valid ones.
            * If a string, then that value will always be used as the method.
            * If a list of string, then a random value will be picked from
              that list per image.
            * If a StochasticParameter, then a random value will be sampled
              from that paramter per image.

    sigmoid : bool or number, optional
        Whether to apply a sigmoid function to the final noise maps, resulting
        in maps that have more extreme values (close to 0.0 or 1.0).

            * If bool, then a sigmoid will always (True) or never (False) be
              applied.
            * If a number ``p`` with ``0<=p<=1``, then a sigmoid will be applied to
              ``p`` percent of all final noise maps.

    sigmoid_thresh : None or number or tuple of number or imgaug.parameters.StochasticParameter, optional
        Threshold of the sigmoid, when applied. Thresholds above zero
        (e.g. 5.0) will move the saddle point towards the right, leading to
        more values close to 0.0.

            * If None, then ``Normal(0, 5.0)`` will be used.
            * If number, then that threshold will be used for all images.
            * If tuple of two numbers ``(a, b)``, then a random value will
              be sampled per image from the range ``[a, b]``.
            * If StochasticParameter, then a random value will be sampled from
              that parameter per image.

    name : None or str, optional
        See :func:`imgaug.augmenters.meta.Augmenter.__init__`.

    deterministic : bool, optional
        See :func:`imgaug.augmenters.meta.Augmenter.__init__`.

    random_state : None or int or numpy.random.RandomState, optional
        See :func:`imgaug.augmenters.meta.Augmenter.__init__`.

    Examples
    --------
    >>> aug = iaa.SimplexNoiseAlpha(iaa.EdgeDetect(1.0))

    Detects per image all edges, marks them in a black and white image and
    then alpha-blends the result with the original image using simplex noise
    masks.

    >>> aug = iaa.SimplexNoiseAlpha(iaa.EdgeDetect(1.0), upscale_method="linear")

    Same as the first example, but uses only (smooth) linear upscaling to
    scale the simplex noise masks to the final image sizes, i.e. no nearest
    neighbour upsampling is used, which would result in rectangles with hard
    edges.

    >>> aug = iaa.SimplexNoiseAlpha(iaa.EdgeDetect(1.0), sigmoid_thresh=iap.Normal(10.0, 5.0))

    Same as the first example, but uses a threshold for the sigmoid function
    that is further to the right. This is more conservative, i.e. the generated
    noise masks will be mostly black (values around 0.0), which means that
    most of the original images (parameter/branch `second`) will be kept,
    rather than using the results of the augmentation (parameter/branch
    `first`).

    """
    upscale_method_default = iap.Choice(["nearest", "linear", "cubic"], p=[0.05, 0.6, 0.35])
    sigmoid_thresh_default = iap.Normal(0.0, 5.0)

    noise = iap.SimplexNoise(
        size_px_max=size_px_max,
        upscale_method=upscale_method if upscale_method is not None else upscale_method_default
    )

    if iterations != 1:
        noise = iap.IterativeNoiseAggregator(
            noise,
            iterations=iterations,
            aggregation_method=aggregation_method
        )

    if sigmoid is False or (ia.is_single_number(sigmoid) and sigmoid <= 0.01):
        noise = iap.Sigmoid.create_for_noise(
            noise,
            threshold=sigmoid_thresh if sigmoid_thresh is not None else sigmoid_thresh_default,
            activated=sigmoid
        )

    if name is None:
        name = "Unnamed%s" % (ia.caller_name(),)

    return AlphaElementwise(
        factor=noise, first=first, second=second, per_channel=per_channel,
        name=name, deterministic=deterministic, random_state=random_state
    )


</source>
<source file="systems/imgaug-0.2.9/imgaug/augmenters/blend.py" startline="983" endline="1192" pcid="66">
def FrequencyNoiseAlpha(exponent=(-4, 4), first=None, second=None, per_channel=False,
                        size_px_max=(4, 16), upscale_method=None,
                        iterations=(1, 3), aggregation_method=["avg", "max"],
                        sigmoid=0.5, sigmoid_thresh=None,
                        name=None, deterministic=False, random_state=None):
    """
    Augmenter to alpha-blend two image sources using frequency noise masks.

    The alpha masks are sampled using frequency noise of varying scales,
    which can sometimes create large connected blobs of 1s surrounded by 0s
    and other times results in smaller patterns. If nearest neighbour
    upsampling is used, these blobs can be rectangular with sharp edges.

    dtype support::

        See ``imgaug.augmenters.blend.AlphaElementwise``.

    Parameters
    ----------
    exponent : number or tuple of number of list of number or imgaug.parameters.StochasticParameter, optional
        Exponent to use when scaling in the frequency domain.
        Sane values are in the range -4 (large blobs) to 4 (small patterns).
        To generate cloud-like structures, use roughly -2.

            * If number, then that number will be used as the exponent for all
              iterations.
            * If tuple of two numbers ``(a, b)``, then a value will be sampled
              per iteration from the range ``[a, b]``.
            * If a list of numbers, then a value will be picked per iteration
              at random from that list.
            * If a StochasticParameter, then a value will be sampled from
              that parameter per iteration.

    first : None or imgaug.augmenters.meta.Augmenter or iterable of imgaug.augmenters.meta.Augmenter, optional
        Augmenter(s) that make up the first of the two branches.

            * If None, then the input images will be reused as the output
              of the first branch.
            * If Augmenter, then that augmenter will be used as the branch.
            * If iterable of Augmenter, then that iterable will be converted
              into a Sequential and used as the augmenter.

    second : None or imgaug.augmenters.meta.Augmenter or iterable of imgaug.augmenters.meta.Augmenter, optional
        Augmenter(s) that make up the second of the two branches.

            * If None, then the input images will be reused as the output
              of the second branch.
            * If Augmenter, then that augmenter will be used as the branch.
            * If iterable of Augmenter, then that iterable will be converted
              into a Sequential and used as the augmenter.

    per_channel : bool or float, optional
        Whether to use the same factor for all channels (False)
        or to sample a new value for each channel (True).
        If this value is a float ``p``, then for ``p`` percent of all images
        `per_channel` will be treated as True, otherwise as False.

    size_px_max : int or tuple of int or list of int or imgaug.parameters.StochasticParameter, optional
        The noise is generated in a low resolution environment.
        This parameter defines the maximum size of that environment (in
        pixels). The environment is initialized at the same size as the input
        image and then downscaled, so that no side exceeds `size_px_max`
        (aspect ratio is kept).

            * If int, then that number will be used as the size for all
              iterations.
            * If tuple of two ints ``(a, b)``, then a value will be sampled
              per iteration from the discrete range ``[a..b]``.
            * If a list of ints, then a value will be picked per iteration at
              random from that list.
            * If a StochasticParameter, then a value will be sampled from
              that parameter per iteration.

    upscale_method : None or imgaug.ALL or str or list of str or imgaug.parameters.StochasticParameter, optional
        After generating the noise maps in low resolution environments, they
        have to be upscaled to the input image size. This parameter controls
        the upscaling method.

            * If None, then either ``nearest`` or ``linear`` or ``cubic`` is picked.
              Most weight is put on linear, followed by cubic.
            * If imgaug.ALL, then either ``nearest`` or ``linear`` or ``area`` or ``cubic``
              is picked per iteration (all same probability).
            * If string, then that value will be used as the method (must be
              ``nearest`` or ``linear`` or ``area`` or ``cubic``).
            * If list of string, then a random value will be picked from that
              list per iteration.
            * If StochasticParameter, then a random value will be sampled
              from that parameter per iteration.

    iterations : int or tuple of int or list of int or imgaug.parameters.StochasticParameter, optional
        How often to repeat the simplex noise generation process per
        image.

            * If int, then that number will be used as the iterations for all
              images.
            * If tuple of two ints ``(a, b)``, then a value will be sampled
              per image from the discrete range ``[a..b]``.
            * If a list of ints, then a value will be picked per image at
              random from that list.
            * If a StochasticParameter, then a value will be sampled from
              that parameter per image.

    aggregation_method : imgaug.ALL or str or list of str or imgaug.parameters.StochasticParameter, optional
        The noise maps (from each iteration) are combined to one noise map
        using an aggregation process. This parameter defines the method used
        for that process. Valid methods are ``min``, ``max`` or ``avg``,
        where 'min' combines the noise maps by taking the (elementwise) minimum
        over all iteration's results, ``max`` the (elementwise) maximum and
        ``avg`` the (elementwise) average.

            * If imgaug.ALL, then a random value will be picked per image from the
              valid ones.
            * If a string, then that value will always be used as the method.
            * If a list of string, then a random value will be picked from
              that list per image.
            * If a StochasticParameter, then a random value will be sampled
              from that parameter per image.

    sigmoid : bool or number, optional
        Whether to apply a sigmoid function to the final noise maps, resulting
        in maps that have more extreme values (close to 0.0 or 1.0).

            * If bool, then a sigmoid will always (True) or never (False) be
              applied.
            * If a number ``p`` with ``0<=p<=1``, then a sigmoid will be applied to
              ``p`` percent of all final noise maps.

    sigmoid_thresh : None or number or tuple of number or imgaug.parameters.StochasticParameter, optional
        Threshold of the sigmoid, when applied. Thresholds above zero
        (e.g. 5.0) will move the saddle point towards the right, leading to
        more values close to 0.0.

            * If None, then ``Normal(0, 5.0)`` will be used.
            * If number, then that threshold will be used for all images.
            * If tuple of two numbers ``(a, b)``, then a random value will
              be sampled per image from the range ``[a, b]``.
            * If StochasticParameter, then a random value will be sampled from
              that parameter per image.

    name : None or str, optional
        See :func:`imgaug.augmenters.meta.Augmenter.__init__`.

    deterministic : bool, optional
        See :func:`imgaug.augmenters.meta.Augmenter.__init__`.

    random_state : None or int or numpy.random.RandomState, optional
        See :func:`imgaug.augmenters.meta.Augmenter.__init__`.

    Examples
    --------
    >>> aug = iaa.FrequencyNoiseAlpha(first=iaa.EdgeDetect(1.0))

    Detects per image all edges, marks them in a black and white image and
    then alpha-blends the result with the original image using frequency noise
    masks.

    >>> aug = iaa.FrequencyNoiseAlpha(first=iaa.EdgeDetect(1.0), upscale_method="linear")

    Same as the first example, but uses only (smooth) linear upscaling to
    scale the frequency noise masks to the final image sizes, i.e. no nearest
    neighbour upsampling is used, which would result in rectangles with hard
    edges.

    >>> aug = iaa.FrequencyNoiseAlpha(first=iaa.EdgeDetect(1.0), upscale_method="linear", exponent=-2, sigmoid=False)

    Same as the previous example, but also limits the exponent to -2 and
    deactivates the sigmoid, resulting in cloud-like patterns without sharp
    edges.

    >>> aug = iaa.FrequencyNoiseAlpha(first=iaa.EdgeDetect(1.0), sigmoid_thresh=iap.Normal(10.0, 5.0))

    Same as the first example, but uses a threshold for the sigmoid function
    that is further to the right. This is more conservative, i.e. the generated
    noise masks will be mostly black (values around 0.0), which means that
    most of the original images (parameter/branch `second`) will be kept,
    rather than using the results of the augmentation (parameter/branch
    `first`).

    """
    # pylint: disable=dangerous-default-value
    upscale_method_default = iap.Choice(["nearest", "linear", "cubic"], p=[0.05, 0.6, 0.35])
    sigmoid_thresh_default = iap.Normal(0.0, 5.0)

    noise = iap.FrequencyNoise(
        exponent=exponent,
        size_px_max=size_px_max,
        upscale_method=upscale_method if upscale_method is not None else upscale_method_default
    )

    if iterations != 1:
        noise = iap.IterativeNoiseAggregator(
            noise,
            iterations=iterations,
            aggregation_method=aggregation_method
        )

    if sigmoid is False or (ia.is_single_number(sigmoid) and sigmoid <= 0.01):
        noise = iap.Sigmoid.create_for_noise(
            noise,
            threshold=sigmoid_thresh if sigmoid_thresh is not None else sigmoid_thresh_default,
            activated=sigmoid
        )

    if name is None:
        name = "Unnamed%s" % (ia.caller_name(),)

    return AlphaElementwise(
        factor=noise, first=first, second=second, per_channel=per_channel,
        name=name, deterministic=deterministic, random_state=random_state
    )
</source>
</class>

<class classid="3" nclones="2" nlines="11" similarity="100">
<source file="systems/imgaug-0.2.9/imgaug/augmenters/flip.py" startline="110" endline="122" pcid="72">
    def _augment_keypoints(self, keypoints_on_images, random_state, parents, hooks):
        nb_images = len(keypoints_on_images)
        samples = self.p.draw_samples((nb_images,), random_state=random_state)
        for i, keypoints_on_image in enumerate(keypoints_on_images):
            if not keypoints_on_image.keypoints:
                continue
            elif samples[i] == 1:
                width = keypoints_on_image.shape[1]
                for keypoint in keypoints_on_image.keypoints:
                    # TODO is this still correct with float keypoints? Seems like the -1 should be dropped
                    keypoint.x = (width - 1) - keypoint.x
        return keypoints_on_images

</source>
<source file="systems/imgaug-0.2.9/imgaug/augmenters/flip.py" startline="203" endline="215" pcid="78">
    def _augment_keypoints(self, keypoints_on_images, random_state, parents, hooks):
        nb_images = len(keypoints_on_images)
        samples = self.p.draw_samples((nb_images,), random_state=random_state)
        for i, keypoints_on_image in enumerate(keypoints_on_images):
            if not keypoints_on_image.keypoints:
                continue
            elif samples[i] == 1:
                height = keypoints_on_image.shape[0]
                for keypoint in keypoints_on_image.keypoints:
                    # TODO is this still correct with float keypoints? seems like the -1 should be dropped
                    keypoint.y = (height - 1) - keypoint.y
        return keypoints_on_images

</source>
</class>

<class classid="4" nclones="2" nlines="22" similarity="86">
<source file="systems/imgaug-0.2.9/imgaug/augmenters/convolutional.py" startline="210" endline="295" pcid="114">
def Sharpen(alpha=0, lightness=1, name=None, deterministic=False, random_state=None):
    """
    Augmenter that sharpens images and overlays the result with the original image.

    dtype support::

        See ``imgaug.augmenters.convolutional.Convolve``.

    Parameters
    ----------
    alpha : number or tuple of number or list of number or imgaug.parameters.StochasticParameter, optional
        Visibility of the sharpened image. At 0, only the original image is
        visible, at 1.0 only its sharpened version is visible.

            * If an int or float, exactly that value will be used.
            * If a tuple ``(a, b)``, a random value from the range ``a <= x <= b`` will
              be sampled per image.
            * If a list, then a random value will be sampled from that list
              per image.
            * If a StochasticParameter, a value will be sampled from the
              parameter per image.

    lightness : number or tuple of number or list of number or imgaug.parameters.StochasticParameter, optional
        Parameter that controls the lightness/brightness of the sharped image.
        Sane values are somewhere in the range ``(0.5, 2)``.
        The value 0 results in an edge map. Values higher than 1 create bright
        images. Default value is 1.

            * If an int or float, exactly that value will be used.
            * If a tuple ``(a, b)``, a random value from the range ``a <= x <= b`` will
              be sampled per image.
            * If a list, then a random value will be sampled from that list
              per image.
            * If a StochasticParameter, a value will be sampled from the
              parameter per image.

    name : None or str, optional
        See :func:`imgaug.augmenters.meta.Augmenter.__init__`.

    deterministic : bool, optional
        See :func:`imgaug.augmenters.meta.Augmenter.__init__`.

    random_state : None or int or numpy.random.RandomState, optional
        See :func:`imgaug.augmenters.meta.Augmenter.__init__`.

    Examples
    --------
    >>> aug = Sharpen(alpha=(0.0, 1.0))

    sharpens input images and overlays the sharpened image by a variable
    amount over the old image.

    >>> aug = Sharpen(alpha=(0.0, 1.0), lightness=(0.75, 2.0))

    sharpens input images with a variable lightness in the range
    ``0.75 <= x <= 2.0`` and with a variable alpha.

    """
    alpha_param = iap.handle_continuous_param(alpha, "alpha", value_range=(0, 1.0), tuple_to_uniform=True,
                                              list_to_choice=True)
    lightness_param = iap.handle_continuous_param(lightness, "lightness", value_range=(0, None), tuple_to_uniform=True,
                                                  list_to_choice=True)

    def create_matrices(image, nb_channels, random_state_func):
        alpha_sample = alpha_param.draw_sample(random_state=random_state_func)
        ia.do_assert(0 <= alpha_sample <= 1.0)
        lightness_sample = lightness_param.draw_sample(random_state=random_state_func)
        matrix_nochange = np.array([
            [0, 0, 0],
            [0, 1, 0],
            [0, 0, 0]
        ], dtype=np.float32)
        matrix_effect = np.array([
            [-1, -1, -1],
            [-1, 8+lightness_sample, -1],
            [-1, -1, -1]
        ], dtype=np.float32)
        matrix = (1-alpha_sample) * matrix_nochange + alpha_sample * matrix_effect
        return [matrix] * nb_channels

    if name is None:
        name = "Unnamed%s" % (ia.caller_name(),)

    return Convolve(create_matrices, name=name, deterministic=deterministic, random_state=random_state)


</source>
<source file="systems/imgaug-0.2.9/imgaug/augmenters/convolutional.py" startline="296" endline="381" pcid="116">
def Emboss(alpha=0, strength=1, name=None, deterministic=False, random_state=None):
    """
    Augmenter that embosses images and overlays the result with the original
    image.

    The embossed version pronounces highlights and shadows,
    letting the image look as if it was recreated on a metal plate ("embossed").

    dtype support::

        See ``imgaug.augmenters.convolutional.Convolve``.

    Parameters
    ----------
    alpha : number or tuple of number or list of number or imgaug.parameters.StochasticParameter, optional
        Visibility of the sharpened image. At 0, only the original image is
        visible, at 1.0 only its sharpened version is visible.

            * If an int or float, exactly that value will be used.
            * If a tuple ``(a, b)``, a random value from the range ``a <= x <= b`` will
              be sampled per image.
            * If a list, then a random value will be sampled from that list
              per image.
            * If a StochasticParameter, a value will be sampled from the
              parameter per image.

    strength : number or tuple of number or list of number or imgaug.parameters.StochasticParameter, optional
        Parameter that controls the strength of the embossing.
        Sane values are somewhere in the range ``(0, 2)`` with 1 being the standard
        embossing effect. Default value is 1.

            * If an int or float, exactly that value will be used.
            * If a tuple ``(a, b)``, a random value from the range ``a <= x <= b`` will
              be sampled per image.
            * If a list, then a random value will be sampled from that list
              per image.
            * If a StochasticParameter, a value will be sampled from the
              parameter per image.

    name : None or str, optional
        See :func:`imgaug.augmenters.meta.Augmenter.__init__`.

    deterministic : bool, optional
        See :func:`imgaug.augmenters.meta.Augmenter.__init__`.

    random_state : None or int or numpy.random.RandomState, optional
        See :func:`imgaug.augmenters.meta.Augmenter.__init__`.

    Examples
    --------
    >>> aug = Emboss(alpha=(0.0, 1.0), strength=(0.5, 1.5))

    embosses an image with a variable strength in the range ``0.5 <= x <= 1.5``
    and overlays the result with a variable alpha in the range ``0.0 <= a <= 1.0``
    over the old image.

    """
    alpha_param = iap.handle_continuous_param(alpha, "alpha", value_range=(0, 1.0), tuple_to_uniform=True,
                                              list_to_choice=True)
    strength_param = iap.handle_continuous_param(strength, "strength", value_range=(0, None), tuple_to_uniform=True,
                                                 list_to_choice=True)

    def create_matrices(image, nb_channels, random_state_func):
        alpha_sample = alpha_param.draw_sample(random_state=random_state_func)
        ia.do_assert(0 <= alpha_sample <= 1.0)
        strength_sample = strength_param.draw_sample(random_state=random_state_func)
        matrix_nochange = np.array([
            [0, 0, 0],
            [0, 1, 0],
            [0, 0, 0]
        ], dtype=np.float32)
        matrix_effect = np.array([
            [-1-strength_sample, 0-strength_sample, 0],
            [0-strength_sample, 1, 0+strength_sample],
            [0, 0+strength_sample, 1+strength_sample]
        ], dtype=np.float32)
        matrix = (1-alpha_sample) * matrix_nochange + alpha_sample * matrix_effect
        return [matrix] * nb_channels

    if name is None:
        name = "Unnamed%s" % (ia.caller_name(),)

    return Convolve(create_matrices, name=name, deterministic=deterministic, random_state=random_state)


# TODO tests
</source>
</class>

<class classid="5" nclones="3" nlines="14" similarity="71">
<source file="systems/imgaug-0.2.9/imgaug/augmenters/convolutional.py" startline="273" endline="289" pcid="115">
    def create_matrices(image, nb_channels, random_state_func):
        alpha_sample = alpha_param.draw_sample(random_state=random_state_func)
        ia.do_assert(0 <= alpha_sample <= 1.0)
        lightness_sample = lightness_param.draw_sample(random_state=random_state_func)
        matrix_nochange = np.array([
            [0, 0, 0],
            [0, 1, 0],
            [0, 0, 0]
        ], dtype=np.float32)
        matrix_effect = np.array([
            [-1, -1, -1],
            [-1, 8+lightness_sample, -1],
            [-1, -1, -1]
        ], dtype=np.float32)
        matrix = (1-alpha_sample) * matrix_nochange + alpha_sample * matrix_effect
        return [matrix] * nb_channels

</source>
<source file="systems/imgaug-0.2.9/imgaug/augmenters/convolutional.py" startline="426" endline="441" pcid="119">
    def create_matrices(_image, nb_channels, random_state_func):
        alpha_sample = alpha_param.draw_sample(random_state=random_state_func)
        ia.do_assert(0 <= alpha_sample <= 1.0)
        matrix_nochange = np.array([
            [0, 0, 0],
            [0, 1, 0],
            [0, 0, 0]
        ], dtype=np.float32)
        matrix_effect = np.array([
            [0, 1, 0],
            [1, -4, 1],
            [0, 1, 0]
        ], dtype=np.float32)
        matrix = (1-alpha_sample) * matrix_nochange + alpha_sample * matrix_effect
        return [matrix] * nb_channels

</source>
<source file="systems/imgaug-0.2.9/imgaug/augmenters/convolutional.py" startline="358" endline="374" pcid="117">
    def create_matrices(image, nb_channels, random_state_func):
        alpha_sample = alpha_param.draw_sample(random_state=random_state_func)
        ia.do_assert(0 <= alpha_sample <= 1.0)
        strength_sample = strength_param.draw_sample(random_state=random_state_func)
        matrix_nochange = np.array([
            [0, 0, 0],
            [0, 1, 0],
            [0, 0, 0]
        ], dtype=np.float32)
        matrix_effect = np.array([
            [-1-strength_sample, 0-strength_sample, 0],
            [0-strength_sample, 1, 0+strength_sample],
            [0, 0+strength_sample, 1+strength_sample]
        ], dtype=np.float32)
        matrix = (1-alpha_sample) * matrix_nochange + alpha_sample * matrix_effect
        return [matrix] * nb_channels

</source>
</class>

<class classid="6" nclones="2" nlines="49" similarity="78">
<source file="systems/imgaug-0.2.9/imgaug/augmenters/arithmetic.py" startline="130" endline="206" pcid="128">
    def _augment_images(self, images, random_state, parents, hooks):
        iadt.gate_dtypes(images,
                         allowed=["bool", "uint8", "uint16", "int8", "int16", "float16", "float32"],
                         disallowed=["uint32", "uint64", "uint128", "uint256", "int32", "int64", "int128", "int256",
                                     "float64", "float96", "float128", "float256"],
                         augmenter=self)

        input_dtypes = iadt.copy_dtypes_for_restore(images, force_list=True)

        nb_images = len(images)
        nb_channels_max = meta.estimate_max_number_of_channels(images)
        rss = ia.derive_random_states(random_state, 2)
        value_samples = self.value.draw_samples((nb_images, nb_channels_max), random_state=rss[0])
        per_channel_samples = self.per_channel.draw_samples((nb_images,), random_state=rss[1])

        gen = enumerate(zip(images, value_samples, per_channel_samples, input_dtypes))
        for i, (image, value_samples_i, per_channel_samples_i, input_dtype) in gen:
            nb_channels = image.shape[2]

            # Example code to directly add images via image+sample (uint8 only)
            # if per_channel_samples_i > 0.5:
            #     result = []
            #     image = image.astype(np.int16)
            #     value_samples_i = value_samples_i.astype(np.int16)
            #     for c, value in enumerate(value_samples_i[0:nb_channels]):
            #         result.append(np.clip(image[..., c:c+1] + value, 0, 255).astype(np.uint8))
            #     images[i] = np.concatenate(result, axis=2)
            # else:
            #     images[i] = np.clip(
            #         image.astype(np.int16) + value_samples_i[0].astype(np.int16), 0, 255).astype(np.uint8)

            if image.dtype.name == "uint8":
                # Using this LUT approach is significantly faster than the else-block code (around 3-4x speedup)
                # and is still faster than the simpler image+sample approach without LUT (about 10% at 64x64 and about
                # 2x at 224x224 -- maybe dependent on installed BLAS libraries?)
                value_samples_i = np.clip(np.round(value_samples_i), -255, 255).astype(np.int16)
                value_range = np.arange(0, 256, dtype=np.int16)
                if per_channel_samples_i > 0.5:
                    result = []
                    tables = np.tile(value_range[np.newaxis, :], (nb_channels, 1)) \
                        + value_samples_i[0:nb_channels, np.newaxis]
                    tables = np.clip(tables, 0, 255).astype(image.dtype)
                    for c, table in enumerate(tables):
                        arr_aug = cv2.LUT(image[..., c], table)
                        result.append(arr_aug[..., np.newaxis])
                    images[i] = np.concatenate(result, axis=2)
                else:
                    table = value_range + value_samples_i[0]
                    image_aug = cv2.LUT(image, np.clip(table, 0, 255).astype(image.dtype))
                    if image_aug.ndim == 2:
                        image_aug = image_aug[..., np.newaxis]
                    images[i] = image_aug
            else:
                if per_channel_samples_i > 0.5:
                    value = value_samples_i[0:nb_channels].reshape((1, 1, nb_channels))
                else:
                    value = value_samples_i[0:1].reshape((1, 1, 1))

                # We limit here the value range of the value parameter to the bytes in the image's dtype.
                # This prevents overflow problems and makes it less likely that the image has to be up-casted, which
                # again improves performance and saves memory. Note that this also enables more dtypes for image inputs.
                # The downside is that the mul parameter is limited in its value range.
                #
                # We need 2* the itemsize of the image here to allow to shift the image's max value to the lowest
                # possible value, e.g. for uint8 it must allow for -255 to 255.
                itemsize = image.dtype.itemsize * 2
                dtype_target = np.dtype("%s%d" % (value.dtype.kind, itemsize))
                value = iadt.clip_to_dtype_value_range_(value, dtype_target, validate=True)

                image, value = iadt.promote_array_dtypes_([image, value], dtypes=[image.dtype, dtype_target],
                                                          increase_itemsize_factor=2)
                image = np.add(image, value, out=image, casting="no")

                image = iadt.restore_dtypes_(image, input_dtype)
                images[i] = image

        return images
</source>
<source file="systems/imgaug-0.2.9/imgaug/augmenters/arithmetic.py" startline="706" endline="787" pcid="141">

    def _augment_images(self, images, random_state, parents, hooks):
        iadt.gate_dtypes(images,
                         allowed=["bool", "uint8", "uint16", "int8", "int16", "float16", "float32"],
                         disallowed=["uint32", "uint64", "uint128", "uint256", "int32", "int64", "int128", "int256",
                                     "float64", "float96", "float128", "float256"],
                         augmenter=self)

        input_dtypes = iadt.copy_dtypes_for_restore(images, force_list=True)

        nb_images = len(images)
        nb_channels_max = meta.estimate_max_number_of_channels(images)
        rss = ia.derive_random_states(random_state, 2)
        mul_samples = self.mul.draw_samples((nb_images, nb_channels_max), random_state=rss[0])
        per_channel_samples = self.per_channel.draw_samples((nb_images,), random_state=rss[1])

        gen = enumerate(zip(images, mul_samples, per_channel_samples, input_dtypes))
        for i, (image, mul_samples_i, per_channel_samples_i, input_dtype) in gen:
            nb_channels = image.shape[2]

            # Example code to directly multiply images via image*sample (uint8 only) -- apparently slower than LUT
            # if per_channel_samples_i > 0.5:
            #     result = []
            #     image = image.astype(np.float32)
            #     mul_samples_i = mul_samples_i.astype(np.float32)
            #     for c, mul in enumerate(mul_samples_i[0:nb_channels]):
            #         result.append(np.clip(image[..., c:c+1] * mul, 0, 255).astype(np.uint8))
            #     images[i] = np.concatenate(result, axis=2)
            # else:
            #     images[i] = np.clip(
            #         image.astype(np.float32) * mul_samples_i[0].astype(np.float32), 0, 255).astype(np.uint8)

            if image.dtype.name == "uint8":
                # Using this LUT approach is significantly faster than else-block code (more than 10x speedup)
                # and is still faster than the simpler image*sample approach without LUT (1.5-3x speedup,
                # maybe dependent on installed BLAS libraries?)
                value_range = np.arange(0, 256, dtype=np.float32)
                if per_channel_samples_i > 0.5:
                    result = []
                    mul_samples_i = mul_samples_i.astype(np.float32)
                    tables = np.tile(value_range[np.newaxis, :], (nb_channels, 1)) \
                        * mul_samples_i[0:nb_channels, np.newaxis]
                    tables = np.clip(tables, 0, 255).astype(image.dtype)
                    for c, table in enumerate(tables):
                        arr_aug = cv2.LUT(image[..., c], table)
                        result.append(arr_aug[..., np.newaxis])
                    images[i] = np.concatenate(result, axis=2)
                else:
                    table = value_range * mul_samples_i[0].astype(np.float32)
                    image_aug = cv2.LUT(image, np.clip(table, 0, 255).astype(image.dtype))
                    if image_aug.ndim == 2:
                        image_aug = image_aug[..., np.newaxis]
                    images[i] = image_aug
            else:
                # TODO estimate via image min/max values whether a resolution increase is necessary

                if per_channel_samples_i > 0.5:
                    mul = mul_samples_i[0:nb_channels].reshape((1, 1, nb_channels))
                else:
                    mul = mul_samples_i[0:1].reshape((1, 1, 1))

                mul_min = np.min(mul)
                mul_max = np.max(mul)
                is_not_increasing_value_range = (-1 <= mul_min <= 1) and (-1 <= mul_max <= 1)

                # We limit here the value range of the mul parameter to the bytes in the image's dtype.
                # This prevents overflow problems and makes it less likely that the image has to be up-casted, which
                # again improves performance and saves memory. Note that this also enables more dtypes for image inputs.
                # The downside is that the mul parameter is limited in its value range.
                itemsize = max(image.dtype.itemsize, 2 if mul.dtype.kind == "f" else 1)  # float min itemsize is 2 not 1
                dtype_target = np.dtype("%s%d" % (mul.dtype.kind, itemsize))
                mul = iadt.clip_to_dtype_value_range_(mul, dtype_target, validate=True)

                image, mul = iadt.promote_array_dtypes_(
                    [image, mul],
                    dtypes=[image.dtype, dtype_target],
                    increase_itemsize_factor=1 if is_not_increasing_value_range else 2)
                image = np.multiply(image, mul, out=image, casting="no")

                image = iadt.restore_dtypes_(image, input_dtype)
                images[i] = image

</source>
</class>

<class classid="7" nclones="3" nlines="13" similarity="71">
<source file="systems/imgaug-0.2.9/imgaug/augmenters/contrast.py" startline="41" endline="108" pcid="180">
def adjust_contrast_gamma(arr, gamma):
    """
    Adjust contrast by scaling each pixel value to ``255 * ((I_ij/255)**gamma)``.

    dtype support::

        * ``uint8``: yes; fully tested (1) (2) (3)
        * ``uint16``: yes; tested (2) (3)
        * ``uint32``: yes; tested (2) (3)
        * ``uint64``: yes; tested (2) (3) (4)
        * ``int8``: limited; tested (2) (3) (5)
        * ``int16``: limited; tested (2) (3) (5)
        * ``int32``: limited; tested (2) (3) (5)
        * ``int64``: limited; tested (2) (3) (4) (5)
        * ``float16``: limited; tested (5)
        * ``float32``: limited; tested (5)
        * ``float64``: limited; tested (5)
        * ``float128``: no (6)
        * ``bool``: no (7)

        - (1) Handled by ``cv2``. Other dtypes are handled by ``skimage``.
        - (2) Normalization is done as ``I_ij/max``, where ``max`` is the maximum value of the
              dtype, e.g. 255 for ``uint8``. The normalization is reversed afterwards,
              e.g. ``result*255`` for ``uint8``.
        - (3) Integer-like values are not rounded after applying the contrast adjustment equation
              (before inverting the normalization to 0.0-1.0 space), i.e. projection from continuous
              space to discrete happens according to floor function.
        - (4) Note that scikit-image doc says that integers are converted to ``float64`` values before
              applying the contrast normalization method. This might lead to inaccuracies for large
              64bit integer values. Tests showed no indication of that happening though.
        - (5) Must not contain negative values. Values >=0 are fully supported.
        - (6) Leads to error in scikit-image.
        - (7) Does not make sense for contrast adjustments.

    Parameters
    ----------
    arr : numpy.ndarray
        Array for which to adjust the contrast. Dtype ``uint8`` is fastest.

    gamma : number
        Exponent for the contrast adjustment. Higher values darken the image.

    Returns
    -------
    numpy.ndarray
        Array with adjusted contrast.

    """
    # int8 is also possible according to docs
    # https://docs.opencv.org/3.0-beta/modules/core/doc/operations_on_arrays.html#cv2.LUT , but here it seemed
    # like `d` was 0 for CV_8S, causing that to fail
    if arr.dtype.name == "uint8":
        min_value, _center_value, max_value = iadt.get_value_range_of_dtype(arr.dtype)
        dynamic_range = max_value - min_value

        value_range = np.linspace(0, 1.0, num=dynamic_range+1, dtype=np.float32)
        # 255 * ((I_ij/255)**gamma)
        # using np.float32(.) here still works when the input is a numpy array of size 1
        table = (min_value + (value_range ** np.float32(gamma)) * dynamic_range)
        arr_aug = cv2.LUT(arr, np.clip(table, min_value, max_value).astype(arr.dtype))
        if arr.ndim == 3 and arr_aug.ndim == 2:
            return arr_aug[..., np.newaxis]
        return arr_aug
    else:
        return ski_exposure.adjust_gamma(arr, gamma)


# TODO quite similar to the other adjust_contrast_*() functions, make DRY
</source>
<source file="systems/imgaug-0.2.9/imgaug/augmenters/contrast.py" startline="185" endline="255" pcid="182">
def adjust_contrast_log(arr, gain):
    """
    Adjust contrast by scaling each pixel value to ``255 * gain * log_2(1 + I_ij/255)``.

    dtype support::

        * ``uint8``: yes; fully tested (1) (2) (3)
        * ``uint16``: yes; tested (2) (3)
        * ``uint32``: yes; tested (2) (3)
        * ``uint64``: yes; tested (2) (3) (4)
        * ``int8``: limited; tested (2) (3) (5)
        * ``int16``: limited; tested (2) (3) (5)
        * ``int32``: limited; tested (2) (3) (5)
        * ``int64``: limited; tested (2) (3) (4) (5)
        * ``float16``: limited; tested (5)
        * ``float32``: limited; tested (5)
        * ``float64``: limited; tested (5)
        * ``float128``: no (6)
        * ``bool``: no (7)

        - (1) Handled by ``cv2``. Other dtypes are handled by ``skimage``.
        - (2) Normalization is done as ``I_ij/max``, where ``max`` is the maximum value of the
              dtype, e.g. 255 for ``uint8``. The normalization is reversed afterwards,
              e.g. ``result*255`` for ``uint8``.
        - (3) Integer-like values are not rounded after applying the contrast adjustment equation
              (before inverting the normalization to 0.0-1.0 space), i.e. projection from continuous
              space to discrete happens according to floor function.
        - (4) Note that scikit-image doc says that integers are converted to ``float64`` values before
              applying the contrast normalization method. This might lead to inaccuracies for large
              64bit integer values. Tests showed no indication of that happening though.
        - (5) Must not contain negative values. Values >=0 are fully supported.
        - (6) Leads to error in scikit-image.
        - (7) Does not make sense for contrast adjustments.

    Parameters
    ----------
    arr : numpy.ndarray
        Array for which to adjust the contrast. Dtype ``uint8`` is fastest.

    gain : number
        Multiplier for the logarithm result. Values around 1.0 lead to a contrast-adjusted
        images. Values above 1.0 quickly lead to partially broken images due to exceeding the
        datatype's value range.

    Returns
    -------
    numpy.ndarray
        Array with adjusted contrast.

    """
    # int8 is also possible according to docs
    # https://docs.opencv.org/3.0-beta/modules/core/doc/operations_on_arrays.html#cv2.LUT , but here it seemed
    # like `d` was 0 for CV_8S, causing that to fail
    if arr.dtype.name == "uint8":
        min_value, _center_value, max_value = iadt.get_value_range_of_dtype(arr.dtype)
        dynamic_range = max_value - min_value

        value_range = np.linspace(0, 1.0, num=dynamic_range+1, dtype=np.float32)
        # 255 * 1/(1 + exp(gain*(cutoff - I_ij/255)))
        # using np.float32(.) here still works when the input is a numpy array of size 1
        gain = np.float32(gain)
        table = min_value + dynamic_range * gain * np.log2(1 + value_range)
        arr_aug = cv2.LUT(arr, np.clip(table, min_value, max_value).astype(arr.dtype))
        if arr.ndim == 3 and arr_aug.ndim == 2:
            return arr_aug[..., np.newaxis]
        return arr_aug
    else:
        return ski_exposure.adjust_log(arr, gain=gain)


# TODO quite similar to the other adjust_contrast_*() functions, make DRY
</source>
<source file="systems/imgaug-0.2.9/imgaug/augmenters/contrast.py" startline="109" endline="184" pcid="181">
def adjust_contrast_sigmoid(arr, gain, cutoff):
    """
    Adjust contrast by scaling each pixel value to ``255 * 1/(1 + exp(gain*(cutoff - I_ij/255)))``.

    dtype support::

        * ``uint8``: yes; fully tested (1) (2) (3)
        * ``uint16``: yes; tested (2) (3)
        * ``uint32``: yes; tested (2) (3)
        * ``uint64``: yes; tested (2) (3) (4)
        * ``int8``: limited; tested (2) (3) (5)
        * ``int16``: limited; tested (2) (3) (5)
        * ``int32``: limited; tested (2) (3) (5)
        * ``int64``: limited; tested (2) (3) (4) (5)
        * ``float16``: limited; tested (5)
        * ``float32``: limited; tested (5)
        * ``float64``: limited; tested (5)
        * ``float128``: no (6)
        * ``bool``: no (7)

        - (1) Handled by ``cv2``. Other dtypes are handled by ``skimage``.
        - (2) Normalization is done as ``I_ij/max``, where ``max`` is the maximum value of the
              dtype, e.g. 255 for ``uint8``. The normalization is reversed afterwards,
              e.g. ``result*255`` for ``uint8``.
        - (3) Integer-like values are not rounded after applying the contrast adjustment equation
              (before inverting the normalization to 0.0-1.0 space), i.e. projection from continuous
              space to discrete happens according to floor function.
        - (4) Note that scikit-image doc says that integers are converted to ``float64`` values before
              applying the contrast normalization method. This might lead to inaccuracies for large
              64bit integer values. Tests showed no indication of that happening though.
        - (5) Must not contain negative values. Values >=0 are fully supported.
        - (6) Leads to error in scikit-image.
        - (7) Does not make sense for contrast adjustments.

    Parameters
    ----------
    arr : numpy.ndarray
        Array for which to adjust the contrast. Dtype ``uint8`` is fastest.

    gain : number
        Multiplier for the sigmoid function's output.
        Higher values lead to quicker changes from dark to light pixels.

    cutoff : number
        Cutoff that shifts the sigmoid function in horizontal direction.
        Higher values mean that the switch from dark to light pixels happens later, i.e.
        the pixels will remain darker.

    Returns
    -------
    numpy.ndarray
        Array with adjusted contrast.

    """
    # int8 is also possible according to docs
    # https://docs.opencv.org/3.0-beta/modules/core/doc/operations_on_arrays.html#cv2.LUT , but here it seemed
    # like `d` was 0 for CV_8S, causing that to fail
    if arr.dtype.name == "uint8":
        min_value, _center_value, max_value = iadt.get_value_range_of_dtype(arr.dtype)
        dynamic_range = max_value - min_value

        value_range = np.linspace(0, 1.0, num=dynamic_range+1, dtype=np.float32)
        # 255 * 1/(1 + exp(gain*(cutoff - I_ij/255)))
        # using np.float32(.) here still works when the input is a numpy array of size 1
        gain = np.float32(gain)
        cutoff = np.float32(cutoff)
        table = min_value + dynamic_range * 1/(1 + np.exp(gain * (cutoff - value_range)))
        arr_aug = cv2.LUT(arr, np.clip(table, min_value, max_value).astype(arr.dtype))
        if arr.ndim == 3 and arr_aug.ndim == 2:
            return arr_aug[..., np.newaxis]
        return arr_aug
    else:
        return ski_exposure.adjust_sigmoid(arr, cutoff=cutoff, gain=gain)


# TODO quite similar to the other adjust_contrast_*() functions, make DRY
</source>
</class>

<class classid="8" nclones="3" nlines="13" similarity="71">
<source file="systems/imgaug-0.2.9/imgaug/augmenters/contrast.py" startline="321" endline="375" pcid="184">
def GammaContrast(gamma=1, per_channel=False, name=None, deterministic=False, random_state=None):
    """
    Adjust contrast by scaling each pixel value to ``255 * ((I_ij/255)**gamma)``.

    Values in the range ``gamma=(0.5, 2.0)`` seem to be sensible.

    dtype support::

        See :func:`imgaug.augmenters.contrast.adjust_contrast_gamma`.

    Parameters
    ----------
    gamma : number or tuple of number or list of number or imgaug.parameters.StochasticParameter, optional
        Exponent for the contrast adjustment. Higher values darken the image.

            * If a number, then that value will be used for all images.
            * If a tuple ``(a, b)``, then a value from the range ``[a, b]`` will be used per image.
            * If a list, then a random value will be sampled from that list per image.
            * If a StochasticParameter, then a value will be sampled per image from that parameter.

    per_channel :  bool or float, optional
        Whether to use the same value for all channels (False) or to sample a new value for each
        channel (True). If this value is a float ``p``, then for ``p`` percent of all images `per_channel`
        will be treated as True, otherwise as False.

    name : None or str, optional
        See :func:`imgaug.augmenters.meta.Augmenter.__init__`.

    deterministic : bool, optional
        See :func:`imgaug.augmenters.meta.Augmenter.__init__`.

    random_state : None or int or numpy.random.RandomState, optional
        See :func:`imgaug.augmenters.meta.Augmenter.__init__`.

    Returns
    -------
    _ContrastFuncWrapper
        Augmenter to perform gamma contrast adjustment.

    """
    params1d = [iap.handle_continuous_param(gamma, "gamma", value_range=None, tuple_to_uniform=True,
                                            list_to_choice=True)]
    func = adjust_contrast_gamma
    return _ContrastFuncWrapper(
        func, params1d, per_channel,
        dtypes_allowed=["uint8", "uint16", "uint32", "uint64",
                        "int8", "int16", "int32", "int64",
                        "float16", "float32", "float64"],
        dtypes_disallowed=["float96", "float128", "float256", "bool"],
        name=name if name is not None else ia.caller_name(),
        deterministic=deterministic,
        random_state=random_state
    )


</source>
<source file="systems/imgaug-0.2.9/imgaug/augmenters/contrast.py" startline="376" endline="444" pcid="185">
def SigmoidContrast(gain=10, cutoff=0.5, per_channel=False, name=None, deterministic=False, random_state=None):
    """
    Adjust contrast by scaling each pixel value to ``255 * 1/(1 + exp(gain*(cutoff - I_ij/255)))``.

    Values in the range ``gain=(5, 20)`` and ``cutoff=(0.25, 0.75)`` seem to be sensible.

    dtype support::

        See :func:`imgaug.augmenters.contrast.adjust_contrast_sigmoid`.

    Parameters
    ----------
    gain : number or tuple of number or list of number or imgaug.parameters.StochasticParameter, optional
        Multiplier for the sigmoid function's output.
        Higher values lead to quicker changes from dark to light pixels.

            * If a number, then that value will be used for all images.
            * If a tuple ``(a, b)``, then a value from the range ``[a, b]`` will be used per image.
            * If a list, then a random value will be sampled from that list per image.
            * If a StochasticParameter, then a value will be sampled per image from that parameter.

    cutoff : number or tuple of number or list of number or imgaug.parameters.StochasticParameter, optional
        Cutoff that shifts the sigmoid function in horizontal direction.
        Higher values mean that the switch from dark to light pixels happens later, i.e.
        the pixels will remain darker.

            * If a number, then that value will be used for all images.
            * If a tuple ``(a, b)``, then a value from the range ``[a, b]`` will be used per image.
            * If a list, then a random value will be sampled from that list per image.
            * If a StochasticParameter, then a value will be sampled per image from that parameter.

    per_channel :  bool or float, optional
        Whether to use the same value for all channels (False) or to sample a new value for each
        channel (True). If this value is a float ``p``, then for ``p`` percent of all images `per_channel`
        will be treated as True, otherwise as False.

    name : None or str, optional
        See :func:`imgaug.augmenters.meta.Augmenter.__init__`.

    deterministic : bool, optional
        See :func:`imgaug.augmenters.meta.Augmenter.__init__`.

    random_state : None or int or numpy.random.RandomState, optional
        See :func:`imgaug.augmenters.meta.Augmenter.__init__`.

    Returns
    -------
    _ContrastFuncWrapper
        Augmenter to perform sigmoid contrast adjustment.

    """
    # TODO add inv parameter?
    params1d = [
        iap.handle_continuous_param(gain, "gain", value_range=(0, None), tuple_to_uniform=True, list_to_choice=True),
        iap.handle_continuous_param(cutoff, "cutoff", value_range=(0, 1.0), tuple_to_uniform=True, list_to_choice=True)
    ]
    func = adjust_contrast_sigmoid
    return _ContrastFuncWrapper(
        func, params1d, per_channel,
        dtypes_allowed=["uint8", "uint16", "uint32", "uint64",
                        "int8", "int16", "int32", "int64",
                        "float16", "float32", "float64"],
        dtypes_disallowed=["float96", "float128", "float256", "bool"],
        name=name if name is not None else ia.caller_name(),
        deterministic=deterministic,
        random_state=random_state
    )


</source>
<source file="systems/imgaug-0.2.9/imgaug/augmenters/contrast.py" startline="445" endline="500" pcid="186">
def LogContrast(gain=1, per_channel=False, name=None, deterministic=False, random_state=None):
    """
    Adjust contrast by scaling each pixel value to ``255 * gain * log_2(1 + I_ij/255)``.

    dtype support::

        See :func:`imgaug.augmenters.contrast.adjust_contrast_log`.

    Parameters
    ----------
    gain : number or tuple of number or list of number or imgaug.parameters.StochasticParameter, optional
        Multiplier for the logarithm result. Values around 1.0 lead to a contrast-adjusted
        images. Values above 1.0 quickly lead to partially broken images due to exceeding the
        datatype's value range.

            * If a number, then that value will be used for all images.
            * If a tuple ``(a, b)``, then a value from the range ``[a, b]`` will be used per image.
            * If a list, then a random value will be sampled from that list per image.
            * If a StochasticParameter, then a value will be sampled per image from that parameter.

    per_channel :  bool or float, optional
        Whether to use the same value for all channels (False) or to sample a new value for each
        channel (True). If this value is a float ``p``, then for ``p`` percent of all images `per_channel`
        will be treated as True, otherwise as False.

    name : None or str, optional
        See :func:`imgaug.augmenters.meta.Augmenter.__init__`.

    deterministic : bool, optional
        See :func:`imgaug.augmenters.meta.Augmenter.__init__`.

    random_state : None or int or numpy.random.RandomState, optional
        See :func:`imgaug.augmenters.meta.Augmenter.__init__`.

    Returns
    -------
    _ContrastFuncWrapper
        Augmenter to perform logarithmic contrast adjustment.

    """
    # TODO add inv parameter?
    params1d = [iap.handle_continuous_param(gain, "gain", value_range=(0, None), tuple_to_uniform=True,
                                            list_to_choice=True)]
    func = adjust_contrast_log
    return _ContrastFuncWrapper(
        func, params1d, per_channel,
        dtypes_allowed=["uint8", "uint16", "uint32", "uint64",
                        "int8", "int16", "int32", "int64",
                        "float16", "float32", "float64"],
        dtypes_disallowed=["float96", "float128", "float256", "bool"],
        name=name if name is not None else ia.caller_name(),
        deterministic=deterministic,
        random_state=random_state
    )


</source>
</class>

<class classid="9" nclones="2" nlines="13" similarity="84">
<source file="systems/imgaug-0.2.9/imgaug/augmenters/contrast.py" startline="943" endline="958" pcid="196">
    def _augment_images(self, images, random_state, parents, hooks):
        iadt.gate_dtypes(images,
                         allowed=["uint8"],
                         disallowed=["bool",
                                     "uint16", "uint32", "uint64", "uint128", "uint256",
                                     "int8", "int16", "int32", "int64", "int128", "int256",
                                     "float16", "float32", "float64", "float96", "float128", "float256"],
                         augmenter=self)

        def _augment_all_channels_clahe(images_normalized, random_state_derived):
            return self.all_channel_clahe._augment_images(images_normalized, random_state_derived, parents + [self],
                                                          hooks)

        return self.intensity_channel_based_applier.apply(images, random_state, parents + [self], hooks,
                                                          _augment_all_channels_clahe)

</source>
<source file="systems/imgaug-0.2.9/imgaug/augmenters/contrast.py" startline="1131" endline="1146" pcid="207">
    def _augment_images(self, images, random_state, parents, hooks):
        iadt.gate_dtypes(images,
                         allowed=["uint8"],
                         disallowed=["bool",
                                     "uint16", "uint32", "uint64", "uint128", "uint256",
                                     "int8", "int16", "int32", "int64", "int128", "int256",
                                     "float16", "float32", "float64", "float96", "float128", "float256"],
                         augmenter=self)

        def _augment_all_channels_histogram_equalization(images_normalized, random_state_derived):
            return self.all_channel_histogram_equalization._augment_images(images_normalized, random_state_derived,
                                                                           parents + [self], hooks)

        return self.intensity_channel_based_applier.apply(images, random_state, parents + [self], hooks,
                                                          _augment_all_channels_histogram_equalization)

</source>
</class>

<class classid="10" nclones="3" nlines="22" similarity="76">
<source file="systems/imgaug-0.2.9/imgaug/imgaug.py" startline="728" endline="773" pcid="249">
def quokka_keypoints(size=None, extract=None):
    """
    Returns example keypoints on the standard example quokke image.

    The keypoints cover the eyes, ears, nose and paws.

    Parameters
    ----------
    size : None or float or tuple of int or tuple of float, optional
        Size of the output image on which the keypoints are placed. If None, then the keypoints
        are not projected to any new size (positions on the original image are used).
        Floats lead to relative size changes, ints to absolute sizes in pixels.

    extract : None or 'square' or tuple of number or imgaug.BoundingBox or imgaug.BoundingBoxesOnImage
        Subarea to extract from the image. See :func:`imgaug.quokka`.

    Returns
    -------
    kpsoi : imgaug.KeypointsOnImage
        Example keypoints on the quokka image.

    """
    # TODO get rid of this deferred import
    from imgaug.augmentables.kps import Keypoint, KeypointsOnImage

    left, top = 0, 0
    if extract is not None:
        bb_extract = _quokka_normalize_extract(extract)
        left = bb_extract.x1
        top = bb_extract.y1
    with open(QUOKKA_ANNOTATIONS_FP, "r") as f:
        json_dict = json.load(f)
    keypoints = []
    for kp_dict in json_dict["keypoints"]:
        keypoints.append(Keypoint(x=kp_dict["x"] - left, y=kp_dict["y"] - top))
    if extract is not None:
        shape = (bb_extract.height, bb_extract.width, 3)
    else:
        shape = (643, 960, 3)
    kpsoi = KeypointsOnImage(keypoints, shape=shape)
    if size is not None:
        shape_resized = _compute_resized_shape(shape, size)
        kpsoi = kpsoi.on(shape_resized)
    return kpsoi


</source>
<source file="systems/imgaug-0.2.9/imgaug/imgaug.py" startline="827" endline="877" pcid="251">
def quokka_polygons(size=None, extract=None):
    """
    Returns example polygons on the standard example quokke image.

    The result contains one polygon, covering the quokka's outline.

    Parameters
    ----------
    size : None or float or tuple of int or tuple of float, optional
        Size of the output image on which the polygons are placed. If None,
        then the polygons are not projected to any new size (positions on the
        original image are used). Floats lead to relative size changes, ints
        to absolute sizes in pixels.

    extract : None or 'square' or tuple of number or imgaug.BoundingBox or \
              imgaug.BoundingBoxesOnImage
        Subarea to extract from the image. See :func:`imgaug.quokka`.

    Returns
    -------
    psoi : imgaug.PolygonsOnImage
        Example polygons on the quokka image.

    """
    # TODO get rid of this deferred import
    from imgaug.augmentables.polys import Polygon, PolygonsOnImage

    left, top = 0, 0
    if extract is not None:
        bb_extract = _quokka_normalize_extract(extract)
        left = bb_extract.x1
        top = bb_extract.y1
    with open(QUOKKA_ANNOTATIONS_FP, "r") as f:
        json_dict = json.load(f)
    polygons = []
    for poly_json in json_dict["polygons"]:
        polygons.append(
            Polygon([(point["x"] - left, point["y"] - top)
                    for point in poly_json["keypoints"]])
        )
    if extract is not None:
        shape = (bb_extract.height, bb_extract.width, 3)
    else:
        shape = (643, 960, 3)
    psoi = PolygonsOnImage(polygons, shape=shape)
    if size is not None:
        shape_resized = _compute_resized_shape(shape, size)
        psoi = psoi.on(shape_resized)
    return psoi


</source>
<source file="systems/imgaug-0.2.9/imgaug/imgaug.py" startline="774" endline="826" pcid="250">
def quokka_bounding_boxes(size=None, extract=None):
    """
    Returns example bounding boxes on the standard example quokke image.

    Currently only a single bounding box is returned that covers the quokka.

    Parameters
    ----------
    size : None or float or tuple of int or tuple of float, optional
        Size of the output image on which the BBs are placed. If None, then the BBs
        are not projected to any new size (positions on the original image are used).
        Floats lead to relative size changes, ints to absolute sizes in pixels.

    extract : None or 'square' or tuple of number or imgaug.BoundingBox or imgaug.BoundingBoxesOnImage
        Subarea to extract from the image. See :func:`imgaug.quokka`.

    Returns
    -------
    bbsoi : imgaug.BoundingBoxesOnImage
        Example BBs on the quokka image.

    """
    # TODO get rid of this deferred import
    from imgaug.augmentables.bbs import BoundingBox, BoundingBoxesOnImage

    left, top = 0, 0
    if extract is not None:
        bb_extract = _quokka_normalize_extract(extract)
        left = bb_extract.x1
        top = bb_extract.y1
    with open(QUOKKA_ANNOTATIONS_FP, "r") as f:
        json_dict = json.load(f)
    bbs = []
    for bb_dict in json_dict["bounding_boxes"]:
        bbs.append(
            BoundingBox(
                x1=bb_dict["x1"] - left,
                y1=bb_dict["y1"] - top,
                x2=bb_dict["x2"] - left,
                y2=bb_dict["y2"] - top
            )
        )
    if extract is not None:
        shape = (bb_extract.height, bb_extract.width, 3)
    else:
        shape = (643, 960, 3)
    bbsoi = BoundingBoxesOnImage(bbs, shape=shape)
    if size is not None:
        shape_resized = _compute_resized_shape(shape, size)
        bbsoi = bbsoi.on(shape_resized)
    return bbsoi


</source>
</class>

<class classid="11" nclones="2" nlines="11" similarity="100">
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect.py" startline="107" endline="123" pcid="288">
    def __init__(self, type, point, segment, slope):
        assert(isinstance(point, tuple))
        self.type = type
        self.point = point
        self.segment = segment

        # will be None for INTERSECTION
        self.slope = slope
        if segment is not None:
            self.span = segment[1][X] - segment[0][X]

        if USE_DEBUG:
            self.other = None
            self.in_sweep = False

    # note that this isn't essential,
    # it just avoids non-deterministic ordering, see #9.
</source>
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect_py2py3.py" startline="107" endline="123" pcid="363">
    def __init__(self, type, point, segment, slope):
        assert(isinstance(point, tuple))
        self.type = type
        self.point = point
        self.segment = segment

        # will be None for INTERSECTION
        self.slope = slope
        if segment is not None:
            self.span = segment[1][X] - segment[0][X]

        if USE_DEBUG:
            self.other = None
            self.in_sweep = False

    # note that this isn't essential,
    # it just avoids non-deterministic ordering, see #9.
</source>
</class>

<class classid="12" nclones="2" nlines="18" similarity="94">
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect.py" startline="131" endline="154" pcid="291">
    def y_intercept_x(self, x: Real):
        # vertical events only for comparison (above_all check)
        # never added into the binary-tree its self
        if USE_VERTICAL:
            if self.is_vertical():
                return None

        if x <= self.segment[0][X]:
            return self.segment[0][Y]
        elif x >= self.segment[1][X]:
            return self.segment[1][Y]

        # use the largest to avoid float precision error with nearly vertical lines.
        delta_x0 = x - self.segment[0][X]
        delta_x1 = self.segment[1][X] - x
        if delta_x0 > delta_x1:
            ifac = delta_x0 / self.span
            fac = NUM_ONE - ifac
        else:
            fac = delta_x1 / self.span
            ifac = NUM_ONE - fac
        assert(fac <= NUM_ONE)
        return (self.segment[0][Y] * fac) + (self.segment[1][Y] * ifac)

</source>
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect_py2py3.py" startline="131" endline="154" pcid="366">
    def y_intercept_x(self, x):
        # vertical events only for comparison (above_all check)
        # never added into the binary-tree its self
        if USE_VERTICAL:
            if self.is_vertical():
                return None

        if x <= self.segment[0][X]:
            return self.segment[0][Y]
        elif x >= self.segment[1][X]:
            return self.segment[1][Y]

        # use the largest to avoid float precision error with nearly vertical lines.
        delta_x0 = x - self.segment[0][X]
        delta_x1 = self.segment[1][X] - x
        if delta_x0 > delta_x1:
            ifac = delta_x0 / self.span
            fac = NUM_ONE - ifac
        else:
            fac = delta_x1 / self.span
            ifac = NUM_ONE - fac
        assert(fac <= NUM_ONE)
        return (self.segment[0][Y] * fac) + (self.segment[1][Y] * ifac)

</source>
</class>

<class classid="13" nclones="2" nlines="33" similarity="100">
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect.py" startline="156" endline="198" pcid="292">
    def Compare(sweep_line, this, that):
        if this is that:
            return 0
        if USE_DEBUG:
            if this.other is that:
                return 0
        current_point_x = sweep_line._current_event_point_x
        this_y = this.y_intercept_x(current_point_x)
        that_y = that.y_intercept_x(current_point_x)
        # print(this_y, that_y)
        if USE_VERTICAL:
            if this_y is None:
                this_y = this.point[Y]
            if that_y is None:
                that_y = that.point[Y]

        delta_y = this_y - that_y

        assert((delta_y < NUM_ZERO) == (this_y < that_y))
        # NOTE, VERY IMPORTANT TO USE EPSILON HERE!
        # otherwise w/ float precision errors we get incorrect comparisons
        # can get very strange & hard to debug output without this.
        if abs(delta_y) > NUM_EPS:
            return -1 if (delta_y < NUM_ZERO) else 1
        else:
            this_slope = this.slope
            that_slope = that.slope
            if this_slope != that_slope:
                if sweep_line._before:
                    return -1 if (this_slope > that_slope) else 1
                else:
                    return 1 if (this_slope > that_slope) else -1

        delta_x_p1 = this.segment[0][X] - that.segment[0][X]
        if delta_x_p1 != NUM_ZERO:
            return -1 if (delta_x_p1 < NUM_ZERO) else 1

        delta_x_p2 = this.segment[1][X] - that.segment[1][X]
        if delta_x_p2 != NUM_ZERO:
            return -1 if (delta_x_p2 < NUM_ZERO) else 1

        return 0

</source>
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect_py2py3.py" startline="156" endline="198" pcid="367">
    def Compare(sweep_line, this, that):
        if this is that:
            return 0
        if USE_DEBUG:
            if this.other is that:
                return 0
        current_point_x = sweep_line._current_event_point_x
        this_y = this.y_intercept_x(current_point_x)
        that_y = that.y_intercept_x(current_point_x)
        # print(this_y, that_y)
        if USE_VERTICAL:
            if this_y is None:
                this_y = this.point[Y]
            if that_y is None:
                that_y = that.point[Y]

        delta_y = this_y - that_y

        assert((delta_y < NUM_ZERO) == (this_y < that_y))
        # NOTE, VERY IMPORTANT TO USE EPSILON HERE!
        # otherwise w/ float precision errors we get incorrect comparisons
        # can get very strange & hard to debug output without this.
        if abs(delta_y) > NUM_EPS:
            return -1 if (delta_y < NUM_ZERO) else 1
        else:
            this_slope = this.slope
            that_slope = that.slope
            if this_slope != that_slope:
                if sweep_line._before:
                    return -1 if (this_slope > that_slope) else 1
                else:
                    return 1 if (this_slope > that_slope) else -1

        delta_x_p1 = this.segment[0][X] - that.segment[0][X]
        if delta_x_p1 != NUM_ZERO:
            return -1 if (delta_x_p1 < NUM_ZERO) else 1

        delta_x_p2 = this.segment[1][X] - that.segment[1][X]
        if delta_x_p2 != NUM_ZERO:
            return -1 if (delta_x_p2 < NUM_ZERO) else 1

        return 0

</source>
</class>

<class classid="14" nclones="2" nlines="13" similarity="100">
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect.py" startline="247" endline="268" pcid="296">
    def get_intersections_with_segments(self):
        """
        Return a list of unordered intersection '(point, segment)' pairs,
        where segments may contain 2 or more values.
        """
        if Real is float:
            return [
                (p, [event.segment for event in event_set])
                for p, event_set in self.intersections.items()
            ]
        else:
            return [
                (
                    (float(p[0]), float(p[1])),
                    [((float(event.segment[0][0]), float(event.segment[0][1])),
                      (float(event.segment[1][0]), float(event.segment[1][1])))
                     for event in event_set],
                )
                for p, event_set in self.intersections.items()
            ]

    # Checks if an intersection exists between two Events 'a' and 'b'.
</source>
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect_py2py3.py" startline="247" endline="268" pcid="371">
    def get_intersections_with_segments(self):
        """
        Return a list of unordered intersection '(point, segment)' pairs,
        where segments may contain 2 or more values.
        """
        if Real is float:
            return [
                (p, [event.segment for event in event_set])
                for p, event_set in self.intersections.items()
            ]
        else:
            return [
                (
                    (float(p[0]), float(p[1])),
                    [((float(event.segment[0][0]), float(event.segment[0][1])),
                      (float(event.segment[1][0]), float(event.segment[1][1])))
                     for event in event_set],
                )
                for p, event_set in self.intersections.items()
            ]

    # Checks if an intersection exists between two Events 'a' and 'b'.
</source>
</class>

<class classid="15" nclones="2" nlines="26" similarity="96">
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect.py" startline="269" endline="314" pcid="297">
    def _check_intersection(self, a: Event, b: Event):
        # Return immediately in case either of the events is null, or
        # if one of them is an INTERSECTION event.
        if ((a is None or b is None) or
                (a.type == Event.Type.INTERSECTION) or
                (b.type == Event.Type.INTERSECTION)):

            return

        if a is b:
            return

        # Get the intersection point between 'a' and 'b'.
        p = isect_seg_seg_v2_point(
                a.segment[0], a.segment[1],
                b.segment[0], b.segment[1])

        # No intersection exists.
        if p is None:
            return

        # If the intersection is formed by both the segment endings, AND
        # USE_IGNORE_SEGMENT_ENDINGS is true,
        # return from this method.
        if USE_IGNORE_SEGMENT_ENDINGS:
            if ((len_squared_v2v2(p, a.segment[0]) < NUM_EPS_SQ or
                 len_squared_v2v2(p, a.segment[1]) < NUM_EPS_SQ) and
                (len_squared_v2v2(p, b.segment[0]) < NUM_EPS_SQ or
                 len_squared_v2v2(p, b.segment[1]) < NUM_EPS_SQ)):

                return

        # Add the intersection.
        events_for_point = self.intersections.pop(p, set())
        is_new = len(events_for_point) == 0
        events_for_point.add(a)
        events_for_point.add(b)
        self.intersections[p] = events_for_point

        # If the intersection occurs to the right of the sweep line, OR
        # if the intersection is on the sweep line and it's above the
        # current event-point, add it as a new Event to the queue.
        if is_new and p[X] >= self._current_event_point_x:
            event_isect = Event(Event.Type.INTERSECTION, p, None, None)
            self.queue.offer(p, event_isect)

</source>
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect_py2py3.py" startline="269" endline="314" pcid="372">
    def _check_intersection(self, a, b):
        # Return immediately in case either of the events is null, or
        # if one of them is an INTERSECTION event.
        if ((a is None or b is None) or
                (a.type == Event.Type.INTERSECTION) or
                (b.type == Event.Type.INTERSECTION)):

            return

        if a is b:
            return

        # Get the intersection point between 'a' and 'b'.
        p = isect_seg_seg_v2_point(
                a.segment[0], a.segment[1],
                b.segment[0], b.segment[1])

        # No intersection exists.
        if p is None:
            return

        # If the intersection is formed by both the segment endings, AND
        # USE_IGNORE_SEGMENT_ENDINGS is true,
        # return from this method.
        if USE_IGNORE_SEGMENT_ENDINGS:
            if ((len_squared_v2v2(p, a.segment[0]) < NUM_EPS_SQ or
                 len_squared_v2v2(p, a.segment[1]) < NUM_EPS_SQ) and
                (len_squared_v2v2(p, b.segment[0]) < NUM_EPS_SQ or
                 len_squared_v2v2(p, b.segment[1]) < NUM_EPS_SQ)):

                return

        # Add the intersection.
        events_for_point = self.intersections.pop(p, set())
        is_new = len(events_for_point) == 0
        events_for_point.add(a)
        events_for_point.add(b)
        self.intersections[p] = events_for_point

        # If the intersection occurs to the right of the sweep line, OR
        # if the intersection is on the sweep line and it's above the
        # current event-point, add it as a new Event to the queue.
        if is_new and p[X] >= self._current_event_point_x:
            event_isect = Event(Event.Type.INTERSECTION, p, None, None)
            self.queue.offer(p, event_isect)

</source>
</class>

<class classid="16" nclones="2" nlines="10" similarity="100">
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect.py" startline="323" endline="335" pcid="299">
    def insert(self, event):
        assert(event not in self._events_current_sweep)
        assert(not USE_VERTICAL or event.type != Event.Type.START_VERTICAL)
        if USE_DEBUG:
            assert(event.in_sweep == False)
            assert(event.other.in_sweep == False)

        self._events_current_sweep.insert(event, None)

        if USE_DEBUG:
            event.in_sweep = True
            event.other.in_sweep = True

</source>
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect_py2py3.py" startline="323" endline="335" pcid="374">
    def insert(self, event):
        assert(event not in self._events_current_sweep)
        assert(not USE_VERTICAL or event.type != Event.Type.START_VERTICAL)
        if USE_DEBUG:
            assert(event.in_sweep == False)
            assert(event.other.in_sweep == False)

        self._events_current_sweep.insert(event, None)

        if USE_DEBUG:
            event.in_sweep = True
            event.other.in_sweep = True

</source>
</class>

<class classid="17" nclones="2" nlines="14" similarity="100">
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect.py" startline="336" endline="350" pcid="300">
    def remove(self, event):
        try:
            self._events_current_sweep.remove(event)
            if USE_DEBUG:
                assert(event.in_sweep == True)
                assert(event.other.in_sweep == True)
                event.in_sweep = False
                event.other.in_sweep = False
            return True
        except KeyError:
            if USE_DEBUG:
                assert(event.in_sweep == False)
                assert(event.other.in_sweep == False)
            return False

</source>
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect_py2py3.py" startline="336" endline="350" pcid="375">
    def remove(self, event):
        try:
            self._events_current_sweep.remove(event)
            if USE_DEBUG:
                assert(event.in_sweep == True)
                assert(event.other.in_sweep == True)
                event.in_sweep = False
                event.other.in_sweep = False
            return True
        except KeyError:
            if USE_DEBUG:
                assert(event.in_sweep == False)
                assert(event.other.in_sweep == False)
            return False

</source>
</class>

<class classid="18" nclones="2" nlines="12" similarity="100">
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect.py" startline="370" endline="386" pcid="304">
    def handle(self, p, events_current):
        if len(events_current) == 0:
            return
        # done already
        # self._sweep_to(events_current[0])
        assert(p[0] == self._current_event_point_x)

        if not USE_IGNORE_SEGMENT_ENDINGS:
            if len(events_current) > 1:
                for i in range(0, len(events_current) - 1):
                    for j in range(i + 1, len(events_current)):
                        self._check_intersection(
                                events_current[i], events_current[j])

        for e in events_current:
            self.handle_event(e)

</source>
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect_py2py3.py" startline="370" endline="386" pcid="379">
    def handle(self, p, events_current):
        if len(events_current) == 0:
            return
        # done already
        # self._sweep_to(events_current[0])
        assert(p[0] == self._current_event_point_x)

        if not USE_IGNORE_SEGMENT_ENDINGS:
            if len(events_current) > 1:
                for i in range(0, len(events_current) - 1):
                    for j in range(i + 1, len(events_current)):
                        self._check_intersection(
                                events_current[i], events_current[j])

        for e in events_current:
            self.handle_event(e)

</source>
</class>

<class classid="19" nclones="2" nlines="54" similarity="100">
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect.py" startline="387" endline="474" pcid="305">
    def handle_event(self, event):
        t = event.type
        if t == Event.Type.START:
            # print("  START")
            self._before = False
            self.insert(event)

            e_above = self.above(event)
            e_below = self.below(event)

            self._check_intersection(event, e_above)
            self._check_intersection(event, e_below)
            if USE_PARANOID:
                self._check_intersection(e_above, e_below)

        elif t == Event.Type.END:
            # print("  END")
            self._before = True

            e_above = self.above(event)
            e_below = self.below(event)

            self.remove(event)

            self._check_intersection(e_above, e_below)
            if USE_PARANOID:
                self._check_intersection(event, e_above)
                self._check_intersection(event, e_below)

        elif t == Event.Type.INTERSECTION:
            # print("  INTERSECTION")
            self._before = True
            event_set = self.intersections[event.point]
            # note: events_current aren't sorted.
            reinsert_stack = []  # Stack
            for e in event_set:
                # Since we know the Event wasn't already removed,
                # we want to insert it later on.
                if self.remove(e):
                    reinsert_stack.append(e)
            self._before = False

            # Insert all Events that we were able to remove.
            while reinsert_stack:
                e = reinsert_stack.pop()

                self.insert(e)

                e_above = self.above(e)
                e_below = self.below(e)

                self._check_intersection(e, e_above)
                self._check_intersection(e, e_below)
                if USE_PARANOID:
                    self._check_intersection(e_above, e_below)
        elif (USE_VERTICAL and
                (t == Event.Type.START_VERTICAL)):

            # just check sanity
            assert(event.segment[0][X] == event.segment[1][X])
            assert(event.segment[0][Y] <= event.segment[1][Y])

            # In this case we only need to find all segments in this span.
            y_above_max = event.segment[1][Y]

            # self.insert(event)
            for e_above in self.above_all(event):
                if e_above.type == Event.Type.START_VERTICAL:
                    continue
                y_above = e_above.y_intercept_x(
                        self._current_event_point_x)
                if USE_IGNORE_SEGMENT_ENDINGS:
                    if y_above >= y_above_max - NUM_EPS:
                        break
                else:
                    if y_above > y_above_max:
                        break

                # We know this intersects,
                # so we could use a faster function now:
                # ix = (self._current_event_point_x, y_above)
                # ...however best use existing functions
                # since it does all sanity checks on endpoints... etc.
                self._check_intersection(event, e_above)

            # self.remove(event)


</source>
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect_py2py3.py" startline="387" endline="474" pcid="380">
    def handle_event(self, event):
        t = event.type
        if t == Event.Type.START:
            # print("  START")
            self._before = False
            self.insert(event)

            e_above = self.above(event)
            e_below = self.below(event)

            self._check_intersection(event, e_above)
            self._check_intersection(event, e_below)
            if USE_PARANOID:
                self._check_intersection(e_above, e_below)

        elif t == Event.Type.END:
            # print("  END")
            self._before = True

            e_above = self.above(event)
            e_below = self.below(event)

            self.remove(event)

            self._check_intersection(e_above, e_below)
            if USE_PARANOID:
                self._check_intersection(event, e_above)
                self._check_intersection(event, e_below)

        elif t == Event.Type.INTERSECTION:
            # print("  INTERSECTION")
            self._before = True
            event_set = self.intersections[event.point]
            # note: events_current aren't sorted.
            reinsert_stack = []  # Stack
            for e in event_set:
                # Since we know the Event wasn't already removed,
                # we want to insert it later on.
                if self.remove(e):
                    reinsert_stack.append(e)
            self._before = False

            # Insert all Events that we were able to remove.
            while reinsert_stack:
                e = reinsert_stack.pop()

                self.insert(e)

                e_above = self.above(e)
                e_below = self.below(e)

                self._check_intersection(e, e_above)
                self._check_intersection(e, e_below)
                if USE_PARANOID:
                    self._check_intersection(e_above, e_below)
        elif (USE_VERTICAL and
                (t == Event.Type.START_VERTICAL)):

            # just check sanity
            assert(event.segment[0][X] == event.segment[1][X])
            assert(event.segment[0][Y] <= event.segment[1][Y])

            # In this case we only need to find all segments in this span.
            y_above_max = event.segment[1][Y]

            # self.insert(event)
            for e_above in self.above_all(event):
                if e_above.type == Event.Type.START_VERTICAL:
                    continue
                y_above = e_above.y_intercept_x(
                        self._current_event_point_x)
                if USE_IGNORE_SEGMENT_ENDINGS:
                    if y_above >= y_above_max - NUM_EPS:
                        break
                else:
                    if y_above > y_above_max:
                        break

                # We know this intersects,
                # so we could use a faster function now:
                # ix = (self._current_event_point_x, y_above)
                # ...however best use existing functions
                # since it does all sanity checks on endpoints... etc.
                self._check_intersection(event, e_above)

            # self.remove(event)


</source>
</class>

<class classid="20" nclones="2" nlines="21" similarity="95">
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect.py" startline="483" endline="513" pcid="306">
    def __init__(self, segments, line: SweepLine):
        self.events_scan = RBTree()
        # segments = [s for s in segments if s[0][0] != s[1][0] and s[0][1] != s[1][1]]

        for s in segments:
            assert(s[0][X] <= s[1][X])

            slope = slope_v2v2(*s)

            if s[0] == s[1]:
                pass
            elif USE_VERTICAL and (s[0][X] == s[1][X]):
                e_start = Event(Event.Type.START_VERTICAL, s[0], s, slope)

                if USE_DEBUG:
                    e_start.other = e_start  # FAKE, avoid error checking

                self.offer(s[0], e_start)
            else:
                e_start = Event(Event.Type.START, s[0], s, slope)
                e_end   = Event(Event.Type.END,   s[1], s, slope)

                if USE_DEBUG:
                    e_start.other = e_end
                    e_end.other = e_start

                self.offer(s[0], e_start)
                self.offer(s[1], e_end)

        line.queue = self

</source>
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect_py2py3.py" startline="483" endline="513" pcid="381">
    def __init__(self, segments, line):
        self.events_scan = RBTree()
        # segments = [s for s in segments if s[0][0] != s[1][0] and s[0][1] != s[1][1]]

        for s in segments:
            assert(s[0][X] <= s[1][X])

            slope = slope_v2v2(*s)

            if s[0] == s[1]:
                pass
            elif USE_VERTICAL and (s[0][X] == s[1][X]):
                e_start = Event(Event.Type.START_VERTICAL, s[0], s, slope)

                if USE_DEBUG:
                    e_start.other = e_start  # FAKE, avoid error checking

                self.offer(s[0], e_start)
            else:
                e_start = Event(Event.Type.START, s[0], s, slope)
                e_end   = Event(Event.Type.END,   s[1], s, slope)

                if USE_DEBUG:
                    e_start.other = e_end
                    e_end.other = e_start

                self.offer(s[0], e_start)
                self.offer(s[1], e_end)

        line.queue = self

</source>
</class>

<class classid="21" nclones="2" nlines="29" similarity="96">
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect.py" startline="544" endline="584" pcid="309">
def isect_segments_impl(segments, include_segments=False) -> list:
    # order points left -> right
    if Real is float:
        segments = [
            # in nearly all cases, comparing X is enough,
            # but compare Y too for vertical lines
            (s[0], s[1]) if (s[0] <= s[1]) else
            (s[1], s[0])
            for s in segments]
    else:
        segments = [
            # in nearly all cases, comparing X is enough,
            # but compare Y too for vertical lines
            (
                (Real(s[0][0]), Real(s[0][1])),
                (Real(s[1][0]), Real(s[1][1])),
            ) if (s[0] <= s[1]) else
            (
                (Real(s[1][0]), Real(s[1][1])),
                (Real(s[0][0]), Real(s[0][1])),
            )
            for s in segments]

    sweep_line = SweepLine()
    queue = EventQueue(segments, sweep_line)

    while len(queue.events_scan) > 0:
        if USE_VERBOSE:
            print(len(queue.events_scan), sweep_line._current_event_point_x)
        p, e_ls = queue.poll()
        for events_current in e_ls:
            if events_current:
                sweep_line._sweep_to(p)
                sweep_line.handle(p, events_current)

    if include_segments is False:
        return sweep_line.get_intersections()
    else:
        return sweep_line.get_intersections_with_segments()


</source>
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect_py2py3.py" startline="544" endline="584" pcid="384">
def isect_segments_impl(segments, include_segments=False):
    # order points left -> right
    if Real is float:
        segments = [
            # in nearly all cases, comparing X is enough,
            # but compare Y too for vertical lines
            (s[0], s[1]) if (s[0] <= s[1]) else
            (s[1], s[0])
            for s in segments]
    else:
        segments = [
            # in nearly all cases, comparing X is enough,
            # but compare Y too for vertical lines
            (
                (Real(s[0][0]), Real(s[0][1])),
                (Real(s[1][0]), Real(s[1][1])),
            ) if (s[0] <= s[1]) else
            (
                (Real(s[1][0]), Real(s[1][1])),
                (Real(s[0][0]), Real(s[0][1])),
            )
            for s in segments]

    sweep_line = SweepLine()
    queue = EventQueue(segments, sweep_line)

    while len(queue.events_scan) > 0:
        if USE_VERBOSE:
            print(len(queue.events_scan), sweep_line._current_event_point_x)
        p, e_ls = queue.poll()
        for events_current in e_ls:
            if events_current:
                sweep_line._sweep_to(p)
                sweep_line.handle(p, events_current)

    if include_segments is False:
        return sweep_line.get_intersections()
    else:
        return sweep_line.get_intersections_with_segments()


</source>
</class>

<class classid="22" nclones="2" nlines="24" similarity="100">
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect.py" startline="647" endline="684" pcid="320">
def isect_seg_seg_v2_point(v1, v2, v3, v4, bias=NUM_ZERO):
    # Only for predictability and hashable point when same input is given
    if v1 > v2:
        v1, v2 = v2, v1
    if v3 > v4:
        v3, v4 = v4, v3

    if (v1, v2) > (v3, v4):
        v1, v2, v3, v4 = v3, v4, v1, v2

    div = (v2[0] - v1[0]) * (v4[1] - v3[1]) - (v2[1] - v1[1]) * (v4[0] - v3[0])
    if div == NUM_ZERO:
        return None

    vi = (((v3[0] - v4[0]) *
           (v1[0] * v2[1] - v1[1] * v2[0]) - (v1[0] - v2[0]) *
           (v3[0] * v4[1] - v3[1] * v4[0])) / div,
          ((v3[1] - v4[1]) *
           (v1[0] * v2[1] - v1[1] * v2[0]) - (v1[1] - v2[1]) *
           (v3[0] * v4[1] - v3[1] * v4[0])) / div,
          )

    fac = line_point_factor_v2(vi, v1, v2, default=-NUM_ONE)
    if fac < NUM_ZERO - bias or fac > NUM_ONE + bias:
        return None

    fac = line_point_factor_v2(vi, v3, v4, default=-NUM_ONE)
    if fac < NUM_ZERO - bias or fac > NUM_ONE + bias:
        return None

    # vi = round(vi[X], 8), round(vi[Y], 8)
    return vi


# ----------------------------------------------------------------------------
# Simple naive line intersect, (for testing only)


</source>
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect_py2py3.py" startline="647" endline="684" pcid="395">
def isect_seg_seg_v2_point(v1, v2, v3, v4, bias=NUM_ZERO):
    # Only for predictability and hashable point when same input is given
    if v1 > v2:
        v1, v2 = v2, v1
    if v3 > v4:
        v3, v4 = v4, v3

    if (v1, v2) > (v3, v4):
        v1, v2, v3, v4 = v3, v4, v1, v2

    div = (v2[0] - v1[0]) * (v4[1] - v3[1]) - (v2[1] - v1[1]) * (v4[0] - v3[0])
    if div == NUM_ZERO:
        return None

    vi = (((v3[0] - v4[0]) *
           (v1[0] * v2[1] - v1[1] * v2[0]) - (v1[0] - v2[0]) *
           (v3[0] * v4[1] - v3[1] * v4[0])) / div,
          ((v3[1] - v4[1]) *
           (v1[0] * v2[1] - v1[1] * v2[0]) - (v1[1] - v2[1]) *
           (v3[0] * v4[1] - v3[1] * v4[0])) / div,
          )

    fac = line_point_factor_v2(vi, v1, v2, default=-NUM_ONE)
    if fac < NUM_ZERO - bias or fac > NUM_ONE + bias:
        return None

    fac = line_point_factor_v2(vi, v3, v4, default=-NUM_ONE)
    if fac < NUM_ZERO - bias or fac > NUM_ONE + bias:
        return None

    # vi = round(vi[X], 8), round(vi[Y], 8)
    return vi


# ----------------------------------------------------------------------------
# Simple naive line intersect, (for testing only)


</source>
</class>

<class classid="23" nclones="2" nlines="26" similarity="96">
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect.py" startline="685" endline="723" pcid="321">
def isect_segments__naive(segments) -> list:
    """
    Brute force O(n2) version of ``isect_segments`` for test validation.
    """
    isect = []

    # order points left -> right
    if Real is float:
        segments = [
            (s[0], s[1]) if s[0][X] <= s[1][X] else
            (s[1], s[0])
            for s in segments]
    else:
        segments = [
            (
                (Real(s[0][0]), Real(s[0][1])),
                (Real(s[1][0]), Real(s[1][1])),
            ) if (s[0] <= s[1]) else
            (
                (Real(s[1][0]), Real(s[1][1])),
                (Real(s[0][0]), Real(s[0][1])),
            )
            for s in segments]

    n = len(segments)

    for i in range(n):
        a0, a1 = segments[i]
        for j in range(i + 1, n):
            b0, b1 = segments[j]
            if a0 not in (b0, b1) and a1 not in (b0, b1):
                ix = isect_seg_seg_v2_point(a0, a1, b0, b1)
                if ix is not None:
                    # USE_IGNORE_SEGMENT_ENDINGS handled already
                    isect.append(ix)

    return isect


</source>
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect_py2py3.py" startline="685" endline="723" pcid="396">
def isect_segments__naive(segments):
    """
    Brute force O(n2) version of ``isect_segments`` for test validation.
    """
    isect = []

    # order points left -> right
    if Real is float:
        segments = [
            (s[0], s[1]) if s[0][X] <= s[1][X] else
            (s[1], s[0])
            for s in segments]
    else:
        segments = [
            (
                (Real(s[0][0]), Real(s[0][1])),
                (Real(s[1][0]), Real(s[1][1])),
            ) if (s[0] <= s[1]) else
            (
                (Real(s[1][0]), Real(s[1][1])),
                (Real(s[0][0]), Real(s[0][1])),
            )
            for s in segments]

    n = len(segments)

    for i in range(n):
        a0, a1 = segments[i]
        for j in range(i + 1, n):
            b0, b1 = segments[j]
            if a0 not in (b0, b1) and a1 not in (b0, b1):
                ix = isect_seg_seg_v2_point(a0, a1, b0, b1)
                if ix is not None:
                    # USE_IGNORE_SEGMENT_ENDINGS handled already
                    isect.append(ix)

    return isect


</source>
</class>

<class classid="24" nclones="2" nlines="22" similarity="95">
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect.py" startline="724" endline="773" pcid="322">
def isect_polygon__naive(points) -> list:
    """
    Brute force O(n2) version of ``isect_polygon`` for test validation.
    """
    isect = []

    n = len(points)

    if Real is float:
        pass
    else:
        points = [(Real(p[0]), Real(p[1])) for p in points]


    for i in range(n):
        a0, a1 = points[i], points[(i + 1) % n]
        for j in range(i + 1, n):
            b0, b1 = points[j], points[(j + 1) % n]
            if a0 not in (b0, b1) and a1 not in (b0, b1):
                ix = isect_seg_seg_v2_point(a0, a1, b0, b1)
                if ix is not None:

                    if USE_IGNORE_SEGMENT_ENDINGS:
                        if ((len_squared_v2v2(ix, a0) < NUM_EPS_SQ or
                             len_squared_v2v2(ix, a1) < NUM_EPS_SQ) and
                            (len_squared_v2v2(ix, b0) < NUM_EPS_SQ or
                             len_squared_v2v2(ix, b1) < NUM_EPS_SQ)):
                            continue

                    isect.append(ix)

    return isect


# ----------------------------------------------------------------------------
# Inline Libs
#
# bintrees: 2.0.2, extracted from:
# http://pypi.python.org/pypi/bintrees
#
# - Removed unused functions, such as slicing and range iteration.
# - Added 'cmp' and and 'cmp_data' arguments,
#   so we can define our own comparison that takes an arg.
#   Needed for sweep-line.
# - Added support for 'default' arguments for prev_item/succ_item,
#   so we can avoid exception handling.

# -------
# ABCTree

</source>
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect_py2py3.py" startline="724" endline="773" pcid="397">
def isect_polygon__naive(points):
    """
    Brute force O(n2) version of ``isect_polygon`` for test validation.
    """
    isect = []

    n = len(points)

    if Real is float:
        pass
    else:
        points = [(Real(p[0]), Real(p[1])) for p in points]


    for i in range(n):
        a0, a1 = points[i], points[(i + 1) % n]
        for j in range(i + 1, n):
            b0, b1 = points[j], points[(j + 1) % n]
            if a0 not in (b0, b1) and a1 not in (b0, b1):
                ix = isect_seg_seg_v2_point(a0, a1, b0, b1)
                if ix is not None:

                    if USE_IGNORE_SEGMENT_ENDINGS:
                        if ((len_squared_v2v2(ix, a0) < NUM_EPS_SQ or
                             len_squared_v2v2(ix, a1) < NUM_EPS_SQ) and
                            (len_squared_v2v2(ix, b0) < NUM_EPS_SQ or
                             len_squared_v2v2(ix, b1) < NUM_EPS_SQ)):
                            continue

                    isect.append(ix)

    return isect


# ----------------------------------------------------------------------------
# Inline Libs
#
# bintrees: 2.0.2, extracted from:
# http://pypi.python.org/pypi/bintrees
#
# - Removed unused functions, such as slicing and range iteration.
# - Added 'cmp' and and 'cmp_data' arguments,
#   so we can define our own comparison that takes an arg.
#   Needed for sweep-line.
# - Added support for 'default' arguments for prev_item/succ_item,
#   so we can avoid exception handling.

# -------
# ABCTree

</source>
</class>

<class classid="25" nclones="2" nlines="15" similarity="100">
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect.py" startline="779" endline="795" pcid="323">
    def __init__(self, items=None, cmp=None, cmp_data=None):
        """T.__init__(...) initializes T; see T.__class__.__doc__ for signature"""
        self._root = None
        self._count = 0
        if cmp is None:
            def cmp(cmp_data, a, b):
                if a < b:
                    return -1
                elif a > b:
                    return 1
                else:
                    return 0
        self._cmp = cmp
        self._cmp_data = cmp_data
        if items is not None:
            self.update(items)

</source>
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect_py2py3.py" startline="779" endline="795" pcid="398">
    def __init__(self, items=None, cmp=None, cmp_data=None):
        """T.__init__(...) initializes T; see T.__class__.__doc__ for signature"""
        self._root = None
        self._count = 0
        if cmp is None:
            def cmp(cmp_data, a, b):
                if a < b:
                    return -1
                elif a > b:
                    return 1
                else:
                    return 0
        self._cmp = cmp
        self._cmp_data = cmp_data
        if items is not None:
            self.update(items)

</source>
</class>

<class classid="26" nclones="2" nlines="11" similarity="100">
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect.py" startline="812" endline="823" pcid="328">
    def get_value(self, key):
        node = self._root
        while node is not None:
            cmp = self._cmp(self._cmp_data, key, node.key)
            if cmp == 0:
                return node.value
            elif cmp < 0:
                node = node.left
            else:
                node = node.right
        raise KeyError(str(key))

</source>
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect_py2py3.py" startline="812" endline="823" pcid="403">
    def get_value(self, key):
        node = self._root
        while node is not None:
            cmp = self._cmp(self._cmp_data, key, node.key)
            if cmp == 0:
                return node.value
            elif cmp < 0:
                node = node.left
            else:
                node = node.right
        raise KeyError(str(key))

</source>
</class>

<class classid="27" nclones="2" nlines="15" similarity="100">
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect.py" startline="824" endline="841" pcid="329">
    def pop_item(self):
        """T.pop_item() -> (k, v), remove and return some (key, value) pair as a
        2-tuple; but raise KeyError if T is empty.
        """
        if self.is_empty():
            raise KeyError("pop_item(): tree is empty")
        node = self._root
        while True:
            if node.left is not None:
                node = node.left
            elif node.right is not None:
                node = node.right
            else:
                break
        key = node.key
        value = node.value
        self.remove(key)
        return key, value
</source>
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect_py2py3.py" startline="824" endline="841" pcid="404">
    def pop_item(self):
        """T.pop_item() -> (k, v), remove and return some (key, value) pair as a
        2-tuple; but raise KeyError if T is empty.
        """
        if self.is_empty():
            raise KeyError("pop_item(): tree is empty")
        node = self._root
        while True:
            if node.left is not None:
                node = node.left
            elif node.right is not None:
                node = node.right
            else:
                break
        key = node.key
        value = node.value
        self.remove(key)
        return key, value
</source>
</class>

<class classid="28" nclones="4" nlines="30" similarity="93">
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect.py" startline="862" endline="901" pcid="332">
    def succ_item(self, key, default=_sentinel):
        """Get successor (k,v) pair of key, raises KeyError if key is max key
        or key does not exist. optimized for pypy.
        """
        # removed graingets version, because it was little slower on CPython and much slower on pypy
        # this version runs about 4x faster with pypy than the Cython version
        # Note: Code sharing of succ_item() and ceiling_item() is possible, but has always a speed penalty.
        node = self._root
        succ_node = None
        while node is not None:
            cmp = self._cmp(self._cmp_data, key, node.key)
            if cmp == 0:
                break
            elif cmp < 0:
                if (succ_node is None) or self._cmp(self._cmp_data, node.key, succ_node.key) < 0:
                    succ_node = node
                node = node.left
            else:
                node = node.right

        if node is None:  # stay at dead end
            if default is _sentinel:
                raise KeyError(str(key))
            return default
        # found node of key
        if node.right is not None:
            # find smallest node of right subtree
            node = node.right
            while node.left is not None:
                node = node.left
            if succ_node is None:
                succ_node = node
            elif self._cmp(self._cmp_data, node.key, succ_node.key) < 0:
                succ_node = node
        elif succ_node is None:  # given key is biggest in tree
            if default is _sentinel:
                raise KeyError(str(key))
            return default
        return succ_node.key, succ_node.value

</source>
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect_py2py3.py" startline="862" endline="901" pcid="407">
    def succ_item(self, key, default=_sentinel):
        """Get successor (k,v) pair of key, raises KeyError if key is max key
        or key does not exist. optimized for pypy.
        """
        # removed graingets version, because it was little slower on CPython and much slower on pypy
        # this version runs about 4x faster with pypy than the Cython version
        # Note: Code sharing of succ_item() and ceiling_item() is possible, but has always a speed penalty.
        node = self._root
        succ_node = None
        while node is not None:
            cmp = self._cmp(self._cmp_data, key, node.key)
            if cmp == 0:
                break
            elif cmp < 0:
                if (succ_node is None) or self._cmp(self._cmp_data, node.key, succ_node.key) < 0:
                    succ_node = node
                node = node.left
            else:
                node = node.right

        if node is None:  # stay at dead end
            if default is _sentinel:
                raise KeyError(str(key))
            return default
        # found node of key
        if node.right is not None:
            # find smallest node of right subtree
            node = node.right
            while node.left is not None:
                node = node.left
            if succ_node is None:
                succ_node = node
            elif self._cmp(self._cmp_data, node.key, succ_node.key) < 0:
                succ_node = node
        elif succ_node is None:  # given key is biggest in tree
            if default is _sentinel:
                raise KeyError(str(key))
            return default
        return succ_node.key, succ_node.value

</source>
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect_py2py3.py" startline="902" endline="942" pcid="408">
    def prev_item(self, key, default=_sentinel):
        """Get predecessor (k,v) pair of key, raises KeyError if key is min key
        or key does not exist. optimized for pypy.
        """
        # removed graingets version, because it was little slower on CPython and much slower on pypy
        # this version runs about 4x faster with pypy than the Cython version
        # Note: Code sharing of prev_item() and floor_item() is possible, but has always a speed penalty.
        node = self._root
        prev_node = None

        while node is not None:
            cmp = self._cmp(self._cmp_data, key, node.key)
            if cmp == 0:
                break
            elif cmp < 0:
                node = node.left
            else:
                if (prev_node is None) or self._cmp(self._cmp_data, prev_node.key, node.key) < 0:
                    prev_node = node
                node = node.right

        if node is None:  # stay at dead end (None)
            if default is _sentinel:
                raise KeyError(str(key))
            return default
        # found node of key
        if node.left is not None:
            # find biggest node of left subtree
            node = node.left
            while node.right is not None:
                node = node.right
            if prev_node is None:
                prev_node = node
            elif self._cmp(self._cmp_data, prev_node.key, node.key) < 0:
                prev_node = node
        elif prev_node is None:  # given key is smallest in tree
            if default is _sentinel:
                raise KeyError(str(key))
            return default
        return prev_node.key, prev_node.value

</source>
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect.py" startline="902" endline="942" pcid="333">
    def prev_item(self, key, default=_sentinel):
        """Get predecessor (k,v) pair of key, raises KeyError if key is min key
        or key does not exist. optimized for pypy.
        """
        # removed graingets version, because it was little slower on CPython and much slower on pypy
        # this version runs about 4x faster with pypy than the Cython version
        # Note: Code sharing of prev_item() and floor_item() is possible, but has always a speed penalty.
        node = self._root
        prev_node = None

        while node is not None:
            cmp = self._cmp(self._cmp_data, key, node.key)
            if cmp == 0:
                break
            elif cmp < 0:
                node = node.left
            else:
                if (prev_node is None) or self._cmp(self._cmp_data, prev_node.key, node.key) < 0:
                    prev_node = node
                node = node.right

        if node is None:  # stay at dead end (None)
            if default is _sentinel:
                raise KeyError(str(key))
            return default
        # found node of key
        if node.left is not None:
            # find biggest node of left subtree
            node = node.left
            while node.right is not None:
                node = node.right
            if prev_node is None:
                prev_node = node
            elif self._cmp(self._cmp_data, prev_node.key, node.key) < 0:
                prev_node = node
        elif prev_node is None:  # given key is smallest in tree
            if default is _sentinel:
                raise KeyError(str(key))
            return default
        return prev_node.key, prev_node.value

</source>
</class>

<class classid="29" nclones="2" nlines="12" similarity="100">
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect.py" startline="980" endline="995" pcid="340">
    def pop(self, key, *args):
        """T.pop(k[,d]) -> v, remove specified key and return the corresponding value.
        If key is not found, d is returned if given, otherwise KeyError is raised
        """
        if len(args) > 1:
            raise TypeError("pop expected at most 2 arguments, got %d" % (1 + len(args)))
        try:
            value = self.get_value(key)
            self.remove(key)
            return value
        except KeyError:
            if len(args) == 0:
                raise
            else:
                return args[0]

</source>
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect_py2py3.py" startline="980" endline="995" pcid="415">
    def pop(self, key, *args):
        """T.pop(k[,d]) -> v, remove specified key and return the corresponding value.
        If key is not found, d is returned if given, otherwise KeyError is raised
        """
        if len(args) > 1:
            raise TypeError("pop expected at most 2 arguments, got %d" % (1 + len(args)))
        try:
            value = self.get_value(key)
            self.remove(key)
            return value
        except KeyError:
            if len(args) == 0:
                raise
            else:
                return args[0]

</source>
</class>

<class classid="30" nclones="2" nlines="20" similarity="100">
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect.py" startline="1065" endline="1086" pcid="351">
    def _iter_items(self, left=attrgetter("left"), right=attrgetter("right"), start_key=None, end_key=None):
        node = self._root
        stack = []
        go_left = True
        in_range = self._get_in_range_func(start_key, end_key)

        while True:
            if left(node) is not None and go_left:
                stack.append(node)
                node = left(node)
            else:
                if in_range(node.key):
                    yield node.key, node.value
                if right(node) is not None:
                    node = right(node)
                    go_left = True
                else:
                    if not len(stack):
                        return  # all done
                    node = stack.pop()
                    go_left = False

</source>
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect_py2py3.py" startline="1065" endline="1086" pcid="426">
    def _iter_items(self, left=attrgetter("left"), right=attrgetter("right"), start_key=None, end_key=None):
        node = self._root
        stack = []
        go_left = True
        in_range = self._get_in_range_func(start_key, end_key)

        while True:
            if left(node) is not None and go_left:
                stack.append(node)
                node = left(node)
            else:
                if in_range(node.key):
                    yield node.key, node.value
                if right(node) is not None:
                    node = right(node)
                    go_left = True
                else:
                    if not len(stack):
                        return  # all done
                    node = stack.pop()
                    go_left = False

</source>
</class>

<class classid="31" nclones="2" nlines="11" similarity="100">
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect.py" startline="1087" endline="1102" pcid="352">
    def _get_in_range_func(self, start_key, end_key):
        if start_key is None and end_key is None:
            return lambda x: True
        else:
            if start_key is None:
                start_key = self.min_key()
            if end_key is None:
                return (lambda x: self._cmp(self._cmp_data, start_key, x) <= 0)
            else:
                return (lambda x: self._cmp(self._cmp_data, start_key, x) <= 0 and
                        self._cmp(self._cmp_data, x, end_key) < 0)


# ------
# RBTree

</source>
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect_py2py3.py" startline="1087" endline="1102" pcid="427">
    def _get_in_range_func(self, start_key, end_key):
        if start_key is None and end_key is None:
            return lambda x: True
        else:
            if start_key is None:
                start_key = self.min_key()
            if end_key is None:
                return (lambda x: self._cmp(self._cmp_data, start_key, x) <= 0)
            else:
                return (lambda x: self._cmp(self._cmp_data, start_key, x) <= 0 and
                        self._cmp(self._cmp_data, x, end_key) < 0)


# ------
# RBTree

</source>
</class>

<class classid="32" nclones="2" nlines="39" similarity="100">
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect.py" startline="1166" endline="1217" pcid="361">
    def insert(self, key, value):
        """T.insert(key, value) <==> T[key] = value, insert key, value into tree."""
        if self._root is None:  # Empty tree case
            self._root = self._new_node(key, value)
            self._root.red = False  # make root black
            return

        head = Node()  # False tree root
        grand_parent = None
        grand_grand_parent = head
        parent = None  # parent
        direction = 0
        last = 0

        # Set up helpers
        grand_grand_parent.right = self._root
        node = grand_grand_parent.right
        # Search down the tree
        while True:
            if node is None:  # Insert new node at the bottom
                node = self._new_node(key, value)
                parent[direction] = node
            elif RBTree.is_red(node.left) and RBTree.is_red(node.right):  # Color flip
                node.red = True
                node.left.red = False
                node.right.red = False

            # Fix red violation
            if RBTree.is_red(node) and RBTree.is_red(parent):
                direction2 = 1 if grand_grand_parent.right is grand_parent else 0
                if node is parent[last]:
                    grand_grand_parent[direction2] = RBTree.jsw_single(grand_parent, 1 - last)
                else:
                    grand_grand_parent[direction2] = RBTree.jsw_double(grand_parent, 1 - last)

            # Stop if found
            if self._cmp(self._cmp_data, key, node.key) == 0:
                node.value = value  # set new value for key
                break

            last = direction
            direction = 0 if (self._cmp(self._cmp_data, key, node.key) < 0) else 1
            # Update helpers
            if grand_parent is not None:
                grand_grand_parent = grand_parent
            grand_parent = parent
            parent = node
            node = node[direction]

        self._root = head.right  # Update root
        self._root.red = False  # make root black

</source>
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect_py2py3.py" startline="1166" endline="1217" pcid="436">
    def insert(self, key, value):
        """T.insert(key, value) <==> T[key] = value, insert key, value into tree."""
        if self._root is None:  # Empty tree case
            self._root = self._new_node(key, value)
            self._root.red = False  # make root black
            return

        head = Node()  # False tree root
        grand_parent = None
        grand_grand_parent = head
        parent = None  # parent
        direction = 0
        last = 0

        # Set up helpers
        grand_grand_parent.right = self._root
        node = grand_grand_parent.right
        # Search down the tree
        while True:
            if node is None:  # Insert new node at the bottom
                node = self._new_node(key, value)
                parent[direction] = node
            elif RBTree.is_red(node.left) and RBTree.is_red(node.right):  # Color flip
                node.red = True
                node.left.red = False
                node.right.red = False

            # Fix red violation
            if RBTree.is_red(node) and RBTree.is_red(parent):
                direction2 = 1 if grand_grand_parent.right is grand_parent else 0
                if node is parent[last]:
                    grand_grand_parent[direction2] = RBTree.jsw_single(grand_parent, 1 - last)
                else:
                    grand_grand_parent[direction2] = RBTree.jsw_double(grand_parent, 1 - last)

            # Stop if found
            if self._cmp(self._cmp_data, key, node.key) == 0:
                node.value = value  # set new value for key
                break

            last = direction
            direction = 0 if (self._cmp(self._cmp_data, key, node.key) < 0) else 1
            # Update helpers
            if grand_parent is not None:
                grand_grand_parent = grand_parent
            grand_parent = parent
            parent = node
            node = node[direction]

        self._root = head.right  # Update root
        self._root.red = False  # make root black

</source>
</class>

<class classid="33" nclones="2" nlines="50" similarity="100">
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect.py" startline="1218" endline="1283" pcid="362">
    def remove(self, key):
        """T.remove(key) <==> del T[key], remove item <key> from tree."""
        if self._root is None:
            raise KeyError(str(key))
        head = Node()  # False tree root
        node = head
        node.right = self._root
        parent = None
        grand_parent = None
        found = None  # Found item
        direction = 1

        # Search and push a red down
        while node[direction] is not None:
            last = direction

            # Update helpers
            grand_parent = parent
            parent = node
            node = node[direction]

            direction = 1 if (self._cmp(self._cmp_data, node.key, key) < 0) else 0

            # Save found node
            if self._cmp(self._cmp_data, key, node.key) == 0:
                found = node

            # Push the red node down
            if not RBTree.is_red(node) and not RBTree.is_red(node[direction]):
                if RBTree.is_red(node[1 - direction]):
                    parent[last] = RBTree.jsw_single(node, direction)
                    parent = parent[last]
                elif not RBTree.is_red(node[1 - direction]):
                    sibling = parent[1 - last]
                    if sibling is not None:
                        if (not RBTree.is_red(sibling[1 - last])) and (not RBTree.is_red(sibling[last])):
                            # Color flip
                            parent.red = False
                            sibling.red = True
                            node.red = True
                        else:
                            direction2 = 1 if grand_parent.right is parent else 0
                            if RBTree.is_red(sibling[last]):
                                grand_parent[direction2] = RBTree.jsw_double(parent, last)
                            elif RBTree.is_red(sibling[1-last]):
                                grand_parent[direction2] = RBTree.jsw_single(parent, last)
                            # Ensure correct coloring
                            grand_parent[direction2].red = True
                            node.red = True
                            grand_parent[direction2].left.red = False
                            grand_parent[direction2].right.red = False

        # Replace and remove if found
        if found is not None:
            found.key = node.key
            found.value = node.value
            parent[int(parent.right is node)] = node[int(node.left is None)]
            node.free()
            self._count -= 1

        # Update root and make it black
        self._root = head.right
        if self._root is not None:
            self._root.red = False
        if not found:
            raise KeyError(str(key))
</source>
<source file="systems/imgaug-0.2.9/imgaug/external/poly_point_isect_py2py3.py" startline="1218" endline="1283" pcid="437">
    def remove(self, key):
        """T.remove(key) <==> del T[key], remove item <key> from tree."""
        if self._root is None:
            raise KeyError(str(key))
        head = Node()  # False tree root
        node = head
        node.right = self._root
        parent = None
        grand_parent = None
        found = None  # Found item
        direction = 1

        # Search and push a red down
        while node[direction] is not None:
            last = direction

            # Update helpers
            grand_parent = parent
            parent = node
            node = node[direction]

            direction = 1 if (self._cmp(self._cmp_data, node.key, key) < 0) else 0

            # Save found node
            if self._cmp(self._cmp_data, key, node.key) == 0:
                found = node

            # Push the red node down
            if not RBTree.is_red(node) and not RBTree.is_red(node[direction]):
                if RBTree.is_red(node[1 - direction]):
                    parent[last] = RBTree.jsw_single(node, direction)
                    parent = parent[last]
                elif not RBTree.is_red(node[1 - direction]):
                    sibling = parent[1 - last]
                    if sibling is not None:
                        if (not RBTree.is_red(sibling[1 - last])) and (not RBTree.is_red(sibling[last])):
                            # Color flip
                            parent.red = False
                            sibling.red = True
                            node.red = True
                        else:
                            direction2 = 1 if grand_parent.right is parent else 0
                            if RBTree.is_red(sibling[last]):
                                grand_parent[direction2] = RBTree.jsw_double(parent, last)
                            elif RBTree.is_red(sibling[1-last]):
                                grand_parent[direction2] = RBTree.jsw_single(parent, last)
                            # Ensure correct coloring
                            grand_parent[direction2].red = True
                            node.red = True
                            grand_parent[direction2].left.red = False
                            grand_parent[direction2].right.red = False

        # Replace and remove if found
        if found is not None:
            found.key = node.key
            found.value = node.value
            parent[int(parent.right is node)] = node[int(node.left is None)]
            node.free()
            self._count -= 1

        # Update root and make it black
        self._root = head.right
        if self._root is not None:
            self._root.red = False
        if not found:
            raise KeyError(str(key))
</source>
</class>

<class classid="34" nclones="2" nlines="18" similarity="72">
<source file="systems/imgaug-0.2.9/imgaug/augmentables/normalization.py" startline="66" endline="91" pcid="441">
def _assert_many_arrays_ndim(arrs, ndim, shape_str, to_ntype):
    # For polygons, this can be a list of lists of arrays, hence we must
    # flatten the lists here.
    # itertools.chain.from_iterable() seems to flatten the arrays too, so it
    # cannot be used here.
    iterable_type_str = "iterable"
    if len(arrs) == 0:
        arrs_flat = []
    elif ia.is_np_array(arrs[0]):
        arrs_flat = arrs
    else:
        iterable_type_str = "iterable of iterable"
        arrs_flat = [arr for arrs_sublist in arrs for arr in arrs_sublist]

    if any([arr.ndim != ndim for arr in arrs_flat]):
        raise ValueError(
            ("Tried to convert an %s of arrays to a list of "
             + "%s. Expected each array to be of shape %s, "
             + "i.e. to be %d-dimensional, but got dimensions %s "
             + "instead (array shapes: %s).") % (
                iterable_type_str, to_ntype, shape_str, ndim,
                ", ".join([str(arr.ndim) for arr in arrs_flat]),
                ", ".join([str(arr.shape) for arr in arrs_flat]))
        )


</source>
<source file="systems/imgaug-0.2.9/imgaug/augmentables/normalization.py" startline="102" endline="126" pcid="443">
def _assert_many_arrays_last_dim_exactly(arrs, size, to_ntype):
    # For polygons, this can be a list of lists of arrays, hence we must
    # flatten the lists here.
    # itertools.chain.from_iterable() seems to flatten the arrays too, so it
    # cannot be used here.
    iterable_type_str = "iterable"
    if len(arrs) == 0:
        arrs_flat = []
    elif ia.is_np_array(arrs[0]):
        arrs_flat = arrs
    else:
        iterable_type_str = "iterable of iterable"
        arrs_flat = [arr for arrs_sublist in arrs for arr in arrs_sublist]

    if any([arr.shape[-1] != size for arr in arrs_flat]):
        raise ValueError(
            ("Tried to convert an %s of array to a list of %s. Expected the "
             + "arrays' last dimensions to have size %d, but got %s instead "
             + "(array shapes: %s).") % (
                 iterable_type_str, to_ntype, size,
                 ", ".join([str(arr.shape[-1]) for arr in arrs_flat]),
                 ", ".join([str(arr.shape) for arr in arrs_flat]))
        )


</source>
</class>

<class classid="35" nclones="2" nlines="67" similarity="88">
<source file="systems/imgaug-0.2.9/imgaug/augmentables/normalization.py" startline="235" endline="307" pcid="447">
def normalize_keypoints(inputs, shapes=None):
    # TODO get rid of this deferred import
    from imgaug.augmentables.kps import Keypoint, KeypointsOnImage

    shapes = _preprocess_shapes(shapes)
    ntype = estimate_keypoints_norm_type(inputs)
    _assert_exactly_n_shapes_partial = functools.partial(
        _assert_exactly_n_shapes,
        from_ntype=ntype, to_ntype="List[KeypointsOnImage]",
        shapes=shapes)

    if ntype == "None":
        return inputs
    elif ntype in ["array[float]", "array[int]", "array[uint]"]:
        _assert_single_array_ndim(inputs, 3, "(N,K,2)", "KeypointsOnImage")
        _assert_single_array_last_dim_exactly(inputs, 2, "KeypointsOnImage")
        _assert_exactly_n_shapes_partial(n=len(inputs))
        return [
            KeypointsOnImage.from_xy_array(attr_i, shape=shape)
            for attr_i, shape
            in zip(inputs, shapes)
        ]
    elif ntype == "tuple[number,size=2]":
        _assert_exactly_n_shapes_partial(n=1)
        return [KeypointsOnImage([Keypoint(x=inputs[0], y=inputs[1])],
                                 shape=shapes[0])]
    elif ntype == "Keypoint":
        _assert_exactly_n_shapes_partial(n=1)
        return [KeypointsOnImage([inputs], shape=shapes[0])]
    elif ntype == "KeypointsOnImage":
        return [inputs]
    elif ntype == "iterable[empty]":
        return None
    elif ntype in ["iterable-array[float]",
                   "iterable-array[int]",
                   "iterable-array[uint]"]:
        _assert_many_arrays_ndim(inputs, 2, "(K,2)", "KeypointsOnImage")
        _assert_many_arrays_last_dim_exactly(inputs, 2, "KeypointsOnImage")
        _assert_exactly_n_shapes_partial(n=len(inputs))
        return [
            KeypointsOnImage.from_xy_array(attr_i, shape=shape)
            for attr_i, shape
            in zip(inputs, shapes)
        ]
    elif ntype == "iterable-tuple[number,size=2]":
        _assert_exactly_n_shapes_partial(n=1)
        return [KeypointsOnImage([Keypoint(x=x, y=y) for x, y in inputs],
                                 shape=shapes[0])]
    elif ntype == "iterable-Keypoint":
        _assert_exactly_n_shapes_partial(n=1)
        return [KeypointsOnImage(inputs, shape=shapes[0])]
    elif ntype == "iterable-KeypointsOnImage":
        return inputs
    elif ntype == "iterable-iterable[empty]":
        return None
    elif ntype == "iterable-iterable-tuple[number,size=2]":
        _assert_exactly_n_shapes_partial(n=len(inputs))
        return [
            KeypointsOnImage.from_xy_array(
                np.array(attr_i, dtype=np.float32),
                shape=shape)
            for attr_i, shape
            in zip(inputs, shapes)
        ]
    else:
        assert ntype == "iterable-iterable-Keypoint", (
            "Got unknown normalization type '%s'." % (ntype,))
        _assert_exactly_n_shapes_partial(n=len(inputs))
        return [KeypointsOnImage(attr_i, shape=shape)
                for attr_i, shape
                in zip(inputs, shapes)]


</source>
<source file="systems/imgaug-0.2.9/imgaug/augmentables/normalization.py" startline="308" endline="389" pcid="448">
def normalize_bounding_boxes(inputs, shapes=None):
    # TODO get rid of this deferred import
    from imgaug.augmentables.bbs import BoundingBox, BoundingBoxesOnImage

    shapes = _preprocess_shapes(shapes)
    ntype = estimate_bounding_boxes_norm_type(inputs)
    _assert_exactly_n_shapes_partial = functools.partial(
        _assert_exactly_n_shapes,
        from_ntype=ntype, to_ntype="List[BoundingBoxesOnImage]",
        shapes=shapes)

    if ntype == "None":
        return None
    elif ntype in ["array[float]", "array[int]", "array[uint]"]:
        _assert_single_array_ndim(inputs, 3, "(N,B,4)", "BoundingBoxesOnImage")
        _assert_single_array_last_dim_exactly(inputs, 4, "BoundingBoxesOnImage")
        _assert_exactly_n_shapes_partial(n=len(inputs))
        return [
            BoundingBoxesOnImage.from_xyxy_array(attr_i, shape=shape)
            for attr_i, shape
            in zip(inputs, shapes)
        ]
    elif ntype == "tuple[number,size=4]":
        _assert_exactly_n_shapes_partial(n=1)
        return [
            BoundingBoxesOnImage(
                [BoundingBox(
                    x1=inputs[0], y1=inputs[1],
                    x2=inputs[2], y2=inputs[3])],
                shape=shapes[0])
        ]
    elif ntype == "BoundingBox":
        _assert_exactly_n_shapes_partial(n=1)
        return [BoundingBoxesOnImage([inputs], shape=shapes[0])]
    elif ntype == "BoundingBoxesOnImage":
        return [inputs]
    elif ntype == "iterable[empty]":
        return None
    elif ntype in ["iterable-array[float]",
                   "iterable-array[int]",
                   "iterable-array[uint]"]:
        _assert_many_arrays_ndim(inputs, 2, "(B,4)", "BoundingBoxesOnImage")
        _assert_many_arrays_last_dim_exactly(inputs, 4, "BoundingBoxesOnImage")
        _assert_exactly_n_shapes_partial(n=len(inputs))
        return [
            BoundingBoxesOnImage.from_xyxy_array(attr_i, shape=shape)
            for attr_i, shape
            in zip(inputs, shapes)
        ]
    elif ntype == "iterable-tuple[number,size=4]":
        _assert_exactly_n_shapes_partial(n=1)
        return [
            BoundingBoxesOnImage(
                [BoundingBox(x1=x1, y1=y1, x2=x2, y2=y2)
                 for x1, y1, x2, y2 in inputs],
                shape=shapes[0])
        ]
    elif ntype == "iterable-BoundingBox":
        _assert_exactly_n_shapes_partial(n=1)
        return [BoundingBoxesOnImage(inputs, shape=shapes[0])]
    elif ntype == "iterable-BoundingBoxesOnImage":
        return inputs
    elif ntype == "iterable-iterable[empty]":
        return None
    elif ntype == "iterable-iterable-tuple[number,size=4]":
        _assert_exactly_n_shapes_partial(n=len(inputs))
        return [
            BoundingBoxesOnImage.from_xyxy_array(
                np.array(attr_i, dtype=np.float32),
                shape=shape)
            for attr_i, shape
            in zip(inputs, shapes)
        ]
    else:
        assert ntype == "iterable-iterable-BoundingBox", (
            "Got unknown normalization type '%s'." % (ntype,))
        _assert_exactly_n_shapes_partial(n=len(inputs))
        return [BoundingBoxesOnImage(attr_i, shape=shape)
                for attr_i, shape
                in zip(inputs, shapes)]


</source>
</class>

<class classid="36" nclones="2" nlines="27" similarity="71">
<source file="systems/imgaug-0.2.9/imgaug/augmentables/normalization.py" startline="558" endline="585" pcid="453">
def invert_normalize_heatmaps(heatmaps, heatmaps_old):
    ntype = estimate_heatmaps_norm_type(heatmaps_old)
    if ntype == "None":
        assert heatmaps is None
        return heatmaps
    elif ntype == "array[float]":
        assert len(heatmaps) == heatmaps_old.shape[0]
        input_dtype = heatmaps_old.dtype
        return restore_dtype_and_merge(
            [hm_i.arr_0to1 for hm_i in heatmaps],
            input_dtype)
    elif ntype == "HeatmapsOnImage":
        assert len(heatmaps) == 1
        return heatmaps[0]
    elif ntype == "iterable[empty]":
        assert heatmaps is None
        return []
    elif ntype == "iterable-array[float]":
        nonempty, _, _ = find_first_nonempty(heatmaps_old)
        input_dtype = nonempty.dtype
        return [restore_dtype_and_merge(hm_i.arr_0to1, input_dtype)
                for hm_i in heatmaps]
    else:
        assert ntype == "iterable-HeatmapsOnImage", (
            "Got unknown normalization type '%s'." % (ntype,))
        return heatmaps


</source>
<source file="systems/imgaug-0.2.9/imgaug/augmentables/normalization.py" startline="586" endline="616" pcid="454">
def invert_normalize_segmentation_maps(segmentation_maps,
                                       segmentation_maps_old):
    ntype = estimate_segmaps_norm_type(segmentation_maps_old)
    if ntype == "None":
        assert segmentation_maps is None
        return segmentation_maps
    elif ntype in ["array[int]", "array[uint]", "array[bool]"]:
        assert len(segmentation_maps) == segmentation_maps_old.shape[0]
        input_dtype = segmentation_maps_old.dtype
        return restore_dtype_and_merge(
            [segmap_i.get_arr_int() for segmap_i in segmentation_maps],
            input_dtype)
    elif ntype == "SegmentationMapOnImage":
        assert len(segmentation_maps) == 1
        return segmentation_maps[0]
    elif ntype == "iterable[empty]":
        assert segmentation_maps is None
        return []
    elif ntype in ["iterable-array[int]",
                   "iterable-array[uint]",
                   "iterable-array[bool]"]:
        nonempty, _, _ = find_first_nonempty(segmentation_maps_old)
        input_dtype = nonempty.dtype
        return [restore_dtype_and_merge(segmap_i.get_arr_int(), input_dtype)
                for segmap_i in segmentation_maps]
    else:
        assert ntype == "iterable-SegmentationMapOnImage", (
            "Got unknown normalization type '%s'." % (ntype,))
        return segmentation_maps


</source>
</class>

<class classid="37" nclones="2" nlines="53" similarity="86">
<source file="systems/imgaug-0.2.9/imgaug/augmentables/normalization.py" startline="617" endline="674" pcid="455">
def invert_normalize_keypoints(keypoints, keypoints_old):
    ntype = estimate_keypoints_norm_type(keypoints_old)
    if ntype == "None":
        assert keypoints is None
        return keypoints
    elif ntype in ["array[float]", "array[int]", "array[uint]"]:
        assert len(keypoints) == 1
        input_dtype = keypoints_old.dtype
        return restore_dtype_and_merge(
            [kpsoi.to_xy_array() for kpsoi in keypoints],
            input_dtype)
    elif ntype == "tuple[number,size=2]":
        assert len(keypoints) == 1
        assert len(keypoints[0].keypoints) == 1
        return (keypoints[0].keypoints[0].x,
                keypoints[0].keypoints[0].y)
    elif ntype == "Keypoint":
        assert len(keypoints) == 1
        assert len(keypoints[0].keypoints) == 1
        return keypoints[0].keypoints[0]
    elif ntype == "KeypointsOnImage":
        assert len(keypoints) == 1
        return keypoints[0]
    elif ntype == "iterable[empty]":
        assert keypoints is None
        return []
    elif ntype in ["iterable-array[float]",
                   "iterable-array[int]",
                   "iterable-array[uint]"]:
        nonempty, _, _ = find_first_nonempty(keypoints_old)
        input_dtype = nonempty.dtype
        return [
            restore_dtype_and_merge(kps_i.to_xy_array(), input_dtype)
            for kps_i in keypoints]
    elif ntype == "iterable-tuple[number,size=2]":
        assert len(keypoints) == 1
        return [
            (kp.x, kp.y) for kp in keypoints[0].keypoints]
    elif ntype == "iterable-Keypoint":
        assert len(keypoints) == 1
        return keypoints[0].keypoints
    elif ntype == "iterable-KeypointsOnImage":
        return keypoints
    elif ntype == "iterable-iterable[empty]":
        assert keypoints is None
        return keypoints_old[:]
    elif ntype == "iterable-iterable-tuple[number,size=2]":
        return [
            [(kp.x, kp.y) for kp in kpsoi.keypoints]
            for kpsoi in keypoints]
    else:
        assert ntype == "iterable-iterable-Keypoint", (
            "Got unknown normalization type '%s'." % (ntype,))
        return [
            [kp for kp in kpsoi.keypoints]
            for kpsoi in keypoints]


</source>
<source file="systems/imgaug-0.2.9/imgaug/augmentables/normalization.py" startline="675" endline="733" pcid="456">
def invert_normalize_bounding_boxes(bounding_boxes, bounding_boxes_old):
    ntype = estimate_normalization_type(bounding_boxes_old)
    if ntype == "None":
        assert bounding_boxes is None
        return bounding_boxes
    elif ntype in ["array[float]", "array[int]", "array[uint]"]:
        assert len(bounding_boxes) == 1
        input_dtype = bounding_boxes_old.dtype
        return restore_dtype_and_merge([
            bbsoi.to_xyxy_array() for bbsoi in bounding_boxes
        ], input_dtype)
    elif ntype == "tuple[number,size=4]":
        assert len(bounding_boxes) == 1
        assert len(bounding_boxes[0].bounding_boxes) == 1
        bb = bounding_boxes[0].bounding_boxes[0]
        return bb.x1, bb.y1, bb.x2, bb.y2
    elif ntype == "BoundingBox":
        assert len(bounding_boxes) == 1
        assert len(bounding_boxes[0].bounding_boxes) == 1
        return bounding_boxes[0].bounding_boxes[0]
    elif ntype == "BoundingBoxesOnImage":
        assert len(bounding_boxes) == 1
        return bounding_boxes[0]
    elif ntype == "iterable[empty]":
        assert bounding_boxes is None
        return []
    elif ntype in ["iterable-array[float]",
                   "iterable-array[int]",
                   "iterable-array[uint]"]:
        nonempty, _, _ = find_first_nonempty(bounding_boxes_old)
        input_dtype = nonempty.dtype
        return [
            restore_dtype_and_merge(bbsoi.to_xyxy_array(), input_dtype)
            for bbsoi in bounding_boxes]
    elif ntype == "iterable-tuple[number,size=4]":
        assert len(bounding_boxes) == 1
        return [
            (bb.x1, bb.y1, bb.x2, bb.y2)
            for bb in bounding_boxes[0].bounding_boxes]
    elif ntype == "iterable-BoundingBox":
        assert len(bounding_boxes) == 1
        return bounding_boxes[0].bounding_boxes
    elif ntype == "iterable-BoundingBoxesOnImage":
        return bounding_boxes
    elif ntype == "iterable-iterable[empty]":
        assert bounding_boxes is None
        return bounding_boxes_old[:]
    elif ntype == "iterable-iterable-tuple[number,size=4]":
        return [
            [(bb.x1, bb.y1, bb.x2, bb.y2) for bb in bbsoi.bounding_boxes]
            for bbsoi in bounding_boxes]
    else:
        assert ntype == "iterable-iterable-BoundingBox", (
            "Got unknown normalization type '%s'." % (ntype,))
        return [
            [bb for bb in bbsoi.bounding_boxes]
            for bbsoi in bounding_boxes]


</source>
</class>

<class classid="38" nclones="2" nlines="23" similarity="91">
<source file="systems/imgaug-0.2.9/imgaug/augmentables/normalization.py" startline="900" endline="924" pcid="463">
def estimate_keypoints_norm_type(keypoints):
    type_str = estimate_normalization_type(keypoints)
    valid_type_strs = [
        "None",
        "array[float]",
        "array[int]",
        "array[uint]",
        "tuple[number,size=2]",
        "Keypoint",
        "KeypointsOnImage",
        "iterable[empty]",
        "iterable-array[float]",
        "iterable-array[int]",
        "iterable-array[uint]",
        "iterable-tuple[number,size=2]",
        "iterable-Keypoint",
        "iterable-KeypointsOnImage",
        "iterable-iterable[empty]",
        "iterable-iterable-tuple[number,size=2]",
        "iterable-iterable-Keypoint"
    ]
    _assert_is_of_norm_type(type_str, valid_type_strs, "keypoints")
    return type_str


</source>
<source file="systems/imgaug-0.2.9/imgaug/augmentables/normalization.py" startline="925" endline="950" pcid="464">
def estimate_bounding_boxes_norm_type(bounding_boxes):
    type_str = estimate_normalization_type(bounding_boxes)
    valid_type_strs = [
        "None",
        "array[float]",
        "array[int]",
        "array[uint]",
        "tuple[number,size=4]",
        "BoundingBox",
        "BoundingBoxesOnImage",
        "iterable[empty]",
        "iterable-array[float]",
        "iterable-array[int]",
        "iterable-array[uint]",
        "iterable-tuple[number,size=4]",
        "iterable-BoundingBox",
        "iterable-BoundingBoxesOnImage",
        "iterable-iterable[empty]",
        "iterable-iterable-tuple[number,size=4]",
        "iterable-iterable-BoundingBox"
    ]
    _assert_is_of_norm_type(
        type_str, valid_type_strs, "bounding_boxes")
    return type_str


</source>
</class>

<class classid="39" nclones="2" nlines="13" similarity="78">
<source file="systems/imgaug-0.2.9/imgaug/augmentables/utils.py" startline="84" endline="97" pcid="475">
def interpolate_points(points, nb_steps, closed=True):
    if len(points) <= 1:
        return points
    if closed:
        points = list(points) + [points[0]]
    points_interp = []
    for point_a, point_b in zip(points[:-1], points[1:]):
        points_interp.extend([point_a] + interpolate_point_pair(point_a, point_b, nb_steps))
    if not closed:
        points_interp.append(points[-1])
    # close does not have to be reverted here, as last point is not included in the extend()
    return points_interp


</source>
<source file="systems/imgaug-0.2.9/imgaug/augmentables/utils.py" startline="98" endline="111" pcid="476">
def interpolate_points_by_max_distance(points, max_distance, closed=True):
    ia.do_assert(max_distance > 0, "max_distance must have value greater than 0, got %.8f" % (max_distance,))
    if len(points) <= 1:
        return points
    if closed:
        points = list(points) + [points[0]]
    points_interp = []
    for point_a, point_b in zip(points[:-1], points[1:]):
        dist = np.sqrt((point_a[0] - point_b[0]) ** 2 + (point_a[1] - point_b[1]) ** 2)
        nb_steps = int((dist / max_distance) - 1)
        points_interp.extend([point_a] + interpolate_point_pair(point_a, point_b, nb_steps))
    if not closed:
        points_interp.append(points[-1])
    return points_interp
</source>
</class>

<class classid="40" nclones="2" nlines="39" similarity="76">
<source file="systems/imgaug-0.2.9/imgaug/augmentables/kps.py" startline="626" endline="696" pcid="575">
    def from_keypoint_image(image, if_not_found_coords={"x": -1, "y": -1}, threshold=1, nb_channels=None): # pylint: disable=locally-disabled, dangerous-default-value, line-too-long
        """
        Converts an image generated by ``to_keypoint_image()`` back to a KeypointsOnImage object.

        Parameters
        ----------
        image : (H,W,N) ndarray
            The keypoints image. N is the number of keypoints.

        if_not_found_coords : tuple or list or dict or None, optional
            Coordinates to use for keypoints that cannot be found in `image`.
            If this is a list/tuple, it must have two integer values.
            If it is a dictionary, it must have the keys ``x`` and ``y`` with
            each containing one integer value.
            If this is None, then the keypoint will not be added to the final
            KeypointsOnImage object.

        threshold : int, optional
            The search for keypoints works by searching for the argmax in
            each channel. This parameters contains the minimum value that
            the max must have in order to be viewed as a keypoint.

        nb_channels : None or int, optional
            Number of channels of the image on which the keypoints are placed.
            Some keypoint augmenters require that information.
            If set to None, the keypoint's shape will be set
            to ``(height, width)``, otherwise ``(height, width, nb_channels)``.

        Returns
        -------
        out : KeypointsOnImage
            The extracted keypoints.

        """
        ia.do_assert(len(image.shape) == 3)
        height, width, nb_keypoints = image.shape

        drop_if_not_found = False
        if if_not_found_coords is None:
            drop_if_not_found = True
            if_not_found_x = -1
            if_not_found_y = -1
        elif isinstance(if_not_found_coords, (tuple, list)):
            ia.do_assert(len(if_not_found_coords) == 2)
            if_not_found_x = if_not_found_coords[0]
            if_not_found_y = if_not_found_coords[1]
        elif isinstance(if_not_found_coords, dict):
            if_not_found_x = if_not_found_coords["x"]
            if_not_found_y = if_not_found_coords["y"]
        else:
            raise Exception("Expected if_not_found_coords to be None or tuple or list or dict, got %s." % (
                type(if_not_found_coords),))

        keypoints = []
        for i in sm.xrange(nb_keypoints):
            maxidx_flat = np.argmax(image[..., i])
            maxidx_ndim = np.unravel_index(maxidx_flat, (height, width))
            found = (image[maxidx_ndim[0], maxidx_ndim[1], i] >= threshold)
            if found:
                keypoints.append(Keypoint(x=maxidx_ndim[1], y=maxidx_ndim[0]))
            else:
                if drop_if_not_found:
                    pass  # dont add the keypoint to the result list, i.e. drop it
                else:
                    keypoints.append(Keypoint(x=if_not_found_x, y=if_not_found_y))

        out_shape = (height, width)
        if nb_channels is not None:
            out_shape += (nb_channels,)
        return KeypointsOnImage(keypoints, shape=out_shape)

</source>
<source file="systems/imgaug-0.2.9/imgaug/augmentables/kps.py" startline="740" endline="824" pcid="577">
    def from_distance_maps(distance_maps, inverted=False, if_not_found_coords={"x": -1, "y": -1}, threshold=None, # pylint: disable=locally-disabled, dangerous-default-value, line-too-long
                           nb_channels=None):
        """
        Converts maps generated by ``to_distance_maps()`` back to a KeypointsOnImage object.

        Parameters
        ----------
        distance_maps : (H,W,N) ndarray
            The distance maps. N is the number of keypoints.

        inverted : bool, optional
            Whether the given distance maps were generated in inverted or normal mode.

        if_not_found_coords : tuple or list or dict or None, optional
            Coordinates to use for keypoints that cannot be found in ``distance_maps``.
            If this is a list/tuple, it must have two integer values.
            If it is a dictionary, it must have the keys ``x`` and ``y``, with each
            containing one integer value.
            If this is None, then the keypoint will not be added to the final
            KeypointsOnImage object.

        threshold : float, optional
            The search for keypoints works by searching for the argmin (non-inverted) or
            argmax (inverted) in each channel. This parameters contains the maximum (non-inverted)
            or minimum (inverted) value to accept in order to view a hit as a keypoint.
            Use None to use no min/max.

        nb_channels : None or int, optional
            Number of channels of the image on which the keypoints are placed.
            Some keypoint augmenters require that information.
            If set to None, the keypoint's shape will be set
            to ``(height, width)``, otherwise ``(height, width, nb_channels)``.

        Returns
        -------
        imgaug.KeypointsOnImage
            The extracted keypoints.

        """
        ia.do_assert(len(distance_maps.shape) == 3)
        height, width, nb_keypoints = distance_maps.shape

        drop_if_not_found = False
        if if_not_found_coords is None:
            drop_if_not_found = True
            if_not_found_x = -1
            if_not_found_y = -1
        elif isinstance(if_not_found_coords, (tuple, list)):
            ia.do_assert(len(if_not_found_coords) == 2)
            if_not_found_x = if_not_found_coords[0]
            if_not_found_y = if_not_found_coords[1]
        elif isinstance(if_not_found_coords, dict):
            if_not_found_x = if_not_found_coords["x"]
            if_not_found_y = if_not_found_coords["y"]
        else:
            raise Exception("Expected if_not_found_coords to be None or tuple or list or dict, got %s." % (
                type(if_not_found_coords),))

        keypoints = []
        for i in sm.xrange(nb_keypoints):
            # TODO introduce voting here among all distance values that have min/max values
            if inverted:
                hitidx_flat = np.argmax(distance_maps[..., i])
            else:
                hitidx_flat = np.argmin(distance_maps[..., i])
            hitidx_ndim = np.unravel_index(hitidx_flat, (height, width))
            if not inverted and threshold is not None:
                found = (distance_maps[hitidx_ndim[0], hitidx_ndim[1], i] < threshold)
            elif inverted and threshold is not None:
                found = (distance_maps[hitidx_ndim[0], hitidx_ndim[1], i] >= threshold)
            else:
                found = True
            if found:
                keypoints.append(Keypoint(x=hitidx_ndim[1], y=hitidx_ndim[0]))
            else:
                if drop_if_not_found:
                    pass  # dont add the keypoint to the result list, i.e. drop it
                else:
                    keypoints.append(Keypoint(x=if_not_found_x, y=if_not_found_y))

        out_shape = (height, width)
        if nb_channels is not None:
            out_shape += (nb_channels,)
        return KeypointsOnImage(keypoints, shape=out_shape)

</source>
</class>

<class classid="41" nclones="2" nlines="18" similarity="100">
<source file="systems/imgaug-0.2.9/imgaug/augmentables/batches.py" startline="161" endline="179" pcid="582">
    def __init__(self, images=None, heatmaps=None, segmentation_maps=None,
                 keypoints=None, bounding_boxes=None, polygons=None,
                 line_strings=None, data=None):
        self.images_unaug = images
        self.images_aug = None
        self.heatmaps_unaug = heatmaps
        self.heatmaps_aug = None
        self.segmentation_maps_unaug = segmentation_maps
        self.segmentation_maps_aug = None
        self.keypoints_unaug = keypoints
        self.keypoints_aug = None
        self.bounding_boxes_unaug = bounding_boxes
        self.bounding_boxes_aug = None
        self.polygons_unaug = polygons
        self.polygons_aug = None
        self.line_strings_unaug = line_strings
        self.line_strings_aug = None
        self.data = data

</source>
<source file="systems/imgaug-0.2.9/imgaug/augmentables/batches.py" startline="314" endline="332" pcid="585">
        not be returned in the original order, making this information useful.

    """
    def __init__(self, images=None, heatmaps=None, segmentation_maps=None,
                 keypoints=None, bounding_boxes=None, polygons=None,
                 line_strings=None, data=None):
        self.images_unaug = images
        self.images_aug = None
        self.heatmaps_unaug = heatmaps
        self.heatmaps_aug = None
        self.segmentation_maps_unaug = segmentation_maps
        self.segmentation_maps_aug = None
        self.keypoints_unaug = keypoints
        self.keypoints_aug = None
        self.bounding_boxes_unaug = bounding_boxes
        self.bounding_boxes_aug = None
        self.polygons_unaug = polygons
        self.polygons_aug = None
        self.line_strings_unaug = line_strings
</source>
</class>

<class classid="42" nclones="2" nlines="12" similarity="76">
<source file="systems/imgaug-0.2.9/imgaug/augmentables/lines.py" startline="615" endline="660" pcid="615">
    def draw_lines_heatmap_array(self, image_shape, alpha=1.0,
                                 size=1, antialiased=True,
                                 raise_if_out_of_image=False):
        """
        Draw the line segments of the line string as a heatmap array.

        Parameters
        ----------
        image_shape : tuple of int
            The shape of the image onto which to draw the line mask.

        alpha : float, optional
            Opacity of the line string. Higher values denote a more visible
            line string.

        size : int, optional
            Thickness of the line segments.

        antialiased : bool, optional
            Whether to draw the line with anti-aliasing activated.

        raise_if_out_of_image : bool, optional
            Whether to raise an error if the line string is fully
            outside of the image. If set to False, no error will be raised and
            only the parts inside the image will be drawn.

        Returns
        -------
        ndarray
            Float array of shape `image_shape` (no channel axis) with drawn
            line string. All values are in the interval ``[0.0, 1.0]``.

        """
        assert len(image_shape) == 2 or (
            len(image_shape) == 3 and image_shape[-1] == 1), (
            "Expected (H,W) or (H,W,1) as image_shape, got %s." % (
                image_shape,))

        arr = self.draw_lines_on_image(
            np.zeros(image_shape, dtype=np.uint8),
            color=255, alpha=alpha, size=size,
            antialiased=antialiased,
            raise_if_out_of_image=raise_if_out_of_image
        )
        return arr.astype(np.float32) / 255.0

</source>
<source file="systems/imgaug-0.2.9/imgaug/augmentables/lines.py" startline="661" endline="701" pcid="616">
    def draw_points_heatmap_array(self, image_shape, alpha=1.0,
                                  size=1, raise_if_out_of_image=False):
        """
        Draw the points of the line string as a heatmap array.

        Parameters
        ----------
        image_shape : tuple of int
            The shape of the image onto which to draw the point mask.

        alpha : float, optional
            Opacity of the line string points. Higher values denote a more
            visible points.

        size : int, optional
            Size of the points in pixels.

        raise_if_out_of_image : bool, optional
            Whether to raise an error if the line string is fully
            outside of the image. If set to False, no error will be raised and
            only the parts inside the image will be drawn.

        Returns
        -------
        ndarray
            Float array of shape `image_shape` (no channel axis) with drawn
            line string points. All values are in the interval ``[0.0, 1.0]``.

        """
        assert len(image_shape) == 2 or (
            len(image_shape) == 3 and image_shape[-1] == 1), (
            "Expected (H,W) or (H,W,1) as image_shape, got %s." % (
                image_shape,))

        arr = self.draw_points_on_image(
            np.zeros(image_shape, dtype=np.uint8),
            color=255, alpha=alpha, size=size,
            raise_if_out_of_image=raise_if_out_of_image
        )
        return arr.astype(np.float32) / 255.0

</source>
</class>

<class classid="43" nclones="3" nlines="12" similarity="91">
<source file="systems/imgaug-0.2.9/imgaug/parameters.py" startline="1440" endline="1456" pcid="742">
        self.elementwise = elementwise

    def _draw_samples(self, size, random_state):
        # TODO replace with derive_random_state()
        seed = random_state.randint(0, 10**6, 1)[0]
        samples = self.other_param.draw_samples(size, random_state=ia.new_random_state(seed))

        elementwise = self.elementwise and not isinstance(self.val, Deterministic)

        if elementwise:
            val_samples = self.val.draw_samples(size, random_state=ia.new_random_state(seed+1))
        else:
            val_samples = self.val.draw_sample(random_state=ia.new_random_state(seed+1))

        if elementwise:
            return np.multiply(samples, val_samples)
        else:
</source>
<source file="systems/imgaug-0.2.9/imgaug/parameters.py" startline="1576" endline="1592" pcid="750">
        self.elementwise = elementwise

    def _draw_samples(self, size, random_state):
        # TODO replace with derive_random_state()
        seed = random_state.randint(0, 10**6, 1)[0]
        samples = self.other_param.draw_samples(size, random_state=ia.new_random_state(seed))

        elementwise = self.elementwise and not isinstance(self.val, Deterministic)

        if elementwise:
            val_samples = self.val.draw_samples(size, random_state=ia.new_random_state(seed+1))
        else:
            val_samples = self.val.draw_sample(random_state=ia.new_random_state(seed+1))

        if elementwise:
            return np.add(samples, val_samples)
        else:
</source>
<source file="systems/imgaug-0.2.9/imgaug/parameters.py" startline="1635" endline="1651" pcid="754">
        self.elementwise = elementwise

    def _draw_samples(self, size, random_state):
        # TODO replace with derive_random_state()
        seed = random_state.randint(0, 10**6, 1)[0]
        samples = self.other_param.draw_samples(size, random_state=ia.new_random_state(seed))

        elementwise = self.elementwise and not isinstance(self.val, Deterministic)

        if elementwise:
            val_samples = self.val.draw_samples(size, random_state=ia.new_random_state(seed+1))
        else:
            val_samples = self.val.draw_sample(random_state=ia.new_random_state(seed+1))

        if elementwise:
            return np.subtract(samples, val_samples)
        else:
</source>
</class>

<class classid="44" nclones="2" nlines="24" similarity="72">
<source file="systems/imgaug-0.2.9/imgaug/parameters.py" startline="2075" endline="2101" pcid="776">
                            + "got %s." % (type(aggregation_method),))

    def _draw_samples(self, size, random_state):
        seed = random_state.randint(0, 10**6)
        aggregation_method = self.aggregation_method.draw_sample(random_state=ia.new_random_state(seed))
        iterations = self.iterations.draw_sample(random_state=ia.new_random_state(seed+1))
        ia.do_assert(iterations > 0)

        result = np.zeros(size, dtype=np.float32)
        for i in sm.xrange(iterations):
            noise_iter = self.other_param.draw_samples(size, random_state=ia.new_random_state(seed+2+i))
            if aggregation_method == "avg":
                result += noise_iter
            elif aggregation_method == "min":
                if i == 0:
                    result = noise_iter
                else:
                    result = np.minimum(result, noise_iter)
            else: # self.aggregation_method == "max"
                if i == 0:
                    result = noise_iter
                else:
                    result = np.maximum(result, noise_iter)

        if aggregation_method == "avg":
            result = result / iterations

</source>
<source file="systems/imgaug-0.2.9/imgaug/parameters.py" startline="2287" endline="2314" pcid="785">
                            + "got %s." % (type(upscale_method),))

    def _draw_samples(self, size, random_state):
        ia.do_assert(len(size) == 2, "Expected requested noise to have shape (H, W), got shape %s." % (size,))
        h, w = size
        seed = random_state.randint(0, 10**6)
        iterations = 1
        aggregation_method = "max"
        upscale_methods = self.upscale_method.draw_samples((iterations,), random_state=ia.new_random_state(seed))
        result = np.zeros((h, w), dtype=np.float32)
        for i in sm.xrange(iterations):
            noise_iter = self._draw_samples_iteration(h, w, seed + 10 + i, upscale_methods[i])
            if aggregation_method == "avg":
                result += noise_iter
            elif aggregation_method == "min":
                if i == 0:
                    result = noise_iter
                else:
                    result = np.minimum(result, noise_iter)
            else:  # self.aggregation_method == "max"
                if i == 0:
                    result = noise_iter
                else:
                    result = np.maximum(result, noise_iter)

        if aggregation_method == "avg":
            result = result / iterations

</source>
</class>

<class classid="45" nclones="2" nlines="17" similarity="88">
<source file="systems/imgaug-0.2.9/imgaug/parameters.py" startline="2269" endline="2286" pcid="784">

    """
    def __init__(self, size_px_max=(2, 16), upscale_method=["linear", "nearest"]): # pylint: disable=locally-disabled, dangerous-default-value, line-too-long
        super(SimplexNoise, self).__init__()
        self.size_px_max = handle_discrete_param(size_px_max, "size_px_max", value_range=(1, 10000))

        if upscale_method == ia.ALL:
            self.upscale_method = Choice(["nearest", "linear", "area", "cubic"])
        elif ia.is_string(upscale_method):
            self.upscale_method = Deterministic(upscale_method)
        elif isinstance(upscale_method, list):
            ia.do_assert(len(upscale_method) >= 1)
            ia.do_assert(all([ia.is_string(val) for val in upscale_method]))
            self.upscale_method = Choice(upscale_method)
        elif isinstance(upscale_method, StochasticParameter):
            self.upscale_method = upscale_method
        else:
            raise Exception("Expected upscale_method to be string or list of strings or StochasticParameter, "
</source>
<source file="systems/imgaug-0.2.9/imgaug/parameters.py" startline="2432" endline="2450" pcid="789">

    """
    def __init__(self, exponent=(-4, 4), size_px_max=(4, 32), upscale_method=["linear", "nearest"]): # pylint: disable=locally-disabled, dangerous-default-value, line-too-long
        super(FrequencyNoise, self).__init__()
        self.exponent = handle_continuous_param(exponent, "exponent")
        self.size_px_max = handle_discrete_param(size_px_max, "size_px_max", value_range=(1, 10000))

        if upscale_method == ia.ALL:
            self.upscale_method = Choice(["nearest", "linear", "area", "cubic"])
        elif ia.is_string(upscale_method):
            self.upscale_method = Deterministic(upscale_method)
        elif isinstance(upscale_method, list):
            ia.do_assert(len(upscale_method) >= 1)
            ia.do_assert(all([ia.is_string(val) for val in upscale_method]))
            self.upscale_method = Choice(upscale_method)
        elif isinstance(upscale_method, StochasticParameter):
            self.upscale_method = upscale_method
        else:
            raise Exception("Expected upscale_method to be string or list of strings or StochasticParameter, "
</source>
</class>

<class classid="46" nclones="2" nlines="120" similarity="71">
<source file="systems/imgaug-0.2.9/checks/check_segmentation_maps.py" startline="9" endline="164" pcid="826">
def main():
    quokka = ia.quokka(size=0.5)
    h, w = quokka.shape[0:2]
    c = 4
    segmap = np.zeros((h, w, c), dtype=np.float32)
    segmap[70:120, 90:150, 0] = 1.0
    segmap[30:70, 50:65, 1] = 1.0
    segmap[20:50, 55:85, 2] = 1.0
    segmap[120:140, 0:20, 3] = 1.0

    segmap = ia.SegmentationMapOnImage(segmap, quokka.shape)

    print("Affine...")
    aug = iaa.Affine(translate_px={"x": 20}, mode="constant", cval=128)
    quokka_aug = aug.augment_image(quokka)
    segmaps_aug = aug.augment_segmentation_maps([segmap])[0]
    segmaps_drawn = segmap.draw_on_image(quokka)
    segmaps_aug_drawn = segmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(
        np.hstack([
            segmaps_drawn,
            segmaps_aug_drawn
        ])
    )

    print("Affine with mode=edge...")
    aug = iaa.Affine(translate_px={"x": 20}, mode="edge")
    quokka_aug = aug.augment_image(quokka)
    segmaps_aug = aug.augment_segmentation_maps([segmap])[0]
    segmaps_drawn = segmap.draw_on_image(quokka)
    segmaps_aug_drawn = segmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(
        np.hstack([
            segmaps_drawn,
            segmaps_aug_drawn
        ])
    )

    print("PiecewiseAffine...")
    aug = iaa.PiecewiseAffine(scale=0.04)
    aug_det = aug.to_deterministic()
    quokka_aug = aug_det.augment_image(quokka)
    segmaps_aug = aug_det.augment_segmentation_maps([segmap])[0]
    segmaps_drawn = segmap.draw_on_image(quokka)
    segmaps_aug_drawn = segmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(
        np.hstack([
            segmaps_drawn,
            segmaps_aug_drawn
        ])
    )

    print("PerspectiveTransform...")
    aug = iaa.PerspectiveTransform(scale=0.04)
    aug_det = aug.to_deterministic()
    quokka_aug = aug_det.augment_image(quokka)
    segmaps_aug = aug_det.augment_segmentation_maps([segmap])[0]
    segmaps_drawn = segmap.draw_on_image(quokka)
    segmaps_aug_drawn = segmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(
        np.hstack([
            segmaps_drawn,
            segmaps_aug_drawn
        ])
    )

    print("ElasticTransformation alpha=3, sig=0.5...")
    aug = iaa.ElasticTransformation(alpha=3.0, sigma=0.5)
    aug_det = aug.to_deterministic()
    quokka_aug = aug_det.augment_image(quokka)
    segmaps_aug = aug_det.augment_segmentation_maps([segmap])[0]
    segmaps_drawn = segmap.draw_on_image(quokka)
    segmaps_aug_drawn = segmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(
        np.hstack([
            segmaps_drawn,
            segmaps_aug_drawn
        ])
    )

    print("ElasticTransformation alpha=10, sig=3...")
    aug = iaa.ElasticTransformation(alpha=10.0, sigma=3.0)
    aug_det = aug.to_deterministic()
    quokka_aug = aug_det.augment_image(quokka)
    segmaps_aug = aug_det.augment_segmentation_maps([segmap])[0]
    segmaps_drawn = segmap.draw_on_image(quokka)
    segmaps_aug_drawn = segmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(
        np.hstack([
            segmaps_drawn,
            segmaps_aug_drawn
        ])
    )

    print("CopAndPad mode=constant...")
    aug = iaa.CropAndPad(px=(-10, 10, 15, -15), pad_mode="constant", pad_cval=128)
    aug_det = aug.to_deterministic()
    quokka_aug = aug_det.augment_image(quokka)
    segmaps_aug = aug_det.augment_segmentation_maps([segmap])[0]
    segmaps_drawn = segmap.draw_on_image(quokka)
    segmaps_aug_drawn = segmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(
        np.hstack([
            segmaps_drawn,
            segmaps_aug_drawn
        ])
    )

    print("CropAndPad mode=edge...")
    aug = iaa.CropAndPad(px=(-10, 10, 15, -15), pad_mode="edge")
    aug_det = aug.to_deterministic()
    quokka_aug = aug_det.augment_image(quokka)
    segmaps_aug = aug_det.augment_segmentation_maps([segmap])[0]
    segmaps_drawn = segmap.draw_on_image(quokka)
    segmaps_aug_drawn = segmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(
        np.hstack([
            segmaps_drawn,
            segmaps_aug_drawn
        ])
    )

    print("Resize...")
    aug = iaa.Resize(0.5, interpolation="nearest")
    aug_det = aug.to_deterministic()
    quokka_aug = aug_det.augment_image(quokka)
    segmaps_aug = aug_det.augment_segmentation_maps([segmap])[0]
    segmaps_drawn = segmap.draw_on_image(quokka)
    segmaps_aug_drawn = segmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(ia.draw_grid([segmaps_drawn, segmaps_aug_drawn], cols=2))

    print("Alpha...")
    aug = iaa.Alpha(0.7, iaa.Affine(rotate=20))
    aug_det = aug.to_deterministic()
    quokka_aug = aug_det.augment_image(quokka)
    segmaps_aug = aug_det.augment_segmentation_maps([segmap])[0]
    segmaps_drawn = segmap.draw_on_image(quokka)
    segmaps_aug_drawn = segmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(
        np.hstack([
            segmaps_drawn,
            segmaps_aug_drawn
        ])
    )


</source>
<source file="systems/imgaug-0.2.9/checks/check_heatmaps.py" startline="9" endline="178" pcid="836">
def main():
    quokka = ia.quokka(size=0.5)
    h, w = quokka.shape[0:2]
    heatmap = np.zeros((h, w), dtype=np.float32)
    heatmap[70:120, 90:150] = 0.1
    heatmap[30:70, 50:65] = 0.5
    heatmap[20:50, 55:85] = 1.0
    heatmap[120:140, 0:20] = 0.75

    heatmaps = ia.HeatmapsOnImage(heatmap[..., np.newaxis], quokka.shape)

    print("Affine...")
    aug = iaa.Affine(translate_px={"x": 20}, mode="constant", cval=128)
    quokka_aug = aug.augment_image(quokka)
    heatmaps_aug = aug.augment_heatmaps([heatmaps])[0]
    heatmaps_drawn = heatmaps.draw_on_image(quokka)
    heatmaps_aug_drawn = heatmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(
        np.hstack([
            heatmaps_drawn[0],
            heatmaps_aug_drawn[0]
        ])
    )

    print("Affine with mode=edge...")
    aug = iaa.Affine(translate_px={"x": 20}, mode="edge")
    quokka_aug = aug.augment_image(quokka)
    heatmaps_aug = aug.augment_heatmaps([heatmaps])[0]
    heatmaps_drawn = heatmaps.draw_on_image(quokka)
    heatmaps_aug_drawn = heatmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(
        np.hstack([
            heatmaps_drawn[0],
            heatmaps_aug_drawn[0]
        ])
    )

    print("PiecewiseAffine...")
    aug = iaa.PiecewiseAffine(scale=0.04)
    aug_det = aug.to_deterministic()
    quokka_aug = aug_det.augment_image(quokka)
    heatmaps_aug = aug_det.augment_heatmaps([heatmaps])[0]
    heatmaps_drawn = heatmaps.draw_on_image(quokka)
    heatmaps_aug_drawn = heatmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(
        np.hstack([
            heatmaps_drawn[0],
            heatmaps_aug_drawn[0]
        ])
    )

    print("PerspectiveTransform...")
    aug = iaa.PerspectiveTransform(scale=0.04)
    aug_det = aug.to_deterministic()
    quokka_aug = aug_det.augment_image(quokka)
    heatmaps_aug = aug_det.augment_heatmaps([heatmaps])[0]
    heatmaps_drawn = heatmaps.draw_on_image(quokka)
    heatmaps_aug_drawn = heatmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(
        np.hstack([
            heatmaps_drawn[0],
            heatmaps_aug_drawn[0]
        ])
    )

    print("ElasticTransformation alpha=3, sig=0.5...")
    aug = iaa.ElasticTransformation(alpha=3.0, sigma=0.5)
    aug_det = aug.to_deterministic()
    quokka_aug = aug_det.augment_image(quokka)
    heatmaps_aug = aug_det.augment_heatmaps([heatmaps])[0]
    heatmaps_drawn = heatmaps.draw_on_image(quokka)
    heatmaps_aug_drawn = heatmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(
        np.hstack([
            heatmaps_drawn[0],
            heatmaps_aug_drawn[0]
        ])
    )

    print("ElasticTransformation alpha=10, sig=3...")
    aug = iaa.ElasticTransformation(alpha=10.0, sigma=3.0)
    aug_det = aug.to_deterministic()
    quokka_aug = aug_det.augment_image(quokka)
    heatmaps_aug = aug_det.augment_heatmaps([heatmaps])[0]
    heatmaps_drawn = heatmaps.draw_on_image(quokka)
    heatmaps_aug_drawn = heatmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(
        np.hstack([
            heatmaps_drawn[0],
            heatmaps_aug_drawn[0]
        ])
    )

    print("CopAndPad mode=constant...")
    aug = iaa.CropAndPad(px=(-10, 10, 15, -15), pad_mode="constant", pad_cval=128)
    aug_det = aug.to_deterministic()
    quokka_aug = aug_det.augment_image(quokka)
    heatmaps_aug = aug_det.augment_heatmaps([heatmaps])[0]
    heatmaps_drawn = heatmaps.draw_on_image(quokka)
    heatmaps_aug_drawn = heatmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(
        np.hstack([
            heatmaps_drawn[0],
            heatmaps_aug_drawn[0]
        ])
    )

    print("CopAndPad mode=constant + percent...")
    aug = iaa.CropAndPad(percent=(-0.05, 0.05, 0.1, -0.1), pad_mode="constant", pad_cval=128)
    aug_det = aug.to_deterministic()
    quokka_aug = aug_det.augment_image(quokka)
    heatmaps_aug = aug_det.augment_heatmaps([heatmaps])[0]
    heatmaps_drawn = heatmaps.draw_on_image(quokka)
    heatmaps_aug_drawn = heatmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(
        np.hstack([
            heatmaps_drawn[0],
            heatmaps_aug_drawn[0]
        ])
    )

    print("CropAndPad mode=edge...")
    aug = iaa.CropAndPad(px=(-10, 10, 15, -15), pad_mode="edge")
    aug_det = aug.to_deterministic()
    quokka_aug = aug_det.augment_image(quokka)
    heatmaps_aug = aug_det.augment_heatmaps([heatmaps])[0]
    heatmaps_drawn = heatmaps.draw_on_image(quokka)
    heatmaps_aug_drawn = heatmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(
        np.hstack([
            heatmaps_drawn[0],
            heatmaps_aug_drawn[0]
        ])
    )

    print("Resize...")
    aug = iaa.Resize(0.5, interpolation="nearest")
    aug_det = aug.to_deterministic()
    quokka_aug = aug_det.augment_image(quokka)
    heatmaps_aug = aug_det.augment_heatmaps([heatmaps])[0]
    heatmaps_drawn = heatmaps.draw_on_image(quokka)
    heatmaps_aug_drawn = heatmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(ia.draw_grid([heatmaps_drawn[0], heatmaps_aug_drawn[0]], cols=2))

    print("Alpha...")
    aug = iaa.Alpha(0.7, iaa.Affine(rotate=20))
    aug_det = aug.to_deterministic()
    quokka_aug = aug_det.augment_image(quokka)
    heatmaps_aug = aug_det.augment_heatmaps([heatmaps])[0]
    heatmaps_drawn = heatmaps.draw_on_image(quokka)
    heatmaps_aug_drawn = heatmaps_aug.draw_on_image(quokka_aug)

    ia.imshow(
        np.hstack([
            heatmaps_drawn[0],
            heatmaps_aug_drawn[0]
        ])
    )


</source>
</class>

<class classid="47" nclones="3" nlines="12" similarity="100">
<source file="systems/imgaug-0.2.9/checks/check_clouds.py" startline="9" endline="24" pcid="829">
def main():
    for size in [0.1, 0.2, 1.0]:
        image = imageio.imread("https://upload.wikimedia.org/wikipedia/commons/8/89/Kukle%2CCzech_Republic..jpg",
                               format="jpg")
        image = ia.imresize_single_image(image, size, "cubic")
        print(image.shape)
        augs = [
            ("iaa.Clouds()", iaa.Clouds())
        ]

        for descr, aug in augs:
            print(descr)
            images_aug = aug.augment_images([image] * 64)
            ia.imshow(ia.draw_grid(images_aug))


</source>
<source file="systems/imgaug-0.2.9/checks/check_fog.py" startline="9" endline="24" pcid="852">
def main():
    for size in [0.1, 0.2, 1.0]:
        image = imageio.imread("https://upload.wikimedia.org/wikipedia/commons/8/89/Kukle%2CCzech_Republic..jpg",
                               format="jpg")
        image = ia.imresize_single_image(image, size, "cubic")
        print(image.shape)
        augs = [
            ("iaa.Fog()", iaa.Fog())
        ]

        for descr, aug in augs:
            print(descr)
            images_aug = aug.augment_images([image] * 64)
            ia.imshow(ia.draw_grid(images_aug))


</source>
<source file="systems/imgaug-0.2.9/checks/check_snowflakes.py" startline="9" endline="24" pcid="835">
def main():
    for size in [0.1, 0.2, 1.0]:
        image = imageio.imread("https://upload.wikimedia.org/wikipedia/commons/8/89/Kukle%2CCzech_Republic..jpg",
                               format="jpg")
        image = ia.imresize_single_image(image, size, "cubic")
        print(image.shape)
        augs = [
            ("iaa.Snowflakes()", iaa.Snowflakes())
        ]

        for descr, aug in augs:
            print(descr)
            images_aug = aug.augment_images([image] * 64)
            ia.imshow(ia.draw_grid(images_aug))


</source>
</class>

<class classid="48" nclones="2" nlines="76" similarity="100">
<source file="systems/imgaug-0.2.9/checks/check_elastic_transformation.py" startline="126" endline="218" pcid="833">
    def map_coordinates(cls, image, dx, dy, order=1, cval=0, mode="constant"):
        # small debug message to be sure that the right function is executed
        print("map_coordinates() with scipy")

        if order == 0 and image.dtype.name in ["uint64", "int64"]:
            raise Exception(("dtypes uint64 and int64 are only supported in ElasticTransformation for order=0, "
                             + "got order=%d with dtype=%s.") % (order, image.dtype.name))

        input_dtype = image.dtype
        if image.dtype.name == "bool":
            image = image.astype(np.float32)
        elif order == 1 and image.dtype.name in ["int8", "int16", "int32"]:
            image = image.astype(np.float64)
        elif order >= 2 and image.dtype.name == "int8":
            image = image.astype(np.int16)
        elif order >= 2 and image.dtype.name == "int32":
            image = image.astype(np.float64)

        shrt_max = 32767
        backend = "cv2"
        if order == 0:
            bad_dtype_cv2 = (image.dtype.name in ["uint32", "uint64", "int64", "float128", "bool"])
        elif order == 1:
            bad_dtype_cv2 = (image.dtype.name in ["uint32", "uint64", "int8", "int16", "int32", "int64", "float128",
                                                  "bool"])
        else:
            bad_dtype_cv2 = (image.dtype.name in ["uint32", "uint64", "int8", "int32", "int64", "float128", "bool"])

        bad_dx_shape_cv2 = (dx.shape[0] >= shrt_max or dx.shape[1] >= shrt_max)
        bad_dy_shape_cv2 = (dy.shape[0] >= shrt_max or dy.shape[1] >= shrt_max)
        if bad_dtype_cv2 or bad_dx_shape_cv2 or bad_dy_shape_cv2:
            backend = "scipy"

        ia.do_assert(image.ndim == 3)
        result = np.copy(image)
        height, width = image.shape[0:2]
        # True was added here, only difference to usual code
        if True or backend == "scipy":
            h, w = image.shape[0:2]
            y, x = np.meshgrid(np.arange(h).astype(np.float32), np.arange(w).astype(np.float32), indexing='ij')
            x_shifted = x + (-1) * dx
            y_shifted = y + (-1) * dy

            for c in sm.xrange(image.shape[2]):
                remapped_flat = ndimage.interpolation.map_coordinates(
                    image[..., c],
                    (y_shifted.flatten(), x_shifted.flatten()),
                    order=order,
                    cval=cval,
                    mode=mode
                )
                remapped = remapped_flat.reshape((height, width))
                result[..., c] = remapped
        else:
            h, w, nb_channels = image.shape

            y, x = np.meshgrid(np.arange(h).astype(np.float32), np.arange(w).astype(np.float32), indexing='ij')
            x_shifted = x + (-1) * dx
            y_shifted = y + (-1) * dy

            if image.dtype.kind == "f":
                cval = float(cval)
            else:
                cval = int(cval)
            border_mode = cls._MAPPING_MODE_SCIPY_CV2[mode]
            interpolation = cls._MAPPING_ORDER_SCIPY_CV2[order]

            is_nearest_neighbour = (interpolation == cv2.INTER_NEAREST)
            map1, map2 = cv2.convertMaps(x_shifted, y_shifted, cv2.CV_16SC2, nninterpolation=is_nearest_neighbour)
            # remap only supports up to 4 channels
            if nb_channels <= 4:
                result = cv2.remap(image, map1, map2, interpolation=interpolation, borderMode=border_mode, borderValue=cval)
                if image.ndim == 3 and result.ndim == 2:
                    result = result[..., np.newaxis]
            else:
                current_chan_idx = 0
                result = []
                while current_chan_idx < nb_channels:
                    channels = image[..., current_chan_idx:current_chan_idx+4]
                    result_c =  cv2.remap(channels, map1, map2, interpolation=interpolation, borderMode=border_mode,
                                          borderValue=cval)
                    if result_c.ndim == 2:
                        result_c = result_c[..., np.newaxis]
                    result.append(result_c)
                    current_chan_idx += 4
                result = np.concatenate(result, axis=2)

        if result.dtype.name != input_dtype.name:
            result = meta.restore_dtypes_(result, input_dtype)

        return result


</source>
<source file="systems/imgaug-0.2.9/checks/check_elastic_transformation.py" startline="221" endline="313" pcid="834">
    def map_coordinates(cls, image, dx, dy, order=1, cval=0, mode="constant"):
        # small debug message to be sure that the right function is executed
        print("map_coordinates() with cv2")

        if order == 0 and image.dtype.name in ["uint64", "int64"]:
            raise Exception(("dtypes uint64 and int64 are only supported in ElasticTransformation for order=0, "
                             + "got order=%d with dtype=%s.") % (order, image.dtype.name))

        input_dtype = image.dtype
        if image.dtype.name == "bool":
            image = image.astype(np.float32)
        elif order == 1 and image.dtype.name in ["int8", "int16", "int32"]:
            image = image.astype(np.float64)
        elif order >= 2 and image.dtype.name == "int8":
            image = image.astype(np.int16)
        elif order >= 2 and image.dtype.name == "int32":
            image = image.astype(np.float64)

        shrt_max = 32767
        backend = "cv2"
        if order == 0:
            bad_dtype_cv2 = (image.dtype.name in ["uint32", "uint64", "int64", "float128", "bool"])
        elif order == 1:
            bad_dtype_cv2 = (image.dtype.name in ["uint32", "uint64", "int8", "int16", "int32", "int64", "float128",
                                                  "bool"])
        else:
            bad_dtype_cv2 = (image.dtype.name in ["uint32", "uint64", "int8", "int32", "int64", "float128", "bool"])

        bad_dx_shape_cv2 = (dx.shape[0] >= shrt_max or dx.shape[1] >= shrt_max)
        bad_dy_shape_cv2 = (dy.shape[0] >= shrt_max or dy.shape[1] >= shrt_max)
        if bad_dtype_cv2 or bad_dx_shape_cv2 or bad_dy_shape_cv2:
            backend = "scipy"

        ia.do_assert(image.ndim == 3)
        result = np.copy(image)
        height, width = image.shape[0:2]
        # False was added here, only difference to usual code
        if False or backend == "scipy":
            h, w = image.shape[0:2]
            y, x = np.meshgrid(np.arange(h).astype(np.float32), np.arange(w).astype(np.float32), indexing='ij')
            x_shifted = x + (-1) * dx
            y_shifted = y + (-1) * dy

            for c in sm.xrange(image.shape[2]):
                remapped_flat = ndimage.interpolation.map_coordinates(
                    image[..., c],
                    (x_shifted.flatten(), y_shifted.flatten()),
                    order=order,
                    cval=cval,
                    mode=mode
                )
                remapped = remapped_flat.reshape((height, width))
                result[..., c] = remapped
        else:
            h, w, nb_channels = image.shape

            y, x = np.meshgrid(np.arange(h).astype(np.float32), np.arange(w).astype(np.float32), indexing='ij')
            x_shifted = x + (-1) * dx
            y_shifted = y + (-1) * dy

            if image.dtype.kind == "f":
                cval = float(cval)
            else:
                cval = int(cval)
            border_mode = cls._MAPPING_MODE_SCIPY_CV2[mode]
            interpolation = cls._MAPPING_ORDER_SCIPY_CV2[order]

            is_nearest_neighbour = (interpolation == cv2.INTER_NEAREST)
            map1, map2 = cv2.convertMaps(x_shifted, y_shifted, cv2.CV_16SC2, nninterpolation=is_nearest_neighbour)
            # remap only supports up to 4 channels
            if nb_channels <= 4:
                result = cv2.remap(image, map1, map2, interpolation=interpolation, borderMode=border_mode, borderValue=cval)
                if image.ndim == 3 and result.ndim == 2:
                    result = result[..., np.newaxis]
            else:
                current_chan_idx = 0
                result = []
                while current_chan_idx < nb_channels:
                    channels = image[..., current_chan_idx:current_chan_idx+4]
                    result_c =  cv2.remap(channels, map1, map2, interpolation=interpolation, borderMode=border_mode,
                                          borderValue=cval)
                    if result_c.ndim == 2:
                        result_c = result_c[..., np.newaxis]
                    result.append(result_c)
                    current_chan_idx += 4
                result = np.concatenate(result, axis=2)

        if result.dtype.name != input_dtype.name:
            result = meta.restore_dtypes_(result, input_dtype)

        return result


</source>
</class>

<class classid="49" nclones="2" nlines="25" similarity="81">
<source file="systems/imgaug-0.2.9/checks/check_median_blur.py" startline="14" endline="44" pcid="841">
def main():
    image = data.astronaut()
    image = ia.imresize_single_image(image, (64, 64))
    print("image shape:", image.shape)
    print("Press any key or wait %d ms to proceed to the next image." % (TIME_PER_STEP,))

    k = [
        1,
        3,
        5,
        7,
        (3, 3),
        (1, 11)
    ]

    cv2.namedWindow("aug", cv2.WINDOW_NORMAL)
    cv2.resizeWindow("aug", 64*NB_AUGS_PER_IMAGE, 64)

    for ki in k:
        aug = iaa.MedianBlur(k=ki)
        img_aug = [aug.augment_image(image) for _ in range(NB_AUGS_PER_IMAGE)]
        img_aug = np.hstack(img_aug)
        print("dtype", img_aug.dtype, "averages", np.average(img_aug, axis=tuple(range(0, img_aug.ndim-1))))

        title = "k=%s" % (str(ki),)
        img_aug = ia.draw_text(img_aug, x=5, y=5, text=title)

        cv2.imshow("aug", img_aug[..., ::-1]) # here with rgb2bgr
        cv2.waitKey(TIME_PER_STEP)


</source>
<source file="systems/imgaug-0.2.9/checks/check_average_blur.py" startline="14" endline="48" pcid="873">
def main():
    image = data.astronaut()
    image = ia.imresize_single_image(image, (64, 64))
    print("image shape:", image.shape)
    print("Press any key or wait %d ms to proceed to the next image." % (TIME_PER_STEP,))

    k = [
        1,
        2,
        4,
        8,
        16,
        (8, 8),
        (1, 8),
        ((1, 1), (8, 8)),
        ((1, 16), (1, 16)),
        ((1, 16), 1)
    ]

    cv2.namedWindow("aug", cv2.WINDOW_NORMAL)
    cv2.resizeWindow("aug", 64*NB_AUGS_PER_IMAGE, 64)

    for ki in k:
        aug = iaa.AverageBlur(k=ki)
        img_aug = [aug.augment_image(image) for _ in range(NB_AUGS_PER_IMAGE)]
        img_aug = np.hstack(img_aug)
        print("dtype", img_aug.dtype, "averages", np.average(img_aug, axis=tuple(range(0, img_aug.ndim-1))))

        title = "k=%s" % (str(ki),)
        img_aug = ia.draw_text(img_aug, x=5, y=5, text=title)

        cv2.imshow("aug", img_aug[..., ::-1])  # here with rgb2bgr
        cv2.waitKey(TIME_PER_STEP)


</source>
</class>

<class classid="50" nclones="2" nlines="24" similarity="70">
<source file="systems/imgaug-0.2.9/checks/check_pool.py" startline="321" endline="353" pcid="884">
def load_images(n_batches=10, sleep=0.0, draw_text=True):
    batch_size = 4
    astronaut = data.astronaut()
    astronaut = ia.imresize_single_image(astronaut, (64, 64))
    kps = ia.KeypointsOnImage([ia.Keypoint(x=15, y=25)], shape=astronaut.shape)

    counter = 0
    for i in range(n_batches):
        if draw_text:
            batch_images = []
            batch_kps = []
            for b in range(batch_size):
                astronaut_text = ia.draw_text(astronaut, x=0, y=0, text="%d" % (counter,), color=[0, 255, 0], size=16)
                batch_images.append(astronaut_text)
                batch_kps.append(kps)
                counter += 1
            batch = ia.Batch(
                images=np.array(batch_images, dtype=np.uint8),
                keypoints=batch_kps
            )
        else:
            if i == 0:
                batch_images = np.array([np.copy(astronaut) for _ in range(batch_size)], dtype=np.uint8)

            batch = ia.Batch(
                images=np.copy(batch_images),
                keypoints=[kps.deepcopy() for _ in range(batch_size)]
            )
        yield batch
        if sleep > 0:
            time.sleep(sleep)


</source>
<source file="systems/imgaug-0.2.9/checks/check_background_augmentation.py" startline="261" endline="283" pcid="894">
def load_images(n_batches=10, sleep=0.0):
    batch_size = 4
    astronaut = data.astronaut()
    astronaut = ia.imresize_single_image(astronaut, (64, 64))
    kps = ia.KeypointsOnImage([ia.Keypoint(x=15, y=25)], shape=astronaut.shape)
    counter = 0
    for i in range(n_batches):
        batch_images = []
        batch_kps = []
        for b in range(batch_size):
            astronaut_text = ia.draw_text(astronaut, x=0, y=0, text="%d" % (counter,), color=[0, 255, 0], size=16)
            batch_images.append(astronaut_text)
            batch_kps.append(kps)
            counter += 1
        batch = ia.Batch(
            images=np.array(batch_images, dtype=np.uint8),
            keypoints=batch_kps
        )
        yield batch
        if sleep > 0:
            time.sleep(sleep)


</source>
</class>

<class classid="51" nclones="2" nlines="17" similarity="100">
<source file="systems/imgaug-0.2.9/checks/check_pool.py" startline="354" endline="374" pcid="885">
def draw_grid(images_aug, keypoints_aug):
    if keypoints_aug is None:
        keypoints_aug = []
        for bidx in range(len(images_aug)):
            keypoints_aug.append([None for image in images_aug[bidx]])

    images_kps_batches = []
    for bidx in range(len(images_aug)):
        images_kps_batch = []
        for image, kps in zip(images_aug[bidx], keypoints_aug[bidx]):
            if kps is None:
                image_kps = image
            else:
                image_kps = kps.draw_on_image(image, size=5, color=[255, 0, 0])
            images_kps_batch.append(image_kps)
        images_kps_batches.extend(images_kps_batch)

    grid = ia.draw_grid(images_kps_batches, cols=len(images_aug[0]))
    return grid


</source>
<source file="systems/imgaug-0.2.9/checks/check_background_augmentation.py" startline="284" endline="304" pcid="895">
def draw_grid(images_aug, keypoints_aug):
    if keypoints_aug is None:
        keypoints_aug = []
        for bidx in range(len(images_aug)):
            keypoints_aug.append([None for image in images_aug[bidx]])

    images_kps_batches = []
    for bidx in range(len(images_aug)):
        images_kps_batch = []
        for image, kps in zip(images_aug[bidx], keypoints_aug[bidx]):
            if kps is None:
                image_kps = image
            else:
                image_kps = kps.draw_on_image(image, size=5, color=[255, 0, 0])
            images_kps_batch.append(image_kps)
        images_kps_batches.extend(images_kps_batch)

    grid = ia.draw_grid(images_kps_batches, cols=len(images_aug[0]))
    return grid


</source>
</class>

<class classid="52" nclones="3" nlines="38" similarity="78">
<source file="systems/imgaug-0.2.9/test/test_imgaug.py" startline="29" endline="82" pcid="896">
def main():
    time_start = time.time()

    test_is_np_array()
    test_is_single_integer()
    test_is_single_float()
    test_is_single_number()
    test_is_iterable()
    test_is_string()
    test_is_single_bool()
    test_is_integer_array()
    test_is_float_array()
    test_is_callable()
    test_caller_name()
    test_seed()
    test_current_random_state()
    test_new_random_state()
    test_dummy_random_state()
    test_copy_random_state()
    test_derive_random_state()
    test_derive_random_states()
    test_forward_random_state()
    test__quokka_normalize_extract()
    test__compute_resized_shape()
    test_quokka()
    test_quokka_square()
    test_quokka_heatmap()
    test_quokka_segmentation_map()
    test_quokka_keypoints()
    test_quokka_bounding_boxes()
    # test_angle_between_vectors()
    test_compute_line_intersection_point()
    test_draw_text()
    test_imresize_many_images()
    test_imresize_single_image()
    test_pad()
    test_compute_paddings_for_aspect_ratio()
    test_pad_to_aspect_ratio()
    test_pool()
    test_avg_pool()
    test_max_pool()
    test_draw_grid()
    # test_show_grid()
    # test_do_assert()
    # test_HooksImages_is_activated()
    # test_HooksImages_is_propagating()
    # test_HooksImages_preprocess()
    # test_HooksImages_postprocess()
    test_classes_and_functions_marked_deprecated()

    time_end = time.time()
    print("<%s> Finished without errors in %.4fs." % (__file__, time_end - time_start,))


</source>
<source file="systems/imgaug-0.2.9/test/test_parameters.py" startline="29" endline="72" pcid="1279">
def main():
    time_start = time.time()

    test_parameters_handle_continuous_param()
    test_parameters_handle_discrete_param()
    test_parameters_handle_probability_param()
    test_parameters_force_np_float_dtype()
    test_parameters_both_np_float_if_one_is_float()
    test_parameters_draw_distribution_graph()
    test_parameters_Biomial()
    test_parameters_Choice()
    test_parameters_DiscreteUniform()
    test_parameters_Poisson()
    test_parameters_Normal()
    test_parameters_Laplace()
    test_parameters_ChiSquare()
    test_parameters_Weibull()
    test_parameters_Uniform()
    test_parameters_Beta()
    test_parameters_Deterministic()
    test_parameters_FromLowerResolution()
    test_parameters_Clip()
    test_parameters_Discretize()
    test_parameters_Multiply()
    test_parameters_Divide()
    test_parameters_Add()
    test_parameters_Subtract()
    test_parameters_Power()
    test_parameters_Absolute()
    test_parameters_RandomSign()
    test_parameters_ForceSign()
    test_parameters_Positive()
    test_parameters_Negative()
    test_parameters_IterativeNoiseAggregator()
    test_parameters_Sigmoid()
    # test_parameters_SimplexNoise()
    # test_parameters_FrequencyNoise()
    test_parameters_operators()
    test_parameters_copy()

    time_end = time.time()
    print("<%s> Finished without errors in %.4fs." % (__file__, time_end - time_start,))


</source>
<source file="systems/imgaug-0.2.9/test/augmentables/test_polys.py" startline="31" endline="62" pcid="1162">
def main():
    test_Polygon___init__()
    test_Polygon_xx()
    test_Polygon_yy()
    test_Polygon_xx_int()
    test_Polygon_yy_int()
    test_Polygon_is_valid()
    test_Polygon_area()
    test_Polygon_height()
    test_Polygon_width()
    test_Polygon_project()
    test_Polygon_find_closest_point_idx()
    test_Polygon_is_fully_within_image()
    test_Polygon_is_partly_within_image()
    test_Polygon_is_out_of_image()
    test_Polygon_cut_out_of_image()
    test_Polygon_clip_out_of_image()
    test_Polygon_shift()
    test_Polygon_draw_on_image()
    test_Polygon_extract_from_image()
    test_Polygon_to_shapely_polygon()
    test_Polygon_to_bounding_box()
    test_Polygon_from_shapely()
    test_Polygon_copy()
    test_Polygon_deepcopy()
    test_Polygon___repr__()
    test_Polygon___str__()
    test_Polygon_exterior_almost_equals()
    test_Polygon_almost_equals()
    test___convert_points_to_shapely_line_string()


</source>
</class>

<class classid="53" nclones="2" nlines="10" similarity="100">
<source file="systems/imgaug-0.2.9/test/test_imgaug.py" startline="102" endline="113" pcid="898">
def test_is_single_integer():
    assert ia.is_single_integer("A") is False
    assert ia.is_single_integer(None) is False
    assert ia.is_single_integer(1.2) is False
    assert ia.is_single_integer(1.0) is False
    assert ia.is_single_integer(np.ones((1,), dtype=np.float32)[0]) is False
    assert ia.is_single_integer(1) is True
    assert ia.is_single_integer(1234) is True
    assert ia.is_single_integer(np.ones((1,), dtype=np.uint8)[0]) is True
    assert ia.is_single_integer(np.ones((1,), dtype=np.int32)[0]) is True


</source>
<source file="systems/imgaug-0.2.9/test/test_imgaug.py" startline="114" endline="125" pcid="899">
def test_is_single_float():
    assert ia.is_single_float("A") is False
    assert ia.is_single_float(None) is False
    assert ia.is_single_float(1.2) is True
    assert ia.is_single_float(1.0) is True
    assert ia.is_single_float(np.ones((1,), dtype=np.float32)[0]) is True
    assert ia.is_single_float(1) is False
    assert ia.is_single_float(1234) is False
    assert ia.is_single_float(np.ones((1,), dtype=np.uint8)[0]) is False
    assert ia.is_single_float(np.ones((1,), dtype=np.int32)[0]) is False


</source>
</class>

<class classid="54" nclones="2" nlines="10" similarity="70">
<source file="systems/imgaug-0.2.9/test/test_imgaug.py" startline="164" endline="175" pcid="903">
def test_is_string():
    class _Dummy(object):
        pass
    values_true = ["A", "BC", "1", ""]
    values_false = [-100, 1, 0, 1, 100, -1.2, -0.001, 0.0, 0.001, 1.2, 1e-4, True, False, (1.0, 2.0), [1.0, 2.0],
                    _Dummy(), np.zeros((1, 2), dtype=np.uint8)]
    for value in values_true:
        assert ia.is_string(value) is True
    for value in values_false:
        assert ia.is_string(value) is False


</source>
<source file="systems/imgaug-0.2.9/test/test_imgaug.py" startline="176" endline="187" pcid="904">
def test_is_single_bool():
    class _Dummy(object):
        pass
    values_true = [False, True]
    values_false = [-100, 1, 0, 1, 100, -1.2, -0.001, 0.0, 0.001, 1.2, 1e-4, (1.0, 2.0), [1.0, 2.0], _Dummy(),
                    np.zeros((1, 2), dtype=np.uint8), np.zeros((1,), dtype=bool)]
    for value in values_true:
        assert ia.is_single_bool(value) is True
    for value in values_false:
        assert ia.is_single_bool(value) is False


</source>
</class>

<class classid="55" nclones="2" nlines="20" similarity="90">
<source file="systems/imgaug-0.2.9/test/test_imgaug.py" startline="188" endline="211" pcid="905">
def test_is_integer_array():
    class _Dummy(object):
        pass
    values_true = [
        np.zeros((1, 2), dtype=np.uint8),
        np.zeros((100,), dtype=np.uint8),
        np.zeros((1, 2), dtype=np.uint16),
        np.zeros((1, 2), dtype=np.int32),
        np.zeros((1, 2), dtype=np.int64)
    ]
    values_false = [
        "A", "BC", "1", "", -100, 1, 0, 1, 100, -1.2, -0.001, 0.0, 0.001, 1.2, 1e-4, True, False,
        (1.0, 2.0), [1.0, 2.0], _Dummy(),
        np.zeros((1, 2), dtype=np.float16),
        np.zeros((100,), dtype=np.float32),
        np.zeros((1, 2), dtype=np.float64),
        np.zeros((1, 2), dtype=np.bool)
    ]
    for value in values_true:
        assert ia.is_integer_array(value) is True
    for value in values_false:
        assert ia.is_integer_array(value) is False


</source>
<source file="systems/imgaug-0.2.9/test/test_imgaug.py" startline="212" endline="236" pcid="906">
def test_is_float_array():
    class _Dummy(object):
        pass

    values_true = [
        np.zeros((1, 2), dtype=np.float16),
        np.zeros((100,), dtype=np.float32),
        np.zeros((1, 2), dtype=np.float64)
    ]
    values_false = [
        "A", "BC", "1", "", -100, 1, 0, 1, 100, -1.2, -0.001, 0.0, 0.001, 1.2, 1e-4, True, False,
        (1.0, 2.0), [1.0, 2.0], _Dummy(),
        np.zeros((1, 2), dtype=np.uint8),
        np.zeros((100,), dtype=np.uint8),
        np.zeros((1, 2), dtype=np.uint16),
        np.zeros((1, 2), dtype=np.int32),
        np.zeros((1, 2), dtype=np.int64),
        np.zeros((1, 2), dtype=np.bool)
    ]
    for value in values_true:
        assert ia.is_float_array(value) is True
    for value in values_false:
        assert ia.is_float_array(value) is False


</source>
</class>

<class classid="56" nclones="2" nlines="13" similarity="92">
<source file="systems/imgaug-0.2.9/test/test_imgaug.py" startline="486" endline="503" pcid="922">
def test_quokka_heatmap():
    hm = ia.quokka_heatmap()
    assert hm.shape == (643, 960, 3)
    assert hm.arr_0to1.shape == (643, 960, 1)
    assert np.allclose(np.average(hm.arr_0to1), 0.57618505)

    hm = ia.quokka_heatmap(extract="square")
    assert hm.shape == (643, 643, 3)
    assert hm.arr_0to1.shape == (643, 643, 1)
    # TODO this value is 0.48026073 in python 2.7, while 0.48026952 in 3.7 -- why?
    assert np.allclose(np.average(hm.arr_0to1), 0.48026952, atol=1e-4)

    hm = ia.quokka_heatmap(size=(642, 959))
    assert hm.shape == (642, 959, 3)
    assert hm.arr_0to1.shape == (642, 959, 1)
    assert np.allclose(np.average(hm.arr_0to1), 0.5762454)


</source>
<source file="systems/imgaug-0.2.9/test/test_imgaug.py" startline="504" endline="520" pcid="923">
def test_quokka_segmentation_map():
    segmap = ia.quokka_segmentation_map()
    assert segmap.shape == (643, 960, 3)
    assert segmap.arr.shape == (643, 960, 1)
    assert np.allclose(np.average(segmap.arr), 0.3016427)

    segmap = ia.quokka_segmentation_map(extract="square")
    assert segmap.shape == (643, 643, 3)
    assert segmap.arr.shape == (643, 643, 1)
    assert np.allclose(np.average(segmap.arr), 0.450353)

    segmap = ia.quokka_segmentation_map(size=(642, 959))
    assert segmap.shape == (642, 959, 3)
    assert segmap.arr.shape == (642, 959, 1)
    assert np.allclose(np.average(segmap.arr), 0.30160266)


</source>
</class>

<class classid="57" nclones="2" nlines="26" similarity="80">
<source file="systems/imgaug-0.2.9/test/test_imgaug.py" startline="521" endline="551" pcid="924">
def test_quokka_keypoints():
    kpsoi = ia.quokka_keypoints()
    assert len(kpsoi.keypoints) > 0
    assert np.allclose(kpsoi.keypoints[0].x, 163.0)
    assert np.allclose(kpsoi.keypoints[0].y, 78.0)
    assert kpsoi.shape == (643, 960, 3)

    img = ia.quokka()
    patches = []
    for kp in kpsoi.keypoints:
        bb = ia.BoundingBox(x1=kp.x-1, x2=kp.x+2, y1=kp.y-1, y2=kp.y+2)
        patches.append(bb.extract_from_image(img))

    img_square = ia.quokka(extract="square")
    kpsoi_square = ia.quokka_keypoints(extract="square")
    assert len(kpsoi.keypoints) == len(kpsoi_square.keypoints)
    assert kpsoi_square.shape == (643, 643, 3)

    for kp, patch in zip(kpsoi_square.keypoints, patches):
        bb = ia.BoundingBox(x1=kp.x-1, x2=kp.x+2, y1=kp.y-1, y2=kp.y+2)
        patch_square = bb.extract_from_image(img_square)
        assert np.average(np.abs(patch.astype(np.float32) - patch_square.astype(np.float32))) < 1.0

    kpsoi_resized = ia.quokka_keypoints(size=(642, 959))
    assert kpsoi_resized.shape == (642, 959, 3)
    assert len(kpsoi.keypoints) == len(kpsoi_resized.keypoints)
    for kp, kp_resized in zip(kpsoi.keypoints, kpsoi_resized.keypoints):
        d = np.sqrt((kp.x - kp_resized.x) ** 2 + (kp.y - kp_resized.y) ** 2)
        assert d < 1.0


</source>
<source file="systems/imgaug-0.2.9/test/test_imgaug.py" startline="552" endline="583" pcid="925">
def test_quokka_bounding_boxes():
    bbsoi = ia.quokka_bounding_boxes()
    assert len(bbsoi.bounding_boxes) > 0
    bb0 = bbsoi.bounding_boxes[0]
    assert np.allclose(bb0.x1, 148.0)
    assert np.allclose(bb0.y1, 50.0)
    assert np.allclose(bb0.x2, 550.0)
    assert np.allclose(bb0.y2, 642.0)
    assert bbsoi.shape == (643, 960, 3)

    img = ia.quokka()
    patches = []
    for bb in bbsoi.bounding_boxes:
        patches.append(bb.extract_from_image(img))

    img_square = ia.quokka(extract="square")
    bbsoi_square = ia.quokka_bounding_boxes(extract="square")
    assert len(bbsoi.bounding_boxes) == len(bbsoi_square.bounding_boxes)
    assert bbsoi_square.shape == (643, 643, 3)

    for bb, patch in zip(bbsoi_square.bounding_boxes, patches):
        patch_square = bb.extract_from_image(img_square)
        assert np.average(np.abs(patch.astype(np.float32) - patch_square.astype(np.float32))) < 1.0

    bbsoi_resized = ia.quokka_bounding_boxes(size=(642, 959))
    assert bbsoi_resized.shape == (642, 959, 3)
    assert len(bbsoi.bounding_boxes) == len(bbsoi_resized.bounding_boxes)
    for bb, bb_resized in zip(bbsoi.bounding_boxes, bbsoi_resized.bounding_boxes):
        d = np.sqrt((bb.center_x - bb_resized.center_x) ** 2 + (bb.center_y - bb_resized.center_y) ** 2)
        assert d < 1.0


</source>
</class>

<class classid="58" nclones="2" nlines="13" similarity="100">
<source file="systems/imgaug-0.2.9/test/test_imgaug.py" startline="1713" endline="1729" pcid="936">
    arr_pooled = ia.pool(arr, 2, np.average, cval=22)
    assert arr_pooled.shape == (2, 2)
    assert arr_pooled.dtype == arr.dtype.type
    assert arr_pooled[0, 0] == int(np.average([0, 1, 4, 5]))
    assert arr_pooled[0, 1] == int(np.average([2, 22, 6, 22]))
    assert arr_pooled[1, 0] == int(np.average([8, 9, 22, 22]))
    assert arr_pooled[1, 1] == int(np.average([10, 22, 22, 22]))


def test_avg_pool():
    # very basic test, as avg_pool() just calls pool(), which is tested in test_pool()
    arr = np.uint8([
        [0, 1, 2, 3],
        [4, 5, 6, 7],
        [8, 9, 10, 11],
        [12, 13, 14, 15]
    ])
</source>
<source file="systems/imgaug-0.2.9/test/test_imgaug.py" startline="1730" endline="1746" pcid="937">
    arr_pooled = ia.avg_pool(arr, 2)
    assert arr_pooled.shape == (2, 2)
    assert arr_pooled.dtype == arr.dtype.type
    assert arr_pooled[0, 0] == int(np.average([0, 1, 4, 5]))
    assert arr_pooled[0, 1] == int(np.average([2, 3, 6, 7]))
    assert arr_pooled[1, 0] == int(np.average([8, 9, 12, 13]))
    assert arr_pooled[1, 1] == int(np.average([10, 11, 14, 15]))


def test_max_pool():
    # very basic test, as avg_pool() just calls pool(), which is tested in test_pool()
    arr = np.uint8([
        [0, 1, 2, 3],
        [4, 5, 6, 7],
        [8, 9, 10, 11],
        [12, 13, 14, 15]
    ])
</source>
</class>

<class classid="59" nclones="2" nlines="10" similarity="100">
<source file="systems/imgaug-0.2.9/test/augmenters/test_weather.py" startline="128" endline="143" pcid="950">
def test_Clouds():
    # rough test as fairly hard to test more detailed
    reseed()

    img = np.zeros((100, 100, 3), dtype=np.uint8)
    img_aug = iaa.Clouds().augment_image(img)
    assert 20 < np.average(img_aug) < 250
    assert np.max(img_aug) > 150

    grad_x = img_aug[:, 1:].astype(np.float32) - img_aug[:, :-1].astype(np.float32)
    grad_y = img_aug[1:, :].astype(np.float32) - img_aug[:-1, :].astype(np.float32)

    assert np.sum(np.abs(grad_x)) > 5 * img.shape[1]
    assert np.sum(np.abs(grad_y)) > 5 * img.shape[0]


</source>
<source file="systems/imgaug-0.2.9/test/augmenters/test_weather.py" startline="144" endline="159" pcid="951">
def test_Fog():
    # rough test as fairly hard to test more detailed
    reseed()

    img = np.zeros((100, 100, 3), dtype=np.uint8)
    img_aug = iaa.Clouds().augment_image(img)
    assert 50 < np.average(img_aug) < 255
    assert np.max(img_aug) > 100

    grad_x = img_aug[:, 1:].astype(np.float32) - img_aug[:, :-1].astype(np.float32)
    grad_y = img_aug[1:, :].astype(np.float32) - img_aug[:-1, :].astype(np.float32)

    assert np.sum(np.abs(grad_x)) > 1 * img.shape[1]
    assert np.sum(np.abs(grad_y)) > 1 * img.shape[0]


</source>
</class>

<class classid="60" nclones="6" nlines="12" similarity="70">
<source file="systems/imgaug-0.2.9/test/augmenters/test_geometric.py" startline="18" endline="31" pcid="954">
def main():
    time_start = time.time()

    test_Affine()
    test_AffineCv2()
    test_PiecewiseAffine()
    test_PerspectiveTransform()
    test_ElasticTransformation()
    test_Rot90()

    time_end = time.time()
    print("<%s> Finished without errors in %.4fs." % (__file__, time_end - time_start,))


</source>
<source file="systems/imgaug-0.2.9/test/augmenters/test_size.py" startline="19" endline="35" pcid="1107">
def main():
    time_start = time.time()

    test__handle_position_parameter()

    test_Resize()
    # TODO test_CropAndPad()
    test_Pad()
    test_Crop()
    test_PadToFixedSize()
    test_CropToFixedSize()
    test_KeepSizeByResize()

    time_end = time.time()
    print("<%s> Finished without errors in %.4fs." % (__file__, time_end - time_start,))


</source>
<source file="systems/imgaug-0.2.9/test/augmentables/test_heatmaps.py" startline="24" endline="51" pcid="1244">
def main():
    time_start = time.time()

    # test_HooksImages_is_activated()
    # test_HooksImages_is_propagating()
    # test_HooksImages_preprocess()
    # test_HooksImages_postprocess()
    # test_HeatmapsOnImage_get_arr()
    # test_HeatmapsOnImage_find_global_maxima()
    test_HeatmapsOnImage_draw()
    test_HeatmapsOnImage_draw_on_image()
    test_HeatmapsOnImage_invert()
    test_HeatmapsOnImage_pad()
    test_HeatmapsOnImage_pad_to_aspect_ratio()
    test_HeatmapsOnImage_avg_pool()
    test_HeatmapsOnImage_max_pool()
    test_HeatmapsOnImage_scale()
    # test_HeatmapsOnImage_to_uint8()
    test_HeatmapsOnImage_from_uint8()
    # test_HeatmapsOnImage_from_0to1()
    test_HeatmapsOnImage_change_normalization()
    # test_HeatmapsOnImage_copy()
    # test_HeatmapsOnImage_deepcopy()

    time_end = time.time()
    print("<%s> Finished without errors in %.4fs." % (__file__, time_end - time_start,))


</source>
<source file="systems/imgaug-0.2.9/test/augmentables/test_segmaps.py" startline="24" endline="43" pcid="1232">
def main():
    time_start = time.time()

    test_SegmentationMapOnImage_bool()
    test_SegmentationMapOnImage_get_arr_int()
    # test_SegmentationMapOnImage_get_arr_bool()
    test_SegmentationMapOnImage_draw()
    test_SegmentationMapOnImage_draw_on_image()
    test_SegmentationMapOnImage_pad()
    test_SegmentationMapOnImage_pad_to_aspect_ratio()
    test_SegmentationMapOnImage_scale()
    test_SegmentationMapOnImage_to_heatmaps()
    test_SegmentationMapOnImage_from_heatmaps()
    test_SegmentationMapOnImage_copy()
    test_SegmentationMapOnImage_deepcopy()

    time_end = time.time()
    print("<%s> Finished without errors in %.4fs." % (__file__, time_end - time_start,))


</source>
<source file="systems/imgaug-0.2.9/test/augmenters/test_arithmetic.py" startline="18" endline="42" pcid="1074">
def main():
    time_start = time.time()

    test_Add()
    test_AddElementwise()
    test_AdditiveGaussianNoise()
    test_Multiply()
    test_MultiplyElementwise()
    test_Dropout()
    test_CoarseDropout()
    test_SaltAndPepper()
    test_CoarseSaltAndPepper()
    test_Salt()
    test_CoarseSalt()
    test_Pepper()
    test_CoarsePepper()
    test_ReplaceElementwise()
    test_Invert()
    # test_ContrastNormalization()
    test_JpegCompression()

    time_end = time.time()
    print("<%s> Finished without errors in %.4fs." % (__file__, time_end - time_start,))


</source>
<source file="systems/imgaug-0.2.9/test/test_readme_examples.py" startline="18" endline="32" pcid="1260">
def main():
    example_standard_situation()
    example_heavy_augmentations()
    example_show()
    #example_grayscale()
    example_determinism()
    example_keypoints()
    example_single_augmenters()
    example_withchannels()
    example_unusual_distributions()
    example_hooks()
    example_background_augment_batches()
    example_background_pool()


</source>
</class>

<class classid="61" nclones="3" nlines="45" similarity="77">
<source file="systems/imgaug-0.2.9/test/augmenters/test_contrast.py" startline="861" endline="928" pcid="1017">
    def _test_single_image_3d_rgb_to_x(self, to_colorspace, channel_idx):
        img = [
            [0, 1, 2, 3, 4],
            [5, 6, 7, 8, 9],
            [10, 11, 12, 13, 14]
        ]
        img = np.uint8(img)
        img3d = np.tile(img[..., np.newaxis], (1, 1, 3))
        img3d[..., 1] += 10
        img3d[..., 2] += 20

        def side_effect_change_colorspace(imgs_call, _random_state, _parents, _hooks):
            return [imgs_call[0] + 1]

        def side_effect_all_channel_clahe(imgs_call, _random_state, _parents, _hooks):
            return [imgs_call[0] + 2]

        def side_effect_change_colorspace_inv(imgs_call, _random_state, _parents, _hooks):
            return [imgs_call[0] + 3]

        mock_change_colorspace = mock.Mock()
        mock_change_colorspace._augment_images.side_effect = side_effect_change_colorspace
        mock_change_colorspace.to_colorspace = iap.Deterministic(to_colorspace)
        mock_all_channel_clahe = mock.Mock()
        mock_all_channel_clahe._augment_images.side_effect = side_effect_all_channel_clahe
        mock_change_colorspace_inv = mock.Mock()
        mock_change_colorspace_inv._augment_images.side_effect = side_effect_change_colorspace_inv

        clahe = iaa.CLAHE(clip_limit=1, tile_grid_size_px=3, tile_grid_size_px_min=2,
                          from_colorspace=iaa.CLAHE.RGB,
                          to_colorspace=to_colorspace)
        clahe.all_channel_clahe = mock_all_channel_clahe
        clahe.intensity_channel_based_applier.change_colorspace = mock_change_colorspace
        clahe.intensity_channel_based_applier.change_colorspace_inv = mock_change_colorspace_inv

        img3d_aug = clahe.augment_image(np.copy(img3d))
        expected1 = img3d + 1
        expected2 = np.copy(expected1)
        expected2[..., channel_idx] += 2
        expected3 = np.copy(expected2) + 3
        assert np.array_equal(img3d_aug, expected3)

        mock_change_colorspace = mock_change_colorspace._augment_images
        mock_all_channel_clahe = mock_all_channel_clahe._augment_images
        mock_change_colorspace_inv = mock_change_colorspace_inv._augment_images

        assert mock_change_colorspace.call_count == 1
        assert mock_all_channel_clahe.call_count == 1
        assert mock_change_colorspace_inv.call_count == 1

        # indices: call 0, args, arg 0, image 0 in list of images
        assert np.array_equal(mock_change_colorspace.call_args_list[0][0][0][0], img3d)

        # for some unclear reason, call_args_list here seems to contain the output instead of the input
        # to side_effect_all_channel_clahe, so this assert is deactivated for now
        # print("mock", mock_all_channel_clahe.call_args_list[0][0][0][0].shape)
        # print("mock", mock_all_channel_clahe.call_args_list[0][0][0][0][..., 0])
        # print("exp ", expected1[..., channel_idx])
        # assert np.array_equal(
        #     mock_all_channel_clahe.call_args_list[0][0][0][0],
        #     expected1[..., channel_idx:channel_idx+1]
        # )

        assert np.array_equal(
            mock_change_colorspace_inv.call_args_list[0][0][0][0],
            expected2
        )

</source>
<source file="systems/imgaug-0.2.9/test/augmenters/test_contrast.py" startline="1007" endline="1069" pcid="1028">
    def test_single_image_5d_rgb_to_lab(self):
        img = [
            [0, 1, 2, 3, 4],
            [5, 6, 7, 8, 9],
            [10, 11, 12, 13, 14]
        ]
        img = np.uint8(img)
        img5d = np.tile(img[..., np.newaxis], (1, 1, 5))
        img5d[..., 1] += 10
        img5d[..., 2] += 20
        img5d[..., 3] += 30
        img5d[..., 4] += 40

        def side_effect_change_colorspace(imgs_call, _random_state, _parents, _hooks):
            return [imgs_call[0] + 1]

        def side_effect_all_channel_clahe(imgs_call, _random_state, _parents, _hooks):
            return [imgs_call[0] + 2]

        def side_effect_change_colorspace_inv(imgs_call, _random_state, _parents, _hooks):
            return [imgs_call[0] + 3]

        mock_change_colorspace = mock.Mock()
        mock_change_colorspace._augment_images.side_effect = side_effect_change_colorspace
        mock_all_channel_clahe = mock.Mock()
        mock_all_channel_clahe._augment_images.side_effect = side_effect_all_channel_clahe
        mock_change_colorspace_inv = mock.Mock()
        mock_change_colorspace_inv._augment_images.side_effect = side_effect_change_colorspace_inv

        clahe = iaa.CLAHE(clip_limit=1, tile_grid_size_px=3, tile_grid_size_px_min=2,
                          from_colorspace=iaa.CLAHE.RGB,
                          to_colorspace=iaa.CLAHE.Lab,
                          name="ExampleCLAHE")
        clahe.all_channel_clahe = mock_all_channel_clahe
        clahe.intensity_channel_based_applier.change_colorspace = mock_change_colorspace
        clahe.intensity_channel_based_applier.change_colorspace_inv = mock_change_colorspace_inv

        # note that self.assertWarningRegex does not exist in python 2.7
        with warnings.catch_warnings(record=True) as caught_warnings:
            # Cause all warnings to always be triggered.
            warnings.simplefilter("always")
            # Trigger a warning.
            img5d_aug = clahe.augment_image(img5d)
            # Verify
            assert len(caught_warnings) == 1
            assert "Got image with 5 channels in _IntensityChannelBasedApplier (parents: ExampleCLAHE)" \
                   in str(caught_warnings[-1].message)

        assert np.array_equal(img5d_aug, img5d + 2)

        mock_change_colorspace = mock_change_colorspace._augment_images
        mock_all_channel_clahe = mock_all_channel_clahe._augment_images
        mock_change_colorspace_inv = mock_change_colorspace_inv._augment_images

        assert mock_change_colorspace.call_count == 0
        assert mock_all_channel_clahe.call_count == 1
        assert mock_change_colorspace_inv.call_count == 0

        # indices: call 0, args, arg 0, image 0 in list of images
        assert np.array_equal(
            mock_all_channel_clahe.call_args_list[0][0][0][0],
            img5d
        )
</source>
<source file="systems/imgaug-0.2.9/test/augmenters/test_contrast.py" startline="938" endline="1006" pcid="1024">
    def test_single_image_4d_rgb_to_lab(self):
        channel_idx = 0

        img = [
            [0, 1, 2, 3, 4],
            [5, 6, 7, 8, 9],
            [10, 11, 12, 13, 14]
        ]
        img = np.uint8(img)
        img4d = np.tile(img[..., np.newaxis], (1, 1, 4))
        img4d[..., 1] += 10
        img4d[..., 2] += 20
        img4d[..., 3] += 30

        def side_effect_change_colorspace(imgs_call, _random_state, _parents, _hooks):
            return [imgs_call[0] + 1]

        def side_effect_all_channel_clahe(imgs_call, _random_state, _parents, _hooks):
            return [imgs_call[0] + 2]

        def side_effect_change_colorspace_inv(imgs_call, _random_state, _parents, _hooks):
            return [imgs_call[0] + 3]

        mock_change_colorspace = mock.Mock()
        mock_change_colorspace._augment_images.side_effect = side_effect_change_colorspace
        mock_change_colorspace.to_colorspace = iap.Deterministic(iaa.CLAHE.Lab)
        mock_all_channel_clahe = mock.Mock()
        mock_all_channel_clahe._augment_images.side_effect = side_effect_all_channel_clahe
        mock_change_colorspace_inv = mock.Mock()
        mock_change_colorspace_inv._augment_images.side_effect = side_effect_change_colorspace_inv

        clahe = iaa.CLAHE(clip_limit=1, tile_grid_size_px=3, tile_grid_size_px_min=2,
                          from_colorspace=iaa.CLAHE.RGB,
                          to_colorspace=iaa.CLAHE.Lab)
        clahe.all_channel_clahe = mock_all_channel_clahe
        clahe.intensity_channel_based_applier.change_colorspace = mock_change_colorspace
        clahe.intensity_channel_based_applier.change_colorspace_inv = mock_change_colorspace_inv

        img4d_aug = clahe.augment_image(img4d)
        expected1 = img4d[..., 0:3] + 1
        expected2 = np.copy(expected1)
        expected2[..., channel_idx] += 2
        expected3 = np.copy(expected2) + 3
        expected4 = np.dstack((expected3, img4d[..., 3:4]))
        assert np.array_equal(img4d_aug, expected4)

        mock_change_colorspace = mock_change_colorspace._augment_images
        mock_all_channel_clahe = mock_all_channel_clahe._augment_images
        mock_change_colorspace_inv = mock_change_colorspace_inv._augment_images

        assert mock_change_colorspace.call_count == 1
        assert mock_all_channel_clahe.call_count == 1
        assert mock_change_colorspace_inv.call_count == 1

        # indices: call 0, args, arg 0, image 0 in list of images
        assert np.array_equal(mock_change_colorspace.call_args_list[0][0][0][0], img4d[..., 0:3])

        # for some unclear reason, call_args_list here seems to contain the output instead of the input
        # to side_effect_all_channel_clahe, so this assert is deactivated for now
        # assert np.array_equal(
        #     mock_all_channel_clahe.call_args_list[0][0][0][0],
        #     expected1[..., channel_idx:channel_idx+1]
        # )

        assert np.array_equal(
            mock_change_colorspace_inv.call_args_list[0][0][0][0],
            expected2
        )

</source>
</class>

<class classid="62" nclones="2" nlines="67" similarity="71">
<source file="systems/imgaug-0.2.9/test/augmenters/test_contrast.py" startline="1070" endline="1166" pcid="1032">

    def _test_many_images_rgb_to_lab_list(self, with_3d_images):
        img = [
            [0, 1, 2, 3, 4],
            [5, 6, 7, 8, 9],
            [10, 11, 12, 13, 14]
        ]
        img = np.uint8(img)

        imgs = [
            img,
            img + 1
        ]
        if with_3d_images:
            imgs.extend([
                np.tile(img[..., np.newaxis], (1, 1, 3)) + 2,
                np.tile(img[..., np.newaxis], (1, 1, 3)) + 3,
                np.tile(img[..., np.newaxis], (1, 1, 4)) + 4
            ])

        def side_effect_change_colorspace(imgs_call, _random_state, _parents, _hooks):
            return [img + 1 for img in imgs_call]

        def side_effect_all_channel_clahe(imgs_call, _random_state, _parents, _hooks):
            return [img + 2 for img in imgs_call]

        def side_effect_change_colorspace_inv(imgs_call, _random_state, _parents, _hooks):
            return [img + 3 for img in imgs_call]

        mock_change_colorspace = mock.Mock()
        mock_change_colorspace._augment_images.side_effect = side_effect_change_colorspace
        mock_change_colorspace.to_colorspace = iap.Deterministic(iaa.CLAHE.Lab)
        mock_all_channel_clahe = mock.Mock()
        mock_all_channel_clahe._augment_images.side_effect = side_effect_all_channel_clahe
        mock_change_colorspace_inv = mock.Mock()
        mock_change_colorspace_inv._augment_images.side_effect = side_effect_change_colorspace_inv

        clahe = iaa.CLAHE(clip_limit=1, tile_grid_size_px=3, tile_grid_size_px_min=2,
                          from_colorspace=iaa.CLAHE.RGB,
                          to_colorspace=iaa.CLAHE.Lab)
        clahe.all_channel_clahe = mock_all_channel_clahe
        clahe.intensity_channel_based_applier.change_colorspace = mock_change_colorspace
        clahe.intensity_channel_based_applier.change_colorspace_inv = mock_change_colorspace_inv

        imgs_aug = clahe.augment_images(imgs)
        assert isinstance(imgs_aug, list)

        mock_change_colorspace = mock_change_colorspace._augment_images
        mock_all_channel_clahe = mock_all_channel_clahe._augment_images
        mock_change_colorspace_inv = mock_change_colorspace_inv._augment_images

        assert mock_change_colorspace.call_count == (1 if with_3d_images else 0)
        assert mock_all_channel_clahe.call_count == 1
        assert mock_change_colorspace_inv.call_count == (1 if with_3d_images else 0)

        # indices: call 0, args, arg 0
        if with_3d_images:
            assert isinstance(mock_change_colorspace.call_args_list[0][0][0], list)
            assert isinstance(mock_change_colorspace_inv.call_args_list[0][0][0], list)
        assert isinstance(mock_all_channel_clahe.call_args_list[0][0][0], list)

        if with_3d_images:
            assert len(mock_change_colorspace.call_args_list[0][0][0]) == 3
            assert len(mock_change_colorspace_inv.call_args_list[0][0][0]) == 3
        assert len(mock_all_channel_clahe.call_args_list[0][0][0]) == 5 if with_3d_images else 2

        # indices: call 0, args, arg 0, image i in list of images
        for i in sm.xrange(0, 2):
            expected = imgs[i][..., np.newaxis]
            assert np.array_equal(
                mock_all_channel_clahe.call_args_list[0][0][0][i],
                expected
            )

        if with_3d_images:
            for i in sm.xrange(2, 5):
                expected = imgs[i]
                if expected.shape[2] == 4:
                    expected = expected[..., 0:3]
                assert np.array_equal(
                    mock_change_colorspace.call_args_list[0][0][0][i-2],
                    expected
                )

                # for some unclear reason, call_args_list here seems to contain the output instead of the input
                # to side_effect_all_channel_clahe, so this assert is deactivated for now
                # assert np.array_equal(
                #     mock_all_channel_clahe.call_args_list[0][0][0][i],
                #     (expected + 1)[..., 0:1]
                # )

                exp = (expected + 1)
                exp[..., 0:1] += 2
                assert np.array_equal(
                    mock_change_colorspace_inv.call_args_list[0][0][0][i-2],
                    exp
                )
</source>
<source file="systems/imgaug-0.2.9/test/augmenters/test_contrast.py" startline="1173" endline="1271" pcid="1038">

    def _test_many_images_rgb_to_lab_array(self, nb_channels, nb_images):
        with_color_conversion = True if nb_channels is not None and nb_channels in [3, 4] else False

        img = [
            [0, 1, 2, 3, 4],
            [5, 6, 7, 8, 9],
            [10, 11, 12, 13, 14]
        ]
        img = np.uint8(img)
        if nb_channels is not None:
            img = np.tile(img[..., np.newaxis], (1, 1, nb_channels))

        imgs = [img] * nb_images
        imgs = np.uint8(imgs)

        def side_effect_change_colorspace(imgs_call, _random_state, _parents, _hooks):
            return [img + 1 for img in imgs_call]

        def side_effect_all_channel_clahe(imgs_call, _random_state, _parents, _hooks):
            return [img + 2 for img in imgs_call]

        def side_effect_change_colorspace_inv(imgs_call, _random_state, _parents, _hooks):
            return [img + 3 for img in imgs_call]

        mock_change_colorspace = mock.Mock()
        mock_change_colorspace._augment_images.side_effect = side_effect_change_colorspace
        mock_change_colorspace.to_colorspace = iap.Deterministic(iaa.CLAHE.Lab)
        mock_all_channel_clahe = mock.Mock()
        mock_all_channel_clahe._augment_images.side_effect = side_effect_all_channel_clahe
        mock_change_colorspace_inv = mock.Mock()
        mock_change_colorspace_inv._augment_images.side_effect = side_effect_change_colorspace_inv

        clahe = iaa.CLAHE(clip_limit=1, tile_grid_size_px=3, tile_grid_size_px_min=2,
                          from_colorspace=iaa.CLAHE.RGB,
                          to_colorspace=iaa.CLAHE.Lab)
        clahe.all_channel_clahe = mock_all_channel_clahe
        clahe.intensity_channel_based_applier.change_colorspace = mock_change_colorspace
        clahe.intensity_channel_based_applier.change_colorspace_inv = mock_change_colorspace_inv

        imgs_aug = clahe.augment_images(imgs)
        assert ia.is_np_array(imgs_aug)

        mock_change_colorspace = mock_change_colorspace._augment_images
        mock_all_channel_clahe = mock_all_channel_clahe._augment_images
        mock_change_colorspace_inv = mock_change_colorspace_inv._augment_images

        assert mock_change_colorspace.call_count == (1 if with_color_conversion else 0)
        assert mock_all_channel_clahe.call_count == 1
        assert mock_change_colorspace_inv.call_count == (1 if with_color_conversion else 0)

        # indices: call 0, args, arg 0
        if with_color_conversion:
            assert isinstance(mock_change_colorspace.call_args_list[0][0][0], list)
            assert isinstance(mock_change_colorspace_inv.call_args_list[0][0][0], list)
        assert isinstance(mock_all_channel_clahe.call_args_list[0][0][0], list)

        if with_color_conversion:
            assert len(mock_change_colorspace.call_args_list[0][0][0]) == nb_images
            assert len(mock_change_colorspace_inv.call_args_list[0][0][0]) == nb_images
        assert len(mock_all_channel_clahe.call_args_list[0][0][0]) == nb_images

        # indices: call 0, args, arg 0, image i in list of images
        if not with_color_conversion:
            for i in sm.xrange(nb_images):
                expected = imgs[i]
                if expected.ndim == 2:
                    expected = expected[..., np.newaxis]
                # cant have 4 channels and no color conversion for RGB2Lab

                assert np.array_equal(
                    mock_all_channel_clahe.call_args_list[0][0][0][i],
                    expected
                )
        else:
            for i in sm.xrange(nb_images):
                expected = imgs[i]
                if expected.shape[2] == 4:
                    expected = expected[..., 0:3]
                # cant have color conversion for RGB2Lab and no channel axis

                assert np.array_equal(
                    mock_change_colorspace.call_args_list[0][0][0][i],
                    expected
                )

                # for some unclear reason, call_args_list here seems to contain the output instead of the input
                # to side_effect_all_channel_clahe, so this assert is deactivated for now
                # assert np.array_equal(
                #     mock_all_channel_clahe.call_args_list[0][0][0][i],
                #     (expected + 1)[..., 0:1]
                # )

                exp = (expected + 1)
                exp[..., 0:1] += 2
                assert np.array_equal(
                    mock_change_colorspace_inv.call_args_list[0][0][0][i],
                    exp
                )
</source>
</class>

<class classid="63" nclones="2" nlines="201" similarity="100">
<source file="systems/imgaug-0.2.9/test/augmenters/test_flip.py" startline="41" endline="295" pcid="1068">
def test_Fliplr():
    reseed()

    base_img = np.array([[0, 0, 1],
                         [0, 0, 1],
                         [0, 1, 1]], dtype=np.uint8)
    base_img = base_img[:, :, np.newaxis]

    base_img_flipped = np.array([[1, 0, 0],
                                 [1, 0, 0],
                                 [1, 1, 0]], dtype=np.uint8)
    base_img_flipped = base_img_flipped[:, :, np.newaxis]

    images = np.array([base_img])
    images_flipped = np.array([base_img_flipped])

    keypoints = [ia.KeypointsOnImage([ia.Keypoint(x=0, y=0), ia.Keypoint(x=1, y=1),
                                      ia.Keypoint(x=2, y=2)], shape=base_img.shape)]
    keypoints_flipped = [ia.KeypointsOnImage([ia.Keypoint(x=2, y=0), ia.Keypoint(x=1, y=1),
                                              ia.Keypoint(x=0, y=2)], shape=base_img.shape)]

    polygons = [ia.PolygonsOnImage(
        [ia.Polygon([(0, 0), (2, 0), (2, 2)])],
        shape=base_img.shape)]
    polygons_flipped = [ia.PolygonsOnImage(
        [ia.Polygon([(2, 0), (0, 0), (0, 2)])],
        shape=base_img.shape)]

    # 0% chance of flip
    aug = iaa.Fliplr(0)
    aug_det = aug.to_deterministic()

    for _ in sm.xrange(10):
        observed = aug.augment_images(images)
        expected = images
        assert np.array_equal(observed, expected)

        observed = aug_det.augment_images(images)
        expected = images
        assert np.array_equal(observed, expected)

        observed = aug.augment_keypoints(keypoints)
        expected = keypoints
        assert keypoints_equal(observed, expected)

        observed = aug_det.augment_keypoints(keypoints)
        expected = keypoints
        assert keypoints_equal(observed, expected)

        for aug_ in [aug, aug_det]:
            observed = aug_.augment_polygons(polygons)
            assert len(observed) == 1
            assert len(observed[0].polygons) == 1
            assert observed[0].shape == polygons[0].shape
            assert observed[0].polygons[0].exterior_almost_equals(
                polygons[0].polygons[0])
            assert observed[0].polygons[0].is_valid

    # 0% chance of flip, heatmaps
    aug = iaa.Fliplr(0)
    heatmaps = ia.HeatmapsOnImage(
        np.float32([
            [0, 0.5, 0.75],
            [0, 0.5, 0.75],
            [0.75, 0.75, 0.75],
        ]),
        shape=(3, 3, 3)
    )
    observed = aug.augment_heatmaps([heatmaps])[0]
    expected = heatmaps.get_arr()
    assert observed.shape == heatmaps.shape
    assert heatmaps.min_value - 1e-6 < observed.min_value < heatmaps.min_value + 1e-6
    assert heatmaps.max_value - 1e-6 < observed.max_value < heatmaps.max_value + 1e-6
    assert np.array_equal(observed.get_arr(), expected)

    # 100% chance of flip
    aug = iaa.Fliplr(1.0)
    aug_det = aug.to_deterministic()

    for _ in sm.xrange(10):
        observed = aug.augment_images(images)
        expected = images_flipped
        assert np.array_equal(observed, expected)

        observed = aug_det.augment_images(images)
        expected = images_flipped
        assert np.array_equal(observed, expected)

        observed = aug.augment_keypoints(keypoints)
        expected = keypoints_flipped
        assert keypoints_equal(observed, expected)

        observed = aug_det.augment_keypoints(keypoints)
        expected = keypoints_flipped
        assert keypoints_equal(observed, expected)

        for aug_ in [aug, aug_det]:
            observed = aug_.augment_polygons(polygons)
            assert len(observed) == 1
            assert len(observed[0].polygons) == 1
            assert observed[0].shape == polygons[0].shape
            assert observed[0].polygons[0].exterior_almost_equals(
                polygons_flipped[0].polygons[0])
            assert observed[0].polygons[0].is_valid

    # 100% chance of flip, heatmaps
    aug = iaa.Fliplr(1.0)
    heatmaps = ia.HeatmapsOnImage(
        np.float32([
            [0, 0.5, 0.75],
            [0, 0.5, 0.75],
            [0.75, 0.75, 0.75],
        ]),
        shape=(3, 3, 3)
    )
    observed = aug.augment_heatmaps([heatmaps])[0]
    expected = np.fliplr(heatmaps.get_arr())
    assert observed.shape == heatmaps.shape
    assert heatmaps.min_value - 1e-6 < observed.min_value < heatmaps.min_value + 1e-6
    assert heatmaps.max_value - 1e-6 < observed.max_value < heatmaps.max_value + 1e-6
    assert np.array_equal(observed.get_arr(), expected)

    # 50% chance of flip
    aug = iaa.Fliplr(0.5)
    aug_det = aug.to_deterministic()

    nb_iterations = 1000
    nb_images_flipped = 0
    nb_images_flipped_det = 0
    nb_keypoints_flipped = 0
    nb_keypoints_flipped_det = 0
    nb_polygons_flipped = 0
    nb_polygons_flipped_det = 0
    for _ in sm.xrange(nb_iterations):
        observed = aug.augment_images(images)
        if np.array_equal(observed, images_flipped):
            nb_images_flipped += 1

        observed = aug_det.augment_images(images)
        if np.array_equal(observed, images_flipped):
            nb_images_flipped_det += 1

        observed = aug.augment_keypoints(keypoints)
        if keypoints_equal(observed, keypoints_flipped):
            nb_keypoints_flipped += 1

        observed = aug_det.augment_keypoints(keypoints)
        if keypoints_equal(observed, keypoints_flipped):
            nb_keypoints_flipped_det += 1

        observed = aug.augment_polygons(polygons)
        if observed[0].polygons[0].exterior_almost_equals(
                polygons_flipped[0].polygons[0]):
            nb_polygons_flipped += 1

        observed = aug_det.augment_polygons(polygons)
        if observed[0].polygons[0].exterior_almost_equals(
                polygons_flipped[0].polygons[0]):
            nb_polygons_flipped_det += 1

    assert int(nb_iterations * 0.3) <= nb_images_flipped <= int(nb_iterations * 0.7)
    assert int(nb_iterations * 0.3) <= nb_keypoints_flipped <= int(nb_iterations * 0.7)
    assert int(nb_iterations * 0.3) <= nb_polygons_flipped <= int(nb_iterations * 0.7)
    assert nb_images_flipped_det in [0, nb_iterations]
    assert nb_keypoints_flipped_det in [0, nb_iterations]
    assert nb_polygons_flipped_det in [0, nb_iterations]

    # 50% chance of flipped, multiple images, list as input
    images_multi = [base_img, base_img]
    aug = iaa.Fliplr(0.5)
    aug_det = aug.to_deterministic()
    nb_iterations = 1000
    nb_flipped_by_pos = [0] * len(images_multi)
    nb_flipped_by_pos_det = [0] * len(images_multi)
    for _ in sm.xrange(nb_iterations):
        observed = aug.augment_images(images_multi)
        for i in sm.xrange(len(images_multi)):
            if np.array_equal(observed[i], base_img_flipped):
                nb_flipped_by_pos[i] += 1

        observed = aug_det.augment_images(images_multi)
        for i in sm.xrange(len(images_multi)):
            if np.array_equal(observed[i], base_img_flipped):
                nb_flipped_by_pos_det[i] += 1

    for val in nb_flipped_by_pos:
        assert int(nb_iterations * 0.3) <= val <= int(nb_iterations * 0.7)

    for val in nb_flipped_by_pos_det:
        assert val in [0, nb_iterations]

    # test StochasticParameter as p
    aug = iaa.Fliplr(p=iap.Choice([0, 1], p=[0.7, 0.3]))
    seen = [0, 0]
    for _ in sm.xrange(1000):
        observed = aug.augment_image(base_img)
        if np.array_equal(observed, base_img):
            seen[0] += 1
        elif np.array_equal(observed, base_img_flipped):
            seen[1] += 1
        else:
            assert False
    assert 700 - 75 < seen[0] < 700 + 75
    assert 300 - 75 < seen[1] < 300 + 75

    # test exceptions for wrong parameter types
    got_exception = False
    try:
        _ = iaa.Fliplr(p="test")
    except Exception:
        got_exception = True
    assert got_exception

    # test get_parameters()
    aug = iaa.Fliplr(p=0.5)
    params = aug.get_parameters()
    assert isinstance(params[0], iap.Binomial)
    assert isinstance(params[0].p, iap.Deterministic)
    assert 0.5 - 1e-4 < params[0].p.value < 0.5 + 1e-4

    ###################
    # test other dtypes
    ###################
    aug = iaa.Fliplr(1.0)

    image = np.zeros((3, 3), dtype=bool)
    image[0, 0] = True
    expected = np.zeros((3, 3), dtype=bool)
    expected[0, 2] = True
    image_aug = aug.augment_image(image)
    assert image_aug.dtype.type == image.dtype.type
    assert np.all(image_aug == expected)

    for dtype in [np.uint8, np.uint16, np.uint32, np.uint64, np.int8, np.int32, np.int64]:
        min_value, center_value, max_value = iadt.get_value_range_of_dtype(dtype)
        value = max_value
        image = np.zeros((3, 3), dtype=dtype)
        image[0, 0] = value
        expected = np.zeros((3, 3), dtype=dtype)
        expected[0, 2] = value
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert np.array_equal(image_aug, expected)

    for dtype, value in zip([np.float16, np.float32, np.float64, np.float128], [5000, 1000**2, 1000**3, 1000**4]):
        atol = 1e-9 * max_value if dtype != np.float16 else 1e-3 * max_value
        image = np.zeros((3, 3), dtype=dtype)
        image[0, 0] = value
        expected = np.zeros((3, 3), dtype=dtype)
        expected[0, 2] = value
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert np.allclose(image_aug, expected, atol=atol)


</source>
<source file="systems/imgaug-0.2.9/test/augmenters/test_flip.py" startline="296" endline="550" pcid="1069">
def test_Flipud():
    reseed()

    base_img = np.array([[0, 0, 1],
                         [0, 0, 1],
                         [0, 1, 1]], dtype=np.uint8)
    base_img = base_img[:, :, np.newaxis]

    base_img_flipped = np.array([[0, 1, 1],
                                 [0, 0, 1],
                                 [0, 0, 1]], dtype=np.uint8)
    base_img_flipped = base_img_flipped[:, :, np.newaxis]

    images = np.array([base_img])
    images_flipped = np.array([base_img_flipped])

    keypoints = [ia.KeypointsOnImage([ia.Keypoint(x=0, y=0), ia.Keypoint(x=1, y=1),
                                      ia.Keypoint(x=2, y=2)], shape=base_img.shape)]
    keypoints_flipped = [ia.KeypointsOnImage([ia.Keypoint(x=0, y=2), ia.Keypoint(x=1, y=1),
                                              ia.Keypoint(x=2, y=0)], shape=base_img.shape)]

    polygons = [ia.PolygonsOnImage(
        [ia.Polygon([(0, 0), (2, 0), (2, 2)])],
        shape=base_img.shape)]
    polygons_flipped = [ia.PolygonsOnImage(
        [ia.Polygon([(0, 2), (2, 2), (2, 0)])],
        shape=base_img.shape)]

    # 0% chance of flip
    aug = iaa.Flipud(0)
    aug_det = aug.to_deterministic()

    for _ in sm.xrange(10):
        observed = aug.augment_images(images)
        expected = images
        assert np.array_equal(observed, expected)

        observed = aug_det.augment_images(images)
        expected = images
        assert np.array_equal(observed, expected)

        observed = aug.augment_keypoints(keypoints)
        expected = keypoints
        assert keypoints_equal(observed, expected)

        observed = aug_det.augment_keypoints(keypoints)
        expected = keypoints
        assert keypoints_equal(observed, expected)

        for aug_ in [aug, aug_det]:
            observed = aug_.augment_polygons(polygons)
            assert len(observed) == 1
            assert len(observed[0].polygons) == 1
            assert observed[0].shape == polygons[0].shape
            assert observed[0].polygons[0].exterior_almost_equals(
                polygons[0].polygons[0])
            assert observed[0].polygons[0].is_valid

    # 0% chance of flip, heatmaps
    aug = iaa.Flipud(0)
    heatmaps = ia.HeatmapsOnImage(
        np.float32([
            [0, 0.5, 0.75],
            [0, 0.5, 0.75],
            [0.75, 0.75, 0.75],
        ]),
        shape=(3, 3, 3)
    )
    observed = aug.augment_heatmaps([heatmaps])[0]
    expected = heatmaps.get_arr()
    assert observed.shape == heatmaps.shape
    assert heatmaps.min_value - 1e-6 < observed.min_value < heatmaps.min_value + 1e-6
    assert heatmaps.max_value - 1e-6 < observed.max_value < heatmaps.max_value + 1e-6
    assert np.array_equal(observed.get_arr(), expected)

    # 100% chance of flip
    aug = iaa.Flipud(1.0)
    aug_det = aug.to_deterministic()

    for _ in sm.xrange(10):
        observed = aug.augment_images(images)
        expected = images_flipped
        assert np.array_equal(observed, expected)

        observed = aug_det.augment_images(images)
        expected = images_flipped
        assert np.array_equal(observed, expected)

        observed = aug.augment_keypoints(keypoints)
        expected = keypoints_flipped
        assert keypoints_equal(observed, expected)

        observed = aug_det.augment_keypoints(keypoints)
        expected = keypoints_flipped
        assert keypoints_equal(observed, expected)

        for aug_ in [aug, aug_det]:
            observed = aug_.augment_polygons(polygons)
            assert len(observed) == 1
            assert len(observed[0].polygons) == 1
            assert observed[0].shape == polygons[0].shape
            assert observed[0].polygons[0].exterior_almost_equals(
                polygons_flipped[0].polygons[0])
            assert observed[0].polygons[0].is_valid

    # 100% chance of flip, heatmaps
    aug = iaa.Flipud(1.0)
    heatmaps = ia.HeatmapsOnImage(
        np.float32([
            [0, 0.5, 0.75],
            [0, 0.5, 0.75],
            [0.75, 0.75, 0.75],
        ]),
        shape=(3, 3, 3)
    )
    observed = aug.augment_heatmaps([heatmaps])[0]
    expected = np.flipud(heatmaps.get_arr())
    assert observed.shape == heatmaps.shape
    assert heatmaps.min_value - 1e-6 < observed.min_value < heatmaps.min_value + 1e-6
    assert heatmaps.max_value - 1e-6 < observed.max_value < heatmaps.max_value + 1e-6
    assert np.array_equal(observed.get_arr(), expected)

    # 50% chance of flip
    aug = iaa.Flipud(0.5)
    aug_det = aug.to_deterministic()

    nb_iterations = 1000
    nb_images_flipped = 0
    nb_images_flipped_det = 0
    nb_keypoints_flipped = 0
    nb_keypoints_flipped_det = 0
    nb_polygons_flipped = 0
    nb_polygons_flipped_det = 0
    for _ in sm.xrange(nb_iterations):
        observed = aug.augment_images(images)
        if np.array_equal(observed, images_flipped):
            nb_images_flipped += 1

        observed = aug_det.augment_images(images)
        if np.array_equal(observed, images_flipped):
            nb_images_flipped_det += 1

        observed = aug.augment_keypoints(keypoints)
        if keypoints_equal(observed, keypoints_flipped):
            nb_keypoints_flipped += 1

        observed = aug_det.augment_keypoints(keypoints)
        if keypoints_equal(observed, keypoints_flipped):
            nb_keypoints_flipped_det += 1

        observed = aug.augment_polygons(polygons)
        if observed[0].polygons[0].exterior_almost_equals(
                polygons_flipped[0].polygons[0]):
            nb_polygons_flipped += 1

        observed = aug_det.augment_polygons(polygons)
        if observed[0].polygons[0].exterior_almost_equals(
                polygons_flipped[0].polygons[0]):
            nb_polygons_flipped_det += 1

    assert int(nb_iterations * 0.3) <= nb_images_flipped <= int(nb_iterations * 0.7)
    assert int(nb_iterations * 0.3) <= nb_keypoints_flipped <= int(nb_iterations * 0.7)
    assert int(nb_iterations * 0.3) <= nb_polygons_flipped <= int(nb_iterations * 0.7)
    assert nb_images_flipped_det in [0, nb_iterations]
    assert nb_keypoints_flipped_det in [0, nb_iterations]
    assert nb_polygons_flipped_det in [0, nb_iterations]

    # 50% chance of flipped, multiple images, list as input
    images_multi = [base_img, base_img]
    aug = iaa.Flipud(0.5)
    aug_det = aug.to_deterministic()
    nb_iterations = 1000
    nb_flipped_by_pos = [0] * len(images_multi)
    nb_flipped_by_pos_det = [0] * len(images_multi)
    for _ in sm.xrange(nb_iterations):
        observed = aug.augment_images(images_multi)
        for i in sm.xrange(len(images_multi)):
            if np.array_equal(observed[i], base_img_flipped):
                nb_flipped_by_pos[i] += 1

        observed = aug_det.augment_images(images_multi)
        for i in sm.xrange(len(images_multi)):
            if np.array_equal(observed[i], base_img_flipped):
                nb_flipped_by_pos_det[i] += 1

    for val in nb_flipped_by_pos:
        assert int(nb_iterations * 0.3) <= val <= int(nb_iterations * 0.7)

    for val in nb_flipped_by_pos_det:
        assert val in [0, nb_iterations]

    # test StochasticParameter as p
    aug = iaa.Flipud(p=iap.Choice([0, 1], p=[0.7, 0.3]))
    seen = [0, 0]
    for _ in sm.xrange(1000):
        observed = aug.augment_image(base_img)
        if np.array_equal(observed, base_img):
            seen[0] += 1
        elif np.array_equal(observed, base_img_flipped):
            seen[1] += 1
        else:
            assert False
    assert 700 - 75 < seen[0] < 700 + 75
    assert 300 - 75 < seen[1] < 300 + 75

    # test exceptions for wrong parameter types
    got_exception = False
    try:
        _ = iaa.Flipud(p="test")
    except Exception:
        got_exception = True
    assert got_exception

    # test get_parameters()
    aug = iaa.Flipud(p=0.5)
    params = aug.get_parameters()
    assert isinstance(params[0], iap.Binomial)
    assert isinstance(params[0].p, iap.Deterministic)
    assert 0.5 - 1e-4 < params[0].p.value < 0.5 + 1e-4

    ###################
    # test other dtypes
    ###################
    aug = iaa.Flipud(1.0)

    image = np.zeros((3, 3), dtype=bool)
    image[0, 0] = True
    expected = np.zeros((3, 3), dtype=bool)
    expected[2, 0] = True
    image_aug = aug.augment_image(image)
    assert image_aug.dtype.type == image.dtype.type
    assert np.all(image_aug == expected)

    for dtype in [np.uint8, np.uint16, np.uint32, np.uint64, np.int8, np.int32, np.int64]:
        min_value, center_value, max_value = iadt.get_value_range_of_dtype(dtype)
        value = max_value
        image = np.zeros((3, 3), dtype=dtype)
        image[0, 0] = value
        expected = np.zeros((3, 3), dtype=dtype)
        expected[2, 0] = value
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert np.array_equal(image_aug, expected)

    for dtype, value in zip([np.float16, np.float32, np.float64, np.float128], [5000, 1000 ** 2, 1000 ** 3, 1000 ** 4]):
        atol = 1e-9 * max_value if dtype != np.float16 else 1e-3 * max_value
        image = np.zeros((3, 3), dtype=dtype)
        image[0, 0] = value
        expected = np.zeros((3, 3), dtype=dtype)
        expected[2, 0] = value
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert np.allclose(image_aug, expected, atol=atol)


</source>
</class>

<class classid="64" nclones="4" nlines="321" similarity="71">
<source file="systems/imgaug-0.2.9/test/augmenters/test_arithmetic.py" startline="414" endline="801" pcid="1078">
    hm_aug = aug.augment_heatmaps([hm])[0]
    assert np.allclose(hm.arr_0to1, hm_aug.arr_0to1)


def test_Multiply():
    reseed()

    base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
    images = np.array([base_img])
    images_list = [base_img]
    keypoints = [ia.KeypointsOnImage([ia.Keypoint(x=0, y=0), ia.Keypoint(x=1, y=1),
                                      ia.Keypoint(x=2, y=2)], shape=base_img.shape)]

    # no multiply, shouldnt change anything
    aug = iaa.Multiply(mul=1.0)
    aug_det = aug.to_deterministic()

    observed = aug.augment_images(images)
    expected = images
    assert np.array_equal(observed, expected)

    observed = aug.augment_images(images_list)
    expected = images_list
    assert array_equal_lists(observed, expected)

    observed = aug_det.augment_images(images)
    expected = images
    assert np.array_equal(observed, expected)

    observed = aug_det.augment_images(images_list)
    expected = images_list
    assert array_equal_lists(observed, expected)

    # multiply >1.0
    aug = iaa.Multiply(mul=1.2)
    aug_det = aug.to_deterministic()

    observed = aug.augment_images(images)
    expected = np.ones((1, 3, 3, 1), dtype=np.uint8) * 120
    assert np.array_equal(observed, expected)

    observed = aug.augment_images(images_list)
    expected = [np.ones((3, 3, 1), dtype=np.uint8) * 120]
    assert array_equal_lists(observed, expected)

    observed = aug_det.augment_images(images)
    expected = np.ones((1, 3, 3, 1), dtype=np.uint8) * 120
    assert np.array_equal(observed, expected)

    observed = aug_det.augment_images(images_list)
    expected = [np.ones((3, 3, 1), dtype=np.uint8) * 120]
    assert array_equal_lists(observed, expected)

    # multiply <1.0
    aug = iaa.Multiply(mul=0.8)
    aug_det = aug.to_deterministic()

    observed = aug.augment_images(images)
    expected = np.ones((1, 3, 3, 1), dtype=np.uint8) * 80
    assert np.array_equal(observed, expected)

    observed = aug.augment_images(images_list)
    expected = [np.ones((3, 3, 1), dtype=np.uint8) * 80]
    assert array_equal_lists(observed, expected)

    observed = aug_det.augment_images(images)
    expected = np.ones((1, 3, 3, 1), dtype=np.uint8) * 80
    assert np.array_equal(observed, expected)

    observed = aug_det.augment_images(images_list)
    expected = [np.ones((3, 3, 1), dtype=np.uint8) * 80]
    assert array_equal_lists(observed, expected)

    # keypoints shouldnt be changed
    aug = iaa.Multiply(mul=1.2)
    aug_det = iaa.Multiply(mul=1.2).to_deterministic()
    observed = aug.augment_keypoints(keypoints)
    expected = keypoints
    assert keypoints_equal(observed, expected)

    observed = aug_det.augment_keypoints(keypoints)
    expected = keypoints
    assert keypoints_equal(observed, expected)

    # varying multiply factors
    aug = iaa.Multiply(mul=(0, 2.0))
    aug_det = aug.to_deterministic()

    last_aug = None
    last_aug_det = None
    nb_changed_aug = 0
    nb_changed_aug_det = 0
    nb_iterations = 1000
    for i in sm.xrange(nb_iterations):
        observed_aug = aug.augment_images(images)
        observed_aug_det = aug_det.augment_images(images)
        if i == 0:
            last_aug = observed_aug
            last_aug_det = observed_aug_det
        else:
            if not np.array_equal(observed_aug, last_aug):
                nb_changed_aug += 1
            if not np.array_equal(observed_aug_det, last_aug_det):
                nb_changed_aug_det += 1
            last_aug = observed_aug
            last_aug_det = observed_aug_det
    assert nb_changed_aug >= int(nb_iterations * 0.95)
    assert nb_changed_aug_det == 0

    # test channelwise
    aug = iaa.Multiply(mul=iap.Choice([0, 2]), per_channel=True)
    observed = aug.augment_image(np.ones((1, 1, 100), dtype=np.uint8))
    uq = np.unique(observed)
    assert 0 in uq
    assert 2 in uq
    assert len(uq) == 2

    # test channelwise with probability
    aug = iaa.Multiply(mul=iap.Choice([0, 2]), per_channel=0.5)
    seen = [0, 0]
    for _ in sm.xrange(400):
        observed = aug.augment_image(np.ones((1, 1, 20), dtype=np.uint8))
        uq = np.unique(observed)
        per_channel = (len(uq) == 2)
        if per_channel:
            seen[0] += 1
        else:
            seen[1] += 1
    assert 150 < seen[0] < 250
    assert 150 < seen[1] < 250

    # test exceptions for wrong parameter types
    got_exception = False
    try:
        _ = iaa.Multiply(mul="test")
    except Exception:
        got_exception = True
    assert got_exception

    got_exception = False
    try:
        _ = iaa.Multiply(mul=1, per_channel="test")
    except Exception:
        got_exception = True
    assert got_exception

    # test get_parameters()
    aug = iaa.Multiply(mul=1, per_channel=False)
    params = aug.get_parameters()
    assert isinstance(params[0], iap.Deterministic)
    assert isinstance(params[1], iap.Deterministic)
    assert params[0].value == 1
    assert params[1].value == 0

    # test heatmaps (not affected by augmenter)
    aug = iaa.Multiply(mul=2)
    hm = ia.quokka_heatmap()
    hm_aug = aug.augment_heatmaps([hm])[0]
    assert np.allclose(hm.arr_0to1, hm_aug.arr_0to1)

    ###################
    # test other dtypes
    ###################
    # bool
    image = np.zeros((3, 3), dtype=bool)
    aug = iaa.Multiply(1.0)
    image_aug = aug.augment_image(image)
    assert image_aug.dtype.type == np.bool_
    assert np.all(image_aug == 0)

    image = np.full((3, 3), True, dtype=bool)
    aug = iaa.Multiply(1.0)
    image_aug = aug.augment_image(image)
    assert image_aug.dtype.type == np.bool_
    assert np.all(image_aug == 1)

    image = np.full((3, 3), True, dtype=bool)
    aug = iaa.Multiply(2.0)
    image_aug = aug.augment_image(image)
    assert image_aug.dtype.type == np.bool_
    assert np.all(image_aug == 1)

    image = np.full((3, 3), True, dtype=bool)
    aug = iaa.Multiply(0.0)
    image_aug = aug.augment_image(image)
    assert image_aug.dtype.type == np.bool_
    assert np.all(image_aug == 0)

    image = np.full((3, 3), True, dtype=bool)
    aug = iaa.Multiply(-1.0)
    image_aug = aug.augment_image(image)
    assert image_aug.dtype.type == np.bool_
    assert np.all(image_aug == 0)

    # uint, int
    for dtype in [np.uint8, np.uint16, np.int8, np.int16]:
        min_value, center_value, max_value = iadt.get_value_range_of_dtype(dtype)

        image = np.full((3, 3), 10, dtype=dtype)
        aug = iaa.Multiply(1)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert np.all(image_aug == 10)

        image = np.full((3, 3), 10, dtype=dtype)
        aug = iaa.Multiply(10)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert np.all(image_aug == 100)

        image = np.full((3, 3), 10, dtype=dtype)
        aug = iaa.Multiply(0.5)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert np.all(image_aug == 5)

        image = np.full((3, 3), 0, dtype=dtype)
        aug = iaa.Multiply(0)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert np.all(image_aug == 0)

        if np.dtype(dtype).kind == "u":
            image = np.full((3, 3), 10, dtype=dtype)
            aug = iaa.Multiply(-1)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == 0)
        else:
            image = np.full((3, 3), 10, dtype=dtype)
            aug = iaa.Multiply(-1)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == -10)

        image = np.full((3, 3), int(center_value), dtype=dtype)
        aug = iaa.Multiply(1)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert np.all(image_aug == int(center_value))

        image = np.full((3, 3), int(center_value), dtype=dtype)
        aug = iaa.Multiply(1.2)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert np.all(image_aug == int(1.2 * int(center_value)))

        if np.dtype(dtype).kind == "u":
            image = np.full((3, 3), int(center_value), dtype=dtype)
            aug = iaa.Multiply(100)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == max_value)

        image = np.full((3, 3), max_value, dtype=dtype)
        aug = iaa.Multiply(1)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert np.all(image_aug == max_value)

        image = np.full((3, 3), max_value, dtype=dtype)
        aug = iaa.Multiply(10)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert np.all(image_aug == max_value)

        image = np.full((3, 3), max_value, dtype=dtype)
        aug = iaa.Multiply(0)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert np.all(image_aug == 0)

        image = np.full((3, 3), max_value, dtype=dtype)
        aug = iaa.Multiply(-2)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert np.all(image_aug == min_value)

        for _ in sm.xrange(10):
            image = np.full((1, 1, 3), 10, dtype=dtype)
            aug = iaa.Multiply(iap.Uniform(0.5, 1.5))
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(np.logical_and(5 <= image_aug, image_aug <= 15))
            assert len(np.unique(image_aug)) == 1

            image = np.full((1, 1, 100), 10, dtype=dtype)
            aug = iaa.Multiply(iap.Uniform(0.5, 1.5), per_channel=True)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(np.logical_and(5 <= image_aug, image_aug <= 15))
            assert len(np.unique(image_aug)) > 1

            image = np.full((1, 1, 3), 10, dtype=dtype)
            aug = iaa.Multiply(iap.DiscreteUniform(1, 3))
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(np.logical_and(10 <= image_aug, image_aug <= 30))
            assert len(np.unique(image_aug)) == 1

            image = np.full((1, 1, 100), 10, dtype=dtype)
            aug = iaa.Multiply(iap.DiscreteUniform(1, 3), per_channel=True)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(np.logical_and(10 <= image_aug, image_aug <= 30))
            assert len(np.unique(image_aug)) > 1

    # float
    for dtype in [np.float16, np.float32]:
        min_value, center_value, max_value = iadt.get_value_range_of_dtype(dtype)

        if dtype == np.float16:
            atol = 1e-3 * max_value
        else:
            atol = 1e-9 * max_value
        _allclose = functools.partial(np.allclose, atol=atol, rtol=0)

        image = np.full((3, 3), 10.0, dtype=dtype)
        aug = iaa.Multiply(1.0)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert _allclose(image_aug, 10.0)

        image = np.full((3, 3), 10.0, dtype=dtype)
        aug = iaa.Multiply(2.0)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert _allclose(image_aug, 20.0)

        image = np.full((3, 3), max_value, dtype=dtype)
        aug = iaa.Multiply(-10)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert _allclose(image_aug, min_value)

        image = np.full((3, 3), max_value, dtype=dtype)
        aug = iaa.Multiply(0.0)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert _allclose(image_aug, 0.0)

        image = np.full((3, 3), max_value, dtype=dtype)
        aug = iaa.Multiply(0.5)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert _allclose(image_aug, 0.5*max_value)

        image = np.full((3, 3), min_value, dtype=dtype)
        aug = iaa.Multiply(-2.0)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert _allclose(image_aug, max_value)

        image = np.full((3, 3), min_value, dtype=dtype)
        aug = iaa.Multiply(0.0)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert _allclose(image_aug, 0.0)

        # using tolerances of -100 - 1e-2 and 100 + 1e-2 is not enough for float16, had to be increased to -/+ 1e-1
        for _ in sm.xrange(10):
            image = np.full((1, 1, 3), 10.0, dtype=dtype)
            aug = iaa.Multiply(iap.Uniform(-10, 10))
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(np.logical_and(-100 - 1e-1 < image_aug, image_aug < 100 + 1e-1))
            assert np.allclose(image_aug[1:, :, 0], image_aug[:-1, :, 0])
            assert np.allclose(image_aug[..., 0], image_aug[..., 1])

            image = np.full((1, 1, 100), 10.0, dtype=dtype)
            aug = iaa.Multiply(iap.Uniform(-10, 10), per_channel=True)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(np.logical_and(-100 - 1e-1 < image_aug, image_aug < 100 + 1e-1))
            assert not np.allclose(image_aug[:, :, 1:], image_aug[:, :, :-1])

            image = np.full((1, 1, 3), 10.0, dtype=dtype)
            aug = iaa.Multiply(iap.DiscreteUniform(-10, 10))
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(np.logical_and(-100 - 1e-1 < image_aug, image_aug < 100 + 1e-1))
            assert np.allclose(image_aug[1:, :, 0], image_aug[:-1, :, 0])
            assert np.allclose(image_aug[..., 0], image_aug[..., 1])

            image = np.full((1, 1, 100), 10.0, dtype=dtype)
            aug = iaa.Multiply(iap.DiscreteUniform(-10, 10), per_channel=True)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
</source>
<source file="systems/imgaug-0.2.9/test/augmenters/test_arithmetic.py" startline="802" endline="1211" pcid="1079">
            assert np.all(np.logical_and(-100 - 1e-1 < image_aug, image_aug < 100 + 1e-1))
            assert not np.allclose(image_aug[:, :, 1:], image_aug[:, :, :-1])


def test_MultiplyElementwise():
    reseed()

    base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
    images = np.array([base_img])
    images_list = [base_img]
    keypoints = [ia.KeypointsOnImage([ia.Keypoint(x=0, y=0), ia.Keypoint(x=1, y=1),
                                      ia.Keypoint(x=2, y=2)], shape=base_img.shape)]

    # no multiply, shouldnt change anything
    aug = iaa.MultiplyElementwise(mul=1.0)
    aug_det = aug.to_deterministic()

    observed = aug.augment_images(images)
    expected = images
    assert np.array_equal(observed, expected)

    observed = aug.augment_images(images_list)
    expected = images_list
    assert array_equal_lists(observed, expected)

    observed = aug_det.augment_images(images)
    expected = images
    assert np.array_equal(observed, expected)

    observed = aug_det.augment_images(images_list)
    expected = images_list
    assert array_equal_lists(observed, expected)

    # multiply >1.0
    aug = iaa.MultiplyElementwise(mul=1.2)
    aug_det = aug.to_deterministic()

    observed = aug.augment_images(images)
    expected = np.ones((1, 3, 3, 1), dtype=np.uint8) * 120
    assert np.array_equal(observed, expected)

    observed = aug.augment_images(images_list)
    expected = [np.ones((3, 3, 1), dtype=np.uint8) * 120]
    assert array_equal_lists(observed, expected)

    observed = aug_det.augment_images(images)
    expected = np.ones((1, 3, 3, 1), dtype=np.uint8) * 120
    assert np.array_equal(observed, expected)

    observed = aug_det.augment_images(images_list)
    expected = [np.ones((3, 3, 1), dtype=np.uint8) * 120]
    assert array_equal_lists(observed, expected)

    # multiply <1.0
    aug = iaa.MultiplyElementwise(mul=0.8)
    aug_det = aug.to_deterministic()

    observed = aug.augment_images(images)
    expected = np.ones((1, 3, 3, 1), dtype=np.uint8) * 80
    assert np.array_equal(observed, expected)

    observed = aug.augment_images(images_list)
    expected = [np.ones((3, 3, 1), dtype=np.uint8) * 80]
    assert array_equal_lists(observed, expected)

    observed = aug_det.augment_images(images)
    expected = np.ones((1, 3, 3, 1), dtype=np.uint8) * 80
    assert np.array_equal(observed, expected)

    observed = aug_det.augment_images(images_list)
    expected = [np.ones((3, 3, 1), dtype=np.uint8) * 80]
    assert array_equal_lists(observed, expected)

    # keypoints shouldnt be changed
    aug = iaa.MultiplyElementwise(mul=1.2)
    aug_det = iaa.Multiply(mul=1.2).to_deterministic()
    observed = aug.augment_keypoints(keypoints)
    expected = keypoints
    assert keypoints_equal(observed, expected)

    observed = aug_det.augment_keypoints(keypoints)
    expected = keypoints
    assert keypoints_equal(observed, expected)

    # varying multiply factors
    aug = iaa.MultiplyElementwise(mul=(0, 2.0))
    aug_det = aug.to_deterministic()

    last_aug = None
    last_aug_det = None
    nb_changed_aug = 0
    nb_changed_aug_det = 0
    nb_iterations = 1000
    for i in sm.xrange(nb_iterations):
        observed_aug = aug.augment_images(images)
        observed_aug_det = aug_det.augment_images(images)
        if i == 0:
            last_aug = observed_aug
            last_aug_det = observed_aug_det
        else:
            if not np.array_equal(observed_aug, last_aug):
                nb_changed_aug += 1
            if not np.array_equal(observed_aug_det, last_aug_det):
                nb_changed_aug_det += 1
            last_aug = observed_aug
            last_aug_det = observed_aug_det
    assert nb_changed_aug >= int(nb_iterations * 0.95)
    assert nb_changed_aug_det == 0

    # values should change between pixels
    aug = iaa.MultiplyElementwise(mul=(0.5, 1.5))

    nb_same = 0
    nb_different = 0
    nb_iterations = 1000
    for i in sm.xrange(nb_iterations):
        observed_aug = aug.augment_images(images)
        observed_aug_flat = observed_aug.flatten()
        last = None
        for j in sm.xrange(observed_aug_flat.size):
            if last is not None:
                v = observed_aug_flat[j]
                if v - 0.0001 <= last <= v + 0.0001:
                    nb_same += 1
                else:
                    nb_different += 1
            last = observed_aug_flat[j]
    assert nb_different > 0.95 * (nb_different + nb_same)

    # test channelwise
    aug = iaa.MultiplyElementwise(mul=iap.Choice([0, 1]), per_channel=True)
    observed = aug.augment_image(np.ones((100, 100, 3), dtype=np.uint8))
    sums = np.sum(observed, axis=2)
    values = np.unique(sums)
    assert all([(value in values) for value in [0, 1, 2, 3]])

    # test channelwise with probability
    aug = iaa.MultiplyElementwise(mul=iap.Choice([0, 1]), per_channel=0.5)
    seen = [0, 0]
    for _ in sm.xrange(400):
        observed = aug.augment_image(np.ones((20, 20, 3), dtype=np.uint8))
        sums = np.sum(observed, axis=2)
        values = np.unique(sums)
        all_values_found = all([(value in values) for value in [0, 1, 2, 3]])
        if all_values_found:
            seen[0] += 1
        else:
            seen[1] += 1
    assert 150 < seen[0] < 250
    assert 150 < seen[1] < 250

    # test exceptions for wrong parameter types
    got_exception = False
    try:
        aug = iaa.MultiplyElementwise(mul="test")
    except Exception:
        got_exception = True
    assert got_exception

    got_exception = False
    try:
        aug = iaa.MultiplyElementwise(mul=1, per_channel="test")
    except Exception:
        got_exception = True
    assert got_exception

    # test get_parameters()
    aug = iaa.MultiplyElementwise(mul=1, per_channel=False)
    params = aug.get_parameters()
    assert isinstance(params[0], iap.Deterministic)
    assert isinstance(params[1], iap.Deterministic)
    assert params[0].value == 1
    assert params[1].value == 0

    # test heatmaps (not affected by augmenter)
    aug = iaa.MultiplyElementwise(mul=2)
    hm = ia.quokka_heatmap()
    hm_aug = aug.augment_heatmaps([hm])[0]
    assert np.allclose(hm.arr_0to1, hm_aug.arr_0to1)

    ###################
    # test other dtypes
    ###################
    # bool
    image = np.zeros((3, 3), dtype=bool)
    aug = iaa.MultiplyElementwise(1.0)
    image_aug = aug.augment_image(image)
    assert image_aug.dtype.type == np.bool_
    assert np.all(image_aug == 0)

    image = np.full((3, 3), True, dtype=bool)
    aug = iaa.MultiplyElementwise(1.0)
    image_aug = aug.augment_image(image)
    assert image_aug.dtype.type == np.bool_
    assert np.all(image_aug == 1)

    image = np.full((3, 3), True, dtype=bool)
    aug = iaa.MultiplyElementwise(2.0)
    image_aug = aug.augment_image(image)
    assert image_aug.dtype.type == np.bool_
    assert np.all(image_aug == 1)

    image = np.full((3, 3), True, dtype=bool)
    aug = iaa.MultiplyElementwise(0.0)
    image_aug = aug.augment_image(image)
    assert image_aug.dtype.type == np.bool_
    assert np.all(image_aug == 0)

    image = np.full((3, 3), True, dtype=bool)
    aug = iaa.MultiplyElementwise(-1.0)
    image_aug = aug.augment_image(image)
    assert image_aug.dtype.type == np.bool_
    assert np.all(image_aug == 0)

    # uint, int
    for dtype in [np.uint8, np.uint16, np.int8, np.int16]:
        min_value, center_value, max_value = iadt.get_value_range_of_dtype(dtype)

        image = np.full((3, 3), 10, dtype=dtype)
        aug = iaa.MultiplyElementwise(1)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert np.all(image_aug == 10)

        image = np.full((3, 3), 10, dtype=dtype)
        aug = iaa.MultiplyElementwise(10)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert np.all(image_aug == 100)

        image = np.full((3, 3), 10, dtype=dtype)
        aug = iaa.MultiplyElementwise(0.5)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert np.all(image_aug == 5)

        image = np.full((3, 3), 0, dtype=dtype)
        aug = iaa.MultiplyElementwise(0)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert np.all(image_aug == 0)

        if np.dtype(dtype).kind == "u":
            image = np.full((3, 3), 10, dtype=dtype)
            aug = iaa.MultiplyElementwise(-1)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == 0)
        else:
            image = np.full((3, 3), 10, dtype=dtype)
            aug = iaa.MultiplyElementwise(-1)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == -10)

        image = np.full((3, 3), int(center_value), dtype=dtype)
        aug = iaa.MultiplyElementwise(1)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert np.all(image_aug == int(center_value))

        image = np.full((3, 3), int(center_value), dtype=dtype)
        aug = iaa.MultiplyElementwise(1.2)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert np.all(image_aug == int(1.2 * int(center_value)))

        if np.dtype(dtype).kind == "u":
            image = np.full((3, 3), int(center_value), dtype=dtype)
            aug = iaa.MultiplyElementwise(100)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(image_aug == max_value)

        image = np.full((3, 3), max_value, dtype=dtype)
        aug = iaa.MultiplyElementwise(1)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert np.all(image_aug == max_value)

        image = np.full((3, 3), max_value, dtype=dtype)
        aug = iaa.MultiplyElementwise(10)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert np.all(image_aug == max_value)

        image = np.full((3, 3), max_value, dtype=dtype)
        aug = iaa.MultiplyElementwise(0)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert np.all(image_aug == 0)

        image = np.full((3, 3), max_value, dtype=dtype)
        aug = iaa.MultiplyElementwise(-2)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert np.all(image_aug == min_value)

        for _ in sm.xrange(10):
            image = np.full((5, 5, 3), 10, dtype=dtype)
            aug = iaa.MultiplyElementwise(iap.Uniform(0.5, 1.5))
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(np.logical_and(5 <= image_aug, image_aug <= 15))
            assert len(np.unique(image_aug)) > 1
            assert np.all(image_aug[..., 0] == image_aug[..., 1])

            image = np.full((1, 1, 100), 10, dtype=dtype)
            aug = iaa.MultiplyElementwise(iap.Uniform(0.5, 1.5), per_channel=True)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(np.logical_and(5 <= image_aug, image_aug <= 15))
            assert len(np.unique(image_aug)) > 1

            image = np.full((5, 5, 3), 10, dtype=dtype)
            aug = iaa.MultiplyElementwise(iap.DiscreteUniform(1, 3))
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(np.logical_and(10 <= image_aug, image_aug <= 30))
            assert len(np.unique(image_aug)) > 1
            assert np.all(image_aug[..., 0] == image_aug[..., 1])

            image = np.full((1, 1, 100), 10, dtype=dtype)
            aug = iaa.MultiplyElementwise(iap.DiscreteUniform(1, 3), per_channel=True)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(np.logical_and(10 <= image_aug, image_aug <= 30))
            assert len(np.unique(image_aug)) > 1

    # float
    for dtype in [np.float16, np.float32]:
        min_value, center_value, max_value = iadt.get_value_range_of_dtype(dtype)

        if dtype == np.float16:
            atol = 1e-3 * max_value
        else:
            atol = 1e-9 * max_value
        _allclose = functools.partial(np.allclose, atol=atol, rtol=0)

        image = np.full((3, 3), 10.0, dtype=dtype)
        aug = iaa.MultiplyElementwise(1.0)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert _allclose(image_aug, 10.0)

        image = np.full((3, 3), 10.0, dtype=dtype)
        aug = iaa.MultiplyElementwise(2.0)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert _allclose(image_aug, 20.0)

        image = np.full((3, 3), max_value, dtype=dtype)
        aug = iaa.MultiplyElementwise(-10)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert _allclose(image_aug, min_value)

        image = np.full((3, 3), max_value, dtype=dtype)
        aug = iaa.MultiplyElementwise(0.0)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert _allclose(image_aug, 0.0)

        image = np.full((3, 3), max_value, dtype=dtype)
        aug = iaa.MultiplyElementwise(0.5)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert _allclose(image_aug, 0.5*max_value)

        image = np.full((3, 3), min_value, dtype=dtype)
        aug = iaa.MultiplyElementwise(-2.0)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert _allclose(image_aug, max_value)

        image = np.full((3, 3), min_value, dtype=dtype)
        aug = iaa.MultiplyElementwise(0.0)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert _allclose(image_aug, 0.0)

        # using tolerances of -100 - 1e-2 and 100 + 1e-2 is not enough for float16, had to be increased to -/+ 1e-1
        for _ in sm.xrange(10):
            image = np.full((50, 1, 3), 10.0, dtype=dtype)
            aug = iaa.MultiplyElementwise(iap.Uniform(-10, 10))
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(np.logical_and(-100 - 1e-1 < image_aug, image_aug < 100 + 1e-1))
            assert not np.allclose(image_aug[1:, :, 0], image_aug[:-1, :, 0])
            assert np.allclose(image_aug[..., 0], image_aug[..., 1])

            image = np.full((1, 1, 100), 10.0, dtype=dtype)
            aug = iaa.MultiplyElementwise(iap.Uniform(-10, 10), per_channel=True)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(np.logical_and(-100 - 1e-1 < image_aug, image_aug < 100 + 1e-1))
            assert not np.allclose(image_aug[:, :, 1:], image_aug[:, :, :-1])

            image = np.full((50, 1, 3), 10.0, dtype=dtype)
            aug = iaa.MultiplyElementwise(iap.DiscreteUniform(-10, 10))
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(np.logical_and(-100 - 1e-1 < image_aug, image_aug < 100 + 1e-1))
            assert not np.allclose(image_aug[1:, :, 0], image_aug[:-1, :, 0])
            assert np.allclose(image_aug[..., 0], image_aug[..., 1])

            image = np.full((1, 1, 100), 10, dtype=dtype)
            aug = iaa.MultiplyElementwise(iap.DiscreteUniform(-10, 10), per_channel=True)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
</source>
<source file="systems/imgaug-0.2.9/test/augmenters/test_arithmetic.py" startline="2235" endline="2647" pcid="1088">
            assert np.all(np.logical_and(-10 - 1e-2 < image_aug, image_aug < 10 + 1e-2))
            assert not np.allclose(image_aug[:, :, 1:], image_aug[:, :, :-1])


def test_AddElementwise():
    reseed()

    base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
    images = np.array([base_img])
    images_list = [base_img]
    keypoints = [ia.KeypointsOnImage([ia.Keypoint(x=0, y=0), ia.Keypoint(x=1, y=1),
                                      ia.Keypoint(x=2, y=2)], shape=base_img.shape)]

    # no add, shouldnt change anything
    aug = iaa.AddElementwise(value=0)
    aug_det = aug.to_deterministic()

    observed = aug.augment_images(images)
    expected = images
    assert np.array_equal(observed, expected)

    observed = aug.augment_images(images_list)
    expected = images_list
    assert array_equal_lists(observed, expected)

    observed = aug_det.augment_images(images)
    expected = images
    assert np.array_equal(observed, expected)

    observed = aug_det.augment_images(images_list)
    expected = images_list
    assert array_equal_lists(observed, expected)

    # add > 0
    aug = iaa.AddElementwise(value=1)
    aug_det = aug.to_deterministic()

    observed = aug.augment_images(images)
    expected = images + 1
    assert np.array_equal(observed, expected)

    observed = aug.augment_images(images_list)
    expected = [images_list[0] + 1]
    assert array_equal_lists(observed, expected)

    observed = aug_det.augment_images(images)
    expected = images + 1
    assert np.array_equal(observed, expected)

    observed = aug_det.augment_images(images_list)
    expected = [images_list[0] + 1]
    assert array_equal_lists(observed, expected)

    # add < 0
    aug = iaa.AddElementwise(value=-1)
    aug_det = aug.to_deterministic()

    observed = aug.augment_images(images)
    expected = images - 1
    assert np.array_equal(observed, expected)

    observed = aug.augment_images(images_list)
    expected = [images_list[0] - 1]
    assert array_equal_lists(observed, expected)

    observed = aug_det.augment_images(images)
    expected = images - 1
    assert np.array_equal(observed, expected)

    observed = aug_det.augment_images(images_list)
    expected = [images_list[0] - 1]
    assert array_equal_lists(observed, expected)

    # uint8, every possible addition for base value 127
    for value_type in [int]:
        for per_channel in [False, True]:
            for value in np.arange(-255, 255+1):
                aug = iaa.AddElementwise(value=value_type(value), per_channel=per_channel)
                expected = np.clip(127 + value_type(value), 0, 255)

                img = np.full((1, 1), 127, dtype=np.uint8)
                img_aug = aug.augment_image(img)
                assert img_aug.item(0) == expected

                img = np.full((1, 1, 3), 127, dtype=np.uint8)
                img_aug = aug.augment_image(img)
                assert np.all(img_aug == expected)

    # test other parameters
    aug = iaa.AddElementwise(value=iap.DiscreteUniform(1, 10))
    observed = aug.augment_images(images)
    assert np.min(observed) >= 100 + 1
    assert np.max(observed) <= 100 + 10

    aug = iaa.AddElementwise(value=iap.Uniform(1, 10))
    observed = aug.augment_images(images)
    assert np.min(observed) >= 100 + 1
    assert np.max(observed) <= 100 + 10

    aug = iaa.AddElementwise(value=iap.Clip(iap.Normal(1, 1), -3, 3))
    observed = aug.augment_images(images)
    assert np.min(observed) >= 100 - 3
    assert np.max(observed) <= 100 + 3

    aug = iaa.AddElementwise(value=iap.Discretize(iap.Clip(iap.Normal(1, 1), -3, 3)))
    observed = aug.augment_images(images)
    assert np.min(observed) >= 100 - 3
    assert np.max(observed) <= 100 + 3

    # keypoints shouldnt be changed
    aug = iaa.AddElementwise(value=1)
    aug_det = iaa.AddElementwise(value=1).to_deterministic()
    observed = aug.augment_keypoints(keypoints)
    expected = keypoints
    assert keypoints_equal(observed, expected)

    observed = aug_det.augment_keypoints(keypoints)
    expected = keypoints
    assert keypoints_equal(observed, expected)

    # varying values
    aug = iaa.AddElementwise(value=(0, 10))
    aug_det = aug.to_deterministic()

    last_aug = None
    last_aug_det = None
    nb_changed_aug = 0
    nb_changed_aug_det = 0
    nb_iterations = 1000
    for i in sm.xrange(nb_iterations):
        observed_aug = aug.augment_images(images)
        observed_aug_det = aug_det.augment_images(images)
        if i == 0:
            last_aug = observed_aug
            last_aug_det = observed_aug_det
        else:
            if not np.array_equal(observed_aug, last_aug):
                nb_changed_aug += 1
            if not np.array_equal(observed_aug_det, last_aug_det):
                nb_changed_aug_det += 1
            last_aug = observed_aug
            last_aug_det = observed_aug_det
    assert nb_changed_aug >= int(nb_iterations * 0.7)
    assert nb_changed_aug_det == 0

    # values should change between pixels
    aug = iaa.AddElementwise(value=(-50, 50))

    nb_same = 0
    nb_different = 0
    nb_iterations = 1000
    for i in sm.xrange(nb_iterations):
        observed_aug = aug.augment_images(images)
        observed_aug_flat = observed_aug.flatten()
        last = None
        for j in sm.xrange(observed_aug_flat.size):
            if last is not None:
                v = observed_aug_flat[j]
                if v - 0.0001 <= last <= v + 0.0001:
                    nb_same += 1
                else:
                    nb_different += 1
            last = observed_aug_flat[j]
    assert nb_different > 0.9 * (nb_different + nb_same)

    # test channelwise
    aug = iaa.AddElementwise(value=iap.Choice([0, 1]), per_channel=True)
    observed = aug.augment_image(np.zeros((100, 100, 3), dtype=np.uint8))
    sums = np.sum(observed, axis=2)
    values = np.unique(sums)
    assert all([(value in values) for value in [0, 1, 2, 3]])

    # test channelwise with probability
    aug = iaa.AddElementwise(value=iap.Choice([0, 1]), per_channel=0.5)
    seen = [0, 0]
    for _ in sm.xrange(400):
        observed = aug.augment_image(np.zeros((20, 20, 3), dtype=np.uint8))
        sums = np.sum(observed, axis=2)
        values = np.unique(sums)
        all_values_found = all([(value in values) for value in [0, 1, 2, 3]])
        if all_values_found:
            seen[0] += 1
        else:
            seen[1] += 1
    assert 150 < seen[0] < 250
    assert 150 < seen[1] < 250

    # test exceptions for wrong parameter types
    got_exception = False
    try:
        aug = iaa.AddElementwise(value="test")
    except Exception:
        got_exception = True
    assert got_exception

    got_exception = False
    try:
        aug = iaa.AddElementwise(value=1, per_channel="test")
    except Exception:
        got_exception = True
    assert got_exception

    # test get_parameters()
    aug = iaa.AddElementwise(value=1, per_channel=False)
    params = aug.get_parameters()
    assert isinstance(params[0], iap.Deterministic)
    assert isinstance(params[1], iap.Deterministic)
    assert params[0].value == 1
    assert params[1].value == 0

    # test heatmaps (not affected by augmenter)
    aug = iaa.AddElementwise(value=10)
    hm = ia.quokka_heatmap()
    hm_aug = aug.augment_heatmaps([hm])[0]
    assert np.allclose(hm.arr_0to1, hm_aug.arr_0to1)

    ###################
    # test other dtypes
    ###################
    # bool
    image = np.zeros((3, 3), dtype=bool)
    aug = iaa.AddElementwise(value=1)
    image_aug = aug.augment_image(image)
    assert image_aug.dtype.type == np.bool_
    assert np.all(image_aug == 1)

    image = np.full((3, 3), True, dtype=bool)
    aug = iaa.AddElementwise(value=1)
    image_aug = aug.augment_image(image)
    assert image_aug.dtype.type == np.bool_
    assert np.all(image_aug == 1)

    image = np.full((3, 3), True, dtype=bool)
    aug = iaa.AddElementwise(value=-1)
    image_aug = aug.augment_image(image)
    assert image_aug.dtype.type == np.bool_
    assert np.all(image_aug == 0)

    image = np.full((3, 3), True, dtype=bool)
    aug = iaa.AddElementwise(value=-2)
    image_aug = aug.augment_image(image)
    assert image_aug.dtype.type == np.bool_
    assert np.all(image_aug == 0)

    # uint, int
    for dtype in [np.uint8, np.uint16, np.int8, np.int16]:
        min_value, center_value, max_value = iadt.get_value_range_of_dtype(dtype)

        image = np.full((3, 3), min_value, dtype=dtype)
        aug = iaa.AddElementwise(1)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert np.all(image_aug == min_value + 1)

        image = np.full((3, 3), min_value + 10, dtype=dtype)
        aug = iaa.AddElementwise(11)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert np.all(image_aug == min_value + 21)

        image = np.full((3, 3), max_value - 2, dtype=dtype)
        aug = iaa.AddElementwise(1)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert np.all(image_aug == max_value - 1)

        image = np.full((3, 3), max_value - 1, dtype=dtype)
        aug = iaa.AddElementwise(1)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert np.all(image_aug == max_value)

        image = np.full((3, 3), max_value - 1, dtype=dtype)
        aug = iaa.AddElementwise(2)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert np.all(image_aug == max_value)

        image = np.full((3, 3), min_value + 10, dtype=dtype)
        aug = iaa.AddElementwise(-9)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert np.all(image_aug == min_value + 1)

        image = np.full((3, 3), min_value + 10, dtype=dtype)
        aug = iaa.AddElementwise(-10)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert np.all(image_aug == min_value)

        image = np.full((3, 3), min_value + 10, dtype=dtype)
        aug = iaa.AddElementwise(-11)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert np.all(image_aug == min_value)

        for _ in sm.xrange(10):
            image = np.full((5, 5, 3), 20, dtype=dtype)
            aug = iaa.AddElementwise(iap.Uniform(-10, 10))
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(np.logical_and(10 <= image_aug, image_aug <= 30))
            assert len(np.unique(image_aug)) > 1
            assert np.all(image_aug[..., 0] == image_aug[..., 1])

            image = np.full((1, 1, 100), 20, dtype=dtype)
            aug = iaa.AddElementwise(iap.Uniform(-10, 10), per_channel=True)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(np.logical_and(10 <= image_aug, image_aug <= 30))
            assert len(np.unique(image_aug)) > 1

            image = np.full((5, 5, 3), 20, dtype=dtype)
            aug = iaa.AddElementwise(iap.DiscreteUniform(-10, 10))
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(np.logical_and(10 <= image_aug, image_aug <= 30))
            assert len(np.unique(image_aug)) > 1
            assert np.all(image_aug[..., 0] == image_aug[..., 1])

            image = np.full((1, 1, 100), 20, dtype=dtype)
            aug = iaa.AddElementwise(iap.DiscreteUniform(-10, 10), per_channel=True)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(np.logical_and(10 <= image_aug, image_aug <= 30))
            assert len(np.unique(image_aug)) > 1

    # float
    for dtype in [np.float16, np.float32]:
        min_value, center_value, max_value = iadt.get_value_range_of_dtype(dtype)

        if dtype == np.float16:
            atol = 1e-3 * max_value
        else:
            atol = 1e-9 * max_value
        _allclose = functools.partial(np.allclose, atol=atol, rtol=0)

        image = np.full((3, 3), min_value, dtype=dtype)
        aug = iaa.AddElementwise(1)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert _allclose(image_aug, min_value + 1)

        image = np.full((3, 3), min_value + 10, dtype=dtype)
        aug = iaa.AddElementwise(11)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert _allclose(image_aug, min_value + 21)

        image = np.full((3, 3), max_value - 2, dtype=dtype)
        aug = iaa.AddElementwise(1)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert _allclose(image_aug, max_value - 1)

        image = np.full((3, 3), max_value - 1, dtype=dtype)
        aug = iaa.AddElementwise(1)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert _allclose(image_aug, max_value)

        image = np.full((3, 3), max_value - 1, dtype=dtype)
        aug = iaa.AddElementwise(2)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert _allclose(image_aug, max_value)

        image = np.full((3, 3), min_value + 10, dtype=dtype)
        aug = iaa.AddElementwise(-9)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert _allclose(image_aug, min_value + 1)

        image = np.full((3, 3), min_value + 10, dtype=dtype)
        aug = iaa.AddElementwise(-10)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert _allclose(image_aug, min_value)

        image = np.full((3, 3), min_value + 10, dtype=dtype)
        aug = iaa.AddElementwise(-11)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert _allclose(image_aug, min_value)

        for _ in sm.xrange(10):
            image = np.full((50, 1, 3), 0, dtype=dtype)
            aug = iaa.AddElementwise(iap.Uniform(-10, 10))
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(np.logical_and(-10 - 1e-2 < image_aug, image_aug < 10 + 1e-2))
            assert not np.allclose(image_aug[1:, :, 0], image_aug[:-1, :, 0])
            assert np.allclose(image_aug[..., 0], image_aug[..., 1])

            image = np.full((1, 1, 100), 0, dtype=dtype)
            aug = iaa.AddElementwise(iap.Uniform(-10, 10), per_channel=True)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(np.logical_and(-10 - 1e-2 < image_aug, image_aug < 10 + 1e-2))
            assert not np.allclose(image_aug[:, :, 1:], image_aug[:, :, :-1])

            image = np.full((50, 1, 3), 0, dtype=dtype)
            aug = iaa.AddElementwise(iap.DiscreteUniform(-10, 10))
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(np.logical_and(-10 - 1e-2 < image_aug, image_aug < 10 + 1e-2))
            assert not np.allclose(image_aug[1:, :, 0], image_aug[:-1, :, 0])
            assert np.allclose(image_aug[..., 0], image_aug[..., 1])

            image = np.full((1, 1, 100), 0, dtype=dtype)
            aug = iaa.AddElementwise(iap.DiscreteUniform(-10, 10), per_channel=True)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
</source>
<source file="systems/imgaug-0.2.9/test/augmenters/test_arithmetic.py" startline="1829" endline="2234" pcid="1087">
    hm_aug = aug.augment_heatmaps([hm])[0]
    assert np.allclose(hm.arr_0to1, hm_aug.arr_0to1)


def test_Add():
    reseed()

    base_img = np.ones((3, 3, 1), dtype=np.uint8) * 100
    images = np.array([base_img])
    images_list = [base_img]
    keypoints = [ia.KeypointsOnImage([ia.Keypoint(x=0, y=0), ia.Keypoint(x=1, y=1),
                                      ia.Keypoint(x=2, y=2)], shape=base_img.shape)]

    # no add, shouldnt change anything
    aug = iaa.Add(value=0)
    aug_det = aug.to_deterministic()

    observed = aug.augment_images(images)
    expected = images
    assert np.array_equal(observed, expected)

    observed = aug.augment_images(images_list)
    expected = images_list
    assert array_equal_lists(observed, expected)

    observed = aug_det.augment_images(images)
    expected = images
    assert np.array_equal(observed, expected)

    observed = aug_det.augment_images(images_list)
    expected = images_list
    assert array_equal_lists(observed, expected)

    # add > 0
    aug = iaa.Add(value=1)
    aug_det = aug.to_deterministic()

    observed = aug.augment_images(images)
    expected = images + 1
    assert np.array_equal(observed, expected)

    observed = aug.augment_images(images_list)
    expected = [images_list[0] + 1]
    assert array_equal_lists(observed, expected)

    observed = aug_det.augment_images(images)
    expected = images + 1
    assert np.array_equal(observed, expected)

    observed = aug_det.augment_images(images_list)
    expected = [images_list[0] + 1]
    assert array_equal_lists(observed, expected)

    # add < 0
    aug = iaa.Add(value=-1)
    aug_det = aug.to_deterministic()

    observed = aug.augment_images(images)
    expected = images - 1
    assert np.array_equal(observed, expected)

    observed = aug.augment_images(images_list)
    expected = [images_list[0] - 1]
    assert array_equal_lists(observed, expected)

    observed = aug_det.augment_images(images)
    expected = images - 1
    assert np.array_equal(observed, expected)

    observed = aug_det.augment_images(images_list)
    expected = [images_list[0] - 1]
    assert array_equal_lists(observed, expected)

    # uint8, every possible addition for base value 127
    for value_type in [float, int]:
        for per_channel in [False, True]:
            for value in np.arange(-255, 255+1):
                aug = iaa.Add(value=value_type(value), per_channel=per_channel)
                expected = np.clip(127 + value_type(value), 0, 255)

                img = np.full((1, 1), 127, dtype=np.uint8)
                img_aug = aug.augment_image(img)
                assert img_aug.item(0) == expected

                img = np.full((1, 1, 3), 127, dtype=np.uint8)
                img_aug = aug.augment_image(img)
                assert np.all(img_aug == expected)

    # specific tests with floats
    aug = iaa.Add(value=0.75)
    img = np.full((1, 1), 1, dtype=np.uint8)
    img_aug = aug.augment_image(img)
    assert img_aug.item(0) == 2

    img = np.full((1, 1), 1, dtype=np.uint16)
    img_aug = aug.augment_image(img)
    assert img_aug.item(0) == 2

    aug = iaa.Add(value=0.45)
    img = np.full((1, 1), 1, dtype=np.uint8)
    img_aug = aug.augment_image(img)
    assert img_aug.item(0) == 1

    img = np.full((1, 1), 1, dtype=np.uint16)
    img_aug = aug.augment_image(img)
    assert img_aug.item(0) == 1

    # test other parameters
    aug = iaa.Add(value=iap.DiscreteUniform(1, 10))
    observed = aug.augment_images(images)
    assert 100 + 1 <= np.average(observed) <= 100 + 10

    aug = iaa.Add(value=iap.Uniform(1, 10))
    observed = aug.augment_images(images)
    assert 100 + 1 <= np.average(observed) <= 100 + 10

    aug = iaa.Add(value=iap.Clip(iap.Normal(1, 1), -3, 3))
    observed = aug.augment_images(images)
    assert 100 - 3 <= np.average(observed) <= 100 + 3

    aug = iaa.Add(value=iap.Discretize(iap.Clip(iap.Normal(1, 1), -3, 3)))
    observed = aug.augment_images(images)
    assert 100 - 3 <= np.average(observed) <= 100 + 3

    # keypoints shouldnt be changed
    aug = iaa.Add(value=1)
    aug_det = iaa.Add(value=1).to_deterministic()
    observed = aug.augment_keypoints(keypoints)
    expected = keypoints
    assert keypoints_equal(observed, expected)

    observed = aug_det.augment_keypoints(keypoints)
    expected = keypoints
    assert keypoints_equal(observed, expected)

    # varying values
    aug = iaa.Add(value=(0, 10))
    aug_det = aug.to_deterministic()

    last_aug = None
    last_aug_det = None
    nb_changed_aug = 0
    nb_changed_aug_det = 0
    nb_iterations = 1000
    for i in sm.xrange(nb_iterations):
        observed_aug = aug.augment_images(images)
        observed_aug_det = aug_det.augment_images(images)
        if i == 0:
            last_aug = observed_aug
            last_aug_det = observed_aug_det
        else:
            if not np.array_equal(observed_aug, last_aug):
                nb_changed_aug += 1
            if not np.array_equal(observed_aug_det, last_aug_det):
                nb_changed_aug_det += 1
            last_aug = observed_aug
            last_aug_det = observed_aug_det
    assert nb_changed_aug >= int(nb_iterations * 0.7)
    assert nb_changed_aug_det == 0

    # test channelwise
    aug = iaa.Add(value=iap.Choice([0, 1]), per_channel=True)
    observed = aug.augment_image(np.zeros((1, 1, 100), dtype=np.uint8))
    uq = np.unique(observed)
    assert 0 in uq
    assert 1 in uq
    assert len(uq) == 2

    # test channelwise with probability
    aug = iaa.Add(value=iap.Choice([0, 1]), per_channel=0.5)
    seen = [0, 0]
    for _ in sm.xrange(400):
        observed = aug.augment_image(np.zeros((1, 1, 20), dtype=np.uint8))
        uq = np.unique(observed)
        per_channel = (len(uq) == 2)
        if per_channel:
            seen[0] += 1
        else:
            seen[1] += 1
    assert 150 < seen[0] < 250
    assert 150 < seen[1] < 250

    # test exceptions for wrong parameter types
    got_exception = False
    try:
        _ = iaa.Add(value="test")
    except Exception:
        got_exception = True
    assert got_exception

    got_exception = False
    try:
        _ = iaa.Add(value=1, per_channel="test")
    except Exception:
        got_exception = True
    assert got_exception

    # test get_parameters()
    aug = iaa.Add(value=1, per_channel=False)
    params = aug.get_parameters()
    assert isinstance(params[0], iap.Deterministic)
    assert isinstance(params[1], iap.Deterministic)
    assert params[0].value == 1
    assert params[1].value == 0

    # test heatmaps (not affected by augmenter)
    aug = iaa.Add(value=10)
    hm = ia.quokka_heatmap()
    hm_aug = aug.augment_heatmaps([hm])[0]
    assert np.allclose(hm.arr_0to1, hm_aug.arr_0to1)

    ###################
    # test other dtypes
    ###################
    # bool
    image = np.zeros((3, 3), dtype=bool)
    aug = iaa.Add(value=1)
    image_aug = aug.augment_image(image)
    assert image_aug.dtype.type == np.bool_
    assert np.all(image_aug == 1)

    image = np.full((3, 3), True, dtype=bool)
    aug = iaa.Add(value=1)
    image_aug = aug.augment_image(image)
    assert image_aug.dtype.type == np.bool_
    assert np.all(image_aug == 1)

    image = np.full((3, 3), True, dtype=bool)
    aug = iaa.Add(value=-1)
    image_aug = aug.augment_image(image)
    assert image_aug.dtype.type == np.bool_
    assert np.all(image_aug == 0)

    image = np.full((3, 3), True, dtype=bool)
    aug = iaa.Add(value=-2)
    image_aug = aug.augment_image(image)
    assert image_aug.dtype.type == np.bool_
    assert np.all(image_aug == 0)

    # uint, int
    for dtype in [np.uint8, np.uint16, np.int8, np.int16]:
        min_value, center_value, max_value = iadt.get_value_range_of_dtype(dtype)

        image = np.full((3, 3), min_value, dtype=dtype)
        aug = iaa.Add(1)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert np.all(image_aug == min_value + 1)

        image = np.full((3, 3), min_value + 10, dtype=dtype)
        aug = iaa.Add(11)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert np.all(image_aug == min_value + 21)

        image = np.full((3, 3), max_value - 2, dtype=dtype)
        aug = iaa.Add(1)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert np.all(image_aug == max_value - 1)

        image = np.full((3, 3), max_value - 1, dtype=dtype)
        aug = iaa.Add(1)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert np.all(image_aug == max_value)

        image = np.full((3, 3), max_value - 1, dtype=dtype)
        aug = iaa.Add(2)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert np.all(image_aug == max_value)

        image = np.full((3, 3), min_value + 10, dtype=dtype)
        aug = iaa.Add(-9)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert np.all(image_aug == min_value + 1)

        image = np.full((3, 3), min_value + 10, dtype=dtype)
        aug = iaa.Add(-10)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert np.all(image_aug == min_value)

        image = np.full((3, 3), min_value + 10, dtype=dtype)
        aug = iaa.Add(-11)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert np.all(image_aug == min_value)

        for _ in sm.xrange(10):
            image = np.full((1, 1, 3), 20, dtype=dtype)
            aug = iaa.Add(iap.Uniform(-10, 10))
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(np.logical_and(10 <= image_aug, image_aug <= 30))
            assert len(np.unique(image_aug)) == 1

            image = np.full((1, 1, 100), 20, dtype=dtype)
            aug = iaa.Add(iap.Uniform(-10, 10), per_channel=True)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(np.logical_and(10 <= image_aug, image_aug <= 30))
            assert len(np.unique(image_aug)) > 1

            image = np.full((1, 1, 3), 20, dtype=dtype)
            aug = iaa.Add(iap.DiscreteUniform(-10, 10))
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(np.logical_and(10 <= image_aug, image_aug <= 30))
            assert len(np.unique(image_aug)) == 1

            image = np.full((1, 1, 100), 20, dtype=dtype)
            aug = iaa.Add(iap.DiscreteUniform(-10, 10), per_channel=True)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(np.logical_and(10 <= image_aug, image_aug <= 30))
            assert len(np.unique(image_aug)) > 1

    # float
    for dtype in [np.float16, np.float32]:
        min_value, center_value, max_value = iadt.get_value_range_of_dtype(dtype)

        if dtype == np.float16:
            atol = 1e-3 * max_value
        else:
            atol = 1e-9 * max_value
        _allclose = functools.partial(np.allclose, atol=atol, rtol=0)

        image = np.full((3, 3), min_value, dtype=dtype)
        aug = iaa.Add(1)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert _allclose(image_aug, min_value + 1)

        image = np.full((3, 3), min_value + 10, dtype=dtype)
        aug = iaa.Add(11)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert _allclose(image_aug, min_value + 21)

        image = np.full((3, 3), max_value - 2, dtype=dtype)
        aug = iaa.Add(1)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert _allclose(image_aug, max_value - 1)

        image = np.full((3, 3), max_value - 1, dtype=dtype)
        aug = iaa.Add(1)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert _allclose(image_aug, max_value)

        image = np.full((3, 3), max_value - 1, dtype=dtype)
        aug = iaa.Add(2)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert _allclose(image_aug, max_value)

        image = np.full((3, 3), min_value + 10, dtype=dtype)
        aug = iaa.Add(-9)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert _allclose(image_aug, min_value + 1)

        image = np.full((3, 3), min_value + 10, dtype=dtype)
        aug = iaa.Add(-10)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert _allclose(image_aug, min_value)

        image = np.full((3, 3), min_value + 10, dtype=dtype)
        aug = iaa.Add(-11)
        image_aug = aug.augment_image(image)
        assert image_aug.dtype.type == dtype
        assert _allclose(image_aug, min_value)

        for _ in sm.xrange(10):
            image = np.full((50, 1, 3), 0, dtype=dtype)
            aug = iaa.Add(iap.Uniform(-10, 10))
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(np.logical_and(-10 - 1e-2 < image_aug, image_aug < 10 + 1e-2))
            assert np.allclose(image_aug[1:, :, 0], image_aug[:-1, :, 0])
            assert np.allclose(image_aug[..., 0], image_aug[..., 1])

            image = np.full((1, 1, 100), 0, dtype=dtype)
            aug = iaa.Add(iap.Uniform(-10, 10), per_channel=True)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(np.logical_and(-10 - 1e-2 < image_aug, image_aug < 10 + 1e-2))
            assert not np.allclose(image_aug[:, :, 1:], image_aug[:, :, :-1])

            image = np.full((50, 1, 3), 0, dtype=dtype)
            aug = iaa.Add(iap.DiscreteUniform(-10, 10))
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
            assert np.all(np.logical_and(-10 - 1e-2 < image_aug, image_aug < 10 + 1e-2))
            assert np.allclose(image_aug[1:, :, 0], image_aug[:-1, :, 0])
            assert np.allclose(image_aug[..., 0], image_aug[..., 1])

            image = np.full((1, 1, 100), 0, dtype=dtype)
            aug = iaa.Add(iap.DiscreteUniform(-10, 10), per_channel=True)
            image_aug = aug.augment_image(image)
            assert image_aug.dtype.type == dtype
</source>
</class>

<class classid="65" nclones="3" nlines="14" similarity="85">
<source file="systems/imgaug-0.2.9/test/augmenters/test_arithmetic.py" startline="1529" endline="1545" pcid="1081">
        assert np.all(np.logical_and(0 <= image_aug, image_aug <= 10))
        assert not np.allclose(image_aug[:, :, 1:], image_aug[:, :, :-1], atol=0.01)


def test_SaltAndPepper():
    reseed()

    base_img = np.zeros((100, 100, 1), dtype=np.uint8) + 128
    aug = iaa.SaltAndPepper(p=0.5)
    observed = aug.augment_image(base_img)
    p = np.mean(observed != 128)
    assert 0.4 < p < 0.6

    aug = iaa.SaltAndPepper(p=1.0)
    observed = aug.augment_image(base_img)
    nb_pepper = np.sum(observed < 40)
    nb_salt = np.sum(observed > 255 - 40)
</source>
<source file="systems/imgaug-0.2.9/test/augmenters/test_arithmetic.py" startline="1628" endline="1646" pcid="1083">
    hm_aug = aug.augment_heatmaps([hm])[0]
    assert np.allclose(hm.arr_0to1, hm_aug.arr_0to1)


def test_Salt():
    reseed()

    base_img = np.zeros((100, 100, 1), dtype=np.uint8) + 128
    aug = iaa.Salt(p=0.5)
    observed = aug.augment_image(base_img)
    p = np.mean(observed != 128)
    assert 0.4 < p < 0.6
    # Salt() occasionally replaces with 127, which probably should be the center-point here anyways
    assert np.all(observed >= 127)

    aug = iaa.Salt(p=1.0)
    observed = aug.augment_image(base_img)
    nb_pepper = np.sum(observed < 40)
    nb_salt = np.sum(observed > 255 - 40)
</source>
<source file="systems/imgaug-0.2.9/test/augmenters/test_arithmetic.py" startline="1729" endline="1746" pcid="1085">
    hm_aug = aug.augment_heatmaps([hm])[0]
    assert np.allclose(hm.arr_0to1, hm_aug.arr_0to1)


def test_Pepper():
    reseed()

    base_img = np.zeros((100, 100, 1), dtype=np.uint8) + 128
    aug = iaa.Pepper(p=0.5)
    observed = aug.augment_image(base_img)
    p = np.mean(observed != 128)
    assert 0.4 < p < 0.6
    assert np.all(observed <= 128)

    aug = iaa.Pepper(p=1.0)
    observed = aug.augment_image(base_img)
    nb_pepper = np.sum(observed < 40)
    nb_salt = np.sum(observed > 255 - 40)
</source>
</class>

<class classid="66" nclones="3" nlines="67" similarity="100">
<source file="systems/imgaug-0.2.9/test/augmenters/test_arithmetic.py" startline="1549" endline="1627" pcid="1082">
    # not more tests necessary here as SaltAndPepper is just a tiny wrapper around
    # ReplaceElementwise


def test_CoarseSaltAndPepper():
    reseed()

    base_img = np.zeros((100, 100, 1), dtype=np.uint8) + 128
    aug = iaa.CoarseSaltAndPepper(p=0.5, size_px=100)
    observed = aug.augment_image(base_img)
    p = np.mean(observed != 128)
    assert 0.4 < p < 0.6

    aug1 = iaa.CoarseSaltAndPepper(p=0.5, size_px=100)
    aug2 = iaa.CoarseSaltAndPepper(p=0.5, size_px=10)
    base_img = np.zeros((100, 100, 1), dtype=np.uint8) + 128
    ps1 = []
    ps2 = []
    for _ in sm.xrange(100):
        observed1 = aug1.augment_image(base_img)
        observed2 = aug2.augment_image(base_img)
        p1 = np.mean(observed1 != 128)
        p2 = np.mean(observed2 != 128)
        ps1.append(p1)
        ps2.append(p2)
    assert 0.4 < np.mean(ps2) < 0.6
    assert np.std(ps1)*1.5 < np.std(ps2)

    aug = iaa.CoarseSaltAndPepper(p=[0.2, 0.5], size_px=100)
    base_img = np.zeros((100, 100, 1), dtype=np.uint8) + 128
    seen = [0, 0, 0]
    for _ in sm.xrange(200):
        observed = aug.augment_image(base_img)
        p = np.mean(observed != 128)
        diff_020 = abs(0.2 - p)
        diff_050 = abs(0.5 - p)
        if diff_020 < 0.025:
            seen[0] += 1
        elif diff_050 < 0.025:
            seen[1] += 1
        else:
            seen[2] += 1
    assert seen[2] < 10
    assert 75 < seen[0] < 125
    assert 75 < seen[1] < 125

    aug = iaa.CoarseSaltAndPepper(p=(0.0, 1.0), size_px=50)
    base_img = np.zeros((50, 50, 1), dtype=np.uint8) + 128
    ps = []
    for _ in sm.xrange(200):
        observed = aug.augment_image(base_img)
        p = np.mean(observed != 128)
        ps.append(p)

    nb_bins = 5
    hist, _ = np.histogram(ps, bins=nb_bins, range=(0.0, 1.0), density=False)
    tolerance = 0.05
    for nb_seen in hist:
        density = nb_seen / len(ps)
        assert density - tolerance < density < density + tolerance

    # test exceptions for wrong parameter types
    got_exception = False
    try:
        _ = iaa.CoarseSaltAndPepper(p="test", size_px=100)
    except Exception:
        got_exception = True
    assert got_exception

    got_exception = False
    try:
        _ = iaa.CoarseSaltAndPepper(p=0.5, size_px=None, size_percent=None)
    except Exception:
        got_exception = True
    assert got_exception

    # test heatmaps (not affected by augmenter)
    aug = iaa.CoarseSaltAndPepper(p=1.0, size_px=2)
    hm = ia.quokka_heatmap()
</source>
<source file="systems/imgaug-0.2.9/test/augmenters/test_arithmetic.py" startline="1750" endline="1828" pcid="1086">
    # not more tests necessary here as Salt is just a tiny wrapper around
    # ReplaceElementwise


def test_CoarsePepper():
    reseed()

    base_img = np.zeros((100, 100, 1), dtype=np.uint8) + 128
    aug = iaa.CoarsePepper(p=0.5, size_px=100)
    observed = aug.augment_image(base_img)
    p = np.mean(observed != 128)
    assert 0.4 < p < 0.6

    aug1 = iaa.CoarsePepper(p=0.5, size_px=100)
    aug2 = iaa.CoarsePepper(p=0.5, size_px=10)
    base_img = np.zeros((100, 100, 1), dtype=np.uint8) + 128
    ps1 = []
    ps2 = []
    for _ in sm.xrange(100):
        observed1 = aug1.augment_image(base_img)
        observed2 = aug2.augment_image(base_img)
        p1 = np.mean(observed1 != 128)
        p2 = np.mean(observed2 != 128)
        ps1.append(p1)
        ps2.append(p2)
    assert 0.4 < np.mean(ps2) < 0.6
    assert np.std(ps1)*1.5 < np.std(ps2)

    aug = iaa.CoarsePepper(p=[0.2, 0.5], size_px=100)
    base_img = np.zeros((100, 100, 1), dtype=np.uint8) + 128
    seen = [0, 0, 0]
    for _ in sm.xrange(200):
        observed = aug.augment_image(base_img)
        p = np.mean(observed != 128)
        diff_020 = abs(0.2 - p)
        diff_050 = abs(0.5 - p)
        if diff_020 < 0.025:
            seen[0] += 1
        elif diff_050 < 0.025:
            seen[1] += 1
        else:
            seen[2] += 1
    assert seen[2] < 10
    assert 75 < seen[0] < 125
    assert 75 < seen[1] < 125

    aug = iaa.CoarsePepper(p=(0.0, 1.0), size_px=50)
    base_img = np.zeros((50, 50, 1), dtype=np.uint8) + 128
    ps = []
    for _ in sm.xrange(200):
        observed = aug.augment_image(base_img)
        p = np.mean(observed != 128)
        ps.append(p)

    nb_bins = 5
    hist, _ = np.histogram(ps, bins=nb_bins, range=(0.0, 1.0), density=False)
    tolerance = 0.05
    for nb_seen in hist:
        density = nb_seen / len(ps)
        assert density - tolerance < density < density + tolerance

    # test exceptions for wrong parameter types
    got_exception = False
    try:
        _ = iaa.CoarsePepper(p="test", size_px=100)
    except Exception:
        got_exception = True
    assert got_exception

    got_exception = False
    try:
        _ = iaa.CoarsePepper(p=0.5, size_px=None, size_percent=None)
    except Exception:
        got_exception = True
    assert got_exception

    # test heatmaps (not affected by augmenter)
    aug = iaa.CoarsePepper(p=1.0, size_px=2)
    hm = ia.quokka_heatmap()
</source>
<source file="systems/imgaug-0.2.9/test/augmenters/test_arithmetic.py" startline="1650" endline="1728" pcid="1084">
    # not more tests necessary here as Salt is just a tiny wrapper around
    # ReplaceElementwise


def test_CoarseSalt():
    reseed()

    base_img = np.zeros((100, 100, 1), dtype=np.uint8) + 128
    aug = iaa.CoarseSalt(p=0.5, size_px=100)
    observed = aug.augment_image(base_img)
    p = np.mean(observed != 128)
    assert 0.4 < p < 0.6

    aug1 = iaa.CoarseSalt(p=0.5, size_px=100)
    aug2 = iaa.CoarseSalt(p=0.5, size_px=10)
    base_img = np.zeros((100, 100, 1), dtype=np.uint8) + 128
    ps1 = []
    ps2 = []
    for _ in sm.xrange(100):
        observed1 = aug1.augment_image(base_img)
        observed2 = aug2.augment_image(base_img)
        p1 = np.mean(observed1 != 128)
        p2 = np.mean(observed2 != 128)
        ps1.append(p1)
        ps2.append(p2)
    assert 0.4 < np.mean(ps2) < 0.6
    assert np.std(ps1)*1.5 < np.std(ps2)

    aug = iaa.CoarseSalt(p=[0.2, 0.5], size_px=100)
    base_img = np.zeros((100, 100, 1), dtype=np.uint8) + 128
    seen = [0, 0, 0]
    for _ in sm.xrange(200):
        observed = aug.augment_image(base_img)
        p = np.mean(observed != 128)
        diff_020 = abs(0.2 - p)
        diff_050 = abs(0.5 - p)
        if diff_020 < 0.025:
            seen[0] += 1
        elif diff_050 < 0.025:
            seen[1] += 1
        else:
            seen[2] += 1
    assert seen[2] < 10
    assert 75 < seen[0] < 125
    assert 75 < seen[1] < 125

    aug = iaa.CoarseSalt(p=(0.0, 1.0), size_px=50)
    base_img = np.zeros((50, 50, 1), dtype=np.uint8) + 128
    ps = []
    for _ in sm.xrange(200):
        observed = aug.augment_image(base_img)
        p = np.mean(observed != 128)
        ps.append(p)

    nb_bins = 5
    hist, _ = np.histogram(ps, bins=nb_bins, range=(0.0, 1.0), density=False)
    tolerance = 0.05
    for nb_seen in hist:
        density = nb_seen / len(ps)
        assert density - tolerance < density < density + tolerance

    # test exceptions for wrong parameter types
    got_exception = False
    try:
        _ = iaa.CoarseSalt(p="test", size_px=100)
    except Exception:
        got_exception = True
    assert got_exception

    got_exception = False
    try:
        _ = iaa.CoarseSalt(p=0.5, size_px=None, size_percent=None)
    except Exception:
        got_exception = True
    assert got_exception

    # test heatmaps (not affected by augmenter)
    aug = iaa.CoarseSalt(p=1.0, size_px=2)
    hm = ia.quokka_heatmap()
</source>
</class>

<class classid="67" nclones="2" nlines="166" similarity="73">
<source file="systems/imgaug-0.2.9/test/augmenters/test_size.py" startline="1787" endline="2013" pcid="1114">
def test_PadToFixedSize():
    reseed()

    img = np.uint8([[255]])
    img3d = img[:, :, np.newaxis]
    img3d_rgb = np.tile(img3d, (1, 1, 3))

    # basic functionality
    aug = iaa.PadToFixedSize(height=5, width=5)
    observed = aug.augment_image(img)
    assert observed.dtype.type == np.uint8
    assert observed.shape == (5, 5)

    observed = aug.augment_image(img3d)
    assert observed.dtype.type == np.uint8
    assert observed.shape == (5, 5, 1)

    observed = aug.augment_image(img3d_rgb)
    assert observed.dtype.type == np.uint8
    assert observed.shape == (5, 5, 3)

    # test float32, float64, int32
    for dtype in [np.float32, np.float64, np.int32]:
        aug = iaa.PadToFixedSize(height=5, width=5)
        observed = aug.augment_image(img.astype(dtype))
        assert observed.dtype.type == dtype
        assert observed.shape == (5, 5)

    # change only one side when other side has already desired size
    aug = iaa.PadToFixedSize(height=5, width=5)
    observed = aug.augment_image(np.zeros((1, 5, 3), dtype=np.uint8))
    assert observed.dtype.type == np.uint8
    assert observed.shape == (5, 5, 3)

    aug = iaa.PadToFixedSize(height=5, width=5)
    observed = aug.augment_image(np.zeros((5, 1, 3), dtype=np.uint8))
    assert observed.dtype.type == np.uint8
    assert observed.shape == (5, 5, 3)

    # change no side when all sides have exactly desired size
    img5x5 = np.zeros((5, 5, 3), dtype=np.uint8)
    img5x5[2, 2, :] = 255
    aug = iaa.PadToFixedSize(height=5, width=5)
    observed = aug.augment_image(img5x5)
    assert observed.dtype.type == np.uint8
    assert observed.shape == (5, 5, 3)
    assert np.array_equal(observed, img5x5)

    # change no side when all sides have larger than desired size
    img6x6 = np.zeros((6, 6, 3), dtype=np.uint8)
    img6x6[3, 3, :] = 255
    aug = iaa.PadToFixedSize(height=5, width=5)
    observed = aug.augment_image(img6x6)
    assert observed.dtype.type == np.uint8
    assert observed.shape == (6, 6, 3)
    assert np.array_equal(observed, img6x6)

    # make sure that pad mode is recognized
    aug = iaa.PadToFixedSize(height=4, width=4, pad_mode="edge")
    aug.position = (iap.Deterministic(0.5), iap.Deterministic(0.5))
    img2x2 = np.uint8([
        [50, 100],
        [150, 200]
    ])
    expected = np.uint8([
        [50, 50, 100, 100],
        [50, 50, 100, 100],
        [150, 150, 200, 200],
        [150, 150, 200, 200]
    ])
    observed = aug.augment_image(img2x2)
    assert observed.dtype.type == np.uint8
    assert observed.shape == (4, 4)
    assert np.array_equal(observed, expected)

    # explicit non-center position test
    aug = iaa.PadToFixedSize(height=3, width=3, pad_mode="constant", pad_cval=128, position="left-top")
    img1x1 = np.uint8([[255]])
    observed = aug.augment_image(img1x1)
    expected = np.uint8([
        [128, 128, 128],
        [128, 128, 128],
        [128, 128, 255]
    ])
    assert observed.dtype.type == np.uint8
    assert observed.shape == (3, 3)
    assert np.array_equal(observed, expected)

    aug = iaa.PadToFixedSize(height=3, width=3, pad_mode="constant", pad_cval=128, position="right-bottom")
    img1x1 = np.uint8([[255]])
    observed = aug.augment_image(img1x1)
    expected = np.uint8([
        [255, 128, 128],
        [128, 128, 128],
        [128, 128, 128]
    ])
    assert observed.dtype.type == np.uint8
    assert observed.shape == (3, 3)
    assert np.array_equal(observed, expected)

    aug = iaa.PadToFixedSize(height=3, width=3, pad_mode="constant", pad_cval=128, position=(0.5, 1.0))
    img1x1 = np.uint8([[255]])
    observed = aug.augment_image(img1x1)
    expected = np.uint8([
        [128, 255, 128],
        [128, 128, 128],
        [128, 128, 128]
    ])
    assert observed.dtype.type == np.uint8
    assert observed.shape == (3, 3)
    assert np.array_equal(observed, expected)

    # basic keypoint test
    kpsoi = ia.KeypointsOnImage([ia.Keypoint(x=1, y=1)], shape=(3, 3))
    aug = iaa.PadToFixedSize(height=4, width=4, pad_mode="edge", position="center")
    observed = aug.augment_keypoints([kpsoi])
    expected = ia.KeypointsOnImage([ia.Keypoint(x=2, y=2)], shape=(4, 4))
    assert observed[0].shape == expected.shape
    assert keypoints_equal(observed, [expected])

    # keypoint test with shape not being changed
    kpsoi = ia.KeypointsOnImage([ia.Keypoint(x=1, y=1)], shape=(3, 3))
    aug = iaa.PadToFixedSize(height=3, width=3, pad_mode="edge", position="center")
    observed = aug.augment_keypoints([kpsoi])
    expected = ia.KeypointsOnImage([ia.Keypoint(x=1, y=1)], shape=(3, 3))
    assert observed[0].shape == expected.shape
    assert keypoints_equal(observed, [expected])

    # keypoint test with explicit non-center position
    kpsoi = ia.KeypointsOnImage([ia.Keypoint(x=1, y=1)], shape=(3, 3))
    aug = iaa.PadToFixedSize(height=4, width=4, pad_mode="edge", position="left-top")
    observed = aug.augment_keypoints([kpsoi])
    expected = ia.KeypointsOnImage([ia.Keypoint(x=2, y=2)], shape=(4, 4))
    assert observed[0].shape == expected.shape
    assert keypoints_equal(observed, [expected])

    kpsoi = ia.KeypointsOnImage([ia.Keypoint(x=1, y=1)], shape=(3, 3))
    aug = iaa.PadToFixedSize(height=4, width=4, pad_mode="edge", position="right-bottom")
    observed = aug.augment_keypoints([kpsoi])
    expected = ia.KeypointsOnImage([ia.Keypoint(x=1, y=1)], shape=(4, 4))
    assert observed[0].shape == expected.shape
    assert keypoints_equal(observed, [expected])

    # basic heatmaps test
    # pad_mode should be ignored for heatmaps
    heatmaps = ia.HeatmapsOnImage(np.zeros((1, 1, 1), dtype=np.float32) + 1.0, shape=(1, 1, 3))
    aug = iaa.PadToFixedSize(height=3, width=3, pad_mode="edge", position="center")
    observed = aug.augment_heatmaps([heatmaps])[0]
    expected = np.float32([
        [0, 0, 0],
        [0, 1.0, 0],
        [0, 0, 0]
    ])
    expected = expected[..., np.newaxis]
    assert observed.shape == (3, 3, 3)
    assert np.allclose(observed.arr_0to1, expected)

    # heatmaps with size unequal to image
    # pad_mode should be ignored for heatmaps
    heatmaps = ia.HeatmapsOnImage(np.zeros((15, 15, 1), dtype=np.float32) + 1.0, shape=(30, 30, 3))
    aug = iaa.PadToFixedSize(height=32, width=32, pad_mode="edge", position="left-top")
    observed = aug.augment_heatmaps([heatmaps])[0]
    expected = np.zeros((16, 16, 1), dtype=np.float32) + 1.0
    expected[:, 0, 0] = 0.0
    expected[0, :, 0] = 0.0
    assert observed.shape == (32, 32, 3)
    assert np.allclose(observed.arr_0to1, expected)

    ###################
    # test other dtypes
    ###################
    aug = iaa.PadToFixedSize(height=4, width=3, position="center-top")
    mask = np.zeros((4, 3), dtype=bool)
    mask[2, 1] = True

    # bool
    image = np.zeros((3, 3), dtype=bool)
    image[1, 1] = True
    image_aug = aug.augment_image(image)
    assert image_aug.dtype == image.dtype
    assert image_aug.shape == (4, 3)
    assert np.all(image_aug[~mask] == 0)
    assert np.all(image_aug[mask] == 1)

    # uint, int
    for dtype in [np.uint8, np.uint16, np.uint32, np.uint64, np.int8, np.int16, np.int32, np.int64]:
        min_value, center_value, max_value = iadt.get_value_range_of_dtype(dtype)

        if np.dtype(dtype).kind == "i":
            values = [1, 5, 10, 100, int(0.1 * max_value), int(0.2 * max_value),
                      int(0.5 * max_value), max_value - 100, max_value]
            values = values + [(-1) * value for value in values]
        else:
            values = [1, 5, 10, 100, int(center_value), int(0.1 * max_value), int(0.2 * max_value),
                      int(0.5 * max_value), max_value - 100, max_value]

        for value in values:
            image = np.zeros((3, 3), dtype=dtype)
            image[1, 1] = value
            image_aug = aug.augment_image(image)
            assert image_aug.dtype == np.dtype(dtype)
            assert image_aug.shape == (4, 3)
            assert np.all(image_aug[~mask] == 0)
            assert np.all(image_aug[mask] == value)

    # float
    for dtype in [np.float16, np.float32, np.float64, np.float128]:
        min_value, center_value, max_value = iadt.get_value_range_of_dtype(dtype)

        def _isclose(a, b):
            atol = 1e-4 if dtype == np.float16 else 1e-8
            return np.isclose(a, b, atol=atol, rtol=0)

        isize = np.dtype(dtype).itemsize
        values = [0.01, 1.0, 10.0, 100.0, 500 ** (isize - 1), 1000 ** (isize - 1)]
        values = values + [(-1) * value for value in values]
        values = values + [min_value, max_value]
        for value in values:
            image = np.zeros((3, 3), dtype=dtype)
            image[1, 1] = value
            image_aug = aug.augment_image(image)
            assert image_aug.dtype == np.dtype(dtype)
            assert image_aug.shape == (4, 3)
            assert np.all(_isclose(image_aug[~mask], 0))
            assert np.all(_isclose(image_aug[mask], np.float128(value)))


</source>
<source file="systems/imgaug-0.2.9/test/augmenters/test_size.py" startline="2014" endline="2223" pcid="1116">
def test_CropToFixedSize():
    reseed()

    img = np.uint8([
        [128, 129, 130],
        [131, 132, 133],
        [134, 135, 136]
    ])
    img3d = img[:, :, np.newaxis]
    img3d_rgb = np.tile(img3d, (1, 1, 3))

    # basic functionality
    aug = iaa.CropToFixedSize(height=1, width=1)
    observed = aug.augment_image(img)
    assert observed.dtype.type == np.uint8
    assert observed.shape == (1, 1)

    observed = aug.augment_image(img3d)
    assert observed.dtype.type == np.uint8
    assert observed.shape == (1, 1, 1)

    observed = aug.augment_image(img3d_rgb)
    assert observed.dtype.type == np.uint8
    assert observed.shape == (1, 1, 3)

    # test float32, float64, int32
    for dtype in [np.float32, np.float64, np.int32]:
        aug = iaa.CropToFixedSize(height=1, width=1)
        observed = aug.augment_image(img.astype(dtype))
        assert observed.dtype.type == dtype
        assert observed.shape == (1, 1)

    # change only one side when other side has already desired size
    aug = iaa.CropToFixedSize(height=3, width=5)
    observed = aug.augment_image(np.zeros((3, 5, 3), dtype=np.uint8))
    assert observed.dtype.type == np.uint8
    assert observed.shape == (3, 5, 3)

    aug = iaa.CropToFixedSize(height=5, width=3)
    observed = aug.augment_image(np.zeros((5, 3, 3), dtype=np.uint8))
    assert observed.dtype.type == np.uint8
    assert observed.shape == (5, 3, 3)

    # change no side when all sides have exactly desired size
    img5x5 = np.zeros((5, 5, 3), dtype=np.uint8)
    img5x5[2, 2, :] = 255
    aug = iaa.CropToFixedSize(height=5, width=5)
    observed = aug.augment_image(img5x5)
    assert observed.dtype.type == np.uint8
    assert observed.shape == (5, 5, 3)
    assert np.array_equal(observed, img5x5)

    # change no side when all sides have smaller than desired size
    img4x4 = np.zeros((4, 4, 3), dtype=np.uint8)
    img4x4[2, 2, :] = 255
    aug = iaa.CropToFixedSize(height=5, width=5)
    observed = aug.augment_image(img4x4)
    assert observed.dtype.type == np.uint8
    assert observed.shape == (4, 4, 3)
    assert np.array_equal(observed, img4x4)

    # explicit non-center position test
    aug = iaa.CropToFixedSize(height=3, width=3, position="left-top")
    img5x5 = np.arange(25, dtype=np.uint8).reshape((5, 5))
    observed = aug.augment_image(img5x5)
    expected = img5x5[2:, 2:]
    assert observed.dtype.type == np.uint8
    assert observed.shape == (3, 3)
    assert np.array_equal(observed, expected)

    aug = iaa.CropToFixedSize(height=3, width=3, position="right-bottom")
    img5x5 = np.arange(25, dtype=np.uint8).reshape((5, 5))
    observed = aug.augment_image(img5x5)
    expected = img5x5[:3, :3]
    assert observed.dtype.type == np.uint8
    assert observed.shape == (3, 3)
    assert np.array_equal(observed, expected)

    aug = iaa.CropToFixedSize(height=3, width=3, position=(0.5, 1.0))
    img5x5 = np.arange(25, dtype=np.uint8).reshape((5, 5))
    observed = aug.augment_image(img5x5)
    expected = img5x5[:3, 1:4]
    assert observed.dtype.type == np.uint8
    assert observed.shape == (3, 3)
    assert np.array_equal(observed, expected)

    # basic keypoint test
    kpsoi = ia.KeypointsOnImage([ia.Keypoint(x=1, y=1)], shape=(3, 3))
    aug = iaa.CropToFixedSize(height=1, width=1, position="center")
    observed = aug.augment_keypoints([kpsoi])
    expected = ia.KeypointsOnImage([ia.Keypoint(x=0, y=0)], shape=(1, 1))
    assert observed[0].shape == expected.shape
    assert keypoints_equal(observed, [expected])

    # keypoint test with shape not being changed
    kpsoi = ia.KeypointsOnImage([ia.Keypoint(x=1, y=1)], shape=(3, 3))
    aug = iaa.CropToFixedSize(height=3, width=3, position="center")
    observed = aug.augment_keypoints([kpsoi])
    expected = ia.KeypointsOnImage([ia.Keypoint(x=1, y=1)], shape=(3, 3))
    assert observed[0].shape == expected.shape
    assert keypoints_equal(observed, [expected])

    # keypoint test with explicit non-center position
    kpsoi = ia.KeypointsOnImage([ia.Keypoint(x=2, y=2)], shape=(5, 5))
    aug = iaa.CropToFixedSize(height=3, width=3, position="left-top")
    observed = aug.augment_keypoints([kpsoi])
    expected = ia.KeypointsOnImage([ia.Keypoint(x=0, y=0)], shape=(3, 3))
    assert observed[0].shape == expected.shape
    assert keypoints_equal(observed, [expected])

    kpsoi = ia.KeypointsOnImage([ia.Keypoint(x=2, y=2)], shape=(5, 5))
    aug = iaa.CropToFixedSize(height=3, width=3, position="right-bottom")
    observed = aug.augment_keypoints([kpsoi])
    expected = ia.KeypointsOnImage([ia.Keypoint(x=2, y=2)], shape=(3, 3))
    assert observed[0].shape == expected.shape
    assert keypoints_equal(observed, [expected])

    # basic heatmaps test
    heatmaps = ia.HeatmapsOnImage(np.zeros((5, 5, 1), dtype=np.float32) + 1.0, shape=(5, 5, 3))
    aug = iaa.CropToFixedSize(height=3, width=3, position="center")
    observed = aug.augment_heatmaps([heatmaps])[0]
    expected = np.zeros((3, 3, 1), dtype=np.float32) + 1.0
    assert observed.shape == (3, 3, 3)
    assert np.allclose(observed.arr_0to1, expected)

    # heatmaps, crop at non-center position
    heatmaps = np.linspace(0.0, 1.0, 5 * 5 * 1).reshape((5, 5, 1)).astype(np.float32)
    heatmaps_oi = ia.HeatmapsOnImage(heatmaps, shape=(5, 5, 3))
    aug = iaa.CropToFixedSize(height=3, width=3, position="left-top")
    observed = aug.augment_heatmaps([heatmaps_oi])[0]
    expected = heatmaps[2:, 2:, :]
    assert observed.shape == (3, 3, 3)
    assert np.allclose(observed.arr_0to1, expected)

    # heatmaps, crop at non-center position
    heatmaps = np.linspace(0.0, 1.0, 5 * 5 * 1).reshape((5, 5, 1)).astype(np.float32)
    heatmaps_oi = ia.HeatmapsOnImage(heatmaps, shape=(5, 5, 3))
    aug = iaa.CropToFixedSize(height=3, width=3, position="right-bottom")
    observed = aug.augment_heatmaps([heatmaps_oi])[0]
    expected = heatmaps[:3, :3, :]
    assert observed.shape == (3, 3, 3)
    assert np.allclose(observed.arr_0to1, expected)

    # heatmaps with size unequal to image
    heatmaps = ia.HeatmapsOnImage(np.zeros((17, 17, 1), dtype=np.float32) + 1.0, shape=(34, 34, 3))
    aug = iaa.CropToFixedSize(height=32, width=32, position="left-top")
    observed = aug.augment_heatmaps([heatmaps])[0]
    expected = np.zeros((16, 16, 1), dtype=np.float32) + 1.0
    assert observed.shape == (32, 32, 3)
    assert np.allclose(observed.arr_0to1, expected)

    ###################
    # test other dtypes
    ###################
    aug = iaa.CropToFixedSize(height=2, width=3, position="center-top")
    mask = np.zeros((2, 3), dtype=bool)
    mask[0, 1] = True

    # bool
    image = np.zeros((3, 3), dtype=bool)
    image[1, 1] = True
    image_aug = aug.augment_image(image)
    assert image_aug.dtype == image.dtype
    assert image_aug.shape == (2, 3)
    assert np.all(image_aug[~mask] == 0)
    assert np.all(image_aug[mask] == 1)

    # uint, int
    for dtype in [np.uint8, np.uint16, np.uint32, np.uint64, np.int8, np.int16, np.int32, np.int64]:
        min_value, center_value, max_value = iadt.get_value_range_of_dtype(dtype)

        if np.dtype(dtype).kind == "i":
            values = [1, 5, 10, 100, int(0.1 * max_value), int(0.2 * max_value),
                      int(0.5 * max_value), max_value - 100, max_value]
            values = values + [(-1) * value for value in values]
        else:
            values = [1, 5, 10, 100, int(center_value), int(0.1 * max_value), int(0.2 * max_value),
                      int(0.5 * max_value), max_value - 100, max_value]

        for value in values:
            image = np.zeros((3, 3), dtype=dtype)
            image[1, 1] = value
            image_aug = aug.augment_image(image)
            assert image_aug.dtype == np.dtype(dtype)
            assert image_aug.shape == (2, 3)
            assert np.all(image_aug[~mask] == 0)
            assert np.all(image_aug[mask] == value)

    # float
    for dtype in [np.float16, np.float32, np.float64, np.float128]:
        min_value, center_value, max_value = iadt.get_value_range_of_dtype(dtype)

        def _isclose(a, b):
            atol = 1e-4 if dtype == np.float16 else 1e-8
            return np.isclose(a, b, atol=atol, rtol=0)

        isize = np.dtype(dtype).itemsize
        values = [0.01, 1.0, 10.0, 100.0, 500 ** (isize - 1), 1000 ** (isize - 1)]
        values = values + [(-1) * value for value in values]
        values = values + [min_value, max_value]
        for value in values:
            image = np.zeros((3, 3), dtype=dtype)
            image[1, 1] = value
            image_aug = aug.augment_image(image)
            assert image_aug.dtype == np.dtype(dtype)
            assert image_aug.shape == (2, 3)
            assert np.all(_isclose(image_aug[~mask], 0))
            assert np.all(_isclose(image_aug[mask], np.float128(value)))


</source>
</class>

<class classid="68" nclones="2" nlines="241" similarity="72">
<source file="systems/imgaug-0.2.9/test/augmentables/test_normalization.py" startline="1327" endline="1674" pcid="1143">
    def test_normalize_keypoints(self):
        def _assert_single_image_expected(inputs):
            # --> images None
            with self.assertRaises(ValueError):
                _keypoints_norm = normalization.normalize_keypoints(
                    inputs, None)

            # --> too many images
            with self.assertRaises(ValueError):
                _keypoints_norm = normalization.normalize_keypoints(
                    inputs,
                    shapes=np.zeros((2, 1, 1, 3), dtype=np.uint8)
                )

            # --> too many images
            with self.assertRaises(ValueError):
                _keypoints_norm = normalization.normalize_keypoints(
                    inputs,
                    shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                            np.zeros((1, 1, 3), dtype=np.uint8)]
                )

        # ----
        # None
        # ----
        keypoints_norm = normalization.normalize_keypoints(None)
        assert keypoints_norm is None

        # ----
        # array
        # ----
        for dt in [np.dtype("float32"), np.dtype("int16"), np.dtype("uint16")]:
            keypoints_norm = normalization.normalize_keypoints(
                np.zeros((1, 1, 2), dtype=dt) + 1,
                shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
            )
            assert isinstance(keypoints_norm, list)
            assert isinstance(keypoints_norm[0], ia.KeypointsOnImage)
            assert len(keypoints_norm[0].keypoints) == 1
            assert np.allclose(keypoints_norm[0].to_xy_array(), 1)

            keypoints_norm = normalization.normalize_keypoints(
                np.zeros((1, 5, 2), dtype=dt) + 1,
                shapes=np.zeros((1, 1, 1, 3), dtype=np.uint8)
            )
            assert isinstance(keypoints_norm, list)
            assert isinstance(keypoints_norm[0], ia.KeypointsOnImage)
            assert len(keypoints_norm[0].keypoints) == 5
            assert np.allclose(keypoints_norm[0].to_xy_array(), 1)

            # --> keypoints for too many images
            with self.assertRaises(ValueError):
                _keypoints_norm = normalization.normalize_keypoints(
                    np.zeros((2, 1, 2), dtype=dt) + 1,
                    shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
                )

            # --> too few keypoints
            with self.assertRaises(ValueError):
                _keypoints_norm = normalization.normalize_keypoints(
                    np.zeros((1, 1, 2), dtype=dt) + 1,
                    shapes=np.zeros((2, 1, 1, 3), dtype=np.uint8)
                )

            # --> wrong keypoints shape
            with self.assertRaises(ValueError):
                _keypoints_norm = normalization.normalize_keypoints(
                    np.zeros((1, 1, 100), dtype=dt) + 1,
                    shapes=np.zeros((1, 1, 1, 3), dtype=np.uint8)
                )

            _assert_single_image_expected(np.zeros((1, 1, 2), dtype=dt) + 1)

        # ----
        # (x,y)
        # ----
        keypoints_norm = normalization.normalize_keypoints(
            (1, 2),
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert isinstance(keypoints_norm, list)
        assert isinstance(keypoints_norm[0], ia.KeypointsOnImage)
        assert len(keypoints_norm[0].keypoints) == 1
        assert keypoints_norm[0].keypoints[0].x == 1
        assert keypoints_norm[0].keypoints[0].y == 2

        _assert_single_image_expected((1, 2))

        # ----
        # single Keypoint instance
        # ----
        keypoints_norm = normalization.normalize_keypoints(
            ia.Keypoint(x=1, y=2),
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert isinstance(keypoints_norm, list)
        assert isinstance(keypoints_norm[0], ia.KeypointsOnImage)
        assert len(keypoints_norm[0].keypoints) == 1
        assert keypoints_norm[0].keypoints[0].x == 1
        assert keypoints_norm[0].keypoints[0].y == 2

        _assert_single_image_expected(ia.Keypoint(x=1, y=2))

        # ----
        # single KeypointsOnImage instance
        # ----
        keypoints_norm = normalization.normalize_keypoints(
            ia.KeypointsOnImage([ia.Keypoint(x=1, y=2)], shape=(1, 1, 3)),
            shapes=None
        )
        assert isinstance(keypoints_norm, list)
        assert isinstance(keypoints_norm[0], ia.KeypointsOnImage)
        assert len(keypoints_norm[0].keypoints) == 1
        assert keypoints_norm[0].keypoints[0].x == 1
        assert keypoints_norm[0].keypoints[0].y == 2

        # ----
        # empty iterable
        # ----
        keypoints_norm = normalization.normalize_keypoints(
            [], shapes=None
        )
        assert keypoints_norm is None

        # ----
        # iterable of array
        # ----
        for dt in [np.dtype("float32"), np.dtype("int16"), np.dtype("uint16")]:
            keypoints_norm = normalization.normalize_keypoints(
                [np.zeros((1, 2), dtype=dt) + 1],
                shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
            )
            assert isinstance(keypoints_norm, list)
            assert isinstance(keypoints_norm[0], ia.KeypointsOnImage)
            assert len(keypoints_norm[0].keypoints) == 1
            assert np.allclose(keypoints_norm[0].to_xy_array(), 1)

            keypoints_norm = normalization.normalize_keypoints(
                [np.zeros((5, 2), dtype=dt) + 1],
                shapes=np.zeros((1, 1, 1, 3), dtype=np.uint8)
            )
            assert isinstance(keypoints_norm, list)
            assert isinstance(keypoints_norm[0], ia.KeypointsOnImage)
            assert len(keypoints_norm[0].keypoints) == 5
            assert np.allclose(keypoints_norm[0].to_xy_array(), 1)

            # --> keypoints for too many images
            with self.assertRaises(ValueError):
                _keypoints_norm = normalization.normalize_keypoints(
                    [
                        np.zeros((1, 2), dtype=dt) + 1,
                        np.zeros((1, 2), dtype=dt) + 1
                    ],
                    shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
                )

            # --> too few keypoints
            with self.assertRaises(ValueError):
                _keypoints_norm = normalization.normalize_keypoints(
                    [np.zeros((1, 2), dtype=dt) + 1],
                    shapes=np.zeros((2, 1, 1, 3), dtype=np.uint8)
                )

            # --> images None
            with self.assertRaises(ValueError):
                _keypoints_norm = normalization.normalize_keypoints(
                    [np.zeros((1, 2), dtype=dt) + 1],
                    shapes=None
                )

            # --> wrong shape
            with self.assertRaises(ValueError):
                _keypoints_norm = normalization.normalize_keypoints(
                    [np.zeros((1, 100), dtype=dt) + 1],
                    shapes=np.zeros((1, 1, 1, 3), dtype=np.uint8)
                )

        # ----
        # iterable of (x,y)
        # ----
        keypoints_norm = normalization.normalize_keypoints(
            [(1, 2), (3, 4)],
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert isinstance(keypoints_norm, list)
        assert isinstance(keypoints_norm[0], ia.KeypointsOnImage)
        assert len(keypoints_norm[0].keypoints) == 2
        assert keypoints_norm[0].keypoints[0].x == 1
        assert keypoints_norm[0].keypoints[0].y == 2
        assert keypoints_norm[0].keypoints[1].x == 3
        assert keypoints_norm[0].keypoints[1].y == 4

        # may only be used for single images
        with self.assertRaises(ValueError):
            _keypoints_norm = normalization.normalize_keypoints(
                [(1, 2)],
                shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                        np.zeros((1, 1, 3), dtype=np.uint8)]
            )

        # ----
        # iterable of Keypoint
        # ----
        keypoints_norm = normalization.normalize_keypoints(
            [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=4)],
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert isinstance(keypoints_norm, list)
        assert isinstance(keypoints_norm[0], ia.KeypointsOnImage)
        assert len(keypoints_norm[0].keypoints) == 2
        assert keypoints_norm[0].keypoints[0].x == 1
        assert keypoints_norm[0].keypoints[0].y == 2
        assert keypoints_norm[0].keypoints[1].x == 3
        assert keypoints_norm[0].keypoints[1].y == 4

        # may only be used for single images
        with self.assertRaises(ValueError):
            _keypoints_norm = normalization.normalize_keypoints(
                [ia.Keypoint(x=1, y=2)],
                shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                        np.zeros((1, 1, 3), dtype=np.uint8)]
            )

        # ----
        # iterable of KeypointsOnImage
        # ----
        keypoints_norm = normalization.normalize_keypoints(
            [
                ia.KeypointsOnImage([ia.Keypoint(x=1, y=2)], shape=(1, 1, 3)),
                ia.KeypointsOnImage([ia.Keypoint(x=3, y=4)], shape=(1, 1, 3)),
            ],
            shapes=None
        )
        assert isinstance(keypoints_norm, list)

        assert isinstance(keypoints_norm[0], ia.KeypointsOnImage)
        assert len(keypoints_norm[0].keypoints) == 1
        assert keypoints_norm[0].keypoints[0].x == 1
        assert keypoints_norm[0].keypoints[0].y == 2

        assert isinstance(keypoints_norm[1], ia.KeypointsOnImage)
        assert len(keypoints_norm[1].keypoints) == 1
        assert keypoints_norm[1].keypoints[0].x == 3
        assert keypoints_norm[1].keypoints[0].y == 4

        # ----
        # iterable of empty interables
        # ----
        keypoints_norm = normalization.normalize_keypoints(
            [[]],
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert keypoints_norm is None

        # ----
        # iterable of iterable of (x,y)
        # ----
        keypoints_norm = normalization.normalize_keypoints(
            [
                [(1, 2), (3, 4)],
                [(5, 6), (7, 8)]
            ],
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                    np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert isinstance(keypoints_norm, list)
        assert isinstance(keypoints_norm[0], ia.KeypointsOnImage)
        assert len(keypoints_norm[0].keypoints) == 2
        assert keypoints_norm[0].keypoints[0].x == 1
        assert keypoints_norm[0].keypoints[0].y == 2
        assert keypoints_norm[0].keypoints[1].x == 3
        assert keypoints_norm[0].keypoints[1].y == 4

        assert len(keypoints_norm[1].keypoints) == 2
        assert keypoints_norm[1].keypoints[0].x == 5
        assert keypoints_norm[1].keypoints[0].y == 6
        assert keypoints_norm[1].keypoints[1].x == 7
        assert keypoints_norm[1].keypoints[1].y == 8

        # --> images None
        with self.assertRaises(ValueError):
            _keypoints_norm = normalization.normalize_keypoints(
                [
                    [(1, 2), (3, 4)],
                    [(5, 6), (7, 8)]
                ],
                shapes=None
            )

        # --> different number of images
        with self.assertRaises(ValueError):
            _keypoints_norm = normalization.normalize_keypoints(
                [
                    [(1, 2), (3, 4)],
                    [(5, 6), (7, 8)]
                ],
                shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                        np.zeros((1, 1, 3), dtype=np.uint8),
                        np.zeros((1, 1, 3), dtype=np.uint8)]
            )

        # ----
        # iterable of iterable of Keypoint
        # ----
        keypoints_norm = normalization.normalize_keypoints(
            [
                [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=4)],
                [ia.Keypoint(x=5, y=6), ia.Keypoint(x=7, y=8)]
            ],
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                    np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert isinstance(keypoints_norm, list)
        assert isinstance(keypoints_norm[0], ia.KeypointsOnImage)
        assert len(keypoints_norm[0].keypoints) == 2
        assert keypoints_norm[0].keypoints[0].x == 1
        assert keypoints_norm[0].keypoints[0].y == 2
        assert keypoints_norm[0].keypoints[1].x == 3
        assert keypoints_norm[0].keypoints[1].y == 4

        assert len(keypoints_norm[1].keypoints) == 2
        assert keypoints_norm[1].keypoints[0].x == 5
        assert keypoints_norm[1].keypoints[0].y == 6
        assert keypoints_norm[1].keypoints[1].x == 7
        assert keypoints_norm[1].keypoints[1].y == 8

        # --> images None
        with self.assertRaises(ValueError):
            _keypoints_norm = normalization.normalize_keypoints(
                [
                    [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=4)],
                    [ia.Keypoint(x=5, y=6), ia.Keypoint(x=7, y=8)]
                ],
                shapes=None
            )

        # --> different number of images
        with self.assertRaises(ValueError):
            _keypoints_norm = normalization.normalize_keypoints(
                [
                    [ia.Keypoint(x=1, y=2), ia.Keypoint(x=3, y=4)],
                    [ia.Keypoint(x=5, y=6), ia.Keypoint(x=7, y=8)]
                ],
                shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                        np.zeros((1, 1, 3), dtype=np.uint8),
                        np.zeros((1, 1, 3), dtype=np.uint8)]
            )

</source>
<source file="systems/imgaug-0.2.9/test/augmentables/test_normalization.py" startline="1675" endline="2068" pcid="1145">
    def test_normalize_bounding_boxes(self):
        def _assert_single_image_expected(inputs):
            # --> images None
            with self.assertRaises(ValueError):
                _bbs_norm = normalization.normalize_bounding_boxes(
                    inputs,
                    shapes=None
                )

            # --> too many images
            with self.assertRaises(ValueError):
                _bbs_norm = normalization.normalize_bounding_boxes(
                    inputs,
                    shapes=np.zeros((2, 1, 1, 3), dtype=np.uint8)
                )

            # --> too many images
            with self.assertRaises(ValueError):
                _bbs_norm = normalization.normalize_bounding_boxes(
                    inputs,
                    shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                            np.zeros((1, 1, 3), dtype=np.uint8)]
                )

        # ----
        # None
        # ----
        bbs_norm = normalization.normalize_bounding_boxes(None)
        assert bbs_norm is None

        # ----
        # array
        # ----
        for dt in [np.dtype("float32"), np.dtype("int16"), np.dtype("uint16")]:
            bbs_norm = normalization.normalize_bounding_boxes(
                np.zeros((1, 1, 4), dtype=dt) + 1,
                shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
            )
            assert isinstance(bbs_norm, list)
            assert isinstance(bbs_norm[0], ia.BoundingBoxesOnImage)
            assert len(bbs_norm[0].bounding_boxes) == 1
            assert np.allclose(bbs_norm[0].to_xyxy_array(), 1)

            bbs_norm = normalization.normalize_bounding_boxes(
                np.zeros((1, 5, 4), dtype=dt) + 1,
                shapes=np.zeros((1, 1, 1, 3), dtype=np.uint8)
            )
            assert isinstance(bbs_norm, list)
            assert isinstance(bbs_norm[0], ia.BoundingBoxesOnImage)
            assert len(bbs_norm[0].bounding_boxes) == 5
            assert np.allclose(bbs_norm[0].to_xyxy_array(), 1)

            # --> bounding boxes for too many images
            with self.assertRaises(ValueError):
                _bbs_norm = normalization.normalize_bounding_boxes(
                    np.zeros((2, 1, 4), dtype=dt) + 1,
                    shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
                )

            # --> too few bounding boxes
            with self.assertRaises(ValueError):
                _bbs_norm = normalization.normalize_bounding_boxes(
                    np.zeros((1, 1, 4), dtype=dt) + 1,
                    shapes=np.zeros((2, 1, 1, 3), dtype=np.uint8)
                )

            # --> wrong keypoints shape
            with self.assertRaises(ValueError):
                _bbs_norm = normalization.normalize_bounding_boxes(
                    np.zeros((1, 1, 100), dtype=dt) + 1,
                    shapes=np.zeros((1, 1, 1, 3), dtype=np.uint8)
                )

            _assert_single_image_expected(np.zeros((1, 1, 4), dtype=dt) + 1)

        # ----
        # (x1,y1,x2,y2)
        # ----
        bbs_norm = normalization.normalize_bounding_boxes(
            (1, 2, 3, 4),
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert isinstance(bbs_norm, list)
        assert isinstance(bbs_norm[0], ia.BoundingBoxesOnImage)
        assert len(bbs_norm[0].bounding_boxes) == 1
        assert bbs_norm[0].bounding_boxes[0].x1 == 1
        assert bbs_norm[0].bounding_boxes[0].y1 == 2
        assert bbs_norm[0].bounding_boxes[0].x2 == 3
        assert bbs_norm[0].bounding_boxes[0].y2 == 4

        _assert_single_image_expected((1, 2, 3, 4))

        # ----
        # single BoundingBox instance
        # ----
        bbs_norm = normalization.normalize_bounding_boxes(
            ia.BoundingBox(x1=1, y1=2, x2=3, y2=4),
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert isinstance(bbs_norm, list)
        assert isinstance(bbs_norm[0], ia.BoundingBoxesOnImage)
        assert len(bbs_norm[0].bounding_boxes) == 1
        assert bbs_norm[0].bounding_boxes[0].x1 == 1
        assert bbs_norm[0].bounding_boxes[0].y1 == 2
        assert bbs_norm[0].bounding_boxes[0].x2 == 3
        assert bbs_norm[0].bounding_boxes[0].y2 == 4

        _assert_single_image_expected(ia.BoundingBox(x1=1, y1=2, x2=3, y2=4))

        # ----
        # single BoundingBoxesOnImage instance
        # ----
        bbs_norm = normalization.normalize_bounding_boxes(
            ia.BoundingBoxesOnImage(
                [ia.BoundingBox(x1=1, y1=2, x2=3, y2=4)],
                shape=(1, 1, 3)),
            shapes=None
        )
        assert isinstance(bbs_norm, list)
        assert isinstance(bbs_norm[0], ia.BoundingBoxesOnImage)
        assert len(bbs_norm[0].bounding_boxes) == 1
        assert bbs_norm[0].bounding_boxes[0].x1 == 1
        assert bbs_norm[0].bounding_boxes[0].y1 == 2
        assert bbs_norm[0].bounding_boxes[0].x2 == 3
        assert bbs_norm[0].bounding_boxes[0].y2 == 4

        # ----
        # empty iterable
        # ----
        bbs_norm = normalization.normalize_bounding_boxes([], shapes=None)
        assert bbs_norm is None

        # ----
        # iterable of array
        # ----
        for dt in [np.dtype("float32"), np.dtype("int16"), np.dtype("uint16")]:
            bbs_norm = normalization.normalize_bounding_boxes(
                [np.zeros((1, 4), dtype=dt) + 1],
                shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
            )
            assert isinstance(bbs_norm, list)
            assert isinstance(bbs_norm[0], ia.BoundingBoxesOnImage)
            assert len(bbs_norm[0].bounding_boxes) == 1
            assert np.allclose(bbs_norm[0].to_xyxy_array(), 1)

            bbs_norm = normalization.normalize_bounding_boxes(
                [np.zeros((5, 4), dtype=dt) + 1],
                shapes=np.zeros((1, 1, 1, 3), dtype=np.uint8)
            )
            assert isinstance(bbs_norm, list)
            assert isinstance(bbs_norm[0], ia.BoundingBoxesOnImage)
            assert len(bbs_norm[0].bounding_boxes) == 5
            assert np.allclose(bbs_norm[0].to_xyxy_array(), 1)

            # --> bounding boxes for too many images
            with self.assertRaises(ValueError):
                _bbs_norm = normalization.normalize_bounding_boxes(
                    [
                        np.zeros((1, 4), dtype=dt) + 1,
                        np.zeros((1, 4), dtype=dt) + 1
                    ],
                    shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
                )

            # --> too few bounding boxes
            with self.assertRaises(ValueError):
                _bbs_norm = normalization.normalize_bounding_boxes(
                    [np.zeros((1, 4), dtype=dt) + 1],
                    shapes=np.zeros((2, 1, 1, 3), dtype=np.uint8)
                )

            # --> images None
            with self.assertRaises(ValueError):
                _bbs_norm = normalization.normalize_bounding_boxes(
                    [np.zeros((1, 4), dtype=dt) + 1],
                    shapes=None
                )

            # --> wrong shape
            with self.assertRaises(ValueError):
                _bbs_norm = normalization.normalize_bounding_boxes(
                    [np.zeros((1, 100), dtype=dt) + 1],
                    shapes=np.zeros((1, 1, 1, 3), dtype=np.uint8)
                )

        # ----
        # iterable of (x1,y1,x2,y2)
        # ----
        bbs_norm = normalization.normalize_bounding_boxes(
            [(1, 2, 3, 4), (5, 6, 7, 8)],
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert isinstance(bbs_norm, list)
        assert isinstance(bbs_norm[0], ia.BoundingBoxesOnImage)
        assert len(bbs_norm[0].bounding_boxes) == 2
        assert bbs_norm[0].bounding_boxes[0].x1 == 1
        assert bbs_norm[0].bounding_boxes[0].y1 == 2
        assert bbs_norm[0].bounding_boxes[0].x2 == 3
        assert bbs_norm[0].bounding_boxes[0].y2 == 4
        assert bbs_norm[0].bounding_boxes[1].x1 == 5
        assert bbs_norm[0].bounding_boxes[1].y1 == 6
        assert bbs_norm[0].bounding_boxes[1].x2 == 7
        assert bbs_norm[0].bounding_boxes[1].y2 == 8

        # may only be used for single images
        with self.assertRaises(ValueError):
            _bbs_norm = normalization.normalize_bounding_boxes(
                [(1, 2, 3, 4)],
                shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                        np.zeros((1, 1, 3), dtype=np.uint8)]
            )

        # ----
        # iterable of BoundingBox
        # ----
        bbs_norm = normalization.normalize_bounding_boxes(
            [
                ia.BoundingBox(x1=1, y1=2, x2=3, y2=4),
                ia.BoundingBox(x1=5, y1=6, x2=7, y2=8)
            ],
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert isinstance(bbs_norm, list)
        assert isinstance(bbs_norm[0], ia.BoundingBoxesOnImage)
        assert len(bbs_norm[0].bounding_boxes) == 2
        assert bbs_norm[0].bounding_boxes[0].x1 == 1
        assert bbs_norm[0].bounding_boxes[0].y1 == 2
        assert bbs_norm[0].bounding_boxes[0].x2 == 3
        assert bbs_norm[0].bounding_boxes[0].y2 == 4
        assert bbs_norm[0].bounding_boxes[1].x1 == 5
        assert bbs_norm[0].bounding_boxes[1].y1 == 6
        assert bbs_norm[0].bounding_boxes[1].x2 == 7
        assert bbs_norm[0].bounding_boxes[1].y2 == 8

        # may only be used for single images
        with self.assertRaises(ValueError):
            _bbs_norm = normalization.normalize_bounding_boxes(
                [ia.BoundingBox(x1=1, y1=2, x2=3, y2=4)],
                shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                        np.zeros((1, 1, 3), dtype=np.uint8)]
            )

        # ----
        # iterable of BoundingBoxesOnImage
        # ----
        bbs_norm = normalization.normalize_bounding_boxes(
            [
                ia.BoundingBoxesOnImage(
                    [ia.BoundingBox(x1=1, y1=2, x2=3, y2=4)],
                    shape=(1, 1, 3)),
                ia.BoundingBoxesOnImage(
                    [ia.BoundingBox(x1=5, y1=6, x2=7, y2=8)],
                    shape=(1, 1, 3))
            ],
            shapes=None
        )
        assert isinstance(bbs_norm, list)

        assert isinstance(bbs_norm[0], ia.BoundingBoxesOnImage)
        assert len(bbs_norm[0].bounding_boxes) == 1
        assert bbs_norm[0].bounding_boxes[0].x1 == 1
        assert bbs_norm[0].bounding_boxes[0].y1 == 2
        assert bbs_norm[0].bounding_boxes[0].x2 == 3
        assert bbs_norm[0].bounding_boxes[0].y2 == 4

        assert isinstance(bbs_norm[1], ia.BoundingBoxesOnImage)
        assert len(bbs_norm[1].bounding_boxes) == 1
        assert bbs_norm[1].bounding_boxes[0].x1 == 5
        assert bbs_norm[1].bounding_boxes[0].y1 == 6
        assert bbs_norm[1].bounding_boxes[0].x2 == 7
        assert bbs_norm[1].bounding_boxes[0].y2 == 8

        # ----
        # iterable of empty interables
        # ----
        bbs_norm = normalization.normalize_bounding_boxes(
            [[]],
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert bbs_norm is None

        # ----
        # iterable of iterable of (x1,y1,x2,y2)
        # ----
        bbs_norm = normalization.normalize_bounding_boxes(
            [
                [(1, 2, 3, 4)],
                [(5, 6, 7, 8), (9, 10, 11, 12)]
            ],
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                    np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert isinstance(bbs_norm, list)
        assert isinstance(bbs_norm[0], ia.BoundingBoxesOnImage)
        assert len(bbs_norm[0].bounding_boxes) == 1
        assert bbs_norm[0].bounding_boxes[0].x1 == 1
        assert bbs_norm[0].bounding_boxes[0].y1 == 2
        assert bbs_norm[0].bounding_boxes[0].x2 == 3
        assert bbs_norm[0].bounding_boxes[0].y2 == 4

        assert len(bbs_norm[1].bounding_boxes) == 2
        assert bbs_norm[1].bounding_boxes[0].x1 == 5
        assert bbs_norm[1].bounding_boxes[0].y1 == 6
        assert bbs_norm[1].bounding_boxes[0].x2 == 7
        assert bbs_norm[1].bounding_boxes[0].y2 == 8

        assert bbs_norm[1].bounding_boxes[1].x1 == 9
        assert bbs_norm[1].bounding_boxes[1].y1 == 10
        assert bbs_norm[1].bounding_boxes[1].x2 == 11
        assert bbs_norm[1].bounding_boxes[1].y2 == 12

        # --> images None
        with self.assertRaises(ValueError):
            _bbs_norm = normalization.normalize_bounding_boxes(
                [
                    [(1, 2, 3, 4), (3, 4, 5, 6)],
                    [(5, 6, 7, 8), (7, 8, 9, 10)]
                ],
                shapes=None
            )

        # --> different number of images
        with self.assertRaises(ValueError):
            _bbs_norm = normalization.normalize_bounding_boxes(
                [
                    [(1, 2, 3, 4)],
                    [(5, 6, 7, 8)]
                ],
                [np.zeros((1, 1, 3), dtype=np.uint8),
                 np.zeros((1, 1, 3), dtype=np.uint8),
                 np.zeros((1, 1, 3), dtype=np.uint8)]
            )

        # ----
        # iterable of iterable of Keypoint
        # ----
        bbs_norm = normalization.normalize_bounding_boxes(
            [
                [ia.BoundingBox(x1=1, y1=2, x2=3, y2=4),
                 ia.BoundingBox(x1=5, y1=6, x2=7, y2=8)],
                [ia.BoundingBox(x1=9, y1=10, x2=11, y2=12),
                 ia.BoundingBox(x1=13, y1=14, x2=15, y2=16)]
            ],
            shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                    np.zeros((1, 1, 3), dtype=np.uint8)]
        )
        assert isinstance(bbs_norm, list)
        assert isinstance(bbs_norm[0], ia.BoundingBoxesOnImage)
        assert len(bbs_norm[0].bounding_boxes) == 2
        assert bbs_norm[0].bounding_boxes[0].x1 == 1
        assert bbs_norm[0].bounding_boxes[0].y1 == 2
        assert bbs_norm[0].bounding_boxes[0].x2 == 3
        assert bbs_norm[0].bounding_boxes[0].y2 == 4
        assert bbs_norm[0].bounding_boxes[1].x1 == 5
        assert bbs_norm[0].bounding_boxes[1].y1 == 6
        assert bbs_norm[0].bounding_boxes[1].x2 == 7
        assert bbs_norm[0].bounding_boxes[1].y2 == 8

        assert len(bbs_norm[1].bounding_boxes) == 2
        assert bbs_norm[1].bounding_boxes[0].x1 == 9
        assert bbs_norm[1].bounding_boxes[0].y1 == 10
        assert bbs_norm[1].bounding_boxes[0].x2 == 11
        assert bbs_norm[1].bounding_boxes[0].y2 == 12
        assert bbs_norm[1].bounding_boxes[1].x1 == 13
        assert bbs_norm[1].bounding_boxes[1].y1 == 14
        assert bbs_norm[1].bounding_boxes[1].x2 == 15
        assert bbs_norm[1].bounding_boxes[1].y2 == 16

        # --> images None
        with self.assertRaises(ValueError):
            _bbs_norm = normalization.normalize_bounding_boxes(
                [
                    [ia.BoundingBox(x1=1, y1=2, x2=3, y2=4),
                     ia.BoundingBox(x1=5, y1=6, x2=7, y2=8)],
                    [ia.BoundingBox(x1=9, y1=10, x2=11, y2=12),
                     ia.BoundingBox(x1=13, y1=14, x2=15, y2=16)]
                ],
                shapes=None
            )

        # --> different number of images
        with self.assertRaises(ValueError):
            _bbs_norm = normalization.normalize_bounding_boxes(
                [
                    [ia.BoundingBox(x1=1, y1=2, x2=3, y2=4),
                     ia.BoundingBox(x1=5, y1=6, x2=7, y2=8)],
                    [ia.BoundingBox(x1=9, y1=10, x2=11, y2=12),
                     ia.BoundingBox(x1=13, y1=14, x2=15, y2=16)]
                ],
                shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                        np.zeros((1, 1, 3), dtype=np.uint8),
                        np.zeros((1, 1, 3), dtype=np.uint8)]
            )
    
</source>
</class>

<class classid="69" nclones="3" nlines="13" similarity="85">
<source file="systems/imgaug-0.2.9/test/augmentables/test_normalization.py" startline="1328" endline="1351" pcid="1144">
        def _assert_single_image_expected(inputs):
            # --> images None
            with self.assertRaises(ValueError):
                _keypoints_norm = normalization.normalize_keypoints(
                    inputs, None)

            # --> too many images
            with self.assertRaises(ValueError):
                _keypoints_norm = normalization.normalize_keypoints(
                    inputs,
                    shapes=np.zeros((2, 1, 1, 3), dtype=np.uint8)
                )

            # --> too many images
            with self.assertRaises(ValueError):
                _keypoints_norm = normalization.normalize_keypoints(
                    inputs,
                    shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                            np.zeros((1, 1, 3), dtype=np.uint8)]
                )

        # ----
        # None
        # ----
</source>
<source file="systems/imgaug-0.2.9/test/augmentables/test_normalization.py" startline="2070" endline="2089" pcid="1148">
        def _assert_single_image_expected(inputs):
            # --> images None
            with self.assertRaises(ValueError):
                _polygons_norm = normalization.normalize_polygons(
                    inputs, shapes=None)

            # --> too many images
            with self.assertRaises(ValueError):
                _polygons_norm = normalization.normalize_polygons(
                    inputs,
                    shapes=np.zeros((2, 1, 1, 3), dtype=np.uint8))

            # --> too many images
            with self.assertRaises(ValueError):
                _polygons_norm = normalization.normalize_polygons(
                    inputs,
                    shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                            np.zeros((1, 1, 3), dtype=np.uint8)]
                )

</source>
<source file="systems/imgaug-0.2.9/test/augmentables/test_normalization.py" startline="1676" endline="1701" pcid="1146">
        def _assert_single_image_expected(inputs):
            # --> images None
            with self.assertRaises(ValueError):
                _bbs_norm = normalization.normalize_bounding_boxes(
                    inputs,
                    shapes=None
                )

            # --> too many images
            with self.assertRaises(ValueError):
                _bbs_norm = normalization.normalize_bounding_boxes(
                    inputs,
                    shapes=np.zeros((2, 1, 1, 3), dtype=np.uint8)
                )

            # --> too many images
            with self.assertRaises(ValueError):
                _bbs_norm = normalization.normalize_bounding_boxes(
                    inputs,
                    shapes=[np.zeros((1, 1, 3), dtype=np.uint8),
                            np.zeros((1, 1, 3), dtype=np.uint8)]
                )

        # ----
        # None
        # ----
</source>
</class>

<class classid="70" nclones="2" nlines="40" similarity="70">
<source file="systems/imgaug-0.2.9/test/augmentables/test_normalization.py" startline="2901" endline="2960" pcid="1152">
    def test_estimate_heatmaps_norm_type(self):
        ntype = normalization.estimate_heatmaps_norm_type(None)
        assert ntype == "None"

        ntype = normalization.estimate_heatmaps_norm_type(
            np.zeros((1, 1, 1, 1), dtype=np.float32))
        assert ntype == "array[float]"

        ntype = normalization.estimate_heatmaps_norm_type(
            ia.HeatmapsOnImage(
                np.zeros((1, 1, 1), dtype=np.float32),
                shape=(1, 1, 1)
            )
        )
        assert ntype == "HeatmapsOnImage"

        ntype = normalization.estimate_heatmaps_norm_type([])
        assert ntype == "iterable[empty]"

        ntype = normalization.estimate_heatmaps_norm_type(
            [np.zeros((1, 1, 1), dtype=np.float32)])
        assert ntype == "iterable-array[float]"

        ntype = normalization.estimate_heatmaps_norm_type([
            ia.HeatmapsOnImage(np.zeros((1, 1, 1), dtype=np.float32),
                               shape=(1, 1, 1))
        ])
        assert ntype == "iterable-HeatmapsOnImage"

        # --
        # error cases
        # --
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_heatmaps_norm_type(1)

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_heatmaps_norm_type("foo")

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_heatmaps_norm_type(
                np.zeros((1, 1, 1), dtype=np.int32))

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_heatmaps_norm_type([1])

        # wrong class
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_heatmaps_norm_type(
                ia.KeypointsOnImage([], shape=(1, 1, 1)))

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_heatmaps_norm_type([[]])

        # list of list of Heatmaps, only list of Heatmaps is max
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_heatmaps_norm_type([
                [ia.HeatmapsOnImage(np.zeros((1, 1, 1), dtype=np.float32),
                                    shape=(1, 1, 1))]
            ])

</source>
<source file="systems/imgaug-0.2.9/test/augmentables/test_normalization.py" startline="2961" endline="3022" pcid="1153">
    def test_estimate_segmaps_norm_type(self):
        ntype = normalization.estimate_segmaps_norm_type(None)
        assert ntype == "None"

        for name, dt in zip(["int", "uint", "bool"],
                            [np.int32, np.uint16, bool]):
            ntype = normalization.estimate_segmaps_norm_type(
                np.zeros((1, 1, 1, 1), dtype=dt))
            assert ntype == "array[%s]" % (name,)

        ntype = normalization.estimate_segmaps_norm_type(
            ia.SegmentationMapOnImage(
                np.zeros((1, 1, 1), dtype=np.int32),
                shape=(1, 1, 1),
                nb_classes=1
            )
        )
        assert ntype == "SegmentationMapOnImage"

        ntype = normalization.estimate_segmaps_norm_type([])
        assert ntype == "iterable[empty]"

        ntype = normalization.estimate_segmaps_norm_type(
            [np.zeros((1, 1, 1), dtype=np.int32)])
        assert ntype == "iterable-array[int]"

        ntype = normalization.estimate_segmaps_norm_type([
            ia.SegmentationMapOnImage(np.zeros((1, 1, 1), dtype=np.int32),
                                      shape=(1, 1, 1),
                                      nb_classes=1)
        ])
        assert ntype == "iterable-SegmentationMapOnImage"

        # --
        # error cases
        # --
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_segmaps_norm_type(1)

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_segmaps_norm_type("foo")

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_segmaps_norm_type([1])

        # wrong class
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_segmaps_norm_type(
                ia.KeypointsOnImage([], shape=(1, 1, 1)))

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_segmaps_norm_type([[]])

        # list of list of SegMap, only list of SegMap is max
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_segmaps_norm_type([
                [ia.SegmentationMapOnImage(
                    np.zeros((1, 1, 1), dtype=np.int32),
                    shape=(1, 1, 1),
                    nb_classes=1)]
            ])

</source>
</class>

<class classid="71" nclones="2" nlines="55" similarity="71">
<source file="systems/imgaug-0.2.9/test/augmentables/test_normalization.py" startline="3023" endline="3100" pcid="1154">
    def test_estimate_keypoints_norm_type(self):
        ntype = normalization.estimate_keypoints_norm_type(None)
        assert ntype == "None"

        for name, dt in zip(["float", "int", "uint"],
                            [np.float32, np.int32, np.uint16]):
            ntype = normalization.estimate_keypoints_norm_type(
                np.zeros((1, 5, 2), dtype=dt))
            assert ntype == "array[%s]" % (name,)

        ntype = normalization.estimate_keypoints_norm_type((1, 2))
        assert ntype == "tuple[number,size=2]"

        ntype = normalization.estimate_keypoints_norm_type(
            ia.Keypoint(x=1, y=2))
        assert ntype == "Keypoint"

        ntype = normalization.estimate_keypoints_norm_type(
            ia.KeypointsOnImage([ia.Keypoint(x=1, y=2)], shape=(1, 1, 3)))
        assert ntype == "KeypointsOnImage"

        ntype = normalization.estimate_keypoints_norm_type([])
        assert ntype == "iterable[empty]"

        for name, dt in zip(["float", "int", "uint"],
                            [np.float32, np.int32, np.uint16]):
            ntype = normalization.estimate_keypoints_norm_type(
                [np.zeros((5, 2), dtype=dt)])
            assert ntype == "iterable-array[%s]" % (name,)

        ntype = normalization.estimate_keypoints_norm_type([(1, 2)])
        assert ntype == "iterable-tuple[number,size=2]"

        ntype = normalization.estimate_keypoints_norm_type(
            [ia.Keypoint(x=1, y=2)])
        assert ntype == "iterable-Keypoint"

        ntype = normalization.estimate_keypoints_norm_type([
            ia.KeypointsOnImage([ia.Keypoint(x=1, y=2)], shape=(1, 1, 3))])
        assert ntype == "iterable-KeypointsOnImage"

        ntype = normalization.estimate_keypoints_norm_type([[]])
        assert ntype == "iterable-iterable[empty]"

        ntype = normalization.estimate_keypoints_norm_type([[(1, 2)]])
        assert ntype == "iterable-iterable-tuple[number,size=2]"

        ntype = normalization.estimate_keypoints_norm_type(
            [[ia.Keypoint(x=1, y=2)]])
        assert ntype == "iterable-iterable-Keypoint"

        # --
        # error cases
        # --
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_keypoints_norm_type(1)

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_keypoints_norm_type("foo")

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_keypoints_norm_type([1])

        # wrong class
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_keypoints_norm_type(
                ia.HeatmapsOnImage(np.zeros((1, 1, 1), dtype=np.float32),
                                   shape=(1, 1, 1)))

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_keypoints_norm_type([[[]]])

        # list of list of list of keypoints,
        # only list of list of keypoints is max
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_keypoints_norm_type(
                [[[ia.Keypoint(x=1, y=2)]]])

</source>
<source file="systems/imgaug-0.2.9/test/augmentables/test_normalization.py" startline="3101" endline="3183" pcid="1155">
    def test_estimate_bounding_boxes_norm_type(self):
        ntype = normalization.estimate_bounding_boxes_norm_type(None)
        assert ntype == "None"

        for name, dt in zip(["float", "int", "uint"],
                            [np.float32, np.int32, np.uint16]):
            ntype = normalization.estimate_bounding_boxes_norm_type(
                np.zeros((1, 5, 4), dtype=dt))
            assert ntype == "array[%s]" % (name,)

        ntype = normalization.estimate_bounding_boxes_norm_type((1, 2, 3, 4))
        assert ntype == "tuple[number,size=4]"

        ntype = normalization.estimate_bounding_boxes_norm_type(
            ia.BoundingBox(x1=1, y1=2, x2=3, y2=4))
        assert ntype == "BoundingBox"

        ntype = normalization.estimate_bounding_boxes_norm_type(
            ia.BoundingBoxesOnImage(
                [ia.BoundingBox(x1=1, y1=2, x2=3, y2=4)], shape=(1, 1, 3)))
        assert ntype == "BoundingBoxesOnImage"

        ntype = normalization.estimate_bounding_boxes_norm_type([])
        assert ntype == "iterable[empty]"

        for name, dt in zip(["float", "int", "uint"],
                            [np.float32, np.int32, np.uint16]):
            ntype = normalization.estimate_bounding_boxes_norm_type(
                [np.zeros((5, 4), dtype=dt)])
            assert ntype == "iterable-array[%s]" % (name,)

        ntype = normalization.estimate_bounding_boxes_norm_type([(1, 2, 3, 4)])
        assert ntype == "iterable-tuple[number,size=4]"

        ntype = normalization.estimate_bounding_boxes_norm_type([
            ia.BoundingBox(x1=1, y1=2, x2=3, y2=4)])
        assert ntype == "iterable-BoundingBox"

        ntype = normalization.estimate_bounding_boxes_norm_type([
            ia.BoundingBoxesOnImage([ia.BoundingBox(x1=1, y1=2, x2=3, y2=4)],
                                    shape=(1, 1, 3))])
        assert ntype == "iterable-BoundingBoxesOnImage"

        ntype = normalization.estimate_bounding_boxes_norm_type([[]])
        assert ntype == "iterable-iterable[empty]"

        ntype = normalization.estimate_bounding_boxes_norm_type(
            [[(1, 2, 3, 4)]])
        assert ntype == "iterable-iterable-tuple[number,size=4]"

        ntype = normalization.estimate_bounding_boxes_norm_type(
            [[ia.BoundingBox(x1=1, y1=2, x2=3, y2=4)]])
        assert ntype == "iterable-iterable-BoundingBox"

        # --
        # error cases
        # --
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_bounding_boxes_norm_type(1)

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_bounding_boxes_norm_type("foo")

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_bounding_boxes_norm_type([1])

        # wrong class
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_bounding_boxes_norm_type(
                ia.HeatmapsOnImage(
                    np.zeros((1, 1, 1), dtype=np.float32),
                    shape=(1, 1, 1))
            )

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_bounding_boxes_norm_type([[[]]])

        # list of list of list of bounding boxes,
        # only list of list of bounding boxes is max
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_bounding_boxes_norm_type([[[
                ia.BoundingBox(x1=1, y1=2, x2=3, y2=4)]]])

</source>
</class>

<class classid="72" nclones="2" nlines="74" similarity="97">
<source file="systems/imgaug-0.2.9/test/augmentables/test_normalization.py" startline="3184" endline="3298" pcid="1156">
    def test_estimate_polygons_norm_type(self):
        points = [(0, 0), (10, 0), (10, 10)]

        ntype = normalization.estimate_polygons_norm_type(None)
        assert ntype == "None"

        for name, dt in zip(["float", "int", "uint"],
                            [np.float32, np.int32, np.uint16]):
            ntype = normalization.estimate_polygons_norm_type(
                np.zeros((1, 2, 5, 2), dtype=dt)
            )
            assert ntype == "array[%s]" % (name,)

        ntype = normalization.estimate_polygons_norm_type(
            ia.Polygon(points)
        )
        assert ntype == "Polygon"

        ntype = normalization.estimate_polygons_norm_type(
            ia.PolygonsOnImage(
                [ia.Polygon(points)], shape=(1, 1, 3))
        )
        assert ntype == "PolygonsOnImage"

        ntype = normalization.estimate_polygons_norm_type([])
        assert ntype == "iterable[empty]"

        for name, dt in zip(["float", "int", "uint"],
                            [np.float32, np.int32, np.uint16]):
            ntype = normalization.estimate_polygons_norm_type(
                [np.zeros((5, 4), dtype=dt)]
            )
            assert ntype == "iterable-array[%s]" % (name,)

        ntype = normalization.estimate_polygons_norm_type(points)
        assert ntype == "iterable-tuple[number,size=2]"

        ntype = normalization.estimate_polygons_norm_type(
            [ia.Keypoint(x=x, y=y) for x, y in points]
        )
        assert ntype == "iterable-Keypoint"

        ntype = normalization.estimate_polygons_norm_type([ia.Polygon(points)])
        assert ntype == "iterable-Polygon"

        ntype = normalization.estimate_polygons_norm_type(
            [ia.PolygonsOnImage([ia.Polygon(points)],
                                shape=(1, 1, 3))]
        )
        assert ntype == "iterable-PolygonsOnImage"

        ntype = normalization.estimate_polygons_norm_type([[]])
        assert ntype == "iterable-iterable[empty]"

        for name, dt in zip(["float", "int", "uint"],
                            [np.float32, np.int32, np.uint16]):
            ntype = normalization.estimate_polygons_norm_type(
                [[np.zeros((5, 4), dtype=dt)]]
            )
            assert ntype == "iterable-iterable-array[%s]" % (name,)

        ntype = normalization.estimate_polygons_norm_type([points])
        assert ntype == "iterable-iterable-tuple[number,size=2]"

        ntype = normalization.estimate_polygons_norm_type([[
            ia.Keypoint(x=x, y=y) for x, y in points
        ]])
        assert ntype == "iterable-iterable-Keypoint"

        ntype = normalization.estimate_polygons_norm_type(
            [[ia.Polygon(points)]]
        )
        assert ntype == "iterable-iterable-Polygon"

        ntype = normalization.estimate_polygons_norm_type([[[]]])
        assert ntype == "iterable-iterable-iterable[empty]"

        ntype = normalization.estimate_polygons_norm_type([[points]])
        assert ntype == "iterable-iterable-iterable-tuple[number,size=2]"

        ntype = normalization.estimate_polygons_norm_type(
            [[[ia.Keypoint(x=x, y=y) for x, y in points]]]
        )
        assert ntype == "iterable-iterable-iterable-Keypoint"

        # --
        # error cases
        # --
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_polygons_norm_type(1)

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_polygons_norm_type("foo")

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_polygons_norm_type([1])

        # wrong class
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_polygons_norm_type(
                ia.HeatmapsOnImage(
                    np.zeros((1, 1, 1), dtype=np.float32),
                    shape=(1, 1, 1))
            )

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_polygons_norm_type([[[[]]]])

        # list of list of list of polygons,
        # only list of list of polygons is max
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_polygons_norm_type([[[
                ia.Polygon(points)]]]
            )
    
</source>
<source file="systems/imgaug-0.2.9/test/augmentables/test_normalization.py" startline="3299" endline="3413" pcid="1157">
    def test_estimate_line_strings_norm_type(self):
        points = [(0, 0), (10, 0), (10, 10)]

        ntype = normalization.estimate_line_strings_norm_type(None)
        assert ntype == "None"

        for name, dt in zip(["float", "int", "uint"],
                            [np.float32, np.int32, np.uint16]):
            ntype = normalization.estimate_line_strings_norm_type(
                np.zeros((1, 2, 5, 2), dtype=dt)
            )
            assert ntype == "array[%s]" % (name,)

        ntype = normalization.estimate_line_strings_norm_type(
            ia.LineString(points)
        )
        assert ntype == "LineString"

        ntype = normalization.estimate_line_strings_norm_type(
            ia.LineStringsOnImage(
                [ia.LineString(points)], shape=(1, 1, 3))
        )
        assert ntype == "LineStringsOnImage"

        ntype = normalization.estimate_line_strings_norm_type([])
        assert ntype == "iterable[empty]"

        for name, dt in zip(["float", "int", "uint"],
                            [np.float32, np.int32, np.uint16]):
            ntype = normalization.estimate_line_strings_norm_type(
                [np.zeros((5, 4), dtype=dt)]
            )
            assert ntype == "iterable-array[%s]" % (name,)

        ntype = normalization.estimate_line_strings_norm_type(points)
        assert ntype == "iterable-tuple[number,size=2]"

        ntype = normalization.estimate_line_strings_norm_type(
            [ia.Keypoint(x=x, y=y) for x, y in points]
        )
        assert ntype == "iterable-Keypoint"

        ntype = normalization.estimate_line_strings_norm_type(
            [ia.LineString(points)])
        assert ntype == "iterable-LineString"

        ntype = normalization.estimate_line_strings_norm_type(
            [ia.LineStringsOnImage([ia.LineString(points)],
                                   shape=(1, 1, 3))]
        )
        assert ntype == "iterable-LineStringsOnImage"

        ntype = normalization.estimate_line_strings_norm_type([[]])
        assert ntype == "iterable-iterable[empty]"

        for name, dt in zip(["float", "int", "uint"],
                            [np.float32, np.int32, np.uint16]):
            ntype = normalization.estimate_line_strings_norm_type(
                [[np.zeros((5, 4), dtype=dt)]]
            )
            assert ntype == "iterable-iterable-array[%s]" % (name,)

        ntype = normalization.estimate_line_strings_norm_type([points])
        assert ntype == "iterable-iterable-tuple[number,size=2]"

        ntype = normalization.estimate_line_strings_norm_type([[
            ia.Keypoint(x=x, y=y) for x, y in points
        ]])
        assert ntype == "iterable-iterable-Keypoint"

        ntype = normalization.estimate_line_strings_norm_type(
            [[ia.LineString(points)]]
        )
        assert ntype == "iterable-iterable-LineString"

        ntype = normalization.estimate_line_strings_norm_type([[[]]])
        assert ntype == "iterable-iterable-iterable[empty]"

        ntype = normalization.estimate_line_strings_norm_type([[points]])
        assert ntype == "iterable-iterable-iterable-tuple[number,size=2]"

        ntype = normalization.estimate_line_strings_norm_type(
            [[[ia.Keypoint(x=x, y=y) for x, y in points]]]
        )
        assert ntype == "iterable-iterable-iterable-Keypoint"

        # --
        # error cases
        # --
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_line_strings_norm_type(1)

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_line_strings_norm_type("foo")

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_line_strings_norm_type([1])

        # wrong class
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_line_strings_norm_type(
                ia.HeatmapsOnImage(
                    np.zeros((1, 1, 1), dtype=np.float32),
                    shape=(1, 1, 1))
            )

        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_line_strings_norm_type([[[[]]]])

        # list of list of list of LineStrings,
        # only list of list of LineStrings is max
        with self.assertRaises(AssertionError):
            _ntype = normalization.estimate_line_strings_norm_type([[[
                ia.LineString(points)]]]
            )
</source>
</class>

<class classid="73" nclones="2" nlines="11" similarity="100">
<source file="systems/imgaug-0.2.9/test/augmentables/test_polys.py" startline="240" endline="256" pcid="1170">
def test_Polygon_height():
    poly = ia.Polygon([(0, 0), (1, 0), (1, 1), (0, 1)])
    assert np.allclose(poly.height, 1.0, atol=1e-8, rtol=0)

    poly = ia.Polygon([(0, 0), (1, 0), (1, 2), (0, 2)])
    assert np.allclose(poly.height, 2.0, atol=1e-8, rtol=0)

    poly = ia.Polygon([(0, 0), (1, 1), (0, 1)])
    assert np.allclose(poly.height, 1.0, atol=1e-8, rtol=0)

    poly = ia.Polygon([(0, 0), (1, 1)])
    assert np.allclose(poly.height, 1.0, atol=1e-8, rtol=0)

    poly = ia.Polygon([(0, 0)])
    assert np.allclose(poly.height, 0.0, atol=1e-8, rtol=0)


</source>
<source file="systems/imgaug-0.2.9/test/augmentables/test_polys.py" startline="257" endline="273" pcid="1171">
def test_Polygon_width():
    poly = ia.Polygon([(0, 0), (1, 0), (1, 1), (0, 1)])
    assert np.allclose(poly.width, 1.0, atol=1e-8, rtol=0)

    poly = ia.Polygon([(0, 0), (2, 0), (2, 1), (0, 1)])
    assert np.allclose(poly.width, 2.0, atol=1e-8, rtol=0)

    poly = ia.Polygon([(0, 0), (1, 1), (0, 1)])
    assert np.allclose(poly.width, 1.0, atol=1e-8, rtol=0)

    poly = ia.Polygon([(0, 0), (1, 1)])
    assert np.allclose(poly.width, 1.0, atol=1e-8, rtol=0)

    poly = ia.Polygon([(0, 0)])
    assert np.allclose(poly.width, 0.0, atol=1e-8, rtol=0)


</source>
</class>

<class classid="74" nclones="2" nlines="27" similarity="73">
<source file="systems/imgaug-0.2.9/test/augmentables/test_polys.py" startline="1768" endline="1793" pcid="1207">
                           [(100-3, 100+2), (200-3, 100+2),
                            (200-3, 200+2), (100-3, 200+2)],
                           rtol=0, atol=1e-4)
        assert poly_oi_shifted.shape == (10, 11, 3)

    def test_copy(self):
        poly_oi = ia.PolygonsOnImage(
            [ia.Polygon([(1, 1), (8, 1), (8, 9), (1, 9)]),
             ia.Polygon([(2, 2), (16, 2), (16, 10), (2, 10)])],
            shape=(10, 11, 3))
        poly_oi_copy = poly_oi.copy()
        assert len(poly_oi_copy.polygons) == 2
        assert np.allclose(poly_oi_copy.polygons[0].exterior,
                           [(1, 1), (8, 1), (8, 9), (1, 9)],
                           rtol=0, atol=1e-4)
        assert np.allclose(poly_oi_copy.polygons[1].exterior,
                           [(2, 2), (16, 2), (16, 10), (2, 10)],
                           rtol=0, atol=1e-4)

        poly_oi_copy.polygons = [ia.Polygon([(0, 0), (1, 0), (1, 1)])]
        assert np.allclose(poly_oi.polygons[0].exterior,
                           [(1, 1), (8, 1), (8, 9), (1, 9)],
                           rtol=0, atol=1e-4)
        assert np.allclose(poly_oi_copy.polygons[0].exterior,
                           [(0, 0), (1, 0), (1, 1)],
                           rtol=0, atol=1e-4)
</source>
<source file="systems/imgaug-0.2.9/test/augmentables/test_polys.py" startline="1794" endline="1827" pcid="1208">

        poly_oi_copy.shape = (20, 30, 3)
        assert poly_oi.shape == (10, 11, 3)
        assert poly_oi_copy.shape == (20, 30, 3)

    def test_deepcopy(self):
        poly_oi = ia.PolygonsOnImage(
            [ia.Polygon([(1, 1), (8, 1), (8, 9), (1, 9)]),
             ia.Polygon([(2, 2), (16, 2), (16, 10), (2, 10)])],
            shape=(10, 11, 3))
        poly_oi_copy = poly_oi.deepcopy()
        assert len(poly_oi_copy.polygons) == 2
        assert np.allclose(poly_oi_copy.polygons[0].exterior,
                           [(1, 1), (8, 1), (8, 9), (1, 9)],
                           rtol=0, atol=1e-4)
        assert np.allclose(poly_oi_copy.polygons[1].exterior,
                           [(2, 2), (16, 2), (16, 10), (2, 10)],
                           rtol=0, atol=1e-4)

        poly_oi_copy.polygons[0] = ia.Polygon([(0, 0), (1, 0), (1, 1)])
        assert np.allclose(poly_oi.polygons[0].exterior,
                           [(1, 1), (8, 1), (8, 9), (1, 9)],
                           rtol=0, atol=1e-4)
        assert np.allclose(poly_oi_copy.polygons[0].exterior,
                           [(0, 0), (1, 0), (1, 1)],
                           rtol=0, atol=1e-4)

        poly_oi_copy.polygons[1].exterior[0][0] = 100
        assert np.allclose(poly_oi.polygons[1].exterior,
                           [(2, 2), (16, 2), (16, 10), (2, 10)],
                           rtol=0, atol=1e-4)
        assert np.allclose(poly_oi_copy.polygons[1].exterior,
                           [(100, 2), (16, 2), (16, 10), (2, 10)],
                           rtol=0, atol=1e-4)
</source>
</class>

<class classid="75" nclones="2" nlines="16" similarity="100">
<source file="systems/imgaug-0.2.9/test/augmentables/test_polys.py" startline="1828" endline="1845" pcid="1209">

        poly_oi_copy.shape = (20, 30, 3)
        assert poly_oi.shape == (10, 11, 3)
        assert poly_oi_copy.shape == (20, 30, 3)

    def test__repr__(self):
        poly_oi = ia.PolygonsOnImage([], shape=(10, 11, 3))
        assert poly_oi.__repr__() == "PolygonsOnImage([], shape=(10, 11, 3))"

        poly_oi = ia.PolygonsOnImage(
            [ia.Polygon([(1, 1), (8, 1), (8, 9), (1, 9)]),
             ia.Polygon([(2, 2), (16, 2), (16, 10), (2, 10)])],
            shape=(10, 11, 3))
        assert poly_oi.__repr__() == (
            "PolygonsOnImage(["
            + "Polygon([(x=1.000, y=1.000), (x=8.000, y=1.000), "
            + "(x=8.000, y=9.000), (x=1.000, y=9.000)] "
            + "(4 points), label=None), "
</source>
<source file="systems/imgaug-0.2.9/test/augmentables/test_polys.py" startline="1846" endline="1864" pcid="1210">
            + "Polygon([(x=2.000, y=2.000), (x=16.000, y=2.000), "
            + "(x=16.000, y=10.000), (x=2.000, y=10.000)] "
            + "(4 points), label=None)"
            + "], shape=(10, 11, 3))")

    def test__str__(self):
        poly_oi = ia.PolygonsOnImage([], shape=(10, 11, 3))
        assert poly_oi.__repr__() == "PolygonsOnImage([], shape=(10, 11, 3))"

        poly_oi = ia.PolygonsOnImage(
            [ia.Polygon([(1, 1), (8, 1), (8, 9), (1, 9)]),
             ia.Polygon([(2, 2), (16, 2), (16, 10), (2, 10)])],
            shape=(10, 11, 3))
        assert poly_oi.__repr__() == (
            "PolygonsOnImage(["
            + "Polygon([(x=1.000, y=1.000), (x=8.000, y=1.000), "
            + "(x=8.000, y=9.000), (x=1.000, y=9.000)] "
            + "(4 points), label=None), "
            + "Polygon([(x=2.000, y=2.000), (x=16.000, y=2.000), "
</source>
</class>

<class classid="76" nclones="2" nlines="26" similarity="78">
<source file="systems/imgaug-0.2.9/test/augmentables/test_segmaps.py" startline="577" endline="605" pcid="1242">
def test_SegmentationMapOnImage_copy():
    arr_c0 = np.float32([
        [1.0, 0.0],
        [1.0, 0.0]
    ])
    arr_c1 = np.float32([
        [0.0, 1.0],
        [0.0, 1.0]
    ])
    arr = np.concatenate([arr_c0[..., np.newaxis], arr_c1[..., np.newaxis]], axis=2)
    segmap = ia.SegmentationMapOnImage(arr, shape=(2, 2))
    observed = segmap.copy()
    assert np.allclose(observed.arr, segmap.arr)
    assert observed.shape == (2, 2)
    assert observed.nb_classes == segmap.nb_classes
    assert observed.input_was == segmap.input_was

    arr = np.int32([
        [0, 1],
        [2, 3]
    ])
    segmap = ia.SegmentationMapOnImage(arr, shape=(2, 2), nb_classes=10)
    observed = segmap.copy()
    assert np.array_equal(observed.get_arr_int(), arr)
    assert observed.shape == (2, 2)
    assert observed.nb_classes == 10
    assert observed.input_was == segmap.input_was


</source>
<source file="systems/imgaug-0.2.9/test/augmentables/test_segmaps.py" startline="606" endline="637" pcid="1243">
def test_SegmentationMapOnImage_deepcopy():
    arr_c0 = np.float32([
        [1.0, 0.0],
        [1.0, 0.0]
    ])
    arr_c1 = np.float32([
        [0.0, 1.0],
        [0.0, 1.0]
    ])
    arr = np.concatenate([arr_c0[..., np.newaxis], arr_c1[..., np.newaxis]], axis=2)
    segmap = ia.SegmentationMapOnImage(arr, shape=(2, 2))
    observed = segmap.deepcopy()
    assert np.allclose(observed.arr, segmap.arr)
    assert observed.shape == (2, 2)
    assert observed.nb_classes == segmap.nb_classes
    assert observed.input_was == segmap.input_was
    segmap.arr[0, 0, 0] = 0.0
    assert not np.allclose(observed.arr, segmap.arr)

    arr = np.int32([
        [0, 1],
        [2, 3]
    ])
    segmap = ia.SegmentationMapOnImage(arr, shape=(2, 2), nb_classes=10)
    observed = segmap.deepcopy()
    assert np.array_equal(observed.get_arr_int(), segmap.get_arr_int())
    assert observed.shape == (2, 2)
    assert observed.nb_classes == 10
    assert observed.input_was == segmap.input_was
    segmap.arr[0, 0, 0] = 0.0
    segmap.arr[0, 0, 1] = 1.0
    assert not np.array_equal(observed.get_arr_int(), segmap.get_arr_int())
</source>
</class>

<class classid="77" nclones="2" nlines="13" similarity="100">
<source file="systems/imgaug-0.2.9/test/augmentables/test_heatmaps.py" startline="275" endline="292" pcid="1250">
def test_HeatmapsOnImage_avg_pool():
    heatmaps_arr = np.float32([
        [0.0, 0.0, 0.5, 1.0],
        [0.0, 0.0, 0.5, 1.0],
        [0.0, 0.0, 0.5, 1.0],
        [0.0, 0.0, 0.5, 1.0]
    ])
    heatmaps = ia.HeatmapsOnImage(heatmaps_arr, shape=(4, 4, 3))

    heatmaps_pooled = heatmaps.avg_pool(2)
    assert heatmaps_pooled.arr_0to1.shape == (2, 2, 1)
    assert np.allclose(
        heatmaps_pooled.arr_0to1[:, :, 0],
        np.float32([[0.0, 0.75],
                    [0.0, 0.75]])
    )


</source>
<source file="systems/imgaug-0.2.9/test/augmentables/test_heatmaps.py" startline="293" endline="310" pcid="1251">
def test_HeatmapsOnImage_max_pool():
    heatmaps_arr = np.float32([
        [0.0, 0.0, 0.5, 1.0],
        [0.0, 0.0, 0.5, 1.0],
        [0.0, 0.0, 0.5, 1.0],
        [0.0, 0.0, 0.5, 1.0]
    ])
    heatmaps = ia.HeatmapsOnImage(heatmaps_arr, shape=(4, 4, 3))

    heatmaps_pooled = heatmaps.max_pool(2)
    assert heatmaps_pooled.arr_0to1.shape == (2, 2, 1)
    assert np.allclose(
        heatmaps_pooled.arr_0to1[:, :, 0],
        np.float32([[0.0, 1.0],
                    [0.0, 1.0]])
    )


</source>
</class>

<class classid="78" nclones="2" nlines="188" similarity="70">
<source file="systems/imgaug-0.2.9/test/test_parameters.py" startline="79" endline="297" pcid="1281">
def test_parameters_handle_continuous_param():
    # value without value range
    got_exception = False
    try:
        result = iap.handle_continuous_param(1, "[test1]", value_range=None, tuple_to_uniform=True, list_to_choice=True)
        assert isinstance(result, iap.Deterministic)
    except Exception as e:
        got_exception = True
        assert "[test1]" in str(e)
    assert got_exception == False

    # value without value range as (None, None)
    got_exception = False
    try:
        result = iap.handle_continuous_param(1, "[test1b]", value_range=(None, None), tuple_to_uniform=True,
                                             list_to_choice=True)
        assert isinstance(result, iap.Deterministic)
    except Exception as e:
        got_exception = True
        assert "[test1b]" in str(e)
    assert got_exception == False

    # stochastic parameter
    got_exception = False
    try:
        result = iap.handle_continuous_param(iap.Deterministic(1), "[test2]", value_range=None, tuple_to_uniform=True,
                                             list_to_choice=True)
        assert isinstance(result, iap.Deterministic)
    except Exception as e:
        got_exception = True
        assert "[test2]" in str(e)
    assert got_exception == False

    # value within value range
    got_exception = False
    try:
        result = iap.handle_continuous_param(1, "[test3]", value_range=(0, 10), tuple_to_uniform=True,
                                             list_to_choice=True)
        assert isinstance(result, iap.Deterministic)
    except Exception as e:
        got_exception = True
        assert "[test3]" in str(e)
    assert got_exception == False

    # value outside of value range
    got_exception = False
    try:
        result = iap.handle_continuous_param(1, "[test4]", value_range=(2, 12), tuple_to_uniform=True,
                                             list_to_choice=True)
        assert isinstance(result, iap.Deterministic)
    except Exception as e:
        got_exception = True
        assert "[test4]" in str(e)
    assert got_exception == True

    # value within value range (without lower bound)
    got_exception = False
    try:
        result = iap.handle_continuous_param(1, "[test5]", value_range=(None, 12), tuple_to_uniform=True,
                                             list_to_choice=True)
        assert isinstance(result, iap.Deterministic)
    except Exception as e:
        got_exception = True
        assert "[test5]" in str(e)
    assert got_exception == False

    # value outside of value range (without lower bound)
    got_exception = False
    try:
        result = iap.handle_continuous_param(1, "[test6]", value_range=(None, 0), tuple_to_uniform=True,
                                             list_to_choice=True)
        assert isinstance(result, iap.Deterministic)
    except Exception as e:
        got_exception = True
        assert "[test6]" in str(e)
    assert got_exception == True

    # value within value range (without upper bound)
    got_exception = False
    try:
        result = iap.handle_continuous_param(1, "[test7]", value_range=(-1, None), tuple_to_uniform=True,
                                             list_to_choice=True)
        assert isinstance(result, iap.Deterministic)
    except Exception as e:
        got_exception = True
        assert "[test7]" in str(e)
    assert got_exception == False

    # value outside of value range (without upper bound)
    got_exception = False
    try:
        result = iap.handle_continuous_param(1, "[test8]", value_range=(2, None), tuple_to_uniform=True,
                                             list_to_choice=True)
        assert isinstance(result, iap.Deterministic)
    except Exception as e:
        got_exception = True
        assert "[test8]" in str(e)
    assert got_exception == True

    # tuple as value, but no tuples allowed
    got_exception = False
    try:
        result = iap.handle_continuous_param((1, 2), "[test9]", value_range=None, tuple_to_uniform=False,
                                             list_to_choice=True)
        assert isinstance(result, iap.Uniform)
    except Exception as e:
        got_exception = True
        assert "[test9]" in str(e)
    assert got_exception == True

    # tuple as value and tuple allowed
    got_exception = False
    try:
        result = iap.handle_continuous_param((1, 2), "[test10]", value_range=None, tuple_to_uniform=True,
                                             list_to_choice=True)
        assert isinstance(result, iap.Uniform)
    except Exception as e:
        got_exception = True
        assert "[test10]" in str(e)
    assert got_exception == False

    # tuple as value and tuple allowed and tuple within value range
    got_exception = False
    try:
        result = iap.handle_continuous_param((1, 2), "[test11]", value_range=(0, 10), tuple_to_uniform=True,
                                             list_to_choice=True)
        assert isinstance(result, iap.Uniform)
    except Exception as e:
        got_exception = True
        assert "[test11]" in str(e)
    assert got_exception == False

    # tuple as value and tuple allowed and tuple partially outside of value range
    got_exception = False
    try:
        result = iap.handle_continuous_param((1, 2), "[test12]", value_range=(1.5, 13), tuple_to_uniform=True,
                                             list_to_choice=True)
        assert isinstance(result, iap.Uniform)
    except Exception as e:
        got_exception = True
        assert "[test12]" in str(e)
    assert got_exception == True

    # tuple as value and tuple allowed and tuple fully outside of value range
    got_exception = False
    try:
        result = iap.handle_continuous_param((1, 2), "[test13]", value_range=(3, 13), tuple_to_uniform=True,
                                             list_to_choice=True)
        assert isinstance(result, iap.Uniform)
    except Exception as e:
        got_exception = True
        assert "[test13]" in str(e)
    assert got_exception == True

    # list as value, but no list allowed
    got_exception = False
    try:
        result = iap.handle_continuous_param([1, 2, 3], "[test14]", value_range=None, tuple_to_uniform=True,
                                             list_to_choice=False)
        assert isinstance(result, iap.Choice)
    except Exception as e:
        got_exception = True
        assert "[test14]" in str(e)
    assert got_exception == True

    # list as value and list allowed
    got_exception = False
    try:
        result = iap.handle_continuous_param([1, 2, 3], "[test15]", value_range=None, tuple_to_uniform=True,
                                             list_to_choice=True)
        assert isinstance(result, iap.Choice)
    except Exception as e:
        got_exception = True
        assert "[test15]" in str(e)
    assert got_exception == False

    # list as value and list allowed and list partially outside of value range
    got_exception = False
    try:
        result = iap.handle_continuous_param([1, 2], "[test16]", value_range=(1.5, 13), tuple_to_uniform=True,
                                             list_to_choice=True)
        assert isinstance(result, iap.Choice)
    except Exception as e:
        got_exception = True
        assert "[test16]" in str(e)
    assert got_exception == True

    # list as value and list allowed and list fully outside of value range
    got_exception = False
    try:
        result = iap.handle_continuous_param([1, 2], "[test17]", value_range=(3, 13), tuple_to_uniform=True,
                                             list_to_choice=True)
        assert isinstance(result, iap.Choice)
    except Exception as e:
        got_exception = True
        assert "[test17]" in str(e)
    assert got_exception == True

    # single value within value range given as callable
    got_exception = False
    try:
        result = iap.handle_continuous_param(1, "[test18]", value_range=lambda x: -1 < x < 1, tuple_to_uniform=True,
                                             list_to_choice=True)
    except Exception as e:
        got_exception = True
        assert "[test18]" in str(e)
    assert got_exception == False

    # bad datatype for value range
    got_exception = False
    try:
        result = iap.handle_continuous_param(1, "[test19]", value_range=False, tuple_to_uniform=True,
                                             list_to_choice=True)
    except Exception as e:
        got_exception = True
        assert "Unexpected input for value_range" in str(e)
    assert got_exception == True


</source>
<source file="systems/imgaug-0.2.9/test/test_parameters.py" startline="298" endline="539" pcid="1282">
def test_parameters_handle_discrete_param():
    # float value without value range when no float value is allowed
    got_exception = False
    try:
        result = iap.handle_discrete_param(1.5, "[test0]", value_range=None, tuple_to_uniform=True,
                                           list_to_choice=True, allow_floats=False)
        assert isinstance(result, iap.Deterministic)
    except Exception as e:
        got_exception = True
        assert "[test0]" in str(e)
    assert got_exception == True

    # value without value range
    got_exception = False
    try:
        result = iap.handle_discrete_param(1, "[test1]", value_range=None, tuple_to_uniform=True, list_to_choice=True,
                                           allow_floats=True)
        assert isinstance(result, iap.Deterministic)
    except Exception as e:
        got_exception = True
        assert "[test1]" in str(e)
    assert got_exception is False

    # value without value range as (None, None)
    got_exception = False
    try:
        result = iap.handle_discrete_param(1, "[test1b]", value_range=(None, None), tuple_to_uniform=True,
                                           list_to_choice=True, allow_floats=True)
        assert isinstance(result, iap.Deterministic)
    except Exception as e:
        got_exception = True
        assert "[test1b]" in str(e)
    assert got_exception is False

    # stochastic parameter
    got_exception = False
    try:
        result = iap.handle_discrete_param(iap.Deterministic(1), "[test2]", value_range=None, tuple_to_uniform=True,
                                           list_to_choice=True, allow_floats=True)
        assert isinstance(result, iap.Deterministic)
    except Exception as e:
        got_exception = True
        assert "[test2]" in str(e)
    assert got_exception is False

    # value within value range
    got_exception = False
    try:
        result = iap.handle_discrete_param(1, "[test3]", value_range=(0, 10), tuple_to_uniform=True,
                                           list_to_choice=True, allow_floats=True)
        assert isinstance(result, iap.Deterministic)
    except Exception as e:
        got_exception = True
        assert "[test3]" in str(e)
    assert got_exception is False

    # value outside of value range
    got_exception = False
    try:
        result = iap.handle_discrete_param(1, "[test4]", value_range=(2, 12), tuple_to_uniform=True,
                                           list_to_choice=True, allow_floats=True)
        assert isinstance(result, iap.Deterministic)
    except Exception as e:
        got_exception = True
        assert "[test4]" in str(e)
    assert got_exception is True

    # value within value range (without lower bound)
    got_exception = False
    try:
        result = iap.handle_discrete_param(1, "[test5]", value_range=(None, 12), tuple_to_uniform=True,
                                           list_to_choice=True, allow_floats=True)
        assert isinstance(result, iap.Deterministic)
    except Exception as e:
        got_exception = True
        assert "[test5]" in str(e)
    assert got_exception is False

    # value outside of value range (without lower bound)
    got_exception = False
    try:
        result = iap.handle_discrete_param(1, "[test6]", value_range=(None, 0), tuple_to_uniform=True,
                                           list_to_choice=True, allow_floats=True)
        assert isinstance(result, iap.Deterministic)
    except Exception as e:
        got_exception = True
        assert "[test6]" in str(e)
    assert got_exception is True

    # value within value range (without upper bound)
    got_exception = False
    try:
        result = iap.handle_discrete_param(1, "[test7]", value_range=(-1, None), tuple_to_uniform=True,
                                           list_to_choice=True, allow_floats=True)
        assert isinstance(result, iap.Deterministic)
    except Exception as e:
        got_exception = True
        assert "[test7]" in str(e)
    assert got_exception is False

    # value outside of value range (without upper bound)
    got_exception = False
    try:
        result = iap.handle_discrete_param(1, "[test8]", value_range=(2, None), tuple_to_uniform=True,
                                           list_to_choice=True, allow_floats=True)
        assert isinstance(result, iap.Deterministic)
    except Exception as e:
        got_exception = True
        assert "[test8]" in str(e)
    assert got_exception is True

    # tuple as value, but no tuples allowed
    got_exception = False
    try:
        result = iap.handle_discrete_param((1, 2), "[test9]", value_range=None, tuple_to_uniform=False,
                                           list_to_choice=True, allow_floats=True)
        assert isinstance(result, iap.DiscreteUniform)
    except Exception as e:
        got_exception = True
        assert "[test9]" in str(e)
    assert got_exception is True

    # tuple as value and tuple allowed
    got_exception = False
    try:
        result = iap.handle_discrete_param((1, 2), "[test10]", value_range=None, tuple_to_uniform=True,
                                           list_to_choice=True, allow_floats=True)
        assert isinstance(result, iap.DiscreteUniform)
    except Exception as e:
        got_exception = True
        assert "[test10]" in str(e)
    assert got_exception is False

    # tuple as value and tuple allowed and tuple within value range
    got_exception = False
    try:
        result = iap.handle_discrete_param((1, 2), "[test11]", value_range=(0, 10), tuple_to_uniform=True,
                                           list_to_choice=True, allow_floats=True)
        assert isinstance(result, iap.DiscreteUniform)
    except Exception as e:
        got_exception = True
        assert "[test11]" in str(e)
    assert got_exception is False

    # tuple as value and tuple allowed and tuple within value range with allow_floats=False
    got_exception = False
    try:
        result = iap.handle_discrete_param((1, 2), "[test11b]", value_range=(0, 10), tuple_to_uniform=True,
                                           list_to_choice=True, allow_floats=False)
        assert isinstance(result, iap.DiscreteUniform)
    except Exception as e:
        got_exception = True
        assert "[test11b]" in str(e)
    assert got_exception is False

    # tuple as value and tuple allowed and tuple partially outside of value range
    got_exception = False
    try:
        result = iap.handle_discrete_param((1, 3), "[test12]", value_range=(2, 13), tuple_to_uniform=True,
                                           list_to_choice=True, allow_floats=True)
        assert isinstance(result, iap.DiscreteUniform)
    except Exception as e:
        got_exception = True
        assert "[test12]" in str(e)
    assert got_exception is True

    # tuple as value and tuple allowed and tuple fully outside of value range
    got_exception = False
    try:
        result = iap.handle_discrete_param((1, 2), "[test13]", value_range=(3, 13), tuple_to_uniform=True,
                                           list_to_choice=True, allow_floats=True)
        assert isinstance(result, iap.DiscreteUniform)
    except Exception as e:
        got_exception = True
        assert "[test13]" in str(e)
    assert got_exception is True

    # list as value, but no list allowed
    got_exception = False
    try:
        result = iap.handle_discrete_param([1, 2, 3], "[test14]", value_range=None, tuple_to_uniform=True,
                                           list_to_choice=False, allow_floats=True)
        assert isinstance(result, iap.Choice)
    except Exception as e:
        got_exception = True
        assert "[test14]" in str(e)
    assert got_exception is True

    # list as value and list allowed
    got_exception = False
    try:
        result = iap.handle_discrete_param([1, 2, 3], "[test15]", value_range=None, tuple_to_uniform=True,
                                           list_to_choice=True, allow_floats=True)
        assert isinstance(result, iap.Choice)
    except Exception as e:
        got_exception = True
        assert "[test15]" in str(e)
    assert got_exception is False

    # list as value and list allowed and list partially outside of value range
    got_exception = False
    try:
        result = iap.handle_discrete_param([1, 3], "[test16]", value_range=(2, 13), tuple_to_uniform=True,
                                           list_to_choice=True, allow_floats=True)
        assert isinstance(result, iap.Choice)
    except Exception as e:
        got_exception = True
        assert "[test16]" in str(e)
    assert got_exception is True

    # list as value and list allowed and list fully outside of value range
    got_exception = False
    try:
        result = iap.handle_discrete_param([1, 2], "[test17]", value_range=(3, 13), tuple_to_uniform=True,
                                           list_to_choice=True, allow_floats=True)
        assert isinstance(result, iap.Choice)
    except Exception as e:
        got_exception = True
        assert "[test17]" in str(e)
    assert got_exception is True

    # single value within value range given as callable
    got_exception = False
    try:
        _ = iap.handle_discrete_param(1, "[test18]", value_range=lambda x: -1 < x < 1, tuple_to_uniform=True,
                                      list_to_choice=True)
    except Exception as e:
        got_exception = True
        assert "[test18]" in str(e)
    assert got_exception is False

    # bad datatype for value range
    got_exception = False
    try:
        _ = iap.handle_discrete_param(1, "[test19]", value_range=False, tuple_to_uniform=True,
                                      list_to_choice=True)
    except Exception as e:
        got_exception = True
        assert "Unexpected input for value_range" in str(e)
    assert got_exception is True


</source>
</class>

<class classid="79" nclones="2" nlines="44" similarity="89">
<source file="systems/imgaug-0.2.9/test/test_parameters.py" startline="921" endline="971" pcid="1293">

def test_parameters_Normal():
    reseed()

    param = iap.Normal(0, 1)
    sample = param.draw_sample()
    samples = param.draw_samples((100, 1000))
    samples_direct = np.random.RandomState(1234).normal(loc=0, scale=1, size=(100, 1000))
    assert sample.shape == tuple()
    assert samples.shape == (100, 1000)
    assert param.__str__() == param.__repr__() == "Normal(loc=Deterministic(int 0), scale=Deterministic(int 1))"

    samples = np.clip(samples, -1, 1)
    samples_direct = np.clip(samples_direct, -1, 1)
    nb_bins = 10
    hist, _ = np.histogram(samples, bins=nb_bins, range=(-1.0, 1.0), density=False)
    hist_direct, _ = np.histogram(samples_direct, bins=nb_bins, range=(-1.0, 1.0), density=False)
    tolerance = 0.05
    for nb_samples, nb_samples_direct in zip(hist, hist_direct):
        density = nb_samples / samples.size
        density_direct = nb_samples_direct / samples_direct.size
        assert density_direct - tolerance < density < density_direct + tolerance

    param = iap.Normal(iap.Choice([-100, 100]), 1)
    seen = [0, 0]
    for _ in sm.xrange(1000):
        samples = param.draw_samples((100,))
        exp = np.mean(samples)

        if -100 - 10 < exp < -100 + 10:
            seen[0] += 1
        elif 100 - 10 < exp < 100 + 10:
            seen[1] += 1
        else:
            assert False

    assert 500 - 100 < seen[0] < 500 + 100
    assert 500 - 100 < seen[1] < 500 + 100

    param1 = iap.Normal(0, 1)
    param2 = iap.Normal(0, 100)
    samples1 = param1.draw_samples((1000,))
    samples2 = param2.draw_samples((1000,))
    assert np.std(samples1) < np.std(samples2)
    assert 100 - 10 < np.std(samples2) < 100 + 10

    param = iap.Normal(0, 1)
    samples1 = param.draw_samples((10, 5), random_state=np.random.RandomState(1234))
    samples2 = param.draw_samples((10, 5), random_state=np.random.RandomState(1234))
    assert np.allclose(samples1, samples2)

</source>
<source file="systems/imgaug-0.2.9/test/test_parameters.py" startline="972" endline="1028" pcid="1294">

def test_parameters_Laplace():
    reseed()

    param = iap.Laplace(0, 1)
    sample = param.draw_sample()
    samples = param.draw_samples((100, 1000))
    samples_direct = np.random.RandomState(1234).laplace(loc=0, scale=1, size=(100, 1000))
    assert sample.shape == tuple()
    assert samples.shape == (100, 1000)
    assert param.__str__() == param.__repr__() == "Laplace(loc=Deterministic(int 0), scale=Deterministic(int 1))"

    samples = np.clip(samples, -1, 1)
    samples_direct = np.clip(samples_direct, -1, 1)
    nb_bins = 10
    hist, _ = np.histogram(samples, bins=nb_bins, range=(-1.0, 1.0), density=False)
    hist_direct, _ = np.histogram(samples_direct, bins=nb_bins, range=(-1.0, 1.0), density=False)
    tolerance = 0.05
    for nb_samples, nb_samples_direct in zip(hist, hist_direct):
        density = nb_samples / samples.size
        density_direct = nb_samples_direct / samples_direct.size
        assert density_direct - tolerance < density < density_direct + tolerance

    param = iap.Laplace(iap.Choice([-100, 100]), 1)
    seen = [0, 0]
    for _ in sm.xrange(1000):
        samples = param.draw_samples((100,))
        exp = np.mean(samples)

        if -100 - 10 < exp < -100 + 10:
            seen[0] += 1
        elif 100 - 10 < exp < 100 + 10:
            seen[1] += 1
        else:
            assert False

    assert 500 - 100 < seen[0] < 500 + 100
    assert 500 - 100 < seen[1] < 500 + 100

    param1 = iap.Laplace(0, 1)
    param2 = iap.Laplace(0, 100)
    samples1 = param1.draw_samples((1000,))
    samples2 = param2.draw_samples((1000,))
    assert np.var(samples1) < np.var(samples2)

    param1 = iap.Laplace(1, 0)
    samples = param1.draw_samples((100,))
    assert np.all(np.logical_and(
        samples > 1 - _eps(samples),
        samples < 1 + _eps(samples)
    ))

    param = iap.Laplace(0, 1)
    samples1 = param.draw_samples((10, 5), random_state=np.random.RandomState(1234))
    samples2 = param.draw_samples((10, 5), random_state=np.random.RandomState(1234))
    assert np.allclose(samples1, samples2)

</source>
</class>

<class classid="80" nclones="2" nlines="47" similarity="79">
<source file="systems/imgaug-0.2.9/test/test_parameters.py" startline="1029" endline="1082" pcid="1295">

def test_parameters_ChiSquare():
    reseed()

    param = iap.ChiSquare(1)
    sample = param.draw_sample()
    samples = param.draw_samples((100, 1000))
    samples_direct = np.random.RandomState(1234).chisquare(df=1, size=(100, 1000))
    assert sample.shape == tuple()
    assert samples.shape == (100, 1000)
    assert 0 <= sample
    assert np.all(0 <= samples)
    assert param.__str__() == param.__repr__() == "ChiSquare(df=Deterministic(int 1))"

    samples = np.clip(samples, 0, 3)
    samples_direct = np.clip(samples_direct, 0, 3)
    nb_bins = 10
    hist, _ = np.histogram(samples, bins=nb_bins, range=(0, 3.0), density=False)
    hist_direct, _ = np.histogram(samples_direct, bins=nb_bins, range=(0, 3.0), density=False)
    tolerance = 0.05
    for nb_samples, nb_samples_direct in zip(hist, hist_direct):
        density = nb_samples / samples.size
        density_direct = nb_samples_direct / samples_direct.size
        assert density_direct - tolerance < density < density_direct + tolerance

    param = iap.ChiSquare(iap.Choice([1, 10]))
    seen = [0, 0]
    for _ in sm.xrange(1000):
        samples = param.draw_samples((100,))
        exp = np.mean(samples)

        if 1 - 1.0 < exp < 1 + 1.0:
            seen[0] += 1
        elif 10 - 4.0 < exp < 10 + 4.0:
            seen[1] += 1
        else:
            assert False

    assert 500 - 100 < seen[0] < 500 + 100
    assert 500 - 100 < seen[1] < 500 + 100

    param1 = iap.ChiSquare(1)
    param2 = iap.ChiSquare(10)
    samples1 = param1.draw_samples((1000,))
    samples2 = param2.draw_samples((1000,))
    assert np.var(samples1) < np.var(samples2)
    assert 2*1 - 1.0 < np.var(samples1) < 2*1 + 1.0
    assert 2*10 - 5.0 < np.var(samples2) < 2*10 + 5.0

    param = iap.ChiSquare(1)
    samples1 = param.draw_samples((10, 5), random_state=np.random.RandomState(1234))
    samples2 = param.draw_samples((10, 5), random_state=np.random.RandomState(1234))
    assert np.allclose(samples1, samples2)

</source>
<source file="systems/imgaug-0.2.9/test/test_parameters.py" startline="1083" endline="1140" pcid="1296">

def test_parameters_Weibull():
    reseed()

    param = iap.Weibull(1)
    sample = param.draw_sample()
    samples = param.draw_samples((100, 1000))
    samples_direct = np.random.RandomState(1234).weibull(a=1, size=(100, 1000))
    assert sample.shape == tuple()
    assert samples.shape == (100, 1000)
    assert 0 <= sample
    assert np.all(0 <= samples)
    assert param.__str__() == param.__repr__() == "Weibull(a=Deterministic(int 1))"

    samples = np.clip(samples, 0, 2)
    samples_direct = np.clip(samples_direct, 0, 2)
    nb_bins = 10
    hist, _ = np.histogram(samples, bins=nb_bins, range=(0, 2.0), density=False)
    hist_direct, _ = np.histogram(samples_direct, bins=nb_bins, range=(0, 2.0), density=False)
    tolerance = 0.05
    for nb_samples, nb_samples_direct in zip(hist, hist_direct):
        density = nb_samples / samples.size
        density_direct = nb_samples_direct / samples_direct.size
        assert density_direct - tolerance < density < density_direct + tolerance

    param = iap.Weibull(iap.Choice([1, 0.5]))
    expected_first = scipy.special.gamma(1 + 1/1)
    expected_second = scipy.special.gamma(1 + 1/0.5)
    seen = [0, 0]
    for _ in sm.xrange(100):
        samples = param.draw_samples((50000,))
        observed = np.mean(samples)

        if expected_first - 0.2 * expected_first < observed < expected_first + 0.2 * expected_first:
            seen[0] += 1
        elif expected_second - 0.2 * expected_second < observed < expected_second + 0.2 * expected_second:
            seen[1] += 1
        else:
            assert False

    assert 50 - 25 < seen[0] < 50 + 25
    assert 50 - 25 < seen[1] < 50 + 25

    param1 = iap.Weibull(1)
    param2 = iap.Weibull(0.5)
    samples1 = param1.draw_samples((10000,))
    samples2 = param2.draw_samples((10000,))
    assert np.var(samples1) < np.var(samples2)
    expected_first = scipy.special.gamma(1 + 2/1) - (scipy.special.gamma(1 + 1/1))**2
    expected_second = scipy.special.gamma(1 + 2/0.5) - (scipy.special.gamma(1 + 1/0.5))**2
    assert expected_first - 0.2 * expected_first < np.var(samples1) < expected_first + 0.2 * expected_first
    assert expected_second - 0.2 * expected_second < np.var(samples2) < expected_second + 0.2 * expected_second

    param = iap.Weibull(1)
    samples1 = param.draw_samples((10, 5), random_state=np.random.RandomState(1234))
    samples2 = param.draw_samples((10, 5), random_state=np.random.RandomState(1234))
    assert np.allclose(samples1, samples2)

</source>
</class>

<class classid="81" nclones="3" nlines="60" similarity="70">
<source file="systems/imgaug-0.2.9/test/test_parameters.py" startline="1687" endline="1758" pcid="1305">


def test_parameters_Multiply():
    reseed()

    values_int = [-100, -54, -1, 0, 1, 54, 100]
    values_float = [-100.0, -54.3, -1.0, 0.1, 0.0, 0.1, 1.0, 54.4, 100.0]

    for v1 in values_int:
        for v2 in values_int:
            p = iap.Multiply(iap.Deterministic(v1), v2)
            assert p.draw_sample() == v1 * v2
            samples = p.draw_samples((2, 3))
            assert samples.dtype.kind == "i"
            assert np.array_equal(samples, np.zeros((2, 3), dtype=np.int64) + v1 * v2)

            p = iap.Multiply(iap.Deterministic(v1), iap.Deterministic(v2))
            assert p.draw_sample() == v1 * v2
            samples = p.draw_samples((2, 3))
            assert samples.dtype == np.int64
            assert np.array_equal(samples, np.zeros((2, 3), dtype=np.int64) + v1 * v2)

    for v1 in values_float:
        for v2 in values_float:
            p = iap.Multiply(iap.Deterministic(v1), v2)
            sample = p.draw_sample()
            assert v1 * v2 - _eps(sample) < sample < v1 * v2 + _eps(sample)
            samples = p.draw_samples((2, 3))
            assert samples.dtype.kind == "f"
            assert np.allclose(samples, np.zeros((2, 3), dtype=np.float64) + v1 * v2)

            p = iap.Multiply(iap.Deterministic(v1), iap.Deterministic(v2))
            sample = p.draw_sample()
            assert v1 * v2 - _eps(sample) < sample < v1 * v2 + _eps(sample)
            samples = p.draw_samples((2, 3))
            assert samples.dtype.kind == "f"
            assert np.allclose(samples, np.zeros((2, 3), dtype=np.float64) + v1 * v2)

    param = iap.Multiply(iap.Deterministic(1.0), (1.0, 2.0), elementwise=False)
    samples = param.draw_samples((10, 20))
    assert samples.shape == (10, 20)
    assert np.all(samples > 1.0 * 1.0 - _eps(samples))
    assert np.all(samples < 1.0 * 2.0 + _eps(samples))
    samples_sorted = np.sort(samples.flatten())
    assert samples_sorted[0] - _eps(samples_sorted[0]) < samples_sorted[-1] < samples_sorted[0] + _eps(samples_sorted[0])

    param = iap.Multiply(iap.Deterministic(1.0), (1.0, 2.0), elementwise=True)
    samples = param.draw_samples((10, 20))
    assert samples.shape == (10, 20)
    assert np.all(samples > 1.0 * 1.0 - _eps(samples))
    assert np.all(samples < 1.0 * 2.0 + _eps(samples))
    samples_sorted = np.sort(samples.flatten())
    assert not (samples_sorted[0] - _eps(samples_sorted[0]) < samples_sorted[-1] < samples_sorted[0] + _eps(samples_sorted[0]))

    param = iap.Multiply(iap.Uniform(1.0, 2.0), 1.0, elementwise=False)
    samples = param.draw_samples((10, 20))
    assert samples.shape == (10, 20)
    assert np.all(samples > 1.0 * 1.0 - _eps(samples))
    assert np.all(samples < 2.0 * 1.0 + _eps(samples))
    samples_sorted = np.sort(samples.flatten())
    assert not (samples_sorted[0] - _eps(samples_sorted[0]) < samples_sorted[-1] < samples_sorted[0] + _eps(samples_sorted[0]))

    param = iap.Multiply(iap.Uniform(1.0, 2.0), 1.0, elementwise=True)
    samples = param.draw_samples((10, 20))
    assert samples.shape == (10, 20)
    assert np.all(samples > 1.0 * 1.0 - _eps(samples))
    assert np.all(samples < 2.0 * 1.0 + _eps(samples))
    samples_sorted = np.sort(samples.flatten())
    assert not (samples_sorted[0] - _eps(samples_sorted[0]) < samples_sorted[-1] < samples_sorted[0] + _eps(samples_sorted[0]))

    param = iap.Multiply(iap.Deterministic(0), 1, elementwise=False)
    assert param.__str__() == param.__repr__() == "Multiply(Deterministic(int 0), Deterministic(int 1), False)"
</source>
<source file="systems/imgaug-0.2.9/test/test_parameters.py" startline="1848" endline="1918" pcid="1307">


def test_parameters_Add():
    reseed()

    values_int = [-100, -54, -1, 0, 1, 54, 100]
    values_float = [-100.0, -54.3, -1.0, 0.1, 0.0, 0.1, 1.0, 54.4, 100.0]

    for v1 in values_int:
        for v2 in values_int:
            p = iap.Add(iap.Deterministic(v1), v2)
            assert p.draw_sample() == v1 + v2
            samples = p.draw_samples((2, 3))
            assert samples.dtype.kind == "i"
            assert np.array_equal(samples, np.zeros((2, 3), dtype=np.int64) + v1 + v2)

            p = iap.Add(iap.Deterministic(v1), iap.Deterministic(v2))
            assert p.draw_sample() == v1 + v2
            samples = p.draw_samples((2, 3))
            assert samples.dtype.kind == "i"
            assert np.array_equal(samples, np.zeros((2, 3), dtype=np.int64) + v1 + v2)

    for v1 in values_float:
        for v2 in values_float:
            p = iap.Add(iap.Deterministic(v1), v2)
            sample = p.draw_sample()
            assert v1 + v2 - _eps(sample) < sample < v1 + v2 + _eps(sample)
            samples = p.draw_samples((2, 3))
            assert samples.dtype.kind == "f"
            assert np.allclose(samples, np.zeros((2, 3), dtype=np.float64) + v1 + v2)

            p = iap.Add(iap.Deterministic(v1), iap.Deterministic(v2))
            assert v1 + v2 - _eps(sample) < sample < v1 + v2 + _eps(sample)
            samples = p.draw_samples((2, 3))
            assert samples.dtype.kind == "f"
            assert np.allclose(samples, np.zeros((2, 3), dtype=np.float64) + v1 + v2)

    param = iap.Add(iap.Deterministic(1.0), (1.0, 2.0), elementwise=False)
    samples = param.draw_samples((10, 20))
    assert samples.shape == (10, 20)
    assert np.all(samples >= 1.0 + 1.0 - _eps(samples))
    assert np.all(samples <= 1.0 + 2.0 + _eps(samples))
    samples_sorted = np.sort(samples.flatten())
    assert samples_sorted[0] - _eps(samples_sorted[0]) < samples_sorted[-1] < samples_sorted[0] + _eps(samples_sorted[0])

    param = iap.Add(iap.Deterministic(1.0), (1.0, 2.0), elementwise=True)
    samples = param.draw_samples((10, 20))
    assert samples.shape == (10, 20)
    assert np.all(samples >= 1.0 + 1.0 - _eps(samples))
    assert np.all(samples <= 1.0 + 2.0 + _eps(samples))
    samples_sorted = np.sort(samples.flatten())
    assert not (samples_sorted[0] - _eps(samples_sorted[0]) < samples_sorted[-1] < samples_sorted[0] + _eps(samples_sorted[0]))

    param = iap.Add(iap.Uniform(1.0, 2.0), 1.0, elementwise=False)
    samples = param.draw_samples((10, 20))
    assert samples.shape == (10, 20)
    assert np.all(samples >= 1.0 + 1.0 - _eps(samples))
    assert np.all(samples <= 2.0 + 1.0 + _eps(samples))
    samples_sorted = np.sort(samples.flatten())
    assert not (samples_sorted[0] - _eps(samples_sorted[0]) < samples_sorted[-1] < samples_sorted[0] + _eps(samples_sorted[0]))

    param = iap.Add(iap.Uniform(1.0, 2.0), 1.0, elementwise=True)
    samples = param.draw_samples((10, 20))
    assert samples.shape == (10, 20)
    assert np.all(samples >= 1.0 + 1.0 - _eps(samples))
    assert np.all(samples <= 2.0 + 1.0 + _eps(samples))
    samples_sorted = np.sort(samples.flatten())
    assert not (samples_sorted[0] - _eps(samples_sorted[0]) < samples_sorted[-1] < samples_sorted[0] + _eps(samples_sorted[0]))

    param = iap.Add(iap.Deterministic(0), 1, elementwise=False)
    assert param.__str__() == param.__repr__() == "Add(Deterministic(int 0), Deterministic(int 1), False)"
</source>
<source file="systems/imgaug-0.2.9/test/test_parameters.py" startline="1919" endline="1990" pcid="1308">


def test_parameters_Subtract():
    reseed()

    values_int = [-100, -54, -1, 0, 1, 54, 100]
    values_float = [-100.0, -54.3, -1.0, 0.1, 0.0, 0.1, 1.0, 54.4, 100.0]

    for v1 in values_int:
        for v2 in values_int:
            p = iap.Subtract(iap.Deterministic(v1), v2)
            assert p.draw_sample() == v1 - v2
            samples = p.draw_samples((2, 3))
            assert samples.dtype.kind == "i"
            assert np.array_equal(samples, np.zeros((2, 3), dtype=np.int64) + v1 - v2)

            p = iap.Subtract(iap.Deterministic(v1), iap.Deterministic(v2))
            assert p.draw_sample() == v1 - v2
            samples = p.draw_samples((2, 3))
            assert samples.dtype.kind == "i"
            assert np.array_equal(samples, np.zeros((2, 3), dtype=np.int64) + v1 - v2)

    for v1 in values_float:
        for v2 in values_float:
            p = iap.Subtract(iap.Deterministic(v1), v2)
            sample = p.draw_sample()
            assert v1 - v2 - _eps(sample) < sample < v1 - v2 + _eps(sample)
            samples = p.draw_samples((2, 3))
            assert samples.dtype.kind == "f"
            assert np.allclose(samples, np.zeros((2, 3), dtype=np.float64) + v1 - v2)

            p = iap.Subtract(iap.Deterministic(v1), iap.Deterministic(v2))
            sample = p.draw_sample()
            assert v1 - v2 - _eps(sample) < sample < v1 - v2 + _eps(sample)
            samples = p.draw_samples((2, 3))
            assert samples.dtype.kind == "f"
            assert np.allclose(samples, np.zeros((2, 3), dtype=np.float64) + v1 - v2)

    param = iap.Subtract(iap.Deterministic(1.0), (1.0, 2.0), elementwise=False)
    samples = param.draw_samples((10, 20))
    assert samples.shape == (10, 20)
    assert np.all(samples > 1.0 - 2.0 - _eps(samples))
    assert np.all(samples < 1.0 - 1.0 + _eps(samples))
    samples_sorted = np.sort(samples.flatten())
    assert samples_sorted[0] - _eps(samples_sorted[0]) < samples_sorted[-1] < samples_sorted[0] + _eps(samples_sorted[0])

    param = iap.Subtract(iap.Deterministic(1.0), (1.0, 2.0), elementwise=True)
    samples = param.draw_samples((10, 20))
    assert samples.shape == (10, 20)
    assert np.all(samples > 1.0 - 2.0 - _eps(samples))
    assert np.all(samples < 1.0 - 1.0 + _eps(samples))
    samples_sorted = np.sort(samples.flatten())
    assert not (samples_sorted[0] - _eps(samples_sorted[0]) < samples_sorted[-1] < samples_sorted[0] + _eps(samples_sorted[0]))

    param = iap.Subtract(iap.Uniform(1.0, 2.0), 1.0, elementwise=False)
    samples = param.draw_samples((10, 20))
    assert samples.shape == (10, 20)
    assert np.all(samples > 1.0 - 1.0 - _eps(samples))
    assert np.all(samples < 2.0 - 1.0 + _eps(samples))
    samples_sorted = np.sort(samples.flatten())
    assert not (samples_sorted[0] - _eps(samples_sorted[0]) < samples_sorted[-1] < samples_sorted[0] + _eps(samples_sorted[0]))

    param = iap.Subtract(iap.Uniform(1.0, 2.0), 1.0, elementwise=True)
    samples = param.draw_samples((10, 20))
    assert samples.shape == (10, 20)
    assert np.all(samples > 1.0 - 1.0 - _eps(samples))
    assert np.all(samples < 2.0 - 1.0 + _eps(samples))
    samples_sorted = np.sort(samples.flatten())
    assert not (samples_sorted[0] - _eps(samples_sorted[0]) < samples_sorted[-1] < samples_sorted[0] + _eps(samples_sorted[0]))

    param = iap.Subtract(iap.Deterministic(0), 1, elementwise=False)
    assert param.__str__() == param.__repr__() == "Subtract(Deterministic(int 0), Deterministic(int 1), False)"
</source>
</class>

</clones>
