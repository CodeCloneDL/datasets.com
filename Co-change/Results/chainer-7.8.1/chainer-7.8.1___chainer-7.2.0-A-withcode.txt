<clonepair1>
<source file="systems/chainer-7.8.1/tests/chainerx_tests/unit_tests/routines_tests/test_rnn.py" startline="365" endline="396" pcid="9674"></source>
    def generate_inputs(self):
        h_shape = (self.n_layers * 2, self.batches[0], self.hidden_size)
        dtype = self.in_dtypes[0]

        h = array_utils.uniform(h_shape, dtype)
        in_size = self.input_size
        out_size = self.hidden_size
        xs = [array_utils.uniform((self.batches[b], in_size), dtype)
              for b in range(len(self.batches))]

        def w_in(i, j):
            if i == 0 and j < 3:
                return in_size
            elif i > 0 and j < 3:
                return out_size * 2
            else:
                return out_size

        inputs = []
        inputs.append(h)
        for i in range(len(self.batches)):
            inputs.append(xs[i])

        for n in range(self.n_layers):
            for direction in (0, 1):
                for i in range(6):
                    inputs.append(array_utils.uniform(
                        (out_size, w_in(n, i)), dtype))
                for i in range(6):
                    inputs.append(array_utils.uniform((out_size,), dtype))
        return tuple(inputs)

</clonepair1>

<clonepair1>
<source file="systems/chainer-7.8.1/tests/chainer_tests/functions_tests/rnn_tests/test_function_n_step_rnn.py" startline="200" endline="230" pcid="6634"></source>
    def generate_inputs(self):
        h_shape = (self.n_layers * 2, self.batches[0], self.hidden_size)
        dtype = self.dtype

        h = array(h_shape, dtype)
        in_size = self.input_size
        out_size = self.hidden_size
        xs = [array((self.batches[b], in_size), dtype)
              for b in range(len(self.batches))]

        def w_in(i, j):
            if i == 0 and j < 1:
                return in_size
            elif i > 0 and j < 1:
                return out_size * 2
            else:
                return out_size

        inputs = []
        inputs.append(h)
        for i in range(len(self.batches)):
            inputs.append(xs[i])

        for n in range(self.n_layers):
            for direction in (0, 1):
                for i in range(2):
                    inputs.append(array((out_size, w_in(n, i)), dtype))
                for i in range(2):
                    inputs.append(array((out_size,), dtype))
        return tuple(inputs)

</clonepair1>
<clonepair2>
<source file="systems/chainer-7.8.1/tests/chainerx_tests/unit_tests/routines_tests/test_rnn.py" startline="365" endline="396" pcid="9674"></source>
    def generate_inputs(self):
        h_shape = (self.n_layers * 2, self.batches[0], self.hidden_size)
        dtype = self.in_dtypes[0]

        h = array_utils.uniform(h_shape, dtype)
        in_size = self.input_size
        out_size = self.hidden_size
        xs = [array_utils.uniform((self.batches[b], in_size), dtype)
              for b in range(len(self.batches))]

        def w_in(i, j):
            if i == 0 and j < 3:
                return in_size
            elif i > 0 and j < 3:
                return out_size * 2
            else:
                return out_size

        inputs = []
        inputs.append(h)
        for i in range(len(self.batches)):
            inputs.append(xs[i])

        for n in range(self.n_layers):
            for direction in (0, 1):
                for i in range(6):
                    inputs.append(array_utils.uniform(
                        (out_size, w_in(n, i)), dtype))
                for i in range(6):
                    inputs.append(array_utils.uniform((out_size,), dtype))
        return tuple(inputs)

</clonepair2>

<clonepair2>
<source file="systems/chainer-7.8.1/tests/chainer_tests/functions_tests/rnn_tests/test_function_n_step_gru.py" startline="188" endline="218" pcid="6602"></source>
    def generate_inputs(self):
        h_shape = (self.n_layers * 2, self.batches[0], self.hidden_size)
        dtype = numpy.float32

        h = array(h_shape, dtype)
        in_size = self.input_size
        out_size = self.hidden_size
        xs = [array((self.batches[b], in_size), dtype)
              for b in range(len(self.batches))]

        def w_in(i, j):
            if i == 0 and j < 3:
                return in_size
            elif i > 0 and j < 3:
                return out_size * 2
            else:
                return out_size

        inputs = []
        inputs.append(h)
        for i in range(len(self.batches)):
            inputs.append(xs[i])

        for n in range(self.n_layers):
            for direction in (0, 1):
                for i in range(6):
                    inputs.append(array((out_size, w_in(n, i)), dtype))
                for i in range(6):
                    inputs.append(array((out_size,), dtype))
        return tuple(inputs)

</clonepair2>
<clonepair3>
<source file="systems/chainer-7.8.1/tests/chainerx_tests/unit_tests/routines_tests/test_rnn.py" startline="625" endline="638" pcid="9688"></source>
    def process_input(self, inputs):
        h = inputs[0]
        xs = inputs[1:1 + len(self.batches)]
        ws = []
        bs = []
        index = 1 + len(self.batches)
        for n in range(self.n_layers):
            ws.append(inputs[index: index + 2])
            bs.append(inputs[index + 2: index + 4])
            ws.append(inputs[index + 4: index + 6])
            bs.append(inputs[index + 6: index + 8])
            index += 8
        return h, ws, bs, xs

</clonepair3>

<clonepair3>
<source file="systems/chainer-7.8.1/tests/chainer_tests/functions_tests/rnn_tests/test_function_n_step_lstm.py" startline="279" endline="293" pcid="6587"></source>
    def process_inputs(self, inputs):
        h = inputs[0]
        c = inputs[1]
        xs = inputs[2:2 + len(self.batches)]
        ws = []
        bs = []
        index = 2 + len(self.batches)
        for n in range(self.n_layers):
            ws.append(inputs[index: index + 8])
            bs.append(inputs[index + 8: index + 16])
            ws.append(inputs[index + 16: index + 24])
            bs.append(inputs[index + 24: index + 32])
            index += 32
        return h, c, ws, bs, xs
</clonepair3>
<clonepair4>
<source file="systems/chainer-7.8.1/tests/chainerx_tests/unit_tests/routines_tests/test_rnn.py" startline="397" endline="410" pcid="9676"></source>
    def process_input(self, inputs):
        h = inputs[0]
        xs = inputs[1:1 + len(self.batches)]
        ws = []
        bs = []
        index = 1 + len(self.batches)
        for n in range(self.n_layers):
            ws.append(inputs[index: index + 6])
            bs.append(inputs[index + 6: index + 12])
            ws.append(inputs[index + 12: index + 18])
            bs.append(inputs[index + 18: index + 24])
            index += 24
        return h, ws, bs, xs

</clonepair4>

<clonepair4>
<source file="systems/chainer-7.8.1/tests/chainer_tests/functions_tests/rnn_tests/test_function_n_step_lstm.py" startline="279" endline="293" pcid="6587"></source>
    def process_inputs(self, inputs):
        h = inputs[0]
        c = inputs[1]
        xs = inputs[2:2 + len(self.batches)]
        ws = []
        bs = []
        index = 2 + len(self.batches)
        for n in range(self.n_layers):
            ws.append(inputs[index: index + 8])
            bs.append(inputs[index + 8: index + 16])
            ws.append(inputs[index + 16: index + 24])
            bs.append(inputs[index + 24: index + 32])
            index += 32
        return h, c, ws, bs, xs
</clonepair4>
<clonepair5>
<source file="systems/chainer-7.8.1/tests/chainerx_tests/unit_tests/routines_tests/test_rnn.py" startline="625" endline="638" pcid="9688"></source>
    def process_input(self, inputs):
        h = inputs[0]
        xs = inputs[1:1 + len(self.batches)]
        ws = []
        bs = []
        index = 1 + len(self.batches)
        for n in range(self.n_layers):
            ws.append(inputs[index: index + 2])
            bs.append(inputs[index + 2: index + 4])
            ws.append(inputs[index + 4: index + 6])
            bs.append(inputs[index + 6: index + 8])
            index += 8
        return h, ws, bs, xs

</clonepair5>

<clonepair5>
<source file="systems/chainer-7.8.1/tests/chainer_tests/functions_tests/rnn_tests/test_function_n_step_gru.py" startline="219" endline="232" pcid="6604"></source>
    def process_inputs(self, inputs):
        h = inputs[0]
        xs = inputs[1:1 + len(self.batches)]
        ws = []
        bs = []
        index = 1 + len(self.batches)
        for n in range(self.n_layers):
            ws.append(inputs[index: index + 6])
            bs.append(inputs[index + 6: index + 12])
            ws.append(inputs[index + 12: index + 18])
            bs.append(inputs[index + 18: index + 24])
            index += 24
        return h, ws, bs, xs

</clonepair5>
<clonepair6>
<source file="systems/chainer-7.8.1/tests/chainerx_tests/unit_tests/routines_tests/test_rnn.py" startline="397" endline="410" pcid="9676"></source>
    def process_input(self, inputs):
        h = inputs[0]
        xs = inputs[1:1 + len(self.batches)]
        ws = []
        bs = []
        index = 1 + len(self.batches)
        for n in range(self.n_layers):
            ws.append(inputs[index: index + 6])
            bs.append(inputs[index + 6: index + 12])
            ws.append(inputs[index + 12: index + 18])
            bs.append(inputs[index + 18: index + 24])
            index += 24
        return h, ws, bs, xs

</clonepair6>

<clonepair6>
<source file="systems/chainer-7.8.1/tests/chainer_tests/functions_tests/rnn_tests/test_function_n_step_gru.py" startline="219" endline="232" pcid="6604"></source>
    def process_inputs(self, inputs):
        h = inputs[0]
        xs = inputs[1:1 + len(self.batches)]
        ws = []
        bs = []
        index = 1 + len(self.batches)
        for n in range(self.n_layers):
            ws.append(inputs[index: index + 6])
            bs.append(inputs[index + 6: index + 12])
            ws.append(inputs[index + 12: index + 18])
            bs.append(inputs[index + 18: index + 24])
            index += 24
        return h, ws, bs, xs

</clonepair6>
<clonepair7>
<source file="systems/chainer-7.8.1/tests/chainerx_tests/unit_tests/routines_tests/test_rnn.py" startline="625" endline="638" pcid="9688"></source>
    def process_input(self, inputs):
        h = inputs[0]
        xs = inputs[1:1 + len(self.batches)]
        ws = []
        bs = []
        index = 1 + len(self.batches)
        for n in range(self.n_layers):
            ws.append(inputs[index: index + 2])
            bs.append(inputs[index + 2: index + 4])
            ws.append(inputs[index + 4: index + 6])
            bs.append(inputs[index + 6: index + 8])
            index += 8
        return h, ws, bs, xs

</clonepair7>

<clonepair7>
<source file="systems/chainer-7.8.1/tests/chainer_tests/functions_tests/rnn_tests/test_function_n_step_rnn.py" startline="231" endline="244" pcid="6636"></source>
    def process_inputs(self, inputs):
        h = inputs[0]
        xs = inputs[1: 1 + len(self.batches)]
        ws = []
        bs = []
        index = 1 + len(self.batches)
        for n in range(self.n_layers):
            ws.append(inputs[index: index + 2])
            bs.append(inputs[index + 2: index + 4])
            ws.append(inputs[index + 4: index + 6])
            bs.append(inputs[index + 6: index + 8])
            index += 8
        return h, ws, bs, xs

</clonepair7>
<clonepair8>
<source file="systems/chainer-7.8.1/tests/chainerx_tests/unit_tests/routines_tests/test_rnn.py" startline="397" endline="410" pcid="9676"></source>
    def process_input(self, inputs):
        h = inputs[0]
        xs = inputs[1:1 + len(self.batches)]
        ws = []
        bs = []
        index = 1 + len(self.batches)
        for n in range(self.n_layers):
            ws.append(inputs[index: index + 6])
            bs.append(inputs[index + 6: index + 12])
            ws.append(inputs[index + 12: index + 18])
            bs.append(inputs[index + 18: index + 24])
            index += 24
        return h, ws, bs, xs

</clonepair8>

<clonepair8>
<source file="systems/chainer-7.8.1/tests/chainer_tests/functions_tests/rnn_tests/test_function_n_step_rnn.py" startline="231" endline="244" pcid="6636"></source>
    def process_inputs(self, inputs):
        h = inputs[0]
        xs = inputs[1: 1 + len(self.batches)]
        ws = []
        bs = []
        index = 1 + len(self.batches)
        for n in range(self.n_layers):
            ws.append(inputs[index: index + 2])
            bs.append(inputs[index + 2: index + 4])
            ws.append(inputs[index + 4: index + 6])
            bs.append(inputs[index + 6: index + 8])
            index += 8
        return h, ws, bs, xs

</clonepair8>
<clonepair9>
<source file="systems/chainer-7.8.1/tests/chainerx_tests/unit_tests/routines_tests/test_binary.py" startline="555" endline="567" pcid="9632"></source>
    def func_scalar(self, xp, a, scalar):
        if self.is_module:
            if self.is_scalar_rhs:
                return a & scalar
            else:
                return scalar & a
        else:
            if self.is_scalar_rhs:
                return xp.bitwise_and(a, scalar)
            else:
                return xp.bitwise_and(scalar, a)


</clonepair9>

<clonepair9>
<source file="systems/chainer-7.8.1/tests/chainerx_tests/unit_tests/routines_tests/test_arithmetic.py" startline="534" endline="546" pcid="9704"></source>
    def func_scalar(self, xp, a, scalar):
        if self.is_module:
            if self.is_scalar_rhs:
                return a - scalar
            else:
                return scalar - a
        else:
            if self.is_scalar_rhs:
                return xp.subtract(a, scalar)
            else:
                return xp.subtract(scalar, a)


</clonepair9>
<clonepair10>
<source file="systems/chainer-7.8.1/tests/chainerx_tests/unit_tests/routines_tests/test_binary.py" startline="573" endline="585" pcid="9633"></source>
    def func_scalar(self, xp, a, scalar):
        if self.is_module:
            if self.is_scalar_rhs:
                return a | scalar
            else:
                return scalar | a
        else:
            if self.is_scalar_rhs:
                return xp.bitwise_or(a, scalar)
            else:
                return xp.bitwise_or(scalar, a)


</clonepair10>

<clonepair10>
<source file="systems/chainer-7.8.1/tests/chainerx_tests/unit_tests/routines_tests/test_arithmetic.py" startline="328" endline="340" pcid="9698"></source>
    def func_scalar(self, xp, a, scalar):
        if self.is_module:
            if self.is_scalar_rhs:
                return a + scalar
            else:
                return scalar + a
        else:
            if self.is_scalar_rhs:
                return xp.add(a, scalar)
            else:
                return xp.add(scalar, a)


</clonepair10>
<clonepair11>
<source file="systems/chainer-7.8.1/tests/chainerx_tests/unit_tests/routines_tests/test_binary.py" startline="573" endline="585" pcid="9633"></source>
    def func_scalar(self, xp, a, scalar):
        if self.is_module:
            if self.is_scalar_rhs:
                return a | scalar
            else:
                return scalar | a
        else:
            if self.is_scalar_rhs:
                return xp.bitwise_or(a, scalar)
            else:
                return xp.bitwise_or(scalar, a)


</clonepair11>

<clonepair11>
<source file="systems/chainer-7.8.1/tests/chainerx_tests/unit_tests/routines_tests/test_arithmetic.py" startline="534" endline="546" pcid="9704"></source>
    def func_scalar(self, xp, a, scalar):
        if self.is_module:
            if self.is_scalar_rhs:
                return a - scalar
            else:
                return scalar - a
        else:
            if self.is_scalar_rhs:
                return xp.subtract(a, scalar)
            else:
                return xp.subtract(scalar, a)


</clonepair11>
<clonepair12>
<source file="systems/chainer-7.8.1/tests/chainerx_tests/unit_tests/routines_tests/test_binary.py" startline="573" endline="585" pcid="9633"></source>
    def func_scalar(self, xp, a, scalar):
        if self.is_module:
            if self.is_scalar_rhs:
                return a | scalar
            else:
                return scalar | a
        else:
            if self.is_scalar_rhs:
                return xp.bitwise_or(a, scalar)
            else:
                return xp.bitwise_or(scalar, a)


</clonepair12>

<clonepair12>
<source file="systems/chainer-7.8.1/tests/chainerx_tests/unit_tests/routines_tests/test_arithmetic.py" startline="719" endline="731" pcid="9708"></source>
    def func_scalar(self, xp, a, scalar):
        if self.is_module:
            if self.is_scalar_rhs:
                return a * scalar
            else:
                return scalar * a
        else:
            if self.is_scalar_rhs:
                return xp.multiply(a, scalar)
            else:
                return xp.multiply(scalar, a)


</clonepair12>
<clonepair13>
<source file="systems/chainer-7.8.1/tests/chainer_tests/link_hooks_tests/test_weight_standardization.py" startline="153" endline="164" pcid="8902"></source>
    def setUp(self):
        self.in_channels, self.out_channels = 3, 10
        in_channels = None if self.lazy_init else self.in_channels
        conv_init_args = {'ksize': 3, 'stride': 1, 'pad': 1}
        self.layer = self.link(
            in_channels, self.out_channels, **conv_init_args)
        self.x = numpy.random.normal(
            size=(5, self.in_channels, 4, 4)).astype(numpy.float32)
        self.hook = WeightStandardization()
        self.out_size = self.out_channels  # For compatibility


</clonepair13>

<clonepair13>
<source file="systems/chainer-7.8.1/tests/chainer_tests/link_hooks_tests/test_spectral_normalization.py" startline="365" endline="376" pcid="8930"></source>
    def setUp(self):
        self.in_channels, self.out_channels = 3, 10
        in_channels = None if self.lazy_init else self.in_channels
        conv_init_args = {'ksize': 3, 'stride': 1, 'pad': 1}
        self.layer = self.link(
            in_channels, self.out_channels, **conv_init_args)
        self.x = numpy.random.normal(
            size=(5, self.in_channels, 4, 4, 4)).astype(numpy.float32)
        self.hook = SpectralNormalization(use_gamma=self.use_gamma)
        self.out_size = self.out_channels  # For compatibility


</clonepair13>
<clonepair14>
<source file="systems/chainer-7.8.1/tests/chainer_tests/link_hooks_tests/test_weight_standardization.py" startline="171" endline="182" pcid="8903"></source>
    def setUp(self):
        self.in_channels, self.out_channels = 3, 10
        in_channels = None if self.lazy_init else self.in_channels
        conv_init_args = {'ksize': 3, 'stride': 1, 'pad': 1}
        self.layer = self.link(
            in_channels, self.out_channels, **conv_init_args)
        self.x = numpy.random.normal(
            size=(5, self.in_channels, 4, 4, 4)).astype(numpy.float32)
        self.hook = WeightStandardization()
        self.out_size = self.out_channels  # For compatibility


</clonepair14>

<clonepair14>
<source file="systems/chainer-7.8.1/tests/chainer_tests/link_hooks_tests/test_spectral_normalization.py" startline="345" endline="356" pcid="8929"></source>
    def setUp(self):
        self.in_channels, self.out_channels = 3, 10
        in_channels = None if self.lazy_init else self.in_channels
        conv_init_args = {'ksize': 3, 'stride': 1, 'pad': 1}
        self.layer = self.link(
            in_channels, self.out_channels, **conv_init_args)
        self.x = numpy.random.normal(
            size=(5, self.in_channels, 4, 4)).astype(numpy.float32)
        self.hook = SpectralNormalization(use_gamma=self.use_gamma)
        self.out_size = self.out_channels  # For compatibility


</clonepair14>
<clonepair15>
<source file="systems/chainer-7.8.1/tests/chainer_tests/link_hooks_tests/test_weight_standardization.py" startline="153" endline="164" pcid="8902"></source>
    def setUp(self):
        self.in_channels, self.out_channels = 3, 10
        in_channels = None if self.lazy_init else self.in_channels
        conv_init_args = {'ksize': 3, 'stride': 1, 'pad': 1}
        self.layer = self.link(
            in_channels, self.out_channels, **conv_init_args)
        self.x = numpy.random.normal(
            size=(5, self.in_channels, 4, 4)).astype(numpy.float32)
        self.hook = WeightStandardization()
        self.out_size = self.out_channels  # For compatibility


</clonepair15>

<clonepair15>
<source file="systems/chainer-7.8.1/tests/chainer_tests/link_hooks_tests/test_spectral_normalization.py" startline="345" endline="356" pcid="8929"></source>
    def setUp(self):
        self.in_channels, self.out_channels = 3, 10
        in_channels = None if self.lazy_init else self.in_channels
        conv_init_args = {'ksize': 3, 'stride': 1, 'pad': 1}
        self.layer = self.link(
            in_channels, self.out_channels, **conv_init_args)
        self.x = numpy.random.normal(
            size=(5, self.in_channels, 4, 4)).astype(numpy.float32)
        self.hook = SpectralNormalization(use_gamma=self.use_gamma)
        self.out_size = self.out_channels  # For compatibility


</clonepair15>
